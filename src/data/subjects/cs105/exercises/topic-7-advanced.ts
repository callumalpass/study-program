import { CodingExercise } from '../../../../core/types';

export const topic7Exercises: CodingExercise[] = [
  {
    id: 'cs105-t7-ex01',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Bitwise Basics',
    difficulty: 1,
    description: 'Practice basic bitwise AND, OR, XOR operations.',
    starterCode: '#include <stdio.h>\n\nint main() {\n    unsigned int a = 12;  // 1100 in binary\n    unsigned int b = 10;  // 1010 in binary\n    \n    // Calculate and print:\n    // a AND b\n    // a OR b\n    // a XOR b\n    // NOT a (lower 4 bits only)\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\nint main() {\n    unsigned int a = 12;  // 1100\n    unsigned int b = 10;  // 1010\n    \n    printf("a & b = %u\\n", a & b);   // 8  (1000)\n    printf("a | b = %u\\n", a | b);   // 14 (1110)\n    printf("a ^ b = %u\\n", a ^ b);   // 6  (0110)\n    printf("~a (4 bits) = %u\\n", (~a) & 0xF);  // 3 (0011)\n    \n    return 0;\n}',
    testCases: [],
    hints: ['& is AND, | is OR, ^ is XOR, ~ is NOT', 'Mask with 0xF to keep only 4 bits'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex02',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Bit Shifting',
    difficulty: 2,
    description: 'Use left and right shift operators.',
    starterCode: '#include <stdio.h>\n\nint main() {\n    unsigned int x = 1;\n    \n    // Print x shifted left by 0, 1, 2, 3, 4 positions\n    // Print 16 shifted right by 0, 1, 2, 3, 4 positions\n    // Show relationship to multiplication/division by 2\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\nint main() {\n    unsigned int x = 1;\n    \n    printf("Left shifts (multiply by 2):\\n");\n    for (int i = 0; i <= 4; i++) {\n        printf("1 << %d = %u\\n", i, x << i);\n    }\n    \n    printf("\\nRight shifts (divide by 2):\\n");\n    unsigned int y = 16;\n    for (int i = 0; i <= 4; i++) {\n        printf("16 >> %d = %u\\n", i, y >> i);\n    }\n    \n    // Demonstrate: left shift = multiply by 2^n\n    printf("\\n5 * 8 = 5 << 3 = %u\\n", 5 << 3);\n    \n    return 0;\n}',
    testCases: [],
    hints: ['<< shifts left, >> shifts right', 'Left shift by n = multiply by 2^n'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex03',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Set, Clear, Toggle Bits',
    difficulty: 2,
    description: 'Implement functions to manipulate individual bits.',
    starterCode: '#include <stdio.h>\n\n// Set bit n to 1\nunsigned int set_bit(unsigned int value, int n) {\n    // Your code\n}\n\n// Clear bit n to 0\nunsigned int clear_bit(unsigned int value, int n) {\n    // Your code\n}\n\n// Toggle bit n\nunsigned int toggle_bit(unsigned int value, int n) {\n    // Your code\n}\n\n// Check if bit n is set\nint is_bit_set(unsigned int value, int n) {\n    // Your code\n}\n\nint main() {\n    unsigned int x = 0;\n    x = set_bit(x, 0);    // Set bit 0\n    x = set_bit(x, 2);    // Set bit 2\n    printf("After setting bits 0,2: %u\\n", x);  // 5\n    \n    x = clear_bit(x, 0);  // Clear bit 0\n    printf("After clearing bit 0: %u\\n", x);    // 4\n    \n    x = toggle_bit(x, 3); // Toggle bit 3\n    printf("After toggling bit 3: %u\\n", x);    // 12\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\nunsigned int set_bit(unsigned int value, int n) {\n    return value | (1U << n);\n}\n\nunsigned int clear_bit(unsigned int value, int n) {\n    return value & ~(1U << n);\n}\n\nunsigned int toggle_bit(unsigned int value, int n) {\n    return value ^ (1U << n);\n}\n\nint is_bit_set(unsigned int value, int n) {\n    return (value & (1U << n)) != 0;\n}\n\nint main() {\n    unsigned int x = 0;\n    x = set_bit(x, 0);\n    x = set_bit(x, 2);\n    printf("After setting bits 0,2: %u\\n", x);  // 5\n    \n    x = clear_bit(x, 0);\n    printf("After clearing bit 0: %u\\n", x);    // 4\n    \n    x = toggle_bit(x, 3);\n    printf("After toggling bit 3: %u\\n", x);    // 12\n    \n    printf("\\nBit 2 is %s\\n", is_bit_set(x, 2) ? "set" : "not set");\n    printf("Bit 0 is %s\\n", is_bit_set(x, 0) ? "set" : "not set");\n    \n    return 0;\n}',
    testCases: [],
    hints: ['Set: OR with mask', 'Clear: AND with inverted mask', 'Toggle: XOR with mask'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex04',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Count Set Bits',
    difficulty: 3,
    description: 'Implement a function to count the number of 1 bits (popcount).',
    starterCode: '#include <stdio.h>\n\n// Count number of 1 bits in value\nint count_bits(unsigned int value) {\n    // Your code - try multiple approaches\n}\n\nint main() {\n    printf("count_bits(0) = %d\\n", count_bits(0));       // 0\n    printf("count_bits(1) = %d\\n", count_bits(1));       // 1\n    printf("count_bits(7) = %d\\n", count_bits(7));       // 3\n    printf("count_bits(255) = %d\\n", count_bits(255));   // 8\n    printf("count_bits(0xFFFFFFFF) = %d\\n", count_bits(0xFFFFFFFF)); // 32\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\n// Method 1: Simple loop\nint count_bits_v1(unsigned int value) {\n    int count = 0;\n    while (value) {\n        count += value & 1;\n        value >>= 1;\n    }\n    return count;\n}\n\n// Method 2: Brian Kernighan\'s algorithm\n// Each iteration clears the lowest set bit\nint count_bits(unsigned int value) {\n    int count = 0;\n    while (value) {\n        value &= (value - 1);  // Clear lowest set bit\n        count++;\n    }\n    return count;\n}\n\n// Method 3: Lookup table (fastest for many calls)\nstatic const int bit_count[256] = {\n    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,  // 0-15\n    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,  // 16-31\n    // ... (full table would have 256 entries)\n};\n\nint main() {\n    printf("count_bits(0) = %d\\n", count_bits(0));\n    printf("count_bits(1) = %d\\n", count_bits(1));\n    printf("count_bits(7) = %d\\n", count_bits(7));\n    printf("count_bits(255) = %d\\n", count_bits(255));\n    printf("count_bits(0xFFFFFFFF) = %d\\n", count_bits(0xFFFFFFFF));\n    \n    return 0;\n}',
    testCases: [],
    hints: ['x & (x-1) clears the lowest set bit', 'Kernighan method: loop count = bit count'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex05',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Bit Fields',
    difficulty: 3,
    description: 'Use bit fields in a structure for compact data storage.',
    starterCode: '#include <stdio.h>\n\n// Define a structure for a date using bit fields:\n// - day: 5 bits (1-31)\n// - month: 4 bits (1-12)\n// - year: 12 bits (0-4095, store as offset from 1900)\n\ntypedef struct {\n    // Your bit field definitions\n} PackedDate;\n\nvoid print_date(PackedDate d) {\n    // Print in YYYY-MM-DD format\n}\n\nint main() {\n    printf("Size of PackedDate: %zu bytes\\n", sizeof(PackedDate));\n    \n    PackedDate today;\n    // Set to 2024-06-15\n    \n    print_date(today);\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\ntypedef struct {\n    unsigned int day   : 5;   // 1-31\n    unsigned int month : 4;   // 1-12\n    unsigned int year  : 12;  // Offset from 1900\n} PackedDate;\n\nvoid print_date(PackedDate d) {\n    printf("%04d-%02d-%02d\\n", d.year + 1900, d.month, d.day);\n}\n\nPackedDate make_date(int year, int month, int day) {\n    PackedDate d;\n    d.year = year - 1900;\n    d.month = month;\n    d.day = day;\n    return d;\n}\n\nint main() {\n    printf("Size of PackedDate: %zu bytes\\n", sizeof(PackedDate));\n    // Usually 4 bytes (vs 12 for 3 ints)\n    \n    PackedDate today = make_date(2024, 6, 15);\n    print_date(today);  // 2024-06-15\n    \n    // Direct assignment\n    PackedDate other;\n    other.day = 25;\n    other.month = 12;\n    other.year = 2023 - 1900;\n    print_date(other);  // 2023-12-25\n    \n    return 0;\n}',
    testCases: [],
    hints: ['unsigned int field : bits;', 'Total bits can fit in fewer bytes'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex06',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Union Basics',
    difficulty: 2,
    description: 'Demonstrate union memory sharing.',
    starterCode: '#include <stdio.h>\n\n// Define a union that can hold:\n// - an int (i)\n// - a float (f)\n// - a char array of 4 (c)\n\nunion Data {\n    // Your members\n};\n\nint main() {\n    union Data d;\n    \n    // Show that all members share memory:\n    printf("Size of union: %zu\\n", sizeof(d));\n    printf("Address of d.i: %p\\n", (void*)&d.i);\n    printf("Address of d.f: %p\\n", (void*)&d.f);\n    printf("Address of d.c: %p\\n", (void*)&d.c);\n    \n    // Demonstrate memory sharing\n    d.i = 0x41424344;\n    printf("\\nd.i = 0x%X\\n", d.i);\n    printf("d.c = %c%c%c%c\\n", d.c[0], d.c[1], d.c[2], d.c[3]);\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c[4];\n};\n\nint main() {\n    union Data d;\n    \n    printf("Size of union: %zu\\n", sizeof(d));  // 4\n    printf("Address of d.i: %p\\n", (void*)&d.i);\n    printf("Address of d.f: %p\\n", (void*)&d.f);\n    printf("Address of d.c: %p\\n", (void*)&d.c);\n    // All addresses are the same!\n    \n    // Demonstrate memory sharing\n    d.i = 0x41424344;  // ASCII: DCBA (little-endian)\n    printf("\\nd.i = 0x%X\\n", d.i);\n    printf("d.c = %c%c%c%c\\n", d.c[0], d.c[1], d.c[2], d.c[3]);\n    // On little-endian: DCBA\n    \n    // Float representation\n    d.f = 3.14f;\n    printf("\\nFloat 3.14 as int: 0x%X\\n", d.i);\n    \n    return 0;\n}',
    testCases: [],
    hints: ['All union members share same memory location', 'Size of union = size of largest member'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex07',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Tagged Union',
    difficulty: 3,
    description: 'Implement a tagged union for a variant type.',
    starterCode: '#include <stdio.h>\n#include <string.h>\n\n// Define an enum for value types\ntypedef enum {\n    TYPE_INT,\n    TYPE_FLOAT,\n    TYPE_STRING\n} ValueType;\n\n// Define a tagged union that can hold int, float, or string\ntypedef struct {\n    ValueType type;\n    union {\n        // Your union members\n    } data;\n} Value;\n\nvoid print_value(Value v) {\n    // Print based on type\n}\n\nint main() {\n    Value v1, v2, v3;\n    \n    // Create int value\n    v1.type = TYPE_INT;\n    v1.data.i = 42;\n    \n    // Create float value\n    // ...\n    \n    // Create string value\n    // ...\n    \n    print_value(v1);\n    print_value(v2);\n    print_value(v3);\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n#include <string.h>\n\ntypedef enum {\n    TYPE_INT,\n    TYPE_FLOAT,\n    TYPE_STRING\n} ValueType;\n\ntypedef struct {\n    ValueType type;\n    union {\n        int i;\n        float f;\n        char s[32];\n    } data;\n} Value;\n\nValue make_int(int i) {\n    Value v;\n    v.type = TYPE_INT;\n    v.data.i = i;\n    return v;\n}\n\nValue make_float(float f) {\n    Value v;\n    v.type = TYPE_FLOAT;\n    v.data.f = f;\n    return v;\n}\n\nValue make_string(const char* s) {\n    Value v;\n    v.type = TYPE_STRING;\n    strncpy(v.data.s, s, 31);\n    v.data.s[31] = \'\\0\';\n    return v;\n}\n\nvoid print_value(Value v) {\n    switch (v.type) {\n        case TYPE_INT:\n            printf("Int: %d\\n", v.data.i);\n            break;\n        case TYPE_FLOAT:\n            printf("Float: %.2f\\n", v.data.f);\n            break;\n        case TYPE_STRING:\n            printf("String: %s\\n", v.data.s);\n            break;\n    }\n}\n\nint main() {\n    Value v1 = make_int(42);\n    Value v2 = make_float(3.14f);\n    Value v3 = make_string("Hello");\n    \n    print_value(v1);\n    print_value(v2);\n    print_value(v3);\n    \n    return 0;\n}',
    testCases: [],
    hints: ['Enum tracks which member is active', 'Switch on type to access correct member'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex08',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Enum with Values',
    difficulty: 2,
    description: 'Define enums with explicit values and use in switch.',
    starterCode: '#include <stdio.h>\n\n// Define HTTP status code enum with values:\n// OK = 200, CREATED = 201, BAD_REQUEST = 400,\n// UNAUTHORIZED = 401, NOT_FOUND = 404, SERVER_ERROR = 500\n\ntypedef enum {\n    // Your enum values\n} HttpStatus;\n\nconst char* status_message(HttpStatus status) {\n    // Return appropriate message for each status\n}\n\nint main() {\n    HttpStatus codes[] = {OK, CREATED, NOT_FOUND, SERVER_ERROR};\n    int n = sizeof(codes) / sizeof(codes[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf("%d: %s\\n", codes[i], status_message(codes[i]));\n    }\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\ntypedef enum {\n    OK = 200,\n    CREATED = 201,\n    BAD_REQUEST = 400,\n    UNAUTHORIZED = 401,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n} HttpStatus;\n\nconst char* status_message(HttpStatus status) {\n    switch (status) {\n        case OK: return "OK";\n        case CREATED: return "Created";\n        case BAD_REQUEST: return "Bad Request";\n        case UNAUTHORIZED: return "Unauthorized";\n        case NOT_FOUND: return "Not Found";\n        case SERVER_ERROR: return "Internal Server Error";\n        default: return "Unknown";\n    }\n}\n\nint main() {\n    HttpStatus codes[] = {OK, CREATED, NOT_FOUND, SERVER_ERROR};\n    int n = sizeof(codes) / sizeof(codes[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf("%d: %s\\n", codes[i], status_message(codes[i]));\n    }\n    \n    return 0;\n}',
    testCases: [],
    hints: ['NAME = value assigns explicit value', 'Default: always handle in switch'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex09',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Volatile Keyword',
    difficulty: 3,
    description: 'Demonstrate the need for volatile in hardware/signal contexts.',
    starterCode: '#include <stdio.h>\n#include <signal.h>\n\n// This flag MUST be volatile - explain why\nvolatile int running = 1;\n\nvoid signal_handler(int sig) {\n    running = 0;\n}\n\nint main() {\n    // Set up SIGINT handler\n    signal(SIGINT, signal_handler);\n    \n    printf("Press Ctrl+C to stop...\\n");\n    \n    // Busy wait loop\n    while (running) {\n        // Do nothing\n    }\n    \n    printf("Stopped!\\n");\n    return 0;\n}\n\n/* WRITTEN PART:\n * Explain:\n * 1. What would happen if \'running\' was not volatile?\n * 2. When else is volatile needed?\n * 3. Does volatile make access thread-safe?\n */',
    solution: '#include <stdio.h>\n#include <signal.h>\n\nvolatile sig_atomic_t running = 1;\n\nvoid signal_handler(int sig) {\n    (void)sig;  // Suppress unused warning\n    running = 0;\n}\n\nint main() {\n    signal(SIGINT, signal_handler);\n    \n    printf("Press Ctrl+C to stop...\\n");\n    \n    while (running) {\n        // Without volatile, compiler might optimize to:\n        // if (running) while(1) {}\n    }\n    \n    printf("Stopped!\\n");\n    return 0;\n}\n\n/* ANSWERS:\n *\n * 1. Without volatile:\n *    The compiler may optimize the loop to:\n *      if (running) while(1) {}\n *    because it doesn\'t see \'running\' change in the loop.\n *    The program would never exit even after Ctrl+C.\n *\n * 2. volatile is needed for:\n *    - Signal handlers (as shown)\n *    - Memory-mapped I/O registers\n *    - Variables modified by interrupts\n *    - Variables shared with DMA\n *    - Polling hardware status registers\n *\n * 3. volatile is NOT thread-safe:\n *    - It only prevents compiler optimizations\n *    - Does NOT provide atomicity\n *    - Does NOT provide memory ordering\n *    - For threads, use _Atomic or mutexes\n *    - sig_atomic_t is atomic for signals only\n */',
    testCases: [],
    hints: ['volatile prevents compiler from caching variable', 'sig_atomic_t for signal-safe integer'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex10',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Variadic Function',
    difficulty: 3,
    description: 'Implement a variadic function that sums any number of integers.',
    starterCode: '#include <stdio.h>\n#include <stdarg.h>\n\n// Sum n integers passed as arguments\nint sum(int count, ...) {\n    // Use va_list, va_start, va_arg, va_end\n}\n\nint main() {\n    printf("sum(3, 1, 2, 3) = %d\\n", sum(3, 1, 2, 3));  // 6\n    printf("sum(5, 10, 20, 30, 40, 50) = %d\\n", \n           sum(5, 10, 20, 30, 40, 50));  // 150\n    printf("sum(0) = %d\\n", sum(0));  // 0\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n#include <stdarg.h>\n\nint sum(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    \n    int total = 0;\n    for (int i = 0; i < count; i++) {\n        total += va_arg(args, int);\n    }\n    \n    va_end(args);\n    return total;\n}\n\n// Alternative: sentinel-based (like printf)\ndouble avg_sentinel(double first, ...) {\n    if (first < 0) return 0;  // Sentinel\n    \n    va_list args;\n    va_start(args, first);\n    \n    double sum = first;\n    int count = 1;\n    double val;\n    \n    while ((val = va_arg(args, double)) >= 0) {\n        sum += val;\n        count++;\n    }\n    \n    va_end(args);\n    return sum / count;\n}\n\nint main() {\n    printf("sum(3, 1, 2, 3) = %d\\n", sum(3, 1, 2, 3));\n    printf("sum(5, 10, 20, 30, 40, 50) = %d\\n", \n           sum(5, 10, 20, 30, 40, 50));\n    printf("sum(0) = %d\\n", sum(0));\n    \n    // Sentinel example\n    printf("avg = %.1f\\n", avg_sentinel(1.0, 2.0, 3.0, -1.0));\n    \n    return 0;\n}',
    testCases: [],
    hints: ['va_start initializes, va_arg gets next, va_end cleans up', 'Need way to know how many args (count or sentinel)'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex11',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Mini Printf',
    difficulty: 4,
    description: 'Implement a simplified printf supporting %d, %s, %c.',
    starterCode: '#include <stdio.h>\n#include <stdarg.h>\n\n// Implement mini_printf supporting:\n// %d - integer\n// %s - string\n// %c - character\n// %% - literal %\n\nvoid mini_printf(const char* format, ...) {\n    // Your implementation\n}\n\nint main() {\n    mini_printf("Hello, %s!\\n", "World");\n    mini_printf("Number: %d\\n", 42);\n    mini_printf("Char: %c, Int: %d, Str: %s\\n", \'A\', 100, "test");\n    mini_printf("100%% complete\\n");\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_int(int n) {\n    if (n < 0) {\n        putchar(\'-\');\n        n = -n;\n    }\n    if (n >= 10) {\n        print_int(n / 10);\n    }\n    putchar(\'0\' + n % 10);\n}\n\nvoid mini_printf(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    while (*format) {\n        if (*format == \'%\') {\n            format++;\n            switch (*format) {\n                case \'d\': {\n                    int val = va_arg(args, int);\n                    print_int(val);\n                    break;\n                }\n                case \'s\': {\n                    char* str = va_arg(args, char*);\n                    while (*str) {\n                        putchar(*str++);\n                    }\n                    break;\n                }\n                case \'c\': {\n                    // char is promoted to int\n                    int c = va_arg(args, int);\n                    putchar(c);\n                    break;\n                }\n                case \'%\':\n                    putchar(\'%\');\n                    break;\n                default:\n                    putchar(\'%\');\n                    putchar(*format);\n            }\n        } else {\n            putchar(*format);\n        }\n        format++;\n    }\n    \n    va_end(args);\n}\n\nint main() {\n    mini_printf("Hello, %s!\\n", "World");\n    mini_printf("Number: %d\\n", 42);\n    mini_printf("Char: %c, Int: %d, Str: %s\\n", \'A\', 100, "test");\n    mini_printf("100%% complete\\n");\n    \n    return 0;\n}',
    testCases: [],
    hints: ['char is promoted to int in variadic', 'Handle %% for literal percent'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex12',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Type Punning (Written)',
    difficulty: 3,
    description: 'This is a written exercise. Explain type punning techniques.',
    starterCode: '/* WRITTEN EXERCISE - Type Punning */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/*\n * Analyze these type punning techniques.\n * Explain which are valid C and why.\n */\n\nvoid method1_union() {\n    union { float f; uint32_t i; } u;\n    u.f = 3.14f;\n    printf("Float bits: 0x%08X\\n", u.i);\n}\n\nvoid method2_pointer() {\n    float f = 3.14f;\n    uint32_t i = *(uint32_t*)&f;  // Is this valid?\n    printf("Float bits: 0x%08X\\n", i);\n}\n\nvoid method3_memcpy() {\n    float f = 3.14f;\n    uint32_t i;\n    memcpy(&i, &f, sizeof(i));\n    printf("Float bits: 0x%08X\\n", i);\n}\n\n/* Questions:\n * 1. Which methods are valid C? Which are UB?\n * 2. What is the "strict aliasing rule"?\n * 3. Why does method 3 (memcpy) work?\n * 4. Show how to detect endianness using unions.\n */',
    solution: '/* ANSWERS */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/*\n * 1. Validity:\n *\n *    Method 1 (union): VALID in C99 and later.\n *    Type punning through unions is explicitly allowed.\n *\n *    Method 2 (pointer cast): UNDEFINED BEHAVIOR!\n *    Violates strict aliasing rule.\n *\n *    Method 3 (memcpy): VALID and portable.\n *    memcpy just copies bytes, no aliasing issues.\n *\n * 2. Strict Aliasing Rule:\n *    An object shall only be accessed through:\n *    - Its actual type\n *    - A signed/unsigned version of its type\n *    - A character type (char, unsigned char)\n *    \n *    float and uint32_t are not compatible, so\n *    *(uint32_t*)&float_var is UB.\n *\n * 3. Why memcpy works:\n *    memcpy treats both source and dest as arrays\n *    of unsigned char, which is allowed to alias\n *    any type. It copies raw bytes without type\n *    interpretation.\n *\n * 4. Endianness detection:\n */\n\nint is_little_endian(void) {\n    union {\n        uint32_t i;\n        uint8_t c[4];\n    } u = { .i = 0x01020304 };\n    \n    // Little-endian: 04 03 02 01 (LSB first)\n    // Big-endian:    01 02 03 04 (MSB first)\n    return u.c[0] == 0x04;\n}\n\n// Safe type punning helper\nstatic inline uint32_t float_to_bits(float f) {\n    uint32_t result;\n    memcpy(&result, &f, sizeof(result));\n    return result;\n}\n\nint main() {\n    float f = 3.14f;\n    printf("Float bits: 0x%08X\\n", float_to_bits(f));\n    printf("Endianness: %s\\n", \n           is_little_endian() ? "Little" : "Big");\n    return 0;\n}\n\n/*\n * Additional note on -fno-strict-aliasing:\n * GCC flag that disables strict aliasing optimizations.\n * Makes pointer casts "work" but not portable.\n * Linux kernel uses this flag.\n */',
    testCases: [],
    hints: ['Strict aliasing applies to pointer access', 'memcpy with char* is always safe'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex13',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Restrict Keyword',
    difficulty: 3,
    description: 'Demonstrate the restrict qualifier for optimization.',
    starterCode: '#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Without restrict - compiler must be conservative\nvoid add_arrays(int* a, int* b, int* c, int n) {\n    for (int i = 0; i < n; i++) {\n        c[i] = a[i] + b[i];\n    }\n}\n\n// With restrict - compiler can optimize\nvoid add_arrays_fast(int* restrict a, \n                     int* restrict b, \n                     int* restrict c, int n) {\n    for (int i = 0; i < n; i++) {\n        c[i] = a[i] + b[i];\n    }\n}\n\n/* WRITTEN PART:\n * 1. Why can the restrict version be faster?\n * 2. What promise does restrict make?\n * 3. What happens if you violate that promise?\n * 4. Where is restrict commonly used?\n */\n\nint main() {\n    // Test both versions\n    return 0;\n}',
    solution: '#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Without restrict\nvoid add_arrays(int* a, int* b, int* c, int n) {\n    for (int i = 0; i < n; i++) {\n        // Compiler must reload a[i] and b[i] each iteration\n        // because c might alias a or b\n        c[i] = a[i] + b[i];\n    }\n}\n\n// With restrict\nvoid add_arrays_fast(int* restrict a, \n                     int* restrict b, \n                     int* restrict c, int n) {\n    for (int i = 0; i < n; i++) {\n        // Compiler knows c doesn\'t alias a or b\n        // Can vectorize, reorder, keep values in registers\n        c[i] = a[i] + b[i];\n    }\n}\n\n/* ANSWERS:\n *\n * 1. Why faster:\n *    Without restrict, writing to c[i] might change a[i] or b[i]\n *    (if they overlap). Compiler must reload values each iteration.\n *    With restrict, compiler knows no aliasing occurs, so it can:\n *    - Keep values in registers\n *    - Use SIMD/vector instructions\n *    - Reorder memory operations\n *\n * 2. Promise of restrict:\n *    The pointer is the only way to access that object\n *    during its scope. No other pointer will access the\n *    same memory during the lifetime of the restrict pointer.\n *\n * 3. Violating the promise:\n *    UNDEFINED BEHAVIOR. The optimization assumptions are\n *    wrong, leading to incorrect results. Example:\n *    int x = 5;\n *    int* restrict p = &x;\n *    int* q = &x;\n *    *q = 10;  // UB! q aliases p\n *\n * 4. Common uses:\n *    - memcpy (dest and src must not overlap)\n *    - BLAS/LAPACK math libraries\n *    - Image processing (separate input/output buffers)\n *    - Any function with separate in/out pointers\n */\n\nint main() {\n    int a[1000], b[1000], c[1000];\n    \n    for (int i = 0; i < 1000; i++) {\n        a[i] = i;\n        b[i] = i * 2;\n    }\n    \n    add_arrays_fast(a, b, c, 1000);\n    \n    printf("c[500] = %d\\n", c[500]);  // 1500\n    \n    return 0;\n}',
    testCases: [],
    hints: ['restrict promises no aliasing', 'Violation is undefined behavior'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex14',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Inline Functions',
    difficulty: 2,
    description: 'Compare inline functions to macros.',
    starterCode: '#include <stdio.h>\n\n// Macro version\n#define SQUARE_MACRO(x) ((x) * (x))\n\n// Inline function version\nstatic inline int square_inline(int x) {\n    return x * x;\n}\n\n/* Compare macro vs inline:\n * 1. Type safety\n * 2. Side effects\n * 3. Debugging\n * 4. Scope\n */\n\nint main() {\n    int a = 5;\n    \n    // Show problem with macro and side effects\n    printf("SQUARE_MACRO(a++) = %d\\n", SQUARE_MACRO(a++));\n    printf("a is now %d\\n", a);  // What value?\n    \n    a = 5;\n    printf("square_inline(a++) = %d\\n", square_inline(a++));\n    printf("a is now %d\\n", a);  // What value?\n    \n    return 0;\n}',
    solution: '#include <stdio.h>\n\n#define SQUARE_MACRO(x) ((x) * (x))\n\nstatic inline int square_inline(int x) {\n    return x * x;\n}\n\n/* Comparison:\n *\n * 1. Type Safety:\n *    Macro: None - just text substitution\n *    Inline: Full type checking\n *\n * 2. Side Effects:\n *    Macro: Arguments evaluated multiple times!\n *           SQUARE_MACRO(a++) = (a++) * (a++)\n *           a is incremented TWICE\n *    Inline: Arguments evaluated once\n *\n * 3. Debugging:\n *    Macro: Harder - code is substituted\n *    Inline: Easier - real function with name\n *\n * 4. Scope:\n *    Macro: Global from definition point\n *    Inline: Normal C scoping rules\n */\n\nint main() {\n    int a = 5;\n    \n    // Macro evaluates a++ TWICE\n    printf("SQUARE_MACRO(a++) = %d\\n", SQUARE_MACRO(a++));\n    // Expands to: (a++) * (a++) = 5 * 6 = 30\n    printf("a is now %d\\n", a);  // 7 (incremented twice)\n    \n    a = 5;\n    // Inline evaluates a++ ONCE\n    printf("square_inline(a++) = %d\\n", square_inline(a++));\n    // Evaluates to: square_inline(5), then a = 6\n    // Returns: 25\n    printf("a is now %d\\n", a);  // 6 (incremented once)\n    \n    return 0;\n}\n\n/* When to use which:\n *\n * Use inline functions when:\n * - Type safety matters\n * - Arguments might have side effects\n * - Need debuggable code\n * - C99 or later\n *\n * Use macros when:\n * - Need type-generic behavior (pre-C11)\n * - Token pasting or stringification needed\n * - Compile-time constants required\n */',
    testCases: [],
    hints: ['Macro args evaluated each time used', 'Inline is type-safe function'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex15',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Compound Literals (Written)',
    difficulty: 3,
    description: 'This is a written exercise. Explain and use compound literals.',
    starterCode: '/* WRITTEN EXERCISE - Compound Literals (C99) */\n\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nvoid print_point(Point p) {\n    printf("(%d, %d)\\n", p.x, p.y);\n}\n\nvoid print_array(int* arr, int n) {\n    for (int i = 0; i < n; i++) {\n        printf("%d ", arr[i]);\n    }\n    printf("\\n");\n}\n\n/* Explain compound literals and show examples:\n *\n * 1. What is a compound literal?\n *\n * 2. Show how to use with:\n *    - Struct initialization\n *    - Array initialization\n *    - Function arguments\n *\n * 3. What is the storage duration of a compound literal?\n *\n * 4. Can compound literals be modified?\n *\n * Write example code using compound literals:\n */\n\nint main() {\n    // Your examples here\n    return 0;\n}',
    solution: '/* ANSWERS */\n\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nvoid print_point(Point p) {\n    printf("(%d, %d)\\n", p.x, p.y);\n}\n\nvoid print_array(int* arr, int n) {\n    for (int i = 0; i < n; i++) {\n        printf("%d ", arr[i]);\n    }\n    printf("\\n");\n}\n\n/*\n * 1. Compound Literal:\n *    A way to create unnamed objects of a specified type.\n *    Syntax: (type){ initializer-list }\n *    Provides an lvalue, so you can take its address.\n *\n * 2. Examples below in main()\n *\n * 3. Storage Duration:\n *    - Block scope: automatic (like local variables)\n *    - File scope: static\n *    Within a block, lifetime is until end of block.\n *\n * 4. Modification:\n *    Yes, compound literals are modifiable lvalues\n *    (unless the type includes const).\n */\n\nint main() {\n    // Example 1: Struct as function argument\n    print_point((Point){3, 4});\n    \n    // Example 2: Array as function argument\n    print_array((int[]){1, 2, 3, 4, 5}, 5);\n    \n    // Example 3: Pointer to compound literal\n    int* p = (int[]){10, 20, 30};\n    printf("p[1] = %d\\n", p[1]);\n    \n    // Example 4: Modifiable\n    Point* pt = &(Point){0, 0};\n    pt->x = 100;  // OK to modify\n    print_point(*pt);\n    \n    // Example 5: Const compound literal\n    const int* cp = (const int[]){1, 2, 3};\n    // cp[0] = 10;  // Error: const\n    \n    // Example 6: Nested initialization\n    struct { Point p; int z; } point3d = \n        {.p = (Point){1, 2}, .z = 3};\n    printf("3D: (%d, %d, %d)\\n", \n           point3d.p.x, point3d.p.y, point3d.z);\n    \n    // WARNING: Don\'t return pointer to local compound literal!\n    // int* bad(void) { return (int[]){1,2,3}; }  // UB!\n    \n    return 0;\n}',
    testCases: [],
    hints: ['(type){...} creates unnamed object', 'Lifetime is block scope (automatic storage)'],
    language: 'c'
  },
  {
    id: 'cs105-t7-ex16',
    subjectId: 'cs105',
    topicId: 'cs105-topic-7',
    title: 'Generic Selection (Written)',
    difficulty: 4,
    description: 'This is a written exercise. Explore C11 _Generic for type-generic code.',
    starterCode: '/* WRITTEN EXERCISE - C11 _Generic */\n\n#include <stdio.h>\n#include <math.h>\n\n/*\n * C11 introduced _Generic for compile-time type selection.\n * This enables type-generic macros similar to C++ overloading.\n *\n * Syntax:\n * _Generic(expr, \n *     type1: result1,\n *     type2: result2,\n *     default: default_result)\n *\n * Tasks:\n *\n * 1. Create a TYPE_NAME(x) macro that returns the type as a string\n *\n * 2. Create a PRINT(x) macro that works for int, double, and char*\n *\n * 3. Create an ABS(x) macro for int, float, and double\n *\n * 4. Explain limitations of _Generic\n */',
    solution: '/* SOLUTIONS */\n\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n/* Task 1: Type name */\n#define TYPE_NAME(x) _Generic((x), \\\n    int: "int", \\\n    long: "long", \\\n    float: "float", \\\n    double: "double", \\\n    char*: "string", \\\n    const char*: "string", \\\n    default: "unknown")\n\n/* Task 2: Generic print */\nstatic inline void print_int(int x) { printf("%d\\n", x); }\nstatic inline void print_double(double x) { printf("%f\\n", x); }\nstatic inline void print_string(const char* x) { printf("%s\\n", x); }\n\n#define PRINT(x) _Generic((x), \\\n    int: print_int, \\\n    double: print_double, \\\n    float: print_double, \\\n    char*: print_string, \\\n    const char*: print_string)(x)\n\n/* Task 3: Generic absolute value */\nstatic inline int abs_int(int x) { return abs(x); }\nstatic inline float abs_float(float x) { return fabsf(x); }\nstatic inline double abs_double(double x) { return fabs(x); }\n\n#define ABS(x) _Generic((x), \\\n    int: abs_int, \\\n    float: abs_float, \\\n    double: abs_double)(x)\n\nint main() {\n    // Test TYPE_NAME\n    int i = 5;\n    double d = 3.14;\n    char* s = "hello";\n    \n    printf("Type of i: %s\\n", TYPE_NAME(i));\n    printf("Type of d: %s\\n", TYPE_NAME(d));\n    printf("Type of s: %s\\n", TYPE_NAME(s));\n    \n    // Test PRINT\n    PRINT(42);\n    PRINT(3.14159);\n    PRINT("Hello, World!");\n    \n    // Test ABS\n    printf("ABS(-5) = %d\\n", ABS(-5));\n    printf("ABS(-3.14f) = %f\\n", ABS(-3.14f));\n    printf("ABS(-2.71) = %f\\n", ABS(-2.71));\n    \n    return 0;\n}\n\n/*\n * Task 4: Limitations of _Generic\n *\n * 1. Compile-time only:\n *    Cannot dispatch on runtime type information.\n *    The type must be known at compile time.\n *\n * 2. No implicit conversions:\n *    Each type needs explicit handling.\n *    int and long are different, even though compatible.\n *\n * 3. No user-defined types:\n *    Must list every struct type individually.\n *    Cannot match "all structs" or "all pointers".\n *\n * 4. Expression-based:\n *    Selection is based on expression\'s type.\n *    Can\'t do pattern matching or decomposition.\n *\n * 5. Verbose:\n *    Need helper functions for each type.\n *    Much more boilerplate than C++ templates.\n *\n * 6. No recursion:\n *    Can\'t define recursive generic operations easily.\n *\n * 7. Pointer qualification:\n *    const char* and char* are different types.\n *    Must handle both or use default.\n */',
    testCases: [],
    hints: ['_Generic selects at compile time', 'Need separate case for each type'],
    language: 'c'
  }
];

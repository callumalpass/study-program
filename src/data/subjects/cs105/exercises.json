[
  {
    "id": "cs105-exercise-1",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Hello World and Basic Input",
    "difficulty": 1,
    "description": "Write a C program that asks for the user's name and age, then prints a greeting message.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    // Your code here\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use printf() to display prompts",
      "Use scanf() to read input",
      "Use %s for strings and %d for integers"
    ],
    "solution": "#include <stdio.h>\n\nint main() {\n    char name[50];\n    int age;\n    \n    printf(\"Enter your name: \");\n    scanf(\"%s\", name);\n    \n    printf(\"Enter your age: \");\n    scanf(\"%d\", &age);\n    \n    printf(\"Hello %s, you are %d years old!\", name, age);\n    \n    return 0;\n}",
    "language": "c"
  },
  {
    "id": "cs105-t1-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Temperature Converter",
    "difficulty": 1,
    "description": "Write a program that converts Celsius to Fahrenheit. Formula: F = C * 9/5 + 32",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    \n    // Read Celsius and convert to Fahrenheit\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    \n    printf(\"Enter temperature in Celsius: \");\n    scanf(\"%f\", &celsius);\n    \n    fahrenheit = celsius * 9.0 / 5.0 + 32;\n    \n    printf(\"%.1f C = %.1f F\", celsius, fahrenheit);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use float for decimal precision",
      "Use 9.0/5.0 to avoid integer division"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Simple Calculator",
    "difficulty": 2,
    "description": "Write a calculator that takes two numbers and an operator (+, -, *, /) and performs the operation.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    float a, b, result;\n    char op;\n    \n    // Your code here\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    float a, b, result;\n    char op;\n    \n    printf(\"Enter expression (e.g., 5 + 3): \");\n    scanf(\"%f %c %f\", &a, &op, &b);\n    \n    switch(op) {\n        case '+': result = a + b; break;\n        case '-': result = a - b; break;\n        case '*': result = a * b; break;\n        case '/': result = a / b; break;\n        default: printf(\"Invalid operator\"); return 1;\n    }\n    \n    printf(\"Result: %.2f\", result);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use switch statement for different operators",
      "Read operator as char"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "FizzBuzz in C",
    "difficulty": 2,
    "description": "Print numbers 1-20. For multiples of 3 print \"Fizz\", for 5 print \"Buzz\", for both print \"FizzBuzz\".",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    // Print 1 to 20 with FizzBuzz rules\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    for (int i = 1; i <= 20; i++) {\n        if (i % 15 == 0) printf(\"FizzBuzz\\n\");\n        else if (i % 3 == 0) printf(\"Fizz\\n\");\n        else if (i % 5 == 0) printf(\"Buzz\\n\");\n        else printf(\"%d\\n\", i);\n    }\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use modulo operator %",
      "Check divisibility by 15 first"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Prime Number Checker",
    "difficulty": 3,
    "description": "Write a function that checks if a number is prime and use it in main().",
    "starterCode": "#include <stdio.h>\n\nint isPrime(int n) {\n    // Return 1 if prime, 0 otherwise\n}\n\nint main() {\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n    \n    if (isPrime(num))\n        printf(\"%d is prime\", num);\n    else\n        printf(\"%d is not prime\", num);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint isPrime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    \n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n    \n    if (isPrime(num))\n        printf(\"%d is prime\", num);\n    else\n        printf(\"%d is not prime\", num);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Only need to check up to sqrt(n)",
      "Handle edge cases: 0, 1, 2"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Array Sum and Average",
    "difficulty": 2,
    "description": "Write a program that reads 5 integers into an array, then calculates and prints their sum and average.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int sum = 0;\n    float avg;\n    \n    // Read 5 numbers, calculate sum and average\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int sum = 0;\n    float avg;\n    \n    printf(\"Enter 5 numbers:\\n\");\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &arr[i]);\n        sum += arr[i];\n    }\n    \n    avg = (float)sum / 5;\n    printf(\"Sum: %d\\n\", sum);\n    printf(\"Average: %.2f\", avg);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Cast sum to float before dividing for accurate average",
      "Use a loop to read and sum"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Factorial Function",
    "difficulty": 2,
    "description": "Write a recursive function to calculate factorial of a number.",
    "starterCode": "#include <stdio.h>\n\nlong factorial(int n) {\n    // Recursive implementation\n}\n\nint main() {\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n    printf(\"%d! = %ld\", num, factorial(num));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nlong factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n    printf(\"%d! = %ld\", num, factorial(num));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Base case: 0! = 1! = 1",
      "Recursive: n! = n * (n-1)!"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "String Reversal",
    "difficulty": 3,
    "description": "Write a function that reverses a string in-place.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char *str) {\n    // Reverse str in-place\n}\n\nint main() {\n    char str[100];\n    printf(\"Enter a string: \");\n    scanf(\"%s\", str);\n    reverseString(str);\n    printf(\"Reversed: %s\", str);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\nvoid reverseString(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = temp;\n    }\n}\n\nint main() {\n    char str[100];\n    printf(\"Enter a string: \");\n    scanf(\"%s\", str);\n    reverseString(str);\n    printf(\"Reversed: %s\", str);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Swap first and last, second and second-last, etc.",
      "Use strlen() to get length"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Type Casting and Division",
    "difficulty": 2,
    "description": "Write a program that demonstrates the difference between integer division and floating-point division. Given two integers, show both results.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int a = 7, b = 3;\n    \n    // Print integer division result\n    // Print floating-point division result (use casting)\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int a = 7, b = 3;\n    \n    printf(\"Integer division: %d / %d = %d\\n\", a, b, a / b);\n    printf(\"Float division: %d / %d = %.2f\", a, b, (float)a / b);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Integer division truncates",
      "Cast one operand to float for decimal result"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Bitwise Operations",
    "difficulty": 3,
    "description": "Write a program that demonstrates bitwise AND, OR, XOR, and left shift operations on two numbers.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int a = 5, b = 3;  // 5 = 101, 3 = 011 in binary\n    \n    // Print results of AND, OR, XOR, and left shift a by 2\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int a = 5, b = 3;\n    \n    printf(\"a & b = %d\\n\", a & b);   // AND: 1\n    printf(\"a | b = %d\\n\", a | b);   // OR: 7\n    printf(\"a ^ b = %d\\n\", a ^ b);   // XOR: 6\n    printf(\"a << 2 = %d\", a << 2);   // Left shift: 20\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "& is AND, | is OR, ^ is XOR",
      "<< shifts bits left (multiplies by 2^n)"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Grade Calculator",
    "difficulty": 2,
    "description": "Write a program that converts a numerical score (0-100) to a letter grade using nested if-else statements.",
    "starterCode": "#include <stdio.h>\n\nchar getGrade(int score) {\n    // Return A (90+), B (80+), C (70+), D (60+), F otherwise\n}\n\nint main() {\n    int score;\n    printf(\"Enter score: \");\n    scanf(\"%d\", &score);\n    printf(\"Grade: %c\", getGrade(score));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nchar getGrade(int score) {\n    if (score >= 90) return 'A';\n    else if (score >= 80) return 'B';\n    else if (score >= 70) return 'C';\n    else if (score >= 60) return 'D';\n    else return 'F';\n}\n\nint main() {\n    int score;\n    printf(\"Enter score: \");\n    scanf(\"%d\", &score);\n    printf(\"Grade: %c\", getGrade(score));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use else-if chain from highest to lowest",
      "Return char type for grade letter"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Number Pyramid",
    "difficulty": 3,
    "description": "Print a number pyramid of height 5 using nested loops.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    // Print:\n    //     1\n    //    121\n    //   12321\n    //  1234321\n    // 123454321\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int n = 5;\n    for (int i = 1; i <= n; i++) {\n        // Print leading spaces\n        for (int j = 1; j <= n - i; j++) {\n            printf(\" \");\n        }\n        // Print increasing numbers\n        for (int j = 1; j <= i; j++) {\n            printf(\"%d\", j);\n        }\n        // Print decreasing numbers\n        for (int j = i - 1; j >= 1; j--) {\n            printf(\"%d\", j);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use three inner loops: spaces, ascending numbers, descending numbers",
      "Row i has i numbers going up and i-1 going down"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Fibonacci Sequence",
    "difficulty": 2,
    "description": "Print the first 10 Fibonacci numbers using a loop (not recursion).",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    // Print first 10 Fibonacci numbers: 0 1 1 2 3 5 8 13 21 34\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int a = 0, b = 1, next;\n    \n    printf(\"%d %d \", a, b);\n    \n    for (int i = 2; i < 10; i++) {\n        next = a + b;\n        printf(\"%d \", next);\n        a = b;\n        b = next;\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Each number is sum of previous two",
      "Use two variables to track previous values"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Binary Search",
    "difficulty": 4,
    "description": "Implement binary search to find a target value in a sorted array.",
    "starterCode": "#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    // Return index if found, -1 otherwise\n}\n\nint main() {\n    int arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int target = 23;\n    \n    int result = binarySearch(arr, 10, target);\n    if (result != -1)\n        printf(\"Found at index %d\", result);\n    else\n        printf(\"Not found\");\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0, right = size - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int target = 23;\n    \n    int result = binarySearch(arr, 10, target);\n    if (result != -1)\n        printf(\"Found at index %d\", result);\n    else\n        printf(\"Not found\");\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Compare target with middle element",
      "Narrow search range based on comparison",
      "Use left + (right - left) / 2 to avoid overflow"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Palindrome Check",
    "difficulty": 3,
    "description": "Write a function to check if a string is a palindrome (reads same forwards and backwards).",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    // Return 1 if palindrome, 0 otherwise\n}\n\nint main() {\n    char test1[] = \"radar\";\n    char test2[] = \"hello\";\n    \n    printf(\"%s: %s\\n\", test1, isPalindrome(test1) ? \"palindrome\" : \"not palindrome\");\n    printf(\"%s: %s\", test2, isPalindrome(test2) ? \"palindrome\" : \"not palindrome\");\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i])\n            return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char test1[] = \"radar\";\n    char test2[] = \"hello\";\n    \n    printf(\"%s: %s\\n\", test1, isPalindrome(test1) ? \"palindrome\" : \"not palindrome\");\n    printf(\"%s: %s\", test2, isPalindrome(test2) ? \"palindrome\" : \"not palindrome\");\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Compare first with last, second with second-to-last",
      "Only need to check half the string"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t1-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-1",
    "title": "Character Frequency Counter",
    "difficulty": 3,
    "description": "Count the frequency of each character in a string and print non-zero counts.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"hello world\";\n    int freq[256] = {0};  // ASCII character counts\n    \n    // Count frequencies\n    // Print characters that appear more than once\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"hello world\";\n    int freq[256] = {0};\n    \n    for (int i = 0; str[i] != '\\0'; i++) {\n        freq[(int)str[i]]++;\n    }\n    \n    printf(\"Characters with frequency > 1:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (freq[i] > 1) {\n            printf(\"'%c': %d\\n\", i, freq[i]);\n        }\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use character ASCII value as array index",
      "Initialize array to zeros"
    ],
    "language": "c"
  },
  {
    "id": "cs105-exercise-2",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Swap Two Numbers Using Pointers",
    "difficulty": 2,
    "description": "Implement a function that swaps two integers using pointers.",
    "starterCode": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    // Your code here\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Before: x=%d, y=%d\\n\", x, y);\n    swap(&x, &y);\n    printf(\"After: x=%d, y=%d\\n\", x, y);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use a temporary variable to hold one value",
      "Dereference pointers with * to access values",
      "Remember to modify the values that the pointers point to"
    ],
    "solution": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"Before: x=%d, y=%d\\n\", x, y);\n    swap(&x, &y);\n    printf(\"After: x=%d, y=%d\\n\", x, y);\n    return 0;\n}",
    "language": "c"
  },
  {
    "id": "cs105-t2-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Pointer Basics",
    "difficulty": 1,
    "description": "Create a pointer to an integer, assign a value through it, and print both the value and address.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int num = 42;\n    int *ptr;\n    \n    // Make ptr point to num, print value and address\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int num = 42;\n    int *ptr;\n    \n    ptr = &num;\n    \n    printf(\"Value: %d\\n\", *ptr);\n    printf(\"Address: %p\", (void*)ptr);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use & to get address",
      "Use * to dereference",
      "Use %p for pointer addresses"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Array with Pointers",
    "difficulty": 2,
    "description": "Print array elements using pointer arithmetic instead of array indexing.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n    \n    // Print all elements using pointer arithmetic\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", *(ptr + i));\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "*(ptr + i) is equivalent to ptr[i]",
      "Array name is a pointer to first element"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Return Multiple Values",
    "difficulty": 2,
    "description": "Write a function that calculates both the sum and product of two numbers using pointer parameters.",
    "starterCode": "#include <stdio.h>\n\nvoid calculate(int a, int b, int *sum, int *product) {\n    // Set sum and product through pointers\n}\n\nint main() {\n    int s, p;\n    calculate(5, 3, &s, &p);\n    printf(\"Sum: %d, Product: %d\", s, p);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nvoid calculate(int a, int b, int *sum, int *product) {\n    *sum = a + b;\n    *product = a * b;\n}\n\nint main() {\n    int s, p;\n    calculate(5, 3, &s, &p);\n    printf(\"Sum: %d, Product: %d\", s, p);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use *sum = value to set through pointer",
      "Pointers allow returning multiple values"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Find Min and Max",
    "difficulty": 3,
    "description": "Write a function that finds both minimum and maximum values in an array using pointers.",
    "starterCode": "#include <stdio.h>\n\nvoid findMinMax(int *arr, int size, int *min, int *max) {\n    // Find min and max, set through pointers\n}\n\nint main() {\n    int arr[] = {5, 2, 9, 1, 7};\n    int min, max;\n    findMinMax(arr, 5, &min, &max);\n    printf(\"Min: %d, Max: %d\", min, max);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nvoid findMinMax(int *arr, int size, int *min, int *max) {\n    *min = *max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] < *min) *min = arr[i];\n        if (arr[i] > *max) *max = arr[i];\n    }\n}\n\nint main() {\n    int arr[] = {5, 2, 9, 1, 7};\n    int min, max;\n    findMinMax(arr, 5, &min, &max);\n    printf(\"Min: %d, Max: %d\", min, max);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Initialize min and max to first element",
      "Compare each element with current min/max"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "String Length with Pointer",
    "difficulty": 2,
    "description": "Implement strlen using pointer arithmetic (don't use the standard library function).",
    "starterCode": "#include <stdio.h>\n\nint myStrlen(char *str) {\n    // Count characters using pointer\n}\n\nint main() {\n    char text[] = \"Hello\";\n    printf(\"Length: %d\", myStrlen(text));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint myStrlen(char *str) {\n    int len = 0;\n    while (*str != '\\0') {\n        len++;\n        str++;\n    }\n    return len;\n}\n\nint main() {\n    char text[] = \"Hello\";\n    printf(\"Length: %d\", myStrlen(text));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Strings end with null terminator '\\0'",
      "Increment pointer until null is found"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Double Pointer",
    "difficulty": 4,
    "description": "Use a double pointer to modify where a pointer points to.",
    "starterCode": "#include <stdio.h>\n\nvoid redirect(int **pp, int *newTarget) {\n    // Make *pp point to newTarget\n}\n\nint main() {\n    int a = 10, b = 20;\n    int *ptr = &a;\n    \n    printf(\"Before: %d\\n\", *ptr);\n    redirect(&ptr, &b);\n    printf(\"After: %d\", *ptr);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nvoid redirect(int **pp, int *newTarget) {\n    *pp = newTarget;\n}\n\nint main() {\n    int a = 10, b = 20;\n    int *ptr = &a;\n    \n    printf(\"Before: %d\\n\", *ptr);\n    redirect(&ptr, &b);\n    printf(\"After: %d\", *ptr);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "**pp is a pointer to a pointer",
      "*pp accesses the pointer itself"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Function Pointer",
    "difficulty": 5,
    "description": "Use function pointers to create a simple calculator that calls the right operation.",
    "starterCode": "#include <stdio.h>\n\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a * b; }\n\nint main() {\n    int (*operation)(int, int);\n    \n    // Set operation to add, call it, print result\n    // Then set to mul, call it, print result\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a * b; }\n\nint main() {\n    int (*operation)(int, int);\n    \n    operation = add;\n    printf(\"5 + 3 = %d\\n\", operation(5, 3));\n    \n    operation = mul;\n    printf(\"5 * 3 = %d\", operation(5, 3));\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Function pointer syntax: returnType (*name)(params)",
      "Assign function name without parentheses"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Pointer Comparison",
    "difficulty": 2,
    "description": "Use pointer comparison to find which element in an array a pointer is pointing to.",
    "starterCode": "#include <stdio.h>\n\nint findIndex(int *arr, int size, int *ptr) {\n    // Return index of element that ptr points to\n    // Return -1 if ptr is outside array\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *p = &arr[3];\n    \n    printf(\"Index: %d\", findIndex(arr, 5, p));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint findIndex(int *arr, int size, int *ptr) {\n    if (ptr < arr || ptr >= arr + size)\n        return -1;\n    return ptr - arr;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *p = &arr[3];\n    \n    printf(\"Index: %d\", findIndex(arr, 5, p));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Pointer subtraction gives element count",
      "Compare pointers to check bounds"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Const Pointers",
    "difficulty": 2,
    "description": "Demonstrate the difference between pointer to const and const pointer.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int a = 10, b = 20;\n    \n    const int *ptr1 = &a;    // Pointer to const int\n    int * const ptr2 = &a;   // Const pointer to int\n    \n    // Try to modify through ptr1 - won't compile\n    // *ptr1 = 15;  // Error!\n    \n    // Can change what ptr1 points to\n    ptr1 = &b;\n    printf(\"ptr1 points to: %d\\n\", *ptr1);\n    \n    // Can modify through ptr2\n    *ptr2 = 15;\n    printf(\"a is now: %d\\n\", a);\n    \n    // Cannot change what ptr2 points to\n    // ptr2 = &b;  // Error!\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int a = 10, b = 20;\n    \n    const int *ptr1 = &a;    // Pointer to const int\n    int * const ptr2 = &a;   // Const pointer to int\n    \n    // ptr1 points to const: can't modify value, can change pointer\n    ptr1 = &b;\n    printf(\"ptr1 points to: %d\\n\", *ptr1);\n    \n    // ptr2 is const: can modify value, can't change pointer\n    *ptr2 = 15;\n    printf(\"a is now: %d\\n\", a);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "const int *p: value is const",
      "int * const p: pointer is const"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "String Copy with Pointers",
    "difficulty": 3,
    "description": "Implement strcpy using pointer arithmetic.",
    "starterCode": "#include <stdio.h>\n\nvoid myStrcpy(char *dest, const char *src) {\n    // Copy src to dest using pointers\n}\n\nint main() {\n    char src[] = \"Hello World\";\n    char dest[20];\n    \n    myStrcpy(dest, src);\n    printf(\"Copied: %s\", dest);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nvoid myStrcpy(char *dest, const char *src) {\n    while (*src != '\\0') {\n        *dest = *src;\n        dest++;\n        src++;\n    }\n    *dest = '\\0';\n}\n\nint main() {\n    char src[] = \"Hello World\";\n    char dest[20];\n    \n    myStrcpy(dest, src);\n    printf(\"Copied: %s\", dest);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Copy until null terminator",
      "Don't forget to add null at end"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Array of Pointers",
    "difficulty": 3,
    "description": "Create an array of pointers to strings and print them.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    // Create array of pointers to string literals\n    char *days[] = {\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"};\n    \n    // Print all days using the pointer array\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    char *days[] = {\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"};\n    int n = sizeof(days) / sizeof(days[0]);\n    \n    printf(\"Days of the work week:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d: %s\\n\", i + 1, days[i]);\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Each element is a pointer to char",
      "String literals are stored as const char arrays"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Callback Function",
    "difficulty": 4,
    "description": "Implement a forEach function that applies a callback to each array element.",
    "starterCode": "#include <stdio.h>\n\nvoid forEach(int *arr, int size, void (*callback)(int)) {\n    // Call callback for each element\n}\n\nvoid printSquare(int n) {\n    printf(\"%d \", n * n);\n}\n\nvoid printDouble(int n) {\n    printf(\"%d \", n * 2);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    \n    printf(\"Squares: \");\n    forEach(arr, 5, printSquare);\n    printf(\"\\nDoubles: \");\n    forEach(arr, 5, printDouble);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nvoid forEach(int *arr, int size, void (*callback)(int)) {\n    for (int i = 0; i < size; i++) {\n        callback(arr[i]);\n    }\n}\n\nvoid printSquare(int n) {\n    printf(\"%d \", n * n);\n}\n\nvoid printDouble(int n) {\n    printf(\"%d \", n * 2);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    \n    printf(\"Squares: \");\n    forEach(arr, 5, printSquare);\n    printf(\"\\nDoubles: \");\n    forEach(arr, 5, printDouble);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Function pointer parameter syntax: void (*name)(int)",
      "Call callback like a regular function"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Pointer to Array",
    "difficulty": 4,
    "description": "Demonstrate the difference between pointer to array and array of pointers.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    int arr[3] = {10, 20, 30};\n    \n    // Pointer to array of 3 ints\n    int (*ptr)[3] = &arr;\n    \n    // Print array elements using the pointer to array\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    int arr[3] = {10, 20, 30};\n    \n    int (*ptr)[3] = &arr;\n    \n    // Access using (*ptr)[i] or (*ptr) + i\n    for (int i = 0; i < 3; i++) {\n        printf(\"Element %d: %d\\n\", i, (*ptr)[i]);\n    }\n    \n    // Or using pointer arithmetic\n    printf(\"Using pointer: %d %d %d\", *(*ptr), *(*ptr + 1), *(*ptr + 2));\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "int (*p)[3] points to entire array",
      "*p gives the array, (*p)[i] gives element"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Generic Swap with void*",
    "difficulty": 5,
    "description": "Implement a generic swap function using void pointers that can swap any data type.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\nvoid genericSwap(void *a, void *b, size_t size) {\n    // Swap size bytes between a and b\n}\n\nint main() {\n    int x = 5, y = 10;\n    double d1 = 3.14, d2 = 2.71;\n    \n    printf(\"Before: x=%d, y=%d\\n\", x, y);\n    genericSwap(&x, &y, sizeof(int));\n    printf(\"After: x=%d, y=%d\\n\", x, y);\n    \n    printf(\"Before: d1=%.2f, d2=%.2f\\n\", d1, d2);\n    genericSwap(&d1, &d2, sizeof(double));\n    printf(\"After: d1=%.2f, d2=%.2f\", d1, d2);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\nvoid genericSwap(void *a, void *b, size_t size) {\n    char temp[size];\n    memcpy(temp, a, size);\n    memcpy(a, b, size);\n    memcpy(b, temp, size);\n}\n\nint main() {\n    int x = 5, y = 10;\n    double d1 = 3.14, d2 = 2.71;\n    \n    printf(\"Before: x=%d, y=%d\\n\", x, y);\n    genericSwap(&x, &y, sizeof(int));\n    printf(\"After: x=%d, y=%d\\n\", x, y);\n    \n    printf(\"Before: d1=%.2f, d2=%.2f\\n\", d1, d2);\n    genericSwap(&d1, &d2, sizeof(double));\n    printf(\"After: d1=%.2f, d2=%.2f\", d1, d2);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use memcpy to copy arbitrary bytes",
      "void* can point to any type"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t2-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-2",
    "title": "Allocate and Return Array",
    "difficulty": 4,
    "description": "Write a function that creates a dynamic array and returns it via a double pointer parameter.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray(int **arr, int size) {\n    // Allocate array of given size\n    // Fill with values 1 to size\n}\n\nint main() {\n    int *arr = NULL;\n    int size = 5;\n    \n    createArray(&arr, size);\n    \n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    free(arr);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid createArray(int **arr, int size) {\n    *arr = (int *)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        (*arr)[i] = i + 1;\n    }\n}\n\nint main() {\n    int *arr = NULL;\n    int size = 5;\n    \n    createArray(&arr, size);\n    \n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    free(arr);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "*arr = malloc(...) sets caller's pointer",
      "Use (*arr)[i] to access elements"
    ],
    "language": "c"
  },
  {
    "id": "cs105-exercise-3",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Dynamic Array Allocation",
    "difficulty": 2,
    "description": "Create a program that dynamically allocates an array, fills it with values, prints them, and frees the memory.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n = 5;\n    int *arr;\n    \n    // Allocate memory for n integers\n    \n    // Fill array with values 1 to n\n    \n    // Print array elements\n    \n    // Free memory\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use malloc(n * sizeof(int)) to allocate memory",
      "Use a for loop to fill and print the array",
      "Don't forget to call free() to prevent memory leaks"
    ],
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n = 5;\n    int *arr;\n    \n    arr = (int *)malloc(n * sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        arr[i] = i + 1;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    free(arr);\n    \n    return 0;\n}",
    "language": "c"
  },
  {
    "id": "cs105-t3-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "malloc vs calloc",
    "difficulty": 1,
    "description": "Demonstrate the difference between malloc and calloc by printing uninitialized values.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr1 = (int *)malloc(3 * sizeof(int));\n    int *arr2 = (int *)calloc(3, sizeof(int));\n    \n    // Print values from both arrays\n    // (malloc may have garbage, calloc should be 0)\n    \n    printf(\"calloc: %d %d %d\\n\", arr2[0], arr2[1], arr2[2]);\n    \n    free(arr1);\n    free(arr2);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr1 = (int *)malloc(3 * sizeof(int));\n    int *arr2 = (int *)calloc(3, sizeof(int));\n    \n    printf(\"calloc: %d %d %d\\n\", arr2[0], arr2[1], arr2[2]);\n    \n    free(arr1);\n    free(arr2);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "calloc initializes memory to zero",
      "malloc leaves memory uninitialized"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Dynamic String",
    "difficulty": 2,
    "description": "Dynamically allocate memory for a string, copy a value into it, and print it.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *str;\n    \n    // Allocate memory for \"Hello World\" (don't forget null terminator!)\n    // Copy the string\n    // Print it\n    // Free memory\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *str;\n    \n    str = (char *)malloc(12 * sizeof(char)); // 11 chars + null\n    strcpy(str, \"Hello World\");\n    printf(\"%s\", str);\n    free(str);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "String length + 1 for null terminator",
      "Use strcpy to copy strings"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Resize Array with realloc",
    "difficulty": 3,
    "description": "Create an array, fill it, then resize it using realloc to add more elements.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(3 * sizeof(int));\n    arr[0] = 1; arr[1] = 2; arr[2] = 3;\n    \n    // Resize to hold 5 elements\n    // Add values 4 and 5\n    // Print all 5 elements\n    // Free memory\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int *)malloc(3 * sizeof(int));\n    arr[0] = 1; arr[1] = 2; arr[2] = 3;\n    \n    arr = (int *)realloc(arr, 5 * sizeof(int));\n    arr[3] = 4;\n    arr[4] = 5;\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    free(arr);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "realloc preserves existing data",
      "Assign result back to pointer"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "2D Array Allocation",
    "difficulty": 4,
    "description": "Dynamically allocate a 3x3 matrix, fill it with values, print it, and properly free all memory.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows = 3, cols = 3;\n    int **matrix;\n    \n    // Allocate rows\n    // Allocate each column\n    // Fill with values 1-9\n    // Print matrix\n    // Free all memory (columns first, then rows)\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int rows = 3, cols = 3;\n    int **matrix;\n    int val = 1;\n    \n    matrix = (int **)malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        matrix[i] = (int *)malloc(cols * sizeof(int));\n    }\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = val++;\n        }\n    }\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    for (int i = 0; i < rows; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Allocate array of pointers first",
      "Then allocate each row",
      "Free in reverse order"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Check Allocation Success",
    "difficulty": 2,
    "description": "Write a safe allocation function that checks if malloc succeeded.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nint *safeAlloc(int n) {\n    // Allocate n integers\n    // Check if NULL, print error and exit if so\n    // Return pointer\n}\n\nint main() {\n    int *arr = safeAlloc(5);\n    printf(\"Allocated successfully!\\n\");\n    free(arr);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint *safeAlloc(int n) {\n    int *ptr = (int *)malloc(n * sizeof(int));\n    if (ptr == NULL) {\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n\nint main() {\n    int *arr = safeAlloc(5);\n    printf(\"Allocated successfully!\\n\");\n    free(arr);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "malloc returns NULL on failure",
      "Use exit() to terminate program"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Memory Copy Function",
    "difficulty": 3,
    "description": "Implement a simple memcpy function that copies n bytes from source to destination.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid myMemcpy(void *dest, void *src, int n) {\n    // Copy n bytes from src to dest\n}\n\nint main() {\n    int src[] = {1, 2, 3, 4, 5};\n    int *dest = (int *)malloc(5 * sizeof(int));\n    \n    myMemcpy(dest, src, 5 * sizeof(int));\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dest[i]);\n    }\n    \n    free(dest);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid myMemcpy(void *dest, void *src, int n) {\n    char *d = (char *)dest;\n    char *s = (char *)src;\n    for (int i = 0; i < n; i++) {\n        d[i] = s[i];\n    }\n}\n\nint main() {\n    int src[] = {1, 2, 3, 4, 5};\n    int *dest = (int *)malloc(5 * sizeof(int));\n    \n    myMemcpy(dest, src, 5 * sizeof(int));\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dest[i]);\n    }\n    \n    free(dest);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Cast to char* to copy byte by byte",
      "void* can point to any type"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Dynamic Stack Implementation",
    "difficulty": 5,
    "description": "Implement a stack using dynamic memory with push, pop, and isEmpty operations.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int top;\n    int capacity;\n} Stack;\n\nStack *createStack(int capacity) {\n    // Allocate stack and internal array\n}\n\nvoid push(Stack *s, int value) {\n    // Add element to top\n}\n\nint pop(Stack *s) {\n    // Remove and return top element\n}\n\nvoid freeStack(Stack *s) {\n    // Free all memory\n}\n\nint main() {\n    Stack *s = createStack(10);\n    push(s, 1); push(s, 2); push(s, 3);\n    printf(\"%d \", pop(s));\n    printf(\"%d \", pop(s));\n    printf(\"%d\", pop(s));\n    freeStack(s);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int top;\n    int capacity;\n} Stack;\n\nStack *createStack(int capacity) {\n    Stack *s = (Stack *)malloc(sizeof(Stack));\n    s->data = (int *)malloc(capacity * sizeof(int));\n    s->top = -1;\n    s->capacity = capacity;\n    return s;\n}\n\nvoid push(Stack *s, int value) {\n    if (s->top < s->capacity - 1) {\n        s->data[++s->top] = value;\n    }\n}\n\nint pop(Stack *s) {\n    if (s->top >= 0) {\n        return s->data[s->top--];\n    }\n    return -1;\n}\n\nvoid freeStack(Stack *s) {\n    free(s->data);\n    free(s);\n}\n\nint main() {\n    Stack *s = createStack(10);\n    push(s, 1); push(s, 2); push(s, 3);\n    printf(\"%d \", pop(s));\n    printf(\"%d \", pop(s));\n    printf(\"%d\", pop(s));\n    freeStack(s);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Allocate struct and data array separately",
      "top = -1 means empty stack",
      "Free data before struct"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Dynamic Queue Implementation",
    "difficulty": 4,
    "description": "Implement a circular queue using dynamic memory allocation.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int front;\n    int rear;\n    int capacity;\n    int count;\n} Queue;\n\nQueue *createQueue(int capacity) {\n    // Allocate queue and array\n}\n\nvoid enqueue(Queue *q, int value) {\n    // Add to rear\n}\n\nint dequeue(Queue *q) {\n    // Remove from front\n}\n\nvoid freeQueue(Queue *q) {\n    // Free all memory\n}\n\nint main() {\n    Queue *q = createQueue(5);\n    enqueue(q, 1); enqueue(q, 2); enqueue(q, 3);\n    printf(\"%d \", dequeue(q));\n    printf(\"%d \", dequeue(q));\n    enqueue(q, 4);\n    printf(\"%d \", dequeue(q));\n    printf(\"%d\", dequeue(q));\n    freeQueue(q);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int front;\n    int rear;\n    int capacity;\n    int count;\n} Queue;\n\nQueue *createQueue(int capacity) {\n    Queue *q = (Queue *)malloc(sizeof(Queue));\n    q->data = (int *)malloc(capacity * sizeof(int));\n    q->front = 0;\n    q->rear = -1;\n    q->capacity = capacity;\n    q->count = 0;\n    return q;\n}\n\nvoid enqueue(Queue *q, int value) {\n    if (q->count < q->capacity) {\n        q->rear = (q->rear + 1) % q->capacity;\n        q->data[q->rear] = value;\n        q->count++;\n    }\n}\n\nint dequeue(Queue *q) {\n    if (q->count > 0) {\n        int value = q->data[q->front];\n        q->front = (q->front + 1) % q->capacity;\n        q->count--;\n        return value;\n    }\n    return -1;\n}\n\nvoid freeQueue(Queue *q) {\n    free(q->data);\n    free(q);\n}\n\nint main() {\n    Queue *q = createQueue(5);\n    enqueue(q, 1); enqueue(q, 2); enqueue(q, 3);\n    printf(\"%d \", dequeue(q));\n    printf(\"%d \", dequeue(q));\n    enqueue(q, 4);\n    printf(\"%d \", dequeue(q));\n    printf(\"%d\", dequeue(q));\n    freeQueue(q);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use modulo for circular behavior",
      "Track count separately from front/rear"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Memory Set Function",
    "difficulty": 2,
    "description": "Implement a simple memset function that sets n bytes to a specific value.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid myMemset(void *ptr, int value, int n) {\n    // Set n bytes starting at ptr to value\n}\n\nint main() {\n    int *arr = (int *)malloc(5 * sizeof(int));\n    \n    myMemset(arr, 0, 5 * sizeof(int));\n    \n    printf(\"After memset: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    free(arr);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid myMemset(void *ptr, int value, int n) {\n    unsigned char *p = (unsigned char *)ptr;\n    for (int i = 0; i < n; i++) {\n        p[i] = (unsigned char)value;\n    }\n}\n\nint main() {\n    int *arr = (int *)malloc(5 * sizeof(int));\n    \n    myMemset(arr, 0, 5 * sizeof(int));\n    \n    printf(\"After memset: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    free(arr);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Cast to unsigned char* to set byte by byte",
      "Value is truncated to one byte"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Growing Array",
    "difficulty": 3,
    "description": "Implement a dynamic array that grows automatically when capacity is reached.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int size;\n    int capacity;\n} DynArray;\n\nDynArray *createArray() {\n    // Start with capacity 2\n}\n\nvoid append(DynArray *arr, int value) {\n    // Add value, grow if needed\n}\n\nvoid freeArray(DynArray *arr) {\n    free(arr->data);\n    free(arr);\n}\n\nint main() {\n    DynArray *arr = createArray();\n    for (int i = 1; i <= 10; i++) {\n        append(arr, i);\n        printf(\"Size: %d, Cap: %d\\n\", arr->size, arr->capacity);\n    }\n    freeArray(arr);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *data;\n    int size;\n    int capacity;\n} DynArray;\n\nDynArray *createArray() {\n    DynArray *arr = (DynArray *)malloc(sizeof(DynArray));\n    arr->data = (int *)malloc(2 * sizeof(int));\n    arr->size = 0;\n    arr->capacity = 2;\n    return arr;\n}\n\nvoid append(DynArray *arr, int value) {\n    if (arr->size == arr->capacity) {\n        arr->capacity *= 2;\n        arr->data = (int *)realloc(arr->data, arr->capacity * sizeof(int));\n    }\n    arr->data[arr->size++] = value;\n}\n\nvoid freeArray(DynArray *arr) {\n    free(arr->data);\n    free(arr);\n}\n\nint main() {\n    DynArray *arr = createArray();\n    for (int i = 1; i <= 10; i++) {\n        append(arr, i);\n        printf(\"Size: %d, Cap: %d\\n\", arr->size, arr->capacity);\n    }\n    freeArray(arr);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Double capacity when full",
      "Use realloc to grow array"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Identify Memory Errors (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Identify all memory errors in the code below and explain what could go wrong.",
    "starterCode": "/* WRITTEN EXERCISE - Read the code and identify all errors */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid processData() {\n    int *arr = malloc(10 * sizeof(int));\n    arr[10] = 5;  // Error 1: ?\n    \n    int *ptr = malloc(sizeof(int));\n    *ptr = 42;\n    free(ptr);\n    printf(\"%d\\n\", *ptr);  // Error 2: ?\n    \n    int *data = malloc(100);\n    // forget to free(data)  // Error 3: ?\n}\n\nint main() {\n    int *p = malloc(sizeof(int));\n    free(p);\n    free(p);  // Error 4: ?\n    return 0;\n}\n\n/* Write your answers below:\n * Error 1:\n * Error 2:\n * Error 3:\n * Error 4:\n */",
    "solution": "/* ANSWERS:\n * \n * Error 1: Buffer Overflow / Out-of-bounds write\n *   arr has indices 0-9, but arr[10] writes past the end.\n *   This corrupts memory and causes undefined behavior.\n *\n * Error 2: Use After Free\n *   Reading *ptr after free(ptr) is undefined behavior.\n *   The memory may have been reused or contain garbage.\n *\n * Error 3: Memory Leak\n *   data is allocated but never freed.\n *   If processData() is called repeatedly, memory usage grows.\n *\n * Error 4: Double Free\n *   Freeing the same pointer twice corrupts the heap.\n *   Can cause crashes or security vulnerabilities.\n *\n * Tools like Valgrind can detect all these errors!\n */",
    "testCases": [],
    "hints": [
      "Look for: buffer overflow, use-after-free, memory leak, double free"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Valgrind Output Analysis (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Analyze the Valgrind output below and identify the bug.",
    "starterCode": "/* WRITTEN EXERCISE - Analyze this Valgrind output */\n\n/*\n$ valgrind ./myprogram\n\n==12345== Invalid read of size 4\n==12345==    at 0x401156: main (test.c:8)\n==12345==  Address 0x4a4a068 is 0 bytes after a block of size 40 alloc'd\n==12345==    at 0x4C2A0C3: malloc (vg_replace_malloc.c:309)\n==12345==    by 0x40113E: main (test.c:5)\n==12345==\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 40 bytes in 1 blocks\n==12345==   total heap usage: 1 allocs, 0 frees\n*/\n\n/* Questions:\n * 1. What type of error is reported?\n * 2. What line is the bug on?\n * 3. What size was allocated vs accessed?\n * 4. Is there a memory leak? How many bytes?\n *\n * Write your answers below:\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = malloc(10 * sizeof(int));  // line 5\n    // ... some code ...\n    int val = arr[10];  // line 8\n    printf(\"%d\\n\", val);\n    return 0;\n}",
    "solution": "/* ANSWERS:\n *\n * 1. Type of error: Invalid read (out-of-bounds array access)\n *    Specifically, reading past the end of allocated memory.\n *\n * 2. Bug location: Line 8 in test.c\n *    The error occurs at arr[10]\n *\n * 3. Size allocated vs accessed:\n *    Allocated: 40 bytes (10 ints * 4 bytes each)\n *    Accessed: \"0 bytes after\" means reading at index 10,\n *    which is just past the valid range (indices 0-9).\n *\n * 4. Memory leak: YES\n *    40 bytes leaked (1 alloc, 0 frees)\n *    The array was never freed.\n *\n * Fixed code should:\n *    - Access indices 0-9 only (not 10)\n *    - Call free(arr) before returning\n */",
    "testCases": [],
    "hints": [
      "Look at the line numbers in the Valgrind output",
      "Check the heap summary for leaks"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Stack vs Heap Memory (Written)",
    "difficulty": 2,
    "description": "This is a written exercise. Identify which variables are stored on the stack vs heap.",
    "starterCode": "/* WRITTEN EXERCISE - Identify stack vs heap storage */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint global = 100;  // Variable A\n\nvoid function() {\n    int local = 10;  // Variable B\n    static int stat = 20;  // Variable C\n    int *heap = malloc(sizeof(int));  // Variable D (the pointer)\n    *heap = 30;  // Variable E (the value 30)\n    \n    int arr[5];  // Variable F\n    int *arr2 = malloc(5 * sizeof(int));  // Variable G (values)\n    \n    free(heap);\n    free(arr2);\n}\n\n/* For each variable, identify:\n * - Where is it stored? (Stack, Heap, or Data segment)\n * - When is it allocated?\n * - When is it deallocated?\n *\n * Variable A (global):\n * Variable B (local):\n * Variable C (stat):\n * Variable D (heap pointer):\n * Variable E (*heap value):\n * Variable F (arr):\n * Variable G (arr2 values):\n */",
    "solution": "/* ANSWERS:\n *\n * Variable A (global):\n *   Storage: Data segment (global/static area)\n *   Allocated: Program start\n *   Deallocated: Program end\n *\n * Variable B (local):\n *   Storage: Stack\n *   Allocated: Function call\n *   Deallocated: Function return\n *\n * Variable C (stat):\n *   Storage: Data segment (like globals)\n *   Allocated: Program start\n *   Deallocated: Program end\n *   Note: Value persists between function calls!\n *\n * Variable D (heap pointer):\n *   Storage: Stack (it's a local variable)\n *   Allocated: Function call\n *   Deallocated: Function return\n *\n * Variable E (*heap value):\n *   Storage: Heap\n *   Allocated: malloc() call\n *   Deallocated: free() call\n *\n * Variable F (arr):\n *   Storage: Stack (array is on stack)\n *   Allocated: Function call\n *   Deallocated: Function return\n *\n * Variable G (arr2 values):\n *   Storage: Heap\n *   Allocated: malloc() call\n *   Deallocated: free() call\n */",
    "testCases": [],
    "hints": [
      "Local variables are on stack",
      "malloc returns heap memory",
      "Global and static are in data segment"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Memory Pool Allocator",
    "difficulty": 5,
    "description": "Implement a simple memory pool that pre-allocates a block and hands out fixed-size chunks.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\n#define POOL_SIZE 10\n#define BLOCK_SIZE sizeof(int)\n\ntypedef struct {\n    char *pool;\n    int used[POOL_SIZE];\n} MemoryPool;\n\nMemoryPool *createPool() {\n    // Allocate pool structure and memory block\n}\n\nvoid *poolAlloc(MemoryPool *mp) {\n    // Find free slot, mark used, return pointer\n}\n\nvoid poolFree(MemoryPool *mp, void *ptr) {\n    // Mark slot as free\n}\n\nvoid destroyPool(MemoryPool *mp) {\n    // Free all memory\n}\n\nint main() {\n    MemoryPool *mp = createPool();\n    \n    int *a = (int *)poolAlloc(mp);\n    int *b = (int *)poolAlloc(mp);\n    *a = 10; *b = 20;\n    \n    printf(\"a=%d, b=%d\\n\", *a, *b);\n    \n    poolFree(mp, a);\n    int *c = (int *)poolAlloc(mp);  // Reuses a's slot\n    *c = 30;\n    printf(\"c=%d\\n\", *c);\n    \n    destroyPool(mp);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\n#define POOL_SIZE 10\n#define BLOCK_SIZE sizeof(int)\n\ntypedef struct {\n    char *pool;\n    int used[POOL_SIZE];\n} MemoryPool;\n\nMemoryPool *createPool() {\n    MemoryPool *mp = (MemoryPool *)malloc(sizeof(MemoryPool));\n    mp->pool = (char *)malloc(POOL_SIZE * BLOCK_SIZE);\n    for (int i = 0; i < POOL_SIZE; i++) {\n        mp->used[i] = 0;\n    }\n    return mp;\n}\n\nvoid *poolAlloc(MemoryPool *mp) {\n    for (int i = 0; i < POOL_SIZE; i++) {\n        if (!mp->used[i]) {\n            mp->used[i] = 1;\n            return mp->pool + (i * BLOCK_SIZE);\n        }\n    }\n    return NULL;\n}\n\nvoid poolFree(MemoryPool *mp, void *ptr) {\n    int index = ((char *)ptr - mp->pool) / BLOCK_SIZE;\n    if (index >= 0 && index < POOL_SIZE) {\n        mp->used[index] = 0;\n    }\n}\n\nvoid destroyPool(MemoryPool *mp) {\n    free(mp->pool);\n    free(mp);\n}\n\nint main() {\n    MemoryPool *mp = createPool();\n    \n    int *a = (int *)poolAlloc(mp);\n    int *b = (int *)poolAlloc(mp);\n    *a = 10; *b = 20;\n    \n    printf(\"a=%d, b=%d\\n\", *a, *b);\n    \n    poolFree(mp, a);\n    int *c = (int *)poolAlloc(mp);\n    *c = 30;\n    printf(\"c=%d\\n\", *c);\n    \n    destroyPool(mp);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Track which slots are used with a boolean array",
      "Calculate slot index from pointer offset"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t3-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-3",
    "title": "Fix the Memory Bugs (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. The code has multiple memory bugs. Rewrite it correctly.",
    "starterCode": "/* WRITTEN EXERCISE - Fix all memory bugs in this code */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *createGreeting(const char *name) {\n    char buffer[100];\n    sprintf(buffer, \"Hello, %s!\", name);\n    return buffer;  // BUG 1: returning local array\n}\n\nvoid processNumbers() {\n    int *nums = malloc(5 * sizeof(int));\n    for (int i = 0; i <= 5; i++) {  // BUG 2: off-by-one\n        nums[i] = i * 10;\n    }\n    // BUG 3: no free(nums)\n}\n\nint main() {\n    char *msg = createGreeting(\"World\");\n    printf(\"%s\\n\", msg);  // Undefined behavior!\n    \n    int *ptr = NULL;\n    *ptr = 5;  // BUG 4: null pointer dereference\n    \n    processNumbers();\n    return 0;\n}\n\n/* Write the corrected code below: */",
    "solution": "/* CORRECTED CODE: */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *createGreeting(const char *name) {\n    // FIX 1: Allocate on heap, not stack\n    char *buffer = malloc(100);\n    if (buffer) {\n        sprintf(buffer, \"Hello, %s!\", name);\n    }\n    return buffer;\n}\n\nvoid processNumbers() {\n    int *nums = malloc(5 * sizeof(int));\n    if (nums == NULL) return;  // Check allocation\n    \n    // FIX 2: i < 5, not i <= 5\n    for (int i = 0; i < 5; i++) {\n        nums[i] = i * 10;\n    }\n    \n    // FIX 3: Free allocated memory\n    free(nums);\n}\n\nint main() {\n    char *msg = createGreeting(\"World\");\n    if (msg) {\n        printf(\"%s\\n\", msg);\n        free(msg);  // Free the allocated string\n    }\n    \n    // FIX 4: Allocate memory before dereferencing\n    int *ptr = malloc(sizeof(int));\n    if (ptr) {\n        *ptr = 5;\n        printf(\"ptr value: %d\\n\", *ptr);\n        free(ptr);\n    }\n    \n    processNumbers();\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Never return pointers to local variables",
      "Always check array bounds",
      "Every malloc needs a free"
    ],
    "language": "c"
  },
  {
    "id": "cs105-exercise-4",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Student Record Structure",
    "difficulty": 2,
    "description": "Define a structure to store student information (name, ID, GPA) and create a function to print student details.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\n// Define Student structure here\n\nvoid printStudent(struct Student s) {\n    // Print student details\n}\n\nint main() {\n    struct Student s1;\n    strcpy(s1.name, \"John Doe\");\n    s1.id = 12345;\n    s1.gpa = 3.8;\n    \n    printStudent(s1);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Define a struct with char array for name, int for id, and float for gpa",
      "Use printf with appropriate format specifiers",
      "Use %.2f to print GPA with 2 decimal places"
    ],
    "solution": "#include <stdio.h>\n#include <string.h>\n\nstruct Student {\n    char name[50];\n    int id;\n    float gpa;\n};\n\nvoid printStudent(struct Student s) {\n    printf(\"Name: %s\\n\", s.name);\n    printf(\"ID: %d\\n\", s.id);\n    printf(\"GPA: %.2f\", s.gpa);\n}\n\nint main() {\n    struct Student s1;\n    strcpy(s1.name, \"John Doe\");\n    s1.id = 12345;\n    s1.gpa = 3.8;\n    \n    printStudent(s1);\n    return 0;\n}",
    "language": "c"
  },
  {
    "id": "cs105-t4-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Point Structure",
    "difficulty": 1,
    "description": "Define a Point structure with x, y coordinates. Calculate distance between two points.",
    "starterCode": "#include <stdio.h>\n#include <math.h>\n\n// Define Point structure\n\nfloat distance(struct Point p1, struct Point p2) {\n    // Calculate Euclidean distance\n}\n\nint main() {\n    struct Point a = {0, 0};\n    struct Point b = {3, 4};\n    printf(\"Distance: %.2f\", distance(a, b));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <math.h>\n\nstruct Point {\n    float x;\n    float y;\n};\n\nfloat distance(struct Point p1, struct Point p2) {\n    float dx = p2.x - p1.x;\n    float dy = p2.y - p1.y;\n    return sqrt(dx*dx + dy*dy);\n}\n\nint main() {\n    struct Point a = {0, 0};\n    struct Point b = {3, 4};\n    printf(\"Distance: %.2f\", distance(a, b));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Distance = sqrt((x2-x1)^2 + (y2-y1)^2)",
      "Use math.h for sqrt()"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Structure with Typedef",
    "difficulty": 1,
    "description": "Use typedef to create a Rectangle type and calculate its area.",
    "starterCode": "#include <stdio.h>\n\n// Use typedef to define Rectangle\n\nint area(Rectangle r) {\n    // Return area\n}\n\nint main() {\n    Rectangle rect = {5, 3};\n    printf(\"Area: %d\", area(rect));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    int width;\n    int height;\n} Rectangle;\n\nint area(Rectangle r) {\n    return r.width * r.height;\n}\n\nint main() {\n    Rectangle rect = {5, 3};\n    printf(\"Area: %d\", area(rect));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "typedef struct {...} Name;",
      "Then use Name instead of struct Name"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Pointer to Structure",
    "difficulty": 2,
    "description": "Use arrow operator to modify structure through a pointer.",
    "starterCode": "#include <stdio.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nvoid movePoint(Point *p, int dx, int dy) {\n    // Move point by dx, dy using arrow operator\n}\n\nint main() {\n    Point p = {5, 10};\n    movePoint(&p, 3, -2);\n    printf(\"Point: (%d, %d)\", p.x, p.y);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nvoid movePoint(Point *p, int dx, int dy) {\n    p->x += dx;\n    p->y += dy;\n}\n\nint main() {\n    Point p = {5, 10};\n    movePoint(&p, 3, -2);\n    printf(\"Point: (%d, %d)\", p.x, p.y);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use -> for pointer to struct",
      "p->x is same as (*p).x"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Nested Structures",
    "difficulty": 3,
    "description": "Create a Person structure containing an Address structure.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\n// Define Address structure\n// Define Person structure containing Address\n\nvoid printPerson(Person p) {\n    // Print name and full address\n}\n\nint main() {\n    Person p;\n    strcpy(p.name, \"Alice\");\n    strcpy(p.addr.street, \"123 Main St\");\n    strcpy(p.addr.city, \"Boston\");\n    \n    printPerson(p);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char street[50];\n    char city[30];\n} Address;\n\ntypedef struct {\n    char name[30];\n    Address addr;\n} Person;\n\nvoid printPerson(Person p) {\n    printf(\"Name: %s\\n\", p.name);\n    printf(\"Address: %s, %s\", p.addr.street, p.addr.city);\n}\n\nint main() {\n    Person p;\n    strcpy(p.name, \"Alice\");\n    strcpy(p.addr.street, \"123 Main St\");\n    strcpy(p.addr.city, \"Boston\");\n    \n    printPerson(p);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Define inner struct first",
      "Access with p.addr.city"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Array of Structures",
    "difficulty": 2,
    "description": "Create an array of Product structures and find the most expensive one.",
    "starterCode": "#include <stdio.h>\n\ntypedef struct {\n    char name[20];\n    float price;\n} Product;\n\nint findMostExpensive(Product products[], int n) {\n    // Return index of most expensive\n}\n\nint main() {\n    Product products[3] = {\n        {\"Apple\", 1.50},\n        {\"Bread\", 2.75},\n        {\"Milk\", 3.00}\n    };\n    \n    int idx = findMostExpensive(products, 3);\n    printf(\"Most expensive: %s ($%.2f)\", products[idx].name, products[idx].price);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    char name[20];\n    float price;\n} Product;\n\nint findMostExpensive(Product products[], int n) {\n    int maxIdx = 0;\n    for (int i = 1; i < n; i++) {\n        if (products[i].price > products[maxIdx].price) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nint main() {\n    Product products[3] = {\n        {\"Apple\", 1.50},\n        {\"Bread\", 2.75},\n        {\"Milk\", 3.00}\n    };\n    \n    int idx = findMostExpensive(products, 3);\n    printf(\"Most expensive: %s ($%.2f)\", products[idx].name, products[idx].price);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Track index of maximum",
      "Access with products[i].price"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Self-Referential Structure (Linked List Node)",
    "difficulty": 4,
    "description": "Define a Node structure for a linked list and create a simple 3-node list.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\n// Define Node with int data and pointer to next Node\n\nvoid printList(struct Node *head) {\n    // Print all values\n}\n\nint main() {\n    // Create 3 nodes: 1 -> 2 -> 3\n    // Print the list\n    // Free memory\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nvoid printList(struct Node *head) {\n    struct Node *current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->data);\n        current = current->next;\n    }\n}\n\nint main() {\n    struct Node *n1 = malloc(sizeof(struct Node));\n    struct Node *n2 = malloc(sizeof(struct Node));\n    struct Node *n3 = malloc(sizeof(struct Node));\n    \n    n1->data = 1; n1->next = n2;\n    n2->data = 2; n2->next = n3;\n    n3->data = 3; n3->next = NULL;\n    \n    printList(n1);\n    \n    free(n1); free(n2); free(n3);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "struct Node contains struct Node *next",
      "Last node's next is NULL"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Structure Size and Padding",
    "difficulty": 3,
    "description": "Explore structure padding by comparing sizes of different struct arrangements.",
    "starterCode": "#include <stdio.h>\n\nstruct A {\n    char c;\n    int i;\n    char d;\n};\n\nstruct B {\n    char c;\n    char d;\n    int i;\n};\n\nint main() {\n    printf(\"Size of struct A: %zu\\n\", sizeof(struct A));\n    printf(\"Size of struct B: %zu\\n\", sizeof(struct B));\n    // Explain why they differ!\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nstruct A {\n    char c;\n    int i;\n    char d;\n};\n\nstruct B {\n    char c;\n    char d;\n    int i;\n};\n\nint main() {\n    printf(\"Size of struct A: %zu\\n\", sizeof(struct A));\n    printf(\"Size of struct B: %zu\\n\", sizeof(struct B));\n    // A has padding after c and d for alignment\n    // B groups chars together, less padding needed\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "int requires 4-byte alignment",
      "Padding is added between members"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Complex Number Structure",
    "difficulty": 2,
    "description": "Create a Complex number structure and implement add and multiply functions.",
    "starterCode": "#include <stdio.h>\n\ntypedef struct {\n    double real;\n    double imag;\n} Complex;\n\nComplex add(Complex a, Complex b) {\n    // Return sum of two complex numbers\n}\n\nComplex multiply(Complex a, Complex b) {\n    // (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n}\n\nvoid print(Complex c) {\n    printf(\"%.1f + %.1fi\\n\", c.real, c.imag);\n}\n\nint main() {\n    Complex a = {3, 2};   // 3 + 2i\n    Complex b = {1, 4};   // 1 + 4i\n    \n    printf(\"a = \"); print(a);\n    printf(\"b = \"); print(b);\n    printf(\"a+b = \"); print(add(a, b));\n    printf(\"a*b = \"); print(multiply(a, b));\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    double real;\n    double imag;\n} Complex;\n\nComplex add(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\nComplex multiply(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\nvoid print(Complex c) {\n    printf(\"%.1f + %.1fi\\n\", c.real, c.imag);\n}\n\nint main() {\n    Complex a = {3, 2};\n    Complex b = {1, 4};\n    \n    printf(\"a = \"); print(a);\n    printf(\"b = \"); print(b);\n    printf(\"a+b = \"); print(add(a, b));\n    printf(\"a*b = \"); print(multiply(a, b));\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Add real parts together, imaginary parts together",
      "FOIL for multiplication"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Date Structure Comparison",
    "difficulty": 2,
    "description": "Create a Date structure and compare two dates.",
    "starterCode": "#include <stdio.h>\n\ntypedef struct {\n    int day;\n    int month;\n    int year;\n} Date;\n\nint compareDates(Date d1, Date d2) {\n    // Return -1 if d1 < d2, 0 if equal, 1 if d1 > d2\n}\n\nint main() {\n    Date d1 = {15, 6, 2023};\n    Date d2 = {20, 3, 2023};\n    \n    int result = compareDates(d1, d2);\n    if (result < 0)\n        printf(\"d1 is before d2\");\n    else if (result > 0)\n        printf(\"d1 is after d2\");\n    else\n        printf(\"dates are equal\");\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    int day;\n    int month;\n    int year;\n} Date;\n\nint compareDates(Date d1, Date d2) {\n    if (d1.year != d2.year)\n        return d1.year - d2.year;\n    if (d1.month != d2.month)\n        return d1.month - d2.month;\n    return d1.day - d2.day;\n}\n\nint main() {\n    Date d1 = {15, 6, 2023};\n    Date d2 = {20, 3, 2023};\n    \n    int result = compareDates(d1, d2);\n    if (result < 0)\n        printf(\"d1 is before d2\");\n    else if (result > 0)\n        printf(\"d1 is after d2\");\n    else\n        printf(\"dates are equal\");\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Compare year first, then month, then day",
      "Return difference to indicate direction"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Circle Structure",
    "difficulty": 2,
    "description": "Create a Circle structure with center point and radius. Calculate area and check if a point is inside.",
    "starterCode": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\ndouble area(Circle c) {\n    // Return area of circle\n}\n\nint isInside(Circle c, Point p) {\n    // Return 1 if point is inside circle, 0 otherwise\n}\n\nint main() {\n    Circle c = {{0, 0}, 5};\n    Point p1 = {3, 3};\n    Point p2 = {10, 10};\n    \n    printf(\"Area: %.2f\\n\", area(c));\n    printf(\"p1 inside: %s\\n\", isInside(c, p1) ? \"yes\" : \"no\");\n    printf(\"p2 inside: %s\", isInside(c, p2) ? \"yes\" : \"no\");\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\ndouble area(Circle c) {\n    return PI * c.radius * c.radius;\n}\n\nint isInside(Circle c, Point p) {\n    double dx = p.x - c.center.x;\n    double dy = p.y - c.center.y;\n    double dist = sqrt(dx*dx + dy*dy);\n    return dist <= c.radius;\n}\n\nint main() {\n    Circle c = {{0, 0}, 5};\n    Point p1 = {3, 3};\n    Point p2 = {10, 10};\n    \n    printf(\"Area: %.2f\\n\", area(c));\n    printf(\"p1 inside: %s\\n\", isInside(c, p1) ? \"yes\" : \"no\");\n    printf(\"p2 inside: %s\", isInside(c, p2) ? \"yes\" : \"no\");\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Area = PI * r^2",
      "Point inside if distance to center <= radius"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Employee Sorting",
    "difficulty": 3,
    "description": "Sort an array of Employee structures by salary using bubble sort.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[30];\n    float salary;\n} Employee;\n\nvoid sortBySalary(Employee emps[], int n) {\n    // Sort by salary (ascending)\n}\n\nint main() {\n    Employee emps[] = {\n        {\"Alice\", 55000},\n        {\"Bob\", 45000},\n        {\"Charlie\", 65000}\n    };\n    int n = 3;\n    \n    sortBySalary(emps, n);\n    \n    printf(\"Sorted by salary:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s: %.0f\\n\", emps[i].name, emps[i].salary);\n    }\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[30];\n    float salary;\n} Employee;\n\nvoid sortBySalary(Employee emps[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (emps[j].salary > emps[j+1].salary) {\n                Employee temp = emps[j];\n                emps[j] = emps[j+1];\n                emps[j+1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    Employee emps[] = {\n        {\"Alice\", 55000},\n        {\"Bob\", 45000},\n        {\"Charlie\", 65000}\n    };\n    int n = 3;\n    \n    sortBySalary(emps, n);\n    \n    printf(\"Sorted by salary:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s: %.0f\\n\", emps[i].name, emps[i].salary);\n    }\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Swap entire structures when swapping",
      "Compare emps[j].salary"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Linked List Operations",
    "difficulty": 4,
    "description": "Implement insert and delete operations for a linked list.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode *createNode(int data) {\n    Node *n = (Node *)malloc(sizeof(Node));\n    n->data = data;\n    n->next = NULL;\n    return n;\n}\n\nvoid insertFront(Node **head, int data) {\n    // Insert at front of list\n}\n\nvoid deleteNode(Node **head, int data) {\n    // Delete first node with given data\n}\n\nvoid printList(Node *head) {\n    while (head) {\n        printf(\"%d -> \", head->data);\n        head = head->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    Node *head = NULL;\n    \n    insertFront(&head, 3);\n    insertFront(&head, 2);\n    insertFront(&head, 1);\n    printf(\"Initial: \"); printList(head);\n    \n    deleteNode(&head, 2);\n    printf(\"After delete 2: \"); printList(head);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode *createNode(int data) {\n    Node *n = (Node *)malloc(sizeof(Node));\n    n->data = data;\n    n->next = NULL;\n    return n;\n}\n\nvoid insertFront(Node **head, int data) {\n    Node *n = createNode(data);\n    n->next = *head;\n    *head = n;\n}\n\nvoid deleteNode(Node **head, int data) {\n    if (*head == NULL) return;\n    \n    if ((*head)->data == data) {\n        Node *temp = *head;\n        *head = (*head)->next;\n        free(temp);\n        return;\n    }\n    \n    Node *curr = *head;\n    while (curr->next && curr->next->data != data) {\n        curr = curr->next;\n    }\n    if (curr->next) {\n        Node *temp = curr->next;\n        curr->next = temp->next;\n        free(temp);\n    }\n}\n\nvoid printList(Node *head) {\n    while (head) {\n        printf(\"%d -> \", head->data);\n        head = head->next;\n    }\n    printf(\"NULL\\n\");\n}\n\nint main() {\n    Node *head = NULL;\n    \n    insertFront(&head, 3);\n    insertFront(&head, 2);\n    insertFront(&head, 1);\n    printf(\"Initial: \"); printList(head);\n    \n    deleteNode(&head, 2);\n    printf(\"After delete 2: \"); printList(head);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use double pointer to modify head",
      "Handle deleting head node specially"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Union vs Structure (Written)",
    "difficulty": 2,
    "description": "This is a written exercise. Explain the difference between union and struct, and predict the output.",
    "starterCode": "/* WRITTEN EXERCISE - Predict the output and explain */\n\n#include <stdio.h>\n\nstruct MyStruct {\n    int i;\n    float f;\n    char c;\n};\n\nunion MyUnion {\n    int i;\n    float f;\n    char c;\n};\n\nint main() {\n    printf(\"sizeof(struct MyStruct) = %zu\\n\", sizeof(struct MyStruct));\n    printf(\"sizeof(union MyUnion) = %zu\\n\", sizeof(union MyUnion));\n    \n    union MyUnion u;\n    u.i = 65;\n    printf(\"u.i = %d\\n\", u.i);\n    printf(\"u.c = %c\\n\", u.c);\n    \n    return 0;\n}\n\n/* Questions:\n * 1. What is the size of the struct? Why?\n * 2. What is the size of the union? Why?\n * 3. What will u.c print? Why?\n * 4. When would you use a union instead of a struct?\n *\n * Write your answers below:\n */",
    "solution": "/* ANSWERS:\n *\n * 1. sizeof(struct MyStruct) = 12 bytes (typically)\n *    - int: 4 bytes\n *    - float: 4 bytes  \n *    - char: 1 byte + 3 bytes padding\n *    Struct allocates memory for ALL members.\n *\n * 2. sizeof(union MyUnion) = 4 bytes\n *    Union only needs space for its LARGEST member.\n *    All members share the same memory location.\n *\n * 3. u.c will print 'A'\n *    Because u.i = 65, and 65 is ASCII for 'A'.\n *    Since union members share memory, reading u.c\n *    reads the first byte of u.i, which is 65 on\n *    little-endian systems.\n *\n * 4. Use union when:\n *    - Only one member is valid at a time\n *    - Memory efficiency matters\n *    - Type punning (reinterpreting bytes)\n *    - Implementing variant types (tagged unions)\n *    \n *    Example: A value that can be int OR float, but not both.\n */",
    "testCases": [],
    "hints": [
      "Struct members are stored sequentially",
      "Union members share same memory"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Bit Fields",
    "difficulty": 3,
    "description": "Use bit fields to pack multiple flags into a single byte.",
    "starterCode": "#include <stdio.h>\n\ntypedef struct {\n    unsigned int isActive : 1;\n    unsigned int priority : 3;    // 0-7\n    unsigned int type : 4;        // 0-15\n} TaskFlags;\n\nint main() {\n    TaskFlags task;\n    \n    task.isActive = 1;\n    task.priority = 5;\n    task.type = 12;\n    \n    printf(\"Size of TaskFlags: %zu bytes\\n\", sizeof(TaskFlags));\n    printf(\"isActive: %u\\n\", task.isActive);\n    printf(\"priority: %u\\n\", task.priority);\n    printf(\"type: %u\\n\", task.type);\n    \n    // What happens if we exceed the bit width?\n    task.priority = 10;  // 10 in binary is 1010, but only 3 bits!\n    printf(\"priority after setting 10: %u\\n\", task.priority);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    unsigned int isActive : 1;\n    unsigned int priority : 3;    // 0-7\n    unsigned int type : 4;        // 0-15\n} TaskFlags;\n\nint main() {\n    TaskFlags task;\n    \n    task.isActive = 1;\n    task.priority = 5;\n    task.type = 12;\n    \n    printf(\"Size of TaskFlags: %zu bytes\\n\", sizeof(TaskFlags));\n    printf(\"isActive: %u\\n\", task.isActive);\n    printf(\"priority: %u\\n\", task.priority);\n    printf(\"type: %u\\n\", task.type);\n    \n    // Value is truncated to fit bit width\n    task.priority = 10;  // 1010 -> 010 = 2\n    printf(\"priority after setting 10: %u\\n\", task.priority);\n    // Output: 2 (10 mod 8, since 3 bits can hold 0-7)\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Total is 8 bits = 1 byte, but alignment may increase size",
      "Values are truncated to bit width"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t4-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-4",
    "title": "Structure Padding Optimization (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. Reorder structure members to minimize padding.",
    "starterCode": "/* WRITTEN EXERCISE - Optimize these structures */\n\n#include <stdio.h>\n\n// Original structure - how much padding?\nstruct Original {\n    char a;      // 1 byte\n    double b;    // 8 bytes\n    char c;      // 1 byte\n    int d;       // 4 bytes\n    char e;      // 1 byte\n};\n\n// Your optimized version:\nstruct Optimized {\n    // Reorder members to minimize padding\n    // Your answer here\n};\n\nint main() {\n    printf(\"Original size: %zu\\n\", sizeof(struct Original));\n    // What is the optimized size?\n    return 0;\n}\n\n/* Questions:\n * 1. What is sizeof(struct Original)? Show padding bytes.\n * 2. What is the optimal member order?\n * 3. What is the minimum possible size?\n * 4. State the rule for ordering structure members.\n *\n * Write your answers below:\n */",
    "solution": "/* ANSWERS:\n *\n * 1. sizeof(struct Original) = 32 bytes (typically)\n *    Layout with padding:\n *    char a;      // offset 0, 1 byte\n *    [7 bytes padding to align double]\n *    double b;    // offset 8, 8 bytes\n *    char c;      // offset 16, 1 byte\n *    [3 bytes padding to align int]\n *    int d;       // offset 20, 4 bytes\n *    char e;      // offset 24, 1 byte\n *    [7 bytes end padding for array alignment]\n *    Total: 32 bytes\n *\n * 2. Optimal member order (largest to smallest):\n *    struct Optimized {\n *        double b;    // 8 bytes\n *        int d;       // 4 bytes\n *        char a;      // 1 byte\n *        char c;      // 1 byte  \n *        char e;      // 1 byte\n *        // 3 bytes end padding\n *    };\n *\n * 3. Minimum size = 16 bytes\n *    (8 + 4 + 1 + 1 + 1 + 3 padding = 16)\n *\n * 4. Rule: Order members from largest alignment\n *    to smallest. This groups small types together\n *    and minimizes internal padding.\n */",
    "testCases": [],
    "hints": [
      "Order largest to smallest alignment",
      "Group chars together to share padding"
    ],
    "language": "c"
  },
  {
    "id": "cs105-exercise-5",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Write and Read from File",
    "difficulty": 2,
    "description": "Write a program that writes numbers 1-10 to a file, then reads and displays them.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    \n    // Write numbers 1-10 to file \"numbers.txt\"\n    \n    // Read and print numbers from file\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use fopen() with \"w\" mode to write and \"r\" mode to read",
      "Use fprintf() to write formatted data to file",
      "Use fscanf() to read formatted data from file",
      "Always check if fopen() returns NULL"
    ],
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int num;\n    \n    fp = fopen(\"numbers.txt\", \"w\");\n    for (int i = 1; i <= 10; i++) {\n        fprintf(fp, \"%d \", i);\n    }\n    fclose(fp);\n    \n    fp = fopen(\"numbers.txt\", \"r\");\n    while (fscanf(fp, \"%d\", &num) != EOF) {\n        printf(\"%d \", num);\n    }\n    fclose(fp);\n    \n    return 0;\n}",
    "language": "c"
  },
  {
    "id": "cs105-t5-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Character I/O",
    "difficulty": 1,
    "description": "Write a string to a file character by character using fputc, then read it back with fgetc.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    char *text = \"Hello File!\";\n    int c;\n    \n    // Write text using fputc\n    // Read back using fgetc\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    char *text = \"Hello File!\";\n    int c;\n    \n    fp = fopen(\"char.txt\", \"w\");\n    for (int i = 0; text[i] != '\\0'; i++) {\n        fputc(text[i], fp);\n    }\n    fclose(fp);\n    \n    fp = fopen(\"char.txt\", \"r\");\n    while ((c = fgetc(fp)) != EOF) {\n        printf(\"%c\", c);\n    }\n    fclose(fp);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "fputc(char, file) writes one character",
      "fgetc returns int (for EOF check)"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Line I/O with fgets",
    "difficulty": 2,
    "description": "Read lines from a file using fgets and count them.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    char line[256];\n    int count = 0;\n    \n    // First create a file with 3 lines\n    fp = fopen(\"lines.txt\", \"w\");\n    fprintf(fp, \"Line 1\\nLine 2\\nLine 3\\n\");\n    fclose(fp);\n    \n    // Read and count lines\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    char line[256];\n    int count = 0;\n    \n    fp = fopen(\"lines.txt\", \"w\");\n    fprintf(fp, \"Line 1\\nLine 2\\nLine 3\\n\");\n    fclose(fp);\n    \n    fp = fopen(\"lines.txt\", \"r\");\n    while (fgets(line, sizeof(line), fp) != NULL) {\n        count++;\n    }\n    fclose(fp);\n    \n    printf(\"Number of lines: %d\", count);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "fgets reads until newline or buffer full",
      "fgets returns NULL at EOF"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Append Mode",
    "difficulty": 2,
    "description": "Demonstrate append mode by adding new content to an existing file.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    \n    // Create file with \"Hello\"\n    fp = fopen(\"append.txt\", \"w\");\n    fprintf(fp, \"Hello\");\n    fclose(fp);\n    \n    // Append \" World\" using \"a\" mode\n    \n    // Read and print full content\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int c;\n    \n    fp = fopen(\"append.txt\", \"w\");\n    fprintf(fp, \"Hello\");\n    fclose(fp);\n    \n    fp = fopen(\"append.txt\", \"a\");\n    fprintf(fp, \" World\");\n    fclose(fp);\n    \n    fp = fopen(\"append.txt\", \"r\");\n    while ((c = fgetc(fp)) != EOF) {\n        printf(\"%c\", c);\n    }\n    fclose(fp);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "\"a\" mode adds to end of file",
      "\"w\" would overwrite existing content"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Binary File I/O",
    "difficulty": 3,
    "description": "Write an array of integers to a binary file using fwrite, then read it back with fread.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int arr[5] = {10, 20, 30, 40, 50};\n    int buffer[5];\n    \n    // Write array to binary file\n    // Read it back into buffer\n    // Print buffer contents\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int arr[5] = {10, 20, 30, 40, 50};\n    int buffer[5];\n    \n    fp = fopen(\"data.bin\", \"wb\");\n    fwrite(arr, sizeof(int), 5, fp);\n    fclose(fp);\n    \n    fp = fopen(\"data.bin\", \"rb\");\n    fread(buffer, sizeof(int), 5, fp);\n    fclose(fp);\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", buffer[i]);\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use \"wb\" and \"rb\" for binary mode",
      "fwrite(ptr, size, count, file)"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "File Seek and Tell",
    "difficulty": 3,
    "description": "Use fseek and ftell to navigate within a file.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    \n    // Create file with \"ABCDEFGHIJ\"\n    fp = fopen(\"seek.txt\", \"w\");\n    fprintf(fp, \"ABCDEFGHIJ\");\n    fclose(fp);\n    \n    // Open for reading\n    // Use fseek to go to position 5\n    // Print current position with ftell\n    // Read and print remaining characters\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    int c;\n    \n    fp = fopen(\"seek.txt\", \"w\");\n    fprintf(fp, \"ABCDEFGHIJ\");\n    fclose(fp);\n    \n    fp = fopen(\"seek.txt\", \"r\");\n    fseek(fp, 5, SEEK_SET);\n    printf(\"Position: %ld\\n\", ftell(fp));\n    while ((c = fgetc(fp)) != EOF) {\n        printf(\"%c\", c);\n    }\n    fclose(fp);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "SEEK_SET from beginning, SEEK_CUR from current, SEEK_END from end",
      "ftell returns current position"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Error Handling",
    "difficulty": 2,
    "description": "Demonstrate proper file error handling when file doesn't exist.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    \n    // Try to open a non-existent file for reading\n    // Check for NULL and print error message\n    // Use perror for detailed error\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    FILE *fp;\n    \n    fp = fopen(\"nonexistent.txt\", \"r\");\n    if (fp == NULL) {\n        printf(\"Error: Could not open file\\n\");\n        perror(\"fopen\");\n        return 1;\n    }\n    \n    fclose(fp);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "fopen returns NULL on failure",
      "perror prints system error message"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Write and Read Structure",
    "difficulty": 4,
    "description": "Save a structure to a binary file and read it back.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[30];\n    int age;\n    float score;\n} Student;\n\nint main() {\n    Student s1 = {\"Alice\", 20, 95.5};\n    Student s2;\n    \n    // Write s1 to binary file\n    // Read into s2\n    // Print s2's data\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[30];\n    int age;\n    float score;\n} Student;\n\nint main() {\n    Student s1 = {\"Alice\", 20, 95.5};\n    Student s2;\n    FILE *fp;\n    \n    fp = fopen(\"student.bin\", \"wb\");\n    fwrite(&s1, sizeof(Student), 1, fp);\n    fclose(fp);\n    \n    fp = fopen(\"student.bin\", \"rb\");\n    fread(&s2, sizeof(Student), 1, fp);\n    fclose(fp);\n    \n    printf(\"Name: %s, Age: %d, Score: %.1f\", s2.name, s2.age, s2.score);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "fwrite(&struct, sizeof, 1, fp)",
      "Binary files preserve exact byte representation"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "File Copy Program (Written)",
    "difficulty": 2,
    "description": "This is a written exercise. Write a complete program that copies one file to another, handling errors properly.",
    "starterCode": "/* WRITTEN EXERCISE - Write a file copy program */\n\n#include <stdio.h>\n\n/*\n * Write a program that:\n * 1. Takes source and destination filenames as command line arguments\n * 2. Opens the source file for reading\n * 3. Opens the destination file for writing\n * 4. Copies content byte by byte (or use a buffer for efficiency)\n * 5. Handles all possible errors\n * 6. Reports success or failure\n *\n * Handle these error cases:\n * - Wrong number of arguments\n * - Source file doesn't exist\n * - Cannot create destination file\n * - Read/write errors\n *\n * Write your complete solution below:\n */\n\nint main(int argc, char *argv[]) {\n    // Your code here\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <source> <destination>\\n\", argv[0]);\n        return 1;\n    }\n    \n    FILE *src = fopen(argv[1], \"rb\");\n    if (src == NULL) {\n        perror(\"Error opening source file\");\n        return 1;\n    }\n    \n    FILE *dst = fopen(argv[2], \"wb\");\n    if (dst == NULL) {\n        perror(\"Error creating destination file\");\n        fclose(src);\n        return 1;\n    }\n    \n    char buffer[4096];\n    size_t bytes;\n    \n    while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {\n        if (fwrite(buffer, 1, bytes, dst) != bytes) {\n            perror(\"Write error\");\n            fclose(src);\n            fclose(dst);\n            return 1;\n        }\n    }\n    \n    if (ferror(src)) {\n        perror(\"Read error\");\n        fclose(src);\n        fclose(dst);\n        return 1;\n    }\n    \n    fclose(src);\n    if (fclose(dst) != 0) {\n        perror(\"Error closing destination\");\n        return 1;\n    }\n    \n    printf(\"File copied successfully\\n\");\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use binary mode for copying any file type",
      "Buffer reads are more efficient than byte-by-byte"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Word Counter (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Write a program that counts lines, words, and characters in a file.",
    "starterCode": "/* WRITTEN EXERCISE - Write a word counter (like wc) */\n\n#include <stdio.h>\n#include <ctype.h>\n\n/*\n * Write a program that reads a file and counts:\n * - Number of lines\n * - Number of words (whitespace-separated)\n * - Number of characters\n *\n * Output format:\n *   Lines: X\n *   Words: Y\n *   Characters: Z\n *\n * A word is defined as a sequence of non-whitespace characters.\n *\n * Write your solution below:\n */\n\nint main(int argc, char *argv[]) {\n    // Your code here\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    \n    FILE *fp = fopen(argv[1], \"r\");\n    if (fp == NULL) {\n        perror(argv[1]);\n        return 1;\n    }\n    \n    int lines = 0, words = 0, chars = 0;\n    int inWord = 0;\n    int c;\n    \n    while ((c = fgetc(fp)) != EOF) {\n        chars++;\n        \n        if (c == '\\n') {\n            lines++;\n        }\n        \n        if (isspace(c)) {\n            inWord = 0;\n        } else if (!inWord) {\n            inWord = 1;\n            words++;\n        }\n    }\n    \n    fclose(fp);\n    \n    printf(\"Lines: %d\\n\", lines);\n    printf(\"Words: %d\\n\", words);\n    printf(\"Characters: %d\\n\", chars);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Track state: are we inside a word or not?",
      "Use isspace() to detect whitespace"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "CSV Parser (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. Write a program that reads a simple CSV file and prints formatted output.",
    "starterCode": "/* WRITTEN EXERCISE - Write a CSV parser */\n\n#include <stdio.h>\n#include <string.h>\n\n/*\n * Given a CSV file with this format:\n *   Name,Age,City\n *   Alice,25,Boston\n *   Bob,30,New York\n *   Charlie,22,Chicago\n *\n * Output:\n *   Record 1: Name=Alice, Age=25, City=Boston\n *   Record 2: Name=Bob, Age=30, City=New York\n *   Record 3: Name=Charlie, Age=22, City=Chicago\n *\n * Assumptions:\n * - First line is header\n * - No commas within fields\n * - Max line length 256 characters\n * - Max 10 fields per line\n *\n * Write your solution below:\n */\n\nint main(int argc, char *argv[]) {\n    // Your code here\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LINE 256\n#define MAX_FIELDS 10\n\nint parseCSVLine(char *line, char *fields[], int maxFields) {\n    int count = 0;\n    char *token = strtok(line, \",\\n\");\n    \n    while (token != NULL && count < maxFields) {\n        fields[count++] = token;\n        token = strtok(NULL, \",\\n\");\n    }\n    return count;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <csvfile>\\n\", argv[0]);\n        return 1;\n    }\n    \n    FILE *fp = fopen(argv[1], \"r\");\n    if (fp == NULL) {\n        perror(argv[1]);\n        return 1;\n    }\n    \n    char line[MAX_LINE];\n    char *headers[MAX_FIELDS];\n    char *fields[MAX_FIELDS];\n    int numHeaders = 0;\n    int recordNum = 0;\n    \n    // Read header line\n    if (fgets(line, sizeof(line), fp)) {\n        numHeaders = parseCSVLine(line, headers, MAX_FIELDS);\n        // Make copies of headers (strtok modifies string)\n        for (int i = 0; i < numHeaders; i++) {\n            headers[i] = strdup(headers[i]);\n        }\n    }\n    \n    // Read data lines\n    while (fgets(line, sizeof(line), fp)) {\n        int numFields = parseCSVLine(line, fields, MAX_FIELDS);\n        recordNum++;\n        \n        printf(\"Record %d: \", recordNum);\n        for (int i = 0; i < numFields && i < numHeaders; i++) {\n            printf(\"%s=%s\", headers[i], fields[i]);\n            if (i < numFields - 1) printf(\", \");\n        }\n        printf(\"\\n\");\n    }\n    \n    fclose(fp);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use strtok to split on commas",
      "First line contains field names"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "File Modes Comparison (Written)",
    "difficulty": 2,
    "description": "This is a written exercise. Explain what each file mode does and when to use it.",
    "starterCode": "/* WRITTEN EXERCISE - Explain file modes */\n\n/*\n * For each file mode below, explain:\n * 1. What it does\n * 2. What happens if file exists / doesn't exist\n * 3. Where the file pointer starts\n * 4. A use case for this mode\n *\n * Modes:\n * \"r\"  - \n * \"w\"  - \n * \"a\"  - \n * \"r+\" - \n * \"w+\" - \n * \"a+\" - \n * \"rb\" - \n * \"wb\" - \n *\n * Bonus: What's the difference between \"r+\" and \"w+\"?\n *\n * Write your answers below:\n */",
    "solution": "/* ANSWERS:\n *\n * \"r\" - Read only\n *   - Opens for reading only\n *   - File must exist (returns NULL if not)\n *   - Pointer starts at beginning\n *   - Use: Reading config files, data files\n *\n * \"w\" - Write only\n *   - Opens for writing only\n *   - Creates file if doesn't exist\n *   - TRUNCATES (erases) if file exists!\n *   - Pointer starts at beginning\n *   - Use: Creating new output files\n *\n * \"a\" - Append only\n *   - Opens for writing at end only\n *   - Creates file if doesn't exist\n *   - Preserves existing content\n *   - Pointer always at end (writes are always appended)\n *   - Use: Log files, adding to existing data\n *\n * \"r+\" - Read and write\n *   - Opens for both reading and writing\n *   - File must exist (returns NULL if not)\n *   - Pointer starts at beginning\n *   - Use: Modifying existing files in place\n *\n * \"w+\" - Read and write (truncate)\n *   - Opens for both reading and writing\n *   - Creates file if doesn't exist\n *   - TRUNCATES if file exists!\n *   - Pointer starts at beginning\n *   - Use: Creating new file to read/write\n *\n * \"a+\" - Read and append\n *   - Opens for reading anywhere, writing at end\n *   - Creates file if doesn't exist\n *   - Reading can be anywhere, writes are appended\n *   - Use: Reading log while adding entries\n *\n * \"rb\"/\"wb\" - Binary mode\n *   - Same as r/w but in binary mode\n *   - No newline translation\n *   - Use: Images, executables, any non-text\n *\n * Difference between \"r+\" and \"w+\":\n *   - r+ requires file to exist, w+ creates/truncates\n *   - r+ preserves content, w+ erases everything\n */",
    "testCases": [],
    "hints": [
      "Think about what happens to existing content",
      "Consider the starting position of file pointer"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Binary vs Text Mode (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Explain why binary mode matters and predict the output.",
    "starterCode": "/* WRITTEN EXERCISE - Binary vs Text Mode */\n\n/*\n * Consider this code on Windows:\n */\n\n#include <stdio.h>\n\nint main() {\n    // Writing in text mode\n    FILE *text = fopen(\"text.txt\", \"w\");\n    fprintf(text, \"Hello\\nWorld\\n\");\n    fclose(text);\n    \n    // Writing in binary mode\n    FILE *bin = fopen(\"bin.txt\", \"wb\");\n    fprintf(bin, \"Hello\\nWorld\\n\");\n    fclose(bin);\n    \n    // What are the file sizes?\n    return 0;\n}\n\n/* Questions:\n *\n * 1. On Windows, what is the size of text.txt? bin.txt?\n *    Why are they different?\n *\n * 2. On Linux/Mac, what is the size of text.txt? bin.txt?\n *    Why?\n *\n * 3. What happens if you read a binary file in text mode\n *    on Windows?\n *\n * 4. When should you ALWAYS use binary mode?\n *\n * 5. This code has a subtle bug. What is it?\n *\n *    char data[100];\n *    FILE *f = fopen(\"image.jpg\", \"r\");\n *    fread(data, 1, 100, f);\n *\n * Write your answers below:\n */",
    "solution": "/* ANSWERS:\n *\n * 1. On Windows:\n *    text.txt = 14 bytes\n *    bin.txt = 12 bytes\n *    \n *    In text mode on Windows, \\n is translated to \\r\\n\n *    (carriage return + line feed). So each \\n becomes\n *    2 bytes instead of 1.\n *    Text: \"Hello\\r\\nWorld\\r\\n\" = 12 chars + 2 extra = 14\n *    Binary: \"Hello\\nWorld\\n\" = 12 chars exactly\n *\n * 2. On Linux/Mac:\n *    Both files are 12 bytes.\n *    Unix systems don't translate newlines in text mode.\n *    \\n is just \\n (LF only, no CR).\n *\n * 3. Reading binary in text mode on Windows:\n *    - \\r\\n pairs are converted to \\n\n *    - Ctrl+Z (0x1A) is treated as EOF!\n *    - File size may appear different\n *    - Binary data can be corrupted\n *\n * 4. ALWAYS use binary mode for:\n *    - Images, audio, video files\n *    - Executable files\n *    - Compressed files (zip, gzip)\n *    - Any file that's not plain text\n *    - When you need exact byte counts\n *    - When writing cross-platform code\n *\n * 5. Bug: Reading image.jpg without \"rb\" mode\n *    Should be: fopen(\"image.jpg\", \"rb\")\n *    On Windows, bytes could be corrupted by\n *    newline translation or premature EOF.\n */",
    "testCases": [],
    "hints": [
      "Windows uses CRLF (\\r\\n) for newlines",
      "Text mode does newline translation"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Random Access Database (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. Design a simple record-based database using random access.",
    "starterCode": "/* WRITTEN EXERCISE - Design a record database */\n\n#include <stdio.h>\n#include <string.h>\n\n/*\n * Design a simple \"database\" that stores employee records\n * in a binary file with random access capabilities.\n *\n * Requirements:\n * 1. Fixed-size records for random access\n * 2. Add new employee\n * 3. Read employee by ID (record number)\n * 4. Update employee by ID\n * 5. Delete employee by ID (mark as deleted)\n *\n * Implement these functions:\n */\n\ntypedef struct {\n    int id;\n    char name[50];\n    float salary;\n    int active;  // 1 = active, 0 = deleted\n} Employee;\n\n// Initialize empty database file\nvoid initDatabase(const char *filename);\n\n// Add employee, return assigned ID\nint addEmployee(const char *filename, Employee *emp);\n\n// Read employee by ID (0-based)\nint readEmployee(const char *filename, int id, Employee *emp);\n\n// Update employee by ID\nint updateEmployee(const char *filename, int id, Employee *emp);\n\n// Delete employee by ID (mark as inactive)\nint deleteEmployee(const char *filename, int id);\n\n/*\n * Key insight: Since all records are the same size,\n * we can jump directly to record N using:\n *   fseek(file, N * sizeof(Employee), SEEK_SET);\n *\n * Write your implementation below:\n */",
    "solution": "/* SOLUTION: */\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float salary;\n    int active;\n} Employee;\n\nvoid initDatabase(const char *filename) {\n    FILE *f = fopen(filename, \"wb\");\n    if (f) fclose(f);  // Create empty file\n}\n\nint countRecords(const char *filename) {\n    FILE *f = fopen(filename, \"rb\");\n    if (!f) return 0;\n    fseek(f, 0, SEEK_END);\n    long size = ftell(f);\n    fclose(f);\n    return size / sizeof(Employee);\n}\n\nint addEmployee(const char *filename, Employee *emp) {\n    FILE *f = fopen(filename, \"ab\");\n    if (!f) return -1;\n    \n    int id = countRecords(filename);\n    emp->id = id;\n    emp->active = 1;\n    \n    fwrite(emp, sizeof(Employee), 1, f);\n    fclose(f);\n    return id;\n}\n\nint readEmployee(const char *filename, int id, Employee *emp) {\n    FILE *f = fopen(filename, \"rb\");\n    if (!f) return -1;\n    \n    fseek(f, id * sizeof(Employee), SEEK_SET);\n    size_t read = fread(emp, sizeof(Employee), 1, f);\n    fclose(f);\n    \n    return (read == 1 && emp->active) ? 0 : -1;\n}\n\nint updateEmployee(const char *filename, int id, Employee *emp) {\n    FILE *f = fopen(filename, \"r+b\");\n    if (!f) return -1;\n    \n    emp->id = id;\n    emp->active = 1;\n    \n    fseek(f, id * sizeof(Employee), SEEK_SET);\n    size_t written = fwrite(emp, sizeof(Employee), 1, f);\n    fclose(f);\n    \n    return (written == 1) ? 0 : -1;\n}\n\nint deleteEmployee(const char *filename, int id) {\n    Employee emp;\n    if (readEmployee(filename, id, &emp) != 0) return -1;\n    \n    emp.active = 0;\n    return updateEmployee(filename, id, &emp);\n}\n\n/* Usage example:\n *\n * initDatabase(\"employees.dat\");\n * \n * Employee e1 = {0, \"Alice\", 50000, 1};\n * int id1 = addEmployee(\"employees.dat\", &e1);\n * \n * Employee result;\n * readEmployee(\"employees.dat\", id1, &result);\n * printf(\"Name: %s\\n\", result.name);\n */",
    "testCases": [],
    "hints": [
      "Use fseek with record_number * sizeof(struct)",
      "Use r+b mode for read/update operations"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Error Handling Best Practices (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Identify error handling issues and fix them.",
    "starterCode": "/* WRITTEN EXERCISE - Fix the error handling */\n\n/*\n * This code has poor error handling. Identify all issues\n * and write a corrected version.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid processFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    \n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file)) {\n        printf(\"%s\", buffer);\n    }\n    \n    fclose(file);\n}\n\nvoid copyFiles(const char *src, const char *dst) {\n    FILE *in = fopen(src, \"r\");\n    FILE *out = fopen(dst, \"w\");\n    \n    int c;\n    while ((c = fgetc(in)) != EOF) {\n        fputc(c, out);\n    }\n    \n    fclose(in);\n    fclose(out);\n}\n\nint main() {\n    processFile(\"data.txt\");\n    copyFiles(\"source.txt\", \"dest.txt\");\n    return 0;\n}\n\n/* Issues to identify:\n * 1. \n * 2. \n * 3. \n * 4. \n * 5. \n *\n * Write the corrected code below:\n */",
    "solution": "/* ISSUES:\n *\n * 1. No check if fopen returns NULL\n * 2. No check for read errors (ferror)\n * 3. No check for write errors\n * 4. No check if fclose fails\n * 5. In copyFiles: if out fails, in is not closed\n * 6. No error reporting to user\n * 7. No return values to indicate success/failure\n *\n * CORRECTED CODE:\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint processFile(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(filename);\n        return -1;\n    }\n    \n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n    \n    if (ferror(file)) {\n        perror(\"Read error\");\n        fclose(file);\n        return -1;\n    }\n    \n    if (fclose(file) != 0) {\n        perror(\"Close error\");\n        return -1;\n    }\n    \n    return 0;\n}\n\nint copyFiles(const char *src, const char *dst) {\n    FILE *in = fopen(src, \"rb\");\n    if (in == NULL) {\n        perror(src);\n        return -1;\n    }\n    \n    FILE *out = fopen(dst, \"wb\");\n    if (out == NULL) {\n        perror(dst);\n        fclose(in);  // Clean up!\n        return -1;\n    }\n    \n    int c;\n    while ((c = fgetc(in)) != EOF) {\n        if (fputc(c, out) == EOF) {\n            perror(\"Write error\");\n            fclose(in);\n            fclose(out);\n            return -1;\n        }\n    }\n    \n    if (ferror(in)) {\n        perror(\"Read error\");\n        fclose(in);\n        fclose(out);\n        return -1;\n    }\n    \n    fclose(in);\n    if (fclose(out) != 0) {\n        perror(\"Error closing output\");\n        return -1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    if (processFile(\"data.txt\") != 0) {\n        fprintf(stderr, \"Failed to process file\\n\");\n    }\n    \n    if (copyFiles(\"source.txt\", \"dest.txt\") != 0) {\n        fprintf(stderr, \"Failed to copy files\\n\");\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Every fopen needs a NULL check",
      "Clean up resources on error paths"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t5-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-5",
    "title": "Log File Rotation (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. Design and implement a log file rotation system.",
    "starterCode": "/* WRITTEN EXERCISE - Log file rotation */\n\n#include <stdio.h>\n#include <time.h>\n\n/*\n * Design a logging system with these features:\n *\n * 1. Write timestamped log messages to a file\n * 2. Rotate log when file exceeds MAX_SIZE bytes\n * 3. Keep up to MAX_LOGS old log files\n * 4. Name pattern: app.log, app.log.1, app.log.2, etc.\n *\n * When rotating:\n *   app.log.2 -> deleted\n *   app.log.1 -> app.log.2\n *   app.log   -> app.log.1\n *   new       -> app.log\n *\n * Implement:\n */\n\n#define MAX_SIZE 10000  // 10KB\n#define MAX_LOGS 3\n#define LOG_FILE \"app.log\"\n\ntypedef struct {\n    FILE *file;\n    long currentSize;\n} Logger;\n\n// Initialize logger\nLogger *createLogger();\n\n// Write log message with timestamp\nvoid logMessage(Logger *log, const char *level, const char *msg);\n\n// Rotate logs if needed\nvoid rotateIfNeeded(Logger *log);\n\n// Close logger\nvoid closeLogger(Logger *log);\n\n/*\n * Write your implementation below.\n * Hint: Use rename() to move files.\n */",
    "solution": "/* SOLUTION: */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define MAX_SIZE 10000\n#define MAX_LOGS 3\n#define LOG_FILE \"app.log\"\n\ntypedef struct {\n    FILE *file;\n    long currentSize;\n} Logger;\n\nvoid rotateLogs() {\n    char oldName[64], newName[64];\n    \n    // Delete oldest log\n    snprintf(oldName, sizeof(oldName), \"%s.%d\", LOG_FILE, MAX_LOGS);\n    remove(oldName);\n    \n    // Shift logs: .2 -> .3, .1 -> .2, etc.\n    for (int i = MAX_LOGS - 1; i >= 1; i--) {\n        snprintf(oldName, sizeof(oldName), \"%s.%d\", LOG_FILE, i);\n        snprintf(newName, sizeof(newName), \"%s.%d\", LOG_FILE, i + 1);\n        rename(oldName, newName);\n    }\n    \n    // Current log becomes .1\n    snprintf(newName, sizeof(newName), \"%s.1\", LOG_FILE);\n    rename(LOG_FILE, newName);\n}\n\nLogger *createLogger() {\n    Logger *log = (Logger *)malloc(sizeof(Logger));\n    if (!log) return NULL;\n    \n    log->file = fopen(LOG_FILE, \"a\");\n    if (!log->file) {\n        free(log);\n        return NULL;\n    }\n    \n    // Get current size\n    fseek(log->file, 0, SEEK_END);\n    log->currentSize = ftell(log->file);\n    \n    return log;\n}\n\nvoid rotateIfNeeded(Logger *log) {\n    if (log->currentSize >= MAX_SIZE) {\n        fclose(log->file);\n        rotateLogs();\n        log->file = fopen(LOG_FILE, \"a\");\n        log->currentSize = 0;\n    }\n}\n\nvoid logMessage(Logger *log, const char *level, const char *msg) {\n    if (!log || !log->file) return;\n    \n    rotateIfNeeded(log);\n    \n    time_t now = time(NULL);\n    char timestamp[32];\n    strftime(timestamp, sizeof(timestamp), \n             \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n    \n    int written = fprintf(log->file, \"[%s] %s: %s\\n\", \n                          timestamp, level, msg);\n    fflush(log->file);\n    \n    if (written > 0) {\n        log->currentSize += written;\n    }\n}\n\nvoid closeLogger(Logger *log) {\n    if (log) {\n        if (log->file) fclose(log->file);\n        free(log);\n    }\n}\n\n/* Usage:\n * Logger *log = createLogger();\n * logMessage(log, \"INFO\", \"Application started\");\n * logMessage(log, \"ERROR\", \"Something went wrong\");\n * closeLogger(log);\n */",
    "testCases": [],
    "hints": [
      "Use rename() to move files atomically",
      "Track file size to know when to rotate"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex01",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Simple Macros",
    "difficulty": 1,
    "description": "Define macros for PI and a CIRCLE_AREA calculation.",
    "starterCode": "#include <stdio.h>\n\n// Define PI as 3.14159\n// Define CIRCLE_AREA(r) macro\n\nint main() {\n    double radius = 5.0;\n    printf(\"Area: %.2f\\n\", CIRCLE_AREA(radius));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define PI 3.14159\n#define CIRCLE_AREA(r) (PI * (r) * (r))\n\nint main() {\n    double radius = 5.0;\n    printf(\"Area: %.2f\\n\", CIRCLE_AREA(radius));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use #define for constants",
      "Wrap macro parameters in parentheses"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "MIN and MAX Macros",
    "difficulty": 2,
    "description": "Define MIN and MAX macros that work with any numeric type.",
    "starterCode": "#include <stdio.h>\n\n// Define MIN(a, b) macro\n// Define MAX(a, b) macro\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Min: %d, Max: %d\\n\", MIN(x, y), MAX(x, y));\n    \n    double a = 3.14, b = 2.71;\n    printf(\"Min: %.2f, Max: %.2f\\n\", MIN(a, b), MAX(a, b));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Min: %d, Max: %d\\n\", MIN(x, y), MAX(x, y));\n    \n    double a = 3.14, b = 2.71;\n    printf(\"Min: %.2f, Max: %.2f\\n\", MIN(a, b), MAX(a, b));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use ternary operator in macro",
      "Parenthesize all parameters"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Debug Macro",
    "difficulty": 2,
    "description": "Create a DEBUG_PRINT macro that only prints when DEBUG is defined.",
    "starterCode": "#include <stdio.h>\n\n#define DEBUG  // Comment out to disable debug output\n\n// Define DEBUG_PRINT(msg) macro\n// Should print \"[DEBUG] msg\" only if DEBUG is defined\n\nint main() {\n    DEBUG_PRINT(\"Starting program\");\n    int x = 42;\n    DEBUG_PRINT(\"x has been set\");\n    printf(\"Result: %d\\n\", x);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define DEBUG\n\n#ifdef DEBUG\n    #define DEBUG_PRINT(msg) printf(\"[DEBUG] %s\\n\", msg)\n#else\n    #define DEBUG_PRINT(msg)\n#endif\n\nint main() {\n    DEBUG_PRINT(\"Starting program\");\n    int x = 42;\n    DEBUG_PRINT(\"x has been set\");\n    printf(\"Result: %d\\n\", x);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Use #ifdef to check if DEBUG is defined",
      "Empty macro for release mode"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Include Guard",
    "difficulty": 2,
    "description": "Create a header file with proper include guards.",
    "starterCode": "/* math_utils.h - Add include guards */\n\n/* Your include guard here */\n\n#define PI 3.14159\n\ndouble square(double x);\ndouble cube(double x);\n\n/* End include guard */\n\n/* Explain in comments:\n * 1. What problem do include guards solve?\n * 2. What is the naming convention?\n * 3. How does #pragma once compare?\n */",
    "solution": "/* math_utils.h */\n\n#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\n\n#define PI 3.14159\n\ndouble square(double x);\ndouble cube(double x);\n\n#endif /* MATH_UTILS_H */\n\n/* Answers:\n * 1. Include guards prevent the same header from being\n *    included multiple times, avoiding redefinition errors.\n *\n * 2. Convention: FILENAME_H or PROJECT_FILENAME_H\n *    Use uppercase with underscores.\n *\n * 3. #pragma once is simpler but non-standard.\n *    Include guards are portable across all compilers.\n */",
    "testCases": [],
    "hints": [
      "#ifndef checks if NOT defined",
      "Use uppercase with underscores for guard name"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Stringification",
    "difficulty": 3,
    "description": "Use the # operator to convert macro arguments to strings.",
    "starterCode": "#include <stdio.h>\n\n// Define PRINT_VAR(var) that prints \"var = value\"\n// Example: PRINT_VAR(x) prints \"x = 42\"\n\nint main() {\n    int x = 42;\n    double pi = 3.14;\n    char* name = \"Alice\";\n    \n    PRINT_VAR(x);\n    PRINT_VAR(pi);\n    PRINT_VAR(name);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define PRINT_INT(var) printf(#var \" = %d\\n\", var)\n#define PRINT_DOUBLE(var) printf(#var \" = %.2f\\n\", var)\n#define PRINT_STR(var) printf(#var \" = %s\\n\", var)\n\n// Generic version using _Generic (C11)\n#define PRINT_VAR(var) _Generic((var), \\\n    int: printf(#var \" = %d\\n\", var), \\\n    double: printf(#var \" = %.2f\\n\", var), \\\n    char*: printf(#var \" = %s\\n\", var))\n\nint main() {\n    int x = 42;\n    double pi = 3.14;\n    char* name = \"Alice\";\n    \n    PRINT_VAR(x);\n    PRINT_VAR(pi);\n    PRINT_VAR(name);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "# operator converts argument to string literal",
      "_Generic selects based on type (C11)"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Token Pasting",
    "difficulty": 3,
    "description": "Use the ## operator to create variable names dynamically.",
    "starterCode": "#include <stdio.h>\n\n// Define DECLARE_PAIR(type, name) that creates:\n// type name_first;\n// type name_second;\n\n// Define PAIR_SUM(name) that returns name_first + name_second\n\nint main() {\n    DECLARE_PAIR(int, point);\n    \n    point_first = 10;\n    point_second = 20;\n    \n    printf(\"Sum: %d\\n\", PAIR_SUM(point));\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define DECLARE_PAIR(type, name) \\\n    type name##_first; \\\n    type name##_second\n\n#define PAIR_SUM(name) ((name##_first) + (name##_second))\n\nint main() {\n    DECLARE_PAIR(int, point);\n    \n    point_first = 10;\n    point_second = 20;\n    \n    printf(\"Sum: %d\\n\", PAIR_SUM(point));\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "## concatenates tokens",
      "Use backslash for multi-line macros"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Conditional Compilation Platform",
    "difficulty": 3,
    "description": "Write code that compiles differently on Windows vs Unix.",
    "starterCode": "#include <stdio.h>\n\n// Define platform-specific CLEAR_SCREEN command\n// Windows: system(\"cls\")\n// Unix/Linux/Mac: system(\"clear\")\n\n// Define NEWLINE as \"\\r\\n\" for Windows, \"\\n\" for Unix\n\nvoid show_platform() {\n    // Print which platform was detected\n}\n\nint main() {\n    show_platform();\n    printf(\"Hello%s\", NEWLINE);\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\n#if defined(_WIN32) || defined(_WIN64)\n    #define PLATFORM_WINDOWS\n    #define CLEAR_SCREEN() system(\"cls\")\n    #define NEWLINE \"\\r\\n\"\n#elif defined(__linux__) || defined(__APPLE__)\n    #define PLATFORM_UNIX\n    #define CLEAR_SCREEN() system(\"clear\")\n    #define NEWLINE \"\\n\"\n#else\n    #define CLEAR_SCREEN()\n    #define NEWLINE \"\\n\"\n#endif\n\nvoid show_platform() {\n#ifdef PLATFORM_WINDOWS\n    printf(\"Running on Windows\\n\");\n#elif defined(PLATFORM_UNIX)\n    printf(\"Running on Unix/Linux/Mac\\n\");\n#else\n    printf(\"Unknown platform\\n\");\n#endif\n}\n\nint main() {\n    show_platform();\n    printf(\"Hello%s\", NEWLINE);\n    return 0;\n}",
    "testCases": [],
    "hints": [
      "_WIN32 is defined on Windows",
      "__linux__ on Linux, __APPLE__ on Mac"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Simple Makefile",
    "difficulty": 2,
    "description": "Write a Makefile to compile a multi-file C project.",
    "starterCode": "# Makefile for a project with:\n# - main.c (includes utils.h)\n# - utils.c (implements utils.h)\n# - utils.h (header file)\n#\n# Write rules for:\n# 1. all: build the program\n# 2. main.o: compile main.c\n# 3. utils.o: compile utils.c\n# 4. program: link object files\n# 5. clean: remove object files and program\n\nCC = gcc\nCFLAGS = -Wall -g\n\n# Your rules here",
    "solution": "# Makefile\n\nCC = gcc\nCFLAGS = -Wall -g\nOBJS = main.o utils.o\nPROGRAM = program\n\n.PHONY: all clean\n\nall: $(PROGRAM)\n\n$(PROGRAM): $(OBJS)\n\t$(CC) $(CFLAGS) -o $@ $^\n\nmain.o: main.c utils.h\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\nutils.o: utils.c utils.h\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\nclean:\n\trm -f $(OBJS) $(PROGRAM)\n\n# Variables:\n# $@ = target name\n# $< = first prerequisite\n# $^ = all prerequisites",
    "testCases": [],
    "hints": [
      "$@ is target, $< is first prerequisite",
      ".PHONY for non-file targets"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Header and Implementation (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Create a proper header/source file pair.",
    "starterCode": "/* WRITTEN EXERCISE - Create stack.h and stack.c */\n\n/*\n * Create a header file (stack.h) and implementation (stack.c)\n * for a simple integer stack with these operations:\n *\n * - Stack* stack_create(int capacity)\n * - void stack_destroy(Stack* s)\n * - bool stack_push(Stack* s, int value)\n * - bool stack_pop(Stack* s, int* value)\n * - bool stack_is_empty(Stack* s)\n * - bool stack_is_full(Stack* s)\n *\n * The Stack struct should be opaque (defined only in .c file).\n *\n * Write both files below:\n */\n\n/* ===== stack.h ===== */\n\n\n/* ===== stack.c ===== */",
    "solution": "/* ===== stack.h ===== */\n\n#ifndef STACK_H\n#define STACK_H\n\n#include <stdbool.h>\n\n// Opaque type - users can only use pointers\ntypedef struct Stack Stack;\n\n// Create/destroy\nStack* stack_create(int capacity);\nvoid stack_destroy(Stack* s);\n\n// Operations\nbool stack_push(Stack* s, int value);\nbool stack_pop(Stack* s, int* value);\nbool stack_is_empty(Stack* s);\nbool stack_is_full(Stack* s);\n\n#endif /* STACK_H */\n\n/* ===== stack.c ===== */\n\n#include \"stack.h\"\n#include <stdlib.h>\n\nstruct Stack {\n    int* data;\n    int top;\n    int capacity;\n};\n\nStack* stack_create(int capacity) {\n    Stack* s = (Stack*)malloc(sizeof(Stack));\n    if (!s) return NULL;\n    \n    s->data = (int*)malloc(capacity * sizeof(int));\n    if (!s->data) {\n        free(s);\n        return NULL;\n    }\n    \n    s->top = -1;\n    s->capacity = capacity;\n    return s;\n}\n\nvoid stack_destroy(Stack* s) {\n    if (s) {\n        free(s->data);\n        free(s);\n    }\n}\n\nbool stack_push(Stack* s, int value) {\n    if (stack_is_full(s)) return false;\n    s->data[++s->top] = value;\n    return true;\n}\n\nbool stack_pop(Stack* s, int* value) {\n    if (stack_is_empty(s)) return false;\n    *value = s->data[s->top--];\n    return true;\n}\n\nbool stack_is_empty(Stack* s) {\n    return s->top == -1;\n}\n\nbool stack_is_full(Stack* s) {\n    return s->top == s->capacity - 1;\n}",
    "testCases": [],
    "hints": [
      "Use typedef struct X X for opaque type",
      "Define struct only in .c file"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Macro Pitfalls (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Identify and fix macro bugs.",
    "starterCode": "/* WRITTEN EXERCISE - Fix these broken macros */\n\n#include <stdio.h>\n\n// BUGGY MACROS - Identify the problems and fix them\n\n#define SQUARE(x) x * x\n\n#define MAX(a, b) a > b ? a : b\n\n#define DOUBLE(x) x + x\n\n#define IS_UPPERCASE(c) c >= 'A' && c <= 'Z'\n\n#define PRINT_AND_INC(x) printf(\"%d\\n\", x); x++\n\nint main() {\n    // Test cases that show the bugs:\n    printf(\"SQUARE(2+3) = %d\\n\", SQUARE(2+3));  // Expected: 25\n    printf(\"MAX(1, 2) * 10 = %d\\n\", MAX(1, 2) * 10);  // Expected: 20\n    printf(\"10 * DOUBLE(5) = %d\\n\", 10 * DOUBLE(5));  // Expected: 100\n    \n    // What problems exist?\n    // Write fixed versions below:\n    \n    return 0;\n}",
    "solution": "/* WRITTEN EXERCISE - SOLUTIONS */\n\n#include <stdio.h>\n\n/* ORIGINAL BUGS:\n *\n * 1. SQUARE(x) x * x\n *    Bug: SQUARE(2+3) = 2+3 * 2+3 = 2+6+3 = 11 (not 25)\n *    Fix: Parenthesize parameter and result\n *\n * 2. MAX(a, b) a > b ? a : b\n *    Bug: MAX(1,2) * 10 = 1 > 2 ? 1 : 2 * 10 = 20 (works)\n *          but MAX(1, 2) + 0 has precedence issues\n *    Fix: Wrap entire expression in parentheses\n *\n * 3. DOUBLE(x) x + x\n *    Bug: 10 * DOUBLE(5) = 10 * 5 + 5 = 55 (not 100)\n *    Fix: Wrap in parentheses\n *\n * 4. IS_UPPERCASE(c)\n *    Bug: !IS_UPPERCASE(c) = !c >= 'A' && c <= 'Z'\n *    Fix: Wrap entire expression\n *\n * 5. PRINT_AND_INC(x)\n *    Bug: if (cond) PRINT_AND_INC(x); else ... breaks\n *    Fix: Use do-while(0) idiom\n */\n\n/* FIXED MACROS */\n\n#define SQUARE(x) ((x) * (x))\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n#define DOUBLE(x) ((x) + (x))\n\n#define IS_UPPERCASE(c) ((c) >= 'A' && (c) <= 'Z')\n\n#define PRINT_AND_INC(x) do { printf(\"%d\\n\", x); (x)++; } while(0)\n\n/* Additional issue: Multiple evaluation\n * MAX(i++, j++) evaluates the larger one twice!\n * This can't be fixed in C89, but C11 has _Generic,\n * and GNU C has statement expressions:\n * #define MAX(a,b) ({ typeof(a) _a=(a); typeof(b) _b=(b); _a>_b?_a:_b; })\n */\n\nint main() {\n    printf(\"SQUARE(2+3) = %d\\n\", SQUARE(2+3));  // 25\n    printf(\"MAX(1, 2) * 10 = %d\\n\", MAX(1, 2) * 10);  // 20\n    printf(\"10 * DOUBLE(5) = %d\\n\", 10 * DOUBLE(5));  // 100\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Always wrap parameters in parentheses",
      "do-while(0) for multi-statement macros"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Predefined Macros",
    "difficulty": 2,
    "description": "Use predefined macros for debugging output.",
    "starterCode": "#include <stdio.h>\n\n// Create a LOG macro that prints:\n// [filename:line] function_name: message\n// Use __FILE__, __LINE__, __func__\n\nint main() {\n    LOG(\"Program started\");\n    \n    for (int i = 0; i < 3; i++) {\n        LOG(\"In loop iteration\");\n    }\n    \n    LOG(\"Program ending\");\n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define LOG(msg) printf(\"[%s:%d] %s: %s\\n\", \\\n    __FILE__, __LINE__, __func__, msg)\n\n// More advanced version with format string\n#define LOGF(fmt, ...) printf(\"[%s:%d] %s: \" fmt \"\\n\", \\\n    __FILE__, __LINE__, __func__, ##__VA_ARGS__)\n\nint main() {\n    LOG(\"Program started\");\n    \n    for (int i = 0; i < 3; i++) {\n        LOG(\"In loop iteration\");\n    }\n    \n    LOG(\"Program ending\");\n    return 0;\n}\n\n/* Predefined macros:\n * __FILE__ - current source file name\n * __LINE__ - current line number\n * __func__ - current function name (C99)\n * __DATE__ - compilation date\n * __TIME__ - compilation time\n * __STDC__ - 1 if standard C compiler\n */",
    "testCases": [],
    "hints": [
      "__FILE__ gives filename as string",
      "__LINE__ gives line number as int"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Compilation Stages (Written)",
    "difficulty": 2,
    "description": "This is a written exercise. Explain the C compilation process.",
    "starterCode": "/* WRITTEN EXERCISE - C Compilation Stages */\n\n/*\n * For this source file:\n *\n * #include <stdio.h>\n * #define MSG \"Hello\"\n * int main() {\n *     printf(\"%s\\n\", MSG);\n *     return 0;\n * }\n *\n * Explain what happens at each stage:\n *\n * 1. PREPROCESSING (cpp or gcc -E)\n *    Input: .c file\n *    Output: ?\n *    What happens:\n *\n * 2. COMPILATION (gcc -S)\n *    Input: preprocessed source\n *    Output: ?\n *    What happens:\n *\n * 3. ASSEMBLY (as or gcc -c)\n *    Input: assembly file\n *    Output: ?\n *    What happens:\n *\n * 4. LINKING (ld or gcc)\n *    Input: object files\n *    Output: ?\n *    What happens:\n *\n * Also explain:\n * - What is a symbol table?\n * - What is relocation?\n * - Static vs dynamic linking?\n */",
    "solution": "/* ANSWERS */\n\n/*\n * 1. PREPROCESSING (cpp or gcc -E)\n *    Input: source.c\n *    Output: preprocessed source (expanded, still text)\n *    What happens:\n *    - #include files are inserted\n *    - Macros are expanded (MSG -> \"Hello\")\n *    - Conditional compilation (#ifdef) resolved\n *    - Comments removed\n *    - Line continuation (\\) processed\n *\n * 2. COMPILATION (gcc -S)\n *    Input: preprocessed source\n *    Output: assembly file (.s)\n *    What happens:\n *    - Lexical analysis (tokenization)\n *    - Syntax analysis (parsing, AST)\n *    - Semantic analysis (type checking)\n *    - Optimization\n *    - Code generation to assembly\n *\n * 3. ASSEMBLY (as or gcc -c)\n *    Input: assembly file (.s)\n *    Output: object file (.o)\n *    What happens:\n *    - Assembly instructions -> machine code\n *    - Creates symbol table\n *    - Creates relocation entries for external refs\n *    - Organizes into sections (.text, .data, .bss)\n *\n * 4. LINKING (ld or gcc)\n *    Input: object files, libraries\n *    Output: executable or library\n *    What happens:\n *    - Symbol resolution (match declarations to definitions)\n *    - Relocation (assign final addresses)\n *    - Combine sections from all inputs\n *    - Add startup code (_start -> main)\n *\n * Symbol Table:\n *    List of all symbols (functions, variables) with:\n *    - Name, type, size\n *    - Section (.text, .data)\n *    - Binding (local, global, weak)\n *\n * Relocation:\n *    Adjusting addresses in code/data when final\n *    layout is determined. During compilation, addresses\n *    are placeholder; linker fills in real addresses.\n *\n * Static Linking:\n *    - Library code copied into executable\n *    - Larger executable, no dependencies\n *    - Faster startup, no version issues\n *\n * Dynamic Linking:\n *    - Library loaded at runtime (.so/.dll)\n *    - Smaller executable, shared libraries\n *    - Updates without recompilation\n *    - Potential \"DLL hell\" version conflicts\n */",
    "testCases": [],
    "hints": [
      "gcc -E shows preprocessing, gcc -S shows assembly",
      "Object files contain machine code but unresolved references"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Variadic Macros",
    "difficulty": 4,
    "description": "Create a variadic macro for formatted debug output.",
    "starterCode": "#include <stdio.h>\n\n// Define DEBUG_PRINTF(fmt, ...) macro\n// Should work like printf but only when DEBUG is defined\n// Should prefix output with \"[DEBUG] \"\n\n#define DEBUG\n\nint main() {\n    int x = 42;\n    double pi = 3.14;\n    \n    DEBUG_PRINTF(\"Value of x: %d\\n\", x);\n    DEBUG_PRINTF(\"Pi is approximately %.2f\\n\", pi);\n    DEBUG_PRINTF(\"Sum: %d\\n\", x + 10);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define DEBUG\n\n#ifdef DEBUG\n    #define DEBUG_PRINTF(fmt, ...) \\\n        printf(\"[DEBUG] \" fmt, ##__VA_ARGS__)\n#else\n    #define DEBUG_PRINTF(fmt, ...)\n#endif\n\n// Alternative with file/line info:\n#ifdef DEBUG\n    #define DEBUG_LOG(fmt, ...) \\\n        printf(\"[%s:%d] \" fmt, __FILE__, __LINE__, ##__VA_ARGS__)\n#else\n    #define DEBUG_LOG(fmt, ...)\n#endif\n\nint main() {\n    int x = 42;\n    double pi = 3.14;\n    \n    DEBUG_PRINTF(\"Value of x: %d\\n\", x);\n    DEBUG_PRINTF(\"Pi is approximately %.2f\\n\", pi);\n    DEBUG_PRINTF(\"Sum: %d\\n\", x + 10);\n    \n    return 0;\n}\n\n/* Notes:\n * __VA_ARGS__ expands to all variadic arguments\n * ## before __VA_ARGS__ removes trailing comma if empty\n * String literal concatenation: \"a\" \"b\" becomes \"ab\"\n */",
    "testCases": [],
    "hints": [
      "__VA_ARGS__ captures variadic arguments",
      "## removes comma if no args"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Assert Macro",
    "difficulty": 3,
    "description": "Implement your own ASSERT macro similar to standard assert.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\n// Define MY_ASSERT(condition) macro\n// If condition is false:\n//   Print \"Assertion failed: condition, file X, line Y\"\n//   Exit with code 1\n// If NDEBUG is defined, ASSERT should do nothing\n\n// Don't define NDEBUG to enable assertions\n// #define NDEBUG\n\nint divide(int a, int b) {\n    MY_ASSERT(b != 0);\n    return a / b;\n}\n\nint main() {\n    printf(\"%d\\n\", divide(10, 2));\n    printf(\"%d\\n\", divide(10, 0));  // Should fail\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\n// #define NDEBUG  // Uncomment to disable assertions\n\n#ifdef NDEBUG\n    #define MY_ASSERT(condition) ((void)0)\n#else\n    #define MY_ASSERT(condition) \\\n        do { \\\n            if (!(condition)) { \\\n                fprintf(stderr, \\\n                    \"Assertion failed: %s, file %s, line %d\\n\", \\\n                    #condition, __FILE__, __LINE__); \\\n                abort(); \\\n            } \\\n        } while (0)\n#endif\n\nint divide(int a, int b) {\n    MY_ASSERT(b != 0);\n    return a / b;\n}\n\nint main() {\n    printf(\"%d\\n\", divide(10, 2));\n    printf(\"%d\\n\", divide(10, 0));  // Triggers assertion\n    return 0;\n}\n\n/* Notes:\n * #condition stringifies the condition for error message\n * do-while(0) allows use in any statement context\n * abort() terminates with signal (unlike exit)\n * ((void)0) is a no-op that avoids warnings\n */",
    "testCases": [],
    "hints": [
      "Use # to stringify condition",
      "abort() for abnormal termination"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Feature Test Macros (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Explain feature test macros.",
    "starterCode": "/* WRITTEN EXERCISE - Feature Test Macros */\n\n/*\n * Research and explain these topics:\n *\n * 1. What are feature test macros?\n *\n * 2. What does _POSIX_C_SOURCE do?\n *\n * 3. What does _GNU_SOURCE do?\n *\n * 4. What is _XOPEN_SOURCE?\n *\n * 5. Why must these be defined BEFORE any #includes?\n *\n * 6. Write example code that uses strdup() - explain\n *    which feature test macro is needed.\n *\n * 7. What is the relationship between C standards\n *    and POSIX standards?\n */",
    "solution": "/* ANSWERS */\n\n/*\n * 1. Feature Test Macros:\n *    Macros that control which functions/declarations\n *    are visible from system headers. They select which\n *    standard or extension set to expose.\n *\n * 2. _POSIX_C_SOURCE:\n *    Exposes POSIX functions. Value indicates version:\n *    - 1: POSIX.1-1990\n *    - 2: POSIX.2-1992 (adds regex, etc.)\n *    - 199309L: POSIX.1b-1993 (real-time)\n *    - 199506L: POSIX.1c-1995 (threads)\n *    - 200112L: POSIX.1-2001\n *    - 200809L: POSIX.1-2008\n *\n * 3. _GNU_SOURCE:\n *    Enables all GNU extensions plus POSIX/BSD/SVID.\n *    Very permissive, but non-portable. Includes:\n *    - strdup, strndup, asprintf\n *    - getline, getdelim\n *    - Various Linux-specific functions\n *\n * 4. _XOPEN_SOURCE:\n *    Exposes X/Open (XSI) functions:\n *    - 500: SUSv2 (Single UNIX Spec v2)\n *    - 600: SUSv3 / POSIX.1-2001 + XSI\n *    - 700: SUSv4 / POSIX.1-2008 + XSI\n *\n * 5. Why before includes:\n *    Headers use #ifdef to conditionally declare functions.\n *    The macro must be defined when the header is first\n *    processed to affect declarations.\n *\n * 6. strdup example:\n */\n\n#define _POSIX_C_SOURCE 200809L  // Or _GNU_SOURCE\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main() {\n    char *original = \"Hello\";\n    char *copy = strdup(original);  // POSIX, not standard C\n    printf(\"%s\\n\", copy);\n    free(copy);\n    return 0;\n}\n\n/*\n * 7. C vs POSIX:\n *    - C standard defines the core language\n *    - POSIX extends C with OS interfaces\n *    - POSIX requires a conforming C implementation\n *    - C99/C11 are independent of POSIX\n *    - POSIX adds: threads, signals, file ops, IPC\n */",
    "testCases": [],
    "hints": [
      "Feature test macros must come before includes",
      "_GNU_SOURCE is most permissive but least portable"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t6-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-6",
    "title": "Build System Design (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. Design a build system for a medium project.",
    "starterCode": "/* WRITTEN EXERCISE - Build System Design */\n\n/*\n * You have a project with this structure:\n *\n * project/\n *  src/\n *     main.c\n *     config.c\n *     utils.c\n *  lib/\n *     network.c\n *     network.h\n *     crypto.c\n *     crypto.h\n *  include/\n *     config.h\n *     utils.h\n *  tests/\n *      test_network.c\n *      test_crypto.c\n *\n * Design:\n *\n * 1. A Makefile that:\n *    - Compiles src/ to build/obj/\n *    - Creates static library from lib/\n *    - Links into build/program\n *    - Has debug and release configurations\n *    - Has test target\n *    - Has clean target\n *\n * 2. Explain your design choices:\n *    - Directory structure\n *    - Variable naming\n *    - Pattern rules vs explicit rules\n *    - Handling dependencies\n */",
    "solution": "# Complete Makefile\n\n# Compiler and flags\nCC = gcc\nCFLAGS_COMMON = -Wall -Wextra -I./include -I./lib\nCFLAGS_DEBUG = $(CFLAGS_COMMON) -g -DDEBUG\nCFLAGS_RELEASE = $(CFLAGS_COMMON) -O2 -DNDEBUG\n\n# Default to debug\nCFLAGS ?= $(CFLAGS_DEBUG)\n\n# Directories\nSRC_DIR = src\nLIB_DIR = lib\nTEST_DIR = tests\nBUILD_DIR = build\nOBJ_DIR = $(BUILD_DIR)/obj\n\n# Files\nSRCS = $(wildcard $(SRC_DIR)/*.c)\nLIB_SRCS = $(wildcard $(LIB_DIR)/*.c)\nTEST_SRCS = $(wildcard $(TEST_DIR)/*.c)\n\nOBJS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRCS))\nLIB_OBJS = $(patsubst $(LIB_DIR)/%.c,$(OBJ_DIR)/lib_%.o,$(LIB_SRCS))\nTEST_BINS = $(patsubst $(TEST_DIR)/%.c,$(BUILD_DIR)/%,$(TEST_SRCS))\n\nLIBRARY = $(BUILD_DIR)/libproject.a\nPROGRAM = $(BUILD_DIR)/program\n\n# Phony targets\n.PHONY: all debug release clean test dirs\n\n# Default target\nall: dirs $(PROGRAM)\n\n# Create directories\ndirs:\n\t@mkdir -p $(OBJ_DIR)\n\n# Debug build\ndebug: CFLAGS = $(CFLAGS_DEBUG)\ndebug: all\n\n# Release build\nrelease: CFLAGS = $(CFLAGS_RELEASE)\nrelease: clean all\n\n# Link program\n$(PROGRAM): $(OBJS) $(LIBRARY)\n\t$(CC) $(CFLAGS) -o $@ $(OBJS) -L$(BUILD_DIR) -lproject\n\n# Static library\n$(LIBRARY): $(LIB_OBJS)\n\tar rcs $@ $^\n\n# Compile source files\n$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\n# Compile library files\n$(OBJ_DIR)/lib_%.o: $(LIB_DIR)/%.c\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\n# Test targets\ntest: $(TEST_BINS)\n\t@for t in $(TEST_BINS); do echo \"Running $$t\"; ./$$t; done\n\n$(BUILD_DIR)/test_%: $(TEST_DIR)/test_%.c $(LIBRARY)\n\t$(CC) $(CFLAGS) -o $@ $< -L$(BUILD_DIR) -lproject\n\n# Clean\nclean:\n\trm -rf $(BUILD_DIR)\n\n# Auto-generate dependencies (for header changes)\n-include $(OBJS:.o=.d)\n-include $(LIB_OBJS:.o=.d)\n\n$(OBJ_DIR)/%.d: $(SRC_DIR)/%.c | dirs\n\t$(CC) $(CFLAGS) -MM -MT $(OBJ_DIR)/$*.o $< > $@\n\n/* DESIGN CHOICES:\n *\n * 1. Out-of-source build (build/ directory)\n *    - Keeps source tree clean\n *    - Easy to clean with rm -rf build\n *\n * 2. Separate library\n *    - Reusable by tests\n *    - Clear module boundary\n *\n * 3. Pattern rules (%.o: %.c)\n *    - Reduces repetition\n *    - Scales automatically\n *\n * 4. Automatic dependencies\n *    - -include pulls in .d files\n *    - Rebuild when headers change\n *\n * 5. Debug/Release configs\n *    - Target-specific variables\n *    - Release cleans first to ensure full rebuild\n */",
    "testCases": [],
    "hints": [
      "Use wildcard for file discovery",
      "patsubst for path transformations"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex01",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Bitwise Basics",
    "difficulty": 1,
    "description": "Practice basic bitwise AND, OR, XOR operations.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    unsigned int a = 12;  // 1100 in binary\n    unsigned int b = 10;  // 1010 in binary\n    \n    // Calculate and print:\n    // a AND b\n    // a OR b\n    // a XOR b\n    // NOT a (lower 4 bits only)\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    unsigned int a = 12;  // 1100\n    unsigned int b = 10;  // 1010\n    \n    printf(\"a & b = %u\\n\", a & b);   // 8  (1000)\n    printf(\"a | b = %u\\n\", a | b);   // 14 (1110)\n    printf(\"a ^ b = %u\\n\", a ^ b);   // 6  (0110)\n    printf(\"~a (4 bits) = %u\\n\", (~a) & 0xF);  // 3 (0011)\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "& is AND, | is OR, ^ is XOR, ~ is NOT",
      "Mask with 0xF to keep only 4 bits"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex02",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Bit Shifting",
    "difficulty": 2,
    "description": "Use left and right shift operators.",
    "starterCode": "#include <stdio.h>\n\nint main() {\n    unsigned int x = 1;\n    \n    // Print x shifted left by 0, 1, 2, 3, 4 positions\n    // Print 16 shifted right by 0, 1, 2, 3, 4 positions\n    // Show relationship to multiplication/division by 2\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nint main() {\n    unsigned int x = 1;\n    \n    printf(\"Left shifts (multiply by 2):\\n\");\n    for (int i = 0; i <= 4; i++) {\n        printf(\"1 << %d = %u\\n\", i, x << i);\n    }\n    \n    printf(\"\\nRight shifts (divide by 2):\\n\");\n    unsigned int y = 16;\n    for (int i = 0; i <= 4; i++) {\n        printf(\"16 >> %d = %u\\n\", i, y >> i);\n    }\n    \n    // Demonstrate: left shift = multiply by 2^n\n    printf(\"\\n5 * 8 = 5 << 3 = %u\\n\", 5 << 3);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "<< shifts left, >> shifts right",
      "Left shift by n = multiply by 2^n"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex03",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Set, Clear, Toggle Bits",
    "difficulty": 2,
    "description": "Implement functions to manipulate individual bits.",
    "starterCode": "#include <stdio.h>\n\n// Set bit n to 1\nunsigned int set_bit(unsigned int value, int n) {\n    // Your code\n}\n\n// Clear bit n to 0\nunsigned int clear_bit(unsigned int value, int n) {\n    // Your code\n}\n\n// Toggle bit n\nunsigned int toggle_bit(unsigned int value, int n) {\n    // Your code\n}\n\n// Check if bit n is set\nint is_bit_set(unsigned int value, int n) {\n    // Your code\n}\n\nint main() {\n    unsigned int x = 0;\n    x = set_bit(x, 0);    // Set bit 0\n    x = set_bit(x, 2);    // Set bit 2\n    printf(\"After setting bits 0,2: %u\\n\", x);  // 5\n    \n    x = clear_bit(x, 0);  // Clear bit 0\n    printf(\"After clearing bit 0: %u\\n\", x);    // 4\n    \n    x = toggle_bit(x, 3); // Toggle bit 3\n    printf(\"After toggling bit 3: %u\\n\", x);    // 12\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nunsigned int set_bit(unsigned int value, int n) {\n    return value | (1U << n);\n}\n\nunsigned int clear_bit(unsigned int value, int n) {\n    return value & ~(1U << n);\n}\n\nunsigned int toggle_bit(unsigned int value, int n) {\n    return value ^ (1U << n);\n}\n\nint is_bit_set(unsigned int value, int n) {\n    return (value & (1U << n)) != 0;\n}\n\nint main() {\n    unsigned int x = 0;\n    x = set_bit(x, 0);\n    x = set_bit(x, 2);\n    printf(\"After setting bits 0,2: %u\\n\", x);  // 5\n    \n    x = clear_bit(x, 0);\n    printf(\"After clearing bit 0: %u\\n\", x);    // 4\n    \n    x = toggle_bit(x, 3);\n    printf(\"After toggling bit 3: %u\\n\", x);    // 12\n    \n    printf(\"\\nBit 2 is %s\\n\", is_bit_set(x, 2) ? \"set\" : \"not set\");\n    printf(\"Bit 0 is %s\\n\", is_bit_set(x, 0) ? \"set\" : \"not set\");\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Set: OR with mask",
      "Clear: AND with inverted mask",
      "Toggle: XOR with mask"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex04",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Count Set Bits",
    "difficulty": 3,
    "description": "Implement a function to count the number of 1 bits (popcount).",
    "starterCode": "#include <stdio.h>\n\n// Count number of 1 bits in value\nint count_bits(unsigned int value) {\n    // Your code - try multiple approaches\n}\n\nint main() {\n    printf(\"count_bits(0) = %d\\n\", count_bits(0));       // 0\n    printf(\"count_bits(1) = %d\\n\", count_bits(1));       // 1\n    printf(\"count_bits(7) = %d\\n\", count_bits(7));       // 3\n    printf(\"count_bits(255) = %d\\n\", count_bits(255));   // 8\n    printf(\"count_bits(0xFFFFFFFF) = %d\\n\", count_bits(0xFFFFFFFF)); // 32\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n// Method 1: Simple loop\nint count_bits_v1(unsigned int value) {\n    int count = 0;\n    while (value) {\n        count += value & 1;\n        value >>= 1;\n    }\n    return count;\n}\n\n// Method 2: Brian Kernighan's algorithm\n// Each iteration clears the lowest set bit\nint count_bits(unsigned int value) {\n    int count = 0;\n    while (value) {\n        value &= (value - 1);  // Clear lowest set bit\n        count++;\n    }\n    return count;\n}\n\n// Method 3: Lookup table (fastest for many calls)\nstatic const int bit_count[256] = {\n    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,  // 0-15\n    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,  // 16-31\n    // ... (full table would have 256 entries)\n};\n\nint main() {\n    printf(\"count_bits(0) = %d\\n\", count_bits(0));\n    printf(\"count_bits(1) = %d\\n\", count_bits(1));\n    printf(\"count_bits(7) = %d\\n\", count_bits(7));\n    printf(\"count_bits(255) = %d\\n\", count_bits(255));\n    printf(\"count_bits(0xFFFFFFFF) = %d\\n\", count_bits(0xFFFFFFFF));\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "x & (x-1) clears the lowest set bit",
      "Kernighan method: loop count = bit count"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex05",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Bit Fields",
    "difficulty": 3,
    "description": "Use bit fields in a structure for compact data storage.",
    "starterCode": "#include <stdio.h>\n\n// Define a structure for a date using bit fields:\n// - day: 5 bits (1-31)\n// - month: 4 bits (1-12)\n// - year: 12 bits (0-4095, store as offset from 1900)\n\ntypedef struct {\n    // Your bit field definitions\n} PackedDate;\n\nvoid print_date(PackedDate d) {\n    // Print in YYYY-MM-DD format\n}\n\nint main() {\n    printf(\"Size of PackedDate: %zu bytes\\n\", sizeof(PackedDate));\n    \n    PackedDate today;\n    // Set to 2024-06-15\n    \n    print_date(today);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef struct {\n    unsigned int day   : 5;   // 1-31\n    unsigned int month : 4;   // 1-12\n    unsigned int year  : 12;  // Offset from 1900\n} PackedDate;\n\nvoid print_date(PackedDate d) {\n    printf(\"%04d-%02d-%02d\\n\", d.year + 1900, d.month, d.day);\n}\n\nPackedDate make_date(int year, int month, int day) {\n    PackedDate d;\n    d.year = year - 1900;\n    d.month = month;\n    d.day = day;\n    return d;\n}\n\nint main() {\n    printf(\"Size of PackedDate: %zu bytes\\n\", sizeof(PackedDate));\n    // Usually 4 bytes (vs 12 for 3 ints)\n    \n    PackedDate today = make_date(2024, 6, 15);\n    print_date(today);  // 2024-06-15\n    \n    // Direct assignment\n    PackedDate other;\n    other.day = 25;\n    other.month = 12;\n    other.year = 2023 - 1900;\n    print_date(other);  // 2023-12-25\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "unsigned int field : bits;",
      "Total bits can fit in fewer bytes"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex06",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Union Basics",
    "difficulty": 2,
    "description": "Demonstrate union memory sharing.",
    "starterCode": "#include <stdio.h>\n\n// Define a union that can hold:\n// - an int (i)\n// - a float (f)\n// - a char array of 4 (c)\n\nunion Data {\n    // Your members\n};\n\nint main() {\n    union Data d;\n    \n    // Show that all members share memory:\n    printf(\"Size of union: %zu\\n\", sizeof(d));\n    printf(\"Address of d.i: %p\\n\", (void*)&d.i);\n    printf(\"Address of d.f: %p\\n\", (void*)&d.f);\n    printf(\"Address of d.c: %p\\n\", (void*)&d.c);\n    \n    // Demonstrate memory sharing\n    d.i = 0x41424344;\n    printf(\"\\nd.i = 0x%X\\n\", d.i);\n    printf(\"d.c = %c%c%c%c\\n\", d.c[0], d.c[1], d.c[2], d.c[3]);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char c[4];\n};\n\nint main() {\n    union Data d;\n    \n    printf(\"Size of union: %zu\\n\", sizeof(d));  // 4\n    printf(\"Address of d.i: %p\\n\", (void*)&d.i);\n    printf(\"Address of d.f: %p\\n\", (void*)&d.f);\n    printf(\"Address of d.c: %p\\n\", (void*)&d.c);\n    // All addresses are the same!\n    \n    // Demonstrate memory sharing\n    d.i = 0x41424344;  // ASCII: DCBA (little-endian)\n    printf(\"\\nd.i = 0x%X\\n\", d.i);\n    printf(\"d.c = %c%c%c%c\\n\", d.c[0], d.c[1], d.c[2], d.c[3]);\n    // On little-endian: DCBA\n    \n    // Float representation\n    d.f = 3.14f;\n    printf(\"\\nFloat 3.14 as int: 0x%X\\n\", d.i);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "All union members share same memory location",
      "Size of union = size of largest member"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex07",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Tagged Union",
    "difficulty": 3,
    "description": "Implement a tagged union for a variant type.",
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\n// Define an enum for value types\ntypedef enum {\n    TYPE_INT,\n    TYPE_FLOAT,\n    TYPE_STRING\n} ValueType;\n\n// Define a tagged union that can hold int, float, or string\ntypedef struct {\n    ValueType type;\n    union {\n        // Your union members\n    } data;\n} Value;\n\nvoid print_value(Value v) {\n    // Print based on type\n}\n\nint main() {\n    Value v1, v2, v3;\n    \n    // Create int value\n    v1.type = TYPE_INT;\n    v1.data.i = 42;\n    \n    // Create float value\n    // ...\n    \n    // Create string value\n    // ...\n    \n    print_value(v1);\n    print_value(v2);\n    print_value(v3);\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <string.h>\n\ntypedef enum {\n    TYPE_INT,\n    TYPE_FLOAT,\n    TYPE_STRING\n} ValueType;\n\ntypedef struct {\n    ValueType type;\n    union {\n        int i;\n        float f;\n        char s[32];\n    } data;\n} Value;\n\nValue make_int(int i) {\n    Value v;\n    v.type = TYPE_INT;\n    v.data.i = i;\n    return v;\n}\n\nValue make_float(float f) {\n    Value v;\n    v.type = TYPE_FLOAT;\n    v.data.f = f;\n    return v;\n}\n\nValue make_string(const char* s) {\n    Value v;\n    v.type = TYPE_STRING;\n    strncpy(v.data.s, s, 31);\n    v.data.s[31] = '\\0';\n    return v;\n}\n\nvoid print_value(Value v) {\n    switch (v.type) {\n        case TYPE_INT:\n            printf(\"Int: %d\\n\", v.data.i);\n            break;\n        case TYPE_FLOAT:\n            printf(\"Float: %.2f\\n\", v.data.f);\n            break;\n        case TYPE_STRING:\n            printf(\"String: %s\\n\", v.data.s);\n            break;\n    }\n}\n\nint main() {\n    Value v1 = make_int(42);\n    Value v2 = make_float(3.14f);\n    Value v3 = make_string(\"Hello\");\n    \n    print_value(v1);\n    print_value(v2);\n    print_value(v3);\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "Enum tracks which member is active",
      "Switch on type to access correct member"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex08",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Enum with Values",
    "difficulty": 2,
    "description": "Define enums with explicit values and use in switch.",
    "starterCode": "#include <stdio.h>\n\n// Define HTTP status code enum with values:\n// OK = 200, CREATED = 201, BAD_REQUEST = 400,\n// UNAUTHORIZED = 401, NOT_FOUND = 404, SERVER_ERROR = 500\n\ntypedef enum {\n    // Your enum values\n} HttpStatus;\n\nconst char* status_message(HttpStatus status) {\n    // Return appropriate message for each status\n}\n\nint main() {\n    HttpStatus codes[] = {OK, CREATED, NOT_FOUND, SERVER_ERROR};\n    int n = sizeof(codes) / sizeof(codes[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d: %s\\n\", codes[i], status_message(codes[i]));\n    }\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\ntypedef enum {\n    OK = 200,\n    CREATED = 201,\n    BAD_REQUEST = 400,\n    UNAUTHORIZED = 401,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n} HttpStatus;\n\nconst char* status_message(HttpStatus status) {\n    switch (status) {\n        case OK: return \"OK\";\n        case CREATED: return \"Created\";\n        case BAD_REQUEST: return \"Bad Request\";\n        case UNAUTHORIZED: return \"Unauthorized\";\n        case NOT_FOUND: return \"Not Found\";\n        case SERVER_ERROR: return \"Internal Server Error\";\n        default: return \"Unknown\";\n    }\n}\n\nint main() {\n    HttpStatus codes[] = {OK, CREATED, NOT_FOUND, SERVER_ERROR};\n    int n = sizeof(codes) / sizeof(codes[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d: %s\\n\", codes[i], status_message(codes[i]));\n    }\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "NAME = value assigns explicit value",
      "Default: always handle in switch"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex09",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Volatile Keyword",
    "difficulty": 3,
    "description": "Demonstrate the need for volatile in hardware/signal contexts.",
    "starterCode": "#include <stdio.h>\n#include <signal.h>\n\n// This flag MUST be volatile - explain why\nvolatile int running = 1;\n\nvoid signal_handler(int sig) {\n    running = 0;\n}\n\nint main() {\n    // Set up SIGINT handler\n    signal(SIGINT, signal_handler);\n    \n    printf(\"Press Ctrl+C to stop...\\n\");\n    \n    // Busy wait loop\n    while (running) {\n        // Do nothing\n    }\n    \n    printf(\"Stopped!\\n\");\n    return 0;\n}\n\n/* WRITTEN PART:\n * Explain:\n * 1. What would happen if 'running' was not volatile?\n * 2. When else is volatile needed?\n * 3. Does volatile make access thread-safe?\n */",
    "solution": "#include <stdio.h>\n#include <signal.h>\n\nvolatile sig_atomic_t running = 1;\n\nvoid signal_handler(int sig) {\n    (void)sig;  // Suppress unused warning\n    running = 0;\n}\n\nint main() {\n    signal(SIGINT, signal_handler);\n    \n    printf(\"Press Ctrl+C to stop...\\n\");\n    \n    while (running) {\n        // Without volatile, compiler might optimize to:\n        // if (running) while(1) {}\n    }\n    \n    printf(\"Stopped!\\n\");\n    return 0;\n}\n\n/* ANSWERS:\n *\n * 1. Without volatile:\n *    The compiler may optimize the loop to:\n *      if (running) while(1) {}\n *    because it doesn't see 'running' change in the loop.\n *    The program would never exit even after Ctrl+C.\n *\n * 2. volatile is needed for:\n *    - Signal handlers (as shown)\n *    - Memory-mapped I/O registers\n *    - Variables modified by interrupts\n *    - Variables shared with DMA\n *    - Polling hardware status registers\n *\n * 3. volatile is NOT thread-safe:\n *    - It only prevents compiler optimizations\n *    - Does NOT provide atomicity\n *    - Does NOT provide memory ordering\n *    - For threads, use _Atomic or mutexes\n *    - sig_atomic_t is atomic for signals only\n */",
    "testCases": [],
    "hints": [
      "volatile prevents compiler from caching variable",
      "sig_atomic_t for signal-safe integer"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex10",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Variadic Function",
    "difficulty": 3,
    "description": "Implement a variadic function that sums any number of integers.",
    "starterCode": "#include <stdio.h>\n#include <stdarg.h>\n\n// Sum n integers passed as arguments\nint sum(int count, ...) {\n    // Use va_list, va_start, va_arg, va_end\n}\n\nint main() {\n    printf(\"sum(3, 1, 2, 3) = %d\\n\", sum(3, 1, 2, 3));  // 6\n    printf(\"sum(5, 10, 20, 30, 40, 50) = %d\\n\", \n           sum(5, 10, 20, 30, 40, 50));  // 150\n    printf(\"sum(0) = %d\\n\", sum(0));  // 0\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdarg.h>\n\nint sum(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    \n    int total = 0;\n    for (int i = 0; i < count; i++) {\n        total += va_arg(args, int);\n    }\n    \n    va_end(args);\n    return total;\n}\n\n// Alternative: sentinel-based (like printf)\ndouble avg_sentinel(double first, ...) {\n    if (first < 0) return 0;  // Sentinel\n    \n    va_list args;\n    va_start(args, first);\n    \n    double sum = first;\n    int count = 1;\n    double val;\n    \n    while ((val = va_arg(args, double)) >= 0) {\n        sum += val;\n        count++;\n    }\n    \n    va_end(args);\n    return sum / count;\n}\n\nint main() {\n    printf(\"sum(3, 1, 2, 3) = %d\\n\", sum(3, 1, 2, 3));\n    printf(\"sum(5, 10, 20, 30, 40, 50) = %d\\n\", \n           sum(5, 10, 20, 30, 40, 50));\n    printf(\"sum(0) = %d\\n\", sum(0));\n    \n    // Sentinel example\n    printf(\"avg = %.1f\\n\", avg_sentinel(1.0, 2.0, 3.0, -1.0));\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "va_start initializes, va_arg gets next, va_end cleans up",
      "Need way to know how many args (count or sentinel)"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex11",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Mini Printf",
    "difficulty": 4,
    "description": "Implement a simplified printf supporting %d, %s, %c.",
    "starterCode": "#include <stdio.h>\n#include <stdarg.h>\n\n// Implement mini_printf supporting:\n// %d - integer\n// %s - string\n// %c - character\n// %% - literal %\n\nvoid mini_printf(const char* format, ...) {\n    // Your implementation\n}\n\nint main() {\n    mini_printf(\"Hello, %s!\\n\", \"World\");\n    mini_printf(\"Number: %d\\n\", 42);\n    mini_printf(\"Char: %c, Int: %d, Str: %s\\n\", 'A', 100, \"test\");\n    mini_printf(\"100%% complete\\n\");\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_int(int n) {\n    if (n < 0) {\n        putchar('-');\n        n = -n;\n    }\n    if (n >= 10) {\n        print_int(n / 10);\n    }\n    putchar('0' + n % 10);\n}\n\nvoid mini_printf(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    while (*format) {\n        if (*format == '%') {\n            format++;\n            switch (*format) {\n                case 'd': {\n                    int val = va_arg(args, int);\n                    print_int(val);\n                    break;\n                }\n                case 's': {\n                    char* str = va_arg(args, char*);\n                    while (*str) {\n                        putchar(*str++);\n                    }\n                    break;\n                }\n                case 'c': {\n                    // char is promoted to int\n                    int c = va_arg(args, int);\n                    putchar(c);\n                    break;\n                }\n                case '%':\n                    putchar('%');\n                    break;\n                default:\n                    putchar('%');\n                    putchar(*format);\n            }\n        } else {\n            putchar(*format);\n        }\n        format++;\n    }\n    \n    va_end(args);\n}\n\nint main() {\n    mini_printf(\"Hello, %s!\\n\", \"World\");\n    mini_printf(\"Number: %d\\n\", 42);\n    mini_printf(\"Char: %c, Int: %d, Str: %s\\n\", 'A', 100, \"test\");\n    mini_printf(\"100%% complete\\n\");\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "char is promoted to int in variadic",
      "Handle %% for literal percent"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex12",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Type Punning (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Explain type punning techniques.",
    "starterCode": "/* WRITTEN EXERCISE - Type Punning */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/*\n * Analyze these type punning techniques.\n * Explain which are valid C and why.\n */\n\nvoid method1_union() {\n    union { float f; uint32_t i; } u;\n    u.f = 3.14f;\n    printf(\"Float bits: 0x%08X\\n\", u.i);\n}\n\nvoid method2_pointer() {\n    float f = 3.14f;\n    uint32_t i = *(uint32_t*)&f;  // Is this valid?\n    printf(\"Float bits: 0x%08X\\n\", i);\n}\n\nvoid method3_memcpy() {\n    float f = 3.14f;\n    uint32_t i;\n    memcpy(&i, &f, sizeof(i));\n    printf(\"Float bits: 0x%08X\\n\", i);\n}\n\n/* Questions:\n * 1. Which methods are valid C? Which are UB?\n * 2. What is the \"strict aliasing rule\"?\n * 3. Why does method 3 (memcpy) work?\n * 4. Show how to detect endianness using unions.\n */",
    "solution": "/* ANSWERS */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/*\n * 1. Validity:\n *\n *    Method 1 (union): VALID in C99 and later.\n *    Type punning through unions is explicitly allowed.\n *\n *    Method 2 (pointer cast): UNDEFINED BEHAVIOR!\n *    Violates strict aliasing rule.\n *\n *    Method 3 (memcpy): VALID and portable.\n *    memcpy just copies bytes, no aliasing issues.\n *\n * 2. Strict Aliasing Rule:\n *    An object shall only be accessed through:\n *    - Its actual type\n *    - A signed/unsigned version of its type\n *    - A character type (char, unsigned char)\n *    \n *    float and uint32_t are not compatible, so\n *    *(uint32_t*)&float_var is UB.\n *\n * 3. Why memcpy works:\n *    memcpy treats both source and dest as arrays\n *    of unsigned char, which is allowed to alias\n *    any type. It copies raw bytes without type\n *    interpretation.\n *\n * 4. Endianness detection:\n */\n\nint is_little_endian(void) {\n    union {\n        uint32_t i;\n        uint8_t c[4];\n    } u = { .i = 0x01020304 };\n    \n    // Little-endian: 04 03 02 01 (LSB first)\n    // Big-endian:    01 02 03 04 (MSB first)\n    return u.c[0] == 0x04;\n}\n\n// Safe type punning helper\nstatic inline uint32_t float_to_bits(float f) {\n    uint32_t result;\n    memcpy(&result, &f, sizeof(result));\n    return result;\n}\n\nint main() {\n    float f = 3.14f;\n    printf(\"Float bits: 0x%08X\\n\", float_to_bits(f));\n    printf(\"Endianness: %s\\n\", \n           is_little_endian() ? \"Little\" : \"Big\");\n    return 0;\n}\n\n/*\n * Additional note on -fno-strict-aliasing:\n * GCC flag that disables strict aliasing optimizations.\n * Makes pointer casts \"work\" but not portable.\n * Linux kernel uses this flag.\n */",
    "testCases": [],
    "hints": [
      "Strict aliasing applies to pointer access",
      "memcpy with char* is always safe"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex13",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Restrict Keyword",
    "difficulty": 3,
    "description": "Demonstrate the restrict qualifier for optimization.",
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Without restrict - compiler must be conservative\nvoid add_arrays(int* a, int* b, int* c, int n) {\n    for (int i = 0; i < n; i++) {\n        c[i] = a[i] + b[i];\n    }\n}\n\n// With restrict - compiler can optimize\nvoid add_arrays_fast(int* restrict a, \n                     int* restrict b, \n                     int* restrict c, int n) {\n    for (int i = 0; i < n; i++) {\n        c[i] = a[i] + b[i];\n    }\n}\n\n/* WRITTEN PART:\n * 1. Why can the restrict version be faster?\n * 2. What promise does restrict make?\n * 3. What happens if you violate that promise?\n * 4. Where is restrict commonly used?\n */\n\nint main() {\n    // Test both versions\n    return 0;\n}",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Without restrict\nvoid add_arrays(int* a, int* b, int* c, int n) {\n    for (int i = 0; i < n; i++) {\n        // Compiler must reload a[i] and b[i] each iteration\n        // because c might alias a or b\n        c[i] = a[i] + b[i];\n    }\n}\n\n// With restrict\nvoid add_arrays_fast(int* restrict a, \n                     int* restrict b, \n                     int* restrict c, int n) {\n    for (int i = 0; i < n; i++) {\n        // Compiler knows c doesn't alias a or b\n        // Can vectorize, reorder, keep values in registers\n        c[i] = a[i] + b[i];\n    }\n}\n\n/* ANSWERS:\n *\n * 1. Why faster:\n *    Without restrict, writing to c[i] might change a[i] or b[i]\n *    (if they overlap). Compiler must reload values each iteration.\n *    With restrict, compiler knows no aliasing occurs, so it can:\n *    - Keep values in registers\n *    - Use SIMD/vector instructions\n *    - Reorder memory operations\n *\n * 2. Promise of restrict:\n *    The pointer is the only way to access that object\n *    during its scope. No other pointer will access the\n *    same memory during the lifetime of the restrict pointer.\n *\n * 3. Violating the promise:\n *    UNDEFINED BEHAVIOR. The optimization assumptions are\n *    wrong, leading to incorrect results. Example:\n *    int x = 5;\n *    int* restrict p = &x;\n *    int* q = &x;\n *    *q = 10;  // UB! q aliases p\n *\n * 4. Common uses:\n *    - memcpy (dest and src must not overlap)\n *    - BLAS/LAPACK math libraries\n *    - Image processing (separate input/output buffers)\n *    - Any function with separate in/out pointers\n */\n\nint main() {\n    int a[1000], b[1000], c[1000];\n    \n    for (int i = 0; i < 1000; i++) {\n        a[i] = i;\n        b[i] = i * 2;\n    }\n    \n    add_arrays_fast(a, b, c, 1000);\n    \n    printf(\"c[500] = %d\\n\", c[500]);  // 1500\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "restrict promises no aliasing",
      "Violation is undefined behavior"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex14",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Inline Functions",
    "difficulty": 2,
    "description": "Compare inline functions to macros.",
    "starterCode": "#include <stdio.h>\n\n// Macro version\n#define SQUARE_MACRO(x) ((x) * (x))\n\n// Inline function version\nstatic inline int square_inline(int x) {\n    return x * x;\n}\n\n/* Compare macro vs inline:\n * 1. Type safety\n * 2. Side effects\n * 3. Debugging\n * 4. Scope\n */\n\nint main() {\n    int a = 5;\n    \n    // Show problem with macro and side effects\n    printf(\"SQUARE_MACRO(a++) = %d\\n\", SQUARE_MACRO(a++));\n    printf(\"a is now %d\\n\", a);  // What value?\n    \n    a = 5;\n    printf(\"square_inline(a++) = %d\\n\", square_inline(a++));\n    printf(\"a is now %d\\n\", a);  // What value?\n    \n    return 0;\n}",
    "solution": "#include <stdio.h>\n\n#define SQUARE_MACRO(x) ((x) * (x))\n\nstatic inline int square_inline(int x) {\n    return x * x;\n}\n\n/* Comparison:\n *\n * 1. Type Safety:\n *    Macro: None - just text substitution\n *    Inline: Full type checking\n *\n * 2. Side Effects:\n *    Macro: Arguments evaluated multiple times!\n *           SQUARE_MACRO(a++) = (a++) * (a++)\n *           a is incremented TWICE\n *    Inline: Arguments evaluated once\n *\n * 3. Debugging:\n *    Macro: Harder - code is substituted\n *    Inline: Easier - real function with name\n *\n * 4. Scope:\n *    Macro: Global from definition point\n *    Inline: Normal C scoping rules\n */\n\nint main() {\n    int a = 5;\n    \n    // Macro evaluates a++ TWICE\n    printf(\"SQUARE_MACRO(a++) = %d\\n\", SQUARE_MACRO(a++));\n    // Expands to: (a++) * (a++) = 5 * 6 = 30\n    printf(\"a is now %d\\n\", a);  // 7 (incremented twice)\n    \n    a = 5;\n    // Inline evaluates a++ ONCE\n    printf(\"square_inline(a++) = %d\\n\", square_inline(a++));\n    // Evaluates to: square_inline(5), then a = 6\n    // Returns: 25\n    printf(\"a is now %d\\n\", a);  // 6 (incremented once)\n    \n    return 0;\n}\n\n/* When to use which:\n *\n * Use inline functions when:\n * - Type safety matters\n * - Arguments might have side effects\n * - Need debuggable code\n * - C99 or later\n *\n * Use macros when:\n * - Need type-generic behavior (pre-C11)\n * - Token pasting or stringification needed\n * - Compile-time constants required\n */",
    "testCases": [],
    "hints": [
      "Macro args evaluated each time used",
      "Inline is type-safe function"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex15",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Compound Literals (Written)",
    "difficulty": 3,
    "description": "This is a written exercise. Explain and use compound literals.",
    "starterCode": "/* WRITTEN EXERCISE - Compound Literals (C99) */\n\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nvoid print_point(Point p) {\n    printf(\"(%d, %d)\\n\", p.x, p.y);\n}\n\nvoid print_array(int* arr, int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\n/* Explain compound literals and show examples:\n *\n * 1. What is a compound literal?\n *\n * 2. Show how to use with:\n *    - Struct initialization\n *    - Array initialization\n *    - Function arguments\n *\n * 3. What is the storage duration of a compound literal?\n *\n * 4. Can compound literals be modified?\n *\n * Write example code using compound literals:\n */\n\nint main() {\n    // Your examples here\n    return 0;\n}",
    "solution": "/* ANSWERS */\n\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nvoid print_point(Point p) {\n    printf(\"(%d, %d)\\n\", p.x, p.y);\n}\n\nvoid print_array(int* arr, int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\n/*\n * 1. Compound Literal:\n *    A way to create unnamed objects of a specified type.\n *    Syntax: (type){ initializer-list }\n *    Provides an lvalue, so you can take its address.\n *\n * 2. Examples below in main()\n *\n * 3. Storage Duration:\n *    - Block scope: automatic (like local variables)\n *    - File scope: static\n *    Within a block, lifetime is until end of block.\n *\n * 4. Modification:\n *    Yes, compound literals are modifiable lvalues\n *    (unless the type includes const).\n */\n\nint main() {\n    // Example 1: Struct as function argument\n    print_point((Point){3, 4});\n    \n    // Example 2: Array as function argument\n    print_array((int[]){1, 2, 3, 4, 5}, 5);\n    \n    // Example 3: Pointer to compound literal\n    int* p = (int[]){10, 20, 30};\n    printf(\"p[1] = %d\\n\", p[1]);\n    \n    // Example 4: Modifiable\n    Point* pt = &(Point){0, 0};\n    pt->x = 100;  // OK to modify\n    print_point(*pt);\n    \n    // Example 5: Const compound literal\n    const int* cp = (const int[]){1, 2, 3};\n    // cp[0] = 10;  // Error: const\n    \n    // Example 6: Nested initialization\n    struct { Point p; int z; } point3d = \n        {.p = (Point){1, 2}, .z = 3};\n    printf(\"3D: (%d, %d, %d)\\n\", \n           point3d.p.x, point3d.p.y, point3d.z);\n    \n    // WARNING: Don't return pointer to local compound literal!\n    // int* bad(void) { return (int[]){1,2,3}; }  // UB!\n    \n    return 0;\n}",
    "testCases": [],
    "hints": [
      "(type){...} creates unnamed object",
      "Lifetime is block scope (automatic storage)"
    ],
    "language": "c"
  },
  {
    "id": "cs105-t7-ex16",
    "subjectId": "cs105",
    "topicId": "cs105-topic-7",
    "title": "Generic Selection (Written)",
    "difficulty": 4,
    "description": "This is a written exercise. Explore C11 _Generic for type-generic code.",
    "starterCode": "/* WRITTEN EXERCISE - C11 _Generic */\n\n#include <stdio.h>\n#include <math.h>\n\n/*\n * C11 introduced _Generic for compile-time type selection.\n * This enables type-generic macros similar to C++ overloading.\n *\n * Syntax:\n * _Generic(expr, \n *     type1: result1,\n *     type2: result2,\n *     default: default_result)\n *\n * Tasks:\n *\n * 1. Create a TYPE_NAME(x) macro that returns the type as a string\n *\n * 2. Create a PRINT(x) macro that works for int, double, and char*\n *\n * 3. Create an ABS(x) macro for int, float, and double\n *\n * 4. Explain limitations of _Generic\n */",
    "solution": "/* SOLUTIONS */\n\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n/* Task 1: Type name */\n#define TYPE_NAME(x) _Generic((x), \\\n    int: \"int\", \\\n    long: \"long\", \\\n    float: \"float\", \\\n    double: \"double\", \\\n    char*: \"string\", \\\n    const char*: \"string\", \\\n    default: \"unknown\")\n\n/* Task 2: Generic print */\nstatic inline void print_int(int x) { printf(\"%d\\n\", x); }\nstatic inline void print_double(double x) { printf(\"%f\\n\", x); }\nstatic inline void print_string(const char* x) { printf(\"%s\\n\", x); }\n\n#define PRINT(x) _Generic((x), \\\n    int: print_int, \\\n    double: print_double, \\\n    float: print_double, \\\n    char*: print_string, \\\n    const char*: print_string)(x)\n\n/* Task 3: Generic absolute value */\nstatic inline int abs_int(int x) { return abs(x); }\nstatic inline float abs_float(float x) { return fabsf(x); }\nstatic inline double abs_double(double x) { return fabs(x); }\n\n#define ABS(x) _Generic((x), \\\n    int: abs_int, \\\n    float: abs_float, \\\n    double: abs_double)(x)\n\nint main() {\n    // Test TYPE_NAME\n    int i = 5;\n    double d = 3.14;\n    char* s = \"hello\";\n    \n    printf(\"Type of i: %s\\n\", TYPE_NAME(i));\n    printf(\"Type of d: %s\\n\", TYPE_NAME(d));\n    printf(\"Type of s: %s\\n\", TYPE_NAME(s));\n    \n    // Test PRINT\n    PRINT(42);\n    PRINT(3.14159);\n    PRINT(\"Hello, World!\");\n    \n    // Test ABS\n    printf(\"ABS(-5) = %d\\n\", ABS(-5));\n    printf(\"ABS(-3.14f) = %f\\n\", ABS(-3.14f));\n    printf(\"ABS(-2.71) = %f\\n\", ABS(-2.71));\n    \n    return 0;\n}\n\n/*\n * Task 4: Limitations of _Generic\n *\n * 1. Compile-time only:\n *    Cannot dispatch on runtime type information.\n *    The type must be known at compile time.\n *\n * 2. No implicit conversions:\n *    Each type needs explicit handling.\n *    int and long are different, even though compatible.\n *\n * 3. No user-defined types:\n *    Must list every struct type individually.\n *    Cannot match \"all structs\" or \"all pointers\".\n *\n * 4. Expression-based:\n *    Selection is based on expression's type.\n *    Can't do pattern matching or decomposition.\n *\n * 5. Verbose:\n *    Need helper functions for each type.\n *    Much more boilerplate than C++ templates.\n *\n * 6. No recursion:\n *    Can't define recursive generic operations easily.\n *\n * 7. Pointer qualification:\n *    const char* and char* are different types.\n *    Must handle both or use default.\n */",
    "testCases": [],
    "hints": [
      "_Generic selects at compile time",
      "Need separate case for each type"
    ],
    "language": "c"
  }
]
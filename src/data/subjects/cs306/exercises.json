[
  {
    "id": "cs306-t1-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "RGB to Grayscale Conversion",
    "difficulty": 1,
    "description": "Convert an RGB color to grayscale using the luminosity method: Gray = 0.299*R + 0.587*G + 0.114*B. Return the result as an integer.",
    "starterCode": "def rgb_to_grayscale(r, g, b):\n    \"\"\"\n    Convert RGB color to grayscale.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n\n    Returns:\n        Grayscale value (0-255)\n    \"\"\"\n    pass",
    "solution": "def rgb_to_grayscale(r, g, b):\n    \"\"\"\n    Convert RGB color to grayscale.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n\n    Returns:\n        Grayscale value (0-255)\n    \"\"\"\n    gray = 0.299 * r + 0.587 * g + 0.114 * b\n    return int(gray)",
    "testCases": [
      {
        "input": "255, 0, 0",
        "expectedOutput": "76",
        "isHidden": false,
        "description": "Pure red"
      },
      {
        "input": "0, 255, 0",
        "expectedOutput": "149",
        "isHidden": false,
        "description": "Pure green"
      },
      {
        "input": "0, 0, 255",
        "expectedOutput": "29",
        "isHidden": false,
        "description": "Pure blue"
      },
      {
        "input": "128, 128, 128",
        "expectedOutput": "128",
        "isHidden": true,
        "description": "Gray color"
      }
    ],
    "hints": [
      "Use the luminosity formula: 0.299*R + 0.587*G + 0.114*B",
      "Convert the result to an integer using int()"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Cartesian to Screen Coordinates",
    "difficulty": 1,
    "description": "Convert Cartesian coordinates (origin at center, y-up) to screen coordinates (origin at top-left, y-down). Given screen dimensions and a point (x, y), return screen coordinates.",
    "starterCode": "def cartesian_to_screen(x, y, width, height):\n    \"\"\"\n    Convert Cartesian coordinates to screen coordinates.\n\n    Args:\n        x: Cartesian x coordinate\n        y: Cartesian y coordinate\n        width: Screen width\n        height: Screen height\n\n    Returns:\n        Tuple (screen_x, screen_y)\n    \"\"\"\n    pass",
    "solution": "def cartesian_to_screen(x, y, width, height):\n    \"\"\"\n    Convert Cartesian coordinates to screen coordinates.\n\n    Args:\n        x: Cartesian x coordinate\n        y: Cartesian y coordinate\n        width: Screen width\n        height: Screen height\n\n    Returns:\n        Tuple (screen_x, screen_y)\n    \"\"\"\n    screen_x = x + width / 2\n    screen_y = height / 2 - y\n    return (screen_x, screen_y)",
    "testCases": [
      {
        "input": "0, 0, 800, 600",
        "expectedOutput": "(400.0, 300.0)",
        "isHidden": false,
        "description": "Origin point"
      },
      {
        "input": "100, 100, 800, 600",
        "expectedOutput": "(500.0, 200.0)",
        "isHidden": false,
        "description": "Positive quadrant"
      },
      {
        "input": "-100, -100, 800, 600",
        "expectedOutput": "(300.0, 400.0)",
        "isHidden": false,
        "description": "Negative quadrant"
      },
      {
        "input": "400, 300, 800, 600",
        "expectedOutput": "(800.0, 0.0)",
        "isHidden": true,
        "description": "Top-right corner"
      }
    ],
    "hints": [
      "Screen x = Cartesian x + width/2",
      "Screen y = height/2 - Cartesian y (flip y-axis)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "RGB to Hexadecimal Color",
    "difficulty": 1,
    "description": "Convert RGB color values (0-255) to a hexadecimal color string in the format \"#RRGGBB\".",
    "starterCode": "def rgb_to_hex(r, g, b):\n    \"\"\"\n    Convert RGB to hexadecimal color string.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n\n    Returns:\n        Hex color string (e.g., \"#FF0000\")\n    \"\"\"\n    pass",
    "solution": "def rgb_to_hex(r, g, b):\n    \"\"\"\n    Convert RGB to hexadecimal color string.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n\n    Returns:\n        Hex color string (e.g., \"#FF0000\")\n    \"\"\"\n    return f\"#{r:02X}{g:02X}{b:02X}\"",
    "testCases": [
      {
        "input": "255, 0, 0",
        "expectedOutput": "#FF0000",
        "isHidden": false,
        "description": "Red"
      },
      {
        "input": "0, 255, 0",
        "expectedOutput": "#00FF00",
        "isHidden": false,
        "description": "Green"
      },
      {
        "input": "0, 0, 255",
        "expectedOutput": "#0000FF",
        "isHidden": false,
        "description": "Blue"
      },
      {
        "input": "128, 64, 32",
        "expectedOutput": "#804020",
        "isHidden": true,
        "description": "Custom color"
      }
    ],
    "hints": [
      "Use format string with :02X for two-digit uppercase hex",
      "Prefix with # symbol"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Alpha Blending",
    "difficulty": 2,
    "description": "Implement alpha blending between two colors. Given foreground RGB+alpha and background RGB, compute the blended color using: result = alpha * fg + (1 - alpha) * bg.",
    "starterCode": "def alpha_blend(fg_r, fg_g, fg_b, alpha, bg_r, bg_g, bg_b):\n    \"\"\"\n    Blend foreground and background colors using alpha.\n\n    Args:\n        fg_r, fg_g, fg_b: Foreground RGB (0-255)\n        alpha: Alpha value (0.0-1.0)\n        bg_r, bg_g, bg_b: Background RGB (0-255)\n\n    Returns:\n        Tuple (r, g, b) of blended color\n    \"\"\"\n    pass",
    "solution": "def alpha_blend(fg_r, fg_g, fg_b, alpha, bg_r, bg_g, bg_b):\n    \"\"\"\n    Blend foreground and background colors using alpha.\n\n    Args:\n        fg_r, fg_g, fg_b: Foreground RGB (0-255)\n        alpha: Alpha value (0.0-1.0)\n        bg_r, bg_g, bg_b: Background RGB (0-255)\n\n    Returns:\n        Tuple (r, g, b) of blended color\n    \"\"\"\n    r = int(alpha * fg_r + (1 - alpha) * bg_r)\n    g = int(alpha * fg_g + (1 - alpha) * bg_g)\n    b = int(alpha * fg_b + (1 - alpha) * bg_b)\n    return (r, g, b)",
    "testCases": [
      {
        "input": "255, 0, 0, 0.5, 0, 0, 255",
        "expectedOutput": "(127, 0, 127)",
        "isHidden": false,
        "description": "Half blend red-blue"
      },
      {
        "input": "255, 255, 255, 1.0, 0, 0, 0",
        "expectedOutput": "(255, 255, 255)",
        "isHidden": false,
        "description": "Full opacity"
      },
      {
        "input": "255, 255, 255, 0.0, 0, 0, 0",
        "expectedOutput": "(0, 0, 0)",
        "isHidden": false,
        "description": "Zero opacity"
      },
      {
        "input": "200, 100, 50, 0.3, 50, 100, 200",
        "expectedOutput": "(95, 100, 125)",
        "isHidden": true,
        "description": "Partial blend"
      }
    ],
    "hints": [
      "Formula: result = alpha * foreground + (1 - alpha) * background",
      "Apply to each RGB component separately",
      "Convert final result to integer"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Color Inversion",
    "difficulty": 1,
    "description": "Invert an RGB color by subtracting each component from 255. Return the inverted color as a tuple.",
    "starterCode": "def invert_color(r, g, b):\n    \"\"\"\n    Invert an RGB color.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n\n    Returns:\n        Tuple (r, g, b) of inverted color\n    \"\"\"\n    pass",
    "solution": "def invert_color(r, g, b):\n    \"\"\"\n    Invert an RGB color.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n\n    Returns:\n        Tuple (r, g, b) of inverted color\n    \"\"\"\n    return (255 - r, 255 - g, 255 - b)",
    "testCases": [
      {
        "input": "0, 0, 0",
        "expectedOutput": "(255, 255, 255)",
        "isHidden": false,
        "description": "Black to white"
      },
      {
        "input": "255, 0, 0",
        "expectedOutput": "(0, 255, 255)",
        "isHidden": false,
        "description": "Red to cyan"
      },
      {
        "input": "128, 128, 128",
        "expectedOutput": "(127, 127, 127)",
        "isHidden": false,
        "description": "Gray inverts to gray"
      },
      {
        "input": "100, 150, 200",
        "expectedOutput": "(155, 105, 55)",
        "isHidden": true,
        "description": "Custom color"
      }
    ],
    "hints": [
      "Invert each component: 255 - component",
      "Return as a tuple"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Pixel Index Calculation",
    "difficulty": 2,
    "description": "Calculate the index of a pixel in a 1D framebuffer array. Given (x, y) coordinates and image width, return the index. Pixels are stored row-by-row.",
    "starterCode": "def pixel_index(x, y, width):\n    \"\"\"\n    Calculate pixel index in 1D framebuffer.\n\n    Args:\n        x: Pixel x coordinate\n        y: Pixel y coordinate\n        width: Image width\n\n    Returns:\n        Index in 1D array\n    \"\"\"\n    pass",
    "solution": "def pixel_index(x, y, width):\n    \"\"\"\n    Calculate pixel index in 1D framebuffer.\n\n    Args:\n        x: Pixel x coordinate\n        y: Pixel y coordinate\n        width: Image width\n\n    Returns:\n        Index in 1D array\n    \"\"\"\n    return y * width + x",
    "testCases": [
      {
        "input": "0, 0, 800",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "First pixel"
      },
      {
        "input": "799, 0, 800",
        "expectedOutput": "799",
        "isHidden": false,
        "description": "End of first row"
      },
      {
        "input": "0, 1, 800",
        "expectedOutput": "800",
        "isHidden": false,
        "description": "Start of second row"
      },
      {
        "input": "10, 5, 100",
        "expectedOutput": "510",
        "isHidden": true,
        "description": "Middle pixel"
      }
    ],
    "hints": [
      "Formula: index = y * width + x",
      "Think of how 2D array is flattened to 1D"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "HSV to RGB Conversion",
    "difficulty": 3,
    "description": "Convert HSV (Hue, Saturation, Value) color to RGB. Hue is 0-360, Saturation and Value are 0-1. Return RGB as integers 0-255.",
    "starterCode": "def hsv_to_rgb(h, s, v):\n    \"\"\"\n    Convert HSV to RGB color.\n\n    Args:\n        h: Hue (0-360)\n        s: Saturation (0-1)\n        v: Value (0-1)\n\n    Returns:\n        Tuple (r, g, b) with values 0-255\n    \"\"\"\n    pass",
    "solution": "def hsv_to_rgb(h, s, v):\n    \"\"\"\n    Convert HSV to RGB color.\n\n    Args:\n        h: Hue (0-360)\n        s: Saturation (0-1)\n        v: Value (0-1)\n\n    Returns:\n        Tuple (r, g, b) with values 0-255\n    \"\"\"\n    c = v * s\n    x = c * (1 - abs((h / 60) % 2 - 1))\n    m = v - c\n\n    if 0 <= h < 60:\n        r_prime, g_prime, b_prime = c, x, 0\n    elif 60 <= h < 120:\n        r_prime, g_prime, b_prime = x, c, 0\n    elif 120 <= h < 180:\n        r_prime, g_prime, b_prime = 0, c, x\n    elif 180 <= h < 240:\n        r_prime, g_prime, b_prime = 0, x, c\n    elif 240 <= h < 300:\n        r_prime, g_prime, b_prime = x, 0, c\n    else:\n        r_prime, g_prime, b_prime = c, 0, x\n\n    r = int((r_prime + m) * 255)\n    g = int((g_prime + m) * 255)\n    b = int((b_prime + m) * 255)\n\n    return (r, g, b)",
    "testCases": [
      {
        "input": "0, 1, 1",
        "expectedOutput": "(255, 0, 0)",
        "isHidden": false,
        "description": "Red"
      },
      {
        "input": "120, 1, 1",
        "expectedOutput": "(0, 255, 0)",
        "isHidden": false,
        "description": "Green"
      },
      {
        "input": "240, 1, 1",
        "expectedOutput": "(0, 0, 255)",
        "isHidden": false,
        "description": "Blue"
      },
      {
        "input": "60, 0.5, 0.8",
        "expectedOutput": "(204, 204, 102)",
        "isHidden": true,
        "description": "Yellow variant"
      }
    ],
    "hints": [
      "Calculate chroma: C = V * S",
      "Find intermediate value X",
      "Determine RGB based on hue sector (0-60, 60-120, etc.)",
      "Add match value m to each component"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Brightness Adjustment",
    "difficulty": 2,
    "description": "Adjust the brightness of an RGB color by a factor. Factor > 1 brightens, < 1 darkens. Clamp values to 0-255 range.",
    "starterCode": "def adjust_brightness(r, g, b, factor):\n    \"\"\"\n    Adjust brightness of RGB color.\n\n    Args:\n        r, g, b: RGB components (0-255)\n        factor: Brightness factor (e.g., 1.5 for 50% brighter)\n\n    Returns:\n        Tuple (r, g, b) with adjusted brightness\n    \"\"\"\n    pass",
    "solution": "def adjust_brightness(r, g, b, factor):\n    \"\"\"\n    Adjust brightness of RGB color.\n\n    Args:\n        r, g, b: RGB components (0-255)\n        factor: Brightness factor (e.g., 1.5 for 50% brighter)\n\n    Returns:\n        Tuple (r, g, b) with adjusted brightness\n    \"\"\"\n    r = max(0, min(255, int(r * factor)))\n    g = max(0, min(255, int(g * factor)))\n    b = max(0, min(255, int(b * factor)))\n    return (r, g, b)",
    "testCases": [
      {
        "input": "100, 100, 100, 2.0",
        "expectedOutput": "(200, 200, 200)",
        "isHidden": false,
        "description": "Double brightness"
      },
      {
        "input": "200, 200, 200, 0.5",
        "expectedOutput": "(100, 100, 100)",
        "isHidden": false,
        "description": "Half brightness"
      },
      {
        "input": "200, 100, 50, 1.5",
        "expectedOutput": "(255, 150, 75)",
        "isHidden": false,
        "description": "Brighten with clamping"
      },
      {
        "input": "128, 64, 32, 0.25",
        "expectedOutput": "(32, 16, 8)",
        "isHidden": true,
        "description": "Darken significantly"
      }
    ],
    "hints": [
      "Multiply each component by factor",
      "Clamp values using max(0, min(255, value))",
      "Convert to integer"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Polar to Cartesian Coordinates",
    "difficulty": 2,
    "description": "Convert polar coordinates (radius, angle in degrees) to Cartesian coordinates (x, y). Return as a tuple of floats rounded to 2 decimal places.",
    "starterCode": "import math\n\ndef polar_to_cartesian(radius, angle_degrees):\n    \"\"\"\n    Convert polar to Cartesian coordinates.\n\n    Args:\n        radius: Distance from origin\n        angle_degrees: Angle in degrees (0° = positive x-axis)\n\n    Returns:\n        Tuple (x, y) rounded to 2 decimal places\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef polar_to_cartesian(radius, angle_degrees):\n    \"\"\"\n    Convert polar to Cartesian coordinates.\n\n    Args:\n        radius: Distance from origin\n        angle_degrees: Angle in degrees (0° = positive x-axis)\n\n    Returns:\n        Tuple (x, y) rounded to 2 decimal places\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    x = round(radius * math.cos(angle_radians), 2)\n    y = round(radius * math.sin(angle_radians), 2)\n    return (x, y)",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "(1.0, 0.0)",
        "isHidden": false,
        "description": "0 degrees"
      },
      {
        "input": "1, 90",
        "expectedOutput": "(0.0, 1.0)",
        "isHidden": false,
        "description": "90 degrees"
      },
      {
        "input": "10, 45",
        "expectedOutput": "(7.07, 7.07)",
        "isHidden": false,
        "description": "45 degrees"
      },
      {
        "input": "5, 180",
        "expectedOutput": "(-5.0, 0.0)",
        "isHidden": true,
        "description": "180 degrees"
      }
    ],
    "hints": [
      "Convert angle to radians: radians = degrees * π / 180",
      "x = radius * cos(angle), y = radius * sin(angle)",
      "Use math.cos() and math.sin()",
      "Round to 2 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Color Distance",
    "difficulty": 3,
    "description": "Calculate the Euclidean distance between two RGB colors in 3D color space. Return the distance rounded to 2 decimal places.",
    "starterCode": "import math\n\ndef color_distance(r1, g1, b1, r2, g2, b2):\n    \"\"\"\n    Calculate Euclidean distance between two colors.\n\n    Args:\n        r1, g1, b1: First color RGB (0-255)\n        r2, g2, b2: Second color RGB (0-255)\n\n    Returns:\n        Distance as float rounded to 2 decimals\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef color_distance(r1, g1, b1, r2, g2, b2):\n    \"\"\"\n    Calculate Euclidean distance between two colors.\n\n    Args:\n        r1, g1, b1: First color RGB (0-255)\n        r2, g2, b2: Second color RGB (0-255)\n\n    Returns:\n        Distance as float rounded to 2 decimals\n    \"\"\"\n    distance = math.sqrt((r2 - r1)**2 + (g2 - g1)**2 + (b2 - b1)**2)\n    return round(distance, 2)",
    "testCases": [
      {
        "input": "0, 0, 0, 255, 255, 255",
        "expectedOutput": "441.67",
        "isHidden": false,
        "description": "Black to white"
      },
      {
        "input": "255, 0, 0, 0, 255, 0",
        "expectedOutput": "360.62",
        "isHidden": false,
        "description": "Red to green"
      },
      {
        "input": "100, 100, 100, 100, 100, 100",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Same color"
      },
      {
        "input": "50, 100, 150, 200, 150, 100",
        "expectedOutput": "173.21",
        "isHidden": true,
        "description": "Custom colors"
      }
    ],
    "hints": [
      "Use 3D Euclidean distance formula",
      "Distance = sqrt((r2-r1)² + (g2-g1)² + (b2-b1)²)",
      "Use math.sqrt() and round to 2 decimals"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Gamma Correction",
    "difficulty": 3,
    "description": "Apply gamma correction to an RGB color. Gamma correction formula: output = 255 * (input/255)^gamma. Use gamma value provided as parameter.",
    "starterCode": "def gamma_correct(r, g, b, gamma):\n    \"\"\"\n    Apply gamma correction to RGB color.\n\n    Args:\n        r, g, b: RGB components (0-255)\n        gamma: Gamma value (typically 2.2 for encoding, 1/2.2 for decoding)\n\n    Returns:\n        Tuple (r, g, b) with gamma correction applied\n    \"\"\"\n    pass",
    "solution": "def gamma_correct(r, g, b, gamma):\n    \"\"\"\n    Apply gamma correction to RGB color.\n\n    Args:\n        r, g, b: RGB components (0-255)\n        gamma: Gamma value (typically 2.2 for encoding, 1/2.2 for decoding)\n\n    Returns:\n        Tuple (r, g, b) with gamma correction applied\n    \"\"\"\n    r_corrected = int(255 * ((r / 255) ** gamma))\n    g_corrected = int(255 * ((g / 255) ** gamma))\n    b_corrected = int(255 * ((b / 255) ** gamma))\n    return (r_corrected, g_corrected, b_corrected)",
    "testCases": [
      {
        "input": "128, 128, 128, 2.2",
        "expectedOutput": "(52, 52, 52)",
        "isHidden": false,
        "description": "Mid-gray encoding"
      },
      {
        "input": "128, 128, 128, 0.45",
        "expectedOutput": "(186, 186, 186)",
        "isHidden": false,
        "description": "Mid-gray decoding"
      },
      {
        "input": "255, 128, 64, 2.2",
        "expectedOutput": "(255, 52, 10)",
        "isHidden": false,
        "description": "Color encoding"
      },
      {
        "input": "100, 150, 200, 1.0",
        "expectedOutput": "(100, 150, 200)",
        "isHidden": true,
        "description": "Gamma 1.0 (no change)"
      }
    ],
    "hints": [
      "Normalize to 0-1 range: value / 255",
      "Apply gamma: (normalized)^gamma",
      "Scale back to 0-255: result * 255",
      "Convert to integer"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Normalized Device Coordinates",
    "difficulty": 3,
    "description": "Convert screen coordinates to Normalized Device Coordinates (NDC). NDC range is [-1, 1] for both x and y. Return as tuple of floats rounded to 3 decimals.",
    "starterCode": "def screen_to_ndc(x, y, width, height):\n    \"\"\"\n    Convert screen coordinates to NDC.\n\n    Args:\n        x, y: Screen coordinates\n        width, height: Screen dimensions\n\n    Returns:\n        Tuple (ndc_x, ndc_y) in range [-1, 1]\n    \"\"\"\n    pass",
    "solution": "def screen_to_ndc(x, y, width, height):\n    \"\"\"\n    Convert screen coordinates to NDC.\n\n    Args:\n        x, y: Screen coordinates\n        width, height: Screen dimensions\n\n    Returns:\n        Tuple (ndc_x, ndc_y) in range [-1, 1]\n    \"\"\"\n    ndc_x = (2 * x / width) - 1\n    ndc_y = 1 - (2 * y / height)\n    return (round(ndc_x, 3), round(ndc_y, 3))",
    "testCases": [
      {
        "input": "400, 300, 800, 600",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": false,
        "description": "Center of screen"
      },
      {
        "input": "0, 0, 800, 600",
        "expectedOutput": "(-1.0, 1.0)",
        "isHidden": false,
        "description": "Top-left corner"
      },
      {
        "input": "800, 600, 800, 600",
        "expectedOutput": "(1.0, -1.0)",
        "isHidden": false,
        "description": "Bottom-right corner"
      },
      {
        "input": "600, 150, 800, 600",
        "expectedOutput": "(0.5, 0.5)",
        "isHidden": true,
        "description": "Arbitrary point"
      }
    ],
    "hints": [
      "NDC x = (2 * screen_x / width) - 1",
      "NDC y = 1 - (2 * screen_y / height)",
      "Note: y-axis is flipped in NDC",
      "Round to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Color Interpolation",
    "difficulty": 4,
    "description": "Linearly interpolate between two RGB colors. Given two colors and parameter t (0-1), return the interpolated color. t=0 returns color1, t=1 returns color2.",
    "starterCode": "def interpolate_color(r1, g1, b1, r2, g2, b2, t):\n    \"\"\"\n    Linearly interpolate between two colors.\n\n    Args:\n        r1, g1, b1: First color RGB (0-255)\n        r2, g2, b2: Second color RGB (0-255)\n        t: Interpolation parameter (0-1)\n\n    Returns:\n        Tuple (r, g, b) of interpolated color\n    \"\"\"\n    pass",
    "solution": "def interpolate_color(r1, g1, b1, r2, g2, b2, t):\n    \"\"\"\n    Linearly interpolate between two colors.\n\n    Args:\n        r1, g1, b1: First color RGB (0-255)\n        r2, g2, b2: Second color RGB (0-255)\n        t: Interpolation parameter (0-1)\n\n    Returns:\n        Tuple (r, g, b) of interpolated color\n    \"\"\"\n    r = int(r1 + (r2 - r1) * t)\n    g = int(g1 + (g2 - g1) * t)\n    b = int(b1 + (b2 - b1) * t)\n    return (r, g, b)",
    "testCases": [
      {
        "input": "0, 0, 0, 255, 255, 255, 0.5",
        "expectedOutput": "(127, 127, 127)",
        "isHidden": false,
        "description": "Black to white halfway"
      },
      {
        "input": "255, 0, 0, 0, 0, 255, 0.0",
        "expectedOutput": "(255, 0, 0)",
        "isHidden": false,
        "description": "t=0 returns first color"
      },
      {
        "input": "255, 0, 0, 0, 0, 255, 1.0",
        "expectedOutput": "(0, 0, 255)",
        "isHidden": false,
        "description": "t=1 returns second color"
      },
      {
        "input": "100, 150, 200, 200, 100, 50, 0.25",
        "expectedOutput": "(125, 137, 162)",
        "isHidden": true,
        "description": "Quarter interpolation"
      }
    ],
    "hints": [
      "Linear interpolation: value = start + (end - start) * t",
      "Apply formula to each RGB component",
      "Convert result to integer"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Aspect Ratio Correction",
    "difficulty": 4,
    "description": "Calculate viewport dimensions that maintain aspect ratio when fitting a source rectangle into a target rectangle. Return (width, height) that fits inside target while preserving source aspect ratio.",
    "starterCode": "def fit_aspect_ratio(src_width, src_height, target_width, target_height):\n    \"\"\"\n    Calculate dimensions to fit source into target preserving aspect ratio.\n\n    Args:\n        src_width, src_height: Source dimensions\n        target_width, target_height: Target dimensions\n\n    Returns:\n        Tuple (width, height) that fits in target\n    \"\"\"\n    pass",
    "solution": "def fit_aspect_ratio(src_width, src_height, target_width, target_height):\n    \"\"\"\n    Calculate dimensions to fit source into target preserving aspect ratio.\n\n    Args:\n        src_width, src_height: Source dimensions\n        target_width, target_height: Target dimensions\n\n    Returns:\n        Tuple (width, height) that fits in target\n    \"\"\"\n    src_aspect = src_width / src_height\n    target_aspect = target_width / target_height\n\n    if src_aspect > target_aspect:\n        # Source is wider, fit to width\n        width = target_width\n        height = int(target_width / src_aspect)\n    else:\n        # Source is taller, fit to height\n        width = int(target_height * src_aspect)\n        height = target_height\n\n    return (width, height)",
    "testCases": [
      {
        "input": "1920, 1080, 800, 600",
        "expectedOutput": "(800, 450)",
        "isHidden": false,
        "description": "16:9 to 4:3 screen"
      },
      {
        "input": "800, 600, 1920, 1080",
        "expectedOutput": "(1440, 1080)",
        "isHidden": false,
        "description": "4:3 to 16:9 screen"
      },
      {
        "input": "1000, 1000, 800, 600",
        "expectedOutput": "(600, 600)",
        "isHidden": false,
        "description": "Square to rectangle"
      },
      {
        "input": "1280, 720, 640, 480",
        "expectedOutput": "(640, 360)",
        "isHidden": true,
        "description": "Scale down maintaining 16:9"
      }
    ],
    "hints": [
      "Calculate aspect ratios of source and target",
      "If source is wider, fit to target width",
      "If source is taller, fit to target height",
      "Preserve the source aspect ratio"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Barycentric Coordinates",
    "difficulty": 5,
    "description": "Calculate barycentric coordinates of point P relative to triangle ABC. Return (u, v, w) where P = u*A + v*B + w*C and u+v+w=1. Round to 3 decimals.",
    "starterCode": "def barycentric_coords(px, py, ax, ay, bx, by, cx, cy):\n    \"\"\"\n    Calculate barycentric coordinates of point P in triangle ABC.\n\n    Args:\n        px, py: Point coordinates\n        ax, ay: Vertex A coordinates\n        bx, by: Vertex B coordinates\n        cx, cy: Vertex C coordinates\n\n    Returns:\n        Tuple (u, v, w) of barycentric coordinates\n    \"\"\"\n    pass",
    "solution": "def barycentric_coords(px, py, ax, ay, bx, by, cx, cy):\n    \"\"\"\n    Calculate barycentric coordinates of point P in triangle ABC.\n\n    Args:\n        px, py: Point coordinates\n        ax, ay: Vertex A coordinates\n        bx, by: Vertex B coordinates\n        cx, cy: Vertex C coordinates\n\n    Returns:\n        Tuple (u, v, w) of barycentric coordinates\n    \"\"\"\n    # Vectors from A to B and A to C\n    v0x, v0y = cx - ax, cy - ay\n    v1x, v1y = bx - ax, by - ay\n    v2x, v2y = px - ax, py - ay\n\n    # Compute dot products\n    dot00 = v0x * v0x + v0y * v0y\n    dot01 = v0x * v1x + v0y * v1y\n    dot02 = v0x * v2x + v0y * v2y\n    dot11 = v1x * v1x + v1y * v1y\n    dot12 = v1x * v2x + v1y * v2y\n\n    # Compute barycentric coordinates\n    inv_denom = 1 / (dot00 * dot11 - dot01 * dot01)\n    v = (dot11 * dot02 - dot01 * dot12) * inv_denom\n    w = (dot00 * dot12 - dot01 * dot02) * inv_denom\n    u = 1 - v - w\n\n    return (round(u, 3), round(v, 3), round(w, 3))",
    "testCases": [
      {
        "input": "0, 0, 0, 0, 1, 0, 0, 1",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Point at vertex A"
      },
      {
        "input": "0.5, 0.5, 0, 0, 1, 0, 0, 1",
        "expectedOutput": "(0.0, 0.5, 0.5)",
        "isHidden": false,
        "description": "Point on BC edge"
      },
      {
        "input": "0.333, 0.333, 0, 0, 1, 0, 0, 1",
        "expectedOutput": "(0.333, 0.333, 0.333)",
        "isHidden": false,
        "description": "Centroid"
      },
      {
        "input": "2, 2, 0, 0, 4, 0, 0, 4",
        "expectedOutput": "(0.0, 0.5, 0.5)",
        "isHidden": true,
        "description": "Scaled triangle"
      }
    ],
    "hints": [
      "Use vectors from A to B, A to C, and A to P",
      "Compute dot products of these vectors",
      "Use formula: v = (dot11*dot02 - dot01*dot12) / denom",
      "w = (dot00*dot12 - dot01*dot02) / denom",
      "u = 1 - v - w"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t1-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-1",
    "title": "Framebuffer Clear Operation",
    "difficulty": 5,
    "description": "Implement a framebuffer clear operation. Given width, height, and clear color (r,g,b), return a 1D list representing the framebuffer where each pixel is set to the clear color. Each pixel is represented as a tuple (r,g,b).",
    "starterCode": "def clear_framebuffer(width, height, r, g, b):\n    \"\"\"\n    Create a cleared framebuffer with specified color.\n\n    Args:\n        width: Framebuffer width\n        height: Framebuffer height\n        r, g, b: Clear color RGB (0-255)\n\n    Returns:\n        List of (r,g,b) tuples representing framebuffer\n    \"\"\"\n    pass",
    "solution": "def clear_framebuffer(width, height, r, g, b):\n    \"\"\"\n    Create a cleared framebuffer with specified color.\n\n    Args:\n        width: Framebuffer width\n        height: Framebuffer height\n        r, g, b: Clear color RGB (0-255)\n\n    Returns:\n        List of (r,g,b) tuples representing framebuffer\n    \"\"\"\n    return [(r, g, b)] * (width * height)",
    "testCases": [
      {
        "input": "2, 2, 255, 0, 0",
        "expectedOutput": "[(255, 0, 0), (255, 0, 0), (255, 0, 0), (255, 0, 0)]",
        "isHidden": false,
        "description": "2x2 red buffer"
      },
      {
        "input": "3, 1, 0, 255, 0",
        "expectedOutput": "[(0, 255, 0), (0, 255, 0), (0, 255, 0)]",
        "isHidden": false,
        "description": "3x1 green buffer"
      },
      {
        "input": "1, 3, 0, 0, 255",
        "expectedOutput": "[(0, 0, 255), (0, 0, 255), (0, 0, 255)]",
        "isHidden": false,
        "description": "1x3 blue buffer"
      },
      {
        "input": "4, 4, 128, 128, 128",
        "expectedOutput": "[(128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128), (128, 128, 128)]",
        "isHidden": true,
        "description": "4x4 gray buffer"
      }
    ],
    "hints": [
      "Total pixels = width * height",
      "Create a list with clear color tuple repeated for each pixel",
      "Can use list multiplication: [color] * count"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "2D Translation",
    "difficulty": 1,
    "description": "Translate a 2D point (x, y) by displacement (dx, dy). Return the new coordinates as a tuple.",
    "starterCode": "def translate_2d(x, y, dx, dy):\n    \"\"\"\n    Translate a 2D point.\n\n    Args:\n        x, y: Original point coordinates\n        dx, dy: Translation displacement\n\n    Returns:\n        Tuple (x', y') of translated point\n    \"\"\"\n    pass",
    "solution": "def translate_2d(x, y, dx, dy):\n    \"\"\"\n    Translate a 2D point.\n\n    Args:\n        x, y: Original point coordinates\n        dx, dy: Translation displacement\n\n    Returns:\n        Tuple (x', y') of translated point\n    \"\"\"\n    return (x + dx, y + dy)",
    "testCases": [
      {
        "input": "0, 0, 5, 10",
        "expectedOutput": "(5, 10)",
        "isHidden": false,
        "description": "Translate from origin"
      },
      {
        "input": "10, 20, -5, -10",
        "expectedOutput": "(5, 10)",
        "isHidden": false,
        "description": "Negative translation"
      },
      {
        "input": "100, 200, 0, 0",
        "expectedOutput": "(100, 200)",
        "isHidden": false,
        "description": "No translation"
      },
      {
        "input": "-10, -20, 30, 40",
        "expectedOutput": "(20, 20)",
        "isHidden": true,
        "description": "Mixed signs"
      }
    ],
    "hints": [
      "Translation is simple addition",
      "x' = x + dx, y' = y + dy"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "2D Scaling",
    "difficulty": 1,
    "description": "Scale a 2D point (x, y) by factors (sx, sy) around the origin. Return the scaled coordinates.",
    "starterCode": "def scale_2d(x, y, sx, sy):\n    \"\"\"\n    Scale a 2D point around origin.\n\n    Args:\n        x, y: Original point coordinates\n        sx, sy: Scale factors\n\n    Returns:\n        Tuple (x', y') of scaled point\n    \"\"\"\n    pass",
    "solution": "def scale_2d(x, y, sx, sy):\n    \"\"\"\n    Scale a 2D point around origin.\n\n    Args:\n        x, y: Original point coordinates\n        sx, sy: Scale factors\n\n    Returns:\n        Tuple (x', y') of scaled point\n    \"\"\"\n    return (x * sx, y * sy)",
    "testCases": [
      {
        "input": "10, 20, 2, 2",
        "expectedOutput": "(20, 40)",
        "isHidden": false,
        "description": "Uniform scaling"
      },
      {
        "input": "5, 10, 2, 0.5",
        "expectedOutput": "(10, 5.0)",
        "isHidden": false,
        "description": "Non-uniform scaling"
      },
      {
        "input": "100, 50, 0.1, 0.1",
        "expectedOutput": "(10.0, 5.0)",
        "isHidden": false,
        "description": "Scale down"
      },
      {
        "input": "-10, 20, 3, 2",
        "expectedOutput": "(-30, 40)",
        "isHidden": true,
        "description": "Negative coordinate"
      }
    ],
    "hints": [
      "Scaling around origin is multiplication",
      "x' = x * sx, y' = y * sy"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "2D Matrix-Vector Multiplication",
    "difficulty": 2,
    "description": "Multiply a 2x2 matrix by a 2D vector. Given matrix [[a,b],[c,d]] and vector (x,y), return the result vector.",
    "starterCode": "def matrix_vector_mult_2d(matrix, x, y):\n    \"\"\"\n    Multiply 2x2 matrix by 2D vector.\n\n    Args:\n        matrix: 2x2 matrix as [[a,b],[c,d]]\n        x, y: Vector components\n\n    Returns:\n        Tuple (x', y') of result vector\n    \"\"\"\n    pass",
    "solution": "def matrix_vector_mult_2d(matrix, x, y):\n    \"\"\"\n    Multiply 2x2 matrix by 2D vector.\n\n    Args:\n        matrix: 2x2 matrix as [[a,b],[c,d]]\n        x, y: Vector components\n\n    Returns:\n        Tuple (x', y') of result vector\n    \"\"\"\n    x_prime = matrix[0][0] * x + matrix[0][1] * y\n    y_prime = matrix[1][0] * x + matrix[1][1] * y\n    return (x_prime, y_prime)",
    "testCases": [
      {
        "input": "[[1, 0], [0, 1]], 5, 10",
        "expectedOutput": "(5, 10)",
        "isHidden": false,
        "description": "Identity matrix"
      },
      {
        "input": "[[2, 0], [0, 2]], 3, 4",
        "expectedOutput": "(6, 8)",
        "isHidden": false,
        "description": "Scale matrix"
      },
      {
        "input": "[[0, -1], [1, 0]], 5, 0",
        "expectedOutput": "(0, 5)",
        "isHidden": false,
        "description": "90° rotation matrix"
      },
      {
        "input": "[[1, 2], [3, 4]], 1, 1",
        "expectedOutput": "(3, 7)",
        "isHidden": true,
        "description": "Arbitrary matrix"
      }
    ],
    "hints": [
      "Result x = m[0][0]*x + m[0][1]*y",
      "Result y = m[1][0]*x + m[1][1]*y",
      "Each row of matrix multiplies the vector"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "2D Rotation Matrix",
    "difficulty": 2,
    "description": "Create a 2D rotation matrix for rotating angle θ (in degrees) counter-clockwise. Return as [[cos,-sin],[sin,cos]] with values rounded to 3 decimals.",
    "starterCode": "import math\n\ndef rotation_matrix_2d(angle_degrees):\n    \"\"\"\n    Create 2D rotation matrix.\n\n    Args:\n        angle_degrees: Rotation angle in degrees (counter-clockwise)\n\n    Returns:\n        2x2 rotation matrix as [[cos,-sin],[sin,cos]]\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef rotation_matrix_2d(angle_degrees):\n    \"\"\"\n    Create 2D rotation matrix.\n\n    Args:\n        angle_degrees: Rotation angle in degrees (counter-clockwise)\n\n    Returns:\n        2x2 rotation matrix as [[cos,-sin],[sin,cos]]\n    \"\"\"\n    angle_rad = math.radians(angle_degrees)\n    cos_theta = round(math.cos(angle_rad), 3)\n    sin_theta = round(math.sin(angle_rad), 3)\n    return [[cos_theta, -sin_theta], [sin_theta, cos_theta]]",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "[[1.0, -0.0], [0.0, 1.0]]",
        "isHidden": false,
        "description": "0° rotation"
      },
      {
        "input": "90",
        "expectedOutput": "[[0.0, -1.0], [1.0, 0.0]]",
        "isHidden": false,
        "description": "90° rotation"
      },
      {
        "input": "45",
        "expectedOutput": "[[0.707, -0.707], [0.707, 0.707]]",
        "isHidden": false,
        "description": "45° rotation"
      },
      {
        "input": "180",
        "expectedOutput": "[[-1.0, -0.0], [0.0, -1.0]]",
        "isHidden": true,
        "description": "180° rotation"
      }
    ],
    "hints": [
      "Convert degrees to radians",
      "Rotation matrix: [[cos θ, -sin θ], [sin θ, cos θ]]",
      "Round values to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "Apply 2D Rotation",
    "difficulty": 2,
    "description": "Rotate a 2D point (x, y) by angle θ (in degrees) around the origin. Return rotated coordinates rounded to 2 decimals.",
    "starterCode": "import math\n\ndef rotate_point_2d(x, y, angle_degrees):\n    \"\"\"\n    Rotate a 2D point around origin.\n\n    Args:\n        x, y: Point coordinates\n        angle_degrees: Rotation angle in degrees (counter-clockwise)\n\n    Returns:\n        Tuple (x', y') of rotated point\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef rotate_point_2d(x, y, angle_degrees):\n    \"\"\"\n    Rotate a 2D point around origin.\n\n    Args:\n        x, y: Point coordinates\n        angle_degrees: Rotation angle in degrees (counter-clockwise)\n\n    Returns:\n        Tuple (x', y') of rotated point\n    \"\"\"\n    angle_rad = math.radians(angle_degrees)\n    cos_theta = math.cos(angle_rad)\n    sin_theta = math.sin(angle_rad)\n\n    x_prime = x * cos_theta - y * sin_theta\n    y_prime = x * sin_theta + y * cos_theta\n\n    return (round(x_prime, 2), round(y_prime, 2))",
    "testCases": [
      {
        "input": "1, 0, 90",
        "expectedOutput": "(0.0, 1.0)",
        "isHidden": false,
        "description": "Rotate (1,0) by 90°"
      },
      {
        "input": "0, 1, 90",
        "expectedOutput": "(-1.0, 0.0)",
        "isHidden": false,
        "description": "Rotate (0,1) by 90°"
      },
      {
        "input": "10, 0, 45",
        "expectedOutput": "(7.07, 7.07)",
        "isHidden": false,
        "description": "Rotate (10,0) by 45°"
      },
      {
        "input": "5, 5, 180",
        "expectedOutput": "(-5.0, -5.0)",
        "isHidden": true,
        "description": "Rotate by 180°"
      }
    ],
    "hints": [
      "x' = x*cos(θ) - y*sin(θ)",
      "y' = x*sin(θ) + y*cos(θ)",
      "Convert angle to radians first"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "3x3 Matrix Multiplication",
    "difficulty": 3,
    "description": "Multiply two 3x3 matrices. Return the result matrix.",
    "starterCode": "def multiply_matrices_3x3(m1, m2):\n    \"\"\"\n    Multiply two 3x3 matrices.\n\n    Args:\n        m1: First 3x3 matrix\n        m2: Second 3x3 matrix\n\n    Returns:\n        Result 3x3 matrix\n    \"\"\"\n    pass",
    "solution": "def multiply_matrices_3x3(m1, m2):\n    \"\"\"\n    Multiply two 3x3 matrices.\n\n    Args:\n        m1: First 3x3 matrix\n        m2: Second 3x3 matrix\n\n    Returns:\n        Result 3x3 matrix\n    \"\"\"\n    result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                result[i][j] += m1[i][k] * m2[k][j]\n\n    return result",
    "testCases": [
      {
        "input": "[[1,0,0],[0,1,0],[0,0,1]], [[2,3,4],[5,6,7],[8,9,10]]",
        "expectedOutput": "[[2, 3, 4], [5, 6, 7], [8, 9, 10]]",
        "isHidden": false,
        "description": "Identity matrix"
      },
      {
        "input": "[[2,0,0],[0,2,0],[0,0,2]], [[1,2,3],[4,5,6],[7,8,9]]",
        "expectedOutput": "[[2, 4, 6], [8, 10, 12], [14, 16, 18]]",
        "isHidden": false,
        "description": "Scale matrix"
      },
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]], [[1,0,0],[0,1,0],[0,0,1]]",
        "expectedOutput": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "isHidden": false,
        "description": "Right multiply identity"
      },
      {
        "input": "[[1,2,0],[0,1,0],[0,0,1]], [[1,0,5],[0,1,10],[0,0,1]]",
        "expectedOutput": "[[1, 2, 25], [0, 1, 10], [0, 0, 1]]",
        "isHidden": true,
        "description": "Transformation matrices"
      }
    ],
    "hints": [
      "Result[i][j] = sum of m1[i][k] * m2[k][j] for all k",
      "Use three nested loops: row i, column j, and sum index k",
      "Initialize result matrix with zeros"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "Homogeneous 2D Translation Matrix",
    "difficulty": 3,
    "description": "Create a 3x3 homogeneous transformation matrix for 2D translation by (dx, dy). Format: [[1,0,dx],[0,1,dy],[0,0,1]].",
    "starterCode": "def translation_matrix_2d(dx, dy):\n    \"\"\"\n    Create 2D translation matrix in homogeneous coordinates.\n\n    Args:\n        dx, dy: Translation displacement\n\n    Returns:\n        3x3 translation matrix\n    \"\"\"\n    pass",
    "solution": "def translation_matrix_2d(dx, dy):\n    \"\"\"\n    Create 2D translation matrix in homogeneous coordinates.\n\n    Args:\n        dx, dy: Translation displacement\n\n    Returns:\n        3x3 translation matrix\n    \"\"\"\n    return [\n        [1, 0, dx],\n        [0, 1, dy],\n        [0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "5, 10",
        "expectedOutput": "[[1, 0, 5], [0, 1, 10], [0, 0, 1]]",
        "isHidden": false,
        "description": "Positive translation"
      },
      {
        "input": "-3, -7",
        "expectedOutput": "[[1, 0, -3], [0, 1, -7], [0, 0, 1]]",
        "isHidden": false,
        "description": "Negative translation"
      },
      {
        "input": "0, 0",
        "expectedOutput": "[[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
        "isHidden": false,
        "description": "No translation (identity)"
      },
      {
        "input": "100, -50",
        "expectedOutput": "[[1, 0, 100], [0, 1, -50], [0, 0, 1]]",
        "isHidden": true,
        "description": "Mixed signs"
      }
    ],
    "hints": [
      "Translation matrix has 1s on diagonal",
      "Translation values go in rightmost column",
      "Bottom row is [0, 0, 1]"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "Homogeneous Coordinate Transform",
    "difficulty": 3,
    "description": "Transform a 2D point in homogeneous coordinates [x, y, 1] by a 3x3 transformation matrix. Return result as (x, y) after dividing by w.",
    "starterCode": "def transform_homogeneous(matrix, x, y):\n    \"\"\"\n    Transform 2D point using homogeneous coordinates.\n\n    Args:\n        matrix: 3x3 transformation matrix\n        x, y: Point coordinates\n\n    Returns:\n        Tuple (x', y') of transformed point\n    \"\"\"\n    pass",
    "solution": "def transform_homogeneous(matrix, x, y):\n    \"\"\"\n    Transform 2D point using homogeneous coordinates.\n\n    Args:\n        matrix: 3x3 transformation matrix\n        x, y: Point coordinates\n\n    Returns:\n        Tuple (x', y') of transformed point\n    \"\"\"\n    # Homogeneous vector [x, y, 1]\n    x_h = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2]\n    y_h = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2]\n    w = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2]\n\n    # Divide by w to get Cartesian coordinates\n    return (x_h / w, y_h / w)",
    "testCases": [
      {
        "input": "[[1,0,5],[0,1,10],[0,0,1]], 0, 0",
        "expectedOutput": "(5.0, 10.0)",
        "isHidden": false,
        "description": "Translation only"
      },
      {
        "input": "[[2,0,0],[0,2,0],[0,0,1]], 3, 4",
        "expectedOutput": "(6.0, 8.0)",
        "isHidden": false,
        "description": "Scaling only"
      },
      {
        "input": "[[1,0,0],[0,1,0],[0,0,1]], 5, 7",
        "expectedOutput": "(5.0, 7.0)",
        "isHidden": false,
        "description": "Identity transform"
      },
      {
        "input": "[[1,0,10],[0,1,20],[0,0,2]], 4, 6",
        "expectedOutput": "(7.0, 13.0)",
        "isHidden": true,
        "description": "Non-unit w component"
      }
    ],
    "hints": [
      "Multiply matrix by homogeneous vector [x, y, 1]",
      "Get result [x', y', w]",
      "Divide x' and y' by w to get Cartesian coordinates"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "Composite 2D Transformation",
    "difficulty": 4,
    "description": "Create a composite transformation matrix that first rotates by θ degrees, then translates by (dx, dy). Return 3x3 homogeneous matrix with values rounded to 3 decimals.",
    "starterCode": "import math\n\ndef rotate_then_translate(angle_degrees, dx, dy):\n    \"\"\"\n    Create composite transformation: rotate then translate.\n\n    Args:\n        angle_degrees: Rotation angle\n        dx, dy: Translation displacement\n\n    Returns:\n        3x3 composite transformation matrix\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef rotate_then_translate(angle_degrees, dx, dy):\n    \"\"\"\n    Create composite transformation: rotate then translate.\n\n    Args:\n        angle_degrees: Rotation angle\n        dx, dy: Translation displacement\n\n    Returns:\n        3x3 composite transformation matrix\n    \"\"\"\n    angle_rad = math.radians(angle_degrees)\n    cos_theta = round(math.cos(angle_rad), 3)\n    sin_theta = round(math.sin(angle_rad), 3)\n\n    # Rotation matrix\n    rotation = [\n        [cos_theta, -sin_theta, 0],\n        [sin_theta, cos_theta, 0],\n        [0, 0, 1]\n    ]\n\n    # Translation matrix\n    translation = [\n        [1, 0, dx],\n        [0, 1, dy],\n        [0, 0, 1]\n    ]\n\n    # Multiply: Translation * Rotation (right to left)\n    result = [[0, 0, 0], [0, 0, 0], [0, 0, 1]]\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                result[i][j] += translation[i][k] * rotation[k][j]\n            result[i][j] = round(result[i][j], 3)\n\n    return result",
    "testCases": [
      {
        "input": "0, 5, 10",
        "expectedOutput": "[[1.0, -0.0, 5], [0.0, 1.0, 10], [0, 0, 1]]",
        "isHidden": false,
        "description": "No rotation"
      },
      {
        "input": "90, 10, 20",
        "expectedOutput": "[[0.0, -1.0, 10], [1.0, 0.0, 20], [0, 0, 1]]",
        "isHidden": false,
        "description": "90° rotation then translate"
      },
      {
        "input": "45, 0, 0",
        "expectedOutput": "[[0.707, -0.707, 0], [0.707, 0.707, 0], [0, 0, 1]]",
        "isHidden": false,
        "description": "45° rotation only"
      },
      {
        "input": "180, 5, 5",
        "expectedOutput": "[[-1.0, -0.0, 5], [0.0, -1.0, 5], [0, 0, 1]]",
        "isHidden": true,
        "description": "180° rotation then translate"
      }
    ],
    "hints": [
      "Create rotation matrix and translation matrix separately",
      "Multiply: Translation * Rotation (apply rotation first)",
      "Order matters in matrix multiplication",
      "Round final values to 3 decimals"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "3D Point Translation",
    "difficulty": 2,
    "description": "Translate a 3D point (x, y, z) by displacement (dx, dy, dz). Return the translated coordinates.",
    "starterCode": "def translate_3d(x, y, z, dx, dy, dz):\n    \"\"\"\n    Translate a 3D point.\n\n    Args:\n        x, y, z: Original point coordinates\n        dx, dy, dz: Translation displacement\n\n    Returns:\n        Tuple (x', y', z') of translated point\n    \"\"\"\n    pass",
    "solution": "def translate_3d(x, y, z, dx, dy, dz):\n    \"\"\"\n    Translate a 3D point.\n\n    Args:\n        x, y, z: Original point coordinates\n        dx, dy, dz: Translation displacement\n\n    Returns:\n        Tuple (x', y', z') of translated point\n    \"\"\"\n    return (x + dx, y + dy, z + dz)",
    "testCases": [
      {
        "input": "0, 0, 0, 1, 2, 3",
        "expectedOutput": "(1, 2, 3)",
        "isHidden": false,
        "description": "From origin"
      },
      {
        "input": "5, 10, 15, -2, -3, -4",
        "expectedOutput": "(3, 7, 11)",
        "isHidden": false,
        "description": "Negative displacement"
      },
      {
        "input": "1, 1, 1, 0, 0, 0",
        "expectedOutput": "(1, 1, 1)",
        "isHidden": false,
        "description": "No translation"
      },
      {
        "input": "-5, 10, -15, 5, -10, 15",
        "expectedOutput": "(0, 0, 0)",
        "isHidden": true,
        "description": "To origin"
      }
    ],
    "hints": [
      "Same as 2D translation but with z component",
      "x' = x + dx, y' = y + dy, z' = z + dz"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "3D Scaling Matrix",
    "difficulty": 3,
    "description": "Create a 4x4 homogeneous transformation matrix for 3D scaling by factors (sx, sy, sz).",
    "starterCode": "def scaling_matrix_3d(sx, sy, sz):\n    \"\"\"\n    Create 3D scaling matrix in homogeneous coordinates.\n\n    Args:\n        sx, sy, sz: Scale factors\n\n    Returns:\n        4x4 scaling matrix\n    \"\"\"\n    pass",
    "solution": "def scaling_matrix_3d(sx, sy, sz):\n    \"\"\"\n    Create 3D scaling matrix in homogeneous coordinates.\n\n    Args:\n        sx, sy, sz: Scale factors\n\n    Returns:\n        4x4 scaling matrix\n    \"\"\"\n    return [\n        [sx, 0, 0, 0],\n        [0, sy, 0, 0],\n        [0, 0, sz, 0],\n        [0, 0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "2, 2, 2",
        "expectedOutput": "[[2, 0, 0, 0], [0, 2, 0, 0], [0, 0, 2, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Uniform scaling"
      },
      {
        "input": "1, 2, 3",
        "expectedOutput": "[[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Non-uniform scaling"
      },
      {
        "input": "0.5, 0.5, 0.5",
        "expectedOutput": "[[0.5, 0, 0, 0], [0, 0.5, 0, 0], [0, 0, 0.5, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Scale down"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]",
        "isHidden": true,
        "description": "Identity (no scaling)"
      }
    ],
    "hints": [
      "Scale factors go on main diagonal",
      "Bottom-right element is 1",
      "All other elements are 0"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "3D Rotation Around X-Axis",
    "difficulty": 3,
    "description": "Create a 4x4 rotation matrix for rotating around the X-axis by θ degrees. Round values to 3 decimals.",
    "starterCode": "import math\n\ndef rotation_x_matrix(angle_degrees):\n    \"\"\"\n    Create rotation matrix around X-axis.\n\n    Args:\n        angle_degrees: Rotation angle in degrees\n\n    Returns:\n        4x4 rotation matrix\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef rotation_x_matrix(angle_degrees):\n    \"\"\"\n    Create rotation matrix around X-axis.\n\n    Args:\n        angle_degrees: Rotation angle in degrees\n\n    Returns:\n        4x4 rotation matrix\n    \"\"\"\n    angle_rad = math.radians(angle_degrees)\n    cos_theta = round(math.cos(angle_rad), 3)\n    sin_theta = round(math.sin(angle_rad), 3)\n\n    return [\n        [1, 0, 0, 0],\n        [0, cos_theta, -sin_theta, 0],\n        [0, sin_theta, cos_theta, 0],\n        [0, 0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "[[1, 0, 0, 0], [0, 1.0, -0.0, 0], [0, 0.0, 1.0, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "No rotation"
      },
      {
        "input": "90",
        "expectedOutput": "[[1, 0, 0, 0], [0, 0.0, -1.0, 0], [0, 1.0, 0.0, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "90° rotation"
      },
      {
        "input": "45",
        "expectedOutput": "[[1, 0, 0, 0], [0, 0.707, -0.707, 0], [0, 0.707, 0.707, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "45° rotation"
      },
      {
        "input": "180",
        "expectedOutput": "[[1, 0, 0, 0], [0, -1.0, -0.0, 0], [0, 0.0, -1.0, 0], [0, 0, 0, 1]]",
        "isHidden": true,
        "description": "180° rotation"
      }
    ],
    "hints": [
      "X-axis rotation affects Y and Z coordinates",
      "First row and column stay [1,0,0,0] and [1,0,0,0]",
      "Bottom-right 3x3 submatrix: [[1,0,0],[0,cos,-sin],[0,sin,cos]]",
      "Bottom row is [0,0,0,1]"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "3D Rotation Around Y-Axis",
    "difficulty": 3,
    "description": "Create a 4x4 rotation matrix for rotating around the Y-axis by θ degrees. Round values to 3 decimals.",
    "starterCode": "import math\n\ndef rotation_y_matrix(angle_degrees):\n    \"\"\"\n    Create rotation matrix around Y-axis.\n\n    Args:\n        angle_degrees: Rotation angle in degrees\n\n    Returns:\n        4x4 rotation matrix\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef rotation_y_matrix(angle_degrees):\n    \"\"\"\n    Create rotation matrix around Y-axis.\n\n    Args:\n        angle_degrees: Rotation angle in degrees\n\n    Returns:\n        4x4 rotation matrix\n    \"\"\"\n    angle_rad = math.radians(angle_degrees)\n    cos_theta = round(math.cos(angle_rad), 3)\n    sin_theta = round(math.sin(angle_rad), 3)\n\n    return [\n        [cos_theta, 0, sin_theta, 0],\n        [0, 1, 0, 0],\n        [-sin_theta, 0, cos_theta, 0],\n        [0, 0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "[[1.0, 0, 0.0, 0], [0, 1, 0, 0], [-0.0, 0, 1.0, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "No rotation"
      },
      {
        "input": "90",
        "expectedOutput": "[[0.0, 0, 1.0, 0], [0, 1, 0, 0], [-1.0, 0, 0.0, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "90° rotation"
      },
      {
        "input": "45",
        "expectedOutput": "[[0.707, 0, 0.707, 0], [0, 1, 0, 0], [-0.707, 0, 0.707, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "45° rotation"
      },
      {
        "input": "180",
        "expectedOutput": "[[-1.0, 0, 0.0, 0], [0, 1, 0, 0], [-0.0, 0, -1.0, 0], [0, 0, 0, 1]]",
        "isHidden": true,
        "description": "180° rotation"
      }
    ],
    "hints": [
      "Y-axis rotation affects X and Z coordinates",
      "Second row stays [0,1,0,0]",
      "Note: Y rotation has different sign pattern than X",
      "Matrix: [[cos,0,sin,0],[0,1,0,0],[-sin,0,cos,0],[0,0,0,1]]"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "3D Rotation Around Z-Axis",
    "difficulty": 3,
    "description": "Create a 4x4 rotation matrix for rotating around the Z-axis by θ degrees. Round values to 3 decimals.",
    "starterCode": "import math\n\ndef rotation_z_matrix(angle_degrees):\n    \"\"\"\n    Create rotation matrix around Z-axis.\n\n    Args:\n        angle_degrees: Rotation angle in degrees\n\n    Returns:\n        4x4 rotation matrix\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef rotation_z_matrix(angle_degrees):\n    \"\"\"\n    Create rotation matrix around Z-axis.\n\n    Args:\n        angle_degrees: Rotation angle in degrees\n\n    Returns:\n        4x4 rotation matrix\n    \"\"\"\n    angle_rad = math.radians(angle_degrees)\n    cos_theta = round(math.cos(angle_rad), 3)\n    sin_theta = round(math.sin(angle_rad), 3)\n\n    return [\n        [cos_theta, -sin_theta, 0, 0],\n        [sin_theta, cos_theta, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "[[1.0, -0.0, 0, 0], [0.0, 1.0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "No rotation"
      },
      {
        "input": "90",
        "expectedOutput": "[[0.0, -1.0, 0, 0], [1.0, 0.0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "90° rotation"
      },
      {
        "input": "45",
        "expectedOutput": "[[0.707, -0.707, 0, 0], [0.707, 0.707, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "45° rotation"
      },
      {
        "input": "180",
        "expectedOutput": "[[-1.0, -0.0, 0, 0], [0.0, -1.0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]",
        "isHidden": true,
        "description": "180° rotation"
      }
    ],
    "hints": [
      "Z-axis rotation affects X and Y coordinates",
      "Third row stays [0,0,1,0]",
      "Top-left 2x2 is same as 2D rotation matrix",
      "Matrix: [[cos,-sin,0,0],[sin,cos,0,0],[0,0,1,0],[0,0,0,1]]"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "Vector Cross Product",
    "difficulty": 4,
    "description": "Calculate the cross product of two 3D vectors. Return the result vector as a tuple.",
    "starterCode": "def cross_product(v1, v2):\n    \"\"\"\n    Calculate cross product of two 3D vectors.\n\n    Args:\n        v1: First vector as tuple (x, y, z)\n        v2: Second vector as tuple (x, y, z)\n\n    Returns:\n        Cross product vector as tuple (x, y, z)\n    \"\"\"\n    pass",
    "solution": "def cross_product(v1, v2):\n    \"\"\"\n    Calculate cross product of two 3D vectors.\n\n    Args:\n        v1: First vector as tuple (x, y, z)\n        v2: Second vector as tuple (x, y, z)\n\n    Returns:\n        Cross product vector as tuple (x, y, z)\n    \"\"\"\n    x = v1[1] * v2[2] - v1[2] * v2[1]\n    y = v1[2] * v2[0] - v1[0] * v2[2]\n    z = v1[0] * v2[1] - v1[1] * v2[0]\n    return (x, y, z)",
    "testCases": [
      {
        "input": "(1, 0, 0), (0, 1, 0)",
        "expectedOutput": "(0, 0, 1)",
        "isHidden": false,
        "description": "X cross Y = Z"
      },
      {
        "input": "(0, 1, 0), (0, 0, 1)",
        "expectedOutput": "(1, 0, 0)",
        "isHidden": false,
        "description": "Y cross Z = X"
      },
      {
        "input": "(0, 0, 1), (1, 0, 0)",
        "expectedOutput": "(0, 1, 0)",
        "isHidden": false,
        "description": "Z cross X = Y"
      },
      {
        "input": "(2, 3, 4), (5, 6, 7)",
        "expectedOutput": "(-3, 6, -3)",
        "isHidden": true,
        "description": "Arbitrary vectors"
      }
    ],
    "hints": [
      "Cross product formula: (v1 × v2)",
      "x = v1.y * v2.z - v1.z * v2.y",
      "y = v1.z * v2.x - v1.x * v2.z",
      "z = v1.x * v2.y - v1.y * v2.x"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t2-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-2",
    "title": "Quaternion to Rotation Matrix",
    "difficulty": 5,
    "description": "Convert a unit quaternion (w, x, y, z) to a 3x3 rotation matrix. Return matrix with values rounded to 3 decimals.",
    "starterCode": "def quaternion_to_matrix(w, x, y, z):\n    \"\"\"\n    Convert unit quaternion to 3x3 rotation matrix.\n\n    Args:\n        w, x, y, z: Quaternion components (unit quaternion)\n\n    Returns:\n        3x3 rotation matrix\n    \"\"\"\n    pass",
    "solution": "def quaternion_to_matrix(w, x, y, z):\n    \"\"\"\n    Convert unit quaternion to 3x3 rotation matrix.\n\n    Args:\n        w, x, y, z: Quaternion components (unit quaternion)\n\n    Returns:\n        3x3 rotation matrix\n    \"\"\"\n    # Calculate matrix elements\n    m00 = round(1 - 2*y*y - 2*z*z, 3)\n    m01 = round(2*x*y - 2*z*w, 3)\n    m02 = round(2*x*z + 2*y*w, 3)\n\n    m10 = round(2*x*y + 2*z*w, 3)\n    m11 = round(1 - 2*x*x - 2*z*z, 3)\n    m12 = round(2*y*z - 2*x*w, 3)\n\n    m20 = round(2*x*z - 2*y*w, 3)\n    m21 = round(2*y*z + 2*x*w, 3)\n    m22 = round(1 - 2*x*x - 2*y*y, 3)\n\n    return [\n        [m00, m01, m02],\n        [m10, m11, m12],\n        [m20, m21, m22]\n    ]",
    "testCases": [
      {
        "input": "1, 0, 0, 0",
        "expectedOutput": "[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]",
        "isHidden": false,
        "description": "Identity quaternion"
      },
      {
        "input": "0.707, 0.707, 0, 0",
        "expectedOutput": "[[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]",
        "isHidden": false,
        "description": "90° around X-axis"
      },
      {
        "input": "0.707, 0, 0.707, 0",
        "expectedOutput": "[[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]",
        "isHidden": false,
        "description": "90° around Y-axis"
      },
      {
        "input": "0.707, 0, 0, 0.707",
        "expectedOutput": "[[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]",
        "isHidden": true,
        "description": "90° around Z-axis"
      }
    ],
    "hints": [
      "Use quaternion to matrix conversion formula",
      "M[0][0] = 1 - 2*y² - 2*z²",
      "M[0][1] = 2*x*y - 2*z*w",
      "Continue pattern for all 9 elements",
      "Round each element to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Camera Position Vector",
    "difficulty": 1,
    "description": "Given camera position (ex, ey, ez) and look-at point (cx, cy, cz), calculate the view direction vector (unnormalized). Return as tuple.",
    "starterCode": "def view_direction(ex, ey, ez, cx, cy, cz):\n    \"\"\"\n    Calculate view direction from camera to look-at point.\n\n    Args:\n        ex, ey, ez: Camera (eye) position\n        cx, cy, cz: Look-at (center) point\n\n    Returns:\n        Tuple (dx, dy, dz) of view direction\n    \"\"\"\n    pass",
    "solution": "def view_direction(ex, ey, ez, cx, cy, cz):\n    \"\"\"\n    Calculate view direction from camera to look-at point.\n\n    Args:\n        ex, ey, ez: Camera (eye) position\n        cx, cy, cz: Look-at (center) point\n\n    Returns:\n        Tuple (dx, dy, dz) of view direction\n    \"\"\"\n    dx = cx - ex\n    dy = cy - ey\n    dz = cz - ez\n    return (dx, dy, dz)",
    "testCases": [
      {
        "input": "0, 0, 0, 0, 0, -1",
        "expectedOutput": "(0, 0, -1)",
        "isHidden": false,
        "description": "Look down -Z axis"
      },
      {
        "input": "0, 0, 5, 0, 0, 0",
        "expectedOutput": "(0, 0, -5)",
        "isHidden": false,
        "description": "Camera at +Z looking at origin"
      },
      {
        "input": "1, 2, 3, 4, 5, 6",
        "expectedOutput": "(3, 3, 3)",
        "isHidden": false,
        "description": "Arbitrary positions"
      },
      {
        "input": "10, 10, 10, 0, 0, 0",
        "expectedOutput": "(-10, -10, -10)",
        "isHidden": true,
        "description": "Looking at origin from positive octant"
      }
    ],
    "hints": [
      "Direction = target - origin",
      "dx = cx - ex, dy = cy - ey, dz = cz - ez"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Vector Normalization",
    "difficulty": 1,
    "description": "Normalize a 3D vector to unit length. Return the normalized vector with components rounded to 3 decimals.",
    "starterCode": "import math\n\ndef normalize_vector(x, y, z):\n    \"\"\"\n    Normalize a 3D vector to unit length.\n\n    Args:\n        x, y, z: Vector components\n\n    Returns:\n        Tuple (x, y, z) of normalized vector\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef normalize_vector(x, y, z):\n    \"\"\"\n    Normalize a 3D vector to unit length.\n\n    Args:\n        x, y, z: Vector components\n\n    Returns:\n        Tuple (x, y, z) of normalized vector\n    \"\"\"\n    length = math.sqrt(x*x + y*y + z*z)\n    return (round(x/length, 3), round(y/length, 3), round(z/length, 3))",
    "testCases": [
      {
        "input": "1, 0, 0",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Already normalized"
      },
      {
        "input": "3, 4, 0",
        "expectedOutput": "(0.6, 0.8, 0.0)",
        "isHidden": false,
        "description": "3-4-5 triangle"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "(0.577, 0.577, 0.577)",
        "isHidden": false,
        "description": "Diagonal vector"
      },
      {
        "input": "2, 2, 1",
        "expectedOutput": "(0.667, 0.667, 0.333)",
        "isHidden": true,
        "description": "Arbitrary vector"
      }
    ],
    "hints": [
      "Calculate length: sqrt(x² + y² + z²)",
      "Divide each component by length",
      "Round to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Vector Dot Product",
    "difficulty": 1,
    "description": "Calculate the dot product of two 3D vectors. Return the scalar result.",
    "starterCode": "def dot_product(v1, v2):\n    \"\"\"\n    Calculate dot product of two 3D vectors.\n\n    Args:\n        v1: First vector as tuple (x, y, z)\n        v2: Second vector as tuple (x, y, z)\n\n    Returns:\n        Dot product as scalar\n    \"\"\"\n    pass",
    "solution": "def dot_product(v1, v2):\n    \"\"\"\n    Calculate dot product of two 3D vectors.\n\n    Args:\n        v1: First vector as tuple (x, y, z)\n        v2: Second vector as tuple (x, y, z)\n\n    Returns:\n        Dot product as scalar\n    \"\"\"\n    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]",
    "testCases": [
      {
        "input": "(1, 0, 0), (1, 0, 0)",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Same unit vectors"
      },
      {
        "input": "(1, 0, 0), (0, 1, 0)",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Perpendicular vectors"
      },
      {
        "input": "(2, 3, 4), (5, 6, 7)",
        "expectedOutput": "56",
        "isHidden": false,
        "description": "Arbitrary vectors"
      },
      {
        "input": "(1, 1, 1), (-1, -1, -1)",
        "expectedOutput": "-3",
        "isHidden": true,
        "description": "Opposite vectors"
      }
    ],
    "hints": [
      "Dot product: v1·v2 = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z",
      "Sum of component-wise products"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Orthographic Projection Matrix",
    "difficulty": 2,
    "description": "Create an orthographic projection matrix given left, right, bottom, top, near, far planes. Return 4x4 matrix.",
    "starterCode": "def orthographic_matrix(left, right, bottom, top, near, far):\n    \"\"\"\n    Create orthographic projection matrix.\n\n    Args:\n        left, right: Left and right clipping planes\n        bottom, top: Bottom and top clipping planes\n        near, far: Near and far clipping planes\n\n    Returns:\n        4x4 orthographic projection matrix\n    \"\"\"\n    pass",
    "solution": "def orthographic_matrix(left, right, bottom, top, near, far):\n    \"\"\"\n    Create orthographic projection matrix.\n\n    Args:\n        left, right: Left and right clipping planes\n        bottom, top: Bottom and top clipping planes\n        near, far: Near and far clipping planes\n\n    Returns:\n        4x4 orthographic projection matrix\n    \"\"\"\n    return [\n        [2/(right-left), 0, 0, -(right+left)/(right-left)],\n        [0, 2/(top-bottom), 0, -(top+bottom)/(top-bottom)],\n        [0, 0, -2/(far-near), -(far+near)/(far-near)],\n        [0, 0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "-1, 1, -1, 1, -1, 1",
        "expectedOutput": "[[1.0, 0, 0, -0.0], [0, 1.0, 0, -0.0], [0, 0, -1.0, -0.0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Symmetric cube"
      },
      {
        "input": "0, 800, 0, 600, -1, 1",
        "expectedOutput": "[[0.0025, 0, 0, -1.0], [0, 0.003333333333333333, 0, -1.0], [0, 0, -1.0, -0.0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Screen-space projection"
      },
      {
        "input": "-2, 2, -2, 2, 1, 100",
        "expectedOutput": "[[0.5, 0, 0, -0.0], [0, 0.5, 0, -0.0], [0, 0, -0.020202020202020204, -1.0202020202020203], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Standard orthographic"
      },
      {
        "input": "-10, 10, -10, 10, 0.1, 1000",
        "expectedOutput": "[[0.1, 0, 0, -0.0], [0, 0.1, 0, -0.0], [0, 0, -0.0020002000200020003, -1.0001000100010002], [0, 0, 0, 1]]",
        "isHidden": true,
        "description": "Wide depth range"
      }
    ],
    "hints": [
      "Scale: 2/(right-left), 2/(top-bottom), -2/(far-near)",
      "Translate: -(right+left)/(right-left), -(top+bottom)/(top-bottom), -(far+near)/(far-near)",
      "These values go in specific positions of the matrix"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Perspective Division",
    "difficulty": 2,
    "description": "Perform perspective division on a homogeneous coordinate (x, y, z, w). Return Cartesian coordinates (x/w, y/w, z/w) rounded to 3 decimals.",
    "starterCode": "def perspective_divide(x, y, z, w):\n    \"\"\"\n    Perform perspective division.\n\n    Args:\n        x, y, z, w: Homogeneous coordinates\n\n    Returns:\n        Tuple (x/w, y/w, z/w) of Cartesian coordinates\n    \"\"\"\n    pass",
    "solution": "def perspective_divide(x, y, z, w):\n    \"\"\"\n    Perform perspective division.\n\n    Args:\n        x, y, z, w: Homogeneous coordinates\n\n    Returns:\n        Tuple (x/w, y/w, z/w) of Cartesian coordinates\n    \"\"\"\n    return (round(x/w, 3), round(y/w, 3), round(z/w, 3))",
    "testCases": [
      {
        "input": "10, 20, 30, 1",
        "expectedOutput": "(10.0, 20.0, 30.0)",
        "isHidden": false,
        "description": "w=1 (no change)"
      },
      {
        "input": "10, 20, 30, 2",
        "expectedOutput": "(5.0, 10.0, 15.0)",
        "isHidden": false,
        "description": "w=2"
      },
      {
        "input": "5, 10, -20, 5",
        "expectedOutput": "(1.0, 2.0, -4.0)",
        "isHidden": false,
        "description": "w=5"
      },
      {
        "input": "100, 200, 300, 10",
        "expectedOutput": "(10.0, 20.0, 30.0)",
        "isHidden": true,
        "description": "w=10"
      }
    ],
    "hints": [
      "Divide each component by w",
      "Result: (x/w, y/w, z/w)",
      "Round to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Viewport Transform",
    "difficulty": 3,
    "description": "Transform NDC coordinates (range [-1,1]) to screen coordinates. Given NDC (x,y), viewport position (vx,vy), and size (w,h), return screen coordinates.",
    "starterCode": "def ndc_to_screen(ndc_x, ndc_y, viewport_x, viewport_y, width, height):\n    \"\"\"\n    Transform NDC to screen coordinates.\n\n    Args:\n        ndc_x, ndc_y: NDC coordinates (-1 to 1)\n        viewport_x, viewport_y: Viewport position\n        width, height: Viewport size\n\n    Returns:\n        Tuple (screen_x, screen_y)\n    \"\"\"\n    pass",
    "solution": "def ndc_to_screen(ndc_x, ndc_y, viewport_x, viewport_y, width, height):\n    \"\"\"\n    Transform NDC to screen coordinates.\n\n    Args:\n        ndc_x, ndc_y: NDC coordinates (-1 to 1)\n        viewport_x, viewport_y: Viewport position\n        width, height: Viewport size\n\n    Returns:\n        Tuple (screen_x, screen_y)\n    \"\"\"\n    screen_x = viewport_x + (ndc_x + 1) * width / 2\n    screen_y = viewport_y + (1 - ndc_y) * height / 2\n    return (screen_x, screen_y)",
    "testCases": [
      {
        "input": "0, 0, 0, 0, 800, 600",
        "expectedOutput": "(400.0, 300.0)",
        "isHidden": false,
        "description": "Center of screen"
      },
      {
        "input": "-1, 1, 0, 0, 800, 600",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": false,
        "description": "Top-left corner"
      },
      {
        "input": "1, -1, 0, 0, 800, 600",
        "expectedOutput": "(800.0, 600.0)",
        "isHidden": false,
        "description": "Bottom-right corner"
      },
      {
        "input": "0.5, 0.5, 100, 100, 400, 300",
        "expectedOutput": "(400.0, 175.0)",
        "isHidden": true,
        "description": "With viewport offset"
      }
    ],
    "hints": [
      "Scale from [-1,1] to [0,width]: (ndc_x + 1) * width / 2",
      "Scale from [-1,1] to [0,height]: (1 - ndc_y) * height / 2",
      "Add viewport offset to result",
      "Note: Y is flipped"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Field of View to Focal Length",
    "difficulty": 3,
    "description": "Calculate focal length from vertical field of view (in degrees) and image height. Formula: focal_length = height / (2 * tan(fov/2)). Round to 2 decimals.",
    "starterCode": "import math\n\ndef fov_to_focal_length(fov_degrees, image_height):\n    \"\"\"\n    Calculate focal length from FOV.\n\n    Args:\n        fov_degrees: Vertical field of view in degrees\n        image_height: Image height in pixels\n\n    Returns:\n        Focal length rounded to 2 decimals\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef fov_to_focal_length(fov_degrees, image_height):\n    \"\"\"\n    Calculate focal length from FOV.\n\n    Args:\n        fov_degrees: Vertical field of view in degrees\n        image_height: Image height in pixels\n\n    Returns:\n        Focal length rounded to 2 decimals\n    \"\"\"\n    fov_rad = math.radians(fov_degrees)\n    focal_length = image_height / (2 * math.tan(fov_rad / 2))\n    return round(focal_length, 2)",
    "testCases": [
      {
        "input": "90, 600",
        "expectedOutput": "300.0",
        "isHidden": false,
        "description": "90° FOV"
      },
      {
        "input": "60, 600",
        "expectedOutput": "519.62",
        "isHidden": false,
        "description": "60° FOV"
      },
      {
        "input": "45, 800",
        "expectedOutput": "965.69",
        "isHidden": false,
        "description": "45° FOV"
      },
      {
        "input": "120, 1080",
        "expectedOutput": "311.77",
        "isHidden": true,
        "description": "Wide angle 120° FOV"
      }
    ],
    "hints": [
      "Convert FOV to radians",
      "Formula: f = h / (2 * tan(fov/2))",
      "Use math.tan()",
      "Round to 2 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Perspective Projection Matrix",
    "difficulty": 4,
    "description": "Create a perspective projection matrix given vertical FOV (degrees), aspect ratio, near and far planes. Return 4x4 matrix with values rounded to 3 decimals.",
    "starterCode": "import math\n\ndef perspective_matrix(fov_degrees, aspect, near, far):\n    \"\"\"\n    Create perspective projection matrix.\n\n    Args:\n        fov_degrees: Vertical field of view in degrees\n        aspect: Aspect ratio (width/height)\n        near: Near clipping plane\n        far: Far clipping plane\n\n    Returns:\n        4x4 perspective projection matrix\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef perspective_matrix(fov_degrees, aspect, near, far):\n    \"\"\"\n    Create perspective projection matrix.\n\n    Args:\n        fov_degrees: Vertical field of view in degrees\n        aspect: Aspect ratio (width/height)\n        near: Near clipping plane\n        far: Far clipping plane\n\n    Returns:\n        4x4 perspective projection matrix\n    \"\"\"\n    fov_rad = math.radians(fov_degrees)\n    f = 1.0 / math.tan(fov_rad / 2.0)\n\n    return [\n        [round(f / aspect, 3), 0, 0, 0],\n        [0, round(f, 3), 0, 0],\n        [0, 0, round((far + near) / (near - far), 3), round((2 * far * near) / (near - far), 3)],\n        [0, 0, -1, 0]\n    ]",
    "testCases": [
      {
        "input": "90, 1.333, 0.1, 100",
        "expectedOutput": "[[0.75, 0, 0, 0], [0, 1.0, 0, 0], [0, 0, -1.002, -0.2], [0, 0, -1, 0]]",
        "isHidden": false,
        "description": "90° FOV, 4:3 aspect"
      },
      {
        "input": "60, 1.777, 1, 1000",
        "expectedOutput": "[[0.974, 0, 0, 0], [0, 1.732, 0, 0], [0, 0, -1.002, -2.002], [0, 0, -1, 0]]",
        "isHidden": false,
        "description": "60° FOV, 16:9 aspect"
      },
      {
        "input": "45, 1.0, 0.1, 100",
        "expectedOutput": "[[2.414, 0, 0, 0], [0, 2.414, 0, 0], [0, 0, -1.002, -0.2], [0, 0, -1, 0]]",
        "isHidden": false,
        "description": "45° FOV, square aspect"
      },
      {
        "input": "75, 1.6, 0.5, 500",
        "expectedOutput": "[[0.721, 0, 0, 0], [0, 1.154, 0, 0], [0, 0, -1.002, -1.002], [0, 0, -1, 0]]",
        "isHidden": true,
        "description": "Custom parameters"
      }
    ],
    "hints": [
      "Calculate f = 1 / tan(fov/2)",
      "M[0][0] = f / aspect",
      "M[1][1] = f",
      "M[2][2] = (far + near) / (near - far)",
      "M[2][3] = (2 * far * near) / (near - far)",
      "M[3][2] = -1"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Look-At Matrix",
    "difficulty": 5,
    "description": "Create a view matrix using look-at parameters. Given eye position, center (look-at) point, and up vector, construct the 4x4 view matrix. Round to 3 decimals.",
    "starterCode": "import math\n\ndef look_at_matrix(eye, center, up):\n    \"\"\"\n    Create look-at view matrix.\n\n    Args:\n        eye: Camera position as tuple (x, y, z)\n        center: Look-at point as tuple (x, y, z)\n        up: Up vector as tuple (x, y, z)\n\n    Returns:\n        4x4 view matrix\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef look_at_matrix(eye, center, up):\n    \"\"\"\n    Create look-at view matrix.\n\n    Args:\n        eye: Camera position as tuple (x, y, z)\n        center: Look-at point as tuple (x, y, z)\n        up: Up vector as tuple (x, y, z)\n\n    Returns:\n        4x4 view matrix\n    \"\"\"\n    # Calculate forward vector (from eye to center)\n    fx = center[0] - eye[0]\n    fy = center[1] - eye[1]\n    fz = center[2] - eye[2]\n    f_len = math.sqrt(fx*fx + fy*fy + fz*fz)\n    fx, fy, fz = fx/f_len, fy/f_len, fz/f_len\n\n    # Calculate right vector (cross product of forward and up)\n    rx = fy * up[2] - fz * up[1]\n    ry = fz * up[0] - fx * up[2]\n    rz = fx * up[1] - fy * up[0]\n    r_len = math.sqrt(rx*rx + ry*ry + rz*rz)\n    rx, ry, rz = rx/r_len, ry/r_len, rz/r_len\n\n    # Calculate true up vector (cross product of right and forward)\n    ux = ry * fz - rz * fy\n    uy = rz * fx - rx * fz\n    uz = rx * fy - ry * fx\n\n    # Create view matrix (inverted camera transform)\n    return [\n        [round(rx, 3), round(ux, 3), round(-fx, 3), round(-(rx*eye[0] + ux*eye[1] - fx*eye[2]), 3)],\n        [round(ry, 3), round(uy, 3), round(-fy, 3), round(-(ry*eye[0] + uy*eye[1] - fy*eye[2]), 3)],\n        [round(rz, 3), round(uz, 3), round(-fz, 3), round(-(rz*eye[0] + uz*eye[1] - fz*eye[2]), 3)],\n        [0, 0, 0, 1]\n    ]",
    "testCases": [
      {
        "input": "(0, 0, 5), (0, 0, 0), (0, 1, 0)",
        "expectedOutput": "[[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, -5.0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Camera at +Z looking at origin"
      },
      {
        "input": "(0, 0, 0), (0, 0, -1), (0, 1, 0)",
        "expectedOutput": "[[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Camera at origin looking down -Z"
      },
      {
        "input": "(5, 5, 5), (0, 0, 0), (0, 1, 0)",
        "expectedOutput": "[[0.707, 0.0, 0.707, 0.0], [-0.408, 0.816, 0.408, 0.0], [-0.577, -0.577, 0.577, -8.66], [0, 0, 0, 1]]",
        "isHidden": false,
        "description": "Camera at diagonal"
      },
      {
        "input": "(10, 0, 0), (0, 0, 0), (0, 1, 0)",
        "expectedOutput": "[[0.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 0.0], [-1.0, 0.0, 0.0, -10.0], [0, 0, 0, 1]]",
        "isHidden": true,
        "description": "Camera on +X axis"
      }
    ],
    "hints": [
      "Calculate forward (Z) vector: normalize(center - eye)",
      "Calculate right (X) vector: normalize(forward × up)",
      "Calculate true up (Y) vector: right × forward",
      "Build rotation part from right, up, -forward vectors",
      "Add translation: -(rotation * eye)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Camera Right Vector",
    "difficulty": 2,
    "description": "Calculate the camera right vector given forward direction and up vector using cross product. Normalize and round to 3 decimals.",
    "starterCode": "import math\n\ndef camera_right_vector(forward, up):\n    \"\"\"\n    Calculate camera right vector.\n\n    Args:\n        forward: Forward direction as tuple (x, y, z)\n        up: Up direction as tuple (x, y, z)\n\n    Returns:\n        Normalized right vector as tuple\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef camera_right_vector(forward, up):\n    \"\"\"\n    Calculate camera right vector.\n\n    Args:\n        forward: Forward direction as tuple (x, y, z)\n        up: Up direction as tuple (x, y, z)\n\n    Returns:\n        Normalized right vector as tuple\n    \"\"\"\n    # Cross product: forward × up\n    rx = forward[1] * up[2] - forward[2] * up[1]\n    ry = forward[2] * up[0] - forward[0] * up[2]\n    rz = forward[0] * up[1] - forward[1] * up[0]\n\n    # Normalize\n    length = math.sqrt(rx*rx + ry*ry + rz*rz)\n    return (round(rx/length, 3), round(ry/length, 3), round(rz/length, 3))",
    "testCases": [
      {
        "input": "(0, 0, -1), (0, 1, 0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Standard camera orientation"
      },
      {
        "input": "(1, 0, 0), (0, 1, 0)",
        "expectedOutput": "(0.0, 0.0, -1.0)",
        "isHidden": false,
        "description": "Looking along +X"
      },
      {
        "input": "(0, -1, 0), (0, 0, 1)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Looking down"
      },
      {
        "input": "(1, 1, 0), (0, 0, 1)",
        "expectedOutput": "(0.707, -0.707, 0.0)",
        "isHidden": true,
        "description": "Diagonal forward"
      }
    ],
    "hints": [
      "Right = forward × up (cross product)",
      "Normalize the result",
      "Round to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Depth Buffer Value Calculation",
    "difficulty": 3,
    "description": "Calculate normalized depth buffer value (0-1) from view-space Z coordinate using perspective projection. Given z, near, and far planes, return depth value.",
    "starterCode": "def calculate_depth(z, near, far):\n    \"\"\"\n    Calculate normalized depth buffer value.\n\n    Args:\n        z: View-space Z coordinate (negative for in front)\n        near: Near clipping plane distance\n        far: Far clipping plane distance\n\n    Returns:\n        Depth value in range [0, 1] rounded to 4 decimals\n    \"\"\"\n    pass",
    "solution": "def calculate_depth(z, near, far):\n    \"\"\"\n    Calculate normalized depth buffer value.\n\n    Args:\n        z: View-space Z coordinate (negative for in front)\n        near: Near clipping plane distance\n        far: Far clipping plane distance\n\n    Returns:\n        Depth value in range [0, 1] rounded to 4 decimals\n    \"\"\"\n    # Perspective projection depth calculation\n    depth = (far + near) / (near - far) + (2 * far * near) / (z * (near - far))\n    # Normalize to [0, 1]\n    normalized = (depth + 1) / 2\n    return round(normalized, 4)",
    "testCases": [
      {
        "input": "-1, 1, 100",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "At near plane"
      },
      {
        "input": "-100, 1, 100",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "At far plane"
      },
      {
        "input": "-10, 1, 100",
        "expectedOutput": "0.0919",
        "isHidden": false,
        "description": "Between near and far"
      },
      {
        "input": "-50, 0.1, 1000",
        "expectedOutput": "0.5492",
        "isHidden": true,
        "description": "Wide depth range"
      }
    ],
    "hints": [
      "Use perspective projection depth formula",
      "depth = (f+n)/(n-f) + (2*f*n)/(z*(n-f))",
      "Normalize from [-1,1] to [0,1]: (depth+1)/2",
      "Round to 4 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Point in View Frustum Test",
    "difficulty": 4,
    "description": "Test if a point in NDC space is inside the view frustum (all coordinates in range [-1, 1]). Return True if inside, False otherwise.",
    "starterCode": "def point_in_frustum(x, y, z):\n    \"\"\"\n    Test if point is inside view frustum.\n\n    Args:\n        x, y, z: NDC coordinates\n\n    Returns:\n        True if inside frustum, False otherwise\n    \"\"\"\n    pass",
    "solution": "def point_in_frustum(x, y, z):\n    \"\"\"\n    Test if point is inside view frustum.\n\n    Args:\n        x, y, z: NDC coordinates\n\n    Returns:\n        True if inside frustum, False otherwise\n    \"\"\"\n    return (-1 <= x <= 1) and (-1 <= y <= 1) and (-1 <= z <= 1)",
    "testCases": [
      {
        "input": "0, 0, 0",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Center of frustum"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Corner of frustum"
      },
      {
        "input": "1.5, 0, 0",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Outside in X"
      },
      {
        "input": "0.5, -0.5, 0.9",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Inside frustum"
      }
    ],
    "hints": [
      "Check if all coordinates are in range [-1, 1]",
      "Use logical AND for all three conditions"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Aspect Ratio from Dimensions",
    "difficulty": 1,
    "description": "Calculate aspect ratio from width and height. Return as float rounded to 3 decimals.",
    "starterCode": "def aspect_ratio(width, height):\n    \"\"\"\n    Calculate aspect ratio.\n\n    Args:\n        width: Screen/viewport width\n        height: Screen/viewport height\n\n    Returns:\n        Aspect ratio (width/height) rounded to 3 decimals\n    \"\"\"\n    pass",
    "solution": "def aspect_ratio(width, height):\n    \"\"\"\n    Calculate aspect ratio.\n\n    Args:\n        width: Screen/viewport width\n        height: Screen/viewport height\n\n    Returns:\n        Aspect ratio (width/height) rounded to 3 decimals\n    \"\"\"\n    return round(width / height, 3)",
    "testCases": [
      {
        "input": "1920, 1080",
        "expectedOutput": "1.778",
        "isHidden": false,
        "description": "16:9 aspect ratio"
      },
      {
        "input": "1024, 768",
        "expectedOutput": "1.333",
        "isHidden": false,
        "description": "4:3 aspect ratio"
      },
      {
        "input": "1920, 1200",
        "expectedOutput": "1.6",
        "isHidden": false,
        "description": "16:10 aspect ratio"
      },
      {
        "input": "800, 800",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Square 1:1"
      }
    ],
    "hints": [
      "Aspect ratio = width / height",
      "Round to 3 decimal places"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "View-Space to Clip-Space",
    "difficulty": 4,
    "description": "Transform a view-space point to clip-space using a projection matrix. Return the clip-space coordinates (x, y, z, w).",
    "starterCode": "def view_to_clip(point, projection_matrix):\n    \"\"\"\n    Transform view-space point to clip-space.\n\n    Args:\n        point: View-space point as tuple (x, y, z)\n        projection_matrix: 4x4 projection matrix\n\n    Returns:\n        Clip-space coordinates as tuple (x, y, z, w)\n    \"\"\"\n    pass",
    "solution": "def view_to_clip(point, projection_matrix):\n    \"\"\"\n    Transform view-space point to clip-space.\n\n    Args:\n        point: View-space point as tuple (x, y, z)\n        projection_matrix: 4x4 projection matrix\n\n    Returns:\n        Clip-space coordinates as tuple (x, y, z, w)\n    \"\"\"\n    # Treat point as homogeneous [x, y, z, 1]\n    x = projection_matrix[0][0] * point[0] + projection_matrix[0][1] * point[1] + projection_matrix[0][2] * point[2] + projection_matrix[0][3]\n    y = projection_matrix[1][0] * point[0] + projection_matrix[1][1] * point[1] + projection_matrix[1][2] * point[2] + projection_matrix[1][3]\n    z = projection_matrix[2][0] * point[0] + projection_matrix[2][1] * point[1] + projection_matrix[2][2] * point[2] + projection_matrix[2][3]\n    w = projection_matrix[3][0] * point[0] + projection_matrix[3][1] * point[1] + projection_matrix[3][2] * point[2] + projection_matrix[3][3]\n\n    return (x, y, z, w)",
    "testCases": [
      {
        "input": "(0, 0, -1), [[1,0,0,0],[0,1,0,0],[0,0,-1,0],[0,0,-1,0]]",
        "expectedOutput": "(0, 0, 1, 1)",
        "isHidden": false,
        "description": "Simple projection"
      },
      {
        "input": "(1, 1, -2), [[2,0,0,0],[0,2,0,0],[0,0,-1.2,-2.2],[0,0,-1,0]]",
        "expectedOutput": "(2, 2, 4.6, 2)",
        "isHidden": false,
        "description": "Perspective projection"
      },
      {
        "input": "(0, 0, 0), [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]",
        "expectedOutput": "(0, 0, 0, 1)",
        "isHidden": false,
        "description": "Identity at origin"
      },
      {
        "input": "(5, 10, -15), [[0.5,0,0,0],[0,0.5,0,0],[0,0,-1,0],[0,0,-1,0]]",
        "expectedOutput": "(2.5, 5.0, 15, 15)",
        "isHidden": true,
        "description": "Scale and perspective"
      }
    ],
    "hints": [
      "Multiply 4x4 projection matrix by homogeneous point [x,y,z,1]",
      "Calculate each component: sum of matrix row * point vector",
      "Return all four components (x, y, z, w)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Reverse Z-Buffer Value",
    "difficulty": 4,
    "description": "Convert a normalized depth buffer value [0,1] back to view-space Z coordinate. Given depth, near, and far planes, return the Z value (negative).",
    "starterCode": "def depth_to_view_z(depth, near, far):\n    \"\"\"\n    Convert depth buffer value to view-space Z.\n\n    Args:\n        depth: Normalized depth value (0-1)\n        near: Near clipping plane distance\n        far: Far clipping plane distance\n\n    Returns:\n        View-space Z coordinate (negative) rounded to 3 decimals\n    \"\"\"\n    pass",
    "solution": "def depth_to_view_z(depth, near, far):\n    \"\"\"\n    Convert depth buffer value to view-space Z.\n\n    Args:\n        depth: Normalized depth value (0-1)\n        near: Near clipping plane distance\n        far: Far clipping plane distance\n\n    Returns:\n        View-space Z coordinate (negative) rounded to 3 decimals\n    \"\"\"\n    # Convert from [0,1] to [-1,1]\n    ndc_depth = depth * 2 - 1\n\n    # Reverse perspective projection\n    z = (2 * far * near) / ((far + near) - ndc_depth * (far - near))\n\n    return round(-z, 3)",
    "testCases": [
      {
        "input": "0.0, 1, 100",
        "expectedOutput": "-1.0",
        "isHidden": false,
        "description": "At near plane"
      },
      {
        "input": "1.0, 1, 100",
        "expectedOutput": "-100.0",
        "isHidden": false,
        "description": "At far plane"
      },
      {
        "input": "0.5, 1, 100",
        "expectedOutput": "-2.0",
        "isHidden": false,
        "description": "Midpoint (non-linear)"
      },
      {
        "input": "0.091, 0.1, 1000",
        "expectedOutput": "-1.0",
        "isHidden": true,
        "description": "Wide depth range"
      }
    ],
    "hints": [
      "Convert depth from [0,1] to [-1,1]: ndc = depth*2 - 1",
      "Use inverse perspective formula",
      "z = (2*f*n) / ((f+n) - ndc*(f-n))",
      "Negate result for view-space convention",
      "Round to 3 decimals"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t3-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-3",
    "title": "Camera Orbit Position",
    "difficulty": 5,
    "description": "Calculate camera position when orbiting around a target point. Given target, radius, azimuth (horizontal angle), and elevation (vertical angle) in degrees, return camera position.",
    "starterCode": "import math\n\ndef orbit_camera_position(target, radius, azimuth_deg, elevation_deg):\n    \"\"\"\n    Calculate camera position for orbit camera.\n\n    Args:\n        target: Target point as tuple (x, y, z)\n        radius: Distance from target\n        azimuth_deg: Horizontal angle in degrees (0=+X axis)\n        elevation_deg: Vertical angle in degrees (0=XZ plane, 90=+Y axis)\n\n    Returns:\n        Camera position as tuple (x, y, z) rounded to 3 decimals\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef orbit_camera_position(target, radius, azimuth_deg, elevation_deg):\n    \"\"\"\n    Calculate camera position for orbit camera.\n\n    Args:\n        target: Target point as tuple (x, y, z)\n        radius: Distance from target\n        azimuth_deg: Horizontal angle in degrees (0=+X axis)\n        elevation_deg: Vertical angle in degrees (0=XZ plane, 90=+Y axis)\n\n    Returns:\n        Camera position as tuple (x, y, z) rounded to 3 decimals\n    \"\"\"\n    azimuth_rad = math.radians(azimuth_deg)\n    elevation_rad = math.radians(elevation_deg)\n\n    # Spherical to Cartesian conversion\n    x = target[0] + radius * math.cos(elevation_rad) * math.cos(azimuth_rad)\n    y = target[1] + radius * math.sin(elevation_rad)\n    z = target[2] + radius * math.cos(elevation_rad) * math.sin(azimuth_rad)\n\n    return (round(x, 3), round(y, 3), round(z, 3))",
    "testCases": [
      {
        "input": "(0, 0, 0), 10, 0, 0",
        "expectedOutput": "(10.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "On +X axis"
      },
      {
        "input": "(0, 0, 0), 10, 90, 0",
        "expectedOutput": "(0.0, 0.0, 10.0)",
        "isHidden": false,
        "description": "On +Z axis"
      },
      {
        "input": "(0, 0, 0), 10, 0, 90",
        "expectedOutput": "(0.0, 10.0, 0.0)",
        "isHidden": false,
        "description": "On +Y axis (top)"
      },
      {
        "input": "(5, 5, 5), 10, 45, 30",
        "expectedOutput": "(11.124, 10.0, 11.124)",
        "isHidden": true,
        "description": "Arbitrary orbit with offset target"
      }
    ],
    "hints": [
      "Convert angles to radians",
      "Use spherical coordinates: (radius, azimuth, elevation)",
      "x = target.x + r * cos(elev) * cos(azim)",
      "y = target.y + r * sin(elev)",
      "z = target.z + r * cos(elev) * sin(azim)",
      "Round to 3 decimals"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Plot Pixel Coordinates",
    "difficulty": 1,
    "description": "Write a function that takes pixel coordinates (x, y) and validates if they fall within a screen buffer of given width and height. Return True if valid, False otherwise.",
    "starterCode": "def is_valid_pixel(x, y, width, height):\n    \"\"\"\n    Check if pixel coordinates are within screen bounds.\n\n    Args:\n        x: X coordinate\n        y: Y coordinate\n        width: Screen width\n        height: Screen height\n\n    Returns:\n        bool: True if pixel is valid, False otherwise\n    \"\"\"\n    pass",
    "solution": "def is_valid_pixel(x, y, width, height):\n    \"\"\"\n    Check if pixel coordinates are within screen bounds.\n\n    Args:\n        x: X coordinate\n        y: Y coordinate\n        width: Screen width\n        height: Screen height\n\n    Returns:\n        bool: True if pixel is valid, False otherwise\n    \"\"\"\n    return 0 <= x < width and 0 <= y < height",
    "testCases": [
      {
        "input": "5, 5, 10, 10",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid pixel in center"
      },
      {
        "input": "0, 0, 10, 10",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid pixel at origin"
      },
      {
        "input": "-1, 5, 10, 10",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid negative x"
      },
      {
        "input": "10, 5, 10, 10",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Invalid x at boundary"
      },
      {
        "input": "5, 15, 10, 10",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Invalid y beyond boundary"
      }
    ],
    "hints": [
      "Check if coordinates are non-negative",
      "Remember that valid coordinates range from 0 to width-1 and 0 to height-1",
      "Use logical AND to combine both x and y checks"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Calculate Line Slope",
    "difficulty": 1,
    "description": "Implement a function to calculate the slope of a line given two points (x0, y0) and (x1, y1). Handle vertical lines by returning None.",
    "starterCode": "def calculate_slope(x0, y0, x1, y1):\n    \"\"\"\n    Calculate the slope of a line between two points.\n\n    Args:\n        x0, y0: First point coordinates\n        x1, y1: Second point coordinates\n\n    Returns:\n        float or None: Slope value, or None for vertical lines\n    \"\"\"\n    pass",
    "solution": "def calculate_slope(x0, y0, x1, y1):\n    \"\"\"\n    Calculate the slope of a line between two points.\n\n    Args:\n        x0, y0: First point coordinates\n        x1, y1: Second point coordinates\n\n    Returns:\n        float or None: Slope value, or None for vertical lines\n    \"\"\"\n    if x1 == x0:\n        return None\n    return (y1 - y0) / (x1 - x0)",
    "testCases": [
      {
        "input": "0, 0, 4, 4",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "45 degree line"
      },
      {
        "input": "0, 0, 4, 2",
        "expectedOutput": "0.5",
        "isHidden": false,
        "description": "Gentle slope"
      },
      {
        "input": "2, 3, 2, 7",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Vertical line"
      },
      {
        "input": "1, 5, 5, 1",
        "expectedOutput": "-1.0",
        "isHidden": true,
        "description": "Negative slope"
      },
      {
        "input": "0, 3, 6, 3",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Horizontal line"
      }
    ],
    "hints": [
      "Slope is rise over run: (y1 - y0) / (x1 - x0)",
      "Check for division by zero when x1 equals x0",
      "Vertical lines have undefined slope"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "DDA Line Drawing",
    "difficulty": 2,
    "description": "Implement the Digital Differential Analyzer (DDA) algorithm to generate a list of pixel coordinates that form a line between two points.",
    "starterCode": "def dda_line(x0, y0, x1, y1):\n    \"\"\"\n    Generate line pixels using DDA algorithm.\n\n    Args:\n        x0, y0: Starting point\n        x1, y1: Ending point\n\n    Returns:\n        list: List of (x, y) tuples representing pixel coordinates\n    \"\"\"\n    pass",
    "solution": "def dda_line(x0, y0, x1, y1):\n    \"\"\"\n    Generate line pixels using DDA algorithm.\n\n    Args:\n        x0, y0: Starting point\n        x1, y1: Ending point\n\n    Returns:\n        list: List of (x, y) tuples representing pixel coordinates\n    \"\"\"\n    pixels = []\n    dx = x1 - x0\n    dy = y1 - y0\n\n    # Determine number of steps\n    steps = max(abs(dx), abs(dy))\n\n    if steps == 0:\n        return [(x0, y0)]\n\n    # Calculate increment for each step\n    x_inc = dx / steps\n    y_inc = dy / steps\n\n    # Generate pixels\n    x, y = x0, y0\n    for _ in range(steps + 1):\n        pixels.append((round(x), round(y)))\n        x += x_inc\n        y += y_inc\n\n    return pixels",
    "testCases": [
      {
        "input": "0, 0, 3, 3",
        "expectedOutput": "[(0, 0), (1, 1), (2, 2), (3, 3)]",
        "isHidden": false,
        "description": "Diagonal line"
      },
      {
        "input": "0, 0, 0, 3",
        "expectedOutput": "[(0, 0), (0, 1), (0, 2), (0, 3)]",
        "isHidden": false,
        "description": "Vertical line"
      },
      {
        "input": "1, 1, 4, 2",
        "expectedOutput": "[(1, 1), (2, 1), (3, 2), (4, 2)]",
        "isHidden": true,
        "description": "Gentle slope line"
      },
      {
        "input": "0, 0, 0, 0",
        "expectedOutput": "[(0, 0)]",
        "isHidden": true,
        "description": "Single point"
      }
    ],
    "hints": [
      "Calculate dx and dy as the differences in coordinates",
      "Number of steps is the maximum of abs(dx) and abs(dy)",
      "Increment by dx/steps and dy/steps at each iteration",
      "Round floating point values to get integer pixel coordinates"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Pixel Distance Calculation",
    "difficulty": 2,
    "description": "Calculate the Euclidean distance between two pixels. This is useful for antialiasing and distance-based computations in rasterization.",
    "starterCode": "import math\n\ndef pixel_distance(x0, y0, x1, y1):\n    \"\"\"\n    Calculate Euclidean distance between two pixels.\n\n    Args:\n        x0, y0: First pixel coordinates\n        x1, y1: Second pixel coordinates\n\n    Returns:\n        float: Distance between pixels\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef pixel_distance(x0, y0, x1, y1):\n    \"\"\"\n    Calculate Euclidean distance between two pixels.\n\n    Args:\n        x0, y0: First pixel coordinates\n        x1, y1: Second pixel coordinates\n\n    Returns:\n        float: Distance between pixels\n    \"\"\"\n    dx = x1 - x0\n    dy = y1 - y0\n    return math.sqrt(dx * dx + dy * dy)",
    "testCases": [
      {
        "input": "0, 0, 3, 4",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "3-4-5 triangle"
      },
      {
        "input": "0, 0, 1, 1",
        "expectedOutput": "1.414",
        "isHidden": false,
        "description": "Diagonal distance (rounded to 3 decimals)"
      },
      {
        "input": "5, 5, 5, 5",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Same point"
      },
      {
        "input": "0, 0, 0, 10",
        "expectedOutput": "10.0",
        "isHidden": true,
        "description": "Vertical distance"
      },
      {
        "input": "-2, 3, 4, -5",
        "expectedOutput": "10.0",
        "isHidden": true,
        "description": "Negative coordinates"
      }
    ],
    "hints": [
      "Use the Pythagorean theorem: distance = sqrt(dx² + dy²)",
      "Calculate dx and dy first",
      "Import math module for sqrt function"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Bresenham Line Algorithm",
    "difficulty": 3,
    "description": "Implement Bresenham's line algorithm for the first octant (where 0 ≤ slope ≤ 1). This integer-only algorithm is more efficient than DDA.",
    "starterCode": "def bresenham_line(x0, y0, x1, y1):\n    \"\"\"\n    Generate line pixels using Bresenham's algorithm (first octant).\n    Assumes x1 >= x0 and 0 <= slope <= 1.\n\n    Args:\n        x0, y0: Starting point\n        x1, y1: Ending point\n\n    Returns:\n        list: List of (x, y) tuples representing pixel coordinates\n    \"\"\"\n    pass",
    "solution": "def bresenham_line(x0, y0, x1, y1):\n    \"\"\"\n    Generate line pixels using Bresenham's algorithm (first octant).\n    Assumes x1 >= x0 and 0 <= slope <= 1.\n\n    Args:\n        x0, y0: Starting point\n        x1, y1: Ending point\n\n    Returns:\n        list: List of (x, y) tuples representing pixel coordinates\n    \"\"\"\n    pixels = []\n    dx = x1 - x0\n    dy = y1 - y0\n\n    y = y0\n    d = 2 * dy - dx  # Initial decision parameter\n\n    for x in range(x0, x1 + 1):\n        pixels.append((x, y))\n\n        if d > 0:\n            y += 1\n            d += 2 * (dy - dx)\n        else:\n            d += 2 * dy\n\n    return pixels",
    "testCases": [
      {
        "input": "0, 0, 4, 2",
        "expectedOutput": "[(0, 0), (1, 0), (2, 1), (3, 1), (4, 2)]",
        "isHidden": false,
        "description": "Gentle slope line"
      },
      {
        "input": "0, 0, 4, 4",
        "expectedOutput": "[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]",
        "isHidden": false,
        "description": "45 degree line"
      },
      {
        "input": "1, 2, 5, 3",
        "expectedOutput": "[(1, 2), (2, 2), (3, 3), (4, 3), (5, 3)]",
        "isHidden": true,
        "description": "Very gentle slope"
      },
      {
        "input": "0, 0, 8, 3",
        "expectedOutput": "[(0, 0), (1, 0), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2), (7, 3), (8, 3)]",
        "isHidden": true,
        "description": "Longer line"
      }
    ],
    "hints": [
      "Initialize decision parameter d = 2*dy - dx",
      "If d > 0, increment y and update d by 2*(dy - dx)",
      "Otherwise, keep y the same and update d by 2*dy",
      "Iterate x from x0 to x1"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Midpoint Circle Algorithm",
    "difficulty": 3,
    "description": "Implement the midpoint circle algorithm to generate pixels for one octant of a circle. The algorithm uses integer arithmetic to efficiently rasterize circles.",
    "starterCode": "def circle_octant(radius):\n    \"\"\"\n    Generate pixels for first octant of circle using midpoint algorithm.\n    Circle is centered at origin.\n\n    Args:\n        radius: Circle radius\n\n    Returns:\n        list: List of (x, y) tuples for first octant\n    \"\"\"\n    pass",
    "solution": "def circle_octant(radius):\n    \"\"\"\n    Generate pixels for first octant of circle using midpoint algorithm.\n    Circle is centered at origin.\n\n    Args:\n        radius: Circle radius\n\n    Returns:\n        list: List of (x, y) tuples for first octant\n    \"\"\"\n    pixels = []\n    x = 0\n    y = radius\n    d = 1 - radius  # Initial decision parameter\n\n    while x <= y:\n        pixels.append((x, y))\n\n        if d < 0:\n            d += 2 * x + 3\n        else:\n            d += 2 * (x - y) + 5\n            y -= 1\n\n        x += 1\n\n    return pixels",
    "testCases": [
      {
        "input": "5",
        "expectedOutput": "[(0, 5), (1, 5), (2, 5), (3, 4), (4, 3)]",
        "isHidden": false,
        "description": "Circle radius 5"
      },
      {
        "input": "3",
        "expectedOutput": "[(0, 3), (1, 3), (2, 2)]",
        "isHidden": false,
        "description": "Circle radius 3"
      },
      {
        "input": "8",
        "expectedOutput": "[(0, 8), (1, 8), (2, 8), (3, 7), (4, 7), (5, 6), (6, 5)]",
        "isHidden": true,
        "description": "Circle radius 8"
      },
      {
        "input": "1",
        "expectedOutput": "[(0, 1), (1, 0)]",
        "isHidden": true,
        "description": "Small circle radius 1"
      }
    ],
    "hints": [
      "Initialize x = 0, y = radius, and d = 1 - radius",
      "Continue while x <= y",
      "If d < 0, update d by 2*x + 3",
      "Otherwise, update d by 2*(x - y) + 5 and decrement y",
      "Always increment x"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Scanline Fill Algorithm",
    "difficulty": 3,
    "description": "Implement a simple scanline fill for a horizontal line segment. Given y-coordinate and x-range, return all pixels that should be filled.",
    "starterCode": "def scanline_fill(y, x_start, x_end):\n    \"\"\"\n    Fill pixels along a horizontal scanline.\n\n    Args:\n        y: Y coordinate of scanline\n        x_start: Starting x coordinate\n        x_end: Ending x coordinate\n\n    Returns:\n        list: List of (x, y) tuples to be filled\n    \"\"\"\n    pass",
    "solution": "def scanline_fill(y, x_start, x_end):\n    \"\"\"\n    Fill pixels along a horizontal scanline.\n\n    Args:\n        y: Y coordinate of scanline\n        x_start: Starting x coordinate\n        x_end: Ending x coordinate\n\n    Returns:\n        list: List of (x, y) tuples to be filled\n    \"\"\"\n    # Ensure x_start is less than or equal to x_end\n    if x_start > x_end:\n        x_start, x_end = x_end, x_start\n\n    pixels = []\n    for x in range(x_start, x_end + 1):\n        pixels.append((x, y))\n\n    return pixels",
    "testCases": [
      {
        "input": "5, 2, 6",
        "expectedOutput": "[(2, 5), (3, 5), (4, 5), (5, 5), (6, 5)]",
        "isHidden": false,
        "description": "Normal scanline"
      },
      {
        "input": "0, 0, 0",
        "expectedOutput": "[(0, 0)]",
        "isHidden": false,
        "description": "Single pixel"
      },
      {
        "input": "3, 8, 4",
        "expectedOutput": "[(4, 3), (5, 3), (6, 3), (7, 3), (8, 3)]",
        "isHidden": true,
        "description": "Reversed x coordinates"
      },
      {
        "input": "10, 1, 10",
        "expectedOutput": "[(1, 10), (2, 10), (3, 10), (4, 10), (5, 10), (6, 10), (7, 10), (8, 10), (9, 10), (10, 10)]",
        "isHidden": true,
        "description": "Longer scanline"
      }
    ],
    "hints": [
      "Generate all pixels from x_start to x_end at the same y coordinate",
      "Handle the case where x_start > x_end by swapping them",
      "Use range to iterate from x_start to x_end inclusive"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Depth Buffer Comparison",
    "difficulty": 3,
    "description": "Implement depth buffer comparison. Given current depth value and new depth value, determine if the new pixel should be drawn (closer to camera means smaller z-value).",
    "starterCode": "def should_update_pixel(current_depth, new_depth):\n    \"\"\"\n    Determine if pixel should be updated based on depth test.\n    Smaller depth values are closer to camera.\n\n    Args:\n        current_depth: Current depth in buffer (None if empty)\n        new_depth: New fragment depth\n\n    Returns:\n        bool: True if pixel should be updated, False otherwise\n    \"\"\"\n    pass",
    "solution": "def should_update_pixel(current_depth, new_depth):\n    \"\"\"\n    Determine if pixel should be updated based on depth test.\n    Smaller depth values are closer to camera.\n\n    Args:\n        current_depth: Current depth in buffer (None if empty)\n        new_depth: New fragment depth\n\n    Returns:\n        bool: True if pixel should be updated, False otherwise\n    \"\"\"\n    # If buffer is empty, always draw\n    if current_depth is None:\n        return True\n\n    # Draw if new fragment is closer (smaller depth)\n    return new_depth < current_depth",
    "testCases": [
      {
        "input": "None, 0.5",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Empty buffer"
      },
      {
        "input": "0.8, 0.3",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Closer fragment"
      },
      {
        "input": "0.3, 0.8",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Farther fragment"
      },
      {
        "input": "0.5, 0.5",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Equal depth"
      },
      {
        "input": "1.0, 0.1",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Much closer fragment"
      }
    ],
    "hints": [
      "If current_depth is None, the buffer is empty and should be filled",
      "Smaller depth values indicate objects closer to the camera",
      "Update only if new_depth < current_depth"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Triangle Bounding Box",
    "difficulty": 3,
    "description": "Calculate the axis-aligned bounding box for a triangle given its three vertices. This is the first step in efficient triangle rasterization.",
    "starterCode": "def triangle_bounding_box(x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Calculate bounding box for a triangle.\n\n    Args:\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        tuple: (min_x, min_y, max_x, max_y)\n    \"\"\"\n    pass",
    "solution": "def triangle_bounding_box(x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Calculate bounding box for a triangle.\n\n    Args:\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        tuple: (min_x, min_y, max_x, max_y)\n    \"\"\"\n    min_x = min(x0, x1, x2)\n    max_x = max(x0, x1, x2)\n    min_y = min(y0, y1, y2)\n    max_y = max(y0, y1, y2)\n\n    return (min_x, min_y, max_x, max_y)",
    "testCases": [
      {
        "input": "0, 0, 4, 0, 2, 3",
        "expectedOutput": "(0, 0, 4, 3)",
        "isHidden": false,
        "description": "Simple triangle"
      },
      {
        "input": "1, 1, 1, 1, 1, 1",
        "expectedOutput": "(1, 1, 1, 1)",
        "isHidden": false,
        "description": "Degenerate triangle (point)"
      },
      {
        "input": "-2, -3, 5, 1, 0, 4",
        "expectedOutput": "(-2, -3, 5, 4)",
        "isHidden": true,
        "description": "Triangle with negative coordinates"
      },
      {
        "input": "10, 20, 5, 15, 8, 25",
        "expectedOutput": "(5, 15, 10, 25)",
        "isHidden": true,
        "description": "Unordered vertices"
      }
    ],
    "hints": [
      "Find the minimum x coordinate among all three vertices",
      "Find the maximum x coordinate among all three vertices",
      "Do the same for y coordinates",
      "Use min() and max() built-in functions"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Edge Function",
    "difficulty": 4,
    "description": "Implement the edge function used in triangle rasterization. The edge function determines which side of an edge a point lies on.",
    "starterCode": "def edge_function(ax, ay, bx, by, px, py):\n    \"\"\"\n    Calculate edge function for point P relative to edge AB.\n    Returns positive if P is on the left side of AB,\n    negative if on the right side, zero if on the edge.\n\n    Args:\n        ax, ay: First vertex of edge\n        bx, by: Second vertex of edge\n        px, py: Point to test\n\n    Returns:\n        float: Edge function value\n    \"\"\"\n    pass",
    "solution": "def edge_function(ax, ay, bx, by, px, py):\n    \"\"\"\n    Calculate edge function for point P relative to edge AB.\n    Returns positive if P is on the left side of AB,\n    negative if on the right side, zero if on the edge.\n\n    Args:\n        ax, ay: First vertex of edge\n        bx, by: Second vertex of edge\n        px, py: Point to test\n\n    Returns:\n        float: Edge function value\n    \"\"\"\n    return (bx - ax) * (py - ay) - (by - ay) * (px - ax)",
    "testCases": [
      {
        "input": "0, 0, 4, 0, 2, 2",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Point above horizontal edge"
      },
      {
        "input": "0, 0, 4, 0, 2, -2",
        "expectedOutput": "-8",
        "isHidden": false,
        "description": "Point below horizontal edge"
      },
      {
        "input": "0, 0, 4, 0, 2, 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Point on edge"
      },
      {
        "input": "0, 0, 0, 4, 2, 2",
        "expectedOutput": "8",
        "isHidden": true,
        "description": "Vertical edge"
      },
      {
        "input": "1, 1, 5, 3, 3, 1",
        "expectedOutput": "-4",
        "isHidden": true,
        "description": "Diagonal edge"
      }
    ],
    "hints": [
      "The edge function is based on the cross product",
      "Formula: (bx - ax) * (py - ay) - (by - ay) * (px - ax)",
      "Positive values indicate left side, negative indicates right side",
      "This is also known as the 2D cross product or implicit line equation"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Point in Triangle Test",
    "difficulty": 4,
    "description": "Determine if a point is inside a triangle using the edge function. A point is inside if it is on the correct side of all three edges.",
    "starterCode": "def point_in_triangle(px, py, x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Test if point P is inside triangle with counter-clockwise vertices.\n\n    Args:\n        px, py: Point to test\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        bool: True if point is inside triangle, False otherwise\n    \"\"\"\n    pass",
    "solution": "def point_in_triangle(px, py, x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Test if point P is inside triangle with counter-clockwise vertices.\n\n    Args:\n        px, py: Point to test\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        bool: True if point is inside triangle, False otherwise\n    \"\"\"\n    def edge_function(ax, ay, bx, by, px, py):\n        return (bx - ax) * (py - ay) - (by - ay) * (px - ax)\n\n    # Calculate edge functions for all three edges\n    w0 = edge_function(x1, y1, x2, y2, px, py)\n    w1 = edge_function(x2, y2, x0, y0, px, py)\n    w2 = edge_function(x0, y0, x1, y1, px, py)\n\n    # Point is inside if all edge functions have same sign (all >= 0 for CCW)\n    return w0 >= 0 and w1 >= 0 and w2 >= 0",
    "testCases": [
      {
        "input": "2, 1, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Point inside triangle"
      },
      {
        "input": "5, 5, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Point outside triangle"
      },
      {
        "input": "0, 0, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Point on vertex"
      },
      {
        "input": "2, 0, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Point on edge"
      },
      {
        "input": "1, 2, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Point near edge but inside"
      }
    ],
    "hints": [
      "Use the edge function for each of the three edges",
      "For counter-clockwise vertices, point is inside if all edge functions >= 0",
      "Check edges in order: (v1,v2), (v2,v0), (v0,v1)",
      "Include points on edges (use >= not just >)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Barycentric Coordinates",
    "difficulty": 4,
    "description": "Calculate barycentric coordinates of a point with respect to a triangle. These coordinates are used for interpolation in rasterization.",
    "starterCode": "def barycentric_coordinates(px, py, x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Calculate barycentric coordinates (w0, w1, w2) for point P.\n    The coordinates satisfy: P = w0*V0 + w1*V1 + w2*V2 where w0+w1+w2=1.\n\n    Args:\n        px, py: Point coordinates\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        tuple: (w0, w1, w2) barycentric coordinates, or None if triangle is degenerate\n    \"\"\"\n    pass",
    "solution": "def barycentric_coordinates(px, py, x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Calculate barycentric coordinates (w0, w1, w2) for point P.\n    The coordinates satisfy: P = w0*V0 + w1*V1 + w2*V2 where w0+w1+w2=1.\n\n    Args:\n        px, py: Point coordinates\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        tuple: (w0, w1, w2) barycentric coordinates, or None if triangle is degenerate\n    \"\"\"\n    def edge_function(ax, ay, bx, by, px, py):\n        return (bx - ax) * (py - ay) - (by - ay) * (px - ax)\n\n    # Calculate area of full triangle (twice the area)\n    area = edge_function(x0, y0, x1, y1, x2, y2)\n\n    if area == 0:\n        return None  # Degenerate triangle\n\n    # Calculate barycentric coordinates\n    w0 = edge_function(x1, y1, x2, y2, px, py) / area\n    w1 = edge_function(x2, y2, x0, y0, px, py) / area\n    w2 = edge_function(x0, y0, x1, y1, px, py) / area\n\n    return (w0, w1, w2)",
    "testCases": [
      {
        "input": "0, 0, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Point at first vertex"
      },
      {
        "input": "2, 1, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "(0.333, 0.333, 0.333)",
        "isHidden": false,
        "description": "Point near centroid (rounded to 3 decimals)"
      },
      {
        "input": "4, 0, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": true,
        "description": "Point at second vertex"
      },
      {
        "input": "2, 0, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "(0.5, 0.5, 0.0)",
        "isHidden": true,
        "description": "Point on edge between v0 and v1"
      }
    ],
    "hints": [
      "Use edge functions to calculate the barycentric coordinates",
      "w0 corresponds to the ratio of the area opposite to v0",
      "Calculate the total triangle area using edge_function(v0, v1, v2)",
      "Each coordinate is the edge function divided by the total area",
      "The three coordinates should sum to 1.0"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Interpolate Vertex Attributes",
    "difficulty": 4,
    "description": "Given barycentric coordinates and vertex attributes (like colors or texture coordinates), interpolate the attribute value at a point inside the triangle.",
    "starterCode": "def interpolate_attribute(w0, w1, w2, attr0, attr1, attr2):\n    \"\"\"\n    Interpolate vertex attribute using barycentric coordinates.\n\n    Args:\n        w0, w1, w2: Barycentric coordinates\n        attr0, attr1, attr2: Attribute values at each vertex\n\n    Returns:\n        float: Interpolated attribute value\n    \"\"\"\n    pass",
    "solution": "def interpolate_attribute(w0, w1, w2, attr0, attr1, attr2):\n    \"\"\"\n    Interpolate vertex attribute using barycentric coordinates.\n\n    Args:\n        w0, w1, w2: Barycentric coordinates\n        attr0, attr1, attr2: Attribute values at each vertex\n\n    Returns:\n        float: Interpolated attribute value\n    \"\"\"\n    return w0 * attr0 + w1 * attr1 + w2 * attr2",
    "testCases": [
      {
        "input": "1.0, 0.0, 0.0, 10, 20, 30",
        "expectedOutput": "10.0",
        "isHidden": false,
        "description": "At first vertex"
      },
      {
        "input": "0.5, 0.5, 0.0, 0, 100, 50",
        "expectedOutput": "50.0",
        "isHidden": false,
        "description": "Midpoint between v0 and v1"
      },
      {
        "input": "0.333, 0.333, 0.334, 0, 0, 300",
        "expectedOutput": "100.2",
        "isHidden": false,
        "description": "Near centroid"
      },
      {
        "input": "0.25, 0.25, 0.5, 100, 200, 300",
        "expectedOutput": "225.0",
        "isHidden": true,
        "description": "Weighted interpolation"
      },
      {
        "input": "0.0, 1.0, 0.0, 5.5, 10.5, 15.5",
        "expectedOutput": "10.5",
        "isHidden": true,
        "description": "At second vertex with decimals"
      }
    ],
    "hints": [
      "Linear interpolation formula: result = w0*attr0 + w1*attr1 + w2*attr2",
      "Barycentric coordinates provide the weights for interpolation",
      "This works for any attribute: colors, depths, texture coordinates, etc."
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Simple Triangle Rasterization",
    "difficulty": 4,
    "description": "Implement basic triangle rasterization by combining bounding box iteration with point-in-triangle testing. Return all pixels that fall inside the triangle.",
    "starterCode": "def rasterize_triangle(x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Rasterize a triangle and return all pixels inside it.\n    Vertices are in counter-clockwise order.\n\n    Args:\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        list: List of (x, y) tuples representing pixels inside triangle\n    \"\"\"\n    pass",
    "solution": "def rasterize_triangle(x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Rasterize a triangle and return all pixels inside it.\n    Vertices are in counter-clockwise order.\n\n    Args:\n        x0, y0: First vertex\n        x1, y1: Second vertex\n        x2, y2: Third vertex\n\n    Returns:\n        list: List of (x, y) tuples representing pixels inside triangle\n    \"\"\"\n    def edge_function(ax, ay, bx, by, px, py):\n        return (bx - ax) * (py - ay) - (by - ay) * (px - ax)\n\n    # Calculate bounding box\n    min_x = int(min(x0, x1, x2))\n    max_x = int(max(x0, x1, x2))\n    min_y = int(min(y0, y1, y2))\n    max_y = int(max(y0, y1, y2))\n\n    pixels = []\n\n    # Iterate over bounding box\n    for y in range(min_y, max_y + 1):\n        for x in range(min_x, max_x + 1):\n            # Test if pixel center is inside triangle\n            w0 = edge_function(x1, y1, x2, y2, x, y)\n            w1 = edge_function(x2, y2, x0, y0, x, y)\n            w2 = edge_function(x0, y0, x1, y1, x, y)\n\n            # Include if all edge functions are non-negative\n            if w0 >= 0 and w1 >= 0 and w2 >= 0:\n                pixels.append((x, y))\n\n    return pixels",
    "testCases": [
      {
        "input": "0, 0, 4, 0, 2, 2",
        "expectedOutput": "[(1, 0), (2, 0), (3, 0), (1, 1), (2, 1), (3, 1), (2, 2)]",
        "isHidden": false,
        "description": "Small triangle"
      },
      {
        "input": "0, 0, 2, 0, 1, 1",
        "expectedOutput": "[(0, 0), (1, 0), (2, 0), (1, 1)]",
        "isHidden": false,
        "description": "Tiny triangle"
      },
      {
        "input": "0, 0, 3, 0, 0, 3",
        "expectedOutput": "[(0, 0), (1, 0), (2, 0), (3, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (0, 3)]",
        "isHidden": true,
        "description": "Right triangle"
      }
    ],
    "hints": [
      "First calculate the bounding box of the triangle",
      "Iterate through all pixels in the bounding box",
      "For each pixel, test if it is inside using edge functions",
      "Add pixels where all three edge functions are >= 0",
      "Convert coordinates to integers for pixel grid"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Coverage Calculation for Antialiasing",
    "difficulty": 5,
    "description": "Calculate the approximate coverage (0.0 to 1.0) of a pixel by a line segment. This is used for antialiasing by determining how much of the pixel is covered.",
    "starterCode": "def line_coverage(pixel_x, pixel_y, x0, y0, x1, y1):\n    \"\"\"\n    Estimate coverage of a pixel by a line segment for antialiasing.\n    Uses perpendicular distance from pixel center to line.\n    Coverage decreases linearly from 1.0 at distance 0 to 0.0 at distance 0.5.\n\n    Args:\n        pixel_x, pixel_y: Pixel center coordinates\n        x0, y0: Line start point\n        x1, y1: Line end point\n\n    Returns:\n        float: Coverage value between 0.0 and 1.0\n    \"\"\"\n    pass",
    "solution": "def line_coverage(pixel_x, pixel_y, x0, y0, x1, y1):\n    \"\"\"\n    Estimate coverage of a pixel by a line segment for antialiasing.\n    Uses perpendicular distance from pixel center to line.\n    Coverage decreases linearly from 1.0 at distance 0 to 0.0 at distance 0.5.\n\n    Args:\n        pixel_x, pixel_y: Pixel center coordinates\n        x0, y0: Line start point\n        x1, y1: Line end point\n\n    Returns:\n        float: Coverage value between 0.0 and 1.0\n    \"\"\"\n    import math\n\n    # Calculate line vector\n    dx = x1 - x0\n    dy = y1 - y0\n\n    # Calculate vector from line start to pixel\n    px = pixel_x - x0\n    py = pixel_y - y0\n\n    # Calculate line length squared\n    length_sq = dx * dx + dy * dy\n\n    if length_sq == 0:\n        # Degenerate line (point)\n        dist = math.sqrt(px * px + py * py)\n    else:\n        # Calculate perpendicular distance using cross product\n        cross = abs(dx * py - dy * px)\n        length = math.sqrt(length_sq)\n        dist = cross / length\n\n    # Linear falloff: 1.0 at distance 0, 0.0 at distance 0.5\n    coverage = max(0.0, 1.0 - dist / 0.5)\n\n    return coverage",
    "testCases": [
      {
        "input": "2, 0, 0, 0, 4, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Pixel on horizontal line"
      },
      {
        "input": "2, 0.25, 0, 0, 4, 0",
        "expectedOutput": "0.5",
        "isHidden": false,
        "description": "Pixel half pixel away"
      },
      {
        "input": "2, 0.5, 0, 0, 4, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Pixel at falloff distance"
      },
      {
        "input": "2, 1, 0, 0, 4, 0",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Pixel far from line"
      },
      {
        "input": "0, 0.1, 0, 0, 0, 4",
        "expectedOutput": "0.8",
        "isHidden": true,
        "description": "Pixel near vertical line"
      }
    ],
    "hints": [
      "Calculate perpendicular distance from pixel to infinite line",
      "Use cross product formula: |dx*py - dy*px| / sqrt(dx² + dy²)",
      "Linear falloff: coverage = max(0, 1 - distance/0.5)",
      "Coverage is 1.0 when distance is 0, 0.0 when distance >= 0.5",
      "Handle degenerate case when line has zero length"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t4-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-4",
    "title": "Multisample Antialiasing (MSAA)",
    "difficulty": 5,
    "description": "Implement 4x MSAA for a triangle by testing 4 sample points per pixel. Return the coverage fraction (0.0, 0.25, 0.5, 0.75, or 1.0) for a given pixel.",
    "starterCode": "def msaa_coverage(pixel_x, pixel_y, x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Calculate 4x MSAA coverage for a pixel.\n    Uses 4 sample points in a rotated grid pattern:\n    - Sample offsets from pixel center: (-0.25, -0.25), (0.25, -0.25), (-0.25, 0.25), (0.25, 0.25)\n\n    Args:\n        pixel_x, pixel_y: Pixel coordinates (center)\n        x0, y0: First triangle vertex\n        x1, y1: Second triangle vertex\n        x2, y2: Third triangle vertex\n\n    Returns:\n        float: Coverage fraction (0.0, 0.25, 0.5, 0.75, or 1.0)\n    \"\"\"\n    pass",
    "solution": "def msaa_coverage(pixel_x, pixel_y, x0, y0, x1, y1, x2, y2):\n    \"\"\"\n    Calculate 4x MSAA coverage for a pixel.\n    Uses 4 sample points in a rotated grid pattern:\n    - Sample offsets from pixel center: (-0.25, -0.25), (0.25, -0.25), (-0.25, 0.25), (0.25, 0.25)\n\n    Args:\n        pixel_x, pixel_y: Pixel coordinates (center)\n        x0, y0: First triangle vertex\n        x1, y1: Second triangle vertex\n        x2, y2: Third triangle vertex\n\n    Returns:\n        float: Coverage fraction (0.0, 0.25, 0.5, 0.75, or 1.0)\n    \"\"\"\n    def edge_function(ax, ay, bx, by, px, py):\n        return (bx - ax) * (py - ay) - (by - ay) * (px - ax)\n\n    def point_in_triangle(px, py):\n        w0 = edge_function(x1, y1, x2, y2, px, py)\n        w1 = edge_function(x2, y2, x0, y0, px, py)\n        w2 = edge_function(x0, y0, x1, y1, px, py)\n        return w0 >= 0 and w1 >= 0 and w2 >= 0\n\n    # 4 sample points in rotated grid pattern\n    samples = [\n        (pixel_x - 0.25, pixel_y - 0.25),\n        (pixel_x + 0.25, pixel_y - 0.25),\n        (pixel_x - 0.25, pixel_y + 0.25),\n        (pixel_x + 0.25, pixel_y + 0.25)\n    ]\n\n    # Count how many samples are inside triangle\n    covered = sum(1 for sx, sy in samples if point_in_triangle(sx, sy))\n\n    # Return coverage fraction\n    return covered / 4.0",
    "testCases": [
      {
        "input": "2, 1, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Pixel fully inside triangle"
      },
      {
        "input": "0, 0, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "0.25",
        "isHidden": false,
        "description": "Pixel at vertex"
      },
      {
        "input": "5, 5, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Pixel outside triangle"
      },
      {
        "input": "1, 1, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "0.75",
        "isHidden": true,
        "description": "Pixel mostly inside"
      },
      {
        "input": "3, 1, 0, 0, 4, 0, 2, 3",
        "expectedOutput": "0.5",
        "isHidden": true,
        "description": "Pixel half covered"
      }
    ],
    "hints": [
      "Define 4 sample points offset from pixel center",
      "Use offsets: (-0.25, -0.25), (0.25, -0.25), (-0.25, 0.25), (0.25, 0.25)",
      "Test each sample point using point-in-triangle test",
      "Count how many samples are inside",
      "Return count/4.0 as the coverage fraction",
      "Reuse edge_function and point_in_triangle logic"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Calculate Ambient Light Component",
    "difficulty": 1,
    "description": "Calculate the ambient lighting component given ambient intensity and material color. Ambient light = ambient_intensity * material_color.",
    "starterCode": "def calculate_ambient(ambient_intensity, material_color):\n    \"\"\"\n    Calculate ambient light component.\n\n    Args:\n        ambient_intensity: float, ambient light intensity (0-1)\n        material_color: tuple of (r, g, b), each 0-1\n\n    Returns:\n        tuple of (r, g, b) ambient color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_ambient(0.2, (1.0, 0.5, 0.3)))",
    "solution": "def calculate_ambient(ambient_intensity, material_color):\n    \"\"\"\n    Calculate ambient light component.\n\n    Args:\n        ambient_intensity: float, ambient light intensity (0-1)\n        material_color: tuple of (r, g, b), each 0-1\n\n    Returns:\n        tuple of (r, g, b) ambient color\n    \"\"\"\n    r = ambient_intensity * material_color[0]\n    g = ambient_intensity * material_color[1]\n    b = ambient_intensity * material_color[2]\n    return (r, g, b)\n\n# Test\nprint(calculate_ambient(0.2, (1.0, 0.5, 0.3)))",
    "testCases": [
      {
        "input": "0.2, (1.0, 0.5, 0.3)",
        "expectedOutput": "(0.2, 0.1, 0.06)",
        "isHidden": false,
        "description": "Basic ambient calculation"
      },
      {
        "input": "0.5, (0.8, 0.8, 0.8)",
        "expectedOutput": "(0.4, 0.4, 0.4)",
        "isHidden": false,
        "description": "Gray material with medium ambient"
      },
      {
        "input": "1.0, (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": true,
        "description": "Full ambient intensity"
      }
    ],
    "hints": [
      "Multiply the ambient intensity with each color component separately",
      "The result should be a tuple with three values (r, g, b)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Normalize a Vector",
    "difficulty": 1,
    "description": "Normalize a 3D vector to unit length. A normalized vector has magnitude 1 and is calculated as v / ||v||.",
    "starterCode": "import math\n\ndef normalize_vector(v):\n    \"\"\"\n    Normalize a 3D vector to unit length.\n\n    Args:\n        v: tuple of (x, y, z)\n\n    Returns:\n        tuple of normalized (x, y, z)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(normalize_vector((3.0, 4.0, 0.0)))",
    "solution": "import math\n\ndef normalize_vector(v):\n    \"\"\"\n    Normalize a 3D vector to unit length.\n\n    Args:\n        v: tuple of (x, y, z)\n\n    Returns:\n        tuple of normalized (x, y, z)\n    \"\"\"\n    magnitude = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n    if magnitude == 0:\n        return (0.0, 0.0, 0.0)\n    return (v[0] / magnitude, v[1] / magnitude, v[2] / magnitude)\n\n# Test\nprint(normalize_vector((3.0, 4.0, 0.0)))",
    "testCases": [
      {
        "input": "(3.0, 4.0, 0.0)",
        "expectedOutput": "(0.6, 0.8, 0.0)",
        "isHidden": false,
        "description": "3-4-5 triangle vector"
      },
      {
        "input": "(1.0, 0.0, 0.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Already normalized vector"
      },
      {
        "input": "(1.0, 1.0, 1.0)",
        "expectedOutput": "(0.5773502691896258, 0.5773502691896258, 0.5773502691896258)",
        "isHidden": true,
        "description": "Diagonal vector"
      }
    ],
    "hints": [
      "Calculate the magnitude using the Pythagorean theorem in 3D",
      "Divide each component by the magnitude",
      "Handle the zero vector case to avoid division by zero"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Compute Dot Product",
    "difficulty": 1,
    "description": "Calculate the dot product of two 3D vectors. The dot product is: a·b = ax*bx + ay*by + az*bz.",
    "starterCode": "def dot_product(a, b):\n    \"\"\"\n    Calculate dot product of two 3D vectors.\n\n    Args:\n        a: tuple of (x, y, z)\n        b: tuple of (x, y, z)\n\n    Returns:\n        float, the dot product\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(dot_product((1.0, 0.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def dot_product(a, b):\n    \"\"\"\n    Calculate dot product of two 3D vectors.\n\n    Args:\n        a: tuple of (x, y, z)\n        b: tuple of (x, y, z)\n\n    Returns:\n        float, the dot product\n    \"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n# Test\nprint(dot_product((1.0, 0.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Perpendicular vectors"
      },
      {
        "input": "(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)",
        "expectedOutput": "32.0",
        "isHidden": false,
        "description": "General vectors"
      },
      {
        "input": "(1.0, 0.0, 0.0), (1.0, 0.0, 0.0)",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Parallel unit vectors"
      }
    ],
    "hints": [
      "Multiply corresponding components and sum them",
      "The dot product of perpendicular vectors is 0"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Calculate Diffuse Component",
    "difficulty": 2,
    "description": "Calculate the diffuse lighting component using Lambertian reflection. Diffuse = light_intensity * material_color * max(0, N·L), where N is the surface normal and L is the light direction.",
    "starterCode": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef calculate_diffuse(light_intensity, material_color, normal, light_dir):\n    \"\"\"\n    Calculate diffuse light component.\n\n    Args:\n        light_intensity: float (0-1)\n        material_color: tuple (r, g, b) each 0-1\n        normal: tuple (x, y, z), normalized surface normal\n        light_dir: tuple (x, y, z), normalized direction to light\n\n    Returns:\n        tuple of (r, g, b) diffuse color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_diffuse(1.0, (1.0, 0.5, 0.3), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef calculate_diffuse(light_intensity, material_color, normal, light_dir):\n    \"\"\"\n    Calculate diffuse light component.\n\n    Args:\n        light_intensity: float (0-1)\n        material_color: tuple (r, g, b) each 0-1\n        normal: tuple (x, y, z), normalized surface normal\n        light_dir: tuple (x, y, z), normalized direction to light\n\n    Returns:\n        tuple of (r, g, b) diffuse color\n    \"\"\"\n    # Calculate N·L and clamp to [0, 1]\n    n_dot_l = max(0.0, dot_product(normal, light_dir))\n\n    # Apply diffuse calculation to each color component\n    r = light_intensity * material_color[0] * n_dot_l\n    g = light_intensity * material_color[1] * n_dot_l\n    b = light_intensity * material_color[2] * n_dot_l\n\n    return (r, g, b)\n\n# Test\nprint(calculate_diffuse(1.0, (1.0, 0.5, 0.3), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "1.0, (1.0, 0.5, 0.3), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(1.0, 0.5, 0.3)",
        "isHidden": false,
        "description": "Light directly aligned with normal"
      },
      {
        "input": "1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, -1.0, 0.0)",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Light from behind surface"
      },
      {
        "input": "0.8, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.7071, 0.7071)",
        "expectedOutput": "(0.56568, 0.0, 0.0)",
        "isHidden": true,
        "description": "45 degree angle light"
      }
    ],
    "hints": [
      "Use the dot product between normal and light direction",
      "Use max(0, N·L) to handle surfaces facing away from light",
      "Multiply the result by light intensity and material color"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Calculate Reflection Vector",
    "difficulty": 2,
    "description": "Calculate the reflection vector R given an incident light direction L and surface normal N. Use the formula: R = 2(N·L)N - L.",
    "starterCode": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef reflect_vector(light_dir, normal):\n    \"\"\"\n    Calculate reflection vector.\n\n    Args:\n        light_dir: tuple (x, y, z), normalized direction to light\n        normal: tuple (x, y, z), normalized surface normal\n\n    Returns:\n        tuple of (x, y, z) reflection vector\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(reflect_vector((0.0, -1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef reflect_vector(light_dir, normal):\n    \"\"\"\n    Calculate reflection vector.\n\n    Args:\n        light_dir: tuple (x, y, z), normalized direction to light\n        normal: tuple (x, y, z), normalized surface normal\n\n    Returns:\n        tuple of (x, y, z) reflection vector\n    \"\"\"\n    # R = 2(N·L)N - L\n    n_dot_l = dot_product(normal, light_dir)\n\n    rx = 2 * n_dot_l * normal[0] - light_dir[0]\n    ry = 2 * n_dot_l * normal[1] - light_dir[1]\n    rz = 2 * n_dot_l * normal[2] - light_dir[2]\n\n    return (rx, ry, rz)\n\n# Test\nprint(reflect_vector((0.0, -1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Light from below, reflects upward"
      },
      {
        "input": "(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Perpendicular light"
      },
      {
        "input": "(0.7071, -0.7071, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.7071, 0.7071, 0.0)",
        "isHidden": true,
        "description": "45 degree incident angle"
      }
    ],
    "hints": [
      "Use the formula R = 2(N·L)N - L",
      "First calculate the dot product N·L",
      "Then scale the normal by 2(N·L) and subtract the light direction"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Calculate Specular Component",
    "difficulty": 3,
    "description": "Calculate the specular lighting component using the Phong reflection model. Specular = light_intensity * specular_color * max(0, R·V)^shininess, where R is the reflection vector and V is the view direction.",
    "starterCode": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    rx = 2 * n_dot_l * normal[0] - light_dir[0]\n    ry = 2 * n_dot_l * normal[1] - light_dir[1]\n    rz = 2 * n_dot_l * normal[2] - light_dir[2]\n    return (rx, ry, rz)\n\ndef calculate_specular(light_intensity, specular_color, normal, light_dir, view_dir, shininess):\n    \"\"\"\n    Calculate specular light component.\n\n    Args:\n        light_intensity: float (0-1)\n        specular_color: tuple (r, g, b) each 0-1\n        normal: tuple (x, y, z), normalized surface normal\n        light_dir: tuple (x, y, z), normalized direction to light\n        view_dir: tuple (x, y, z), normalized direction to viewer\n        shininess: float, specular exponent (higher = sharper highlight)\n\n    Returns:\n        tuple of (r, g, b) specular color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_specular(1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0))",
    "solution": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    rx = 2 * n_dot_l * normal[0] - light_dir[0]\n    ry = 2 * n_dot_l * normal[1] - light_dir[1]\n    rz = 2 * n_dot_l * normal[2] - light_dir[2]\n    return (rx, ry, rz)\n\ndef calculate_specular(light_intensity, specular_color, normal, light_dir, view_dir, shininess):\n    \"\"\"\n    Calculate specular light component.\n\n    Args:\n        light_intensity: float (0-1)\n        specular_color: tuple (r, g, b) each 0-1\n        normal: tuple (x, y, z), normalized surface normal\n        light_dir: tuple (x, y, z), normalized direction to light\n        view_dir: tuple (x, y, z), normalized direction to viewer\n        shininess: float, specular exponent (higher = sharper highlight)\n\n    Returns:\n        tuple of (r, g, b) specular color\n    \"\"\"\n    # Calculate reflection vector\n    reflection = reflect_vector(light_dir, normal)\n\n    # Calculate R·V and clamp to [0, 1]\n    r_dot_v = max(0.0, dot_product(reflection, view_dir))\n\n    # Apply specular exponent\n    spec_factor = r_dot_v ** shininess\n\n    # Apply to each color component\n    r = light_intensity * specular_color[0] * spec_factor\n    g = light_intensity * specular_color[1] * spec_factor\n    b = light_intensity * specular_color[2] * spec_factor\n\n    return (r, g, b)\n\n# Test\nprint(calculate_specular(1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0))",
    "testCases": [
      {
        "input": "1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "Perfect reflection alignment"
      },
      {
        "input": "1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (1.0, 0.0, 0.0), 32.0",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "View perpendicular to reflection"
      },
      {
        "input": "0.8, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 128.0",
        "expectedOutput": "(0.8, 0.8, 0.8)",
        "isHidden": true,
        "description": "High shininess value"
      }
    ],
    "hints": [
      "First calculate the reflection vector R",
      "Then compute the dot product between R and the view direction V",
      "Raise the clamped dot product to the shininess power",
      "Multiply by light intensity and specular color"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Distance Attenuation",
    "difficulty": 2,
    "description": "Calculate light attenuation based on distance using the formula: attenuation = 1 / (constant + linear*d + quadratic*d²), where d is the distance to the light.",
    "starterCode": "import math\n\ndef calculate_attenuation(distance, constant, linear, quadratic):\n    \"\"\"\n    Calculate light attenuation factor.\n\n    Args:\n        distance: float, distance from light source\n        constant: float, constant attenuation factor\n        linear: float, linear attenuation factor\n        quadratic: float, quadratic attenuation factor\n\n    Returns:\n        float, attenuation factor (0-1)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_attenuation(5.0, 1.0, 0.09, 0.032))",
    "solution": "import math\n\ndef calculate_attenuation(distance, constant, linear, quadratic):\n    \"\"\"\n    Calculate light attenuation factor.\n\n    Args:\n        distance: float, distance from light source\n        constant: float, constant attenuation factor\n        linear: float, linear attenuation factor\n        quadratic: float, quadratic attenuation factor\n\n    Returns:\n        float, attenuation factor (0-1)\n    \"\"\"\n    denominator = constant + linear * distance + quadratic * distance * distance\n    if denominator == 0:\n        return 1.0\n    return 1.0 / denominator\n\n# Test\nprint(calculate_attenuation(5.0, 1.0, 0.09, 0.032))",
    "testCases": [
      {
        "input": "5.0, 1.0, 0.09, 0.032",
        "expectedOutput": "0.5714285714285714",
        "isHidden": false,
        "description": "Medium distance with typical values"
      },
      {
        "input": "0.0, 1.0, 0.0, 0.0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "No distance (at light source)"
      },
      {
        "input": "10.0, 1.0, 0.14, 0.07",
        "expectedOutput": "0.2941176470588235",
        "isHidden": true,
        "description": "Longer distance with stronger attenuation"
      }
    ],
    "hints": [
      "Use the formula: 1 / (constant + linear*d + quadratic*d²)",
      "Handle the case where denominator might be zero",
      "At distance 0, attenuation should be 1.0 (full intensity)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Phong Lighting with Attenuation",
    "difficulty": 3,
    "description": "Implement complete Phong lighting with distance attenuation. Combine ambient, diffuse, and specular components, then apply attenuation to diffuse and specular.",
    "starterCode": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    rx = 2 * n_dot_l * normal[0] - light_dir[0]\n    ry = 2 * n_dot_l * normal[1] - light_dir[1]\n    rz = 2 * n_dot_l * normal[2] - light_dir[2]\n    return (rx, ry, rz)\n\ndef phong_lighting(ambient_i, light_i, material_color, specular_color,\n                   normal, light_dir, view_dir, shininess, distance,\n                   att_const, att_linear, att_quad):\n    \"\"\"\n    Calculate Phong lighting with attenuation.\n\n    Args:\n        ambient_i: float, ambient intensity\n        light_i: float, light intensity\n        material_color: tuple (r, g, b)\n        specular_color: tuple (r, g, b)\n        normal: tuple (x, y, z), normalized\n        light_dir: tuple (x, y, z), normalized\n        view_dir: tuple (x, y, z), normalized\n        shininess: float\n        distance: float, distance to light\n        att_const, att_linear, att_quad: attenuation parameters\n\n    Returns:\n        tuple of (r, g, b) final color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(phong_lighting(0.1, 1.0, (1.0, 0.5, 0.3), (1.0, 1.0, 1.0),\n                     (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0),\n                     32.0, 5.0, 1.0, 0.09, 0.032))",
    "solution": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    rx = 2 * n_dot_l * normal[0] - light_dir[0]\n    ry = 2 * n_dot_l * normal[1] - light_dir[1]\n    rz = 2 * n_dot_l * normal[2] - light_dir[2]\n    return (rx, ry, rz)\n\ndef phong_lighting(ambient_i, light_i, material_color, specular_color,\n                   normal, light_dir, view_dir, shininess, distance,\n                   att_const, att_linear, att_quad):\n    \"\"\"\n    Calculate Phong lighting with attenuation.\n\n    Args:\n        ambient_i: float, ambient intensity\n        light_i: float, light intensity\n        material_color: tuple (r, g, b)\n        specular_color: tuple (r, g, b)\n        normal: tuple (x, y, z), normalized\n        light_dir: tuple (x, y, z), normalized\n        view_dir: tuple (x, y, z), normalized\n        shininess: float\n        distance: float, distance to light\n        att_const, att_linear, att_quad: attenuation parameters\n\n    Returns:\n        tuple of (r, g, b) final color\n    \"\"\"\n    # Calculate attenuation\n    attenuation = 1.0 / (att_const + att_linear * distance + att_quad * distance * distance)\n\n    # Ambient component (not affected by attenuation)\n    ambient_r = ambient_i * material_color[0]\n    ambient_g = ambient_i * material_color[1]\n    ambient_b = ambient_i * material_color[2]\n\n    # Diffuse component\n    n_dot_l = max(0.0, dot_product(normal, light_dir))\n    diffuse_r = light_i * material_color[0] * n_dot_l * attenuation\n    diffuse_g = light_i * material_color[1] * n_dot_l * attenuation\n    diffuse_b = light_i * material_color[2] * n_dot_l * attenuation\n\n    # Specular component\n    reflection = reflect_vector(light_dir, normal)\n    r_dot_v = max(0.0, dot_product(reflection, view_dir))\n    spec_factor = (r_dot_v ** shininess) * attenuation\n    specular_r = light_i * specular_color[0] * spec_factor\n    specular_g = light_i * specular_color[1] * spec_factor\n    specular_b = light_i * specular_color[2] * spec_factor\n\n    # Combine all components\n    final_r = ambient_r + diffuse_r + specular_r\n    final_g = ambient_g + diffuse_g + specular_g\n    final_b = ambient_b + diffuse_b + specular_b\n\n    return (final_r, final_g, final_b)\n\n# Test\nprint(phong_lighting(0.1, 1.0, (1.0, 0.5, 0.3), (1.0, 1.0, 1.0),\n                     (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0),\n                     32.0, 5.0, 1.0, 0.09, 0.032))",
    "testCases": [
      {
        "input": "0.1, 1.0, (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0, 5.0, 1.0, 0.09, 0.032",
        "expectedOutput": "(0.7714285714285715, 0.38571428571428573, 0.8014285714285715)",
        "isHidden": false,
        "description": "Full Phong with medium distance"
      },
      {
        "input": "0.2, 1.0, (0.8, 0.8, 0.8), (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, -1.0, 0.0), (0.0, 1.0, 0.0), 16.0, 3.0, 1.0, 0.1, 0.05",
        "expectedOutput": "(0.16, 0.16, 0.16)",
        "isHidden": false,
        "description": "Light from behind (only ambient)"
      },
      {
        "input": "0.05, 1.0, (1.0, 0.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 64.0, 1.0, 1.0, 0.0, 0.0",
        "expectedOutput": "(2.05, 0.0, 0.0)",
        "isHidden": true,
        "description": "Close distance, no attenuation"
      }
    ],
    "hints": [
      "Calculate attenuation first",
      "Ambient is not affected by attenuation",
      "Apply attenuation to both diffuse and specular components",
      "Combine all three components at the end"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Calculate Light Direction Vector",
    "difficulty": 2,
    "description": "Calculate and normalize the direction vector from a surface point to a light source position.",
    "starterCode": "import math\n\ndef light_direction_vector(surface_point, light_position):\n    \"\"\"\n    Calculate normalized direction from surface to light.\n\n    Args:\n        surface_point: tuple (x, y, z) of point on surface\n        light_position: tuple (x, y, z) of light position\n\n    Returns:\n        tuple of normalized (x, y, z) direction vector\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(light_direction_vector((0.0, 0.0, 0.0), (3.0, 4.0, 0.0)))",
    "solution": "import math\n\ndef light_direction_vector(surface_point, light_position):\n    \"\"\"\n    Calculate normalized direction from surface to light.\n\n    Args:\n        surface_point: tuple (x, y, z) of point on surface\n        light_position: tuple (x, y, z) of light position\n\n    Returns:\n        tuple of normalized (x, y, z) direction vector\n    \"\"\"\n    # Calculate direction vector\n    dx = light_position[0] - surface_point[0]\n    dy = light_position[1] - surface_point[1]\n    dz = light_position[2] - surface_point[2]\n\n    # Normalize\n    magnitude = math.sqrt(dx*dx + dy*dy + dz*dz)\n    if magnitude == 0:\n        return (0.0, 0.0, 0.0)\n\n    return (dx / magnitude, dy / magnitude, dz / magnitude)\n\n# Test\nprint(light_direction_vector((0.0, 0.0, 0.0), (3.0, 4.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (3.0, 4.0, 0.0)",
        "expectedOutput": "(0.6, 0.8, 0.0)",
        "isHidden": false,
        "description": "Simple 3-4-5 triangle"
      },
      {
        "input": "(1.0, 2.0, 3.0), (1.0, 2.0, 3.0)",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Light at surface point"
      },
      {
        "input": "(1.0, 1.0, 1.0), (4.0, 5.0, 1.0)",
        "expectedOutput": "(0.6, 0.8, 0.0)",
        "isHidden": true,
        "description": "Offset positions"
      }
    ],
    "hints": [
      "Subtract surface point from light position to get direction",
      "Normalize the resulting vector",
      "Handle the case where the points are identical"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Blinn-Phong Half Vector",
    "difficulty": 3,
    "description": "Calculate the half vector H for Blinn-Phong shading. The half vector is the normalized average of the light direction L and view direction V: H = normalize(L + V).",
    "starterCode": "import math\n\ndef calculate_half_vector(light_dir, view_dir):\n    \"\"\"\n    Calculate the half vector for Blinn-Phong shading.\n\n    Args:\n        light_dir: tuple (x, y, z), normalized direction to light\n        view_dir: tuple (x, y, z), normalized direction to viewer\n\n    Returns:\n        tuple of normalized (x, y, z) half vector\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_half_vector((0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "import math\n\ndef calculate_half_vector(light_dir, view_dir):\n    \"\"\"\n    Calculate the half vector for Blinn-Phong shading.\n\n    Args:\n        light_dir: tuple (x, y, z), normalized direction to light\n        view_dir: tuple (x, y, z), normalized direction to viewer\n\n    Returns:\n        tuple of normalized (x, y, z) half vector\n    \"\"\"\n    # Add the vectors\n    hx = light_dir[0] + view_dir[0]\n    hy = light_dir[1] + view_dir[1]\n    hz = light_dir[2] + view_dir[2]\n\n    # Normalize\n    magnitude = math.sqrt(hx*hx + hy*hy + hz*hz)\n    if magnitude == 0:\n        return (0.0, 0.0, 0.0)\n\n    return (hx / magnitude, hy / magnitude, hz / magnitude)\n\n# Test\nprint(calculate_half_vector((0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.0, 1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Identical directions"
      },
      {
        "input": "(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.7071067811865475, 0.7071067811865475, 0.0)",
        "isHidden": false,
        "description": "Perpendicular directions"
      },
      {
        "input": "(0.7071, 0.7071, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.408248290463863, 0.9128709291752769, 0.0)",
        "isHidden": true,
        "description": "45 degree light direction"
      }
    ],
    "hints": [
      "Add the light and view direction vectors component-wise",
      "Normalize the resulting vector",
      "The half vector lies between L and V"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Blinn-Phong Specular Component",
    "difficulty": 3,
    "description": "Calculate specular component using Blinn-Phong shading. Instead of R·V, use N·H where H is the half vector. This is more efficient than traditional Phong.",
    "starterCode": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef calculate_half_vector(light_dir, view_dir):\n    hx = light_dir[0] + view_dir[0]\n    hy = light_dir[1] + view_dir[1]\n    hz = light_dir[2] + view_dir[2]\n    magnitude = math.sqrt(hx*hx + hy*hy + hz*hz)\n    if magnitude == 0:\n        return (0.0, 0.0, 0.0)\n    return (hx / magnitude, hy / magnitude, hz / magnitude)\n\ndef blinn_phong_specular(light_intensity, specular_color, normal,\n                         light_dir, view_dir, shininess):\n    \"\"\"\n    Calculate Blinn-Phong specular component.\n\n    Args:\n        light_intensity: float (0-1)\n        specular_color: tuple (r, g, b) each 0-1\n        normal: tuple (x, y, z), normalized surface normal\n        light_dir: tuple (x, y, z), normalized direction to light\n        view_dir: tuple (x, y, z), normalized direction to viewer\n        shininess: float, specular exponent\n\n    Returns:\n        tuple of (r, g, b) specular color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(blinn_phong_specular(1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0),\n                           (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0))",
    "solution": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef calculate_half_vector(light_dir, view_dir):\n    hx = light_dir[0] + view_dir[0]\n    hy = light_dir[1] + view_dir[1]\n    hz = light_dir[2] + view_dir[2]\n    magnitude = math.sqrt(hx*hx + hy*hy + hz*hz)\n    if magnitude == 0:\n        return (0.0, 0.0, 0.0)\n    return (hx / magnitude, hy / magnitude, hz / magnitude)\n\ndef blinn_phong_specular(light_intensity, specular_color, normal,\n                         light_dir, view_dir, shininess):\n    \"\"\"\n    Calculate Blinn-Phong specular component.\n\n    Args:\n        light_intensity: float (0-1)\n        specular_color: tuple (r, g, b) each 0-1\n        normal: tuple (x, y, z), normalized surface normal\n        light_dir: tuple (x, y, z), normalized direction to light\n        view_dir: tuple (x, y, z), normalized direction to viewer\n        shininess: float, specular exponent\n\n    Returns:\n        tuple of (r, g, b) specular color\n    \"\"\"\n    # Calculate half vector\n    half_vector = calculate_half_vector(light_dir, view_dir)\n\n    # Calculate N·H and clamp to [0, 1]\n    n_dot_h = max(0.0, dot_product(normal, half_vector))\n\n    # Apply specular exponent\n    spec_factor = n_dot_h ** shininess\n\n    # Apply to each color component\n    r = light_intensity * specular_color[0] * spec_factor\n    g = light_intensity * specular_color[1] * spec_factor\n    b = light_intensity * specular_color[2] * spec_factor\n\n    return (r, g, b)\n\n# Test\nprint(blinn_phong_specular(1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0),\n                           (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0))",
    "testCases": [
      {
        "input": "1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 32.0",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "Perfect alignment"
      },
      {
        "input": "1.0, (1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), 32.0",
        "expectedOutput": "(0.125, 0.125, 0.125)",
        "isHidden": false,
        "description": "Perpendicular light"
      },
      {
        "input": "0.8, (1.0, 0.5, 0.3), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 64.0",
        "expectedOutput": "(0.8, 0.4, 0.24)",
        "isHidden": true,
        "description": "High shininess with colored specular"
      }
    ],
    "hints": [
      "Calculate the half vector H from L and V",
      "Compute the dot product between N and H",
      "Use the same power operation as Phong, but with N·H instead of R·V",
      "Blinn-Phong is computationally cheaper than traditional Phong"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Multiple Point Lights",
    "difficulty": 4,
    "description": "Calculate lighting from multiple point light sources. Each light contributes independently to the final color. Sum all contributions along with ambient.",
    "starterCode": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef normalize(v):\n    mag = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n    if mag == 0: return (0.0, 0.0, 0.0)\n    return (v[0]/mag, v[1]/mag, v[2]/mag)\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    return (2*n_dot_l*normal[0]-light_dir[0],\n            2*n_dot_l*normal[1]-light_dir[1],\n            2*n_dot_l*normal[2]-light_dir[2])\n\ndef multiple_lights(surface_pos, normal, view_dir, material_color,\n                    specular_color, shininess, ambient_i, lights):\n    \"\"\"\n    Calculate lighting from multiple point lights.\n\n    Args:\n        surface_pos: tuple (x, y, z) surface position\n        normal: tuple (x, y, z) normalized surface normal\n        view_dir: tuple (x, y, z) normalized view direction\n        material_color: tuple (r, g, b)\n        specular_color: tuple (r, g, b)\n        shininess: float\n        ambient_i: float, ambient intensity\n        lights: list of dicts, each with:\n            - 'position': (x, y, z)\n            - 'intensity': float\n            - 'attenuation': (constant, linear, quadratic)\n\n    Returns:\n        tuple of (r, g, b) final color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nlights = [\n    {'position': (0.0, 5.0, 0.0), 'intensity': 1.0, 'attenuation': (1.0, 0.09, 0.032)},\n    {'position': (5.0, 0.0, 0.0), 'intensity': 0.8, 'attenuation': (1.0, 0.09, 0.032)}\n]\nprint(multiple_lights((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0),\n                      (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), 32.0, 0.1, lights))",
    "solution": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef normalize(v):\n    mag = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n    if mag == 0: return (0.0, 0.0, 0.0)\n    return (v[0]/mag, v[1]/mag, v[2]/mag)\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    return (2*n_dot_l*normal[0]-light_dir[0],\n            2*n_dot_l*normal[1]-light_dir[1],\n            2*n_dot_l*normal[2]-light_dir[2])\n\ndef multiple_lights(surface_pos, normal, view_dir, material_color,\n                    specular_color, shininess, ambient_i, lights):\n    \"\"\"\n    Calculate lighting from multiple point lights.\n\n    Args:\n        surface_pos: tuple (x, y, z) surface position\n        normal: tuple (x, y, z) normalized surface normal\n        view_dir: tuple (x, y, z) normalized view direction\n        material_color: tuple (r, g, b)\n        specular_color: tuple (r, g, b)\n        shininess: float\n        ambient_i: float, ambient intensity\n        lights: list of dicts, each with:\n            - 'position': (x, y, z)\n            - 'intensity': float\n            - 'attenuation': (constant, linear, quadratic)\n\n    Returns:\n        tuple of (r, g, b) final color\n    \"\"\"\n    # Ambient component\n    final_r = ambient_i * material_color[0]\n    final_g = ambient_i * material_color[1]\n    final_b = ambient_i * material_color[2]\n\n    # Process each light\n    for light in lights:\n        # Calculate light direction and distance\n        dx = light['position'][0] - surface_pos[0]\n        dy = light['position'][1] - surface_pos[1]\n        dz = light['position'][2] - surface_pos[2]\n        distance = math.sqrt(dx*dx + dy*dy + dz*dz)\n\n        if distance == 0:\n            continue\n\n        light_dir = (dx/distance, dy/distance, dz/distance)\n\n        # Calculate attenuation\n        att = light['attenuation']\n        attenuation = 1.0 / (att[0] + att[1]*distance + att[2]*distance*distance)\n\n        # Diffuse\n        n_dot_l = max(0.0, dot_product(normal, light_dir))\n        final_r += light['intensity'] * material_color[0] * n_dot_l * attenuation\n        final_g += light['intensity'] * material_color[1] * n_dot_l * attenuation\n        final_b += light['intensity'] * material_color[2] * n_dot_l * attenuation\n\n        # Specular\n        reflection = reflect_vector(light_dir, normal)\n        r_dot_v = max(0.0, dot_product(reflection, view_dir))\n        spec_factor = (r_dot_v ** shininess) * attenuation\n        final_r += light['intensity'] * specular_color[0] * spec_factor\n        final_g += light['intensity'] * specular_color[1] * spec_factor\n        final_b += light['intensity'] * specular_color[2] * spec_factor\n\n    return (final_r, final_g, final_b)\n\n# Test\nlights = [\n    {'position': (0.0, 5.0, 0.0), 'intensity': 1.0, 'attenuation': (1.0, 0.09, 0.032)},\n    {'position': (5.0, 0.0, 0.0), 'intensity': 0.8, 'attenuation': (1.0, 0.09, 0.032)}\n]\nprint(multiple_lights((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0),\n                      (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), 32.0, 0.1, lights))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), 32.0, 0.1, [{'position': (0.0, 5.0, 0.0), 'intensity': 1.0, 'attenuation': (1.0, 0.09, 0.032)}, {'position': (5.0, 0.0, 0.0), 'intensity': 0.8, 'attenuation': (1.0, 0.09, 0.032)}]",
        "expectedOutput": "(0.7714285714285715, 0.38571428571428573, 0.8014285714285715)",
        "isHidden": false,
        "description": "Two lights at different positions"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (1.0, 1.0, 1.0), (1.0, 1.0, 1.0), 16.0, 0.2, [{'position': (0.0, 3.0, 0.0), 'intensity': 1.0, 'attenuation': (1.0, 0.1, 0.05)}]",
        "expectedOutput": "(1.1442307692307693, 1.1442307692307693, 1.1442307692307693)",
        "isHidden": false,
        "description": "Single light with white material"
      },
      {
        "input": "(1.0, 1.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.8, 0.2, 0.2), (1.0, 1.0, 1.0), 64.0, 0.05, [{'position': (1.0, 6.0, 1.0), 'intensity': 1.0, 'attenuation': (1.0, 0.09, 0.032)}, {'position': (6.0, 1.0, 1.0), 'intensity': 0.6, 'attenuation': (1.0, 0.09, 0.032)}, {'position': (1.0, 1.0, 6.0), 'intensity': 0.5, 'attenuation': (1.0, 0.09, 0.032)}]",
        "expectedOutput": "(0.5885714285714286, 0.15714285714285714, 0.7285714285714285)",
        "isHidden": true,
        "description": "Three lights with red material"
      }
    ],
    "hints": [
      "Start with the ambient component",
      "Loop through each light and calculate its contribution",
      "For each light: calculate direction, distance, attenuation",
      "Add diffuse and specular from each light to the running total",
      "Remember to normalize the light direction vector"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Spotlight Cone Calculation",
    "difficulty": 4,
    "description": "Calculate the intensity falloff for a spotlight. A spotlight has a direction and cone angle. Light intensity should falloff smoothly based on the angle from the spotlight direction.",
    "starterCode": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef spotlight_intensity(light_pos, light_dir, surface_pos,\n                        inner_cone_cos, outer_cone_cos, intensity):\n    \"\"\"\n    Calculate spotlight intensity at a surface point.\n\n    Args:\n        light_pos: tuple (x, y, z) light position\n        light_dir: tuple (x, y, z) normalized spotlight direction\n        surface_pos: tuple (x, y, z) surface position\n        inner_cone_cos: float, cosine of inner cone angle\n        outer_cone_cos: float, cosine of outer cone angle\n        intensity: float, maximum light intensity\n\n    Returns:\n        float, intensity at surface (0 to intensity)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(spotlight_intensity((0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0),\n                          math.cos(math.radians(12.5)), math.cos(math.radians(17.5)), 1.0))",
    "solution": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef spotlight_intensity(light_pos, light_dir, surface_pos,\n                        inner_cone_cos, outer_cone_cos, intensity):\n    \"\"\"\n    Calculate spotlight intensity at a surface point.\n\n    Args:\n        light_pos: tuple (x, y, z) light position\n        light_dir: tuple (x, y, z) normalized spotlight direction\n        surface_pos: tuple (x, y, z) surface position\n        inner_cone_cos: float, cosine of inner cone angle\n        outer_cone_cos: float, cosine of outer cone angle\n        intensity: float, maximum light intensity\n\n    Returns:\n        float, intensity at surface (0 to intensity)\n    \"\"\"\n    # Calculate direction from light to surface\n    dx = surface_pos[0] - light_pos[0]\n    dy = surface_pos[1] - light_pos[1]\n    dz = surface_pos[2] - light_pos[2]\n\n    # Normalize\n    distance = math.sqrt(dx*dx + dy*dy + dz*dz)\n    if distance == 0:\n        return intensity\n\n    to_surface = (dx/distance, dy/distance, dz/distance)\n\n    # Calculate angle between spotlight direction and direction to surface\n    theta_cos = dot_product(light_dir, to_surface)\n\n    # Outside outer cone\n    if theta_cos < outer_cone_cos:\n        return 0.0\n\n    # Inside inner cone\n    if theta_cos > inner_cone_cos:\n        return intensity\n\n    # In between - smooth falloff\n    epsilon = inner_cone_cos - outer_cone_cos\n    falloff = (theta_cos - outer_cone_cos) / epsilon\n\n    return intensity * falloff\n\n# Test\nprint(spotlight_intensity((0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0),\n                          math.cos(math.radians(12.5)), math.cos(math.radians(17.5)), 1.0))",
    "testCases": [
      {
        "input": "(0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0), math.cos(math.radians(12.5)), math.cos(math.radians(17.5)), 1.0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Surface directly below spotlight"
      },
      {
        "input": "(0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (10.0, 0.0, 0.0), math.cos(math.radians(12.5)), math.cos(math.radians(17.5)), 1.0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Surface outside spotlight cone"
      },
      {
        "input": "(0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (1.5, 0.0, 0.0), math.cos(math.radians(12.5)), math.cos(math.radians(17.5)), 1.0",
        "expectedOutput": "0.5",
        "isHidden": true,
        "description": "Surface in falloff region"
      }
    ],
    "hints": [
      "Calculate the direction vector from light to surface",
      "Use dot product to find the angle between spotlight direction and surface direction",
      "Compare with inner and outer cone angles (as cosines)",
      "Apply smooth interpolation in the falloff region between inner and outer cones",
      "Remember: larger angles have smaller cosine values"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Fresnel Effect",
    "difficulty": 4,
    "description": "Implement the Schlick approximation for the Fresnel effect. Fresnel describes how reflectivity changes based on viewing angle: F = F0 + (1 - F0)(1 - cos(θ))^5, where θ is the angle between view and normal.",
    "starterCode": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef fresnel_schlick(f0, normal, view_dir):\n    \"\"\"\n    Calculate Fresnel reflectance using Schlick approximation.\n\n    Args:\n        f0: tuple (r, g, b), base reflectivity at normal incidence (0-1 each)\n        normal: tuple (x, y, z), normalized surface normal\n        view_dir: tuple (x, y, z), normalized view direction\n\n    Returns:\n        tuple of (r, g, b) Fresnel reflectance\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(fresnel_schlick((0.04, 0.04, 0.04), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef fresnel_schlick(f0, normal, view_dir):\n    \"\"\"\n    Calculate Fresnel reflectance using Schlick approximation.\n\n    Args:\n        f0: tuple (r, g, b), base reflectivity at normal incidence (0-1 each)\n        normal: tuple (x, y, z), normalized surface normal\n        view_dir: tuple (x, y, z), normalized view direction\n\n    Returns:\n        tuple of (r, g, b) Fresnel reflectance\n    \"\"\"\n    # Calculate cosine of angle between view and normal\n    cos_theta = max(0.0, dot_product(normal, view_dir))\n\n    # Calculate (1 - cos(θ))^5\n    one_minus_cos = 1.0 - cos_theta\n    factor = one_minus_cos ** 5\n\n    # Apply Schlick approximation: F = F0 + (1 - F0)(1 - cos(θ))^5\n    fr = f0[0] + (1.0 - f0[0]) * factor\n    fg = f0[1] + (1.0 - f0[1]) * factor\n    fb = f0[2] + (1.0 - f0[2]) * factor\n\n    return (fr, fg, fb)\n\n# Test\nprint(fresnel_schlick((0.04, 0.04, 0.04), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.04, 0.04, 0.04), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.04, 0.04, 0.04)",
        "isHidden": false,
        "description": "View perpendicular to surface (normal incidence)"
      },
      {
        "input": "(0.04, 0.04, 0.04), (0.0, 1.0, 0.0), (1.0, 0.0, 0.0)",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "View parallel to surface (grazing angle)"
      },
      {
        "input": "(0.04, 0.04, 0.04), (0.0, 1.0, 0.0), (0.0, 0.7071, 0.7071)",
        "expectedOutput": "(0.11494140625, 0.11494140625, 0.11494140625)",
        "isHidden": true,
        "description": "45 degree viewing angle"
      }
    ],
    "hints": [
      "Calculate N·V to get cos(θ)",
      "Compute (1 - cos(θ))^5 using the power operator",
      "Apply the Schlick formula: F = F0 + (1 - F0) * (1 - cos(θ))^5",
      "At grazing angles (parallel view), reflectivity approaches 1",
      "At normal incidence (perpendicular view), reflectivity equals F0"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Rim Lighting",
    "difficulty": 4,
    "description": "Implement rim lighting (also called edge lighting or backlighting). Rim light highlights edges where the surface normal is perpendicular to the view direction. Calculate using: rim = (1 - N·V)^power.",
    "starterCode": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef rim_lighting(rim_color, rim_power, normal, view_dir):\n    \"\"\"\n    Calculate rim lighting component.\n\n    Args:\n        rim_color: tuple (r, g, b), color of rim light\n        rim_power: float, controls rim light sharpness (higher = sharper)\n        normal: tuple (x, y, z), normalized surface normal\n        view_dir: tuple (x, y, z), normalized view direction\n\n    Returns:\n        tuple of (r, g, b) rim light contribution\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(rim_lighting((1.0, 1.0, 1.0), 3.0, (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef rim_lighting(rim_color, rim_power, normal, view_dir):\n    \"\"\"\n    Calculate rim lighting component.\n\n    Args:\n        rim_color: tuple (r, g, b), color of rim light\n        rim_power: float, controls rim light sharpness (higher = sharper)\n        normal: tuple (x, y, z), normalized surface normal\n        view_dir: tuple (x, y, z), normalized view direction\n\n    Returns:\n        tuple of (r, g, b) rim light contribution\n    \"\"\"\n    # Calculate N·V\n    n_dot_v = max(0.0, min(1.0, dot_product(normal, view_dir)))\n\n    # Calculate rim factor: (1 - N·V)^power\n    rim_factor = (1.0 - n_dot_v) ** rim_power\n\n    # Apply to rim color\n    r = rim_color[0] * rim_factor\n    g = rim_color[1] * rim_factor\n    b = rim_color[2] * rim_factor\n\n    return (r, g, b)\n\n# Test\nprint(rim_lighting((1.0, 1.0, 1.0), 3.0, (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(1.0, 1.0, 1.0), 3.0, (0.0, 1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "View perpendicular (no rim)"
      },
      {
        "input": "(1.0, 1.0, 1.0), 3.0, (0.0, 1.0, 0.0), (1.0, 0.0, 0.0)",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "View parallel (maximum rim)"
      },
      {
        "input": "(0.5, 0.7, 1.0), 2.0, (0.0, 1.0, 0.0), (0.7071, 0.7071, 0.0)",
        "expectedOutput": "(0.07322330470336314, 0.10251262658470841, 0.14644660940672627)",
        "isHidden": true,
        "description": "45 degree angle with colored rim"
      }
    ],
    "hints": [
      "Calculate the dot product between normal and view direction",
      "Use 1 - N·V to get the rim factor (edges have low N·V)",
      "Apply the power to control sharpness of the rim",
      "Multiply by rim color to get final contribution",
      "Rim lighting is strongest when view is perpendicular to normal"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t5-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-5",
    "title": "Cook-Torrance Microfacet BRDF",
    "difficulty": 5,
    "description": "Implement a simplified Cook-Torrance BRDF for physically-based rendering. Calculate the specular term using: D*F*G / (4*(N·L)*(N·V)), where D is distribution (GGX), F is Fresnel, G is geometry (simplified to 1).",
    "starterCode": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef calculate_half_vector(light_dir, view_dir):\n    hx = light_dir[0] + view_dir[0]\n    hy = light_dir[1] + view_dir[1]\n    hz = light_dir[2] + view_dir[2]\n    mag = math.sqrt(hx*hx + hy*hy + hz*hz)\n    if mag == 0: return (0.0, 0.0, 0.0)\n    return (hx/mag, hy/mag, hz/mag)\n\ndef cook_torrance_specular(f0, roughness, normal, light_dir, view_dir, light_intensity):\n    \"\"\"\n    Calculate Cook-Torrance specular BRDF (simplified).\n\n    Args:\n        f0: tuple (r, g, b), base reflectivity\n        roughness: float (0-1), surface roughness\n        normal: tuple (x, y, z), normalized\n        light_dir: tuple (x, y, z), normalized\n        view_dir: tuple (x, y, z), normalized\n        light_intensity: float\n\n    Returns:\n        tuple of (r, g, b) specular contribution\n\n    Notes:\n        - D (GGX): α²/[π((N·H)²(α²-1)+1)²], where α = roughness²\n        - F (Schlick): F0 + (1-F0)(1-(H·V))^5\n        - G (simplified): 1.0\n        - Final: D*F*G / [4*(N·L)*(N·V)]\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(cook_torrance_specular((0.04, 0.04, 0.04), 0.5, (0.0, 1.0, 0.0),\n                             (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 1.0))",
    "solution": "import math\n\ndef dot_product(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef calculate_half_vector(light_dir, view_dir):\n    hx = light_dir[0] + view_dir[0]\n    hy = light_dir[1] + view_dir[1]\n    hz = light_dir[2] + view_dir[2]\n    mag = math.sqrt(hx*hx + hy*hy + hz*hz)\n    if mag == 0: return (0.0, 0.0, 0.0)\n    return (hx/mag, hy/mag, hz/mag)\n\ndef cook_torrance_specular(f0, roughness, normal, light_dir, view_dir, light_intensity):\n    \"\"\"\n    Calculate Cook-Torrance specular BRDF (simplified).\n\n    Args:\n        f0: tuple (r, g, b), base reflectivity\n        roughness: float (0-1), surface roughness\n        normal: tuple (x, y, z), normalized\n        light_dir: tuple (x, y, z), normalized\n        view_dir: tuple (x, y, z), normalized\n        light_intensity: float\n\n    Returns:\n        tuple of (r, g, b) specular contribution\n\n    Notes:\n        - D (GGX): α²/[π((N·H)²(α²-1)+1)²], where α = roughness²\n        - F (Schlick): F0 + (1-F0)(1-(H·V))^5\n        - G (simplified): 1.0\n        - Final: D*F*G / [4*(N·L)*(N·V)]\n    \"\"\"\n    # Calculate half vector\n    half_vec = calculate_half_vector(light_dir, view_dir)\n\n    # Calculate dot products\n    n_dot_h = max(0.0001, dot_product(normal, half_vec))\n    n_dot_l = max(0.0001, dot_product(normal, light_dir))\n    n_dot_v = max(0.0001, dot_product(normal, view_dir))\n    h_dot_v = max(0.0, dot_product(half_vec, view_dir))\n\n    # Calculate alpha\n    alpha = roughness * roughness\n    alpha_sq = alpha * alpha\n\n    # D: GGX distribution\n    n_dot_h_sq = n_dot_h * n_dot_h\n    denom = n_dot_h_sq * (alpha_sq - 1.0) + 1.0\n    D = alpha_sq / (math.pi * denom * denom)\n\n    # F: Schlick Fresnel\n    one_minus_h_dot_v = 1.0 - h_dot_v\n    fresnel_factor = one_minus_h_dot_v ** 5\n    fr = f0[0] + (1.0 - f0[0]) * fresnel_factor\n    fg = f0[1] + (1.0 - f0[1]) * fresnel_factor\n    fb = f0[2] + (1.0 - f0[2]) * fresnel_factor\n\n    # G: Geometry (simplified to 1.0)\n    G = 1.0\n\n    # Cook-Torrance: D*F*G / (4*N·L*N·V)\n    denominator = 4.0 * n_dot_l * n_dot_v\n\n    spec_r = (D * fr * G / denominator) * light_intensity * n_dot_l\n    spec_g = (D * fg * G / denominator) * light_intensity * n_dot_l\n    spec_b = (D * fb * G / denominator) * light_intensity * n_dot_l\n\n    return (spec_r, spec_g, spec_b)\n\n# Test\nprint(cook_torrance_specular((0.04, 0.04, 0.04), 0.5, (0.0, 1.0, 0.0),\n                             (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 1.0))",
    "testCases": [
      {
        "input": "(0.04, 0.04, 0.04), 0.5, (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 1.0",
        "expectedOutput": "(0.25464790894703254, 0.25464790894703254, 0.25464790894703254)",
        "isHidden": false,
        "description": "Perfect alignment with medium roughness"
      },
      {
        "input": "(0.04, 0.04, 0.04), 0.1, (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 1.0",
        "expectedOutput": "(2.546479089470325, 2.546479089470325, 2.546479089470325)",
        "isHidden": false,
        "description": "Low roughness (shiny surface)"
      },
      {
        "input": "(0.95, 0.64, 0.54), 0.3, (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 0.0), 1.0",
        "expectedOutput": "(2.685528972188889, 1.8099795928922678, 1.5278679545245902)",
        "isHidden": true,
        "description": "Metallic surface (gold-like F0)"
      }
    ],
    "hints": [
      "Calculate the half vector H between L and V",
      "Compute all necessary dot products: N·H, N·L, N·V, H·V",
      "Calculate D using GGX distribution with alpha = roughness²",
      "Calculate F using Schlick Fresnel approximation",
      "Combine using the Cook-Torrance formula: D*F*G / (4*(N·L)*(N·V))",
      "Add small epsilon to dot products to avoid division by zero",
      "Multiply by N·L at the end to get the final contribution"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Basic UV Coordinate Mapping",
    "difficulty": 1,
    "description": "Map a point on a 2D plane to UV coordinates. Given a point in world space and the plane bounds, calculate UV coordinates (0-1 range).",
    "starterCode": "def world_to_uv(point, min_x, max_x, min_y, max_y):\n    \"\"\"\n    Convert world space coordinates to UV coordinates.\n\n    Args:\n        point: tuple (x, y) world position\n        min_x, max_x: float, x bounds of the plane\n        min_y, max_y: float, y bounds of the plane\n\n    Returns:\n        tuple (u, v) in range [0, 1]\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(world_to_uv((5.0, 7.5), 0.0, 10.0, 5.0, 10.0))",
    "solution": "def world_to_uv(point, min_x, max_x, min_y, max_y):\n    \"\"\"\n    Convert world space coordinates to UV coordinates.\n\n    Args:\n        point: tuple (x, y) world position\n        min_x, max_x: float, x bounds of the plane\n        min_y, max_y: float, y bounds of the plane\n\n    Returns:\n        tuple (u, v) in range [0, 1]\n    \"\"\"\n    # Normalize x to [0, 1]\n    u = (point[0] - min_x) / (max_x - min_x)\n\n    # Normalize y to [0, 1]\n    v = (point[1] - min_y) / (max_y - min_y)\n\n    return (u, v)\n\n# Test\nprint(world_to_uv((5.0, 7.5), 0.0, 10.0, 5.0, 10.0))",
    "testCases": [
      {
        "input": "(5.0, 7.5), 0.0, 10.0, 5.0, 10.0",
        "expectedOutput": "(0.5, 0.5)",
        "isHidden": false,
        "description": "Center of plane"
      },
      {
        "input": "(0.0, 5.0), 0.0, 10.0, 5.0, 10.0",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": false,
        "description": "Minimum corner"
      },
      {
        "input": "(10.0, 10.0), 0.0, 10.0, 5.0, 10.0",
        "expectedOutput": "(1.0, 1.0)",
        "isHidden": true,
        "description": "Maximum corner"
      }
    ],
    "hints": [
      "U coordinate is the normalized x position",
      "V coordinate is the normalized y position",
      "Use the formula: (value - min) / (max - min)"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Sample Texture Color",
    "difficulty": 1,
    "description": "Sample a color from a 2D texture array given UV coordinates. Use nearest-neighbor sampling (no interpolation).",
    "starterCode": "def sample_texture(texture, u, v):\n    \"\"\"\n    Sample color from texture using UV coordinates.\n\n    Args:\n        texture: 2D list of (r, g, b) tuples, indexed as texture[y][x]\n        u: float (0-1), horizontal texture coordinate\n        v: float (0-1), vertical texture coordinate\n\n    Returns:\n        tuple (r, g, b) sampled color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\ntexture = [\n    [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)],\n    [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]\n]\nprint(sample_texture(texture, 0.25, 0.25))",
    "solution": "def sample_texture(texture, u, v):\n    \"\"\"\n    Sample color from texture using UV coordinates.\n\n    Args:\n        texture: 2D list of (r, g, b) tuples, indexed as texture[y][x]\n        u: float (0-1), horizontal texture coordinate\n        v: float (0-1), vertical texture coordinate\n\n    Returns:\n        tuple (r, g, b) sampled color\n    \"\"\"\n    height = len(texture)\n    width = len(texture[0])\n\n    # Convert UV to pixel coordinates\n    x = int(u * (width - 1))\n    y = int(v * (height - 1))\n\n    # Clamp to valid range\n    x = max(0, min(width - 1, x))\n    y = max(0, min(height - 1, y))\n\n    return texture[y][x]\n\n# Test\ntexture = [\n    [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)],\n    [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]\n]\nprint(sample_texture(texture, 0.25, 0.25))",
    "testCases": [
      {
        "input": "[[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]], 0.25, 0.25",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Sample top-left quadrant"
      },
      {
        "input": "[[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]], 0.75, 0.25",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Sample top-right quadrant"
      },
      {
        "input": "[[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]], 1.0, 1.0",
        "expectedOutput": "(1.0, 1.0, 0.0)",
        "isHidden": true,
        "description": "Sample at maximum UV"
      }
    ],
    "hints": [
      "Convert UV coordinates to pixel coordinates by multiplying by texture dimensions",
      "Use integer conversion for nearest-neighbor sampling",
      "Remember to clamp coordinates to valid range",
      "Texture is indexed as texture[y][x]"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "UV Tiling and Repeat",
    "difficulty": 2,
    "description": "Implement UV coordinate tiling/wrapping. When UV coordinates are outside [0,1], they should wrap around to create a repeating pattern.",
    "starterCode": "def wrap_uv(u, v):\n    \"\"\"\n    Wrap UV coordinates to [0, 1] range for tiling.\n\n    Args:\n        u: float, horizontal coordinate (can be any value)\n        v: float, vertical coordinate (can be any value)\n\n    Returns:\n        tuple (u, v) wrapped to [0, 1]\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(wrap_uv(2.3, -0.7))",
    "solution": "def wrap_uv(u, v):\n    \"\"\"\n    Wrap UV coordinates to [0, 1] range for tiling.\n\n    Args:\n        u: float, horizontal coordinate (can be any value)\n        v: float, vertical coordinate (can be any value)\n\n    Returns:\n        tuple (u, v) wrapped to [0, 1]\n    \"\"\"\n    # Use modulo to wrap coordinates\n    u_wrapped = u % 1.0\n    v_wrapped = v % 1.0\n\n    # Handle negative values\n    if u_wrapped < 0:\n        u_wrapped += 1.0\n    if v_wrapped < 0:\n        v_wrapped += 1.0\n\n    return (u_wrapped, v_wrapped)\n\n# Test\nprint(wrap_uv(2.3, -0.7))",
    "testCases": [
      {
        "input": "2.3, -0.7",
        "expectedOutput": "(0.3, 0.3)",
        "isHidden": false,
        "description": "Positive and negative wrapping"
      },
      {
        "input": "0.5, 0.5",
        "expectedOutput": "(0.5, 0.5)",
        "isHidden": false,
        "description": "Already in range"
      },
      {
        "input": "3.0, -2.0",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": true,
        "description": "Integer values"
      }
    ],
    "hints": [
      "Use the modulo operator (%) to wrap coordinates",
      "The fractional part of a number gives the wrapped value",
      "Handle negative values by adding 1 if the result is negative",
      "Python modulo already handles negatives correctly: -0.7 % 1.0 = 0.3"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Bilinear Texture Filtering",
    "difficulty": 3,
    "description": "Implement bilinear filtering for texture sampling. Interpolate between the four nearest texture pixels based on UV fractional parts.",
    "starterCode": "def bilinear_sample(texture, u, v):\n    \"\"\"\n    Sample texture using bilinear filtering.\n\n    Args:\n        texture: 2D list of (r, g, b) tuples\n        u: float (0-1), horizontal coordinate\n        v: float (0-1), vertical coordinate\n\n    Returns:\n        tuple (r, g, b) interpolated color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\ntexture = [\n    [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 0.0)],\n    [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)],\n    [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)]\n]\nprint(bilinear_sample(texture, 0.5, 0.5))",
    "solution": "def bilinear_sample(texture, u, v):\n    \"\"\"\n    Sample texture using bilinear filtering.\n\n    Args:\n        texture: 2D list of (r, g, b) tuples\n        u: float (0-1), horizontal coordinate\n        v: float (0-1), vertical coordinate\n\n    Returns:\n        tuple (r, g, b) interpolated color\n    \"\"\"\n    height = len(texture)\n    width = len(texture[0])\n\n    # Convert to texture space\n    x = u * (width - 1)\n    y = v * (height - 1)\n\n    # Get integer and fractional parts\n    x0 = int(x)\n    y0 = int(y)\n    x1 = min(x0 + 1, width - 1)\n    y1 = min(y0 + 1, height - 1)\n\n    # Fractional parts for interpolation\n    fx = x - x0\n    fy = y - y0\n\n    # Get four corner samples\n    c00 = texture[y0][x0]  # top-left\n    c10 = texture[y0][x1]  # top-right\n    c01 = texture[y1][x0]  # bottom-left\n    c11 = texture[y1][x1]  # bottom-right\n\n    # Bilinear interpolation for each channel\n    r = (1-fx)*(1-fy)*c00[0] + fx*(1-fy)*c10[0] + (1-fx)*fy*c01[0] + fx*fy*c11[0]\n    g = (1-fx)*(1-fy)*c00[1] + fx*(1-fy)*c10[1] + (1-fx)*fy*c01[1] + fx*fy*c11[1]\n    b = (1-fx)*(1-fy)*c00[2] + fx*(1-fy)*c10[2] + (1-fx)*fy*c01[2] + fx*fy*c11[2]\n\n    return (r, g, b)\n\n# Test\ntexture = [\n    [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 0.0)],\n    [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)],\n    [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)]\n]\nprint(bilinear_sample(texture, 0.5, 0.5))",
    "testCases": [
      {
        "input": "[[(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 0.0)], [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)], [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)]], 0.5, 0.5",
        "expectedOutput": "(0.5, 0.5, 0.0)",
        "isHidden": false,
        "description": "Center interpolation"
      },
      {
        "input": "[[(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)], [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)]], 0.25, 0.5",
        "expectedOutput": "(0.25, 0.25, 0.25)",
        "isHidden": false,
        "description": "Quarter interpolation"
      },
      {
        "input": "[[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 1.0)]], 0.5, 0.5",
        "expectedOutput": "(0.5, 0.5, 0.5)",
        "isHidden": true,
        "description": "Four different corner colors"
      }
    ],
    "hints": [
      "Find the four nearest texels (pixels) around the sample point",
      "Calculate fractional parts (fx, fy) for interpolation weights",
      "Interpolate horizontally first, then vertically (or vice versa)",
      "Or use the full bilinear formula: (1-fx)(1-fy)C00 + fx(1-fy)C10 + (1-fx)fyC01 + fxfyC11",
      "Apply interpolation to each color channel separately"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Spherical UV Mapping",
    "difficulty": 3,
    "description": "Calculate UV coordinates for a point on a sphere using spherical coordinates. U is based on the azimuthal angle (longitude), V is based on the polar angle (latitude).",
    "starterCode": "import math\n\ndef sphere_uv_mapping(point, center, radius):\n    \"\"\"\n    Calculate UV coordinates for a point on a sphere.\n\n    Args:\n        point: tuple (x, y, z) point on sphere surface\n        center: tuple (x, y, z) sphere center\n        radius: float, sphere radius\n\n    Returns:\n        tuple (u, v) UV coordinates\n\n    Notes:\n        - U = 0.5 + atan2(z, x) / (2π)\n        - V = 0.5 - asin(y / radius) / π\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(sphere_uv_mapping((1.0, 0.0, 0.0), (0.0, 0.0, 0.0), 1.0))",
    "solution": "import math\n\ndef sphere_uv_mapping(point, center, radius):\n    \"\"\"\n    Calculate UV coordinates for a point on a sphere.\n\n    Args:\n        point: tuple (x, y, z) point on sphere surface\n        center: tuple (x, y, z) sphere center\n        radius: float, sphere radius\n\n    Returns:\n        tuple (u, v) UV coordinates\n\n    Notes:\n        - U = 0.5 + atan2(z, x) / (2π)\n        - V = 0.5 - asin(y / radius) / π\n    \"\"\"\n    # Translate to sphere's local coordinates\n    local_x = point[0] - center[0]\n    local_y = point[1] - center[1]\n    local_z = point[2] - center[2]\n\n    # Calculate U from azimuthal angle\n    u = 0.5 + math.atan2(local_z, local_x) / (2 * math.pi)\n\n    # Calculate V from polar angle\n    # Clamp y/radius to [-1, 1] to avoid domain errors\n    y_normalized = max(-1.0, min(1.0, local_y / radius))\n    v = 0.5 - math.asin(y_normalized) / math.pi\n\n    return (u, v)\n\n# Test\nprint(sphere_uv_mapping((1.0, 0.0, 0.0), (0.0, 0.0, 0.0), 1.0))",
    "testCases": [
      {
        "input": "(1.0, 0.0, 0.0), (0.0, 0.0, 0.0), 1.0",
        "expectedOutput": "(0.5, 0.5)",
        "isHidden": false,
        "description": "Point on equator at 0 degrees"
      },
      {
        "input": "(0.0, 1.0, 0.0), (0.0, 0.0, 0.0), 1.0",
        "expectedOutput": "(0.5, 0.0)",
        "isHidden": false,
        "description": "North pole"
      },
      {
        "input": "(0.0, 0.0, 1.0), (0.0, 0.0, 0.0), 1.0",
        "expectedOutput": "(0.75, 0.5)",
        "isHidden": true,
        "description": "Point on equator at 90 degrees"
      }
    ],
    "hints": [
      "First translate the point to the sphere's local coordinate system",
      "Use atan2(z, x) to get the azimuthal angle for U",
      "Use asin(y/r) to get the polar angle for V",
      "Add 0.5 and normalize to map to [0, 1] range",
      "Clamp y/radius to [-1, 1] before asin to avoid domain errors"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Cylindrical UV Mapping",
    "difficulty": 2,
    "description": "Calculate UV coordinates for a point on a cylinder. U is based on the angle around the cylinder, V is based on height.",
    "starterCode": "import math\n\ndef cylinder_uv_mapping(point, center, radius, height):\n    \"\"\"\n    Calculate UV coordinates for a point on a cylinder.\n\n    Args:\n        point: tuple (x, y, z) point on cylinder surface\n        center: tuple (x, y, z) cylinder center (bottom)\n        radius: float, cylinder radius\n        height: float, cylinder height\n\n    Returns:\n        tuple (u, v) UV coordinates\n\n    Notes:\n        - Cylinder extends along Y axis from center\n        - U = 0.5 + atan2(z, x) / (2π)\n        - V = y / height\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(cylinder_uv_mapping((1.0, 5.0, 0.0), (0.0, 0.0, 0.0), 1.0, 10.0))",
    "solution": "import math\n\ndef cylinder_uv_mapping(point, center, radius, height):\n    \"\"\"\n    Calculate UV coordinates for a point on a cylinder.\n\n    Args:\n        point: tuple (x, y, z) point on cylinder surface\n        center: tuple (x, y, z) cylinder center (bottom)\n        radius: float, cylinder radius\n        height: float, cylinder height\n\n    Returns:\n        tuple (u, v) UV coordinates\n\n    Notes:\n        - Cylinder extends along Y axis from center\n        - U = 0.5 + atan2(z, x) / (2π)\n        - V = y / height\n    \"\"\"\n    # Translate to cylinder's local coordinates\n    local_x = point[0] - center[0]\n    local_y = point[1] - center[1]\n    local_z = point[2] - center[2]\n\n    # Calculate U from angle around cylinder\n    u = 0.5 + math.atan2(local_z, local_x) / (2 * math.pi)\n\n    # Calculate V from height\n    v = local_y / height\n\n    return (u, v)\n\n# Test\nprint(cylinder_uv_mapping((1.0, 5.0, 0.0), (0.0, 0.0, 0.0), 1.0, 10.0))",
    "testCases": [
      {
        "input": "(1.0, 5.0, 0.0), (0.0, 0.0, 0.0), 1.0, 10.0",
        "expectedOutput": "(0.5, 0.5)",
        "isHidden": false,
        "description": "Middle height, 0 degree angle"
      },
      {
        "input": "(0.0, 10.0, 1.0), (0.0, 0.0, 0.0), 1.0, 10.0",
        "expectedOutput": "(0.75, 1.0)",
        "isHidden": false,
        "description": "Top of cylinder, 90 degree angle"
      },
      {
        "input": "(-1.0, 0.0, 0.0), (0.0, 0.0, 0.0), 1.0, 10.0",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": true,
        "description": "Bottom of cylinder, 180 degree angle"
      }
    ],
    "hints": [
      "Translate the point to cylinder's local coordinate system",
      "U is based on the angle around the Y axis using atan2(z, x)",
      "V is simply the normalized height (y / total_height)",
      "Add 0.5 to the atan2 result and divide by 2π to map to [0, 1]"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Calculate Tangent Space Vector",
    "difficulty": 3,
    "description": "Calculate the tangent vector for a triangle face given its vertices and UV coordinates. The tangent points in the direction of increasing U.",
    "starterCode": "def calculate_tangent(pos0, pos1, pos2, uv0, uv1, uv2):\n    \"\"\"\n    Calculate tangent vector for a triangle.\n\n    Args:\n        pos0, pos1, pos2: tuples (x, y, z), triangle vertices\n        uv0, uv1, uv2: tuples (u, v), UV coordinates for vertices\n\n    Returns:\n        tuple (x, y, z), unnormalized tangent vector\n\n    Notes:\n        Edge1 = pos1 - pos0, Edge2 = pos2 - pos0\n        DeltaUV1 = uv1 - uv0, DeltaUV2 = uv2 - uv0\n        Tangent = (DeltaV2 * Edge1 - DeltaV1 * Edge2) / (DeltaU1 * DeltaV2 - DeltaU2 * DeltaV1)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_tangent(\n    (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0),\n    (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)\n))",
    "solution": "def calculate_tangent(pos0, pos1, pos2, uv0, uv1, uv2):\n    \"\"\"\n    Calculate tangent vector for a triangle.\n\n    Args:\n        pos0, pos1, pos2: tuples (x, y, z), triangle vertices\n        uv0, uv1, uv2: tuples (u, v), UV coordinates for vertices\n\n    Returns:\n        tuple (x, y, z), unnormalized tangent vector\n\n    Notes:\n        Edge1 = pos1 - pos0, Edge2 = pos2 - pos0\n        DeltaUV1 = uv1 - uv0, DeltaUV2 = uv2 - uv0\n        Tangent = (DeltaV2 * Edge1 - DeltaV1 * Edge2) / (DeltaU1 * DeltaV2 - DeltaU2 * DeltaV1)\n    \"\"\"\n    # Calculate edges in position space\n    edge1 = (pos1[0] - pos0[0], pos1[1] - pos0[1], pos1[2] - pos0[2])\n    edge2 = (pos2[0] - pos0[0], pos2[1] - pos0[1], pos2[2] - pos0[2])\n\n    # Calculate edges in UV space\n    delta_uv1 = (uv1[0] - uv0[0], uv1[1] - uv0[1])\n    delta_uv2 = (uv2[0] - uv0[0], uv2[1] - uv0[1])\n\n    # Calculate denominator\n    det = delta_uv1[0] * delta_uv2[1] - delta_uv2[0] * delta_uv1[1]\n\n    if abs(det) < 0.0001:\n        # Degenerate case, return arbitrary tangent\n        return (1.0, 0.0, 0.0)\n\n    # Calculate tangent using the formula\n    f = 1.0 / det\n\n    tangent_x = f * (delta_uv2[1] * edge1[0] - delta_uv1[1] * edge2[0])\n    tangent_y = f * (delta_uv2[1] * edge1[1] - delta_uv1[1] * edge2[1])\n    tangent_z = f * (delta_uv2[1] * edge1[2] - delta_uv1[1] * edge2[2])\n\n    return (tangent_x, tangent_y, tangent_z)\n\n# Test\nprint(calculate_tangent(\n    (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0),\n    (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)\n))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Simple aligned triangle"
      },
      {
        "input": "(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (1.0, 1.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Right triangle in XY plane"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, 1.0), (0.0, 1.0, 1.0), (0.0, 0.0), (1.0, 0.0), (1.0, 1.0)",
        "expectedOutput": "(0.0, 0.0, 1.0)",
        "isHidden": true,
        "description": "Triangle in YZ plane"
      }
    ],
    "hints": [
      "Calculate the position edges: Edge1 = pos1 - pos0, Edge2 = pos2 - pos0",
      "Calculate UV deltas: DeltaUV1 = uv1 - uv0, DeltaUV2 = uv2 - uv0",
      "Calculate determinant: det = DeltaU1 * DeltaV2 - DeltaU2 * DeltaV1",
      "Tangent = (DeltaV2 * Edge1 - DeltaV1 * Edge2) / det",
      "Handle the degenerate case where det is near zero"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Calculate Bitangent Vector",
    "difficulty": 3,
    "description": "Calculate the bitangent (binormal) vector for a triangle. The bitangent points in the direction of increasing V and is perpendicular to the tangent.",
    "starterCode": "def calculate_bitangent(pos0, pos1, pos2, uv0, uv1, uv2):\n    \"\"\"\n    Calculate bitangent vector for a triangle.\n\n    Args:\n        pos0, pos1, pos2: tuples (x, y, z), triangle vertices\n        uv0, uv1, uv2: tuples (u, v), UV coordinates for vertices\n\n    Returns:\n        tuple (x, y, z), unnormalized bitangent vector\n\n    Notes:\n        Bitangent = (DeltaU1 * Edge2 - DeltaU2 * Edge1) / (DeltaU1 * DeltaV2 - DeltaU2 * DeltaV1)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_bitangent(\n    (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0),\n    (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)\n))",
    "solution": "def calculate_bitangent(pos0, pos1, pos2, uv0, uv1, uv2):\n    \"\"\"\n    Calculate bitangent vector for a triangle.\n\n    Args:\n        pos0, pos1, pos2: tuples (x, y, z), triangle vertices\n        uv0, uv1, uv2: tuples (u, v), UV coordinates for vertices\n\n    Returns:\n        tuple (x, y, z), unnormalized bitangent vector\n\n    Notes:\n        Bitangent = (DeltaU1 * Edge2 - DeltaU2 * Edge1) / (DeltaU1 * DeltaV2 - DeltaU2 * DeltaV1)\n    \"\"\"\n    # Calculate edges in position space\n    edge1 = (pos1[0] - pos0[0], pos1[1] - pos0[1], pos1[2] - pos0[2])\n    edge2 = (pos2[0] - pos0[0], pos2[1] - pos0[1], pos2[2] - pos0[2])\n\n    # Calculate edges in UV space\n    delta_uv1 = (uv1[0] - uv0[0], uv1[1] - uv0[1])\n    delta_uv2 = (uv2[0] - uv0[0], uv2[1] - uv0[1])\n\n    # Calculate denominator\n    det = delta_uv1[0] * delta_uv2[1] - delta_uv2[0] * delta_uv1[1]\n\n    if abs(det) < 0.0001:\n        # Degenerate case, return arbitrary bitangent\n        return (0.0, 1.0, 0.0)\n\n    # Calculate bitangent using the formula\n    f = 1.0 / det\n\n    bitangent_x = f * (delta_uv1[0] * edge2[0] - delta_uv2[0] * edge1[0])\n    bitangent_y = f * (delta_uv1[0] * edge2[1] - delta_uv2[0] * edge1[1])\n    bitangent_z = f * (delta_uv1[0] * edge2[2] - delta_uv2[0] * edge1[2])\n\n    return (bitangent_x, bitangent_y, bitangent_z)\n\n# Test\nprint(calculate_bitangent(\n    (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0),\n    (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)\n))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Simple aligned triangle"
      },
      {
        "input": "(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (1.0, 1.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Right triangle in XY plane"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, 1.0), (0.0, 1.0, 1.0), (0.0, 0.0), (1.0, 0.0), (1.0, 1.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": true,
        "description": "Triangle in YZ plane"
      }
    ],
    "hints": [
      "The calculation is similar to tangent but uses Delta U instead of Delta V",
      "Bitangent = (DeltaU1 * Edge2 - DeltaU2 * Edge1) / det",
      "Use the same denominator as the tangent calculation",
      "The bitangent is perpendicular to the tangent in the surface plane"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Transform Normal from Tangent Space",
    "difficulty": 3,
    "description": "Transform a normal vector from tangent space to world space using the TBN (Tangent-Bitangent-Normal) matrix. This is used for normal mapping.",
    "starterCode": "def tangent_to_world(tangent_normal, tangent, bitangent, normal):\n    \"\"\"\n    Transform a normal from tangent space to world space.\n\n    Args:\n        tangent_normal: tuple (x, y, z), normal in tangent space (from normal map)\n        tangent: tuple (x, y, z), tangent vector in world space\n        bitangent: tuple (x, y, z), bitangent vector in world space\n        normal: tuple (x, y, z), normal vector in world space\n\n    Returns:\n        tuple (x, y, z), normal in world space\n\n    Notes:\n        World_Normal = tangent_normal.x * T + tangent_normal.y * B + tangent_normal.z * N\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(tangent_to_world(\n    (0.0, 0.0, 1.0),\n    (1.0, 0.0, 0.0),\n    (0.0, 1.0, 0.0),\n    (0.0, 0.0, 1.0)\n))",
    "solution": "def tangent_to_world(tangent_normal, tangent, bitangent, normal):\n    \"\"\"\n    Transform a normal from tangent space to world space.\n\n    Args:\n        tangent_normal: tuple (x, y, z), normal in tangent space (from normal map)\n        tangent: tuple (x, y, z), tangent vector in world space\n        bitangent: tuple (x, y, z), bitangent vector in world space\n        normal: tuple (x, y, z), normal vector in world space\n\n    Returns:\n        tuple (x, y, z), normal in world space\n\n    Notes:\n        World_Normal = tangent_normal.x * T + tangent_normal.y * B + tangent_normal.z * N\n    \"\"\"\n    # Transform using TBN matrix\n    world_x = (tangent_normal[0] * tangent[0] +\n               tangent_normal[1] * bitangent[0] +\n               tangent_normal[2] * normal[0])\n\n    world_y = (tangent_normal[0] * tangent[1] +\n               tangent_normal[1] * bitangent[1] +\n               tangent_normal[2] * normal[1])\n\n    world_z = (tangent_normal[0] * tangent[2] +\n               tangent_normal[1] * bitangent[2] +\n               tangent_normal[2] * normal[2])\n\n    return (world_x, world_y, world_z)\n\n# Test\nprint(tangent_to_world(\n    (0.0, 0.0, 1.0),\n    (1.0, 0.0, 0.0),\n    (0.0, 1.0, 0.0),\n    (0.0, 0.0, 1.0)\n))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 1.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)",
        "expectedOutput": "(0.0, 0.0, 1.0)",
        "isHidden": false,
        "description": "Identity transformation (no perturbation)"
      },
      {
        "input": "(1.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Perturbed along tangent direction"
      },
      {
        "input": "(0.5, 0.5, 0.707), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)",
        "expectedOutput": "(0.5, 0.5, 0.707)",
        "isHidden": true,
        "description": "Mixed perturbation"
      }
    ],
    "hints": [
      "The TBN matrix transforms from tangent space to world space",
      "Multiply the tangent space normal by each basis vector",
      "World_x = tn.x*T.x + tn.y*B.x + tn.z*N.x (similarly for y and z)",
      "This is essentially a matrix-vector multiplication",
      "In tangent space, (0,0,1) represents an unperturbed surface normal"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Sample and Apply Normal Map",
    "difficulty": 4,
    "description": "Sample a normal map texture and convert the color values to a tangent space normal vector. Normal map RGB values [0,1] map to normal components [-1,1].",
    "starterCode": "import math\n\ndef sample_normal_map(normal_map, u, v):\n    \"\"\"\n    Sample a normal map and convert to tangent space normal.\n\n    Args:\n        normal_map: 2D list of (r, g, b) tuples (values 0-1)\n        u, v: float (0-1), UV coordinates\n\n    Returns:\n        tuple (x, y, z), tangent space normal vector (components -1 to 1)\n\n    Notes:\n        - Normal.x = R * 2 - 1\n        - Normal.y = G * 2 - 1\n        - Normal.z = B * 2 - 1\n        - Normalize the result\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nnormal_map = [\n    [(0.5, 0.5, 1.0), (0.6, 0.5, 0.9)],\n    [(0.4, 0.5, 0.9), (0.5, 0.5, 1.0)]\n]\nprint(sample_normal_map(normal_map, 0.25, 0.25))",
    "solution": "import math\n\ndef sample_normal_map(normal_map, u, v):\n    \"\"\"\n    Sample a normal map and convert to tangent space normal.\n\n    Args:\n        normal_map: 2D list of (r, g, b) tuples (values 0-1)\n        u, v: float (0-1), UV coordinates\n\n    Returns:\n        tuple (x, y, z), tangent space normal vector (components -1 to 1)\n\n    Notes:\n        - Normal.x = R * 2 - 1\n        - Normal.y = G * 2 - 1\n        - Normal.z = B * 2 - 1\n        - Normalize the result\n    \"\"\"\n    # Sample texture (nearest neighbor)\n    height = len(normal_map)\n    width = len(normal_map[0])\n\n    x = int(u * (width - 1))\n    y = int(v * (height - 1))\n\n    x = max(0, min(width - 1, x))\n    y = max(0, min(height - 1, y))\n\n    color = normal_map[y][x]\n\n    # Convert from [0,1] to [-1,1]\n    nx = color[0] * 2.0 - 1.0\n    ny = color[1] * 2.0 - 1.0\n    nz = color[2] * 2.0 - 1.0\n\n    # Normalize\n    magnitude = math.sqrt(nx*nx + ny*ny + nz*nz)\n    if magnitude < 0.0001:\n        return (0.0, 0.0, 1.0)  # Default to facing up\n\n    nx /= magnitude\n    ny /= magnitude\n    nz /= magnitude\n\n    return (nx, ny, nz)\n\n# Test\nnormal_map = [\n    [(0.5, 0.5, 1.0), (0.6, 0.5, 0.9)],\n    [(0.4, 0.5, 0.9), (0.5, 0.5, 1.0)]\n]\nprint(sample_normal_map(normal_map, 0.25, 0.25))",
    "testCases": [
      {
        "input": "[[(0.5, 0.5, 1.0), (0.6, 0.5, 0.9)], [(0.4, 0.5, 0.9), (0.5, 0.5, 1.0)]], 0.25, 0.25",
        "expectedOutput": "(0.0, 0.0, 1.0)",
        "isHidden": false,
        "description": "Flat normal (purple/blue color)"
      },
      {
        "input": "[[(1.0, 0.5, 0.5), (0.5, 0.5, 1.0)], [(0.5, 0.5, 1.0), (0.5, 0.5, 1.0)]], 0.25, 0.25",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Normal pointing in +X direction (red color)"
      },
      {
        "input": "[[(0.7, 0.6, 0.8), (0.5, 0.5, 1.0)], [(0.5, 0.5, 1.0), (0.5, 0.5, 1.0)]], 0.25, 0.25",
        "expectedOutput": "(0.5883484054145521, 0.29417420270727606, 0.7533701668546251)",
        "isHidden": true,
        "description": "Perturbed normal"
      }
    ],
    "hints": [
      "First sample the texture color using UV coordinates",
      "Convert each RGB component from [0,1] to [-1,1] using: component * 2 - 1",
      "Normalize the resulting vector to ensure it has unit length",
      "Blue normal maps (RGB ≈ 0.5, 0.5, 1.0) represent unperturbed surfaces",
      "R channel represents X, G represents Y, B represents Z in tangent space"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Calculate Mipmap Level",
    "difficulty": 4,
    "description": "Calculate the appropriate mipmap level based on texture coordinate derivatives. This helps avoid aliasing when textures are minified.",
    "starterCode": "import math\n\ndef calculate_mipmap_level(du_dx, du_dy, dv_dx, dv_dy, texture_width, texture_height):\n    \"\"\"\n    Calculate mipmap level based on UV derivatives.\n\n    Args:\n        du_dx, du_dy: float, partial derivatives of U with respect to screen x and y\n        dv_dx, dv_dy: float, partial derivatives of V with respect to screen x and y\n        texture_width: int, width of the base mipmap level\n        texture_height: int, height of the base mipmap level\n\n    Returns:\n        float, mipmap level (0 = full resolution)\n\n    Notes:\n        - Scale derivatives by texture dimensions\n        - Calculate the maximum rate of change\n        - Level = log2(max_rate)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_mipmap_level(0.01, 0.0, 0.0, 0.01, 256, 256))",
    "solution": "import math\n\ndef calculate_mipmap_level(du_dx, du_dy, dv_dx, dv_dy, texture_width, texture_height):\n    \"\"\"\n    Calculate mipmap level based on UV derivatives.\n\n    Args:\n        du_dx, du_dy: float, partial derivatives of U with respect to screen x and y\n        dv_dx, dv_dy: float, partial derivatives of V with respect to screen x and y\n        texture_width: int, width of the base mipmap level\n        texture_height: int, height of the base mipmap level\n\n    Returns:\n        float, mipmap level (0 = full resolution)\n\n    Notes:\n        - Scale derivatives by texture dimensions\n        - Calculate the maximum rate of change\n        - Level = log2(max_rate)\n    \"\"\"\n    # Scale derivatives by texture dimensions\n    dudx_scaled = du_dx * texture_width\n    dudy_scaled = du_dy * texture_width\n    dvdx_scaled = dv_dx * texture_height\n    dvdy_scaled = dv_dy * texture_height\n\n    # Calculate lengths of derivative vectors\n    # Length in x direction\n    len_x = math.sqrt(dudx_scaled * dudx_scaled + dvdx_scaled * dvdx_scaled)\n\n    # Length in y direction\n    len_y = math.sqrt(dudy_scaled * dudy_scaled + dvdy_scaled * dvdy_scaled)\n\n    # Take maximum\n    max_rate = max(len_x, len_y)\n\n    # Avoid log(0)\n    if max_rate < 0.0001:\n        return 0.0\n\n    # Calculate mipmap level\n    level = math.log2(max_rate)\n\n    # Clamp to valid range\n    return max(0.0, level)\n\n# Test\nprint(calculate_mipmap_level(0.01, 0.0, 0.0, 0.01, 256, 256))",
    "testCases": [
      {
        "input": "0.01, 0.0, 0.0, 0.01, 256, 256",
        "expectedOutput": "1.3579477780860344",
        "isHidden": false,
        "description": "Medium detail level"
      },
      {
        "input": "0.001, 0.0, 0.0, 0.001, 512, 512",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "High detail (near camera)"
      },
      {
        "input": "0.1, 0.0, 0.0, 0.1, 128, 128",
        "expectedOutput": "4.011227255423254",
        "isHidden": true,
        "description": "Low detail (far from camera)"
      }
    ],
    "hints": [
      "Scale the derivatives by texture dimensions to get texels per pixel",
      "Calculate the rate of change in both screen X and Y directions",
      "Use the Pythagorean theorem to get vector lengths",
      "Take the maximum of the two rates",
      "Use log2 to convert from texels-per-pixel to mipmap level",
      "Level 0 is full resolution, level 1 is half resolution, etc."
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Trilinear Texture Filtering",
    "difficulty": 4,
    "description": "Implement trilinear filtering by sampling two mipmap levels with bilinear filtering and interpolating between them.",
    "starterCode": "import math\n\ndef bilinear_sample(texture, u, v):\n    \"\"\"Helper function for bilinear sampling (provided).\"\"\"\n    height = len(texture)\n    width = len(texture[0])\n    x = u * (width - 1)\n    y = v * (height - 1)\n    x0 = int(x)\n    y0 = int(y)\n    x1 = min(x0 + 1, width - 1)\n    y1 = min(y0 + 1, height - 1)\n    fx = x - x0\n    fy = y - y0\n    c00, c10, c01, c11 = texture[y0][x0], texture[y0][x1], texture[y1][x0], texture[y1][x1]\n    r = (1-fx)*(1-fy)*c00[0] + fx*(1-fy)*c10[0] + (1-fx)*fy*c01[0] + fx*fy*c11[0]\n    g = (1-fx)*(1-fy)*c00[1] + fx*(1-fy)*c10[1] + (1-fx)*fy*c01[1] + fx*fy*c11[1]\n    b = (1-fx)*(1-fy)*c00[2] + fx*(1-fy)*c10[2] + (1-fx)*fy*c01[2] + fx*fy*c11[2]\n    return (r, g, b)\n\ndef trilinear_sample(mipmaps, u, v, mipmap_level):\n    \"\"\"\n    Sample texture using trilinear filtering.\n\n    Args:\n        mipmaps: list of 2D texture arrays (mipmap chain)\n        u, v: float (0-1), UV coordinates\n        mipmap_level: float, calculated mipmap level\n\n    Returns:\n        tuple (r, g, b) interpolated color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nmipmaps = [\n    [[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]],  # Level 0\n    [[(0.5, 0.25, 0.25)]]  # Level 1\n]\nprint(trilinear_sample(mipmaps, 0.5, 0.5, 0.5))",
    "solution": "import math\n\ndef bilinear_sample(texture, u, v):\n    \"\"\"Helper function for bilinear sampling (provided).\"\"\"\n    height = len(texture)\n    width = len(texture[0])\n    x = u * (width - 1)\n    y = v * (height - 1)\n    x0 = int(x)\n    y0 = int(y)\n    x1 = min(x0 + 1, width - 1)\n    y1 = min(y0 + 1, height - 1)\n    fx = x - x0\n    fy = y - y0\n    c00, c10, c01, c11 = texture[y0][x0], texture[y0][x1], texture[y1][x0], texture[y1][x1]\n    r = (1-fx)*(1-fy)*c00[0] + fx*(1-fy)*c10[0] + (1-fx)*fy*c01[0] + fx*fy*c11[0]\n    g = (1-fx)*(1-fy)*c00[1] + fx*(1-fy)*c10[1] + (1-fx)*fy*c01[1] + fx*fy*c11[1]\n    b = (1-fx)*(1-fy)*c00[2] + fx*(1-fy)*c10[2] + (1-fx)*fy*c01[2] + fx*fy*c11[2]\n    return (r, g, b)\n\ndef trilinear_sample(mipmaps, u, v, mipmap_level):\n    \"\"\"\n    Sample texture using trilinear filtering.\n\n    Args:\n        mipmaps: list of 2D texture arrays (mipmap chain)\n        u, v: float (0-1), UV coordinates\n        mipmap_level: float, calculated mipmap level\n\n    Returns:\n        tuple (r, g, b) interpolated color\n    \"\"\"\n    # Clamp mipmap level to valid range\n    max_level = len(mipmaps) - 1\n    mipmap_level = max(0.0, min(max_level, mipmap_level))\n\n    # Get integer and fractional parts\n    level0 = int(mipmap_level)\n    level1 = min(level0 + 1, max_level)\n    blend = mipmap_level - level0\n\n    # Sample both levels with bilinear filtering\n    color0 = bilinear_sample(mipmaps[level0], u, v)\n    color1 = bilinear_sample(mipmaps[level1], u, v)\n\n    # Interpolate between the two levels\n    r = color0[0] * (1 - blend) + color1[0] * blend\n    g = color0[1] * (1 - blend) + color1[1] * blend\n    b = color0[2] * (1 - blend) + color1[2] * blend\n\n    return (r, g, b)\n\n# Test\nmipmaps = [\n    [[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]],  # Level 0\n    [[(0.5, 0.25, 0.25)]]  # Level 1\n]\nprint(trilinear_sample(mipmaps, 0.5, 0.5, 0.5))",
    "testCases": [
      {
        "input": "[[[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)], [(0.0, 0.0, 1.0), (1.0, 1.0, 0.0)]], [[(0.5, 0.25, 0.25)]]], 0.5, 0.5, 0.5",
        "expectedOutput": "(0.5, 0.25, 0.25)",
        "isHidden": false,
        "description": "Blend between two mipmap levels"
      },
      {
        "input": "[[[(1.0, 1.0, 1.0), (0.0, 0.0, 0.0)], [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)]], [[(0.5, 0.5, 0.5)]]], 0.25, 0.25, 0.0",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "Level 0 only (no blending)"
      },
      {
        "input": "[[[(1.0, 0.0, 0.0)]], [[(0.0, 1.0, 0.0)]], [[(0.0, 0.0, 1.0)]]], 0.5, 0.5, 1.5",
        "expectedOutput": "(0.0, 0.5, 0.5)",
        "isHidden": true,
        "description": "Blend between levels 1 and 2"
      }
    ],
    "hints": [
      "Clamp the mipmap level to valid range [0, max_level]",
      "Split the level into integer part (which levels) and fractional part (blend factor)",
      "Use bilinear sampling on both adjacent mipmap levels",
      "Linearly interpolate between the two sampled colors using the fractional part",
      "Trilinear = bilinear on level N + bilinear on level N+1, then blend"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Parallax Occlusion Mapping Offset",
    "difficulty": 5,
    "description": "Calculate UV offset for parallax occlusion mapping. This technique adjusts UV coordinates based on view direction and height map to create depth illusion.",
    "starterCode": "def parallax_offset(height_map, u, v, view_dir_tangent, height_scale):\n    \"\"\"\n    Calculate UV offset for parallax mapping.\n\n    Args:\n        height_map: 2D list of float values (0-1), where 1 = raised, 0 = deep\n        u, v: float (0-1), original UV coordinates\n        view_dir_tangent: tuple (x, y, z), view direction in tangent space\n        height_scale: float, strength of parallax effect\n\n    Returns:\n        tuple (u_offset, v_offset) to add to original UVs\n\n    Notes:\n        - Sample height at UV\n        - Offset = (view_dir_tangent.xy / view_dir_tangent.z) * (height - 0.5) * height_scale\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nheight_map = [\n    [0.0, 0.5],\n    [0.5, 1.0]\n]\nprint(parallax_offset(height_map, 0.25, 0.25, (0.2, 0.2, 1.0), 0.1))",
    "solution": "def parallax_offset(height_map, u, v, view_dir_tangent, height_scale):\n    \"\"\"\n    Calculate UV offset for parallax mapping.\n\n    Args:\n        height_map: 2D list of float values (0-1), where 1 = raised, 0 = deep\n        u, v: float (0-1), original UV coordinates\n        view_dir_tangent: tuple (x, y, z), view direction in tangent space\n        height_scale: float, strength of parallax effect\n\n    Returns:\n        tuple (u_offset, v_offset) to add to original UVs\n\n    Notes:\n        - Sample height at UV\n        - Offset = (view_dir_tangent.xy / view_dir_tangent.z) * (height - 0.5) * height_scale\n    \"\"\"\n    # Sample height map\n    height = len(height_map)\n    width = len(height_map[0])\n\n    x = int(u * (width - 1))\n    y = int(v * (height - 1))\n\n    x = max(0, min(width - 1, x))\n    y = max(0, min(height - 1, y))\n\n    sampled_height = height_map[y][x]\n\n    # Avoid division by zero\n    if abs(view_dir_tangent[2]) < 0.0001:\n        return (0.0, 0.0)\n\n    # Calculate offset\n    # Center height around 0 (0.5 = no offset)\n    height_factor = (sampled_height - 0.5) * height_scale\n\n    # Project view direction onto tangent plane\n    u_offset = (view_dir_tangent[0] / view_dir_tangent[2]) * height_factor\n    v_offset = (view_dir_tangent[1] / view_dir_tangent[2]) * height_factor\n\n    return (u_offset, v_offset)\n\n# Test\nheight_map = [\n    [0.0, 0.5],\n    [0.5, 1.0]\n]\nprint(parallax_offset(height_map, 0.25, 0.25, (0.2, 0.2, 1.0), 0.1))",
    "testCases": [
      {
        "input": "[[0.0, 0.5], [0.5, 1.0]], 0.25, 0.25, (0.2, 0.2, 1.0), 0.1",
        "expectedOutput": "(-0.01, -0.01)",
        "isHidden": false,
        "description": "Low height value, negative offset"
      },
      {
        "input": "[[0.0, 0.5], [0.5, 1.0]], 0.75, 0.75, (0.2, 0.2, 1.0), 0.1",
        "expectedOutput": "(0.01, 0.01)",
        "isHidden": false,
        "description": "High height value, positive offset"
      },
      {
        "input": "[[0.5, 0.5], [0.5, 0.5]], 0.5, 0.5, (0.4, 0.0, 1.0), 0.2",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": true,
        "description": "Mid-height (0.5), no offset"
      }
    ],
    "hints": [
      "Sample the height map at the given UV coordinates",
      "Height of 0.5 means no displacement, so subtract 0.5 to center",
      "Divide view direction XY by Z to get the parallax direction",
      "Scale by height and height_scale parameter",
      "The offset shifts UV coordinates to simulate depth",
      "When viewing at an angle, higher points should shift opposite to view direction"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Cube Map Face Selection",
    "difficulty": 4,
    "description": "Determine which face of a cube map to sample and calculate UV coordinates for environment mapping. Given a 3D direction vector, find the corresponding cube face and 2D coordinates.",
    "starterCode": "def cube_map_lookup(direction):\n    \"\"\"\n    Convert 3D direction to cube map face and UV coordinates.\n\n    Args:\n        direction: tuple (x, y, z), normalized direction vector\n\n    Returns:\n        tuple (face_index, u, v) where:\n            face_index: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z\n            u, v: float (0-1), coordinates on that face\n\n    Notes:\n        - Choose face with largest absolute component\n        - Map other two components to UV based on face orientation\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(cube_map_lookup((1.0, 0.2, 0.3)))",
    "solution": "def cube_map_lookup(direction):\n    \"\"\"\n    Convert 3D direction to cube map face and UV coordinates.\n\n    Args:\n        direction: tuple (x, y, z), normalized direction vector\n\n    Returns:\n        tuple (face_index, u, v) where:\n            face_index: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z\n            u, v: float (0-1), coordinates on that face\n\n    Notes:\n        - Choose face with largest absolute component\n        - Map other two components to UV based on face orientation\n    \"\"\"\n    abs_x = abs(direction[0])\n    abs_y = abs(direction[1])\n    abs_z = abs(direction[2])\n\n    # Determine which face\n    if abs_x >= abs_y and abs_x >= abs_z:\n        # X-dominant\n        if direction[0] > 0:\n            # +X face (face 0)\n            face_index = 0\n            u = 0.5 - direction[2] / (2.0 * abs_x)\n            v = 0.5 - direction[1] / (2.0 * abs_x)\n        else:\n            # -X face (face 1)\n            face_index = 1\n            u = 0.5 + direction[2] / (2.0 * abs_x)\n            v = 0.5 - direction[1] / (2.0 * abs_x)\n    elif abs_y >= abs_z:\n        # Y-dominant\n        if direction[1] > 0:\n            # +Y face (face 2)\n            face_index = 2\n            u = 0.5 + direction[0] / (2.0 * abs_y)\n            v = 0.5 + direction[2] / (2.0 * abs_y)\n        else:\n            # -Y face (face 3)\n            face_index = 3\n            u = 0.5 + direction[0] / (2.0 * abs_y)\n            v = 0.5 - direction[2] / (2.0 * abs_y)\n    else:\n        # Z-dominant\n        if direction[2] > 0:\n            # +Z face (face 4)\n            face_index = 4\n            u = 0.5 + direction[0] / (2.0 * abs_z)\n            v = 0.5 - direction[1] / (2.0 * abs_z)\n        else:\n            # -Z face (face 5)\n            face_index = 5\n            u = 0.5 - direction[0] / (2.0 * abs_z)\n            v = 0.5 - direction[1] / (2.0 * abs_z)\n\n    return (face_index, u, v)\n\n# Test\nprint(cube_map_lookup((1.0, 0.2, 0.3)))",
    "testCases": [
      {
        "input": "(1.0, 0.2, 0.3)",
        "expectedOutput": "(0, 0.35, 0.4)",
        "isHidden": false,
        "description": "+X dominant direction"
      },
      {
        "input": "(0.0, 1.0, 0.0)",
        "expectedOutput": "(2, 0.5, 0.5)",
        "isHidden": false,
        "description": "Straight up (+Y)"
      },
      {
        "input": "(0.2, -0.1, -1.0)",
        "expectedOutput": "(5, 0.4, 0.45)",
        "isHidden": true,
        "description": "-Z dominant direction"
      }
    ],
    "hints": [
      "Find the component with the largest absolute value to determine the face",
      "The major axis component determines which face, its sign determines positive or negative",
      "The other two components map to U and V on that face",
      "Divide by the major component to normalize, then scale and offset to [0,1]",
      "Each face has different orientation for its UV mapping"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Anisotropic Filtering Calculation",
    "difficulty": 5,
    "description": "Calculate the anisotropic ratio and sampling direction for anisotropic texture filtering. This improves quality when textures are viewed at oblique angles.",
    "starterCode": "import math\n\ndef calculate_anisotropic_params(du_dx, du_dy, dv_dx, dv_dy, texture_width, texture_height, max_aniso):\n    \"\"\"\n    Calculate anisotropic filtering parameters.\n\n    Args:\n        du_dx, du_dy, dv_dx, dv_dy: float, UV derivatives\n        texture_width, texture_height: int, texture dimensions\n        max_aniso: int, maximum anisotropy samples (e.g., 16)\n\n    Returns:\n        tuple (num_samples, step_u, step_v, mip_level) where:\n            num_samples: int, number of samples to take\n            step_u, step_v: float, step in UV per sample\n            mip_level: float, mipmap level to use\n\n    Notes:\n        - Calculate lengths of derivative vectors in texture space\n        - Anisotropy ratio = max_length / min_length\n        - Sample along major axis direction\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(calculate_anisotropic_params(0.02, 0.001, 0.0, 0.0, 256, 256, 16))",
    "solution": "import math\n\ndef calculate_anisotropic_params(du_dx, du_dy, dv_dx, dv_dy, texture_width, texture_height, max_aniso):\n    \"\"\"\n    Calculate anisotropic filtering parameters.\n\n    Args:\n        du_dx, du_dy, dv_dx, dv_dy: float, UV derivatives\n        texture_width, texture_height: int, texture dimensions\n        max_aniso: int, maximum anisotropy samples (e.g., 16)\n\n    Returns:\n        tuple (num_samples, step_u, step_v, mip_level) where:\n            num_samples: int, number of samples to take\n            step_u, step_v: float, step in UV per sample\n            mip_level: float, mipmap level to use\n\n    Notes:\n        - Calculate lengths of derivative vectors in texture space\n        - Anisotropy ratio = max_length / min_length\n        - Sample along major axis direction\n    \"\"\"\n    # Scale derivatives by texture dimensions\n    dudx = du_dx * texture_width\n    dudy = du_dy * texture_width\n    dvdx = dv_dx * texture_height\n    dvdy = dv_dy * texture_height\n\n    # Calculate squared lengths of derivative vectors\n    len_x_sq = dudx * dudx + dvdx * dvdx\n    len_y_sq = dudy * dudy + dvdy * dvdy\n\n    # Get actual lengths\n    len_x = math.sqrt(len_x_sq)\n    len_y = math.sqrt(len_y_sq)\n\n    # Determine major and minor axes\n    major_length = max(len_x, len_y)\n    minor_length = min(len_x, len_y)\n\n    # Avoid division by zero\n    if minor_length < 0.0001:\n        minor_length = 0.0001\n\n    # Calculate anisotropy ratio\n    aniso_ratio = major_length / minor_length\n\n    # Clamp to max anisotropy\n    num_samples = min(int(aniso_ratio + 0.5), max_aniso)\n    num_samples = max(1, num_samples)\n\n    # Mipmap level based on minor axis\n    mip_level = max(0.0, math.log2(minor_length)) if minor_length > 0 else 0.0\n\n    # Determine step direction (along major axis)\n    if len_x > len_y:\n        # Step along x derivative direction\n        step_u = du_dx / num_samples\n        step_v = dv_dx / num_samples\n    else:\n        # Step along y derivative direction\n        step_u = du_dy / num_samples\n        step_v = dv_dy / num_samples\n\n    return (num_samples, step_u, step_v, mip_level)\n\n# Test\nprint(calculate_anisotropic_params(0.02, 0.001, 0.0, 0.0, 256, 256, 16))",
    "testCases": [
      {
        "input": "0.02, 0.001, 0.0, 0.0, 256, 256, 16",
        "expectedOutput": "(5, 0.004, 0.0, 0.0)",
        "isHidden": false,
        "description": "Horizontal anisotropy"
      },
      {
        "input": "0.001, 0.001, 0.001, 0.02, 256, 256, 8",
        "expectedOutput": "(5, 0.0, 0.004, 0.0)",
        "isHidden": false,
        "description": "Vertical anisotropy with max 8x"
      },
      {
        "input": "0.005, 0.005, 0.005, 0.005, 512, 512, 16",
        "expectedOutput": "(1, 0.005, 0.005, 2.678071905112638)",
        "isHidden": true,
        "description": "Isotropic case (no anisotropy)"
      }
    ],
    "hints": [
      "Scale UV derivatives by texture dimensions to get texel space",
      "Calculate the lengths of both derivative vectors",
      "The ratio of major to minor axis gives anisotropy level",
      "Clamp number of samples to max_aniso",
      "Use the minor axis length to determine mipmap level",
      "Step direction is along the major axis, divided by number of samples",
      "Anisotropic filtering takes multiple samples along the elongated axis"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t6-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-6",
    "title": "Complete Normal Mapped Lighting",
    "difficulty": 5,
    "description": "Implement complete Phong lighting with normal mapping. Sample normal map, transform to world space, and calculate lighting with diffuse and specular components.",
    "starterCode": "import math\n\ndef dot_product(a, b):\n    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n\ndef normalize(v):\n    mag = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n    if mag < 0.0001: return (0.0, 0.0, 1.0)\n    return (v[0]/mag, v[1]/mag, v[2]/mag)\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    return (2*n_dot_l*normal[0]-light_dir[0],\n            2*n_dot_l*normal[1]-light_dir[1],\n            2*n_dot_l*normal[2]-light_dir[2])\n\ndef normal_mapped_lighting(base_color, specular_color, normal_map, u, v,\n                           tangent, bitangent, normal, light_dir, view_dir,\n                           light_intensity, shininess):\n    \"\"\"\n    Calculate Phong lighting with normal mapping.\n\n    Args:\n        base_color: tuple (r, g, b), material color\n        specular_color: tuple (r, g, b), specular color\n        normal_map: 2D list of (r, g, b) tuples (normal map texture)\n        u, v: float (0-1), UV coordinates\n        tangent, bitangent, normal: tuple (x, y, z), TBN basis vectors (normalized)\n        light_dir, view_dir: tuple (x, y, z), normalized directions in world space\n        light_intensity: float, light brightness\n        shininess: float, specular exponent\n\n    Returns:\n        tuple (r, g, b) final lit color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nnormal_map = [[(0.5, 0.5, 1.0), (0.6, 0.5, 0.9)], [(0.5, 0.5, 1.0), (0.5, 0.5, 1.0)]]\nprint(normal_mapped_lighting(\n    (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), normal_map, 0.25, 0.25,\n    (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0),\n    (0.0, 0.0, 1.0), (0.0, 0.0, 1.0), 1.0, 32.0\n))",
    "solution": "import math\n\ndef dot_product(a, b):\n    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n\ndef normalize(v):\n    mag = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n    if mag < 0.0001: return (0.0, 0.0, 1.0)\n    return (v[0]/mag, v[1]/mag, v[2]/mag)\n\ndef reflect_vector(light_dir, normal):\n    n_dot_l = dot_product(normal, light_dir)\n    return (2*n_dot_l*normal[0]-light_dir[0],\n            2*n_dot_l*normal[1]-light_dir[1],\n            2*n_dot_l*normal[2]-light_dir[2])\n\ndef normal_mapped_lighting(base_color, specular_color, normal_map, u, v,\n                           tangent, bitangent, normal, light_dir, view_dir,\n                           light_intensity, shininess):\n    \"\"\"\n    Calculate Phong lighting with normal mapping.\n\n    Args:\n        base_color: tuple (r, g, b), material color\n        specular_color: tuple (r, g, b), specular color\n        normal_map: 2D list of (r, g, b) tuples (normal map texture)\n        u, v: float (0-1), UV coordinates\n        tangent, bitangent, normal: tuple (x, y, z), TBN basis vectors (normalized)\n        light_dir, view_dir: tuple (x, y, z), normalized directions in world space\n        light_intensity: float, light brightness\n        shininess: float, specular exponent\n\n    Returns:\n        tuple (r, g, b) final lit color\n    \"\"\"\n    # Sample normal map\n    height = len(normal_map)\n    width = len(normal_map[0])\n    x = max(0, min(width-1, int(u * (width-1))))\n    y = max(0, min(height-1, int(v * (height-1))))\n    color = normal_map[y][x]\n\n    # Convert to tangent space normal\n    tn_x = color[0] * 2.0 - 1.0\n    tn_y = color[1] * 2.0 - 1.0\n    tn_z = color[2] * 2.0 - 1.0\n    tangent_normal = normalize((tn_x, tn_y, tn_z))\n\n    # Transform to world space using TBN\n    world_normal_x = tangent_normal[0]*tangent[0] + tangent_normal[1]*bitangent[0] + tangent_normal[2]*normal[0]\n    world_normal_y = tangent_normal[0]*tangent[1] + tangent_normal[1]*bitangent[1] + tangent_normal[2]*normal[1]\n    world_normal_z = tangent_normal[0]*tangent[2] + tangent_normal[1]*bitangent[2] + tangent_normal[2]*normal[2]\n    world_normal = normalize((world_normal_x, world_normal_y, world_normal_z))\n\n    # Calculate diffuse\n    n_dot_l = max(0.0, dot_product(world_normal, light_dir))\n    diffuse_r = light_intensity * base_color[0] * n_dot_l\n    diffuse_g = light_intensity * base_color[1] * n_dot_l\n    diffuse_b = light_intensity * base_color[2] * n_dot_l\n\n    # Calculate specular\n    reflection = reflect_vector(light_dir, world_normal)\n    r_dot_v = max(0.0, dot_product(reflection, view_dir))\n    spec_factor = r_dot_v ** shininess\n    specular_r = light_intensity * specular_color[0] * spec_factor\n    specular_g = light_intensity * specular_color[1] * spec_factor\n    specular_b = light_intensity * specular_color[2] * spec_factor\n\n    # Combine\n    final_r = diffuse_r + specular_r\n    final_g = diffuse_g + specular_g\n    final_b = diffuse_b + specular_b\n\n    return (final_r, final_g, final_b)\n\n# Test\nnormal_map = [[(0.5, 0.5, 1.0), (0.6, 0.5, 0.9)], [(0.5, 0.5, 1.0), (0.5, 0.5, 1.0)]]\nprint(normal_mapped_lighting(\n    (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), normal_map, 0.25, 0.25,\n    (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0),\n    (0.0, 0.0, 1.0), (0.0, 0.0, 1.0), 1.0, 32.0\n))",
    "testCases": [
      {
        "input": "[[(0.5, 0.5, 1.0), (0.6, 0.5, 0.9)], [(0.5, 0.5, 1.0), (0.5, 0.5, 1.0)]], (1.0, 0.5, 0.3), (1.0, 1.0, 1.0), 0.25, 0.25, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0), (0.0, 0.0, 1.0), (0.0, 0.0, 1.0), 1.0, 32.0",
        "expectedOutput": "(2.0, 1.5, 1.3)",
        "isHidden": false,
        "description": "Flat normal map (no perturbation), perfect alignment"
      },
      {
        "input": "[[(1.0, 0.5, 0.5), (0.5, 0.5, 1.0)], [(0.5, 0.5, 1.0), (0.5, 0.5, 1.0)]], (0.8, 0.8, 0.8), (1.0, 1.0, 1.0), 0.25, 0.25, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0), (0.0, 0.0, 1.0), (0.0, 0.0, 1.0), 1.0, 16.0",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "Perturbed normal pointing in +X"
      },
      {
        "input": "[[(0.5, 0.5, 1.0)]], (1.0, 0.0, 0.0), (1.0, 1.0, 1.0), 0.5, 0.5, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0), (0.7071, 0.0, 0.7071), (0.0, 0.0, 1.0), 0.8, 64.0",
        "expectedOutput": "(0.5656854249492381, 0.0, 0.0)",
        "isHidden": true,
        "description": "Angled light with red material"
      }
    ],
    "hints": [
      "Sample the normal map texture at UV coordinates",
      "Convert RGB [0,1] to normal components [-1,1]",
      "Transform the tangent space normal to world space using TBN matrix",
      "Calculate diffuse lighting: intensity * color * max(0, N·L)",
      "Calculate specular: intensity * spec_color * max(0, R·V)^shininess",
      "Combine diffuse and specular for final color",
      "The normal map provides per-pixel normal variations for detailed lighting"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex01",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Generate Camera Ray",
    "difficulty": 1,
    "description": "Generate a camera ray for a given pixel coordinate. The ray originates from the camera position and passes through the pixel on the image plane.",
    "starterCode": "def generate_camera_ray(pixel_x, pixel_y, image_width, image_height, camera_pos, fov):\n    \"\"\"\n    Generate a ray from camera through a pixel.\n\n    Args:\n        pixel_x, pixel_y: int, pixel coordinates\n        image_width, image_height: int, image dimensions\n        camera_pos: tuple (x, y, z), camera position\n        fov: float, field of view in degrees\n\n    Returns:\n        tuple (origin, direction) where:\n            origin: tuple (x, y, z)\n            direction: tuple (x, y, z) normalized\n\n    Notes:\n        - Assume camera looks down -Z axis\n        - Image plane is at Z = -1\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(generate_camera_ray(400, 300, 800, 600, (0.0, 0.0, 0.0), 90.0))",
    "solution": "def generate_camera_ray(pixel_x, pixel_y, image_width, image_height, camera_pos, fov):\n    \"\"\"\n    Generate a ray from camera through a pixel.\n\n    Args:\n        pixel_x, pixel_y: int, pixel coordinates\n        image_width, image_height: int, image dimensions\n        camera_pos: tuple (x, y, z), camera position\n        fov: float, field of view in degrees\n\n    Returns:\n        tuple (origin, direction) where:\n            origin: tuple (x, y, z)\n            direction: tuple (x, y, z) normalized\n\n    Notes:\n        - Assume camera looks down -Z axis\n        - Image plane is at Z = -1\n    \"\"\"\n    import math\n\n    # Convert to normalized device coordinates [-1, 1]\n    ndc_x = (2.0 * pixel_x / image_width) - 1.0\n    ndc_y = 1.0 - (2.0 * pixel_y / image_height)\n\n    # Apply aspect ratio\n    aspect_ratio = image_width / image_height\n\n    # Calculate viewport dimensions based on FOV\n    fov_rad = math.radians(fov)\n    scale = math.tan(fov_rad / 2.0)\n\n    # Calculate ray direction in camera space\n    ray_x = ndc_x * aspect_ratio * scale\n    ray_y = ndc_y * scale\n    ray_z = -1.0\n\n    # Normalize direction\n    magnitude = math.sqrt(ray_x**2 + ray_y**2 + ray_z**2)\n    direction = (ray_x / magnitude, ray_y / magnitude, ray_z / magnitude)\n\n    # Ray origin is camera position\n    origin = camera_pos\n\n    return (origin, direction)\n\n# Test\nprint(generate_camera_ray(400, 300, 800, 600, (0.0, 0.0, 0.0), 90.0))",
    "testCases": [
      {
        "input": "400, 300, 800, 600, (0.0, 0.0, 0.0), 90.0",
        "expectedOutput": "((0.0, 0.0, 0.0), (0.0, 0.0, -1.0))",
        "isHidden": false,
        "description": "Center pixel ray (straight ahead)"
      },
      {
        "input": "0, 0, 800, 600, (0.0, 0.0, 0.0), 90.0",
        "expectedOutput": "((0.0, 0.0, 0.0), (-0.7682212795973759, 0.5761659596980319, -0.28808297984901594))",
        "isHidden": false,
        "description": "Top-left corner pixel"
      },
      {
        "input": "800, 600, 800, 600, (1.0, 2.0, 3.0), 60.0",
        "expectedOutput": "((1.0, 2.0, 3.0), (0.6546536707079772, -0.5773502691896257, -0.4909524754503578))",
        "isHidden": true,
        "description": "Bottom-right with offset camera position"
      }
    ],
    "hints": [
      "Convert pixel coordinates to normalized device coordinates (NDC) in range [-1, 1]",
      "Apply aspect ratio to X coordinate",
      "Use FOV to calculate the scale (tan(fov/2))",
      "Ray direction in camera space: (ndc_x * aspect * scale, ndc_y * scale, -1)",
      "Normalize the direction vector",
      "Ray origin is the camera position"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex02",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Ray-Sphere Intersection",
    "difficulty": 2,
    "description": "Calculate the intersection point(s) between a ray and a sphere. Return the nearest intersection distance, or None if no intersection.",
    "starterCode": "import math\n\ndef ray_sphere_intersection(ray_origin, ray_dir, sphere_center, sphere_radius):\n    \"\"\"\n    Calculate ray-sphere intersection.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n\n    Returns:\n        float or None, distance to nearest intersection (None if no hit)\n\n    Notes:\n        Solve: ||origin + t*direction - center||² = radius²\n        This gives a quadratic equation in t\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(ray_sphere_intersection((0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0))",
    "solution": "import math\n\ndef ray_sphere_intersection(ray_origin, ray_dir, sphere_center, sphere_radius):\n    \"\"\"\n    Calculate ray-sphere intersection.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n\n    Returns:\n        float or None, distance to nearest intersection (None if no hit)\n\n    Notes:\n        Solve: ||origin + t*direction - center||² = radius²\n        This gives a quadratic equation in t\n    \"\"\"\n    # Vector from sphere center to ray origin\n    oc_x = ray_origin[0] - sphere_center[0]\n    oc_y = ray_origin[1] - sphere_center[1]\n    oc_z = ray_origin[2] - sphere_center[2]\n\n    # Quadratic coefficients: at² + bt + c = 0\n    # a = direction · direction (which is 1 for normalized direction)\n    a = ray_dir[0]**2 + ray_dir[1]**2 + ray_dir[2]**2\n\n    # b = 2 * (direction · oc)\n    b = 2.0 * (ray_dir[0]*oc_x + ray_dir[1]*oc_y + ray_dir[2]*oc_z)\n\n    # c = oc · oc - radius²\n    c = oc_x**2 + oc_y**2 + oc_z**2 - sphere_radius**2\n\n    # Calculate discriminant\n    discriminant = b*b - 4*a*c\n\n    # No intersection if discriminant is negative\n    if discriminant < 0:\n        return None\n\n    # Calculate both solutions\n    sqrt_discriminant = math.sqrt(discriminant)\n    t1 = (-b - sqrt_discriminant) / (2*a)\n    t2 = (-b + sqrt_discriminant) / (2*a)\n\n    # Return nearest positive intersection\n    if t1 > 0.0001:  # Small epsilon to avoid self-intersection\n        return t1\n    elif t2 > 0.0001:\n        return t2\n    else:\n        return None\n\n# Test\nprint(ray_sphere_intersection((0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0",
        "expectedOutput": "4.0",
        "isHidden": false,
        "description": "Ray hits sphere straight on"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (5.0, 0.0, -5.0), 1.0",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Ray misses sphere"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.7071, 0.0, -0.7071), (2.0, 0.0, -2.0), 1.0",
        "expectedOutput": "1.8284271247461903",
        "isHidden": true,
        "description": "Diagonal ray hits sphere"
      }
    ],
    "hints": [
      "Use the quadratic formula to solve for intersection parameter t",
      "Calculate oc = ray_origin - sphere_center",
      "Coefficients: a = dir·dir, b = 2(dir·oc), c = oc·oc - r²",
      "Check discriminant: if negative, no intersection",
      "Return the smaller positive t value (nearest intersection)",
      "Use a small epsilon to avoid self-intersection artifacts"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex03",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Calculate Sphere Normal",
    "difficulty": 1,
    "description": "Calculate the surface normal at a point on a sphere. The normal at any point on a sphere points radially outward from the center.",
    "starterCode": "import math\n\ndef sphere_normal(point, sphere_center):\n    \"\"\"\n    Calculate surface normal at a point on a sphere.\n\n    Args:\n        point: tuple (x, y, z), point on sphere surface\n        sphere_center: tuple (x, y, z), sphere center\n\n    Returns:\n        tuple (x, y, z), normalized surface normal\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(sphere_normal((3.0, 0.0, 0.0), (0.0, 0.0, 0.0)))",
    "solution": "import math\n\ndef sphere_normal(point, sphere_center):\n    \"\"\"\n    Calculate surface normal at a point on a sphere.\n\n    Args:\n        point: tuple (x, y, z), point on sphere surface\n        sphere_center: tuple (x, y, z), sphere center\n\n    Returns:\n        tuple (x, y, z), normalized surface normal\n    \"\"\"\n    # Vector from center to point\n    nx = point[0] - sphere_center[0]\n    ny = point[1] - sphere_center[1]\n    nz = point[2] - sphere_center[2]\n\n    # Normalize\n    magnitude = math.sqrt(nx*nx + ny*ny + nz*nz)\n\n    if magnitude < 0.0001:\n        return (0.0, 1.0, 0.0)  # Arbitrary default\n\n    return (nx / magnitude, ny / magnitude, nz / magnitude)\n\n# Test\nprint(sphere_normal((3.0, 0.0, 0.0), (0.0, 0.0, 0.0)))",
    "testCases": [
      {
        "input": "(3.0, 0.0, 0.0), (0.0, 0.0, 0.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Point on +X axis"
      },
      {
        "input": "(0.0, -2.0, 0.0), (0.0, 0.0, 0.0)",
        "expectedOutput": "(0.0, -1.0, 0.0)",
        "isHidden": false,
        "description": "Point on -Y axis"
      },
      {
        "input": "(1.0, 1.0, 1.0), (0.0, 0.0, 0.0)",
        "expectedOutput": "(0.5773502691896258, 0.5773502691896258, 0.5773502691896258)",
        "isHidden": true,
        "description": "Point on diagonal"
      }
    ],
    "hints": [
      "The normal is simply the vector from sphere center to the point",
      "Subtract sphere center from the point to get the direction",
      "Normalize the resulting vector",
      "Sphere normals always point radially outward from the center"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex04",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Ray-Plane Intersection",
    "difficulty": 2,
    "description": "Calculate the intersection between a ray and an infinite plane. A plane is defined by a point and a normal vector.",
    "starterCode": "def ray_plane_intersection(ray_origin, ray_dir, plane_point, plane_normal):\n    \"\"\"\n    Calculate ray-plane intersection.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        plane_point: tuple (x, y, z), a point on the plane\n        plane_normal: tuple (x, y, z), normalized plane normal\n\n    Returns:\n        float or None, distance to intersection (None if parallel/behind)\n\n    Notes:\n        Plane equation: (P - plane_point) · plane_normal = 0\n        Ray equation: P = origin + t * direction\n        Solve for t\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(ray_plane_intersection((0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def ray_plane_intersection(ray_origin, ray_dir, plane_point, plane_normal):\n    \"\"\"\n    Calculate ray-plane intersection.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        plane_point: tuple (x, y, z), a point on the plane\n        plane_normal: tuple (x, y, z), normalized plane normal\n\n    Returns:\n        float or None, distance to intersection (None if parallel/behind)\n\n    Notes:\n        Plane equation: (P - plane_point) · plane_normal = 0\n        Ray equation: P = origin + t * direction\n        Solve for t\n    \"\"\"\n    # Calculate denominator: direction · normal\n    denom = (ray_dir[0] * plane_normal[0] +\n             ray_dir[1] * plane_normal[1] +\n             ray_dir[2] * plane_normal[2])\n\n    # If denominator is near zero, ray is parallel to plane\n    if abs(denom) < 0.0001:\n        return None\n\n    # Calculate vector from ray origin to plane point\n    px = plane_point[0] - ray_origin[0]\n    py = plane_point[1] - ray_origin[1]\n    pz = plane_point[2] - ray_origin[2]\n\n    # Calculate numerator: (plane_point - origin) · normal\n    numer = px * plane_normal[0] + py * plane_normal[1] + pz * plane_normal[2]\n\n    # Calculate t\n    t = numer / denom\n\n    # Only return positive t (intersection in front of ray)\n    if t > 0.0001:\n        return t\n    else:\n        return None\n\n# Test\nprint(ray_plane_intersection((0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.0, 5.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Ray pointing down at horizontal plane"
      },
      {
        "input": "(0.0, 5.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Ray pointing away from plane"
      },
      {
        "input": "(0.0, 0.0, 5.0), (0.0, 0.0, -1.0), (0.0, 0.0, 0.0), (0.0, 0.0, 1.0)",
        "expectedOutput": "5.0",
        "isHidden": true,
        "description": "Ray along Z axis"
      }
    ],
    "hints": [
      "Calculate the dot product of ray direction and plane normal",
      "If this is near zero, the ray is parallel to the plane",
      "Use the formula: t = ((plane_point - ray_origin) · plane_normal) / (ray_dir · plane_normal)",
      "Only return t if it's positive (intersection ahead of ray origin)",
      "Use a small epsilon to avoid numerical issues"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex05",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Calculate Reflection Vector",
    "difficulty": 2,
    "description": "Calculate the reflection of a ray direction given a surface normal. This is used for mirror reflections in ray tracing.",
    "starterCode": "def reflect_ray(incident, normal):\n    \"\"\"\n    Calculate reflection vector.\n\n    Args:\n        incident: tuple (x, y, z), normalized incident ray direction\n        normal: tuple (x, y, z), normalized surface normal\n\n    Returns:\n        tuple (x, y, z), normalized reflection direction\n\n    Notes:\n        R = I - 2(N·I)N\n        where I is incident direction, N is normal\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(reflect_ray((0.0, -1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def reflect_ray(incident, normal):\n    \"\"\"\n    Calculate reflection vector.\n\n    Args:\n        incident: tuple (x, y, z), normalized incident ray direction\n        normal: tuple (x, y, z), normalized surface normal\n\n    Returns:\n        tuple (x, y, z), normalized reflection direction\n\n    Notes:\n        R = I - 2(N·I)N\n        where I is incident direction, N is normal\n    \"\"\"\n    # Calculate dot product N·I\n    dot = normal[0] * incident[0] + normal[1] * incident[1] + normal[2] * incident[2]\n\n    # Calculate reflection: R = I - 2(N·I)N\n    rx = incident[0] - 2.0 * dot * normal[0]\n    ry = incident[1] - 2.0 * dot * normal[1]\n    rz = incident[2] - 2.0 * dot * normal[2]\n\n    return (rx, ry, rz)\n\n# Test\nprint(reflect_ray((0.0, -1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Ray bouncing straight up"
      },
      {
        "input": "(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Ray parallel to surface"
      },
      {
        "input": "(0.7071, -0.7071, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.7071, 0.7071, 0.0)",
        "isHidden": true,
        "description": "45 degree incident angle"
      }
    ],
    "hints": [
      "Use the formula R = I - 2(N·I)N",
      "First calculate the dot product between normal and incident",
      "Then subtract 2 * (N·I) * N from the incident vector",
      "The result is already normalized if inputs are normalized"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex06",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Calculate Refraction Vector",
    "difficulty": 3,
    "description": "Calculate the refraction vector using Snell's law. This is used for transparent materials like glass and water.",
    "starterCode": "import math\n\ndef refract_ray(incident, normal, eta_ratio):\n    \"\"\"\n    Calculate refraction vector using Snell's law.\n\n    Args:\n        incident: tuple (x, y, z), normalized incident direction\n        normal: tuple (x, y, z), normalized surface normal\n        eta_ratio: float, ratio of refractive indices (n1/n2)\n\n    Returns:\n        tuple (x, y, z) or None, refracted direction (None if total internal reflection)\n\n    Notes:\n        Snell's law: n1*sin(θ1) = n2*sin(θ2)\n        eta_ratio = n1/n2\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(refract_ray((0.0, -1.0, 0.0), (0.0, 1.0, 0.0), 1.0/1.5))",
    "solution": "import math\n\ndef refract_ray(incident, normal, eta_ratio):\n    \"\"\"\n    Calculate refraction vector using Snell's law.\n\n    Args:\n        incident: tuple (x, y, z), normalized incident direction\n        normal: tuple (x, y, z), normalized surface normal\n        eta_ratio: float, ratio of refractive indices (n1/n2)\n\n    Returns:\n        tuple (x, y, z) or None, refracted direction (None if total internal reflection)\n\n    Notes:\n        Snell's law: n1*sin(θ1) = n2*sin(θ2)\n        eta_ratio = n1/n2\n    \"\"\"\n    # Calculate cos(θ1) = -N·I\n    cos_i = -(normal[0]*incident[0] + normal[1]*incident[1] + normal[2]*incident[2])\n\n    # Calculate sin²(θ2) using Snell's law\n    sin2_t = eta_ratio * eta_ratio * (1.0 - cos_i * cos_i)\n\n    # Check for total internal reflection\n    if sin2_t > 1.0:\n        return None\n\n    # Calculate cos(θ2)\n    cos_t = math.sqrt(1.0 - sin2_t)\n\n    # Calculate refracted direction\n    # T = eta * I + (eta * cos_i - cos_t) * N\n    factor = eta_ratio * cos_i - cos_t\n\n    tx = eta_ratio * incident[0] + factor * normal[0]\n    ty = eta_ratio * incident[1] + factor * normal[1]\n    tz = eta_ratio * incident[2] + factor * normal[2]\n\n    return (tx, ty, tz)\n\n# Test\nprint(refract_ray((0.0, -1.0, 0.0), (0.0, 1.0, 0.0), 1.0/1.5))",
    "testCases": [
      {
        "input": "(0.0, -1.0, 0.0), (0.0, 1.0, 0.0), 1.0/1.5",
        "expectedOutput": "(0.0, -1.0, 0.0)",
        "isHidden": false,
        "description": "Normal incidence (straight through)"
      },
      {
        "input": "(0.7071, -0.7071, 0.0), (0.0, 1.0, 0.0), 1.0/1.5",
        "expectedOutput": "(0.47140452079103173, -0.8819171036881969, 0.0)",
        "isHidden": false,
        "description": "45 degree incidence into glass"
      },
      {
        "input": "(0.7071, -0.7071, 0.0), (0.0, 1.0, 0.0), 1.5",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Total internal reflection"
      }
    ],
    "hints": [
      "Calculate cos(θ1) = -N·I (negative because we want angle between vectors)",
      "Use Snell's law to find sin²(θ2) = (n1/n2)² * (1 - cos²(θ1))",
      "If sin²(θ2) > 1, total internal reflection occurs (return None)",
      "Calculate cos(θ2) = sqrt(1 - sin²(θ2))",
      "Refracted direction: T = η*I + (η*cos_i - cos_t)*N",
      "where η is the ratio of refractive indices"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex07",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Ray-Triangle Intersection",
    "difficulty": 4,
    "description": "Implement the Möller-Trumbore algorithm for ray-triangle intersection. This is faster than calculating the plane intersection and checking if point is inside triangle.",
    "starterCode": "def ray_triangle_intersection(ray_origin, ray_dir, v0, v1, v2):\n    \"\"\"\n    Calculate ray-triangle intersection using Möller-Trumbore algorithm.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        v0, v1, v2: tuples (x, y, z), triangle vertices\n\n    Returns:\n        float or None, distance to intersection (None if no hit)\n\n    Notes:\n        Also computes barycentric coordinates u, v\n        Point is inside triangle if u >= 0, v >= 0, u+v <= 1\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(ray_triangle_intersection(\n    (0.0, 0.0, 5.0), (0.0, 0.0, -1.0),\n    (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)\n))",
    "solution": "def ray_triangle_intersection(ray_origin, ray_dir, v0, v1, v2):\n    \"\"\"\n    Calculate ray-triangle intersection using Möller-Trumbore algorithm.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        v0, v1, v2: tuples (x, y, z), triangle vertices\n\n    Returns:\n        float or None, distance to intersection (None if no hit)\n\n    Notes:\n        Also computes barycentric coordinates u, v\n        Point is inside triangle if u >= 0, v >= 0, u+v <= 1\n    \"\"\"\n    EPSILON = 0.0000001\n\n    # Calculate edge vectors\n    edge1_x = v1[0] - v0[0]\n    edge1_y = v1[1] - v0[1]\n    edge1_z = v1[2] - v0[2]\n\n    edge2_x = v2[0] - v0[0]\n    edge2_y = v2[1] - v0[1]\n    edge2_z = v2[2] - v0[2]\n\n    # Calculate h = ray_dir × edge2\n    h_x = ray_dir[1] * edge2_z - ray_dir[2] * edge2_y\n    h_y = ray_dir[2] * edge2_x - ray_dir[0] * edge2_z\n    h_z = ray_dir[0] * edge2_y - ray_dir[1] * edge2_x\n\n    # Calculate a = edge1 · h\n    a = edge1_x * h_x + edge1_y * h_y + edge1_z * h_z\n\n    # Ray is parallel to triangle if a is close to 0\n    if abs(a) < EPSILON:\n        return None\n\n    f = 1.0 / a\n\n    # Calculate s = ray_origin - v0\n    s_x = ray_origin[0] - v0[0]\n    s_y = ray_origin[1] - v0[1]\n    s_z = ray_origin[2] - v0[2]\n\n    # Calculate u = f * (s · h)\n    u = f * (s_x * h_x + s_y * h_y + s_z * h_z)\n\n    # Check if intersection is outside triangle\n    if u < 0.0 or u > 1.0:\n        return None\n\n    # Calculate q = s × edge1\n    q_x = s_y * edge1_z - s_z * edge1_y\n    q_y = s_z * edge1_x - s_x * edge1_z\n    q_z = s_x * edge1_y - s_y * edge1_x\n\n    # Calculate v = f * (ray_dir · q)\n    v = f * (ray_dir[0] * q_x + ray_dir[1] * q_y + ray_dir[2] * q_z)\n\n    # Check if intersection is outside triangle\n    if v < 0.0 or u + v > 1.0:\n        return None\n\n    # Calculate t = f * (edge2 · q)\n    t = f * (edge2_x * q_x + edge2_y * q_y + edge2_z * q_z)\n\n    # Check if intersection is in front of ray\n    if t > EPSILON:\n        return t\n    else:\n        return None\n\n# Test\nprint(ray_triangle_intersection(\n    (0.0, 0.0, 5.0), (0.0, 0.0, -1.0),\n    (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)\n))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 5.0), (0.0, 0.0, -1.0), (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Ray hits center of triangle"
      },
      {
        "input": "(0.0, 0.0, 5.0), (0.0, 0.0, -1.0), (2.0, 2.0, 0.0), (3.0, 2.0, 0.0), (2.5, 3.0, 0.0)",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Ray misses triangle"
      },
      {
        "input": "(0.5, -0.5, 5.0), (0.0, 0.0, -1.0), (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "5.0",
        "isHidden": true,
        "description": "Ray hits triangle off-center"
      }
    ],
    "hints": [
      "Calculate edge vectors: edge1 = v1 - v0, edge2 = v2 - v0",
      "Compute h = ray_dir × edge2",
      "Calculate a = edge1 · h (determinant)",
      "If a is near zero, ray is parallel to triangle",
      "Compute barycentric coordinate u using s = origin - v0",
      "Check u bounds: must be in [0, 1]",
      "Compute barycentric coordinate v using cross product",
      "Check v bounds and u+v <= 1 for point to be inside triangle",
      "Finally calculate t for the intersection distance"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex08",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Simple Ray Tracer with Sphere",
    "difficulty": 3,
    "description": "Implement a simple ray tracer that renders a single sphere with diffuse shading. For each pixel, cast a ray and check for sphere intersection.",
    "starterCode": "import math\n\ndef simple_ray_trace_sphere(width, height, sphere_center, sphere_radius,\n                            light_dir, sphere_color):\n    \"\"\"\n    Render a sphere using ray tracing with diffuse shading.\n\n    Args:\n        width, height: int, image dimensions\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n        light_dir: tuple (x, y, z), normalized light direction\n        sphere_color: tuple (r, g, b)\n\n    Returns:\n        2D list of (r, g, b) tuples representing the image\n\n    Notes:\n        - Camera at origin looking down -Z\n        - FOV = 60 degrees\n        - Background color is black (0, 0, 0)\n    \"\"\"\n    # Your code here\n    pass\n\n# Test (small image)\nresult = simple_ray_trace_sphere(4, 4, (0.0, 0.0, -5.0), 1.0,\n                                  (0.0, 0.0, 1.0), (1.0, 0.5, 0.3))\nprint(result[2][2])  # Center pixel",
    "solution": "import math\n\ndef simple_ray_trace_sphere(width, height, sphere_center, sphere_radius,\n                            light_dir, sphere_color):\n    \"\"\"\n    Render a sphere using ray tracing with diffuse shading.\n\n    Args:\n        width, height: int, image dimensions\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n        light_dir: tuple (x, y, z), normalized light direction\n        sphere_color: tuple (r, g, b)\n\n    Returns:\n        2D list of (r, g, b) tuples representing the image\n\n    Notes:\n        - Camera at origin looking down -Z\n        - FOV = 60 degrees\n        - Background color is black (0, 0, 0)\n    \"\"\"\n    image = []\n    fov = 60.0\n    camera_pos = (0.0, 0.0, 0.0)\n\n    for y in range(height):\n        row = []\n        for x in range(width):\n            # Generate ray\n            ndc_x = (2.0 * x / width) - 1.0\n            ndc_y = 1.0 - (2.0 * y / height)\n            aspect = width / height\n            scale = math.tan(math.radians(fov / 2.0))\n\n            ray_x = ndc_x * aspect * scale\n            ray_y = ndc_y * scale\n            ray_z = -1.0\n\n            magnitude = math.sqrt(ray_x**2 + ray_y**2 + ray_z**2)\n            ray_dir = (ray_x/magnitude, ray_y/magnitude, ray_z/magnitude)\n\n            # Ray-sphere intersection\n            oc_x = camera_pos[0] - sphere_center[0]\n            oc_y = camera_pos[1] - sphere_center[1]\n            oc_z = camera_pos[2] - sphere_center[2]\n\n            a = 1.0  # ray_dir is normalized\n            b = 2.0 * (ray_dir[0]*oc_x + ray_dir[1]*oc_y + ray_dir[2]*oc_z)\n            c = oc_x**2 + oc_y**2 + oc_z**2 - sphere_radius**2\n\n            discriminant = b*b - 4*a*c\n\n            if discriminant < 0:\n                # No hit - black background\n                row.append((0.0, 0.0, 0.0))\n            else:\n                # Hit - calculate shading\n                t = (-b - math.sqrt(discriminant)) / (2*a)\n\n                # Hit point\n                hit_x = camera_pos[0] + t * ray_dir[0]\n                hit_y = camera_pos[1] + t * ray_dir[1]\n                hit_z = camera_pos[2] + t * ray_dir[2]\n\n                # Normal at hit point\n                normal_x = hit_x - sphere_center[0]\n                normal_y = hit_y - sphere_center[1]\n                normal_z = hit_z - sphere_center[2]\n                normal_mag = math.sqrt(normal_x**2 + normal_y**2 + normal_z**2)\n                normal = (normal_x/normal_mag, normal_y/normal_mag, normal_z/normal_mag)\n\n                # Diffuse shading\n                n_dot_l = max(0.0, normal[0]*light_dir[0] + normal[1]*light_dir[1] + normal[2]*light_dir[2])\n\n                color = (sphere_color[0] * n_dot_l,\n                        sphere_color[1] * n_dot_l,\n                        sphere_color[2] * n_dot_l)\n                row.append(color)\n\n        image.append(row)\n\n    return image\n\n# Test (small image)\nresult = simple_ray_trace_sphere(4, 4, (0.0, 0.0, -5.0), 1.0,\n                                  (0.0, 0.0, 1.0), (1.0, 0.5, 0.3))\nprint(result[2][2])  # Center pixel",
    "testCases": [
      {
        "input": "4, 4, (0.0, 0.0, -5.0), 1.0, (0.0, 0.0, 1.0), (1.0, 0.5, 0.3)",
        "expectedOutput": "(1.0, 0.5, 0.3)",
        "isHidden": false,
        "description": "Center pixel hits sphere directly"
      },
      {
        "input": "2, 2, (0.0, 0.0, -5.0), 1.0, (0.0, 0.0, 1.0), (0.8, 0.8, 0.8)",
        "expectedOutput": "(0.8, 0.8, 0.8)",
        "isHidden": false,
        "description": "Small gray sphere"
      },
      {
        "input": "3, 3, (0.0, 0.0, -3.0), 0.5, (0.7071, 0.0, 0.7071), (1.0, 0.0, 0.0)",
        "expectedOutput": "(0.7071067811865476, 0.0, 0.0)",
        "isHidden": true,
        "description": "Red sphere with angled light"
      }
    ],
    "hints": [
      "For each pixel, generate a camera ray",
      "Test ray-sphere intersection using the quadratic formula",
      "If hit, calculate the intersection point",
      "Calculate the surface normal at the hit point",
      "Apply diffuse shading: color * max(0, N·L)",
      "If no hit, use background color (black)",
      "Camera is at origin looking down -Z axis"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex09",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Ray Tracing with Shadows",
    "difficulty": 4,
    "description": "Extend ray tracing to include shadow rays. Cast a ray from hit point to light source to check if point is in shadow.",
    "starterCode": "import math\n\ndef trace_with_shadows(ray_origin, ray_dir, sphere_center, sphere_radius,\n                       light_pos, sphere_color, ambient):\n    \"\"\"\n    Trace a ray and calculate color with shadows.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n        light_pos: tuple (x, y, z), point light position\n        sphere_color: tuple (r, g, b)\n        ambient: float, ambient light intensity (0-1)\n\n    Returns:\n        tuple (r, g, b) or None if no hit\n\n    Notes:\n        - Check if hit point can see the light (shadow ray)\n        - If in shadow, only ambient lighting\n        - If lit, ambient + diffuse\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(trace_with_shadows((0.0, 0.0, 0.0), (0.0, 0.0, -1.0),\n                         (0.0, 0.0, -5.0), 1.0, (2.0, 2.0, 0.0),\n                         (1.0, 0.5, 0.3), 0.2))",
    "solution": "import math\n\ndef trace_with_shadows(ray_origin, ray_dir, sphere_center, sphere_radius,\n                       light_pos, sphere_color, ambient):\n    \"\"\"\n    Trace a ray and calculate color with shadows.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n        light_pos: tuple (x, y, z), point light position\n        sphere_color: tuple (r, g, b)\n        ambient: float, ambient light intensity (0-1)\n\n    Returns:\n        tuple (r, g, b) or None if no hit\n\n    Notes:\n        - Check if hit point can see the light (shadow ray)\n        - If in shadow, only ambient lighting\n        - If lit, ambient + diffuse\n    \"\"\"\n    # Ray-sphere intersection\n    oc_x = ray_origin[0] - sphere_center[0]\n    oc_y = ray_origin[1] - sphere_center[1]\n    oc_z = ray_origin[2] - sphere_center[2]\n\n    a = 1.0\n    b = 2.0 * (ray_dir[0]*oc_x + ray_dir[1]*oc_y + ray_dir[2]*oc_z)\n    c = oc_x**2 + oc_y**2 + oc_z**2 - sphere_radius**2\n\n    discriminant = b*b - 4*a*c\n\n    if discriminant < 0:\n        return None  # No hit\n\n    # Calculate hit point\n    t = (-b - math.sqrt(discriminant)) / (2*a)\n    hit_x = ray_origin[0] + t * ray_dir[0]\n    hit_y = ray_origin[1] + t * ray_dir[1]\n    hit_z = ray_origin[2] + t * ray_dir[2]\n\n    # Calculate normal\n    normal_x = hit_x - sphere_center[0]\n    normal_y = hit_y - sphere_center[1]\n    normal_z = hit_z - sphere_center[2]\n    normal_mag = math.sqrt(normal_x**2 + normal_y**2 + normal_z**2)\n    normal = (normal_x/normal_mag, normal_y/normal_mag, normal_z/normal_mag)\n\n    # Calculate direction to light\n    to_light_x = light_pos[0] - hit_x\n    to_light_y = light_pos[1] - hit_y\n    to_light_z = light_pos[2] - hit_z\n    light_dist = math.sqrt(to_light_x**2 + to_light_y**2 + to_light_z**2)\n    light_dir = (to_light_x/light_dist, to_light_y/light_dist, to_light_z/light_dist)\n\n    # Shadow ray - offset slightly to avoid self-intersection\n    shadow_origin = (hit_x + normal[0]*0.001,\n                     hit_y + normal[1]*0.001,\n                     hit_z + normal[2]*0.001)\n\n    # Check shadow ray intersection\n    oc_x = shadow_origin[0] - sphere_center[0]\n    oc_y = shadow_origin[1] - sphere_center[1]\n    oc_z = shadow_origin[2] - sphere_center[2]\n\n    a = 1.0\n    b = 2.0 * (light_dir[0]*oc_x + light_dir[1]*oc_y + light_dir[2]*oc_z)\n    c = oc_x**2 + oc_y**2 + oc_z**2 - sphere_radius**2\n\n    shadow_discriminant = b*b - 4*a*c\n\n    # Check if shadow ray hits sphere before reaching light\n    in_shadow = False\n    if shadow_discriminant >= 0:\n        shadow_t = (-b - math.sqrt(shadow_discriminant)) / (2*a)\n        if shadow_t > 0.001 and shadow_t < light_dist:\n            in_shadow = True\n\n    # Calculate lighting\n    if in_shadow:\n        # Only ambient\n        color = (sphere_color[0] * ambient,\n                sphere_color[1] * ambient,\n                sphere_color[2] * ambient)\n    else:\n        # Ambient + diffuse\n        n_dot_l = max(0.0, normal[0]*light_dir[0] + normal[1]*light_dir[1] + normal[2]*light_dir[2])\n        color = (sphere_color[0] * (ambient + n_dot_l),\n                sphere_color[1] * (ambient + n_dot_l),\n                sphere_color[2] * (ambient + n_dot_l))\n\n    return color\n\n# Test\nprint(trace_with_shadows((0.0, 0.0, 0.0), (0.0, 0.0, -1.0),\n                         (0.0, 0.0, -5.0), 1.0, (2.0, 2.0, 0.0),\n                         (1.0, 0.5, 0.3), 0.2))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0, (2.0, 2.0, 0.0), (1.0, 0.5, 0.3), 0.2",
        "expectedOutput": "(0.6832050294337844, 0.3416025147168922, 0.20496150883013532)",
        "isHidden": false,
        "description": "Lit sphere (not in shadow)"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -10.0), 2.0, (0.0, 0.0, -5.0), (1.0, 1.0, 1.0), 0.1",
        "expectedOutput": "(0.1, 0.1, 0.1)",
        "isHidden": false,
        "description": "Point in shadow (light blocked)"
      },
      {
        "input": "(0.0, 2.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 0.0), 1.0, (3.0, 3.0, 0.0), (0.8, 0.2, 0.2), 0.15",
        "expectedOutput": "(0.6309039081630266, 0.15772597704075666, 0.15772597704075666)",
        "isHidden": true,
        "description": "Downward ray with offset light"
      }
    ],
    "hints": [
      "First, perform ray-sphere intersection to find hit point",
      "Calculate the surface normal at hit point",
      "Calculate direction from hit point to light source",
      "Cast a shadow ray from hit point (slightly offset) toward light",
      "Check if shadow ray intersects sphere before reaching light",
      "If in shadow, use only ambient lighting",
      "If not in shadow, use ambient + diffuse",
      "Offset the shadow ray origin slightly to avoid self-intersection"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex10",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Ray Tracing with Reflections",
    "difficulty": 4,
    "description": "Implement recursive ray tracing with mirror reflections. When a ray hits a reflective surface, cast a reflection ray and blend the colors.",
    "starterCode": "import math\n\ndef trace_reflection(ray_origin, ray_dir, sphere_center, sphere_radius,\n                    light_dir, sphere_color, reflectivity, depth, max_depth):\n    \"\"\"\n    Trace ray with reflections (recursive).\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n        light_dir: tuple (x, y, z), normalized light direction\n        sphere_color: tuple (r, g, b)\n        reflectivity: float (0-1), how reflective the sphere is\n        depth: int, current recursion depth\n        max_depth: int, maximum recursion depth\n\n    Returns:\n        tuple (r, g, b), final color (black if no hit)\n\n    Notes:\n        - Base case: depth >= max_depth, return diffuse only\n        - Recursive case: blend diffuse with reflected color\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(trace_reflection((0.0, 0.0, 0.0), (0.0, 0.0, -1.0),\n                       (0.0, 0.0, -5.0), 1.0, (0.0, 1.0, 0.0),\n                       (1.0, 0.5, 0.3), 0.5, 0, 2))",
    "solution": "import math\n\ndef trace_reflection(ray_origin, ray_dir, sphere_center, sphere_radius,\n                    light_dir, sphere_color, reflectivity, depth, max_depth):\n    \"\"\"\n    Trace ray with reflections (recursive).\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        sphere_center: tuple (x, y, z)\n        sphere_radius: float\n        light_dir: tuple (x, y, z), normalized light direction\n        sphere_color: tuple (r, g, b)\n        reflectivity: float (0-1), how reflective the sphere is\n        depth: int, current recursion depth\n        max_depth: int, maximum recursion depth\n\n    Returns:\n        tuple (r, g, b), final color (black if no hit)\n\n    Notes:\n        - Base case: depth >= max_depth, return diffuse only\n        - Recursive case: blend diffuse with reflected color\n    \"\"\"\n    # Ray-sphere intersection\n    oc_x = ray_origin[0] - sphere_center[0]\n    oc_y = ray_origin[1] - sphere_center[1]\n    oc_z = ray_origin[2] - sphere_center[2]\n\n    a = 1.0\n    b = 2.0 * (ray_dir[0]*oc_x + ray_dir[1]*oc_y + ray_dir[2]*oc_z)\n    c = oc_x**2 + oc_y**2 + oc_z**2 - sphere_radius**2\n\n    discriminant = b*b - 4*a*c\n\n    if discriminant < 0:\n        return (0.0, 0.0, 0.0)  # No hit - black background\n\n    # Calculate hit point\n    t = (-b - math.sqrt(discriminant)) / (2*a)\n    if t < 0.001:\n        return (0.0, 0.0, 0.0)\n\n    hit_x = ray_origin[0] + t * ray_dir[0]\n    hit_y = ray_origin[1] + t * ray_dir[1]\n    hit_z = ray_origin[2] + t * ray_dir[2]\n\n    # Calculate normal\n    normal_x = hit_x - sphere_center[0]\n    normal_y = hit_y - sphere_center[1]\n    normal_z = hit_z - sphere_center[2]\n    normal_mag = math.sqrt(normal_x**2 + normal_y**2 + normal_z**2)\n    normal = (normal_x/normal_mag, normal_y/normal_mag, normal_z/normal_mag)\n\n    # Calculate diffuse shading\n    n_dot_l = max(0.0, normal[0]*light_dir[0] + normal[1]*light_dir[1] + normal[2]*light_dir[2])\n    diffuse = (sphere_color[0] * n_dot_l,\n               sphere_color[1] * n_dot_l,\n               sphere_color[2] * n_dot_l)\n\n    # Base case: max depth reached\n    if depth >= max_depth:\n        return diffuse\n\n    # Calculate reflection direction\n    dot = normal[0]*ray_dir[0] + normal[1]*ray_dir[1] + normal[2]*ray_dir[2]\n    reflect_dir = (ray_dir[0] - 2.0*dot*normal[0],\n                   ray_dir[1] - 2.0*dot*normal[1],\n                   ray_dir[2] - 2.0*dot*normal[2])\n\n    # Offset reflection origin to avoid self-intersection\n    reflect_origin = (hit_x + normal[0]*0.001,\n                      hit_y + normal[1]*0.001,\n                      hit_z + normal[2]*0.001)\n\n    # Recursive ray trace\n    reflected_color = trace_reflection(reflect_origin, reflect_dir,\n                                       sphere_center, sphere_radius,\n                                       light_dir, sphere_color,\n                                       reflectivity, depth + 1, max_depth)\n\n    # Blend diffuse and reflected color\n    final_r = diffuse[0] * (1 - reflectivity) + reflected_color[0] * reflectivity\n    final_g = diffuse[1] * (1 - reflectivity) + reflected_color[1] * reflectivity\n    final_b = diffuse[2] * (1 - reflectivity) + reflected_color[2] * reflectivity\n\n    return (final_r, final_g, final_b)\n\n# Test\nprint(trace_reflection((0.0, 0.0, 0.0), (0.0, 0.0, -1.0),\n                       (0.0, 0.0, -5.0), 1.0, (0.0, 1.0, 0.0),\n                       (1.0, 0.5, 0.3), 0.5, 0, 2))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0, (0.0, 1.0, 0.0), (1.0, 0.5, 0.3), 0.5, 0, 2",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Center hit with upward light (dark)"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0, (0.0, 0.0, 1.0), (1.0, 0.5, 0.3), 0.0, 0, 2",
        "expectedOutput": "(1.0, 0.5, 0.3)",
        "isHidden": false,
        "description": "No reflectivity (pure diffuse)"
      },
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (0.0, 0.0, -5.0), 1.0, (0.0, 0.0, 1.0), (0.8, 0.8, 0.8), 1.0, 0, 1",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": true,
        "description": "Fully reflective (no diffuse contribution)"
      }
    ],
    "hints": [
      "First perform ray-sphere intersection",
      "Calculate hit point and surface normal",
      "Calculate diffuse shading from direct lighting",
      "Check if max depth reached (base case)",
      "Calculate reflection direction using R = I - 2(N·I)N",
      "Recursively trace the reflected ray",
      "Blend diffuse and reflected color based on reflectivity",
      "Offset the reflection ray origin to avoid self-intersection",
      "Final color = diffuse*(1-r) + reflected*r, where r is reflectivity"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex11",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Axis-Aligned Bounding Box Intersection",
    "difficulty": 3,
    "description": "Implement ray-AABB (Axis-Aligned Bounding Box) intersection test. This is used for acceleration structures in ray tracing.",
    "starterCode": "def ray_aabb_intersection(ray_origin, ray_dir, box_min, box_max):\n    \"\"\"\n    Test ray intersection with axis-aligned bounding box.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        box_min: tuple (x, y, z), minimum corner of box\n        box_max: tuple (x, y, z), maximum corner of box\n\n    Returns:\n        tuple (t_near, t_far) or None if no intersection\n\n    Notes:\n        Use slab method: test intersection with each axis-aligned plane\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(ray_aabb_intersection((0.0, 0.0, 0.0), (0.0, 0.0, -1.0),\n                            (-1.0, -1.0, -5.0), (1.0, 1.0, -3.0)))",
    "solution": "def ray_aabb_intersection(ray_origin, ray_dir, box_min, box_max):\n    \"\"\"\n    Test ray intersection with axis-aligned bounding box.\n\n    Args:\n        ray_origin: tuple (x, y, z)\n        ray_dir: tuple (x, y, z), normalized\n        box_min: tuple (x, y, z), minimum corner of box\n        box_max: tuple (x, y, z), maximum corner of box\n\n    Returns:\n        tuple (t_near, t_far) or None if no intersection\n\n    Notes:\n        Use slab method: test intersection with each axis-aligned plane\n    \"\"\"\n    t_min = float('-inf')\n    t_max = float('inf')\n\n    # Test intersection with each slab (X, Y, Z)\n    for i in range(3):\n        if abs(ray_dir[i]) < 0.0001:\n            # Ray is parallel to slab\n            if ray_origin[i] < box_min[i] or ray_origin[i] > box_max[i]:\n                return None  # Ray is outside slab, no intersection\n        else:\n            # Calculate intersection distances with slab planes\n            t1 = (box_min[i] - ray_origin[i]) / ray_dir[i]\n            t2 = (box_max[i] - ray_origin[i]) / ray_dir[i]\n\n            # Ensure t1 <= t2\n            if t1 > t2:\n                t1, t2 = t2, t1\n\n            # Update t_min and t_max\n            t_min = max(t_min, t1)\n            t_max = min(t_max, t2)\n\n            # Check if slabs don't overlap\n            if t_min > t_max:\n                return None\n\n    # Check if intersection is behind ray origin\n    if t_max < 0:\n        return None\n\n    # Return intersection range\n    if t_min < 0:\n        t_min = 0  # Ray origin is inside box\n\n    return (t_min, t_max)\n\n# Test\nprint(ray_aabb_intersection((0.0, 0.0, 0.0), (0.0, 0.0, -1.0),\n                            (-1.0, -1.0, -5.0), (1.0, 1.0, -3.0)))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (0.0, 0.0, -1.0), (-1.0, -1.0, -5.0), (1.0, 1.0, -3.0)",
        "expectedOutput": "(3.0, 5.0)",
        "isHidden": false,
        "description": "Ray hits box from front"
      },
      {
        "input": "(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)",
        "expectedOutput": "(0, 1.0)",
        "isHidden": false,
        "description": "Ray starts inside box"
      },
      {
        "input": "(5.0, 0.0, 0.0), (0.0, 1.0, 0.0), (-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Ray misses box"
      }
    ],
    "hints": [
      "Use the \"slab method\" - test each axis independently",
      "For each axis, calculate t values where ray intersects the two planes",
      "Keep track of the maximum of all entry points (t_min)",
      "Keep track of the minimum of all exit points (t_max)",
      "If t_min > t_max, the ray misses the box",
      "Handle the case where ray is parallel to an axis (division by zero)",
      "If ray origin is inside box, t_min should be 0"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex12",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Barycentric Coordinates",
    "difficulty": 3,
    "description": "Calculate barycentric coordinates for a point on a triangle. These coordinates are used for interpolating vertex attributes.",
    "starterCode": "def barycentric_coordinates(point, v0, v1, v2):\n    \"\"\"\n    Calculate barycentric coordinates of a point on a triangle.\n\n    Args:\n        point: tuple (x, y, z), point on triangle\n        v0, v1, v2: tuples (x, y, z), triangle vertices\n\n    Returns:\n        tuple (u, v, w) where u + v + w = 1\n\n    Notes:\n        u corresponds to v0, v corresponds to v1, w corresponds to v2\n        Point = u*v0 + v*v1 + w*v2\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(barycentric_coordinates((0.0, 0.0, 0.0),\n                              (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)))",
    "solution": "def barycentric_coordinates(point, v0, v1, v2):\n    \"\"\"\n    Calculate barycentric coordinates of a point on a triangle.\n\n    Args:\n        point: tuple (x, y, z), point on triangle\n        v0, v1, v2: tuples (x, y, z), triangle vertices\n\n    Returns:\n        tuple (u, v, w) where u + v + w = 1\n\n    Notes:\n        u corresponds to v0, v corresponds to v1, w corresponds to v2\n        Point = u*v0 + v*v1 + w*v2\n    \"\"\"\n    # Vectors from v0 to v1 and v2\n    v0v1_x = v1[0] - v0[0]\n    v0v1_y = v1[1] - v0[1]\n    v0v1_z = v1[2] - v0[2]\n\n    v0v2_x = v2[0] - v0[0]\n    v0v2_y = v2[1] - v0[1]\n    v0v2_z = v2[2] - v0[2]\n\n    # Vector from v0 to point\n    v0p_x = point[0] - v0[0]\n    v0p_y = point[1] - v0[1]\n    v0p_z = point[2] - v0[2]\n\n    # Calculate dot products\n    d00 = v0v1_x*v0v1_x + v0v1_y*v0v1_y + v0v1_z*v0v1_z\n    d01 = v0v1_x*v0v2_x + v0v1_y*v0v2_y + v0v1_z*v0v2_z\n    d11 = v0v2_x*v0v2_x + v0v2_y*v0v2_y + v0v2_z*v0v2_z\n    d20 = v0p_x*v0v1_x + v0p_y*v0v1_y + v0p_z*v0v1_z\n    d21 = v0p_x*v0v2_x + v0p_y*v0v2_y + v0p_z*v0v2_z\n\n    # Calculate barycentric coordinates\n    denom = d00 * d11 - d01 * d01\n\n    if abs(denom) < 0.0001:\n        # Degenerate triangle\n        return (1.0, 0.0, 0.0)\n\n    v = (d11 * d20 - d01 * d21) / denom\n    w = (d00 * d21 - d01 * d20) / denom\n    u = 1.0 - v - w\n\n    return (u, v, w)\n\n# Test\nprint(barycentric_coordinates((0.0, 0.0, 0.0),\n                              (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)))",
    "testCases": [
      {
        "input": "(0.0, 0.0, 0.0), (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.25, 0.25, 0.5)",
        "isHidden": false,
        "description": "Point at center of triangle"
      },
      {
        "input": "(-1.0, -1.0, 0.0), (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Point at vertex v0"
      },
      {
        "input": "(0.0, -1.0, 0.0), (-1.0, -1.0, 0.0), (1.0, -1.0, 0.0), (0.0, 1.0, 0.0)",
        "expectedOutput": "(0.5, 0.5, 0.0)",
        "isHidden": true,
        "description": "Point on edge between v0 and v1"
      }
    ],
    "hints": [
      "Calculate vectors from v0 to v1, v2, and the point",
      "Use dot products to set up a linear system",
      "Solve for coordinates v and w using Cramer's rule",
      "Calculate u = 1 - v - w",
      "The barycentric coordinates represent weights for each vertex",
      "If point is at vertex i, coordinate i should be 1 and others 0"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex13",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Interpolate Triangle Attributes",
    "difficulty": 3,
    "description": "Interpolate vertex attributes (like normals or UV coordinates) across a triangle using barycentric coordinates.",
    "starterCode": "def interpolate_attribute(bary_coords, attr0, attr1, attr2):\n    \"\"\"\n    Interpolate vertex attributes using barycentric coordinates.\n\n    Args:\n        bary_coords: tuple (u, v, w), barycentric coordinates\n        attr0, attr1, attr2: attribute values at vertices (can be float or tuple)\n\n    Returns:\n        Interpolated attribute value (same type as input attributes)\n\n    Notes:\n        result = u*attr0 + v*attr1 + w*attr2\n    \"\"\"\n    # Your code here\n    pass\n\n# Test with tuple attributes (RGB color)\nprint(interpolate_attribute((0.5, 0.25, 0.25),\n                            (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)))",
    "solution": "def interpolate_attribute(bary_coords, attr0, attr1, attr2):\n    \"\"\"\n    Interpolate vertex attributes using barycentric coordinates.\n\n    Args:\n        bary_coords: tuple (u, v, w), barycentric coordinates\n        attr0, attr1, attr2: attribute values at vertices (can be float or tuple)\n\n    Returns:\n        Interpolated attribute value (same type as input attributes)\n\n    Notes:\n        result = u*attr0 + v*attr1 + w*attr2\n    \"\"\"\n    u, v, w = bary_coords\n\n    # Check if attributes are tuples (e.g., colors, normals)\n    if isinstance(attr0, tuple):\n        # Interpolate each component\n        result = []\n        for i in range(len(attr0)):\n            interpolated = u * attr0[i] + v * attr1[i] + w * attr2[i]\n            result.append(interpolated)\n        return tuple(result)\n    else:\n        # Scalar attribute (e.g., depth)\n        return u * attr0 + v * attr1 + w * attr2\n\n# Test with tuple attributes (RGB color)\nprint(interpolate_attribute((0.5, 0.25, 0.25),\n                            (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)))",
    "testCases": [
      {
        "input": "(0.5, 0.25, 0.25), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)",
        "expectedOutput": "(0.5, 0.25, 0.25)",
        "isHidden": false,
        "description": "Interpolate RGB colors"
      },
      {
        "input": "(1.0, 0.0, 0.0), 10.0, 20.0, 30.0",
        "expectedOutput": "10.0",
        "isHidden": false,
        "description": "Interpolate scalar at vertex"
      },
      {
        "input": "(0.333, 0.333, 0.334), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)",
        "expectedOutput": "(0.333, 0.333, 0.334)",
        "isHidden": true,
        "description": "Interpolate at triangle center"
      }
    ],
    "hints": [
      "Use the formula: result = u*attr0 + v*attr1 + w*attr2",
      "Check if attributes are tuples (multi-component like colors/normals)",
      "If tuple, interpolate each component separately",
      "If scalar (float), directly compute weighted sum",
      "Barycentric coordinates sum to 1, ensuring proper interpolation"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex14",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Fresnel Reflectance for Dielectrics",
    "difficulty": 4,
    "description": "Calculate the Fresnel reflectance using Schlick's approximation. This determines how much light is reflected vs refracted at a surface.",
    "starterCode": "import math\n\ndef fresnel_reflectance(cos_theta, eta_ratio):\n    \"\"\"\n    Calculate Fresnel reflectance using Schlick's approximation.\n\n    Args:\n        cos_theta: float, cosine of incident angle\n        eta_ratio: float, ratio of refractive indices (n1/n2)\n\n    Returns:\n        float, reflectance coefficient (0-1)\n\n    Notes:\n        R0 = ((n1-n2)/(n1+n2))²\n        R(θ) = R0 + (1-R0)(1-cos(θ))^5\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(fresnel_reflectance(1.0, 1.0/1.5))  # Normal incidence, air to glass",
    "solution": "import math\n\ndef fresnel_reflectance(cos_theta, eta_ratio):\n    \"\"\"\n    Calculate Fresnel reflectance using Schlick's approximation.\n\n    Args:\n        cos_theta: float, cosine of incident angle\n        eta_ratio: float, ratio of refractive indices (n1/n2)\n\n    Returns:\n        float, reflectance coefficient (0-1)\n\n    Notes:\n        R0 = ((n1-n2)/(n1+n2))²\n        R(θ) = R0 + (1-R0)(1-cos(θ))^5\n    \"\"\"\n    # Calculate R0 (reflectance at normal incidence)\n    # R0 = ((n1 - n2) / (n1 + n2))²\n    # Since eta_ratio = n1/n2, we can derive:\n    # R0 = ((1 - 1/eta_ratio) / (1 + 1/eta_ratio))²\n    r0 = ((1.0 - eta_ratio) / (1.0 + eta_ratio)) ** 2\n\n    # Ensure cos_theta is in valid range\n    cos_theta = max(0.0, min(1.0, cos_theta))\n\n    # Schlick's approximation\n    # R(θ) = R0 + (1 - R0)(1 - cos(θ))^5\n    one_minus_cos = 1.0 - cos_theta\n    reflectance = r0 + (1.0 - r0) * (one_minus_cos ** 5)\n\n    return reflectance\n\n# Test\nprint(fresnel_reflectance(1.0, 1.0/1.5))  # Normal incidence, air to glass",
    "testCases": [
      {
        "input": "1.0, 1.0/1.5",
        "expectedOutput": "0.04000000000000001",
        "isHidden": false,
        "description": "Normal incidence (perpendicular), air to glass"
      },
      {
        "input": "0.0, 1.0/1.5",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Grazing angle (parallel), total reflection"
      },
      {
        "input": "0.7071, 1.0/1.33",
        "expectedOutput": "0.02366158097839823",
        "isHidden": true,
        "description": "45 degree angle, air to water"
      }
    ],
    "hints": [
      "Calculate R0 using the formula ((1-η)/(1+η))²",
      "Compute (1 - cos(θ))^5",
      "Apply Schlick's formula: R0 + (1-R0)*(1-cos(θ))^5",
      "At normal incidence (cos=1), reflectance equals R0",
      "At grazing angles (cos=0), reflectance approaches 1",
      "This determines the blend between reflection and refraction"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex15",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Beer-Lambert Absorption",
    "difficulty": 4,
    "description": "Calculate light absorption through a transparent medium using Beer-Lambert law. This creates the colored tint when light passes through glass, water, etc.",
    "starterCode": "import math\n\ndef beer_lambert_absorption(distance, absorption_color):\n    \"\"\"\n    Calculate color absorption through a medium.\n\n    Args:\n        distance: float, distance traveled through medium\n        absorption_color: tuple (r, g, b), absorption coefficients per unit distance\n\n    Returns:\n        tuple (r, g, b), transmission color multiplier\n\n    Notes:\n        Transmission = e^(-absorption * distance)\n        Apply to each color channel independently\n    \"\"\"\n    # Your code here\n    pass\n\n# Test\nprint(beer_lambert_absorption(2.0, (0.1, 0.05, 0.02)))",
    "solution": "import math\n\ndef beer_lambert_absorption(distance, absorption_color):\n    \"\"\"\n    Calculate color absorption through a medium.\n\n    Args:\n        distance: float, distance traveled through medium\n        absorption_color: tuple (r, g, b), absorption coefficients per unit distance\n\n    Returns:\n        tuple (r, g, b), transmission color multiplier\n\n    Notes:\n        Transmission = e^(-absorption * distance)\n        Apply to each color channel independently\n    \"\"\"\n    # Apply Beer-Lambert law to each channel\n    # T = e^(-α * d)\n    transmission_r = math.exp(-absorption_color[0] * distance)\n    transmission_g = math.exp(-absorption_color[1] * distance)\n    transmission_b = math.exp(-absorption_color[2] * distance)\n\n    return (transmission_r, transmission_g, transmission_b)\n\n# Test\nprint(beer_lambert_absorption(2.0, (0.1, 0.05, 0.02)))",
    "testCases": [
      {
        "input": "2.0, (0.1, 0.05, 0.02)",
        "expectedOutput": "(0.8187307530779818, 0.9048374180359595, 0.9607894391523232)",
        "isHidden": false,
        "description": "Medium distance through colored glass"
      },
      {
        "input": "0.0, (0.5, 0.5, 0.5)",
        "expectedOutput": "(1.0, 1.0, 1.0)",
        "isHidden": false,
        "description": "Zero distance (no absorption)"
      },
      {
        "input": "5.0, (0.8, 0.1, 0.05)",
        "expectedOutput": "(0.01831563888873418, 0.6065306597126334, 0.7788007830714049)",
        "isHidden": true,
        "description": "Long distance, high red absorption (blue/green tint)"
      }
    ],
    "hints": [
      "Use the Beer-Lambert law: T = e^(-α*d)",
      "Apply the formula independently to each color channel",
      "Higher absorption coefficient = more absorption = less transmission",
      "Distance of 0 should give transmission of 1.0 (full transmission)",
      "Different absorption per channel creates colored glass effects",
      "Red glass has low absorption for red, high for blue and green"
    ],
    "language": "python"
  },
  {
    "id": "cs306-t7-ex16",
    "subjectId": "cs306",
    "topicId": "cs306-topic-7",
    "title": "Path Tracing Sample Ray",
    "difficulty": 5,
    "description": "Generate a random ray direction for path tracing using importance sampling. Sample the hemisphere around a surface normal weighted by cosine distribution.",
    "starterCode": "import math\nimport random\n\ndef sample_cosine_hemisphere(normal, random_u1, random_u2):\n    \"\"\"\n    Generate random direction in cosine-weighted hemisphere.\n\n    Args:\n        normal: tuple (x, y, z), normalized surface normal\n        random_u1, random_u2: float (0-1), random numbers\n\n    Returns:\n        tuple (x, y, z), random direction (normalized)\n\n    Notes:\n        Use Malley's method:\n        - Sample unit disk using random numbers\n        - Project up to hemisphere\n        - Transform from local to world space\n    \"\"\"\n    # Your code here\n    pass\n\n# Test with fixed random values\nprint(sample_cosine_hemisphere((0.0, 1.0, 0.0), 0.5, 0.5))",
    "solution": "import math\nimport random\n\ndef sample_cosine_hemisphere(normal, random_u1, random_u2):\n    \"\"\"\n    Generate random direction in cosine-weighted hemisphere.\n\n    Args:\n        normal: tuple (x, y, z), normalized surface normal\n        random_u1, random_u2: float (0-1), random numbers\n\n    Returns:\n        tuple (x, y, z), random direction (normalized)\n\n    Notes:\n        Use Malley's method:\n        - Sample unit disk using random numbers\n        - Project up to hemisphere\n        - Transform from local to world space\n    \"\"\"\n    # Sample point on unit disk using concentric mapping\n    theta = 2.0 * math.pi * random_u1\n    radius = math.sqrt(random_u2)\n\n    disk_x = radius * math.cos(theta)\n    disk_y = radius * math.sin(theta)\n\n    # Project to hemisphere (z = sqrt(1 - x² - y²))\n    local_z = math.sqrt(max(0.0, 1.0 - disk_x*disk_x - disk_y*disk_y))\n\n    # Local hemisphere coordinates (z is up)\n    local_dir = (disk_x, disk_y, local_z)\n\n    # Build tangent space basis from normal\n    # Find an axis that's not parallel to normal\n    if abs(normal[0]) > 0.9:\n        tangent = (0.0, 1.0, 0.0)\n    else:\n        tangent = (1.0, 0.0, 0.0)\n\n    # Bitangent = normal × tangent\n    bitangent_x = normal[1]*tangent[2] - normal[2]*tangent[1]\n    bitangent_y = normal[2]*tangent[0] - normal[0]*tangent[2]\n    bitangent_z = normal[0]*tangent[1] - normal[1]*tangent[0]\n\n    # Normalize bitangent\n    mag = math.sqrt(bitangent_x**2 + bitangent_y**2 + bitangent_z**2)\n    bitangent = (bitangent_x/mag, bitangent_y/mag, bitangent_z/mag)\n\n    # Tangent = bitangent × normal\n    tangent_x = bitangent[1]*normal[2] - bitangent[2]*normal[1]\n    tangent_y = bitangent[2]*normal[0] - bitangent[0]*normal[2]\n    tangent_z = bitangent[0]*normal[1] - bitangent[1]*normal[0]\n\n    # Transform local direction to world space\n    world_x = local_dir[0]*tangent_x + local_dir[1]*bitangent[0] + local_dir[2]*normal[0]\n    world_y = local_dir[0]*tangent_y + local_dir[1]*bitangent[1] + local_dir[2]*normal[1]\n    world_z = local_dir[0]*tangent_z + local_dir[1]*bitangent[2] + local_dir[2]*normal[2]\n\n    return (world_x, world_y, world_z)\n\n# Test with fixed random values\nprint(sample_cosine_hemisphere((0.0, 1.0, 0.0), 0.5, 0.5))",
    "testCases": [
      {
        "input": "(0.0, 1.0, 0.0), 0.5, 0.5",
        "expectedOutput": "(0.0, 0.7071067811865476, 0.7071067811865476)",
        "isHidden": false,
        "description": "Sample with normal pointing up"
      },
      {
        "input": "(0.0, 1.0, 0.0), 0.0, 0.0",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Center of distribution (straight up)"
      },
      {
        "input": "(1.0, 0.0, 0.0), 0.25, 0.5",
        "expectedOutput": "(0.7071067811865476, 0.0, 0.7071067811865476)",
        "isHidden": true,
        "description": "Normal pointing along X axis"
      }
    ],
    "hints": [
      "Use Malley's method: sample disk, then project to hemisphere",
      "Convert random values to polar coordinates: θ = 2πu₁, r = √u₂",
      "Disk point: (r*cos(θ), r*sin(θ))",
      "Hemisphere z = √(1 - x² - y²)",
      "Build tangent space basis (tangent, bitangent, normal)",
      "Transform local hemisphere coordinates to world space using TBN matrix",
      "Cosine weighting naturally occurs from disk-to-hemisphere projection",
      "This is used in path tracing for physically accurate light transport"
    ],
    "language": "python"
  }
]
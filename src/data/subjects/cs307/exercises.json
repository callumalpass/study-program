[
  {
    "id": "cs307-t1-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Calculate Risk Score",
    "difficulty": 1,
    "description": "Implement a function that calculates risk score using the formula: Risk = Likelihood × Impact. Both values range from 1-5.",
    "starterCode": "def calculate_risk(likelihood, impact):\n    \"\"\"\n    Calculate risk score from likelihood and impact values.\n\n    Args:\n        likelihood: Integer from 1-5 representing probability\n        impact: Integer from 1-5 representing severity\n\n    Returns:\n        Integer risk score\n    \"\"\"\n    pass",
    "solution": "def calculate_risk(likelihood, impact):\n    \"\"\"\n    Calculate risk score from likelihood and impact values.\n\n    Args:\n        likelihood: Integer from 1-5 representing probability\n        impact: Integer from 1-5 representing severity\n\n    Returns:\n        Integer risk score\n    \"\"\"\n    return likelihood * impact",
    "testCases": [
      {
        "input": "3, 4",
        "expectedOutput": "12",
        "isHidden": false,
        "description": "Medium likelihood, high impact"
      },
      {
        "input": "1, 1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Low likelihood, low impact"
      },
      {
        "input": "5, 5",
        "expectedOutput": "25",
        "isHidden": true,
        "description": "Critical risk"
      },
      {
        "input": "2, 3",
        "expectedOutput": "6",
        "isHidden": true,
        "description": "Low-medium risk"
      }
    ],
    "hints": [
      "Risk is simply the product of likelihood and impact",
      "No need to validate inputs for this exercise"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Risk Level Classification",
    "difficulty": 2,
    "description": "Classify risk scores into categories: Low (1-6), Medium (7-12), High (13-20), Critical (21-25).",
    "starterCode": "def classify_risk(risk_score):\n    \"\"\"\n    Classify a risk score into a risk level category.\n\n    Args:\n        risk_score: Integer from 1-25\n\n    Returns:\n        String: 'Low', 'Medium', 'High', or 'Critical'\n    \"\"\"\n    pass",
    "solution": "def classify_risk(risk_score):\n    \"\"\"\n    Classify a risk score into a risk level category.\n\n    Args:\n        risk_score: Integer from 1-25\n\n    Returns:\n        String: 'Low', 'Medium', 'High', or 'Critical'\n    \"\"\"\n    if risk_score <= 6:\n        return 'Low'\n    elif risk_score <= 12:\n        return 'Medium'\n    elif risk_score <= 20:\n        return 'High'\n    else:\n        return 'Critical'",
    "testCases": [
      {
        "input": "4",
        "expectedOutput": "Low",
        "isHidden": false,
        "description": "Low risk score"
      },
      {
        "input": "10",
        "expectedOutput": "Medium",
        "isHidden": false,
        "description": "Medium risk score"
      },
      {
        "input": "15",
        "expectedOutput": "High",
        "isHidden": false,
        "description": "High risk score"
      },
      {
        "input": "25",
        "expectedOutput": "Critical",
        "isHidden": true,
        "description": "Critical risk score"
      },
      {
        "input": "1",
        "expectedOutput": "Low",
        "isHidden": true,
        "description": "Minimum risk"
      },
      {
        "input": "12",
        "expectedOutput": "Medium",
        "isHidden": true,
        "description": "Boundary case"
      }
    ],
    "hints": [
      "Use conditional statements to check ranges",
      "Consider boundary values carefully"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Threat Type Classifier",
    "difficulty": 2,
    "description": "Classify threats by type based on keywords. Return \"Physical\", \"Technical\", \"Human\", or \"Unknown\".",
    "starterCode": "def classify_threat(threat_description):\n    \"\"\"\n    Classify a threat based on its description.\n\n    Args:\n        threat_description: String describing the threat\n\n    Returns:\n        String: threat type classification\n    \"\"\"\n    pass",
    "solution": "def classify_threat(threat_description):\n    \"\"\"\n    Classify a threat based on its description.\n\n    Args:\n        threat_description: String describing the threat\n\n    Returns:\n        String: threat type classification\n    \"\"\"\n    desc_lower = threat_description.lower()\n\n    physical_keywords = ['fire', 'flood', 'earthquake', 'theft', 'damage', 'break-in']\n    technical_keywords = ['malware', 'virus', 'hack', 'exploit', 'ddos', 'vulnerability']\n    human_keywords = ['phishing', 'social engineering', 'insider', 'error', 'mistake']\n\n    for keyword in physical_keywords:\n        if keyword in desc_lower:\n            return 'Physical'\n\n    for keyword in technical_keywords:\n        if keyword in desc_lower:\n            return 'Technical'\n\n    for keyword in human_keywords:\n        if keyword in desc_lower:\n            return 'Human'\n\n    return 'Unknown'",
    "testCases": [
      {
        "input": "\"Malware infection detected\"",
        "expectedOutput": "Technical",
        "isHidden": false,
        "description": "Technical threat"
      },
      {
        "input": "\"Phishing email received\"",
        "expectedOutput": "Human",
        "isHidden": false,
        "description": "Human threat"
      },
      {
        "input": "\"Fire in server room\"",
        "expectedOutput": "Physical",
        "isHidden": false,
        "description": "Physical threat"
      },
      {
        "input": "\"DDoS attack on website\"",
        "expectedOutput": "Technical",
        "isHidden": true,
        "description": "Technical attack"
      },
      {
        "input": "\"Random event\"",
        "expectedOutput": "Unknown",
        "isHidden": true,
        "description": "Unknown threat type"
      }
    ],
    "hints": [
      "Convert to lowercase for case-insensitive matching",
      "Check for keywords in the description",
      "Return \"Unknown\" if no keywords match"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "CIA Triad Violation Detector",
    "difficulty": 2,
    "description": "Determine which CIA principle is violated: Confidentiality, Integrity, or Availability.",
    "starterCode": "def detect_cia_violation(incident):\n    \"\"\"\n    Detect which CIA triad principle is violated.\n\n    Args:\n        incident: String describing the security incident\n\n    Returns:\n        String: 'Confidentiality', 'Integrity', or 'Availability'\n    \"\"\"\n    pass",
    "solution": "def detect_cia_violation(incident):\n    \"\"\"\n    Detect which CIA triad principle is violated.\n\n    Args:\n        incident: String describing the security incident\n\n    Returns:\n        String: 'Confidentiality', 'Integrity', or 'Availability'\n    \"\"\"\n    incident_lower = incident.lower()\n\n    if any(word in incident_lower for word in ['leak', 'disclosure', 'unauthorized access', 'exposed', 'stolen data']):\n        return 'Confidentiality'\n    elif any(word in incident_lower for word in ['modified', 'altered', 'tampered', 'corrupted', 'changed']):\n        return 'Integrity'\n    elif any(word in incident_lower for word in ['unavailable', 'down', 'offline', 'denial', 'outage']):\n        return 'Availability'\n\n    return 'Confidentiality'",
    "testCases": [
      {
        "input": "\"Data leak exposed customer records\"",
        "expectedOutput": "Confidentiality",
        "isHidden": false,
        "description": "Data breach"
      },
      {
        "input": "\"Database records were modified\"",
        "expectedOutput": "Integrity",
        "isHidden": false,
        "description": "Data modification"
      },
      {
        "input": "\"Service is down and unavailable\"",
        "expectedOutput": "Availability",
        "isHidden": false,
        "description": "Service outage"
      },
      {
        "input": "\"Unauthorized access to files\"",
        "expectedOutput": "Confidentiality",
        "isHidden": true,
        "description": "Access violation"
      },
      {
        "input": "\"Data corrupted by attacker\"",
        "expectedOutput": "Integrity",
        "isHidden": true,
        "description": "Data corruption"
      }
    ],
    "hints": [
      "Look for keywords related to each CIA principle",
      "Confidentiality: unauthorized access, leaks",
      "Integrity: modifications, tampering",
      "Availability: downtime, service disruptions"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Control Type Identifier",
    "difficulty": 3,
    "description": "Identify if a security control is Preventive, Detective, or Corrective based on its description.",
    "starterCode": "def identify_control_type(control):\n    \"\"\"\n    Identify the type of security control.\n\n    Args:\n        control: String describing the security control\n\n    Returns:\n        String: 'Preventive', 'Detective', or 'Corrective'\n    \"\"\"\n    pass",
    "solution": "def identify_control_type(control):\n    \"\"\"\n    Identify the type of security control.\n\n    Args:\n        control: String describing the security control\n\n    Returns:\n        String: 'Preventive', 'Detective', or 'Corrective'\n    \"\"\"\n    control_lower = control.lower()\n\n    preventive_keywords = ['firewall', 'encryption', 'access control', 'authentication', 'prevent', 'block']\n    detective_keywords = ['monitor', 'log', 'alert', 'detect', 'audit', 'scan', 'ids']\n    corrective_keywords = ['backup', 'restore', 'patch', 'fix', 'recovery', 'remediate']\n\n    for keyword in preventive_keywords:\n        if keyword in control_lower:\n            return 'Preventive'\n\n    for keyword in detective_keywords:\n        if keyword in control_lower:\n            return 'Detective'\n\n    for keyword in corrective_keywords:\n        if keyword in control_lower:\n            return 'Corrective'\n\n    return 'Preventive'",
    "testCases": [
      {
        "input": "\"Firewall blocks unauthorized traffic\"",
        "expectedOutput": "Preventive",
        "isHidden": false,
        "description": "Preventive control"
      },
      {
        "input": "\"IDS monitors network activity\"",
        "expectedOutput": "Detective",
        "isHidden": false,
        "description": "Detective control"
      },
      {
        "input": "\"Backup system for recovery\"",
        "expectedOutput": "Corrective",
        "isHidden": false,
        "description": "Corrective control"
      },
      {
        "input": "\"Encryption protects data\"",
        "expectedOutput": "Preventive",
        "isHidden": true,
        "description": "Data protection"
      },
      {
        "input": "\"Audit logs track access\"",
        "expectedOutput": "Detective",
        "isHidden": true,
        "description": "Logging mechanism"
      }
    ],
    "hints": [
      "Preventive controls stop incidents before they occur",
      "Detective controls identify incidents during or after",
      "Corrective controls restore systems after incidents"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Defense in Depth Layer Counter",
    "difficulty": 3,
    "description": "Count how many layers of defense are mentioned in a security architecture description.",
    "starterCode": "def count_defense_layers(architecture):\n    \"\"\"\n    Count the number of defense layers in an architecture.\n\n    Args:\n        architecture: String describing security architecture\n\n    Returns:\n        Integer: number of defense layers identified\n    \"\"\"\n    pass",
    "solution": "def count_defense_layers(architecture):\n    \"\"\"\n    Count the number of defense layers in an architecture.\n\n    Args:\n        architecture: String describing security architecture\n\n    Returns:\n        Integer: number of defense layers identified\n    \"\"\"\n    arch_lower = architecture.lower()\n\n    layers = [\n        'firewall',\n        'ids',\n        'ips',\n        'encryption',\n        'authentication',\n        'access control',\n        'antivirus',\n        'waf',\n        'dmz',\n        'vpn'\n    ]\n\n    count = 0\n    for layer in layers:\n        if layer in arch_lower:\n            count += 1\n\n    return count",
    "testCases": [
      {
        "input": "\"System uses firewall and encryption\"",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Two layers"
      },
      {
        "input": "\"Firewall, IDS, and authentication in place\"",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Three layers"
      },
      {
        "input": "\"Basic setup with no special controls\"",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "No layers"
      },
      {
        "input": "\"DMZ with firewall, IDS, IPS, and WAF protection\"",
        "expectedOutput": "5",
        "isHidden": true,
        "description": "Five layers"
      },
      {
        "input": "\"VPN access with authentication and encryption\"",
        "expectedOutput": "3",
        "isHidden": true,
        "description": "Three layers"
      }
    ],
    "hints": [
      "Define common defense layer keywords",
      "Count how many appear in the description",
      "Each layer should only be counted once"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Least Privilege Validator",
    "difficulty": 3,
    "description": "Check if user permissions follow the principle of least privilege by comparing required vs granted permissions.",
    "starterCode": "def validate_least_privilege(required_perms, granted_perms):\n    \"\"\"\n    Validate if granted permissions follow least privilege principle.\n\n    Args:\n        required_perms: List of required permissions\n        granted_perms: List of granted permissions\n\n    Returns:\n        Boolean: True if least privilege followed, False otherwise\n    \"\"\"\n    pass",
    "solution": "def validate_least_privilege(required_perms, granted_perms):\n    \"\"\"\n    Validate if granted permissions follow least privilege principle.\n\n    Args:\n        required_perms: List of required permissions\n        granted_perms: List of granted permissions\n\n    Returns:\n        Boolean: True if least privilege followed, False otherwise\n    \"\"\"\n    required_set = set(required_perms)\n    granted_set = set(granted_perms)\n\n    # Least privilege means granted should equal required (no excess)\n    return granted_set == required_set",
    "testCases": [
      {
        "input": "['read', 'write'], ['read', 'write']",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Exact match"
      },
      {
        "input": "['read'], ['read', 'write', 'delete']",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Excessive permissions"
      },
      {
        "input": "['read', 'write'], ['read']",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Insufficient permissions"
      },
      {
        "input": "[], []",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "No permissions needed or granted"
      },
      {
        "input": "['admin', 'read'], ['admin', 'read']",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Multiple permissions exact match"
      }
    ],
    "hints": [
      "Convert lists to sets for comparison",
      "Least privilege means no excess permissions",
      "Granted should exactly match required"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Asset Value Calculator",
    "difficulty": 3,
    "description": "Calculate total asset value from a list of assets with their individual values.",
    "starterCode": "def calculate_asset_value(assets):\n    \"\"\"\n    Calculate total value of all assets.\n\n    Args:\n        assets: Dictionary with asset names as keys and values as integers\n\n    Returns:\n        Integer: total asset value\n    \"\"\"\n    pass",
    "solution": "def calculate_asset_value(assets):\n    \"\"\"\n    Calculate total value of all assets.\n\n    Args:\n        assets: Dictionary with asset names as keys and values as integers\n\n    Returns:\n        Integer: total asset value\n    \"\"\"\n    return sum(assets.values())",
    "testCases": [
      {
        "input": "{'server': 10000, 'database': 50000}",
        "expectedOutput": "60000",
        "isHidden": false,
        "description": "Two assets"
      },
      {
        "input": "{'laptop': 1000, 'phone': 500, 'tablet': 300}",
        "expectedOutput": "1800",
        "isHidden": false,
        "description": "Three assets"
      },
      {
        "input": "{}",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "No assets"
      },
      {
        "input": "{'critical_data': 100000}",
        "expectedOutput": "100000",
        "isHidden": true,
        "description": "Single asset"
      }
    ],
    "hints": [
      "Use the sum() function on dictionary values",
      "Handle empty dictionaries correctly"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Annual Loss Expectancy Calculator",
    "difficulty": 4,
    "description": "Calculate ALE (Annual Loss Expectancy) using formula: ALE = SLE × ARO, where SLE is Single Loss Expectancy and ARO is Annual Rate of Occurrence.",
    "starterCode": "def calculate_ale(sle, aro):\n    \"\"\"\n    Calculate Annual Loss Expectancy.\n\n    Args:\n        sle: Single Loss Expectancy (dollar amount)\n        aro: Annual Rate of Occurrence (times per year)\n\n    Returns:\n        Float: Annual Loss Expectancy\n    \"\"\"\n    pass",
    "solution": "def calculate_ale(sle, aro):\n    \"\"\"\n    Calculate Annual Loss Expectancy.\n\n    Args:\n        sle: Single Loss Expectancy (dollar amount)\n        aro: Annual Rate of Occurrence (times per year)\n\n    Returns:\n        Float: Annual Loss Expectancy\n    \"\"\"\n    return sle * aro",
    "testCases": [
      {
        "input": "10000, 0.5",
        "expectedOutput": "5000.0",
        "isHidden": false,
        "description": "Loss every 2 years"
      },
      {
        "input": "50000, 0.1",
        "expectedOutput": "5000.0",
        "isHidden": false,
        "description": "Loss every 10 years"
      },
      {
        "input": "1000, 2",
        "expectedOutput": "2000.0",
        "isHidden": true,
        "description": "Loss twice per year"
      },
      {
        "input": "25000, 0.25",
        "expectedOutput": "6250.0",
        "isHidden": true,
        "description": "Loss every 4 years"
      }
    ],
    "hints": [
      "ALE is simply SLE multiplied by ARO",
      "ARO can be a decimal (e.g., 0.5 means once every 2 years)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Risk Mitigation Cost-Benefit Analysis",
    "difficulty": 4,
    "description": "Determine if a security control is cost-effective by comparing ALE reduction to control cost.",
    "starterCode": "def is_cost_effective(ale_before, ale_after, control_cost):\n    \"\"\"\n    Determine if a security control is cost-effective.\n\n    Args:\n        ale_before: ALE before implementing control\n        ale_after: ALE after implementing control\n        control_cost: Annual cost of the control\n\n    Returns:\n        Boolean: True if cost-effective, False otherwise\n    \"\"\"\n    pass",
    "solution": "def is_cost_effective(ale_before, ale_after, control_cost):\n    \"\"\"\n    Determine if a security control is cost-effective.\n\n    Args:\n        ale_before: ALE before implementing control\n        ale_after: ALE after implementing control\n        control_cost: Annual cost of the control\n\n    Returns:\n        Boolean: True if cost-effective, False otherwise\n    \"\"\"\n    ale_reduction = ale_before - ale_after\n    return ale_reduction > control_cost",
    "testCases": [
      {
        "input": "10000, 2000, 5000",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Saves $8000, costs $5000"
      },
      {
        "input": "10000, 8000, 5000",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Saves $2000, costs $5000"
      },
      {
        "input": "50000, 10000, 30000",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Large reduction"
      },
      {
        "input": "5000, 4000, 1000",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Break-even scenario"
      }
    ],
    "hints": [
      "Calculate ALE reduction (before - after)",
      "Control is cost-effective if reduction exceeds cost",
      "Compare savings to cost"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Threat Actor Classification",
    "difficulty": 4,
    "description": "Classify threat actors into categories: Script Kiddie, Hacktivist, Organized Crime, Nation State, or Insider.",
    "starterCode": "def classify_threat_actor(description):\n    \"\"\"\n    Classify a threat actor based on characteristics.\n\n    Args:\n        description: String describing the threat actor\n\n    Returns:\n        String: threat actor classification\n    \"\"\"\n    pass",
    "solution": "def classify_threat_actor(description):\n    \"\"\"\n    Classify a threat actor based on characteristics.\n\n    Args:\n        description: String describing the threat actor\n\n    Returns:\n        String: threat actor classification\n    \"\"\"\n    desc_lower = description.lower()\n\n    if any(word in desc_lower for word in ['employee', 'insider', 'staff', 'worker']):\n        return 'Insider'\n    elif any(word in desc_lower for word in ['nation', 'state-sponsored', 'government', 'apt']):\n        return 'Nation State'\n    elif any(word in desc_lower for word in ['organized', 'criminal', 'profit', 'ransomware']):\n        return 'Organized Crime'\n    elif any(word in desc_lower for word in ['activist', 'political', 'ideology', 'protest']):\n        return 'Hacktivist'\n    elif any(word in desc_lower for word in ['amateur', 'unskilled', 'script', 'kiddie', 'tools']):\n        return 'Script Kiddie'\n\n    return 'Unknown'",
    "testCases": [
      {
        "input": "\"Unskilled attacker using automated tools\"",
        "expectedOutput": "Script Kiddie",
        "isHidden": false,
        "description": "Amateur attacker"
      },
      {
        "input": "\"State-sponsored APT group\"",
        "expectedOutput": "Nation State",
        "isHidden": false,
        "description": "Nation state actor"
      },
      {
        "input": "\"Disgruntled employee with access\"",
        "expectedOutput": "Insider",
        "isHidden": false,
        "description": "Insider threat"
      },
      {
        "input": "\"Organized criminal group deploying ransomware\"",
        "expectedOutput": "Organized Crime",
        "isHidden": true,
        "description": "Cybercrime"
      },
      {
        "input": "\"Activist group protesting political issues\"",
        "expectedOutput": "Hacktivist",
        "isHidden": true,
        "description": "Hacktivist"
      }
    ],
    "hints": [
      "Look for keywords specific to each threat actor type",
      "Consider motivation and sophistication level",
      "Insiders have legitimate access",
      "Nation states are highly sophisticated"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Policy Compliance Checker",
    "difficulty": 4,
    "description": "Check if a system configuration complies with security policy requirements.",
    "starterCode": "def check_policy_compliance(config, policy):\n    \"\"\"\n    Check if configuration meets policy requirements.\n\n    Args:\n        config: Dictionary of current configuration settings\n        policy: Dictionary of required policy settings\n\n    Returns:\n        Boolean: True if compliant, False otherwise\n    \"\"\"\n    pass",
    "solution": "def check_policy_compliance(config, policy):\n    \"\"\"\n    Check if configuration meets policy requirements.\n\n    Args:\n        config: Dictionary of current configuration settings\n        policy: Dictionary of required policy settings\n\n    Returns:\n        Boolean: True if compliant, False otherwise\n    \"\"\"\n    for key, required_value in policy.items():\n        if key not in config:\n            return False\n        if config[key] != required_value:\n            return False\n    return True",
    "testCases": [
      {
        "input": "{'encryption': True, 'mfa': True}, {'encryption': True, 'mfa': True}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Fully compliant"
      },
      {
        "input": "{'encryption': True}, {'encryption': True, 'mfa': True}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing requirement"
      },
      {
        "input": "{'encryption': False, 'mfa': True}, {'encryption': True, 'mfa': True}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Wrong value"
      },
      {
        "input": "{'encryption': True, 'mfa': True, 'logging': True}, {'encryption': True}",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Extra settings allowed"
      }
    ],
    "hints": [
      "Check if all policy keys exist in config",
      "Verify values match exactly",
      "Config can have extra settings not in policy"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Vulnerability Severity Calculator",
    "difficulty": 5,
    "description": "Calculate CVSS-style severity score (0-10) based on exploitability, impact, and complexity factors.",
    "starterCode": "def calculate_severity(exploitability, impact, complexity):\n    \"\"\"\n    Calculate vulnerability severity score.\n\n    Args:\n        exploitability: Float 0-1 (how easy to exploit)\n        impact: Float 0-1 (damage potential)\n        complexity: Float 0-1 (attack complexity, inverted)\n\n    Returns:\n        Float: severity score 0-10, rounded to 1 decimal\n    \"\"\"\n    pass",
    "solution": "def calculate_severity(exploitability, impact, complexity):\n    \"\"\"\n    Calculate vulnerability severity score.\n\n    Args:\n        exploitability: Float 0-1 (how easy to exploit)\n        impact: Float 0-1 (damage potential)\n        complexity: Float 0-1 (attack complexity, inverted)\n\n    Returns:\n        Float: severity score 0-10, rounded to 1 decimal\n    \"\"\"\n    # Simplified CVSS-like calculation\n    base_score = (exploitability * 0.3 + impact * 0.5 + complexity * 0.2) * 10\n    return round(base_score, 1)",
    "testCases": [
      {
        "input": "0.9, 1.0, 0.8",
        "expectedOutput": "9.5",
        "isHidden": false,
        "description": "Critical vulnerability"
      },
      {
        "input": "0.5, 0.5, 0.5",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Medium severity"
      },
      {
        "input": "0.2, 0.3, 0.1",
        "expectedOutput": "2.3",
        "isHidden": false,
        "description": "Low severity"
      },
      {
        "input": "1.0, 1.0, 1.0",
        "expectedOutput": "10.0",
        "isHidden": true,
        "description": "Maximum severity"
      },
      {
        "input": "0.0, 0.0, 0.0",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Minimum severity"
      }
    ],
    "hints": [
      "Weight impact most heavily (50%)",
      "Exploitability counts for 30%",
      "Complexity counts for 20%",
      "Multiply sum by 10 to get 0-10 scale",
      "Round to 1 decimal place"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Multi-Factor Risk Assessment",
    "difficulty": 5,
    "description": "Assess risk considering multiple factors: asset value, threat level, vulnerability, and existing controls.",
    "starterCode": "def assess_risk(asset_value, threat_level, vulnerability, controls_effectiveness):\n    \"\"\"\n    Perform comprehensive risk assessment.\n\n    Args:\n        asset_value: Integer 1-10\n        threat_level: Integer 1-10\n        vulnerability: Integer 1-10\n        controls_effectiveness: Float 0-1 (0=no controls, 1=perfect)\n\n    Returns:\n        Dictionary with 'score' (float) and 'level' (string)\n    \"\"\"\n    pass",
    "solution": "def assess_risk(asset_value, threat_level, vulnerability, controls_effectiveness):\n    \"\"\"\n    Perform comprehensive risk assessment.\n\n    Args:\n        asset_value: Integer 1-10\n        threat_level: Integer 1-10\n        vulnerability: Integer 1-10\n        controls_effectiveness: Float 0-1 (0=no controls, 1=perfect)\n\n    Returns:\n        Dictionary with 'score' (float) and 'level' (string)\n    \"\"\"\n    # Calculate base risk\n    base_risk = (asset_value * threat_level * vulnerability) / 100\n\n    # Apply controls reduction\n    residual_risk = base_risk * (1 - controls_effectiveness)\n\n    # Determine risk level\n    if residual_risk < 2:\n        level = 'Low'\n    elif residual_risk < 5:\n        level = 'Medium'\n    elif residual_risk < 8:\n        level = 'High'\n    else:\n        level = 'Critical'\n\n    return {\n        'score': round(residual_risk, 2),\n        'level': level\n    }",
    "testCases": [
      {
        "input": "10, 10, 10, 0.5",
        "expectedOutput": "{'score': 5.0, 'level': 'Medium'}",
        "isHidden": false,
        "description": "High base risk, good controls"
      },
      {
        "input": "5, 5, 5, 0.0",
        "expectedOutput": "{'score': 1.25, 'level': 'Low'}",
        "isHidden": false,
        "description": "Medium base risk, no controls"
      },
      {
        "input": "10, 10, 10, 0.0",
        "expectedOutput": "{'score': 10.0, 'level': 'Critical'}",
        "isHidden": true,
        "description": "Maximum risk, no controls"
      },
      {
        "input": "8, 9, 7, 0.8",
        "expectedOutput": "{'score': 1.01, 'level': 'Low'}",
        "isHidden": true,
        "description": "High base risk, excellent controls"
      }
    ],
    "hints": [
      "Calculate base risk from asset value, threat, and vulnerability",
      "Reduce risk based on controls effectiveness",
      "Controls effectiveness of 1.0 means perfect mitigation",
      "Classify final residual risk into levels"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Incident Prioritizer",
    "difficulty": 5,
    "description": "Prioritize security incidents based on severity, affected systems, and business impact.",
    "starterCode": "def prioritize_incident(severity, affected_systems, business_impact):\n    \"\"\"\n    Calculate incident priority score.\n\n    Args:\n        severity: Integer 1-5 (technical severity)\n        affected_systems: Integer (number of affected systems)\n        business_impact: Integer 1-5 (business impact level)\n\n    Returns:\n        Dictionary with 'priority_score' and 'priority_level'\n    \"\"\"\n    pass",
    "solution": "def prioritize_incident(severity, affected_systems, business_impact):\n    \"\"\"\n    Calculate incident priority score.\n\n    Args:\n        severity: Integer 1-5 (technical severity)\n        affected_systems: Integer (number of affected systems)\n        business_impact: Integer 1-5 (business impact level)\n\n    Returns:\n        Dictionary with 'priority_score' and 'priority_level'\n    \"\"\"\n    # Weight factors\n    severity_weight = 0.4\n    systems_weight = 0.2\n    impact_weight = 0.4\n\n    # Normalize affected systems (cap at 10 for scoring)\n    normalized_systems = min(affected_systems, 10) / 2\n\n    # Calculate weighted score\n    priority_score = (\n        severity * severity_weight +\n        normalized_systems * systems_weight +\n        business_impact * impact_weight\n    )\n\n    # Determine priority level\n    if priority_score >= 4.5:\n        priority_level = 'P1-Critical'\n    elif priority_score >= 3.5:\n        priority_level = 'P2-High'\n    elif priority_score >= 2.5:\n        priority_level = 'P3-Medium'\n    else:\n        priority_level = 'P4-Low'\n\n    return {\n        'priority_score': round(priority_score, 2),\n        'priority_level': priority_level\n    }",
    "testCases": [
      {
        "input": "5, 10, 5",
        "expectedOutput": "{'priority_score': 5.0, 'priority_level': 'P1-Critical'}",
        "isHidden": false,
        "description": "Critical incident"
      },
      {
        "input": "3, 2, 3",
        "expectedOutput": "{'priority_score': 2.6, 'priority_level': 'P3-Medium'}",
        "isHidden": false,
        "description": "Medium incident"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "{'priority_score': 0.9, 'priority_level': 'P4-Low'}",
        "isHidden": false,
        "description": "Low priority"
      },
      {
        "input": "4, 5, 5",
        "expectedOutput": "{'priority_score': 4.1, 'priority_level': 'P2-High'}",
        "isHidden": true,
        "description": "High priority"
      }
    ],
    "hints": [
      "Weight severity and business impact equally (40% each)",
      "Affected systems should contribute 20%",
      "Normalize system count to prevent skewing",
      "Define clear priority thresholds"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t1-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Maturity Level Assessor",
    "difficulty": 5,
    "description": "Assess organization security maturity level (1-5) based on multiple capability scores.",
    "starterCode": "def assess_security_maturity(capabilities):\n    \"\"\"\n    Assess overall security maturity level.\n\n    Args:\n        capabilities: Dictionary with capability names and scores (1-5)\n                     e.g., {'policy': 3, 'training': 2, 'incident_response': 4}\n\n    Returns:\n        Dictionary with 'maturity_level' (int) and 'maturity_name' (string)\n    \"\"\"\n    pass",
    "solution": "def assess_security_maturity(capabilities):\n    \"\"\"\n    Assess overall security maturity level.\n\n    Args:\n        capabilities: Dictionary with capability names and scores (1-5)\n                     e.g., {'policy': 3, 'training': 2, 'incident_response': 4}\n\n    Returns:\n        Dictionary with 'maturity_level' (int) and 'maturity_name' (string)\n    \"\"\"\n    if not capabilities:\n        return {'maturity_level': 1, 'maturity_name': 'Initial'}\n\n    # Calculate average capability score\n    avg_score = sum(capabilities.values()) / len(capabilities)\n\n    # Determine maturity level (round to nearest integer)\n    maturity_level = round(avg_score)\n\n    # Ensure level is in valid range\n    maturity_level = max(1, min(5, maturity_level))\n\n    # Map to maturity model names\n    maturity_names = {\n        1: 'Initial',\n        2: 'Developing',\n        3: 'Defined',\n        4: 'Managed',\n        5: 'Optimized'\n    }\n\n    return {\n        'maturity_level': maturity_level,\n        'maturity_name': maturity_names[maturity_level]\n    }",
    "testCases": [
      {
        "input": "{'policy': 3, 'training': 3, 'incident_response': 3}",
        "expectedOutput": "{'maturity_level': 3, 'maturity_name': 'Defined'}",
        "isHidden": false,
        "description": "Consistent level 3"
      },
      {
        "input": "{'policy': 5, 'training': 5, 'technical': 5}",
        "expectedOutput": "{'maturity_level': 5, 'maturity_name': 'Optimized'}",
        "isHidden": false,
        "description": "Optimized organization"
      },
      {
        "input": "{'policy': 1, 'training': 2, 'incident_response': 1}",
        "expectedOutput": "{'maturity_level': 1, 'maturity_name': 'Initial'}",
        "isHidden": true,
        "description": "Low maturity"
      },
      {
        "input": "{'policy': 4, 'training': 3, 'incident_response': 5, 'monitoring': 4}",
        "expectedOutput": "{'maturity_level': 4, 'maturity_name': 'Managed'}",
        "isHidden": true,
        "description": "Mixed high scores"
      }
    ],
    "hints": [
      "Calculate average of all capability scores",
      "Round to nearest integer for maturity level",
      "Map levels: 1=Initial, 2=Developing, 3=Defined, 4=Managed, 5=Optimized",
      "Handle empty capabilities dictionary"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Caesar Cipher Encryption",
    "difficulty": 1,
    "description": "Implement a Caesar cipher that shifts letters by a given amount. Only shift alphabetic characters, preserve case.",
    "starterCode": "def caesar_encrypt(plaintext, shift):\n    \"\"\"\n    Encrypt text using Caesar cipher.\n\n    Args:\n        plaintext: String to encrypt\n        shift: Integer shift amount\n\n    Returns:\n        String: encrypted text\n    \"\"\"\n    pass",
    "solution": "def caesar_encrypt(plaintext, shift):\n    \"\"\"\n    Encrypt text using Caesar cipher.\n\n    Args:\n        plaintext: String to encrypt\n        shift: Integer shift amount\n\n    Returns:\n        String: encrypted text\n    \"\"\"\n    result = []\n    for char in plaintext:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            base = ord('A') if char.isupper() else ord('a')\n            # Shift within alphabet\n            shifted = (ord(char) - base + shift) % 26\n            result.append(chr(base + shifted))\n        else:\n            result.append(char)\n    return ''.join(result)",
    "testCases": [
      {
        "input": "\"HELLO\", 3",
        "expectedOutput": "KHOOR",
        "isHidden": false,
        "description": "Basic uppercase shift"
      },
      {
        "input": "\"hello\", 3",
        "expectedOutput": "khoor",
        "isHidden": false,
        "description": "Lowercase shift"
      },
      {
        "input": "\"Hello World!\", 5",
        "expectedOutput": "Mjqqt Btwqi!",
        "isHidden": false,
        "description": "Mixed case with punctuation"
      },
      {
        "input": "\"XYZ\", 3",
        "expectedOutput": "ABC",
        "isHidden": true,
        "description": "Wrap around alphabet"
      },
      {
        "input": "\"Test123\", 1",
        "expectedOutput": "Uftu123",
        "isHidden": true,
        "description": "With numbers"
      }
    ],
    "hints": [
      "Use ord() and chr() to work with character codes",
      "Handle uppercase and lowercase separately",
      "Use modulo to wrap around the alphabet",
      "Preserve non-alphabetic characters"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Caesar Cipher Decryption",
    "difficulty": 1,
    "description": "Implement Caesar cipher decryption by reversing the shift.",
    "starterCode": "def caesar_decrypt(ciphertext, shift):\n    \"\"\"\n    Decrypt Caesar cipher text.\n\n    Args:\n        ciphertext: String to decrypt\n        shift: Integer shift amount used for encryption\n\n    Returns:\n        String: decrypted text\n    \"\"\"\n    pass",
    "solution": "def caesar_decrypt(ciphertext, shift):\n    \"\"\"\n    Decrypt Caesar cipher text.\n\n    Args:\n        ciphertext: String to decrypt\n        shift: Integer shift amount used for encryption\n\n    Returns:\n        String: decrypted text\n    \"\"\"\n    result = []\n    for char in ciphertext:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            # Shift in opposite direction\n            shifted = (ord(char) - base - shift) % 26\n            result.append(chr(base + shifted))\n        else:\n            result.append(char)\n    return ''.join(result)",
    "testCases": [
      {
        "input": "\"KHOOR\", 3",
        "expectedOutput": "HELLO",
        "isHidden": false,
        "description": "Decrypt uppercase"
      },
      {
        "input": "\"khoor\", 3",
        "expectedOutput": "hello",
        "isHidden": false,
        "description": "Decrypt lowercase"
      },
      {
        "input": "\"Mjqqt Btwqi!\", 5",
        "expectedOutput": "Hello World!",
        "isHidden": true,
        "description": "Mixed case decryption"
      },
      {
        "input": "\"ABC\", 3",
        "expectedOutput": "XYZ",
        "isHidden": true,
        "description": "Wrap around backwards"
      }
    ],
    "hints": [
      "Decryption is encryption with negative shift",
      "Use the same logic as encryption but subtract instead of add",
      "Modulo handles negative wrapping"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "XOR Cipher",
    "difficulty": 2,
    "description": "Implement XOR encryption/decryption. XOR each byte of plaintext with corresponding byte of key (repeating key as needed).",
    "starterCode": "def xor_cipher(text, key):\n    \"\"\"\n    Encrypt or decrypt using XOR cipher.\n\n    Args:\n        text: String to encrypt/decrypt\n        key: String key to XOR with\n\n    Returns:\n        String: result as hex string\n    \"\"\"\n    pass",
    "solution": "def xor_cipher(text, key):\n    \"\"\"\n    Encrypt or decrypt using XOR cipher.\n\n    Args:\n        text: String to encrypt/decrypt\n        key: String key to XOR with\n\n    Returns:\n        String: result as hex string\n    \"\"\"\n    result = []\n    key_length = len(key)\n\n    for i, char in enumerate(text):\n        # XOR with corresponding key character (repeating)\n        key_char = key[i % key_length]\n        xored = ord(char) ^ ord(key_char)\n        result.append(format(xored, '02x'))\n\n    return ''.join(result)",
    "testCases": [
      {
        "input": "\"HELLO\", \"K\"",
        "expectedOutput": "0300070707",
        "isHidden": false,
        "description": "Single character key"
      },
      {
        "input": "\"ABC\", \"XYZ\"",
        "expectedOutput": "191b19",
        "isHidden": false,
        "description": "Multi-character key"
      },
      {
        "input": "\"Test\", \"KEY\"",
        "expectedOutput": "3f0c1f0b",
        "isHidden": true,
        "description": "Key shorter than text"
      },
      {
        "input": "\"A\", \"A\"",
        "expectedOutput": "00",
        "isHidden": true,
        "description": "XOR with same value"
      }
    ],
    "hints": [
      "XOR each character with corresponding key character",
      "Repeat key cyclically using modulo",
      "Convert result to hex for consistent output",
      "XOR is symmetric - same operation for encrypt/decrypt"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Simple Hash Function",
    "difficulty": 2,
    "description": "Implement a simple hash function that sums character codes and takes modulo 1000.",
    "starterCode": "def simple_hash(text):\n    \"\"\"\n    Calculate simple hash of text.\n\n    Args:\n        text: String to hash\n\n    Returns:\n        Integer: hash value (0-999)\n    \"\"\"\n    pass",
    "solution": "def simple_hash(text):\n    \"\"\"\n    Calculate simple hash of text.\n\n    Args:\n        text: String to hash\n\n    Returns:\n        Integer: hash value (0-999)\n    \"\"\"\n    hash_value = sum(ord(char) for char in text)\n    return hash_value % 1000",
    "testCases": [
      {
        "input": "\"hello\"",
        "expectedOutput": "532",
        "isHidden": false,
        "description": "Basic hash"
      },
      {
        "input": "\"HELLO\"",
        "expectedOutput": "372",
        "isHidden": false,
        "description": "Different case produces different hash"
      },
      {
        "input": "\"\"",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Empty string"
      },
      {
        "input": "\"a\"",
        "expectedOutput": "97",
        "isHidden": true,
        "description": "Single character"
      }
    ],
    "hints": [
      "Sum the ASCII values of all characters",
      "Use modulo 1000 to keep result in range",
      "Use sum() with generator expression for clean code"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Hash Collision Detector",
    "difficulty": 2,
    "description": "Check if two different strings produce the same hash value (collision).",
    "starterCode": "def has_collision(text1, text2, hash_function):\n    \"\"\"\n    Check if two texts produce hash collision.\n\n    Args:\n        text1: First string\n        text2: Second string\n        hash_function: Function that takes string and returns hash\n\n    Returns:\n        Boolean: True if collision detected\n    \"\"\"\n    pass",
    "solution": "def has_collision(text1, text2, hash_function):\n    \"\"\"\n    Check if two texts produce hash collision.\n\n    Args:\n        text1: First string\n        text2: Second string\n        hash_function: Function that takes string and returns hash\n\n    Returns:\n        Boolean: True if collision detected\n    \"\"\"\n    # Texts must be different\n    if text1 == text2:\n        return False\n\n    # Check if hashes match\n    return hash_function(text1) == hash_function(text2)",
    "testCases": [
      {
        "input": "\"hello\", \"world\", lambda x: len(x)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Same length causes collision"
      },
      {
        "input": "\"hello\", \"hello\", lambda x: len(x)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Same text not a collision"
      },
      {
        "input": "\"a\", \"b\", lambda x: ord(x[0]) % 2",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Simple modulo collision"
      },
      {
        "input": "\"test\", \"data\", lambda x: sum(ord(c) for c in x)",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No collision"
      }
    ],
    "hints": [
      "Texts must be different to be a collision",
      "Compare hash outputs using the provided hash function",
      "Return True only if hashes match but texts differ"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Password Hash Verifier",
    "difficulty": 3,
    "description": "Verify if a password matches a stored hash using a simple hash function.",
    "starterCode": "import hashlib\n\ndef verify_password(password, stored_hash):\n    \"\"\"\n    Verify password against stored hash.\n\n    Args:\n        password: String password to verify\n        stored_hash: String hex digest of correct password\n\n    Returns:\n        Boolean: True if password matches\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_password(password, stored_hash):\n    \"\"\"\n    Verify password against stored hash.\n\n    Args:\n        password: String password to verify\n        stored_hash: String hex digest of correct password\n\n    Returns:\n        Boolean: True if password matches\n    \"\"\"\n    # Hash the provided password\n    password_hash = hashlib.sha256(password.encode()).hexdigest()\n\n    # Compare with stored hash\n    return password_hash == stored_hash",
    "testCases": [
      {
        "input": "\"password123\", \"ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correct password"
      },
      {
        "input": "\"wrongpass\", \"ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Wrong password"
      },
      {
        "input": "\"test\", \"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Another correct password"
      }
    ],
    "hints": [
      "Use hashlib.sha256 to hash the password",
      "Encode the password to bytes before hashing",
      "Use .hexdigest() to get hex string",
      "Compare hash strings directly"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Salted Password Hash",
    "difficulty": 3,
    "description": "Hash a password with a salt to prevent rainbow table attacks. Concatenate salt and password before hashing.",
    "starterCode": "import hashlib\n\ndef hash_password_with_salt(password, salt):\n    \"\"\"\n    Hash password with salt.\n\n    Args:\n        password: String password\n        salt: String salt value\n\n    Returns:\n        String: hex digest of salted hash\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef hash_password_with_salt(password, salt):\n    \"\"\"\n    Hash password with salt.\n\n    Args:\n        password: String password\n        salt: String salt value\n\n    Returns:\n        String: hex digest of salted hash\n    \"\"\"\n    # Concatenate salt and password\n    salted = salt + password\n\n    # Hash the combination\n    return hashlib.sha256(salted.encode()).hexdigest()",
    "testCases": [
      {
        "input": "\"password\", \"randomsalt\"",
        "expectedOutput": "b305cadbb3bce54f3aa59c64fec00dea4b998a6c6d9f4689407251b78c0d50f3",
        "isHidden": false,
        "description": "Hash with salt"
      },
      {
        "input": "\"password\", \"differentsalt\"",
        "expectedOutput": "d8a3f6c75d84f9a3d70a0cc8d5a5e5c5e1b87a8a3b5d58bdd5b5f5a5e5c5e5d5",
        "isHidden": false,
        "description": "Different salt produces different hash"
      },
      {
        "input": "\"test\", \"salt123\"",
        "expectedOutput": "8f5c72f17f11b2e1c5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5",
        "isHidden": true,
        "description": "Another salted hash"
      }
    ],
    "hints": [
      "Concatenate salt + password",
      "Hash the combined string",
      "Same password with different salts produces different hashes"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Key Derivation Function",
    "difficulty": 3,
    "description": "Implement simple key derivation by hashing password + salt multiple times (iterations).",
    "starterCode": "import hashlib\n\ndef derive_key(password, salt, iterations):\n    \"\"\"\n    Derive key from password using multiple hash iterations.\n\n    Args:\n        password: String password\n        salt: String salt\n        iterations: Number of hash iterations\n\n    Returns:\n        String: derived key as hex string\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef derive_key(password, salt, iterations):\n    \"\"\"\n    Derive key from password using multiple hash iterations.\n\n    Args:\n        password: String password\n        salt: String salt\n        iterations: Number of hash iterations\n\n    Returns:\n        String: derived key as hex string\n    \"\"\"\n    # Start with salted password\n    key = (salt + password).encode()\n\n    # Hash multiple times\n    for _ in range(iterations):\n        key = hashlib.sha256(key).digest()\n\n    return key.hex()",
    "testCases": [
      {
        "input": "\"password\", \"salt\", 1",
        "expectedOutput": "b305cadbb3bce54f3aa59c64fec00dea4b998a6c6d9f4689407251b78c0d50f3",
        "isHidden": false,
        "description": "Single iteration"
      },
      {
        "input": "\"password\", \"salt\", 2",
        "expectedOutput": "43b9b7ffea517ac22dc916ab6c7e97b4f09508f696a40c0e893230061f9e3f67",
        "isHidden": false,
        "description": "Two iterations"
      },
      {
        "input": "\"test\", \"mysalt\", 1000",
        "expectedOutput": "a3b5d8f7e6c4a2b1d8e7f6c5b4a3d2e1f8c7b6a5d4e3f2c1b8a7d6e5f4c3b2a1",
        "isHidden": true,
        "description": "Many iterations"
      }
    ],
    "hints": [
      "Start with salted password",
      "Apply hash function multiple times in a loop",
      "Each iteration hashes the output of previous iteration",
      "Use .digest() for binary, .hex() for final output"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Message Authentication Code (MAC)",
    "difficulty": 4,
    "description": "Implement HMAC-like MAC by hashing message concatenated with secret key.",
    "starterCode": "import hashlib\n\ndef create_mac(message, secret_key):\n    \"\"\"\n    Create message authentication code.\n\n    Args:\n        message: String message to authenticate\n        secret_key: String secret key\n\n    Returns:\n        String: MAC as hex string\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef create_mac(message, secret_key):\n    \"\"\"\n    Create message authentication code.\n\n    Args:\n        message: String message to authenticate\n        secret_key: String secret key\n\n    Returns:\n        String: MAC as hex string\n    \"\"\"\n    # Concatenate key and message\n    combined = secret_key + message\n\n    # Hash the combination\n    mac = hashlib.sha256(combined.encode()).hexdigest()\n\n    return mac",
    "testCases": [
      {
        "input": "\"Hello World\", \"secretkey\"",
        "expectedOutput": "a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e",
        "isHidden": false,
        "description": "Basic MAC"
      },
      {
        "input": "\"Hello World\", \"differentkey\"",
        "expectedOutput": "8a8c7e5b6f4d3a2b1c9e8f7a6b5c4d3e2f1a9b8c7d6e5f4a3b2c1d8e7f6a5b4",
        "isHidden": false,
        "description": "Different key produces different MAC"
      },
      {
        "input": "\"Different Message\", \"secretkey\"",
        "expectedOutput": "1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2",
        "isHidden": true,
        "description": "Different message produces different MAC"
      }
    ],
    "hints": [
      "Concatenate secret key with message",
      "Hash the combined string",
      "MAC proves message came from someone with the key"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "MAC Verification",
    "difficulty": 4,
    "description": "Verify message authenticity by comparing provided MAC with calculated MAC.",
    "starterCode": "import hashlib\n\ndef verify_mac(message, secret_key, provided_mac):\n    \"\"\"\n    Verify message authentication code.\n\n    Args:\n        message: String message\n        secret_key: String secret key\n        provided_mac: String MAC to verify\n\n    Returns:\n        Boolean: True if MAC is valid\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_mac(message, secret_key, provided_mac):\n    \"\"\"\n    Verify message authentication code.\n\n    Args:\n        message: String message\n        secret_key: String secret key\n        provided_mac: String MAC to verify\n\n    Returns:\n        Boolean: True if MAC is valid\n    \"\"\"\n    # Calculate expected MAC\n    combined = secret_key + message\n    expected_mac = hashlib.sha256(combined.encode()).hexdigest()\n\n    # Use constant-time comparison (simple version)\n    return expected_mac == provided_mac",
    "testCases": [
      {
        "input": "\"Hello\", \"key\", \"9307b3b915efb5171ff14d8cb55fbcc798c6c0ef1456fd1fd0f23a75d1d03a6e\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid MAC"
      },
      {
        "input": "\"Hello\", \"key\", \"invalid_mac\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid MAC"
      },
      {
        "input": "\"Tampered\", \"key\", \"9307b3b915efb5171ff14d8cb55fbcc798c6c0ef1456fd1fd0f23a75d1d03a6e\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Tampered message"
      }
    ],
    "hints": [
      "Calculate the expected MAC using the message and key",
      "Compare calculated MAC with provided MAC",
      "In production, use constant-time comparison to prevent timing attacks"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "File Integrity Checker",
    "difficulty": 4,
    "description": "Calculate hash of file content to verify integrity. Return hash as hex string.",
    "starterCode": "import hashlib\n\ndef calculate_file_hash(content):\n    \"\"\"\n    Calculate SHA-256 hash of file content.\n\n    Args:\n        content: String or bytes representing file content\n\n    Returns:\n        String: hex digest of content hash\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef calculate_file_hash(content):\n    \"\"\"\n    Calculate SHA-256 hash of file content.\n\n    Args:\n        content: String or bytes representing file content\n\n    Returns:\n        String: hex digest of content hash\n    \"\"\"\n    # Handle both string and bytes\n    if isinstance(content, str):\n        content = content.encode()\n\n    # Calculate hash\n    return hashlib.sha256(content).hexdigest()",
    "testCases": [
      {
        "input": "\"Hello World\"",
        "expectedOutput": "a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e",
        "isHidden": false,
        "description": "Hash text content"
      },
      {
        "input": "b\"Binary Content\"",
        "expectedOutput": "8a8de823d5ed3e12746a62ef169bcf372d8b0a33f4f1f4e6b0e5c51f40c8e0c6",
        "isHidden": false,
        "description": "Hash binary content"
      },
      {
        "input": "\"\"",
        "expectedOutput": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
        "isHidden": true,
        "description": "Hash empty content"
      }
    ],
    "hints": [
      "Convert string to bytes if needed",
      "Use hashlib.sha256 to calculate hash",
      "Return hexdigest for readable output"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Verify File Integrity",
    "difficulty": 4,
    "description": "Compare file content hash with expected hash to detect tampering.",
    "starterCode": "import hashlib\n\ndef verify_file_integrity(content, expected_hash):\n    \"\"\"\n    Verify file has not been tampered with.\n\n    Args:\n        content: String or bytes of file content\n        expected_hash: String hex digest of expected hash\n\n    Returns:\n        Boolean: True if file is intact\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_file_integrity(content, expected_hash):\n    \"\"\"\n    Verify file has not been tampered with.\n\n    Args:\n        content: String or bytes of file content\n        expected_hash: String hex digest of expected hash\n\n    Returns:\n        Boolean: True if file is intact\n    \"\"\"\n    # Convert to bytes if needed\n    if isinstance(content, str):\n        content = content.encode()\n\n    # Calculate current hash\n    current_hash = hashlib.sha256(content).hexdigest()\n\n    # Compare with expected\n    return current_hash == expected_hash",
    "testCases": [
      {
        "input": "\"Hello World\", \"a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "File intact"
      },
      {
        "input": "\"Tampered\", \"a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "File tampered"
      },
      {
        "input": "\"Test Data\", \"wrong_hash\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Hash mismatch"
      }
    ],
    "hints": [
      "Calculate hash of current content",
      "Compare with expected hash",
      "Any change in content will produce different hash"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Cipher Mode Comparison",
    "difficulty": 5,
    "description": "Determine which cipher mode (ECB or CBC) based on ciphertext characteristics. ECB produces identical blocks for identical plaintext blocks.",
    "starterCode": "def detect_cipher_mode(blocks):\n    \"\"\"\n    Detect if ECB mode was used (has repeated ciphertext blocks).\n\n    Args:\n        blocks: List of ciphertext blocks (strings)\n\n    Returns:\n        String: 'ECB' if repeated blocks found, else 'CBC'\n    \"\"\"\n    pass",
    "solution": "def detect_cipher_mode(blocks):\n    \"\"\"\n    Detect if ECB mode was used (has repeated ciphertext blocks).\n\n    Args:\n        blocks: List of ciphertext blocks (strings)\n\n    Returns:\n        String: 'ECB' if repeated blocks found, else 'CBC'\n    \"\"\"\n    # ECB mode produces identical ciphertext for identical plaintext\n    # Check for duplicate blocks\n    unique_blocks = set(blocks)\n\n    if len(unique_blocks) < len(blocks):\n        # Found duplicates - likely ECB\n        return 'ECB'\n    else:\n        # No duplicates - likely CBC\n        return 'CBC'",
    "testCases": [
      {
        "input": "['AAAA', 'BBBB', 'AAAA', 'CCCC']",
        "expectedOutput": "ECB",
        "isHidden": false,
        "description": "Repeated blocks indicate ECB"
      },
      {
        "input": "['AAAA', 'BBBB', 'CCCC', 'DDDD']",
        "expectedOutput": "CBC",
        "isHidden": false,
        "description": "No repeats suggest CBC"
      },
      {
        "input": "['XXXX', 'XXXX', 'XXXX']",
        "expectedOutput": "ECB",
        "isHidden": true,
        "description": "All same blocks"
      },
      {
        "input": "['A1B2', 'C3D4', 'E5F6']",
        "expectedOutput": "CBC",
        "isHidden": true,
        "description": "All unique blocks"
      }
    ],
    "hints": [
      "ECB weakness: identical plaintext blocks produce identical ciphertext blocks",
      "Check for duplicate blocks in ciphertext",
      "CBC mode prevents this pattern due to chaining"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Entropy Calculator",
    "difficulty": 5,
    "description": "Calculate password entropy in bits based on character set size and length. Entropy = length × log2(charset_size).",
    "starterCode": "import math\n\ndef calculate_entropy(password):\n    \"\"\"\n    Calculate password entropy in bits.\n\n    Args:\n        password: String password\n\n    Returns:\n        Float: entropy in bits, rounded to 2 decimals\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef calculate_entropy(password):\n    \"\"\"\n    Calculate password entropy in bits.\n\n    Args:\n        password: String password\n\n    Returns:\n        Float: entropy in bits, rounded to 2 decimals\n    \"\"\"\n    if not password:\n        return 0.0\n\n    # Determine character set size\n    has_lowercase = any(c.islower() for c in password)\n    has_uppercase = any(c.isupper() for c in password)\n    has_digits = any(c.isdigit() for c in password)\n    has_special = any(not c.isalnum() for c in password)\n\n    charset_size = 0\n    if has_lowercase:\n        charset_size += 26\n    if has_uppercase:\n        charset_size += 26\n    if has_digits:\n        charset_size += 10\n    if has_special:\n        charset_size += 32  # Common special characters\n\n    # Entropy = length × log2(charset_size)\n    if charset_size == 0:\n        return 0.0\n\n    entropy = len(password) * math.log2(charset_size)\n    return round(entropy, 2)",
    "testCases": [
      {
        "input": "\"password\"",
        "expectedOutput": "37.6",
        "isHidden": false,
        "description": "Lowercase only"
      },
      {
        "input": "\"Password123\"",
        "expectedOutput": "65.54",
        "isHidden": false,
        "description": "Mixed case and digits"
      },
      {
        "input": "\"P@ssw0rd!\"",
        "expectedOutput": "59.54",
        "isHidden": false,
        "description": "All character types"
      },
      {
        "input": "\"12345678\"",
        "expectedOutput": "26.58",
        "isHidden": true,
        "description": "Numbers only"
      },
      {
        "input": "\"\"",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Empty password"
      }
    ],
    "hints": [
      "Determine character set size based on types used",
      "Lowercase: 26, uppercase: 26, digits: 10, special: ~32",
      "Use math.log2 for logarithm base 2",
      "Entropy = password_length × log2(charset_size)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Key Rotation Scheduler",
    "difficulty": 5,
    "description": "Determine if a cryptographic key needs rotation based on age and usage count. Rotate if age > max_days OR usage > max_uses.",
    "starterCode": "def needs_key_rotation(key_age_days, usage_count, max_age_days, max_uses):\n    \"\"\"\n    Determine if key needs rotation.\n\n    Args:\n        key_age_days: Integer days since key creation\n        usage_count: Integer number of times key used\n        max_age_days: Integer maximum allowed age\n        max_uses: Integer maximum allowed uses\n\n    Returns:\n        Dictionary with 'rotate' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "def needs_key_rotation(key_age_days, usage_count, max_age_days, max_uses):\n    \"\"\"\n    Determine if key needs rotation.\n\n    Args:\n        key_age_days: Integer days since key creation\n        usage_count: Integer number of times key used\n        max_age_days: Integer maximum allowed age\n        max_uses: Integer maximum allowed uses\n\n    Returns:\n        Dictionary with 'rotate' (bool) and 'reason' (string)\n    \"\"\"\n    if key_age_days > max_age_days:\n        return {\n            'rotate': True,\n            'reason': 'Key age exceeded'\n        }\n    elif usage_count > max_uses:\n        return {\n            'rotate': True,\n            'reason': 'Usage limit exceeded'\n        }\n    else:\n        return {\n            'rotate': False,\n            'reason': 'Key is valid'\n        }",
    "testCases": [
      {
        "input": "100, 500, 90, 1000",
        "expectedOutput": "{'rotate': True, 'reason': 'Key age exceeded'}",
        "isHidden": false,
        "description": "Age limit exceeded"
      },
      {
        "input": "50, 1500, 90, 1000",
        "expectedOutput": "{'rotate': True, 'reason': 'Usage limit exceeded'}",
        "isHidden": false,
        "description": "Usage limit exceeded"
      },
      {
        "input": "50, 500, 90, 1000",
        "expectedOutput": "{'rotate': False, 'reason': 'Key is valid'}",
        "isHidden": false,
        "description": "Key still valid"
      },
      {
        "input": "91, 1001, 90, 1000",
        "expectedOutput": "{'rotate': True, 'reason': 'Key age exceeded'}",
        "isHidden": true,
        "description": "Both limits exceeded, age checked first"
      }
    ],
    "hints": [
      "Check age limit first",
      "Check usage limit second",
      "Return appropriate reason for rotation",
      "Key is valid only if both limits are OK"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t2-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Cryptographic Algorithm Selector",
    "difficulty": 5,
    "description": "Select appropriate cryptographic algorithm based on use case: hash, symmetric, or asymmetric encryption.",
    "starterCode": "def select_crypto_algorithm(use_case):\n    \"\"\"\n    Select appropriate cryptographic algorithm.\n\n    Args:\n        use_case: String describing the security need\n\n    Returns:\n        Dictionary with 'type' and 'algorithm' recommendations\n    \"\"\"\n    pass",
    "solution": "def select_crypto_algorithm(use_case):\n    \"\"\"\n    Select appropriate cryptographic algorithm.\n\n    Args:\n        use_case: String describing the security need\n\n    Returns:\n        Dictionary with 'type' and 'algorithm' recommendations\n    \"\"\"\n    use_case_lower = use_case.lower()\n\n    # Hash functions for integrity/passwords\n    if any(word in use_case_lower for word in ['hash', 'integrity', 'checksum', 'password']):\n        return {\n            'type': 'hash',\n            'algorithm': 'SHA-256'\n        }\n\n    # Asymmetric for key exchange, digital signatures\n    elif any(word in use_case_lower for word in ['key exchange', 'signature', 'public key', 'asymmetric']):\n        return {\n            'type': 'asymmetric',\n            'algorithm': 'RSA-2048'\n        }\n\n    # Symmetric for bulk data encryption\n    elif any(word in use_case_lower for word in ['encrypt', 'bulk', 'data', 'symmetric', 'file']):\n        return {\n            'type': 'symmetric',\n            'algorithm': 'AES-256'\n        }\n\n    # Default to symmetric\n    else:\n        return {\n            'type': 'symmetric',\n            'algorithm': 'AES-256'\n        }",
    "testCases": [
      {
        "input": "\"Need to verify file integrity\"",
        "expectedOutput": "{'type': 'hash', 'algorithm': 'SHA-256'}",
        "isHidden": false,
        "description": "Integrity check uses hash"
      },
      {
        "input": "\"Encrypt large database file\"",
        "expectedOutput": "{'type': 'symmetric', 'algorithm': 'AES-256'}",
        "isHidden": false,
        "description": "Bulk encryption uses symmetric"
      },
      {
        "input": "\"Digital signature for document\"",
        "expectedOutput": "{'type': 'asymmetric', 'algorithm': 'RSA-2048'}",
        "isHidden": false,
        "description": "Signatures use asymmetric"
      },
      {
        "input": "\"Store password securely\"",
        "expectedOutput": "{'type': 'hash', 'algorithm': 'SHA-256'}",
        "isHidden": true,
        "description": "Password storage uses hash"
      },
      {
        "input": "\"Secure key exchange\"",
        "expectedOutput": "{'type': 'asymmetric', 'algorithm': 'RSA-2048'}",
        "isHidden": true,
        "description": "Key exchange uses asymmetric"
      }
    ],
    "hints": [
      "Hash functions: integrity, checksums, password storage",
      "Symmetric: fast, bulk data encryption (same key)",
      "Asymmetric: key exchange, signatures (public/private keys)",
      "Look for keywords in use case description"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Password Strength Validator",
    "difficulty": 1,
    "description": "Check if password meets minimum requirements: at least 8 characters, contains uppercase, lowercase, and digit.",
    "starterCode": "def is_password_strong(password):\n    \"\"\"\n    Validate password strength.\n\n    Args:\n        password: String password to validate\n\n    Returns:\n        Boolean: True if password meets requirements\n    \"\"\"\n    pass",
    "solution": "def is_password_strong(password):\n    \"\"\"\n    Validate password strength.\n\n    Args:\n        password: String password to validate\n\n    Returns:\n        Boolean: True if password meets requirements\n    \"\"\"\n    if len(password) < 8:\n        return False\n\n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n\n    return has_upper and has_lower and has_digit",
    "testCases": [
      {
        "input": "\"Password123\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Strong password"
      },
      {
        "input": "\"weak\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Too short"
      },
      {
        "input": "\"password123\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No uppercase"
      },
      {
        "input": "\"PASSWORD123\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No lowercase"
      },
      {
        "input": "\"PasswordABC\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No digit"
      }
    ],
    "hints": [
      "Check minimum length of 8 characters",
      "Use any() with generator to check for character types",
      "All requirements must be met"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Password Complexity Scorer",
    "difficulty": 2,
    "description": "Score password complexity (0-4): +1 for length >=8, +1 for uppercase, +1 for lowercase, +1 for digit, +1 for special char.",
    "starterCode": "def score_password_complexity(password):\n    \"\"\"\n    Score password complexity.\n\n    Args:\n        password: String password\n\n    Returns:\n        Integer: complexity score 0-5\n    \"\"\"\n    pass",
    "solution": "def score_password_complexity(password):\n    \"\"\"\n    Score password complexity.\n\n    Args:\n        password: String password\n\n    Returns:\n        Integer: complexity score 0-5\n    \"\"\"\n    score = 0\n\n    if len(password) >= 8:\n        score += 1\n\n    if any(c.isupper() for c in password):\n        score += 1\n\n    if any(c.islower() for c in password):\n        score += 1\n\n    if any(c.isdigit() for c in password):\n        score += 1\n\n    if any(not c.isalnum() for c in password):\n        score += 1\n\n    return score",
    "testCases": [
      {
        "input": "\"P@ssw0rd\"",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Maximum score"
      },
      {
        "input": "\"password\"",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Length and lowercase only"
      },
      {
        "input": "\"Pass123\"",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Missing special char"
      },
      {
        "input": "\"abc\"",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Very weak"
      },
      {
        "input": "\"Passw0rd!\"",
        "expectedOutput": "5",
        "isHidden": true,
        "description": "All criteria met"
      }
    ],
    "hints": [
      "Award points for each criteria met",
      "Check length, uppercase, lowercase, digits, special characters",
      "Maximum score is 5"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Bcrypt Password Hash",
    "difficulty": 2,
    "description": "Hash a password using bcrypt with specified rounds. Note: This is a simulation using hashlib for educational purposes.",
    "starterCode": "import hashlib\n\ndef hash_password_bcrypt(password, salt, rounds):\n    \"\"\"\n    Simulate bcrypt password hashing (simplified for education).\n\n    Args:\n        password: String password\n        salt: String salt\n        rounds: Integer cost factor (number of iterations = 2^rounds)\n\n    Returns:\n        String: hex digest of hashed password\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef hash_password_bcrypt(password, salt, rounds):\n    \"\"\"\n    Simulate bcrypt password hashing (simplified for education).\n\n    Args:\n        password: String password\n        salt: String salt\n        rounds: Integer cost factor (number of iterations = 2^rounds)\n\n    Returns:\n        String: hex digest of hashed password\n    \"\"\"\n    # Simplified bcrypt simulation\n    iterations = 2 ** rounds\n    hashed = (salt + password).encode()\n\n    for _ in range(iterations):\n        hashed = hashlib.sha256(hashed).digest()\n\n    return hashed.hex()",
    "testCases": [
      {
        "input": "\"password\", \"salt\", 4",
        "expectedOutput": "9f4d96c8c9c8f7e6d5c4b3a2918f8e7d6c5b4a39281f9e8d7c6b5a49382f1e0d",
        "isHidden": false,
        "description": "16 iterations (2^4)"
      },
      {
        "input": "\"password\", \"salt\", 2",
        "expectedOutput": "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2",
        "isHidden": false,
        "description": "4 iterations (2^2)"
      },
      {
        "input": "\"test123\", \"randomsalt\", 3",
        "expectedOutput": "d7c6b5a49382f1e0d9c8b7a69584f3e2d1c0b9a88776f5e4d3c2b1a09f8e7d6c",
        "isHidden": true,
        "description": "8 iterations (2^3)"
      }
    ],
    "hints": [
      "Calculate iterations as 2^rounds",
      "Apply hash function iteratively",
      "Higher rounds means more computational cost",
      "This makes brute-force attacks slower"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Verify Bcrypt Password",
    "difficulty": 2,
    "description": "Verify a password against a bcrypt hash using the same salt and rounds.",
    "starterCode": "import hashlib\n\ndef verify_bcrypt_password(password, salt, rounds, stored_hash):\n    \"\"\"\n    Verify password against bcrypt hash (simplified).\n\n    Args:\n        password: String password to verify\n        salt: String salt used for original hash\n        rounds: Integer cost factor\n        stored_hash: String hex digest to compare against\n\n    Returns:\n        Boolean: True if password matches\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_bcrypt_password(password, salt, rounds, stored_hash):\n    \"\"\"\n    Verify password against bcrypt hash (simplified).\n\n    Args:\n        password: String password to verify\n        salt: String salt used for original hash\n        rounds: Integer cost factor\n        stored_hash: String hex digest to compare against\n\n    Returns:\n        Boolean: True if password matches\n    \"\"\"\n    # Hash the provided password\n    iterations = 2 ** rounds\n    hashed = (salt + password).encode()\n\n    for _ in range(iterations):\n        hashed = hashlib.sha256(hashed).digest()\n\n    # Compare with stored hash\n    return hashed.hex() == stored_hash",
    "testCases": [
      {
        "input": "\"password\", \"salt\", 4, \"9f4d96c8c9c8f7e6d5c4b3a2918f8e7d6c5b4a39281f9e8d7c6b5a49382f1e0d\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correct password"
      },
      {
        "input": "\"wrongpass\", \"salt\", 4, \"9f4d96c8c9c8f7e6d5c4b3a2918f8e7d6c5b4a39281f9e8d7c6b5a49382f1e0d\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Wrong password"
      },
      {
        "input": "\"test123\", \"randomsalt\", 3, \"d7c6b5a49382f1e0d9c8b7a69584f3e2d1c0b9a88776f5e4d3c2b1a09f8e7d6c\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Correct with different salt/rounds"
      }
    ],
    "hints": [
      "Use same hashing logic as the hash function",
      "Compare computed hash with stored hash",
      "Must use same salt and rounds as original"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "TOTP Code Generator",
    "difficulty": 3,
    "description": "Generate a 6-digit TOTP code from a timestamp and secret. Use simple hash of (secret + timestamp) modulo 1000000.",
    "starterCode": "import hashlib\n\ndef generate_totp(secret, timestamp):\n    \"\"\"\n    Generate TOTP code (simplified educational version).\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer unix timestamp (use timestamp // 30 for 30-sec window)\n\n    Returns:\n        String: 6-digit TOTP code\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef generate_totp(secret, timestamp):\n    \"\"\"\n    Generate TOTP code (simplified educational version).\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer unix timestamp (use timestamp // 30 for 30-sec window)\n\n    Returns:\n        String: 6-digit TOTP code\n    \"\"\"\n    # Use 30-second time window\n    time_counter = timestamp // 30\n\n    # Combine secret and time counter\n    message = f\"{secret}{time_counter}\".encode()\n\n    # Hash the message\n    hash_value = hashlib.sha256(message).digest()\n\n    # Extract last 4 bytes and convert to integer\n    offset = hash_value[-1] & 0x0f\n    code_bytes = hash_value[offset:offset+4]\n    code_int = int.from_bytes(code_bytes, byteorder='big')\n\n    # Get 6-digit code\n    code = code_int % 1000000\n\n    # Return as 6-digit string with leading zeros\n    return str(code).zfill(6)",
    "testCases": [
      {
        "input": "\"SECRETKEY\", 1609459200",
        "expectedOutput": "123456",
        "isHidden": false,
        "description": "Generate TOTP at specific time"
      },
      {
        "input": "\"SECRETKEY\", 1609459230",
        "expectedOutput": "123456",
        "isHidden": false,
        "description": "Same code within 30-sec window"
      },
      {
        "input": "\"SECRETKEY\", 1609459260",
        "expectedOutput": "789012",
        "isHidden": true,
        "description": "Different code in next window"
      },
      {
        "input": "\"DIFFERENTSECRET\", 1609459200",
        "expectedOutput": "654321",
        "isHidden": true,
        "description": "Different secret produces different code"
      }
    ],
    "hints": [
      "Divide timestamp by 30 for time-based counter",
      "Hash the combination of secret and time counter",
      "Extract a portion of hash to generate numeric code",
      "Use modulo 1000000 for 6-digit code",
      "Pad with zeros to ensure 6 digits"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Verify TOTP Code",
    "difficulty": 3,
    "description": "Verify a TOTP code allowing for time drift (check current window and ±1 window).",
    "starterCode": "import hashlib\n\ndef verify_totp(secret, timestamp, provided_code):\n    \"\"\"\n    Verify TOTP code with time drift tolerance.\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer current unix timestamp\n        provided_code: String 6-digit code to verify\n\n    Returns:\n        Boolean: True if code is valid\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_totp(secret, timestamp, provided_code):\n    \"\"\"\n    Verify TOTP code with time drift tolerance.\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer current unix timestamp\n        provided_code: String 6-digit code to verify\n\n    Returns:\n        Boolean: True if code is valid\n    \"\"\"\n    def generate_code(secret, ts):\n        time_counter = ts // 30\n        message = f\"{secret}{time_counter}\".encode()\n        hash_value = hashlib.sha256(message).digest()\n        offset = hash_value[-1] & 0x0f\n        code_bytes = hash_value[offset:offset+4]\n        code_int = int.from_bytes(code_bytes, byteorder='big')\n        code = code_int % 1000000\n        return str(code).zfill(6)\n\n    # Check current window and ±1 window (90 seconds total)\n    for time_offset in [-30, 0, 30]:\n        check_time = timestamp + time_offset\n        if generate_code(secret, check_time) == provided_code:\n            return True\n\n    return False",
    "testCases": [
      {
        "input": "\"SECRETKEY\", 1609459200, \"123456\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Exact match"
      },
      {
        "input": "\"SECRETKEY\", 1609459230, \"123456\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Within time window"
      },
      {
        "input": "\"SECRETKEY\", 1609459200, \"999999\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Wrong code"
      },
      {
        "input": "\"SECRETKEY\", 1609459260, \"123456\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Previous window still valid"
      }
    ],
    "hints": [
      "Generate codes for current time and ±30 seconds",
      "Check if any of these match the provided code",
      "This accounts for clock drift between client and server",
      "Return True if any window matches"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "JWT Payload Decoder",
    "difficulty": 3,
    "description": "Decode JWT payload (middle section). JWT format: header.payload.signature (base64 encoded).",
    "starterCode": "import base64\nimport json\n\ndef decode_jwt_payload(jwt_token):\n    \"\"\"\n    Decode JWT payload section.\n\n    Args:\n        jwt_token: String JWT token\n\n    Returns:\n        Dictionary: decoded payload\n    \"\"\"\n    pass",
    "solution": "import base64\nimport json\n\ndef decode_jwt_payload(jwt_token):\n    \"\"\"\n    Decode JWT payload section.\n\n    Args:\n        jwt_token: String JWT token\n\n    Returns:\n        Dictionary: decoded payload\n    \"\"\"\n    # Split token into parts\n    parts = jwt_token.split('.')\n\n    if len(parts) != 3:\n        return {}\n\n    # Get payload (second part)\n    payload_b64 = parts[1]\n\n    # Add padding if needed (base64 requires length multiple of 4)\n    padding = 4 - (len(payload_b64) % 4)\n    if padding != 4:\n        payload_b64 += '=' * padding\n\n    # Decode base64\n    payload_bytes = base64.b64decode(payload_b64)\n\n    # Parse JSON\n    return json.loads(payload_bytes)",
    "testCases": [
      {
        "input": "\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiIsInJvbGUiOiJhZG1pbiJ9.signature\"",
        "expectedOutput": "{'user': 'john', 'role': 'admin'}",
        "isHidden": false,
        "description": "Decode JWT payload"
      },
      {
        "input": "\"header.eyJzdWIiOiIxMjM0NTY3ODkwIn0.signature\"",
        "expectedOutput": "{'sub': '1234567890'}",
        "isHidden": false,
        "description": "Decode with subject claim"
      },
      {
        "input": "\"a.b.c\"",
        "expectedOutput": "{}",
        "isHidden": true,
        "description": "Invalid JWT returns empty dict"
      }
    ],
    "hints": [
      "JWT has three parts separated by dots",
      "Payload is the middle part",
      "Decode from base64",
      "Add padding if needed (= characters)",
      "Parse as JSON"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "JWT Signature Validator",
    "difficulty": 4,
    "description": "Validate JWT signature using HMAC. Signature is HMAC-SHA256 of \"header.payload\" with secret key.",
    "starterCode": "import base64\nimport hashlib\nimport hmac\n\ndef validate_jwt_signature(jwt_token, secret_key):\n    \"\"\"\n    Validate JWT signature.\n\n    Args:\n        jwt_token: String JWT token\n        secret_key: String secret key for HMAC\n\n    Returns:\n        Boolean: True if signature is valid\n    \"\"\"\n    pass",
    "solution": "import base64\nimport hashlib\nimport hmac\n\ndef validate_jwt_signature(jwt_token, secret_key):\n    \"\"\"\n    Validate JWT signature.\n\n    Args:\n        jwt_token: String JWT token\n        secret_key: String secret key for HMAC\n\n    Returns:\n        Boolean: True if signature is valid\n    \"\"\"\n    parts = jwt_token.split('.')\n\n    if len(parts) != 3:\n        return False\n\n    header, payload, signature = parts\n\n    # Recreate the message that was signed\n    message = f\"{header}.{payload}\"\n\n    # Calculate expected signature\n    expected_sig = hmac.new(\n        secret_key.encode(),\n        message.encode(),\n        hashlib.sha256\n    ).digest()\n\n    # Encode as base64url (without padding)\n    expected_sig_b64 = base64.urlsafe_b64encode(expected_sig).decode().rstrip('=')\n\n    # Compare with provided signature\n    return signature == expected_sig_b64",
    "testCases": [
      {
        "input": "\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.XYZ\", \"secret\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid signature"
      },
      {
        "input": "\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.INVALID\", \"secret\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid signature"
      },
      {
        "input": "\"a.b.c\", \"secret\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Malformed token"
      }
    ],
    "hints": [
      "Split token into header, payload, signature",
      "Recreate message as \"header.payload\"",
      "Calculate HMAC-SHA256 with secret key",
      "Encode result as base64url",
      "Compare with provided signature"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "JWT Expiration Checker",
    "difficulty": 4,
    "description": "Check if JWT is expired by comparing exp claim with current timestamp.",
    "starterCode": "import base64\nimport json\n\ndef is_jwt_expired(jwt_token, current_timestamp):\n    \"\"\"\n    Check if JWT token is expired.\n\n    Args:\n        jwt_token: String JWT token\n        current_timestamp: Integer current unix timestamp\n\n    Returns:\n        Boolean: True if token is expired\n    \"\"\"\n    pass",
    "solution": "import base64\nimport json\n\ndef is_jwt_expired(jwt_token, current_timestamp):\n    \"\"\"\n    Check if JWT token is expired.\n\n    Args:\n        jwt_token: String JWT token\n        current_timestamp: Integer current unix timestamp\n\n    Returns:\n        Boolean: True if token is expired\n    \"\"\"\n    try:\n        # Decode payload\n        parts = jwt_token.split('.')\n        if len(parts) != 3:\n            return True\n\n        payload_b64 = parts[1]\n        padding = 4 - (len(payload_b64) % 4)\n        if padding != 4:\n            payload_b64 += '=' * padding\n\n        payload_bytes = base64.b64decode(payload_b64)\n        payload = json.loads(payload_bytes)\n\n        # Check exp claim\n        if 'exp' not in payload:\n            return False  # No expiration claim\n\n        return current_timestamp > payload['exp']\n\n    except:\n        return True  # Error means invalid/expired",
    "testCases": [
      {
        "input": "\"header.eyJleHAiOjE2MDk0NTkyMDB9.signature\", 1609459100",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not yet expired"
      },
      {
        "input": "\"header.eyJleHAiOjE2MDk0NTkyMDB9.signature\", 1609459300",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Expired token"
      },
      {
        "input": "\"header.eyJ1c2VyIjoiam9obiJ9.signature\", 1609459200",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No exp claim means not expired"
      },
      {
        "input": "\"invalid\", 1609459200",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Invalid token considered expired"
      }
    ],
    "hints": [
      "Decode the JWT payload",
      "Extract the exp (expiration) claim",
      "Compare exp with current timestamp",
      "Token is expired if current time > exp",
      "Handle missing exp claim gracefully"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Role-Based Access Control",
    "difficulty": 4,
    "description": "Check if user has required role for accessing a resource.",
    "starterCode": "def check_rbac_access(user_roles, required_role):\n    \"\"\"\n    Check if user has required role.\n\n    Args:\n        user_roles: List of user's roles\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user has required role\n    \"\"\"\n    pass",
    "solution": "def check_rbac_access(user_roles, required_role):\n    \"\"\"\n    Check if user has required role.\n\n    Args:\n        user_roles: List of user's roles\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user has required role\n    \"\"\"\n    return required_role in user_roles",
    "testCases": [
      {
        "input": "['user', 'admin'], 'admin'",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "User has admin role"
      },
      {
        "input": "['user'], 'admin'",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "User lacks admin role"
      },
      {
        "input": "['editor', 'viewer'], 'editor'",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Has required role"
      },
      {
        "input": "[], 'user'",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No roles assigned"
      }
    ],
    "hints": [
      "Simply check if required role is in user roles list",
      "Use the \"in\" operator"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Hierarchical RBAC",
    "difficulty": 4,
    "description": "Implement hierarchical RBAC where admin > editor > viewer. Higher roles inherit lower role permissions.",
    "starterCode": "def check_hierarchical_rbac(user_role, required_role):\n    \"\"\"\n    Check access with role hierarchy.\n\n    Args:\n        user_role: String user's role\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user role >= required role in hierarchy\n    \"\"\"\n    pass",
    "solution": "def check_hierarchical_rbac(user_role, required_role):\n    \"\"\"\n    Check access with role hierarchy.\n\n    Args:\n        user_role: String user's role\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user role >= required role in hierarchy\n    \"\"\"\n    # Define role hierarchy (higher number = more privileges)\n    hierarchy = {\n        'viewer': 1,\n        'editor': 2,\n        'admin': 3\n    }\n\n    user_level = hierarchy.get(user_role, 0)\n    required_level = hierarchy.get(required_role, 0)\n\n    return user_level >= required_level",
    "testCases": [
      {
        "input": "\"admin\", \"viewer\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Admin can access viewer resources"
      },
      {
        "input": "\"viewer\", \"admin\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Viewer cannot access admin resources"
      },
      {
        "input": "\"editor\", \"editor\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Same role has access"
      },
      {
        "input": "\"editor\", \"viewer\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Editor can access viewer resources"
      },
      {
        "input": "\"unknown\", \"viewer\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Unknown role denied"
      }
    ],
    "hints": [
      "Define role hierarchy with numeric levels",
      "Higher numbers mean higher privileges",
      "User must have level >= required level",
      "Admin inherits all lower permissions"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Session Token Generator",
    "difficulty": 4,
    "description": "Generate a secure random session token using cryptographic random bytes.",
    "starterCode": "import secrets\n\ndef generate_session_token(length):\n    \"\"\"\n    Generate cryptographically secure session token.\n\n    Args:\n        length: Integer number of bytes (token will be hex, so 2x length)\n\n    Returns:\n        String: hex session token\n    \"\"\"\n    pass",
    "solution": "import secrets\n\ndef generate_session_token(length):\n    \"\"\"\n    Generate cryptographically secure session token.\n\n    Args:\n        length: Integer number of bytes (token will be hex, so 2x length)\n\n    Returns:\n        String: hex session token\n    \"\"\"\n    return secrets.token_hex(length)",
    "testCases": [
      {
        "input": "16",
        "expectedOutput": "32_chars",
        "isHidden": false,
        "description": "16 bytes = 32 hex chars"
      },
      {
        "input": "32",
        "expectedOutput": "64_chars",
        "isHidden": false,
        "description": "32 bytes = 64 hex chars"
      },
      {
        "input": "8",
        "expectedOutput": "16_chars",
        "isHidden": true,
        "description": "8 bytes = 16 hex chars"
      }
    ],
    "hints": [
      "Use secrets module for cryptographic randomness",
      "secrets.token_hex generates random hex string",
      "Output length is 2x input (each byte = 2 hex chars)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Session Expiration Manager",
    "difficulty": 5,
    "description": "Manage session expiration. Check if session is expired based on creation time and max age.",
    "starterCode": "def is_session_expired(created_at, current_time, max_age_seconds):\n    \"\"\"\n    Check if session has expired.\n\n    Args:\n        created_at: Integer timestamp when session created\n        current_time: Integer current timestamp\n        max_age_seconds: Integer maximum session age\n\n    Returns:\n        Boolean: True if session expired\n    \"\"\"\n    pass",
    "solution": "def is_session_expired(created_at, current_time, max_age_seconds):\n    \"\"\"\n    Check if session has expired.\n\n    Args:\n        created_at: Integer timestamp when session created\n        current_time: Integer current timestamp\n        max_age_seconds: Integer maximum session age\n\n    Returns:\n        Boolean: True if session expired\n    \"\"\"\n    age = current_time - created_at\n    return age > max_age_seconds",
    "testCases": [
      {
        "input": "1609459200, 1609459500, 600",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "300 seconds old, max 600 - not expired"
      },
      {
        "input": "1609459200, 1609460000, 600",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "800 seconds old, max 600 - expired"
      },
      {
        "input": "1609459200, 1609459800, 600",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Exactly at limit"
      },
      {
        "input": "1609459200, 1609459801, 600",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "One second over limit"
      }
    ],
    "hints": [
      "Calculate session age: current_time - created_at",
      "Compare age with max_age_seconds",
      "Session expired if age > max age"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Attribute-Based Access Control (ABAC)",
    "difficulty": 5,
    "description": "Implement ABAC that checks multiple attributes (role, department, clearance level) for access.",
    "starterCode": "def check_abac_access(user_attrs, required_attrs):\n    \"\"\"\n    Check access based on attributes.\n\n    Args:\n        user_attrs: Dictionary of user attributes\n        required_attrs: Dictionary of required attributes\n\n    Returns:\n        Boolean: True if user meets all requirements\n    \"\"\"\n    pass",
    "solution": "def check_abac_access(user_attrs, required_attrs):\n    \"\"\"\n    Check access based on attributes.\n\n    Args:\n        user_attrs: Dictionary of user attributes\n        required_attrs: Dictionary of required attributes\n\n    Returns:\n        Boolean: True if user meets all requirements\n    \"\"\"\n    for key, required_value in required_attrs.items():\n        # Check if user has the attribute\n        if key not in user_attrs:\n            return False\n\n        # Check if value matches (or is in list if multiple values allowed)\n        user_value = user_attrs[key]\n        if isinstance(required_value, list):\n            if user_value not in required_value:\n                return False\n        else:\n            if user_value != required_value:\n                return False\n\n    return True",
    "testCases": [
      {
        "input": "{'role': 'admin', 'dept': 'IT'}, {'role': 'admin'}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Has required role"
      },
      {
        "input": "{'role': 'user', 'dept': 'IT'}, {'role': 'admin'}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing required role"
      },
      {
        "input": "{'role': 'admin', 'dept': 'IT', 'clearance': 3}, {'role': 'admin', 'dept': 'IT'}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Meets multiple requirements"
      },
      {
        "input": "{'role': 'editor', 'dept': 'IT'}, {'role': ['admin', 'editor']}",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Role in allowed list"
      },
      {
        "input": "{'dept': 'Sales'}, {'dept': 'IT'}",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Wrong department"
      }
    ],
    "hints": [
      "Check each required attribute exists in user attributes",
      "Handle both single values and lists of allowed values",
      "All requirements must be met",
      "Use isinstance to check for lists"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Multi-Factor Authentication Validator",
    "difficulty": 5,
    "description": "Validate MFA by checking both password hash and TOTP code.",
    "starterCode": "import hashlib\n\ndef validate_mfa(password, password_hash, totp_code, secret, timestamp):\n    \"\"\"\n    Validate multi-factor authentication.\n\n    Args:\n        password: String password\n        password_hash: String stored password hash\n        totp_code: String 6-digit TOTP code\n        secret: String TOTP secret\n        timestamp: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef validate_mfa(password, password_hash, totp_code, secret, timestamp):\n    \"\"\"\n    Validate multi-factor authentication.\n\n    Args:\n        password: String password\n        password_hash: String stored password hash\n        totp_code: String 6-digit TOTP code\n        secret: String TOTP secret\n        timestamp: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    # Validate password\n    computed_hash = hashlib.sha256(password.encode()).hexdigest()\n    if computed_hash != password_hash:\n        return {\n            'valid': False,\n            'reason': 'Invalid password'\n        }\n\n    # Validate TOTP\n    def generate_totp(secret, ts):\n        time_counter = ts // 30\n        message = f\"{secret}{time_counter}\".encode()\n        hash_value = hashlib.sha256(message).digest()\n        offset = hash_value[-1] & 0x0f\n        code_bytes = hash_value[offset:offset+4]\n        code_int = int.from_bytes(code_bytes, byteorder='big')\n        code = code_int % 1000000\n        return str(code).zfill(6)\n\n    # Check TOTP with time drift tolerance\n    valid_totp = False\n    for time_offset in [-30, 0, 30]:\n        check_time = timestamp + time_offset\n        if generate_totp(secret, check_time) == totp_code:\n            valid_totp = True\n            break\n\n    if not valid_totp:\n        return {\n            'valid': False,\n            'reason': 'Invalid TOTP code'\n        }\n\n    return {\n        'valid': True,\n        'reason': 'Authentication successful'\n    }",
    "testCases": [
      {
        "input": "\"password\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\", \"123456\", \"SECRET\", 1609459200",
        "expectedOutput": "{'valid': True, 'reason': 'Authentication successful'}",
        "isHidden": false,
        "description": "Valid MFA"
      },
      {
        "input": "\"wrongpass\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\", \"123456\", \"SECRET\", 1609459200",
        "expectedOutput": "{'valid': False, 'reason': 'Invalid password'}",
        "isHidden": false,
        "description": "Wrong password"
      },
      {
        "input": "\"password\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\", \"999999\", \"SECRET\", 1609459200",
        "expectedOutput": "{'valid': False, 'reason': 'Invalid TOTP code'}",
        "isHidden": true,
        "description": "Wrong TOTP"
      }
    ],
    "hints": [
      "Validate password first",
      "Then validate TOTP code",
      "Both must be correct for successful authentication",
      "Return appropriate reason for failure"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "OAuth State Parameter Validator",
    "difficulty": 5,
    "description": "Validate OAuth state parameter to prevent CSRF. State should be random token that matches stored value.",
    "starterCode": "def validate_oauth_state(received_state, stored_state, max_age_seconds, created_at, current_time):\n    \"\"\"\n    Validate OAuth state parameter.\n\n    Args:\n        received_state: String state from OAuth callback\n        stored_state: String state stored in session\n        max_age_seconds: Integer max age for state token\n        created_at: Integer timestamp when state was created\n        current_time: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "def validate_oauth_state(received_state, stored_state, max_age_seconds, created_at, current_time):\n    \"\"\"\n    Validate OAuth state parameter.\n\n    Args:\n        received_state: String state from OAuth callback\n        stored_state: String state stored in session\n        max_age_seconds: Integer max age for state token\n        created_at: Integer timestamp when state was created\n        current_time: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    # Check if state tokens match\n    if received_state != stored_state:\n        return {\n            'valid': False,\n            'reason': 'State mismatch - possible CSRF attack'\n        }\n\n    # Check if state token has expired\n    age = current_time - created_at\n    if age > max_age_seconds:\n        return {\n            'valid': False,\n            'reason': 'State token expired'\n        }\n\n    return {\n        'valid': True,\n        'reason': 'State valid'\n    }",
    "testCases": [
      {
        "input": "\"abc123\", \"abc123\", 300, 1609459200, 1609459300",
        "expectedOutput": "{'valid': True, 'reason': 'State valid'}",
        "isHidden": false,
        "description": "Valid state"
      },
      {
        "input": "\"abc123\", \"xyz789\", 300, 1609459200, 1609459300",
        "expectedOutput": "{'valid': False, 'reason': 'State mismatch - possible CSRF attack'}",
        "isHidden": false,
        "description": "State mismatch"
      },
      {
        "input": "\"abc123\", \"abc123\", 300, 1609459200, 1609459600",
        "expectedOutput": "{'valid': False, 'reason': 'State token expired'}",
        "isHidden": true,
        "description": "Expired state"
      }
    ],
    "hints": [
      "First check if received and stored states match",
      "Then check if state has not expired",
      "State tokens prevent CSRF attacks in OAuth flows",
      "Both checks must pass for valid state"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Basic Input Sanitization",
    "difficulty": 1,
    "description": "Sanitize user input by removing HTML tags using a simple approach.",
    "starterCode": "import re\n\ndef sanitize_html(user_input):\n    \"\"\"\n    Remove HTML tags from user input.\n\n    Args:\n        user_input: String that may contain HTML tags\n\n    Returns:\n        String: sanitized input with HTML tags removed\n    \"\"\"\n    pass",
    "solution": "import re\n\ndef sanitize_html(user_input):\n    \"\"\"\n    Remove HTML tags from user input.\n\n    Args:\n        user_input: String that may contain HTML tags\n\n    Returns:\n        String: sanitized input with HTML tags removed\n    \"\"\"\n    # Remove HTML tags using regex\n    return re.sub(r'<[^>]+>', '', user_input)",
    "testCases": [
      {
        "input": "\"Hello <script>alert(1)</script> World\"",
        "expectedOutput": "Hello alert(1) World",
        "isHidden": false,
        "description": "Remove script tag"
      },
      {
        "input": "\"<b>Bold</b> text\"",
        "expectedOutput": "Bold text",
        "isHidden": false,
        "description": "Remove formatting tags"
      },
      {
        "input": "\"Plain text\"",
        "expectedOutput": "Plain text",
        "isHidden": false,
        "description": "No tags to remove"
      },
      {
        "input": "\"<img src=x onerror=alert(1)>\"",
        "expectedOutput": "",
        "isHidden": true,
        "description": "Remove malicious img tag"
      }
    ],
    "hints": [
      "Use regex to match HTML tags",
      "Pattern: <...> matches opening and closing tags",
      "Replace all matches with empty string"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Escape HTML Special Characters",
    "difficulty": 2,
    "description": "Escape HTML special characters to prevent XSS: < > & \" ' ",
    "starterCode": "def escape_html(text):\n    \"\"\"\n    Escape HTML special characters.\n\n    Args:\n        text: String that may contain special characters\n\n    Returns:\n        String: escaped text safe for HTML output\n    \"\"\"\n    pass",
    "solution": "def escape_html(text):\n    \"\"\"\n    Escape HTML special characters.\n\n    Args:\n        text: String that may contain special characters\n\n    Returns:\n        String: escaped text safe for HTML output\n    \"\"\"\n    replacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;'\n    }\n\n    for char, escaped in replacements.items():\n        text = text.replace(char, escaped)\n\n    return text",
    "testCases": [
      {
        "input": "\"<script>alert(1)</script>\"",
        "expectedOutput": "&lt;script&gt;alert(1)&lt;/script&gt;",
        "isHidden": false,
        "description": "Escape script tag"
      },
      {
        "input": "\"Hello & Goodbye\"",
        "expectedOutput": "Hello &amp; Goodbye",
        "isHidden": false,
        "description": "Escape ampersand"
      },
      {
        "input": "\"\\\"quoted\\\"\"",
        "expectedOutput": "&quot;quoted&quot;",
        "isHidden": false,
        "description": "Escape quotes"
      },
      {
        "input": "\"<img src=\\\"x\\\" onerror=\\\"alert(1)\\\">\"",
        "expectedOutput": "&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;",
        "isHidden": true,
        "description": "Escape complex XSS attempt"
      }
    ],
    "hints": [
      "Replace each special character with HTML entity",
      "Order matters: escape & first",
      "Common entities: &lt; &gt; &amp; &quot; &#x27;"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Validate Email Format",
    "difficulty": 2,
    "description": "Validate email format using a simple pattern check.",
    "starterCode": "import re\n\ndef validate_email(email):\n    \"\"\"\n    Validate email format.\n\n    Args:\n        email: String email address\n\n    Returns:\n        Boolean: True if valid format\n    \"\"\"\n    pass",
    "solution": "import re\n\ndef validate_email(email):\n    \"\"\"\n    Validate email format.\n\n    Args:\n        email: String email address\n\n    Returns:\n        Boolean: True if valid format\n    \"\"\"\n    # Simple email validation pattern\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))",
    "testCases": [
      {
        "input": "\"user@example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid email"
      },
      {
        "input": "\"invalid.email\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing @"
      },
      {
        "input": "\"user@domain\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing TLD"
      },
      {
        "input": "\"user+tag@example.co.uk\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Valid with plus and multiple dots"
      },
      {
        "input": "\"@example.com\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Missing local part"
      }
    ],
    "hints": [
      "Pattern: localpart@domain.tld",
      "Allow alphanumeric, dots, hyphens, etc.",
      "Must have @ symbol",
      "Domain must have at least one dot"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "SQL Injection Prevention - Parameterized Query",
    "difficulty": 3,
    "description": "Build a safe parameterized SQL query instead of string concatenation. Return the query and parameters separately.",
    "starterCode": "def build_safe_query(table, username):\n    \"\"\"\n    Build parameterized SQL query.\n\n    Args:\n        table: String table name\n        username: String username value\n\n    Returns:\n        Dictionary with 'query' (string with placeholder) and 'params' (tuple)\n    \"\"\"\n    pass",
    "solution": "def build_safe_query(table, username):\n    \"\"\"\n    Build parameterized SQL query.\n\n    Args:\n        table: String table name\n        username: String username value\n\n    Returns:\n        Dictionary with 'query' (string with placeholder) and 'params' (tuple)\n    \"\"\"\n    # Use parameterized query with placeholder\n    # Note: table name should be validated separately, not parameterized\n    query = f\"SELECT * FROM {table} WHERE username = ?\"\n    params = (username,)\n\n    return {\n        'query': query,\n        'params': params\n    }",
    "testCases": [
      {
        "input": "\"users\", \"john\"",
        "expectedOutput": "{'query': 'SELECT * FROM users WHERE username = ?', 'params': ('john',)}",
        "isHidden": false,
        "description": "Safe parameterized query"
      },
      {
        "input": "\"accounts\", \"admin\"",
        "expectedOutput": "{'query': 'SELECT * FROM accounts WHERE username = ?', 'params': ('admin',)}",
        "isHidden": false,
        "description": "Different table"
      },
      {
        "input": "\"users\", \"admin' OR '1'='1\"",
        "expectedOutput": "{\"query\": \"SELECT * FROM users WHERE username = ?\", \"params\": (\"admin' OR '1'='1\",)}",
        "isHidden": true,
        "description": "SQL injection attempt safely parameterized"
      }
    ],
    "hints": [
      "Use ? as placeholder for parameter",
      "Return query string and params separately",
      "Database driver handles escaping automatically",
      "Never concatenate user input into SQL"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Detect SQL Injection Attempt",
    "difficulty": 3,
    "description": "Detect potential SQL injection by looking for suspicious patterns in user input.",
    "starterCode": "def detect_sql_injection(user_input):\n    \"\"\"\n    Detect potential SQL injection patterns.\n\n    Args:\n        user_input: String user input\n\n    Returns:\n        Boolean: True if suspicious patterns detected\n    \"\"\"\n    pass",
    "solution": "def detect_sql_injection(user_input):\n    \"\"\"\n    Detect potential SQL injection patterns.\n\n    Args:\n        user_input: String user input\n\n    Returns:\n        Boolean: True if suspicious patterns detected\n    \"\"\"\n    user_input_lower = user_input.lower()\n\n    # Common SQL injection patterns\n    suspicious_patterns = [\n        \"' or '\",\n        '\" or \"',\n        \"' or 1=1\",\n        '\" or 1=1',\n        'union select',\n        'drop table',\n        'delete from',\n        'insert into',\n        'update ',\n        '--',\n        ';--',\n        'xp_',\n        'sp_'\n    ]\n\n    for pattern in suspicious_patterns:\n        if pattern in user_input_lower:\n            return True\n\n    return False",
    "testCases": [
      {
        "input": "\"john\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Normal input"
      },
      {
        "input": "\"admin' OR '1'='1\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Classic SQL injection"
      },
      {
        "input": "\"user; DROP TABLE users--\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "DROP TABLE attack"
      },
      {
        "input": "\"user UNION SELECT password FROM accounts\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "UNION attack"
      },
      {
        "input": "\"normal_username_123\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Safe input"
      }
    ],
    "hints": [
      "Look for SQL keywords like OR, UNION, DROP",
      "Check for quote characters in suspicious contexts",
      "Look for SQL comments (--)",
      "Convert to lowercase for case-insensitive matching"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Path Traversal Prevention",
    "difficulty": 3,
    "description": "Validate file path to prevent directory traversal attacks. Reject paths containing .. or absolute paths.",
    "starterCode": "import os\n\ndef is_safe_path(base_dir, user_path):\n    \"\"\"\n    Check if file path is safe (no directory traversal).\n\n    Args:\n        base_dir: String base directory path\n        user_path: String user-provided path\n\n    Returns:\n        Boolean: True if path is safe\n    \"\"\"\n    pass",
    "solution": "import os\n\ndef is_safe_path(base_dir, user_path):\n    \"\"\"\n    Check if file path is safe (no directory traversal).\n\n    Args:\n        base_dir: String base directory path\n        user_path: String user-provided path\n\n    Returns:\n        Boolean: True if path is safe\n    \"\"\"\n    # Reject absolute paths\n    if os.path.isabs(user_path):\n        return False\n\n    # Reject paths with .. (parent directory)\n    if '..' in user_path:\n        return False\n\n    # Normalize and check if path stays within base_dir\n    full_path = os.path.normpath(os.path.join(base_dir, user_path))\n    return full_path.startswith(os.path.normpath(base_dir))",
    "testCases": [
      {
        "input": "\"/var/www/files\", \"document.pdf\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe relative path"
      },
      {
        "input": "\"/var/www/files\", \"../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Directory traversal attempt"
      },
      {
        "input": "\"/var/www/files\", \"/etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Absolute path rejected"
      },
      {
        "input": "\"/var/www/files\", \"subdir/file.txt\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Safe subdirectory path"
      },
      {
        "input": "\"/var/www/files\", \"subdir/../../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Traversal in middle of path"
      }
    ],
    "hints": [
      "Reject absolute paths (starting with /)",
      "Reject paths containing ..",
      "Normalize paths and verify they stay within base directory",
      "Use os.path functions for proper path handling"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "XSS Prevention - Content Security Policy",
    "difficulty": 3,
    "description": "Generate a Content Security Policy header to prevent XSS attacks.",
    "starterCode": "def generate_csp_header(allow_inline_scripts=False):\n    \"\"\"\n    Generate Content-Security-Policy header.\n\n    Args:\n        allow_inline_scripts: Boolean whether to allow inline scripts\n\n    Returns:\n        String: CSP header value\n    \"\"\"\n    pass",
    "solution": "def generate_csp_header(allow_inline_scripts=False):\n    \"\"\"\n    Generate Content-Security-Policy header.\n\n    Args:\n        allow_inline_scripts: Boolean whether to allow inline scripts\n\n    Returns:\n        String: CSP header value\n    \"\"\"\n    # Default to strict policy\n    script_src = \"'self'\"\n\n    if allow_inline_scripts:\n        # Less secure: allow inline scripts\n        script_src = \"'self' 'unsafe-inline'\"\n\n    csp = f\"default-src 'self'; script-src {script_src}; style-src 'self' 'unsafe-inline'; img-src 'self' data:\"\n\n    return csp",
    "testCases": [
      {
        "input": "False",
        "expectedOutput": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:",
        "isHidden": false,
        "description": "Strict CSP"
      },
      {
        "input": "True",
        "expectedOutput": "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:",
        "isHidden": false,
        "description": "CSP with inline scripts"
      }
    ],
    "hints": [
      "CSP restricts where resources can be loaded from",
      "Use 'self' to allow same origin",
      "'unsafe-inline' allows inline scripts (less secure)",
      "Separate directives with semicolons"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Validate URL Scheme",
    "difficulty": 3,
    "description": "Validate URL has safe scheme (http/https) to prevent javascript: URLs and other attacks.",
    "starterCode": "from urllib.parse import urlparse\n\ndef is_safe_url(url):\n    \"\"\"\n    Check if URL has safe scheme.\n\n    Args:\n        url: String URL\n\n    Returns:\n        Boolean: True if URL scheme is safe (http/https)\n    \"\"\"\n    pass",
    "solution": "from urllib.parse import urlparse\n\ndef is_safe_url(url):\n    \"\"\"\n    Check if URL has safe scheme.\n\n    Args:\n        url: String URL\n\n    Returns:\n        Boolean: True if URL scheme is safe (http/https)\n    \"\"\"\n    try:\n        parsed = urlparse(url)\n        return parsed.scheme in ['http', 'https']\n    except:\n        return False",
    "testCases": [
      {
        "input": "\"https://example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe HTTPS URL"
      },
      {
        "input": "\"http://example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe HTTP URL"
      },
      {
        "input": "\"javascript:alert(1)\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Dangerous javascript: URL"
      },
      {
        "input": "\"data:text/html,<script>alert(1)</script>\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Dangerous data: URL"
      },
      {
        "input": "\"ftp://files.example.com\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "FTP not in whitelist"
      }
    ],
    "hints": [
      "Parse URL to extract scheme",
      "Only allow http and https schemes",
      "Reject javascript:, data:, file:, etc.",
      "Handle parsing errors gracefully"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "CSRF Token Generator",
    "difficulty": 4,
    "description": "Generate a CSRF token using cryptographically secure random bytes.",
    "starterCode": "import secrets\n\ndef generate_csrf_token():\n    \"\"\"\n    Generate CSRF token.\n\n    Returns:\n        String: hex CSRF token\n    \"\"\"\n    pass",
    "solution": "import secrets\n\ndef generate_csrf_token():\n    \"\"\"\n    Generate CSRF token.\n\n    Returns:\n        String: hex CSRF token\n    \"\"\"\n    # Generate 32 bytes (256 bits) of random data\n    return secrets.token_hex(32)",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "64_chars",
        "isHidden": false,
        "description": "Token is 64 hex characters"
      }
    ],
    "hints": [
      "Use secrets module for cryptographic randomness",
      "Generate at least 32 bytes",
      "Return as hex string",
      "Token should be unpredictable"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "CSRF Token Validator",
    "difficulty": 4,
    "description": "Validate CSRF token by comparing submitted token with stored token.",
    "starterCode": "def validate_csrf_token(submitted_token, stored_token):\n    \"\"\"\n    Validate CSRF token.\n\n    Args:\n        submitted_token: String token from form/request\n        stored_token: String token from session\n\n    Returns:\n        Boolean: True if tokens match\n    \"\"\"\n    pass",
    "solution": "def validate_csrf_token(submitted_token, stored_token):\n    \"\"\"\n    Validate CSRF token.\n\n    Args:\n        submitted_token: String token from form/request\n        stored_token: String token from session\n\n    Returns:\n        Boolean: True if tokens match\n    \"\"\"\n    # Use constant-time comparison to prevent timing attacks\n    if not submitted_token or not stored_token:\n        return False\n\n    if len(submitted_token) != len(stored_token):\n        return False\n\n    # Simple constant-time comparison\n    result = 0\n    for a, b in zip(submitted_token, stored_token):\n        result |= ord(a) ^ ord(b)\n\n    return result == 0",
    "testCases": [
      {
        "input": "\"abc123def456\", \"abc123def456\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Matching tokens"
      },
      {
        "input": "\"abc123def456\", \"xyz789\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Different tokens"
      },
      {
        "input": "\"\", \"abc123\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty submitted token"
      },
      {
        "input": "\"abc123\", \"\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty stored token"
      }
    ],
    "hints": [
      "Compare tokens for exact match",
      "Use constant-time comparison to prevent timing attacks",
      "Check for empty tokens",
      "XOR can be used for constant-time comparison"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Whitelist Input Validator",
    "difficulty": 4,
    "description": "Validate input against a whitelist of allowed values (more secure than blacklist).",
    "starterCode": "def validate_with_whitelist(user_input, allowed_values):\n    \"\"\"\n    Validate input against whitelist.\n\n    Args:\n        user_input: String user input\n        allowed_values: List of allowed string values\n\n    Returns:\n        Boolean: True if input is in whitelist\n    \"\"\"\n    pass",
    "solution": "def validate_with_whitelist(user_input, allowed_values):\n    \"\"\"\n    Validate input against whitelist.\n\n    Args:\n        user_input: String user input\n        allowed_values: List of allowed string values\n\n    Returns:\n        Boolean: True if input is in whitelist\n    \"\"\"\n    return user_input in allowed_values",
    "testCases": [
      {
        "input": "\"admin\", [\"user\", \"admin\", \"guest\"]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Value in whitelist"
      },
      {
        "input": "\"superadmin\", [\"user\", \"admin\", \"guest\"]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Value not in whitelist"
      },
      {
        "input": "\"user\", [\"user\"]",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Single item whitelist"
      },
      {
        "input": "\"hacker\", []",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty whitelist"
      }
    ],
    "hints": [
      "Simply check if input is in allowed list",
      "Whitelist is more secure than blacklist",
      "Only explicitly allowed values pass"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Safe Filename Validator",
    "difficulty": 4,
    "description": "Validate uploaded filename is safe - only alphanumeric, dots, underscores, and hyphens.",
    "starterCode": "import re\n\ndef is_safe_filename(filename):\n    \"\"\"\n    Validate filename is safe.\n\n    Args:\n        filename: String filename\n\n    Returns:\n        Boolean: True if filename is safe\n    \"\"\"\n    pass",
    "solution": "import re\n\ndef is_safe_filename(filename):\n    \"\"\"\n    Validate filename is safe.\n\n    Args:\n        filename: String filename\n\n    Returns:\n        Boolean: True if filename is safe\n    \"\"\"\n    # Reject empty or very long filenames\n    if not filename or len(filename) > 255:\n        return False\n\n    # Reject directory traversal attempts\n    if '..' in filename or '/' in filename or '\\\\' in filename:\n        return False\n\n    # Only allow alphanumeric, dots, underscores, hyphens\n    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):\n        return False\n\n    # Reject filenames starting with dot (hidden files)\n    if filename.startswith('.'):\n        return False\n\n    return True",
    "testCases": [
      {
        "input": "\"document.pdf\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe filename"
      },
      {
        "input": "\"../../../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Directory traversal"
      },
      {
        "input": "\".htaccess\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Hidden file"
      },
      {
        "input": "\"my_file-2024.txt\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Safe with underscore and hyphen"
      },
      {
        "input": "\"malicious<script>.exe\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Contains special characters"
      }
    ],
    "hints": [
      "Allow only alphanumeric, dots, underscores, hyphens",
      "Reject path separators (/, \\)",
      "Reject .. (directory traversal)",
      "Reject hidden files (starting with dot)",
      "Check length limits"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Command Injection Prevention",
    "difficulty": 5,
    "description": "Safely execute a command with user input by using argument list instead of shell string.",
    "starterCode": "def build_safe_command(base_command, user_arg):\n    \"\"\"\n    Build safe command with user argument.\n\n    Args:\n        base_command: String base command (e.g., 'ls')\n        user_arg: String user-provided argument\n\n    Returns:\n        List: command as list of arguments (safe for subprocess)\n    \"\"\"\n    pass",
    "solution": "def build_safe_command(base_command, user_arg):\n    \"\"\"\n    Build safe command with user argument.\n\n    Args:\n        base_command: String base command (e.g., 'ls')\n        user_arg: String user-provided argument\n\n    Returns:\n        List: command as list of arguments (safe for subprocess)\n    \"\"\"\n    # Return as list - subprocess will NOT use shell\n    # This prevents command injection\n    return [base_command, user_arg]",
    "testCases": [
      {
        "input": "\"ls\", \"/home/user\"",
        "expectedOutput": "['ls', '/home/user']",
        "isHidden": false,
        "description": "Safe command list"
      },
      {
        "input": "\"cat\", \"file.txt\"",
        "expectedOutput": "['cat', 'file.txt']",
        "isHidden": false,
        "description": "Cat command"
      },
      {
        "input": "\"ls\", \"/home; rm -rf /\"",
        "expectedOutput": "['ls', '/home; rm -rf /']",
        "isHidden": true,
        "description": "Injection attempt safely escaped"
      }
    ],
    "hints": [
      "Return command as list, not string",
      "First element is command, rest are arguments",
      "subprocess with list prevents shell injection",
      "Shell metacharacters treated as literal when using list"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "XML External Entity (XXE) Prevention",
    "difficulty": 5,
    "description": "Safely parse XML by disabling external entity resolution.",
    "starterCode": "import xml.etree.ElementTree as ET\n\ndef safe_parse_xml(xml_string):\n    \"\"\"\n    Safely parse XML with XXE prevention.\n\n    Args:\n        xml_string: String XML content\n\n    Returns:\n        Dictionary: parsed data or error message\n    \"\"\"\n    pass",
    "solution": "import xml.etree.ElementTree as ET\n\ndef safe_parse_xml(xml_string):\n    \"\"\"\n    Safely parse XML with XXE prevention.\n\n    Args:\n        xml_string: String XML content\n\n    Returns:\n        Dictionary: parsed data or error message\n    \"\"\"\n    try:\n        # Parse XML (ElementTree has XXE protection by default in Python 3.8+)\n        # For older versions, use defusedxml library\n\n        # Check for DOCTYPE declarations (potential XXE)\n        if '<!DOCTYPE' in xml_string or '<!ENTITY' in xml_string:\n            return {'error': 'DOCTYPE/ENTITY declarations not allowed'}\n\n        root = ET.fromstring(xml_string)\n\n        # Return root tag and text as simple example\n        return {\n            'tag': root.tag,\n            'text': root.text or '',\n            'children': len(list(root))\n        }\n    except ET.ParseError:\n        return {'error': 'Invalid XML'}",
    "testCases": [
      {
        "input": "\"<root>Hello</root>\"",
        "expectedOutput": "{'tag': 'root', 'text': 'Hello', 'children': 0}",
        "isHidden": false,
        "description": "Safe XML"
      },
      {
        "input": "\"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root>&xxe;</root>\"",
        "expectedOutput": "{'error': 'DOCTYPE/ENTITY declarations not allowed'}",
        "isHidden": false,
        "description": "XXE attack blocked"
      },
      {
        "input": "\"<root><child>Test</child></root>\"",
        "expectedOutput": "{'tag': 'root', 'text': '', 'children': 1}",
        "isHidden": true,
        "description": "XML with children"
      }
    ],
    "hints": [
      "Check for DOCTYPE and ENTITY declarations",
      "Reject XML with external entity definitions",
      "Use defusedxml library for better protection",
      "Modern ElementTree has some built-in protections"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Security Headers Generator",
    "difficulty": 5,
    "description": "Generate comprehensive security headers to protect against common vulnerabilities.",
    "starterCode": "def generate_security_headers():\n    \"\"\"\n    Generate security headers for HTTP response.\n\n    Returns:\n        Dictionary: security headers\n    \"\"\"\n    pass",
    "solution": "def generate_security_headers():\n    \"\"\"\n    Generate security headers for HTTP response.\n\n    Returns:\n        Dictionary: security headers\n    \"\"\"\n    return {\n        # Prevent clickjacking\n        'X-Frame-Options': 'DENY',\n\n        # Enable browser XSS protection\n        'X-XSS-Protection': '1; mode=block',\n\n        # Prevent MIME sniffing\n        'X-Content-Type-Options': 'nosniff',\n\n        # Force HTTPS\n        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n\n        # Content Security Policy\n        'Content-Security-Policy': \"default-src 'self'; script-src 'self'\",\n\n        # Referrer policy\n        'Referrer-Policy': 'strict-origin-when-cross-origin',\n\n        # Permissions policy\n        'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'\n    }",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "{'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'X-Content-Type-Options': 'nosniff', 'Strict-Transport-Security': 'max-age=31536000; includeSubDomains', 'Content-Security-Policy': \"default-src 'self'; script-src 'self'\", 'Referrer-Policy': 'strict-origin-when-cross-origin', 'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'}",
        "isHidden": false,
        "description": "All security headers"
      }
    ],
    "hints": [
      "X-Frame-Options prevents clickjacking",
      "X-Content-Type-Options prevents MIME sniffing",
      "Strict-Transport-Security enforces HTTPS",
      "CSP restricts resource loading",
      "Include multiple protective headers"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Input Length Validator",
    "difficulty": 5,
    "description": "Validate input length to prevent buffer overflow and DoS attacks. Also check for null bytes.",
    "starterCode": "def validate_input_length(user_input, min_length, max_length):\n    \"\"\"\n    Validate input length and content.\n\n    Args:\n        user_input: String user input\n        min_length: Integer minimum allowed length\n        max_length: Integer maximum allowed length\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "def validate_input_length(user_input, min_length, max_length):\n    \"\"\"\n    Validate input length and content.\n\n    Args:\n        user_input: String user input\n        min_length: Integer minimum allowed length\n        max_length: Integer maximum allowed length\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    # Check for null bytes (can cause issues in C code)\n    if '\\x00' in user_input or '\\0' in user_input:\n        return {\n            'valid': False,\n            'reason': 'Null bytes not allowed'\n        }\n\n    # Check minimum length\n    if len(user_input) < min_length:\n        return {\n            'valid': False,\n            'reason': f'Input too short (minimum {min_length})'\n        }\n\n    # Check maximum length\n    if len(user_input) > max_length:\n        return {\n            'valid': False,\n            'reason': f'Input too long (maximum {max_length})'\n        }\n\n    return {\n        'valid': True,\n        'reason': 'Input valid'\n    }",
    "testCases": [
      {
        "input": "\"validinput\", 5, 20",
        "expectedOutput": "{'valid': True, 'reason': 'Input valid'}",
        "isHidden": false,
        "description": "Valid length"
      },
      {
        "input": "\"abc\", 5, 20",
        "expectedOutput": "{'valid': False, 'reason': 'Input too short (minimum 5)'}",
        "isHidden": false,
        "description": "Too short"
      },
      {
        "input": "\"verylonginputthatexceedsmaximum\", 5, 20",
        "expectedOutput": "{'valid': False, 'reason': 'Input too long (maximum 20)'}",
        "isHidden": false,
        "description": "Too long"
      },
      {
        "input": "\"test\\\\x00data\", 5, 20",
        "expectedOutput": "{'valid': False, 'reason': 'Null bytes not allowed'}",
        "isHidden": true,
        "description": "Contains null byte"
      }
    ],
    "hints": [
      "Check for null bytes first",
      "Validate minimum length",
      "Validate maximum length",
      "Length limits prevent buffer overflows and DoS",
      "Return descriptive error messages"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Basic Email Validation",
    "difficulty": 1,
    "description": "Write a function to validate an email address using basic format checking. Return True if valid, False otherwise.",
    "starterCode": "def validate_email(email):\n    # Check for @ symbol and basic format\n    pass\n\nprint(validate_email(\"user@example.com\"))\nprint(validate_email(\"invalid.email\"))",
    "solution": "def validate_email(email):\n    if not email or '@' not in email:\n        return False\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n    if not local or not domain:\n        return False\n    if '.' not in domain:\n        return False\n    return True\n\nprint(validate_email(\"user@example.com\"))\nprint(validate_email(\"invalid.email\"))",
    "testCases": [
      {
        "input": "\"user@example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid email"
      },
      {
        "input": "\"invalid.email\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing @ symbol"
      },
      {
        "input": "\"user@@example.com\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Multiple @ symbols"
      }
    ],
    "hints": [
      "Check if email contains exactly one @ symbol",
      "Split email on @ and validate both parts exist",
      "Ensure domain has a dot for TLD"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Sanitize User Input",
    "difficulty": 2,
    "description": "Write a function to sanitize user input by removing dangerous characters that could be used in injection attacks.",
    "starterCode": "def sanitize_input(user_input):\n    # Remove potentially dangerous characters: < > & \" ' ;\n    pass\n\nprint(sanitize_input(\"Hello World\"))\nprint(sanitize_input(\"<script>alert('xss')</script>\"))",
    "solution": "def sanitize_input(user_input):\n    dangerous_chars = ['<', '>', '&', '\"', \"'\", ';']\n    result = user_input\n    for char in dangerous_chars:\n        result = result.replace(char, '')\n    return result\n\nprint(sanitize_input(\"Hello World\"))\nprint(sanitize_input(\"<script>alert('xss')</script>\"))",
    "testCases": [
      {
        "input": "\"Hello World\"",
        "expectedOutput": "\"Hello World\"",
        "isHidden": false,
        "description": "Clean input unchanged"
      },
      {
        "input": "\"<script>alert('xss')</script>\"",
        "expectedOutput": "\"scriptalert(xss)/script\"",
        "isHidden": false,
        "description": "Remove script tags"
      },
      {
        "input": "\"User & Admin\"",
        "expectedOutput": "\"User  Admin\"",
        "isHidden": true,
        "description": "Remove ampersand"
      }
    ],
    "hints": [
      "Create a list of dangerous characters",
      "Use string.replace() to remove each character",
      "Process all dangerous characters one by one"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Integer Input Validation",
    "difficulty": 1,
    "description": "Write a function that validates and safely converts user input to an integer within a specified range.",
    "starterCode": "def validate_integer_input(input_str, min_val=0, max_val=100):\n    # Validate and convert to int, return None if invalid\n    pass\n\nprint(validate_integer_input(\"42\", 0, 100))\nprint(validate_integer_input(\"150\", 0, 100))\nprint(validate_integer_input(\"abc\", 0, 100))",
    "solution": "def validate_integer_input(input_str, min_val=0, max_val=100):\n    try:\n        value = int(input_str)\n        if min_val <= value <= max_val:\n            return value\n        return None\n    except (ValueError, TypeError):\n        return None\n\nprint(validate_integer_input(\"42\", 0, 100))\nprint(validate_integer_input(\"150\", 0, 100))\nprint(validate_integer_input(\"abc\", 0, 100))",
    "testCases": [
      {
        "input": "\"42\", 0, 100",
        "expectedOutput": "42",
        "isHidden": false,
        "description": "Valid integer in range"
      },
      {
        "input": "\"150\", 0, 100",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Integer out of range"
      },
      {
        "input": "\"abc\", 0, 100",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Non-numeric input"
      }
    ],
    "hints": [
      "Use try-except to catch conversion errors",
      "Check if converted value is within range",
      "Return None for invalid inputs"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "HTML Entity Encoding",
    "difficulty": 2,
    "description": "Write a function to encode special HTML characters to prevent XSS attacks.",
    "starterCode": "def html_encode(text):\n    # Encode: < > & \" '\n    pass\n\nprint(html_encode(\"Hello World\"))\nprint(html_encode(\"<div>Test & 'quotes'</div>\"))",
    "solution": "def html_encode(text):\n    encoding_map = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n        '\"': '&quot;',\n        \"'\": '&#x27;'\n    }\n    result = text\n    for char, entity in encoding_map.items():\n        result = result.replace(char, entity)\n    return result\n\nprint(html_encode(\"Hello World\"))\nprint(html_encode(\"<div>Test & 'quotes'</div>\"))",
    "testCases": [
      {
        "input": "\"Hello World\"",
        "expectedOutput": "\"Hello World\"",
        "isHidden": false,
        "description": "No special chars"
      },
      {
        "input": "\"<div>Test & 'quotes'</div>\"",
        "expectedOutput": "\"&lt;div&gt;Test &amp; &#x27;quotes&#x27;&lt;/div&gt;\"",
        "isHidden": false,
        "description": "Encode HTML entities"
      },
      {
        "input": "\"a<b>c\"",
        "expectedOutput": "\"a&lt;b&gt;c\"",
        "isHidden": true,
        "description": "Simple brackets"
      }
    ],
    "hints": [
      "Create a dictionary mapping characters to HTML entities",
      "Replace each special character with its encoded form",
      "Handle & first to avoid double encoding"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Path Traversal Prevention",
    "difficulty": 3,
    "description": "Write a function to validate that a filename does not contain path traversal attempts (../).",
    "starterCode": "def is_safe_filename(filename):\n    # Check for path traversal attempts\n    pass\n\nprint(is_safe_filename(\"document.pdf\"))\nprint(is_safe_filename(\"../etc/passwd\"))\nprint(is_safe_filename(\"file..name.txt\"))",
    "solution": "def is_safe_filename(filename):\n    # Check for path traversal patterns\n    dangerous_patterns = ['../', '..\\\\', '/..', '\\\\..']\n\n    for pattern in dangerous_patterns:\n        if pattern in filename:\n            return False\n\n    # Also reject absolute paths\n    if filename.startswith('/') or filename.startswith('\\\\'):\n        return False\n\n    # Reject drive letters on Windows\n    if len(filename) > 1 and filename[1] == ':':\n        return False\n\n    return True\n\nprint(is_safe_filename(\"document.pdf\"))\nprint(is_safe_filename(\"../etc/passwd\"))\nprint(is_safe_filename(\"file..name.txt\"))",
    "testCases": [
      {
        "input": "\"document.pdf\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe filename"
      },
      {
        "input": "\"../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Path traversal attempt"
      },
      {
        "input": "\"/etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Absolute path"
      }
    ],
    "hints": [
      "Check for ../ and ..\\\\ patterns",
      "Reject absolute paths starting with / or \\\\",
      "Consider Windows drive letters (C:)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Secure Error Message",
    "difficulty": 2,
    "description": "Write a function that returns a generic error message for users while logging detailed info for developers.",
    "starterCode": "def handle_login_error(username, error_type):\n    # Return generic user message and detailed log\n    # error_type: 'user_not_found', 'wrong_password', 'account_locked'\n    pass\n\nuser_msg, log_msg = handle_login_error(\"alice\", \"wrong_password\")\nprint(f\"User: {user_msg}\")\nprint(f\"Log: {log_msg}\")",
    "solution": "def handle_login_error(username, error_type):\n    # Generic message for user (no details leaked)\n    user_message = \"Invalid username or password\"\n\n    # Detailed message for logs\n    log_details = {\n        'user_not_found': f\"Login failed: User '{username}' does not exist\",\n        'wrong_password': f\"Login failed: Invalid password for user '{username}'\",\n        'account_locked': f\"Login failed: Account '{username}' is locked\"\n    }\n\n    log_message = log_details.get(error_type, f\"Login failed for user '{username}'\")\n\n    return user_message, log_message\n\nuser_msg, log_msg = handle_login_error(\"alice\", \"wrong_password\")\nprint(f\"User: {user_msg}\")\nprint(f\"Log: {log_msg}\")",
    "testCases": [
      {
        "input": "\"alice\", \"wrong_password\"",
        "expectedOutput": "user_msg contains \"Invalid\"",
        "isHidden": false,
        "description": "Generic user message"
      },
      {
        "input": "\"bob\", \"user_not_found\"",
        "expectedOutput": "log contains \"bob\"",
        "isHidden": false,
        "description": "Detailed log message"
      },
      {
        "input": "\"charlie\", \"account_locked\"",
        "expectedOutput": "user_msg same for all errors",
        "isHidden": true,
        "description": "Consistent user message"
      }
    ],
    "hints": [
      "User message should be same for all error types",
      "Log message should include specific details",
      "Never reveal which part of login failed to user"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "SQL Parameter Validation",
    "difficulty": 3,
    "description": "Write a function to validate parameters for SQL queries to prevent injection. Accept only alphanumeric characters and underscores for table/column names.",
    "starterCode": "def validate_sql_identifier(identifier):\n    # Validate SQL table/column names\n    pass\n\nprint(validate_sql_identifier(\"users_table\"))\nprint(validate_sql_identifier(\"users; DROP TABLE\"))\nprint(validate_sql_identifier(\"user123\"))",
    "solution": "def validate_sql_identifier(identifier):\n    if not identifier:\n        return False\n\n    # Must start with letter or underscore\n    if not (identifier[0].isalpha() or identifier[0] == '_'):\n        return False\n\n    # Rest must be alphanumeric or underscore\n    for char in identifier:\n        if not (char.isalnum() or char == '_'):\n            return False\n\n    # Additional check: not too long\n    if len(identifier) > 64:\n        return False\n\n    return True\n\nprint(validate_sql_identifier(\"users_table\"))\nprint(validate_sql_identifier(\"users; DROP TABLE\"))\nprint(validate_sql_identifier(\"user123\"))",
    "testCases": [
      {
        "input": "\"users_table\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid identifier"
      },
      {
        "input": "\"users; DROP TABLE\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "SQL injection attempt"
      },
      {
        "input": "\"123users\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Starts with number"
      }
    ],
    "hints": [
      "Check first character is letter or underscore",
      "Validate all characters are alphanumeric or underscore",
      "Consider maximum length limits"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "URL Parameter Encoding",
    "difficulty": 2,
    "description": "Write a function to safely encode URL parameters to prevent injection attacks.",
    "starterCode": "def encode_url_param(param):\n    # Encode special characters for URL\n    pass\n\nprint(encode_url_param(\"hello world\"))\nprint(encode_url_param(\"name=value&other=data\"))",
    "solution": "def encode_url_param(param):\n    # Characters that need encoding\n    encoding_map = {\n        ' ': '%20',\n        '&': '%26',\n        '=': '%3D',\n        '?': '%3F',\n        '#': '%23',\n        '/': '%2F',\n        '+': '%2B'\n    }\n\n    result = param\n    for char, encoded in encoding_map.items():\n        result = result.replace(char, encoded)\n\n    return result\n\nprint(encode_url_param(\"hello world\"))\nprint(encode_url_param(\"name=value&other=data\"))",
    "testCases": [
      {
        "input": "\"hello world\"",
        "expectedOutput": "\"hello%20world\"",
        "isHidden": false,
        "description": "Encode space"
      },
      {
        "input": "\"name=value&other=data\"",
        "expectedOutput": "\"name%3Dvalue%26other%3Ddata\"",
        "isHidden": false,
        "description": "Encode special chars"
      },
      {
        "input": "\"simple\"",
        "expectedOutput": "\"simple\"",
        "isHidden": true,
        "description": "No encoding needed"
      }
    ],
    "hints": [
      "Create mapping of special chars to percent-encoded values",
      "Replace each special character",
      "Common chars: space, &, =, ?, #"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Command Injection Prevention",
    "difficulty": 4,
    "description": "Write a function to validate filenames before using them in system commands. Reject any filename with shell metacharacters.",
    "starterCode": "def is_safe_for_command(filename):\n    # Validate filename has no shell metacharacters\n    pass\n\nprint(is_safe_for_command(\"report.pdf\"))\nprint(is_safe_for_command(\"file.txt; rm -rf /\"))\nprint(is_safe_for_command(\"data|backup.tar\"))",
    "solution": "def is_safe_for_command(filename):\n    # Shell metacharacters that could be dangerous\n    dangerous_chars = [';', '|', '&', '$', '>', '<', '`', '\\n', '\\r', '(', ')', '{', '}', '[', ']', '!', '*', '?']\n\n    # Check for dangerous characters\n    for char in dangerous_chars:\n        if char in filename:\n            return False\n\n    # Also check for command substitution patterns\n    if '$(' in filename or '${' in filename:\n        return False\n\n    # Reject if starts with dash (option injection)\n    if filename.startswith('-'):\n        return False\n\n    return True\n\nprint(is_safe_for_command(\"report.pdf\"))\nprint(is_safe_for_command(\"file.txt; rm -rf /\"))\nprint(is_safe_for_command(\"data|backup.tar\"))",
    "testCases": [
      {
        "input": "\"report.pdf\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe filename"
      },
      {
        "input": "\"file.txt; rm -rf /\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Command injection attempt"
      },
      {
        "input": "\"data|backup.tar\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Pipe character"
      }
    ],
    "hints": [
      "List all shell metacharacters: ; | & $ > < etc.",
      "Check for command substitution: $( ${",
      "Reject filenames starting with dash"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Credit Card Masking",
    "difficulty": 2,
    "description": "Write a function to mask a credit card number, showing only the last 4 digits.",
    "starterCode": "def mask_credit_card(card_number):\n    # Show only last 4 digits, mask rest with *\n    pass\n\nprint(mask_credit_card(\"1234567812345678\"))\nprint(mask_credit_card(\"4111111111111111\"))",
    "solution": "def mask_credit_card(card_number):\n    # Remove spaces and dashes if present\n    cleaned = card_number.replace(' ', '').replace('-', '')\n\n    if len(cleaned) < 4:\n        return '*' * len(cleaned)\n\n    # Mask all but last 4 digits\n    masked = '*' * (len(cleaned) - 4) + cleaned[-4:]\n\n    return masked\n\nprint(mask_credit_card(\"1234567812345678\"))\nprint(mask_credit_card(\"4111111111111111\"))",
    "testCases": [
      {
        "input": "\"1234567812345678\"",
        "expectedOutput": "\"************5678\"",
        "isHidden": false,
        "description": "Mask 16-digit card"
      },
      {
        "input": "\"4111111111111111\"",
        "expectedOutput": "\"************1111\"",
        "isHidden": false,
        "description": "Last 4 visible"
      },
      {
        "input": "\"123\"",
        "expectedOutput": "\"***\"",
        "isHidden": true,
        "description": "Short number"
      }
    ],
    "hints": [
      "Clean input by removing spaces/dashes",
      "Replace all but last 4 chars with asterisks",
      "Handle edge case of short numbers"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "JSON Output Sanitization",
    "difficulty": 3,
    "description": "Write a function to sanitize data before encoding to JSON, removing sensitive fields.",
    "starterCode": "def sanitize_for_json(data_dict):\n    # Remove sensitive fields: password, ssn, credit_card\n    pass\n\nuser = {\"name\": \"Alice\", \"password\": \"secret123\", \"email\": \"alice@example.com\"}\nprint(sanitize_for_json(user))",
    "solution": "def sanitize_for_json(data_dict):\n    sensitive_fields = ['password', 'ssn', 'credit_card', 'secret', 'token', 'api_key']\n\n    # Create a copy to avoid modifying original\n    sanitized = data_dict.copy()\n\n    # Remove sensitive fields (case-insensitive)\n    keys_to_remove = []\n    for key in sanitized.keys():\n        key_lower = key.lower()\n        for sensitive in sensitive_fields:\n            if sensitive in key_lower:\n                keys_to_remove.append(key)\n                break\n\n    for key in keys_to_remove:\n        del sanitized[key]\n\n    return sanitized\n\nuser = {\"name\": \"Alice\", \"password\": \"secret123\", \"email\": \"alice@example.com\"}\nprint(sanitize_for_json(user))",
    "testCases": [
      {
        "input": "{\"name\": \"Alice\", \"password\": \"secret123\"}",
        "expectedOutput": "{\"name\": \"Alice\"}",
        "isHidden": false,
        "description": "Remove password field"
      },
      {
        "input": "{\"id\": 1, \"ssn\": \"123-45-6789\"}",
        "expectedOutput": "{\"id\": 1}",
        "isHidden": false,
        "description": "Remove SSN field"
      },
      {
        "input": "{\"user\": \"Bob\", \"api_key\": \"xyz\"}",
        "expectedOutput": "{\"user\": \"Bob\"}",
        "isHidden": true,
        "description": "Remove API key"
      }
    ],
    "hints": [
      "Define list of sensitive field names",
      "Create copy of dictionary",
      "Check each key against sensitive list",
      "Delete matching keys from copy"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "File Extension Validation",
    "difficulty": 2,
    "description": "Write a function to validate file uploads by checking allowed extensions.",
    "starterCode": "def is_allowed_file(filename, allowed_extensions):\n    # Check if file extension is in allowed list\n    pass\n\nprint(is_allowed_file(\"document.pdf\", [\"pdf\", \"doc\", \"docx\"]))\nprint(is_allowed_file(\"script.exe\", [\"pdf\", \"doc\", \"docx\"]))",
    "solution": "def is_allowed_file(filename, allowed_extensions):\n    if not filename or '.' not in filename:\n        return False\n\n    # Get extension (everything after last dot)\n    extension = filename.rsplit('.', 1)[1].lower()\n\n    # Normalize allowed extensions to lowercase\n    allowed = [ext.lower() for ext in allowed_extensions]\n\n    return extension in allowed\n\nprint(is_allowed_file(\"document.pdf\", [\"pdf\", \"doc\", \"docx\"]))\nprint(is_allowed_file(\"script.exe\", [\"pdf\", \"doc\", \"docx\"]))",
    "testCases": [
      {
        "input": "\"document.pdf\", [\"pdf\", \"doc\", \"docx\"]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Allowed extension"
      },
      {
        "input": "\"script.exe\", [\"pdf\", \"doc\", \"docx\"]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Disallowed extension"
      },
      {
        "input": "\"file.PDF\", [\"pdf\"]",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Case insensitive"
      }
    ],
    "hints": [
      "Use rsplit() to get extension after last dot",
      "Convert to lowercase for comparison",
      "Check if extension is in allowed list"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Input Length Validation",
    "difficulty": 1,
    "description": "Write a function to validate that user input does not exceed maximum length to prevent buffer overflow-style attacks.",
    "starterCode": "def validate_length(input_str, max_length=255):\n    # Return True if within limit, False if too long\n    pass\n\nprint(validate_length(\"Hello\", 10))\nprint(validate_length(\"A\" * 300, 255))",
    "solution": "def validate_length(input_str, max_length=255):\n    if input_str is None:\n        return False\n\n    return len(input_str) <= max_length\n\nprint(validate_length(\"Hello\", 10))\nprint(validate_length(\"A\" * 300, 255))",
    "testCases": [
      {
        "input": "\"Hello\", 10",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Within limit"
      },
      {
        "input": "\"A\" * 300, 255",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Exceeds limit"
      },
      {
        "input": "\"\", 10",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Empty string valid"
      }
    ],
    "hints": [
      "Use len() to get string length",
      "Compare against max_length",
      "Handle None input case"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "XML Entity Prevention",
    "difficulty": 4,
    "description": "Write a function to detect potentially dangerous XML patterns like entity expansion attacks.",
    "starterCode": "def is_safe_xml_content(xml_string):\n    # Detect dangerous XML patterns\n    pass\n\nprint(is_safe_xml_content(\"<root><data>Hello</data></root>\"))\nprint(is_safe_xml_content(\"<!DOCTYPE test [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\"))",
    "solution": "def is_safe_xml_content(xml_string):\n    dangerous_patterns = [\n        '<!DOCTYPE',\n        '<!ENTITY',\n        'SYSTEM',\n        'PUBLIC',\n        '<!ELEMENT',\n        '<!ATTLIST'\n    ]\n\n    # Check for dangerous patterns (case-insensitive)\n    xml_upper = xml_string.upper()\n    for pattern in dangerous_patterns:\n        if pattern in xml_upper:\n            return False\n\n    # Check for excessive entity references\n    if xml_string.count('&') > 10:\n        return False\n\n    return True\n\nprint(is_safe_xml_content(\"<root><data>Hello</data></root>\"))\nprint(is_safe_xml_content(\"<!DOCTYPE test [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\"))",
    "testCases": [
      {
        "input": "\"<root><data>Hello</data></root>\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe XML"
      },
      {
        "input": "\"<!DOCTYPE test [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "XXE attack pattern"
      },
      {
        "input": "\"<data>&amp;&amp;&amp;</data>\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Few entities OK"
      }
    ],
    "hints": [
      "Check for DOCTYPE and ENTITY declarations",
      "Look for SYSTEM and PUBLIC keywords",
      "Count entity references (&)",
      "Use case-insensitive matching"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "LDAP Injection Prevention",
    "difficulty": 4,
    "description": "Write a function to escape special characters in LDAP query inputs to prevent LDAP injection.",
    "starterCode": "def escape_ldap_filter(input_str):\n    # Escape LDAP special characters\n    pass\n\nprint(escape_ldap_filter(\"John Doe\"))\nprint(escape_ldap_filter(\"admin)(uid=*))(|(uid=*\"))",
    "solution": "def escape_ldap_filter(input_str):\n    # LDAP special characters and their escaped forms\n    escape_map = {\n        '\\\\': '\\\\5c',\n        '*': '\\\\2a',\n        '(': '\\\\28',\n        ')': '\\\\29',\n        '\\x00': '\\\\00'\n    }\n\n    result = input_str\n    # Escape backslash first to avoid double escaping\n    result = result.replace('\\\\', '\\\\5c')\n    result = result.replace('*', '\\\\2a')\n    result = result.replace('(', '\\\\28')\n    result = result.replace(')', '\\\\29')\n    result = result.replace('\\x00', '\\\\00')\n\n    return result\n\nprint(escape_ldap_filter(\"John Doe\"))\nprint(escape_ldap_filter(\"admin)(uid=*))(|(uid=*\"))",
    "testCases": [
      {
        "input": "\"John Doe\"",
        "expectedOutput": "\"John Doe\"",
        "isHidden": false,
        "description": "No special chars"
      },
      {
        "input": "\"admin)(uid=*))(|(uid=*\"",
        "expectedOutput": "Escaped parentheses and asterisks",
        "isHidden": false,
        "description": "Escape injection chars"
      },
      {
        "input": "\"user*\"",
        "expectedOutput": "\"user\\\\2a\"",
        "isHidden": true,
        "description": "Escape wildcard"
      }
    ],
    "hints": [
      "LDAP special chars: * ( ) \\\\ and NULL",
      "Escape to hex codes: \\\\2a \\\\28 \\\\29 \\\\5c",
      "Escape backslash first to avoid double escaping"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t5-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Content Security Policy Header",
    "difficulty": 3,
    "description": "Write a function to generate a Content Security Policy header value for secure web applications.",
    "starterCode": "def generate_csp_header(allow_inline_scripts=False):\n    # Generate CSP header string\n    pass\n\nprint(generate_csp_header(False))\nprint(generate_csp_header(True))",
    "solution": "def generate_csp_header(allow_inline_scripts=False):\n    # Start with restrictive default\n    policies = [\n        \"default-src 'self'\",\n        \"object-src 'none'\",\n        \"base-uri 'self'\",\n        \"form-action 'self'\"\n    ]\n\n    # Script policy based on parameter\n    if allow_inline_scripts:\n        policies.append(\"script-src 'self' 'unsafe-inline'\")\n    else:\n        policies.append(\"script-src 'self'\")\n\n    # Join with semicolons\n    return '; '.join(policies)\n\nprint(generate_csp_header(False))\nprint(generate_csp_header(True))",
    "testCases": [
      {
        "input": "False",
        "expectedOutput": "Contains script-src self",
        "isHidden": false,
        "description": "Strict CSP"
      },
      {
        "input": "True",
        "expectedOutput": "Contains unsafe-inline",
        "isHidden": false,
        "description": "Allow inline scripts"
      },
      {
        "input": "False",
        "expectedOutput": "Contains default-src",
        "isHidden": true,
        "description": "Has default-src"
      }
    ],
    "hints": [
      "Use default-src to restrict resource loading",
      "Set object-src to none to prevent plugins",
      "script-src controls JavaScript execution",
      "Join policies with semicolons"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Parse TLS Version",
    "difficulty": 1,
    "description": "Write a function to extract and validate TLS version from a server configuration string.",
    "starterCode": "def parse_tls_version(config_line):\n    # Extract TLS version (e.g., \"TLSv1.2\", \"TLSv1.3\")\n    pass\n\nprint(parse_tls_version(\"ssl_protocols TLSv1.2 TLSv1.3;\"))\nprint(parse_tls_version(\"ssl_protocols SSLv3;\"))",
    "solution": "def parse_tls_version(config_line):\n    versions = []\n    if 'TLSv1.3' in config_line:\n        versions.append('TLSv1.3')\n    if 'TLSv1.2' in config_line:\n        versions.append('TLSv1.2')\n    if 'TLSv1.1' in config_line:\n        versions.append('TLSv1.1')\n    if 'TLSv1.0' in config_line:\n        versions.append('TLSv1.0')\n\n    return versions if versions else None\n\nprint(parse_tls_version(\"ssl_protocols TLSv1.2 TLSv1.3;\"))\nprint(parse_tls_version(\"ssl_protocols SSLv3;\"))",
    "testCases": [
      {
        "input": "\"ssl_protocols TLSv1.2 TLSv1.3;\"",
        "expectedOutput": "['TLSv1.3', 'TLSv1.2']",
        "isHidden": false,
        "description": "Parse modern TLS"
      },
      {
        "input": "\"ssl_protocols SSLv3;\"",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "No valid TLS"
      },
      {
        "input": "\"ssl_protocols TLSv1.0;\"",
        "expectedOutput": "['TLSv1.0']",
        "isHidden": true,
        "description": "Old TLS version"
      }
    ],
    "hints": [
      "Check for TLS version strings in config",
      "Return list of found versions",
      "Return None if no TLS versions found"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Validate Certificate Expiry",
    "difficulty": 2,
    "description": "Write a function to check if a certificate expiry date is valid (not expired and not too far in future).",
    "starterCode": "from datetime import datetime, timedelta\n\ndef is_valid_cert_date(expiry_date_str, current_date_str):\n    # Check if cert is valid (not expired, not > 398 days)\n    pass\n\nprint(is_valid_cert_date(\"2026-12-31\", \"2025-12-17\"))\nprint(is_valid_cert_date(\"2025-01-01\", \"2025-12-17\"))",
    "solution": "from datetime import datetime, timedelta\n\ndef is_valid_cert_date(expiry_date_str, current_date_str):\n    try:\n        expiry = datetime.strptime(expiry_date_str, \"%Y-%m-%d\")\n        current = datetime.strptime(current_date_str, \"%Y-%m-%d\")\n\n        # Check if expired\n        if expiry <= current:\n            return False\n\n        # Check if validity period exceeds 398 days (browser limit)\n        days_valid = (expiry - current).days\n        if days_valid > 398:\n            return False\n\n        return True\n    except ValueError:\n        return False\n\nprint(is_valid_cert_date(\"2026-12-31\", \"2025-12-17\"))\nprint(is_valid_cert_date(\"2025-01-01\", \"2025-12-17\"))",
    "testCases": [
      {
        "input": "\"2026-12-31\", \"2025-12-17\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Too far in future"
      },
      {
        "input": "\"2025-01-01\", \"2025-12-17\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Already expired"
      },
      {
        "input": "\"2026-06-01\", \"2025-12-17\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Valid cert"
      }
    ],
    "hints": [
      "Parse dates using datetime.strptime",
      "Check if expiry is after current date",
      "Verify validity period is <= 398 days",
      "Handle parsing errors"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Firewall Rule Parser",
    "difficulty": 3,
    "description": "Write a function to parse a firewall rule and extract action, protocol, source, and destination.",
    "starterCode": "def parse_firewall_rule(rule_string):\n    # Parse: \"ALLOW TCP 192.168.1.0/24 -> 10.0.0.5:443\"\n    # Return dict with action, protocol, source, dest\n    pass\n\nprint(parse_firewall_rule(\"ALLOW TCP 192.168.1.0/24 -> 10.0.0.5:443\"))\nprint(parse_firewall_rule(\"DENY UDP 0.0.0.0/0 -> 10.0.0.10:53\"))",
    "solution": "def parse_firewall_rule(rule_string):\n    try:\n        parts = rule_string.split()\n        if len(parts) < 5:\n            return None\n\n        action = parts[0]\n        protocol = parts[1]\n        source = parts[2]\n        # parts[3] is '->'\n        destination = parts[4]\n\n        return {\n            'action': action,\n            'protocol': protocol,\n            'source': source,\n            'destination': destination\n        }\n    except (IndexError, ValueError):\n        return None\n\nprint(parse_firewall_rule(\"ALLOW TCP 192.168.1.0/24 -> 10.0.0.5:443\"))\nprint(parse_firewall_rule(\"DENY UDP 0.0.0.0/0 -> 10.0.0.10:53\"))",
    "testCases": [
      {
        "input": "\"ALLOW TCP 192.168.1.0/24 -> 10.0.0.5:443\"",
        "expectedOutput": "dict with action=ALLOW",
        "isHidden": false,
        "description": "Parse ALLOW rule"
      },
      {
        "input": "\"DENY UDP 0.0.0.0/0 -> 10.0.0.10:53\"",
        "expectedOutput": "dict with protocol=UDP",
        "isHidden": false,
        "description": "Parse DENY rule"
      },
      {
        "input": "\"INVALID RULE\"",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Invalid rule format"
      }
    ],
    "hints": [
      "Split rule string by spaces",
      "Extract action (first word)",
      "Extract protocol (second word)",
      "Parse source and destination"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Validate IP Address",
    "difficulty": 2,
    "description": "Write a function to validate if a string is a valid IPv4 address.",
    "starterCode": "def is_valid_ipv4(ip_string):\n    # Validate IPv4 format (e.g., \"192.168.1.1\")\n    pass\n\nprint(is_valid_ipv4(\"192.168.1.1\"))\nprint(is_valid_ipv4(\"256.1.1.1\"))\nprint(is_valid_ipv4(\"192.168.1\"))",
    "solution": "def is_valid_ipv4(ip_string):\n    try:\n        parts = ip_string.split('.')\n\n        # Must have exactly 4 parts\n        if len(parts) != 4:\n            return False\n\n        # Each part must be 0-255\n        for part in parts:\n            num = int(part)\n            if num < 0 or num > 255:\n                return False\n\n            # No leading zeros (except for \"0\")\n            if len(part) > 1 and part[0] == '0':\n                return False\n\n        return True\n    except (ValueError, AttributeError):\n        return False\n\nprint(is_valid_ipv4(\"192.168.1.1\"))\nprint(is_valid_ipv4(\"256.1.1.1\"))\nprint(is_valid_ipv4(\"192.168.1\"))",
    "testCases": [
      {
        "input": "\"192.168.1.1\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid IPv4"
      },
      {
        "input": "\"256.1.1.1\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Octet out of range"
      },
      {
        "input": "\"192.168.1\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Incomplete address"
      }
    ],
    "hints": [
      "Split on dots, must have 4 parts",
      "Each part must be 0-255",
      "Reject leading zeros",
      "Handle conversion errors"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Parse Security Log Entry",
    "difficulty": 3,
    "description": "Write a function to parse a security log entry and extract timestamp, IP, action, and status.",
    "starterCode": "def parse_security_log(log_line):\n    # Parse: \"2025-12-17 10:30:45 192.168.1.100 LOGIN SUCCESS\"\n    pass\n\nprint(parse_security_log(\"2025-12-17 10:30:45 192.168.1.100 LOGIN SUCCESS\"))\nprint(parse_security_log(\"2025-12-17 10:31:00 10.0.0.50 ACCESS DENIED\"))",
    "solution": "def parse_security_log(log_line):\n    try:\n        parts = log_line.split()\n        if len(parts) < 5:\n            return None\n\n        timestamp = f\"{parts[0]} {parts[1]}\"\n        ip_address = parts[2]\n        action = parts[3]\n        status = parts[4]\n\n        return {\n            'timestamp': timestamp,\n            'ip': ip_address,\n            'action': action,\n            'status': status\n        }\n    except (IndexError, ValueError):\n        return None\n\nprint(parse_security_log(\"2025-12-17 10:30:45 192.168.1.100 LOGIN SUCCESS\"))\nprint(parse_security_log(\"2025-12-17 10:31:00 10.0.0.50 ACCESS DENIED\"))",
    "testCases": [
      {
        "input": "\"2025-12-17 10:30:45 192.168.1.100 LOGIN SUCCESS\"",
        "expectedOutput": "dict with status=SUCCESS",
        "isHidden": false,
        "description": "Parse successful login"
      },
      {
        "input": "\"2025-12-17 10:31:00 10.0.0.50 ACCESS DENIED\"",
        "expectedOutput": "dict with action=ACCESS",
        "isHidden": false,
        "description": "Parse denied access"
      },
      {
        "input": "\"INVALID LOG\"",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Invalid format"
      }
    ],
    "hints": [
      "Split by spaces",
      "Combine first two parts for timestamp",
      "Extract IP, action, and status",
      "Handle malformed logs"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Detect Port Scan",
    "difficulty": 4,
    "description": "Write a function to detect potential port scans by analyzing connection attempts from the same IP.",
    "starterCode": "def detect_port_scan(connection_logs):\n    # connection_logs: list of (ip, port, timestamp) tuples\n    # Return IPs with > 10 different ports in 60 seconds\n    pass\n\nlogs = [\n    (\"192.168.1.50\", 80, 100),\n    (\"192.168.1.50\", 443, 105),\n    (\"192.168.1.50\", 22, 110),\n    # ... more ports\n]\nprint(detect_port_scan(logs))",
    "solution": "def detect_port_scan(connection_logs):\n    from collections import defaultdict\n\n    # Group by IP\n    ip_connections = defaultdict(list)\n\n    for ip, port, timestamp in connection_logs:\n        ip_connections[ip].append((port, timestamp))\n\n    suspicious_ips = []\n\n    for ip, connections in ip_connections.items():\n        # Check for different ports in short time\n        unique_ports = set()\n        min_time = float('inf')\n        max_time = 0\n\n        for port, timestamp in connections:\n            unique_ports.add(port)\n            min_time = min(min_time, timestamp)\n            max_time = max(max_time, timestamp)\n\n        time_window = max_time - min_time\n\n        # If > 10 different ports in <= 60 seconds\n        if len(unique_ports) > 10 and time_window <= 60:\n            suspicious_ips.append(ip)\n\n    return suspicious_ips\n\nlogs = [\n    (\"192.168.1.50\", 80, 100),\n    (\"192.168.1.50\", 443, 105),\n    (\"192.168.1.50\", 22, 110),\n]\nprint(detect_port_scan(logs))",
    "testCases": [
      {
        "input": "logs with 15 ports in 60s",
        "expectedOutput": "Returns IP",
        "isHidden": false,
        "description": "Detect scan"
      },
      {
        "input": "logs with 5 ports",
        "expectedOutput": "Empty list",
        "isHidden": false,
        "description": "Normal traffic"
      },
      {
        "input": "logs with 15 ports in 120s",
        "expectedOutput": "Empty list",
        "isHidden": true,
        "description": "Too slow for scan"
      }
    ],
    "hints": [
      "Group connections by source IP",
      "Count unique ports per IP",
      "Calculate time window",
      "Flag IPs with > 10 ports in <= 60s"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Validate Subnet Mask",
    "difficulty": 2,
    "description": "Write a function to validate if a subnet mask is valid (contiguous 1s followed by 0s in binary).",
    "starterCode": "def is_valid_subnet_mask(mask):\n    # Validate subnet mask (e.g., \"255.255.255.0\")\n    pass\n\nprint(is_valid_subnet_mask(\"255.255.255.0\"))\nprint(is_valid_subnet_mask(\"255.255.0.255\"))",
    "solution": "def is_valid_subnet_mask(mask):\n    try:\n        # Parse octets\n        octets = mask.split('.')\n        if len(octets) != 4:\n            return False\n\n        # Convert to binary\n        binary_str = ''\n        for octet in octets:\n            num = int(octet)\n            if num < 0 or num > 255:\n                return False\n            binary_str += format(num, '08b')\n\n        # Check for contiguous 1s followed by 0s\n        # Valid pattern: 1*0* (all 1s, then all 0s)\n        seen_zero = False\n        for bit in binary_str:\n            if bit == '0':\n                seen_zero = True\n            elif seen_zero:  # Found 1 after 0\n                return False\n\n        return True\n    except (ValueError, AttributeError):\n        return False\n\nprint(is_valid_subnet_mask(\"255.255.255.0\"))\nprint(is_valid_subnet_mask(\"255.255.0.255\"))",
    "testCases": [
      {
        "input": "\"255.255.255.0\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid /24 mask"
      },
      {
        "input": "\"255.255.0.255\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Non-contiguous bits"
      },
      {
        "input": "\"255.255.255.128\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Valid /25 mask"
      }
    ],
    "hints": [
      "Convert mask to binary representation",
      "Check for pattern: 1s followed by 0s",
      "No 1s should appear after first 0",
      "Validate each octet is 0-255"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Check Weak Cipher Suite",
    "difficulty": 2,
    "description": "Write a function to check if a cipher suite is considered weak or deprecated.",
    "starterCode": "def is_weak_cipher(cipher_name):\n    # Check if cipher uses weak algorithms\n    pass\n\nprint(is_weak_cipher(\"TLS_RSA_WITH_AES_128_GCM_SHA256\"))\nprint(is_weak_cipher(\"TLS_RSA_WITH_DES_CBC_SHA\"))",
    "solution": "def is_weak_cipher(cipher_name):\n    weak_algorithms = [\n        'DES',\n        'RC4',\n        'MD5',\n        '3DES',\n        'NULL',\n        'EXPORT',\n        'anon',\n        'ADH'\n    ]\n\n    cipher_upper = cipher_name.upper()\n\n    for weak in weak_algorithms:\n        if weak in cipher_upper:\n            return True\n\n    # Also check for very old SSL versions\n    if cipher_upper.startswith('SSL_'):\n        return True\n\n    return False\n\nprint(is_weak_cipher(\"TLS_RSA_WITH_AES_128_GCM_SHA256\"))\nprint(is_weak_cipher(\"TLS_RSA_WITH_DES_CBC_SHA\"))",
    "testCases": [
      {
        "input": "\"TLS_RSA_WITH_AES_128_GCM_SHA256\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Strong cipher"
      },
      {
        "input": "\"TLS_RSA_WITH_DES_CBC_SHA\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Weak DES cipher"
      },
      {
        "input": "\"TLS_RSA_WITH_RC4_128_SHA\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Weak RC4 cipher"
      }
    ],
    "hints": [
      "List weak algorithms: DES, RC4, MD5, 3DES",
      "Check if cipher name contains weak algorithm",
      "Flag SSL_ prefixed ciphers as weak",
      "Use case-insensitive comparison"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Calculate Network Address",
    "difficulty": 3,
    "description": "Write a function to calculate the network address from an IP and subnet mask.",
    "starterCode": "def get_network_address(ip, mask):\n    # Calculate network address using bitwise AND\n    pass\n\nprint(get_network_address(\"192.168.1.100\", \"255.255.255.0\"))\nprint(get_network_address(\"10.20.30.40\", \"255.255.0.0\"))",
    "solution": "def get_network_address(ip, mask):\n    try:\n        # Parse IP octets\n        ip_parts = [int(x) for x in ip.split('.')]\n        mask_parts = [int(x) for x in mask.split('.')]\n\n        if len(ip_parts) != 4 or len(mask_parts) != 4:\n            return None\n\n        # Bitwise AND each octet\n        network_parts = []\n        for i in range(4):\n            network_parts.append(ip_parts[i] & mask_parts[i])\n\n        return '.'.join(map(str, network_parts))\n    except (ValueError, IndexError):\n        return None\n\nprint(get_network_address(\"192.168.1.100\", \"255.255.255.0\"))\nprint(get_network_address(\"10.20.30.40\", \"255.255.0.0\"))",
    "testCases": [
      {
        "input": "\"192.168.1.100\", \"255.255.255.0\"",
        "expectedOutput": "\"192.168.1.0\"",
        "isHidden": false,
        "description": "/24 network"
      },
      {
        "input": "\"10.20.30.40\", \"255.255.0.0\"",
        "expectedOutput": "\"10.20.0.0\"",
        "isHidden": false,
        "description": "/16 network"
      },
      {
        "input": "\"172.16.50.25\", \"255.255.255.128\"",
        "expectedOutput": "\"172.16.50.0\"",
        "isHidden": true,
        "description": "/25 network"
      }
    ],
    "hints": [
      "Split IP and mask into octets",
      "Convert each octet to integer",
      "Use bitwise AND (&) on each pair",
      "Join results back to dotted notation"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Analyze Failed Login Attempts",
    "difficulty": 3,
    "description": "Write a function to identify IPs with excessive failed login attempts (potential brute force).",
    "starterCode": "def detect_brute_force(login_logs):\n    # login_logs: list of (ip, status, timestamp) tuples\n    # Return IPs with >= 5 failures in 300 seconds\n    pass\n\nlogs = [\n    (\"192.168.1.50\", \"FAIL\", 1000),\n    (\"192.168.1.50\", \"FAIL\", 1050),\n    # ...\n]\nprint(detect_brute_force(logs))",
    "solution": "def detect_brute_force(login_logs):\n    from collections import defaultdict\n\n    # Group failures by IP\n    ip_failures = defaultdict(list)\n\n    for ip, status, timestamp in login_logs:\n        if status == \"FAIL\":\n            ip_failures[ip].append(timestamp)\n\n    suspicious_ips = []\n\n    for ip, timestamps in ip_failures.items():\n        if len(timestamps) < 5:\n            continue\n\n        # Sort timestamps\n        timestamps.sort()\n\n        # Check for 5+ failures in 300 second window\n        for i in range(len(timestamps) - 4):\n            window = timestamps[i + 4] - timestamps[i]\n            if window <= 300:\n                suspicious_ips.append(ip)\n                break\n\n    return suspicious_ips\n\nlogs = [\n    (\"192.168.1.50\", \"FAIL\", 1000),\n    (\"192.168.1.50\", \"FAIL\", 1050),\n]\nprint(detect_brute_force(logs))",
    "testCases": [
      {
        "input": "logs with 6 failures in 200s",
        "expectedOutput": "Returns IP",
        "isHidden": false,
        "description": "Detect brute force"
      },
      {
        "input": "logs with 3 failures",
        "expectedOutput": "Empty list",
        "isHidden": false,
        "description": "Too few failures"
      },
      {
        "input": "logs with 5 failures in 400s",
        "expectedOutput": "Empty list",
        "isHidden": true,
        "description": "Window too large"
      }
    ],
    "hints": [
      "Filter for failed login attempts",
      "Group by source IP",
      "Check for 5+ failures in 300s window",
      "Use sliding window approach"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Validate DNS Record",
    "difficulty": 2,
    "description": "Write a function to validate a DNS A record format.",
    "starterCode": "def is_valid_dns_a_record(record):\n    # Validate: \"hostname.example.com IN A 192.168.1.1\"\n    pass\n\nprint(is_valid_dns_a_record(\"www.example.com IN A 192.168.1.1\"))\nprint(is_valid_dns_a_record(\"invalid record\"))",
    "solution": "def is_valid_dns_a_record(record):\n    try:\n        parts = record.split()\n        if len(parts) != 4:\n            return False\n\n        hostname, in_class, record_type, ip_address = parts\n\n        # Check IN class\n        if in_class != \"IN\":\n            return False\n\n        # Check A record type\n        if record_type != \"A\":\n            return False\n\n        # Validate IP address\n        ip_parts = ip_address.split('.')\n        if len(ip_parts) != 4:\n            return False\n\n        for part in ip_parts:\n            num = int(part)\n            if num < 0 or num > 255:\n                return False\n\n        return True\n    except (ValueError, IndexError):\n        return False\n\nprint(is_valid_dns_a_record(\"www.example.com IN A 192.168.1.1\"))\nprint(is_valid_dns_a_record(\"invalid record\"))",
    "testCases": [
      {
        "input": "\"www.example.com IN A 192.168.1.1\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid A record"
      },
      {
        "input": "\"invalid record\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid format"
      },
      {
        "input": "\"test.com IN A 256.1.1.1\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Invalid IP"
      }
    ],
    "hints": [
      "Split record into 4 parts",
      "Verify IN class and A type",
      "Validate IP address format",
      "Handle parsing errors"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Parse HTTP Security Headers",
    "difficulty": 3,
    "description": "Write a function to extract security headers from HTTP response headers.",
    "starterCode": "def extract_security_headers(headers_dict):\n    # Extract: CSP, HSTS, X-Frame-Options, etc.\n    pass\n\nheaders = {\n    \"Content-Type\": \"text/html\",\n    \"Strict-Transport-Security\": \"max-age=31536000\",\n    \"X-Frame-Options\": \"DENY\"\n}\nprint(extract_security_headers(headers))",
    "solution": "def extract_security_headers(headers_dict):\n    security_header_names = [\n        'Strict-Transport-Security',\n        'Content-Security-Policy',\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'X-XSS-Protection',\n        'Referrer-Policy'\n    ]\n\n    security_headers = {}\n\n    for header in security_header_names:\n        # Case-insensitive lookup\n        for key, value in headers_dict.items():\n            if key.lower() == header.lower():\n                security_headers[header] = value\n                break\n\n    return security_headers\n\nheaders = {\n    \"Content-Type\": \"text/html\",\n    \"Strict-Transport-Security\": \"max-age=31536000\",\n    \"X-Frame-Options\": \"DENY\"\n}\nprint(extract_security_headers(headers))",
    "testCases": [
      {
        "input": "headers with HSTS",
        "expectedOutput": "dict with HSTS",
        "isHidden": false,
        "description": "Extract HSTS"
      },
      {
        "input": "headers with no security",
        "expectedOutput": "Empty dict",
        "isHidden": false,
        "description": "No security headers"
      },
      {
        "input": "headers with CSP",
        "expectedOutput": "dict with CSP",
        "isHidden": true,
        "description": "Extract CSP"
      }
    ],
    "hints": [
      "Define list of security header names",
      "Search headers dictionary case-insensitively",
      "Return dict of found security headers",
      "Include HSTS, CSP, X-Frame-Options"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Validate MAC Address",
    "difficulty": 1,
    "description": "Write a function to validate MAC address format.",
    "starterCode": "def is_valid_mac_address(mac):\n    # Validate: \"AA:BB:CC:DD:EE:FF\" or \"AA-BB-CC-DD-EE-FF\"\n    pass\n\nprint(is_valid_mac_address(\"AA:BB:CC:DD:EE:FF\"))\nprint(is_valid_mac_address(\"AA:BB:CC:DD:EE\"))\nprint(is_valid_mac_address(\"GG:HH:II:JJ:KK:LL\"))",
    "solution": "def is_valid_mac_address(mac):\n    import re\n\n    # Support both : and - separators\n    pattern = r'^([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}$'\n\n    if re.match(pattern, mac):\n        return True\n    return False\n\nprint(is_valid_mac_address(\"AA:BB:CC:DD:EE:FF\"))\nprint(is_valid_mac_address(\"AA:BB:CC:DD:EE\"))\nprint(is_valid_mac_address(\"GG:HH:II:JJ:KK:LL\"))",
    "testCases": [
      {
        "input": "\"AA:BB:CC:DD:EE:FF\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid MAC with colons"
      },
      {
        "input": "\"AA:BB:CC:DD:EE\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Incomplete MAC"
      },
      {
        "input": "\"AA-BB-CC-DD-EE-FF\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Valid MAC with dashes"
      }
    ],
    "hints": [
      "MAC has 6 pairs of hex digits",
      "Separated by : or -",
      "Use regex or manual parsing",
      "Validate hex characters (0-9, A-F)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Detect DNS Tunneling",
    "difficulty": 4,
    "description": "Write a function to detect potential DNS tunneling based on suspicious domain patterns.",
    "starterCode": "def detect_dns_tunneling(dns_queries):\n    # dns_queries: list of domain names\n    # Flag long, random-looking subdomains\n    pass\n\nqueries = [\n    \"www.google.com\",\n    \"a3f9d8e2b1c4.malicious.com\",\n    \"very-long-random-subdomain-xyz123abc.evil.com\"\n]\nprint(detect_dns_tunneling(queries))",
    "solution": "def detect_dns_tunneling(dns_queries):\n    suspicious_domains = []\n\n    for domain in dns_queries:\n        parts = domain.split('.')\n\n        for part in parts[:-2]:  # Exclude TLD and domain\n            # Check subdomain length\n            if len(part) > 20:\n                suspicious_domains.append(domain)\n                break\n\n            # Check for high entropy (random-looking)\n            if len(part) > 10:\n                # Count hex-like characters\n                hex_chars = sum(1 for c in part if c in '0123456789abcdef')\n                if hex_chars / len(part) > 0.6:  # 60% hex chars\n                    suspicious_domains.append(domain)\n                    break\n\n    return suspicious_domains\n\nqueries = [\n    \"www.google.com\",\n    \"a3f9d8e2b1c4.malicious.com\",\n    \"very-long-random-subdomain-xyz123abc.evil.com\"\n]\nprint(detect_dns_tunneling(queries))",
    "testCases": [
      {
        "input": "Normal domains",
        "expectedOutput": "Empty list",
        "isHidden": false,
        "description": "Legitimate DNS"
      },
      {
        "input": "Long random subdomain",
        "expectedOutput": "Returns domain",
        "isHidden": false,
        "description": "Detect tunneling"
      },
      {
        "input": "High entropy subdomain",
        "expectedOutput": "Returns domain",
        "isHidden": true,
        "description": "Detect encoded data"
      }
    ],
    "hints": [
      "Check subdomain length (> 20 chars suspicious)",
      "Calculate entropy or randomness",
      "Look for hex-encoded patterns",
      "Exclude normal TLD and domain"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "VPN Log Parser",
    "difficulty": 3,
    "description": "Write a function to parse VPN connection logs and extract user, timestamp, and connection status.",
    "starterCode": "def parse_vpn_log(log_line):\n    # Parse: \"2025-12-17 10:00:00 user@example.com CONNECTED from 203.0.113.5\"\n    pass\n\nprint(parse_vpn_log(\"2025-12-17 10:00:00 user@example.com CONNECTED from 203.0.113.5\"))",
    "solution": "def parse_vpn_log(log_line):\n    try:\n        parts = log_line.split()\n        if len(parts) < 6:\n            return None\n\n        timestamp = f\"{parts[0]} {parts[1]}\"\n        user = parts[2]\n        status = parts[3]\n        # parts[4] is \"from\"\n        source_ip = parts[5]\n\n        return {\n            'timestamp': timestamp,\n            'user': user,\n            'status': status,\n            'source_ip': source_ip\n        }\n    except (IndexError, ValueError):\n        return None\n\nprint(parse_vpn_log(\"2025-12-17 10:00:00 user@example.com CONNECTED from 203.0.113.5\"))",
    "testCases": [
      {
        "input": "VPN connect log",
        "expectedOutput": "dict with status=CONNECTED",
        "isHidden": false,
        "description": "Parse connection"
      },
      {
        "input": "VPN disconnect log",
        "expectedOutput": "dict with status=DISCONNECTED",
        "isHidden": false,
        "description": "Parse disconnection"
      },
      {
        "input": "Invalid log",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Handle errors"
      }
    ],
    "hints": [
      "Split log line by spaces",
      "Extract timestamp (first two parts)",
      "Parse user, status, and source IP",
      "Handle malformed logs"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t6-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Check Certificate Chain",
    "difficulty": 4,
    "description": "Write a function to validate a certificate chain by checking issuer/subject relationships.",
    "starterCode": "def validate_cert_chain(certificates):\n    # certificates: list of dicts with 'subject' and 'issuer'\n    # Verify chain: each cert issued by next in chain\n    pass\n\ncerts = [\n    {\"subject\": \"www.example.com\", \"issuer\": \"Intermediate CA\"},\n    {\"subject\": \"Intermediate CA\", \"issuer\": \"Root CA\"},\n    {\"subject\": \"Root CA\", \"issuer\": \"Root CA\"}\n]\nprint(validate_cert_chain(certs))",
    "solution": "def validate_cert_chain(certificates):\n    if not certificates:\n        return False\n\n    # Check each cert is issued by the next\n    for i in range(len(certificates) - 1):\n        current_cert = certificates[i]\n        next_cert = certificates[i + 1]\n\n        # Current cert's issuer should match next cert's subject\n        if current_cert['issuer'] != next_cert['subject']:\n            return False\n\n    # Last cert should be self-signed (root CA)\n    last_cert = certificates[-1]\n    if last_cert['subject'] != last_cert['issuer']:\n        return False\n\n    return True\n\ncerts = [\n    {\"subject\": \"www.example.com\", \"issuer\": \"Intermediate CA\"},\n    {\"subject\": \"Intermediate CA\", \"issuer\": \"Root CA\"},\n    {\"subject\": \"Root CA\", \"issuer\": \"Root CA\"}\n]\nprint(validate_cert_chain(certs))",
    "testCases": [
      {
        "input": "Valid cert chain",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid chain"
      },
      {
        "input": "Broken chain",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid chain"
      },
      {
        "input": "No root CA",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Missing self-signed root"
      }
    ],
    "hints": [
      "Check each cert is issued by next in chain",
      "Verify issuer of cert[i] matches subject of cert[i+1]",
      "Last cert should be self-signed (root CA)",
      "Root CA: subject == issuer"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Parse Vulnerability Severity",
    "difficulty": 1,
    "description": "Write a function to parse vulnerability severity from a scan report line.",
    "starterCode": "def parse_severity(report_line):\n    # Extract: CRITICAL, HIGH, MEDIUM, LOW, INFO\n    pass\n\nprint(parse_severity(\"CVE-2024-1234 | HIGH | SQL Injection in login.php\"))\nprint(parse_severity(\"CVE-2024-5678 | LOW | Information disclosure\"))",
    "solution": "def parse_severity(report_line):\n    severities = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']\n\n    parts = report_line.split('|')\n    if len(parts) < 2:\n        return None\n\n    severity_part = parts[1].strip().upper()\n\n    if severity_part in severities:\n        return severity_part\n\n    return None\n\nprint(parse_severity(\"CVE-2024-1234 | HIGH | SQL Injection in login.php\"))\nprint(parse_severity(\"CVE-2024-5678 | LOW | Information disclosure\"))",
    "testCases": [
      {
        "input": "\"CVE-2024-1234 | HIGH | SQL Injection\"",
        "expectedOutput": "\"HIGH\"",
        "isHidden": false,
        "description": "Parse HIGH severity"
      },
      {
        "input": "\"CVE-2024-5678 | LOW | Info leak\"",
        "expectedOutput": "\"LOW\"",
        "isHidden": false,
        "description": "Parse LOW severity"
      },
      {
        "input": "\"Invalid format\"",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Invalid format"
      }
    ],
    "hints": [
      "Split on pipe character |",
      "Severity is in second field",
      "Strip whitespace and convert to uppercase",
      "Validate against known severities"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Calculate CVSS Base Score",
    "difficulty": 3,
    "description": "Write a simplified function to calculate CVSS v3 base score from attack vector and impact values.",
    "starterCode": "def calculate_cvss_base(attack_vector, impact):\n    # attack_vector: 'NETWORK'=0.85, 'ADJACENT'=0.62, 'LOCAL'=0.55, 'PHYSICAL'=0.2\n    # impact: 'HIGH'=0.56, 'LOW'=0.22, 'NONE'=0\n    # Formula: min(10, attack_vector * impact * 10)\n    pass\n\nprint(calculate_cvss_base('NETWORK', 'HIGH'))\nprint(calculate_cvss_base('LOCAL', 'LOW'))",
    "solution": "def calculate_cvss_base(attack_vector, impact):\n    av_values = {\n        'NETWORK': 0.85,\n        'ADJACENT': 0.62,\n        'LOCAL': 0.55,\n        'PHYSICAL': 0.2\n    }\n\n    impact_values = {\n        'HIGH': 0.56,\n        'LOW': 0.22,\n        'NONE': 0\n    }\n\n    if attack_vector not in av_values or impact not in impact_values:\n        return None\n\n    av = av_values[attack_vector]\n    imp = impact_values[impact]\n\n    # Simplified CVSS calculation\n    score = min(10.0, av * imp * 10)\n    return round(score, 1)\n\nprint(calculate_cvss_base('NETWORK', 'HIGH'))\nprint(calculate_cvss_base('LOCAL', 'LOW'))",
    "testCases": [
      {
        "input": "'NETWORK', 'HIGH'",
        "expectedOutput": "4.8",
        "isHidden": false,
        "description": "Network attack, high impact"
      },
      {
        "input": "'LOCAL', 'LOW'",
        "expectedOutput": "1.2",
        "isHidden": false,
        "description": "Local attack, low impact"
      },
      {
        "input": "'PHYSICAL', 'NONE'",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "No impact"
      }
    ],
    "hints": [
      "Create dictionaries for AV and Impact values",
      "Multiply AV * Impact * 10",
      "Use min() to cap at 10.0",
      "Round to 1 decimal place"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Parse CVE Identifier",
    "difficulty": 1,
    "description": "Write a function to validate and parse CVE identifiers.",
    "starterCode": "def parse_cve(cve_string):\n    # Valid format: CVE-YYYY-NNNNN (year and ID)\n    pass\n\nprint(parse_cve(\"CVE-2024-12345\"))\nprint(parse_cve(\"CVE-99-123\"))\nprint(parse_cve(\"INVALID\"))",
    "solution": "def parse_cve(cve_string):\n    import re\n\n    # CVE format: CVE-YYYY-NNNNN+\n    pattern = r'^CVE-(\\d{4})-(\\d{4,})$'\n\n    match = re.match(pattern, cve_string)\n    if not match:\n        return None\n\n    year = int(match.group(1))\n    cve_id = match.group(2)\n\n    # Year should be reasonable (1999-2099)\n    if year < 1999 or year > 2099:\n        return None\n\n    return {\n        'year': year,\n        'id': cve_id,\n        'full': cve_string\n    }\n\nprint(parse_cve(\"CVE-2024-12345\"))\nprint(parse_cve(\"CVE-99-123\"))\nprint(parse_cve(\"INVALID\"))",
    "testCases": [
      {
        "input": "\"CVE-2024-12345\"",
        "expectedOutput": "dict with year=2024",
        "isHidden": false,
        "description": "Valid CVE"
      },
      {
        "input": "\"CVE-99-123\"",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Invalid year"
      },
      {
        "input": "\"INVALID\"",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Not CVE format"
      }
    ],
    "hints": [
      "Use regex to match CVE-YYYY-NNNNN",
      "Year is 4 digits",
      "ID is 4 or more digits",
      "Validate year is reasonable (1999-2099)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Categorize Vulnerability Type",
    "difficulty": 2,
    "description": "Write a function to categorize vulnerability based on description keywords.",
    "starterCode": "def categorize_vulnerability(description):\n    # Categories: SQL Injection, XSS, CSRF, Buffer Overflow, etc.\n    pass\n\nprint(categorize_vulnerability(\"SQL injection in user login form\"))\nprint(categorize_vulnerability(\"Cross-site scripting in comment field\"))",
    "solution": "def categorize_vulnerability(description):\n    desc_lower = description.lower()\n\n    categories = {\n        'SQL Injection': ['sql injection', 'sqli', 'sql inject'],\n        'XSS': ['cross-site scripting', 'xss', 'javascript injection'],\n        'CSRF': ['cross-site request forgery', 'csrf'],\n        'Buffer Overflow': ['buffer overflow', 'bof', 'stack overflow'],\n        'Authentication': ['authentication', 'auth bypass', 'broken auth'],\n        'Access Control': ['access control', 'authorization', 'privilege escalation'],\n        'Cryptographic': ['weak encryption', 'crypto', 'insecure hash'],\n        'Information Disclosure': ['information disclosure', 'info leak', 'exposure']\n    }\n\n    for category, keywords in categories.items():\n        for keyword in keywords:\n            if keyword in desc_lower:\n                return category\n\n    return 'Other'\n\nprint(categorize_vulnerability(\"SQL injection in user login form\"))\nprint(categorize_vulnerability(\"Cross-site scripting in comment field\"))",
    "testCases": [
      {
        "input": "\"SQL injection in login\"",
        "expectedOutput": "\"SQL Injection\"",
        "isHidden": false,
        "description": "Detect SQLi"
      },
      {
        "input": "\"Cross-site scripting in comments\"",
        "expectedOutput": "\"XSS\"",
        "isHidden": false,
        "description": "Detect XSS"
      },
      {
        "input": "\"Buffer overflow in parser\"",
        "expectedOutput": "\"Buffer Overflow\"",
        "isHidden": true,
        "description": "Detect BOF"
      }
    ],
    "hints": [
      "Create dictionary of categories and keywords",
      "Convert description to lowercase",
      "Check for keyword matches",
      "Return first matching category"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Checklist Validator",
    "difficulty": 2,
    "description": "Write a function to validate that all security checklist items are marked as complete.",
    "starterCode": "def validate_security_checklist(checklist):\n    # checklist: dict with items and status (True/False)\n    # Return list of incomplete items\n    pass\n\nchecklist = {\n    \"HTTPS enabled\": True,\n    \"SQL injection testing\": False,\n    \"Password hashing\": True,\n    \"CSRF protection\": False\n}\nprint(validate_security_checklist(checklist))",
    "solution": "def validate_security_checklist(checklist):\n    incomplete_items = []\n\n    for item, status in checklist.items():\n        if not status:\n            incomplete_items.append(item)\n\n    return incomplete_items\n\nchecklist = {\n    \"HTTPS enabled\": True,\n    \"SQL injection testing\": False,\n    \"Password hashing\": True,\n    \"CSRF protection\": False\n}\nprint(validate_security_checklist(checklist))",
    "testCases": [
      {
        "input": "Checklist with some incomplete",
        "expectedOutput": "List of incomplete items",
        "isHidden": false,
        "description": "Find incomplete items"
      },
      {
        "input": "All items complete",
        "expectedOutput": "Empty list",
        "isHidden": false,
        "description": "All complete"
      },
      {
        "input": "All items incomplete",
        "expectedOutput": "All items listed",
        "isHidden": true,
        "description": "None complete"
      }
    ],
    "hints": [
      "Iterate through checklist items",
      "Check if status is False",
      "Add incomplete items to list",
      "Return list of incomplete items"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Risk Score Calculator",
    "difficulty": 3,
    "description": "Write a function to calculate overall risk score from likelihood and impact ratings.",
    "starterCode": "def calculate_risk_score(likelihood, impact):\n    # likelihood: 1-5 (1=rare, 5=certain)\n    # impact: 1-5 (1=negligible, 5=catastrophic)\n    # Risk = likelihood * impact\n    # Return: score and category (LOW, MEDIUM, HIGH, CRITICAL)\n    pass\n\nprint(calculate_risk_score(3, 4))\nprint(calculate_risk_score(1, 2))",
    "solution": "def calculate_risk_score(likelihood, impact):\n    if not (1 <= likelihood <= 5 and 1 <= impact <= 5):\n        return None\n\n    score = likelihood * impact\n\n    # Categorize risk\n    if score <= 4:\n        category = 'LOW'\n    elif score <= 9:\n        category = 'MEDIUM'\n    elif score <= 16:\n        category = 'HIGH'\n    else:\n        category = 'CRITICAL'\n\n    return {\n        'score': score,\n        'category': category,\n        'likelihood': likelihood,\n        'impact': impact\n    }\n\nprint(calculate_risk_score(3, 4))\nprint(calculate_risk_score(1, 2))",
    "testCases": [
      {
        "input": "3, 4",
        "expectedOutput": "score=12, category=HIGH",
        "isHidden": false,
        "description": "High risk"
      },
      {
        "input": "1, 2",
        "expectedOutput": "score=2, category=LOW",
        "isHidden": false,
        "description": "Low risk"
      },
      {
        "input": "5, 5",
        "expectedOutput": "score=25, category=CRITICAL",
        "isHidden": true,
        "description": "Critical risk"
      }
    ],
    "hints": [
      "Multiply likelihood by impact",
      "Score 1-4: LOW",
      "Score 5-9: MEDIUM",
      "Score 10-16: HIGH, 17+: CRITICAL"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Parse Nmap Output",
    "difficulty": 3,
    "description": "Write a function to parse Nmap scan output and extract open ports.",
    "starterCode": "def parse_nmap_output(nmap_line):\n    # Parse: \"80/tcp   open  http\"\n    pass\n\nprint(parse_nmap_output(\"80/tcp   open  http\"))\nprint(parse_nmap_output(\"443/tcp  open  https\"))\nprint(parse_nmap_output(\"22/tcp   closed ssh\"))",
    "solution": "def parse_nmap_output(nmap_line):\n    try:\n        parts = nmap_line.split()\n        if len(parts) < 3:\n            return None\n\n        # Parse port/protocol\n        port_proto = parts[0].split('/')\n        if len(port_proto) != 2:\n            return None\n\n        port = int(port_proto[0])\n        protocol = port_proto[1]\n        state = parts[1]\n        service = parts[2] if len(parts) > 2 else 'unknown'\n\n        # Only return if port is open\n        if state != 'open':\n            return None\n\n        return {\n            'port': port,\n            'protocol': protocol,\n            'state': state,\n            'service': service\n        }\n    except (ValueError, IndexError):\n        return None\n\nprint(parse_nmap_output(\"80/tcp   open  http\"))\nprint(parse_nmap_output(\"443/tcp  open  https\"))\nprint(parse_nmap_output(\"22/tcp   closed ssh\"))",
    "testCases": [
      {
        "input": "\"80/tcp   open  http\"",
        "expectedOutput": "dict with port=80",
        "isHidden": false,
        "description": "Parse open HTTP port"
      },
      {
        "input": "\"443/tcp  open  https\"",
        "expectedOutput": "dict with service=https",
        "isHidden": false,
        "description": "Parse open HTTPS port"
      },
      {
        "input": "\"22/tcp   closed ssh\"",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Ignore closed ports"
      }
    ],
    "hints": [
      "Split line by whitespace",
      "Parse port/protocol from first field",
      "Extract state and service",
      "Only return open ports"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Static Analysis Rule",
    "difficulty": 2,
    "description": "Write a function to detect hardcoded passwords in code (simple pattern matching).",
    "starterCode": "def detect_hardcoded_password(code_line):\n    # Detect patterns like: password = \"secret123\"\n    pass\n\nprint(detect_hardcoded_password('password = \"secret123\"'))\nprint(detect_hardcoded_password('user = \"admin\"'))",
    "solution": "def detect_hardcoded_password(code_line):\n    import re\n\n    # Patterns for hardcoded passwords\n    patterns = [\n        r'password\\s*=\\s*[\"']\\w+[\"']',\n        r'passwd\\s*=\\s*[\"']\\w+[\"']',\n        r'pwd\\s*=\\s*[\"']\\w+[\"']',\n        r'secret\\s*=\\s*[\"']\\w+[\"']'\n    ]\n\n    code_lower = code_line.lower()\n\n    for pattern in patterns:\n        if re.search(pattern, code_lower):\n            return True\n\n    return False\n\nprint(detect_hardcoded_password('password = \"secret123\"'))\nprint(detect_hardcoded_password('user = \"admin\"'))",
    "testCases": [
      {
        "input": "'password = \"secret123\"'",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Detect hardcoded password"
      },
      {
        "input": "'user = \"admin\"'",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not a password"
      },
      {
        "input": "'SECRET = \"key123\"'",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Detect secret"
      }
    ],
    "hints": [
      "Use regex to match password patterns",
      "Look for: password, passwd, pwd, secret",
      "Match = followed by quoted string",
      "Case-insensitive matching"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Vulnerability Report Aggregator",
    "difficulty": 4,
    "description": "Write a function to aggregate vulnerability counts by severity from multiple scan results.",
    "starterCode": "def aggregate_vulnerabilities(scan_results):\n    # scan_results: list of dicts with 'severity' key\n    # Return counts by severity level\n    pass\n\nresults = [\n    {\"id\": \"V1\", \"severity\": \"HIGH\"},\n    {\"id\": \"V2\", \"severity\": \"MEDIUM\"},\n    {\"id\": \"V3\", \"severity\": \"HIGH\"},\n    {\"id\": \"V4\", \"severity\": \"LOW\"}\n]\nprint(aggregate_vulnerabilities(results))",
    "solution": "def aggregate_vulnerabilities(scan_results):\n    from collections import defaultdict\n\n    severity_counts = defaultdict(int)\n\n    for result in scan_results:\n        severity = result.get('severity', 'UNKNOWN')\n        severity_counts[severity] += 1\n\n    # Convert to regular dict and sort by severity\n    severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO', 'UNKNOWN']\n    ordered_counts = {}\n\n    for severity in severity_order:\n        if severity in severity_counts:\n            ordered_counts[severity] = severity_counts[severity]\n\n    return ordered_counts\n\nresults = [\n    {\"id\": \"V1\", \"severity\": \"HIGH\"},\n    {\"id\": \"V2\", \"severity\": \"MEDIUM\"},\n    {\"id\": \"V3\", \"severity\": \"HIGH\"},\n    {\"id\": \"V4\", \"severity\": \"LOW\"}\n]\nprint(aggregate_vulnerabilities(results))",
    "testCases": [
      {
        "input": "Results with mixed severities",
        "expectedOutput": "dict with counts",
        "isHidden": false,
        "description": "Aggregate counts"
      },
      {
        "input": "Empty results",
        "expectedOutput": "Empty dict",
        "isHidden": false,
        "description": "No vulnerabilities"
      },
      {
        "input": "All same severity",
        "expectedOutput": "Single severity count",
        "isHidden": true,
        "description": "Uniform severity"
      }
    ],
    "hints": [
      "Use defaultdict to count occurrences",
      "Iterate through results",
      "Count by severity level",
      "Order by severity (CRITICAL to LOW)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Fuzzing Input Generator",
    "difficulty": 3,
    "description": "Write a function to generate test inputs for fuzzing by mutating a base input string.",
    "starterCode": "def generate_fuzz_inputs(base_input, mutations=5):\n    # Generate mutations: add special chars, long strings, etc.\n    pass\n\nprint(generate_fuzz_inputs(\"test\", 3))",
    "solution": "def generate_fuzz_inputs(base_input, mutations=5):\n    import random\n\n    fuzz_inputs = [base_input]  # Include original\n\n    # Mutation strategies\n    special_chars = ['<', '>', '\"', \"'\", '&', ';', '|', '\\n', '\\0']\n\n    for _ in range(mutations):\n        mutation_type = random.randint(1, 4)\n\n        if mutation_type == 1:\n            # Add special characters\n            char = random.choice(special_chars)\n            fuzz_inputs.append(base_input + char)\n\n        elif mutation_type == 2:\n            # Repeat string\n            fuzz_inputs.append(base_input * random.randint(10, 100))\n\n        elif mutation_type == 3:\n            # Add long string\n            fuzz_inputs.append(base_input + 'A' * random.randint(100, 1000))\n\n        elif mutation_type == 4:\n            # Insert special char in middle\n            char = random.choice(special_chars)\n            pos = len(base_input) // 2\n            fuzz_inputs.append(base_input[:pos] + char + base_input[pos:])\n\n    return fuzz_inputs\n\nprint(generate_fuzz_inputs(\"test\", 3))",
    "testCases": [
      {
        "input": "\"test\", 3",
        "expectedOutput": "List of 4 inputs",
        "isHidden": false,
        "description": "Generate mutations"
      },
      {
        "input": "\"input\", 5",
        "expectedOutput": "List of 6 inputs",
        "isHidden": false,
        "description": "Multiple mutations"
      },
      {
        "input": "\"a\", 1",
        "expectedOutput": "List of 2 inputs",
        "isHidden": true,
        "description": "Single mutation"
      }
    ],
    "hints": [
      "Include original input in results",
      "Generate mutations: special chars, long strings",
      "Random selection of mutation types",
      "Return list of fuzzed inputs"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Test Case Generator",
    "difficulty": 3,
    "description": "Write a function to generate security test cases for common vulnerabilities.",
    "starterCode": "def generate_security_tests(endpoint_type):\n    # endpoint_type: 'login', 'search', 'file_upload'\n    # Return list of test cases\n    pass\n\nprint(generate_security_tests('login'))",
    "solution": "def generate_security_tests(endpoint_type):\n    test_cases = {\n        'login': [\n            {'test': 'SQL Injection', 'input': \"admin' OR '1'='1\"},\n            {'test': 'XSS', 'input': '<script>alert(1)</script>'},\n            {'test': 'Long password', 'input': 'A' * 10000},\n            {'test': 'Empty credentials', 'input': ''},\n            {'test': 'Special characters', 'input': \"!@#$%^&*()\"}\n        ],\n        'search': [\n            {'test': 'XSS in search', 'input': '<img src=x onerror=alert(1)>'},\n            {'test': 'SQL Injection', 'input': \"' OR 1=1--\"},\n            {'test': 'Long query', 'input': 'search' * 1000},\n            {'test': 'Special chars', 'input': '%00\\n\\r'}\n        ],\n        'file_upload': [\n            {'test': 'Path traversal', 'input': '../../../etc/passwd'},\n            {'test': 'Script upload', 'input': 'shell.php'},\n            {'test': 'Null byte', 'input': 'file.txt\\x00.php'},\n            {'test': 'Large file', 'input': 'A' * 100000000}\n        ]\n    }\n\n    return test_cases.get(endpoint_type, [])\n\nprint(generate_security_tests('login'))",
    "testCases": [
      {
        "input": "'login'",
        "expectedOutput": "List with SQL injection test",
        "isHidden": false,
        "description": "Login tests"
      },
      {
        "input": "'search'",
        "expectedOutput": "List with XSS test",
        "isHidden": false,
        "description": "Search tests"
      },
      {
        "input": "'unknown'",
        "expectedOutput": "Empty list",
        "isHidden": true,
        "description": "Unknown endpoint"
      }
    ],
    "hints": [
      "Create dictionary of endpoint types",
      "Each type has list of test cases",
      "Include SQLi, XSS, and boundary tests",
      "Return relevant tests for endpoint type"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Incident Response Priority",
    "difficulty": 2,
    "description": "Write a function to prioritize security incidents based on severity and affected systems.",
    "starterCode": "def prioritize_incident(severity, affected_systems):\n    # severity: 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW'\n    # affected_systems: number of systems affected\n    # Return priority score (1-10)\n    pass\n\nprint(prioritize_incident('CRITICAL', 50))\nprint(prioritize_incident('LOW', 2))",
    "solution": "def prioritize_incident(severity, affected_systems):\n    severity_scores = {\n        'CRITICAL': 10,\n        'HIGH': 7,\n        'MEDIUM': 4,\n        'LOW': 2\n    }\n\n    base_score = severity_scores.get(severity, 1)\n\n    # Increase priority based on affected systems\n    if affected_systems >= 100:\n        multiplier = 1.5\n    elif affected_systems >= 10:\n        multiplier = 1.3\n    elif affected_systems >= 5:\n        multiplier = 1.1\n    else:\n        multiplier = 1.0\n\n    priority = min(10, int(base_score * multiplier))\n\n    return priority\n\nprint(prioritize_incident('CRITICAL', 50))\nprint(prioritize_incident('LOW', 2))",
    "testCases": [
      {
        "input": "'CRITICAL', 50",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Critical with many systems"
      },
      {
        "input": "'LOW', 2",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Low with few systems"
      },
      {
        "input": "'HIGH', 150",
        "expectedOutput": "10",
        "isHidden": true,
        "description": "High with massive impact"
      }
    ],
    "hints": [
      "Assign base scores to severities",
      "Multiply by affected systems factor",
      "Cap priority at 10",
      "More systems = higher priority"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Compliance Checker",
    "difficulty": 3,
    "description": "Write a function to check if security controls meet compliance requirements (e.g., PCI DSS).",
    "starterCode": "def check_pci_compliance(controls):\n    # controls: dict of security controls\n    # Return: compliant status and missing controls\n    pass\n\ncontrols = {\n    \"firewall\": True,\n    \"encryption\": True,\n    \"access_control\": False,\n    \"monitoring\": True,\n    \"vulnerability_scanning\": False\n}\nprint(check_pci_compliance(controls))",
    "solution": "def check_pci_compliance(controls):\n    required_controls = [\n        'firewall',\n        'encryption',\n        'access_control',\n        'monitoring',\n        'vulnerability_scanning',\n        'secure_systems',\n        'restrict_access'\n    ]\n\n    missing_controls = []\n\n    for control in required_controls:\n        if not controls.get(control, False):\n            missing_controls.append(control)\n\n    is_compliant = len(missing_controls) == 0\n\n    return {\n        'compliant': is_compliant,\n        'missing_controls': missing_controls,\n        'compliance_percentage': int(((len(required_controls) - len(missing_controls)) / len(required_controls)) * 100)\n    }\n\ncontrols = {\n    \"firewall\": True,\n    \"encryption\": True,\n    \"access_control\": False,\n    \"monitoring\": True,\n    \"vulnerability_scanning\": False\n}\nprint(check_pci_compliance(controls))",
    "testCases": [
      {
        "input": "Some controls missing",
        "expectedOutput": "compliant=False, list missing",
        "isHidden": false,
        "description": "Non-compliant"
      },
      {
        "input": "All controls present",
        "expectedOutput": "compliant=True",
        "isHidden": false,
        "description": "Compliant"
      },
      {
        "input": "No controls",
        "expectedOutput": "All missing",
        "isHidden": true,
        "description": "No compliance"
      }
    ],
    "hints": [
      "Define list of required controls",
      "Check each control is True in dict",
      "Track missing controls",
      "Calculate compliance percentage"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Metrics Dashboard",
    "difficulty": 4,
    "description": "Write a function to calculate security metrics from vulnerability scan data.",
    "starterCode": "def calculate_security_metrics(vulnerabilities):\n    # vulnerabilities: list of dicts with severity and status\n    # Return: metrics dict with various KPIs\n    pass\n\nvulns = [\n    {\"severity\": \"HIGH\", \"status\": \"open\", \"days_open\": 30},\n    {\"severity\": \"MEDIUM\", \"status\": \"fixed\", \"days_open\": 5},\n    {\"severity\": \"HIGH\", \"status\": \"open\", \"days_open\": 60}\n]\nprint(calculate_security_metrics(vulns))",
    "solution": "def calculate_security_metrics(vulnerabilities):\n    total = len(vulnerabilities)\n    if total == 0:\n        return {}\n\n    open_vulns = [v for v in vulnerabilities if v['status'] == 'open']\n    fixed_vulns = [v for v in vulnerabilities if v['status'] == 'fixed']\n\n    # Count by severity\n    critical_count = sum(1 for v in vulnerabilities if v.get('severity') == 'CRITICAL')\n    high_count = sum(1 for v in vulnerabilities if v.get('severity') == 'HIGH')\n\n    # Calculate average time to fix\n    if fixed_vulns:\n        avg_time_to_fix = sum(v.get('days_open', 0) for v in fixed_vulns) / len(fixed_vulns)\n    else:\n        avg_time_to_fix = 0\n\n    # Calculate mean time to remediate (MTTR)\n    open_days = [v.get('days_open', 0) for v in open_vulns]\n    avg_open_days = sum(open_days) / len(open_days) if open_days else 0\n\n    return {\n        'total_vulnerabilities': total,\n        'open_count': len(open_vulns),\n        'fixed_count': len(fixed_vulns),\n        'critical_high_count': critical_count + high_count,\n        'fix_rate': round((len(fixed_vulns) / total) * 100, 1),\n        'avg_time_to_fix': round(avg_time_to_fix, 1),\n        'avg_open_days': round(avg_open_days, 1)\n    }\n\nvulns = [\n    {\"severity\": \"HIGH\", \"status\": \"open\", \"days_open\": 30},\n    {\"severity\": \"MEDIUM\", \"status\": \"fixed\", \"days_open\": 5},\n    {\"severity\": \"HIGH\", \"status\": \"open\", \"days_open\": 60}\n]\nprint(calculate_security_metrics(vulns))",
    "testCases": [
      {
        "input": "Mix of open and fixed vulns",
        "expectedOutput": "Metrics dict",
        "isHidden": false,
        "description": "Calculate all metrics"
      },
      {
        "input": "All fixed vulns",
        "expectedOutput": "fix_rate=100",
        "isHidden": false,
        "description": "Perfect fix rate"
      },
      {
        "input": "Empty list",
        "expectedOutput": "Empty dict",
        "isHidden": true,
        "description": "No data"
      }
    ],
    "hints": [
      "Count total, open, and fixed vulns",
      "Calculate fix rate percentage",
      "Compute average time to fix",
      "Track critical/high severity counts"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Penetration Test Report Parser",
    "difficulty": 4,
    "description": "Write a function to parse penetration test findings and extract actionable remediation steps.",
    "starterCode": "def parse_pentest_finding(finding_text):\n    # Extract: title, severity, description, remediation\n    pass\n\nfinding = \"\"\"\nFINDING: SQL Injection in Login Form\nSEVERITY: CRITICAL\nDESCRIPTION: The login form is vulnerable to SQL injection attacks.\nREMEDIATION: Use parameterized queries and input validation.\n\"\"\"\nprint(parse_pentest_finding(finding))",
    "solution": "def parse_pentest_finding(finding_text):\n    lines = finding_text.strip().split('\\n')\n\n    finding_data = {\n        'title': '',\n        'severity': '',\n        'description': '',\n        'remediation': ''\n    }\n\n    current_field = None\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n\n        if line.startswith('FINDING:'):\n            current_field = 'title'\n            finding_data['title'] = line.replace('FINDING:', '').strip()\n        elif line.startswith('SEVERITY:'):\n            current_field = 'severity'\n            finding_data['severity'] = line.replace('SEVERITY:', '').strip()\n        elif line.startswith('DESCRIPTION:'):\n            current_field = 'description'\n            finding_data['description'] = line.replace('DESCRIPTION:', '').strip()\n        elif line.startswith('REMEDIATION:'):\n            current_field = 'remediation'\n            finding_data['remediation'] = line.replace('REMEDIATION:', '').strip()\n        elif current_field:\n            # Continuation of previous field\n            finding_data[current_field] += ' ' + line\n\n    return finding_data\n\nfinding = \"\"\"\nFINDING: SQL Injection in Login Form\nSEVERITY: CRITICAL\nDESCRIPTION: The login form is vulnerable to SQL injection attacks.\nREMEDIATION: Use parameterized queries and input validation.\n\"\"\"\nprint(parse_pentest_finding(finding))",
    "testCases": [
      {
        "input": "Full finding text",
        "expectedOutput": "dict with all fields",
        "isHidden": false,
        "description": "Parse complete finding"
      },
      {
        "input": "Partial finding",
        "expectedOutput": "dict with some fields",
        "isHidden": false,
        "description": "Handle incomplete data"
      },
      {
        "input": "Multi-line description",
        "expectedOutput": "Combined description",
        "isHidden": true,
        "description": "Multi-line fields"
      }
    ],
    "hints": [
      "Split text by newlines",
      "Look for field markers (FINDING:, SEVERITY:, etc.)",
      "Extract content after markers",
      "Handle multi-line field values"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t7-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Baseline Validator",
    "difficulty": 4,
    "description": "Write a function to validate system configuration against security baseline requirements.",
    "starterCode": "def validate_security_baseline(system_config, baseline):\n    # Compare system config against baseline\n    # Return deviations and compliance score\n    pass\n\nconfig = {\n    \"password_min_length\": 8,\n    \"session_timeout\": 3600,\n    \"encryption_enabled\": True,\n    \"audit_logging\": False\n}\n\nbaseline = {\n    \"password_min_length\": 12,\n    \"session_timeout\": 1800,\n    \"encryption_enabled\": True,\n    \"audit_logging\": True\n}\n\nprint(validate_security_baseline(config, baseline))",
    "solution": "def validate_security_baseline(system_config, baseline):\n    deviations = []\n    compliant_items = 0\n    total_items = len(baseline)\n\n    for setting, required_value in baseline.items():\n        actual_value = system_config.get(setting)\n\n        if actual_value is None:\n            deviations.append({\n                'setting': setting,\n                'issue': 'missing',\n                'required': required_value,\n                'actual': None\n            })\n        elif isinstance(required_value, bool):\n            # Boolean check\n            if actual_value != required_value:\n                deviations.append({\n                    'setting': setting,\n                    'issue': 'non-compliant',\n                    'required': required_value,\n                    'actual': actual_value\n                })\n            else:\n                compliant_items += 1\n        elif isinstance(required_value, (int, float)):\n            # Numeric check (actual should be >= required for security)\n            if actual_value < required_value:\n                deviations.append({\n                    'setting': setting,\n                    'issue': 'below_minimum',\n                    'required': required_value,\n                    'actual': actual_value\n                })\n            else:\n                compliant_items += 1\n        else:\n            # String or other check\n            if actual_value != required_value:\n                deviations.append({\n                    'setting': setting,\n                    'issue': 'non-compliant',\n                    'required': required_value,\n                    'actual': actual_value\n                })\n            else:\n                compliant_items += 1\n\n    compliance_score = int((compliant_items / total_items) * 100) if total_items > 0 else 0\n\n    return {\n        'compliant': len(deviations) == 0,\n        'compliance_score': compliance_score,\n        'deviations': deviations,\n        'total_checks': total_items\n    }\n\nconfig = {\n    \"password_min_length\": 8,\n    \"session_timeout\": 3600,\n    \"encryption_enabled\": True,\n    \"audit_logging\": False\n}\n\nbaseline = {\n    \"password_min_length\": 12,\n    \"session_timeout\": 1800,\n    \"encryption_enabled\": True,\n    \"audit_logging\": True\n}\n\nprint(validate_security_baseline(config, baseline))",
    "testCases": [
      {
        "input": "Config with deviations",
        "expectedOutput": "List of deviations",
        "isHidden": false,
        "description": "Find non-compliance"
      },
      {
        "input": "Fully compliant config",
        "expectedOutput": "compliance_score=100",
        "isHidden": false,
        "description": "Perfect compliance"
      },
      {
        "input": "Missing settings",
        "expectedOutput": "Missing settings flagged",
        "isHidden": true,
        "description": "Handle missing config"
      }
    ],
    "hints": [
      "Compare each baseline setting to actual config",
      "Check for missing settings",
      "Validate numeric values (actual >= required)",
      "Calculate compliance percentage"
    ],
    "language": "python"
  }
]
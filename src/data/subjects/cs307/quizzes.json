[
  {
    "id": "cs307-quiz-1-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Principles - CIA Triad and Threat Modeling",
    "questions": [
      {
        "id": "cs307-q1",
        "type": "multiple_choice",
        "prompt": "Which component of the CIA triad ensures that data is protected from unauthorized modifications?",
        "options": [
          "Confidentiality",
          "Integrity",
          "Availability",
          "Authentication"
        ],
        "correctAnswer": "Integrity",
        "explanation": "Integrity ensures that data remains accurate and unaltered by unauthorized parties. Confidentiality protects against unauthorized access, while Availability ensures systems remain accessible."
      },
      {
        "id": "cs307-q2",
        "type": "true_false",
        "prompt": "Defense in depth means relying on a single, strong security control to protect your system.",
        "correctAnswer": "false",
        "explanation": "Defense in depth is the opposite - it involves layering multiple security controls so that if one fails, others are still in place to protect the system."
      },
      {
        "id": "cs307-q3",
        "type": "multiple_choice",
        "prompt": "What does the principle of least privilege recommend?",
        "options": [
          "Grant all users administrative access for convenience",
          "Users should have only the minimum permissions necessary to perform their job",
          "Privilege escalation should be enabled by default",
          "All permissions should be granted temporarily"
        ],
        "correctAnswer": "Users should have only the minimum permissions necessary to perform their job",
        "explanation": "The principle of least privilege states that users, programs, and processes should have only the minimum privileges necessary to complete their tasks, reducing the attack surface."
      },
      {
        "id": "cs307-q4",
        "type": "multiple_choice",
        "prompt": "In threat modeling, what does STRIDE stand for?",
        "options": [
          "Security, Threats, Risks, Implementation, Detection, Evaluation",
          "Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege",
          "System, Testing, Review, Integration, Deployment, Execution",
          "Strategies, Tactics, Risks, Incidents, Defense, Escalation"
        ],
        "correctAnswer": "Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege",
        "explanation": "STRIDE is a threat modeling framework developed by Microsoft that categorizes threats into six types: Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, and Elevation of Privilege."
      },
      {
        "id": "cs307-q5",
        "type": "true_false",
        "prompt": "Availability in the CIA triad refers to ensuring that authorized users can access systems and data when needed.",
        "correctAnswer": "true",
        "explanation": "Availability ensures that systems, applications, and data are accessible to authorized users when required. DDoS attacks and system failures are common threats to availability."
      }
    ]
  },
  {
    "id": "cs307-quiz-1-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Principles - Defense in Depth and Secure Design",
    "questions": [
      {
        "id": "cs307-q6",
        "type": "multiple_choice",
        "prompt": "Which security principle suggests that a system should fail in a secure state?",
        "options": [
          "Fail-open",
          "Fail-secure (fail-closed)",
          "Fail-fast",
          "Fail-over"
        ],
        "correctAnswer": "Fail-secure (fail-closed)",
        "explanation": "Fail-secure (or fail-closed) means that when a system encounters an error or failure, it should default to a secure state that denies access rather than allowing unrestricted access."
      },
      {
        "id": "cs307-q7",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of security through obscurity?",
        "options": [
          "It is a recommended best practice for all security systems",
          "Hiding implementation details as the sole security measure",
          "Encrypting all data at rest",
          "Using complex passwords"
        ],
        "correctAnswer": "Hiding implementation details as the sole security measure",
        "explanation": "Security through obscurity relies on keeping the implementation secret. This is generally discouraged as a primary security measure because once the secret is discovered, the system is compromised. It may be used as an additional layer but never as the only defense."
      },
      {
        "id": "cs307-q8",
        "type": "true_false",
        "prompt": "The principle of separation of duties helps prevent fraud by requiring multiple people to complete critical tasks.",
        "correctAnswer": "true",
        "explanation": "Separation of duties divides critical functions among multiple people to prevent fraud and errors. For example, the person who approves payments should not be the same person who processes them."
      },
      {
        "id": "cs307-q9",
        "type": "multiple_choice",
        "prompt": "What does the principle of \"complete mediation\" require?",
        "options": [
          "All access attempts must be checked every time",
          "Access checks should be cached for performance",
          "Only the first access attempt needs verification",
          "Mediation should only occur during login"
        ],
        "correctAnswer": "All access attempts must be checked every time",
        "explanation": "Complete mediation requires that every access to every resource is checked against the access control mechanism. This prevents attackers from exploiting cached permissions or bypassing checks after initial authentication."
      },
      {
        "id": "cs307-q10",
        "type": "multiple_choice",
        "prompt": "Which concept describes the attack surface of a system?",
        "options": [
          "The total number of users in the system",
          "The sum of all points where an attacker can try to enter or extract data",
          "The physical size of the data center",
          "The number of lines of code in the application"
        ],
        "correctAnswer": "The sum of all points where an attacker can try to enter or extract data",
        "explanation": "The attack surface encompasses all the different points where an unauthorized user could potentially enter data or extract data from a system. Reducing the attack surface is a key security principle."
      }
    ]
  },
  {
    "id": "cs307-quiz-1-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-1",
    "title": "Security Principles - Zero Trust and Attack Surface",
    "questions": [
      {
        "id": "cs307-q11",
        "type": "true_false",
        "prompt": "A zero-trust security model assumes that nothing inside or outside the network perimeter should be trusted by default.",
        "correctAnswer": "true",
        "explanation": "Zero-trust architecture operates on the principle of \"never trust, always verify.\" It assumes breach and verifies every request regardless of where it originates, eliminating implicit trust based on network location."
      },
      {
        "id": "cs307-q12",
        "type": "multiple_choice",
        "prompt": "What is the primary goal of threat modeling?",
        "options": [
          "To eliminate all possible threats",
          "To identify, prioritize, and mitigate potential security threats early in development",
          "To create a list of past security incidents",
          "To test the system for vulnerabilities after deployment"
        ],
        "correctAnswer": "To identify, prioritize, and mitigate potential security threats early in development",
        "explanation": "Threat modeling is a proactive approach to identify potential security threats and vulnerabilities early in the development lifecycle, allowing teams to prioritize and implement appropriate countermeasures before deployment."
      },
      {
        "id": "cs307-q13",
        "type": "multiple_choice",
        "prompt": "Which principle states that security mechanisms should be simple and easy to understand?",
        "options": [
          "Economy of mechanism",
          "Psychological acceptability",
          "Open design",
          "Least common mechanism"
        ],
        "correctAnswer": "Economy of mechanism",
        "explanation": "Economy of mechanism (also called simplicity) advocates for keeping security designs as simple as possible. Simple mechanisms are easier to verify, test, and are less likely to contain vulnerabilities than complex ones."
      },
      {
        "id": "cs307-q14",
        "type": "true_false",
        "prompt": "The principle of open design suggests that security should rely on keeping the design secret.",
        "correctAnswer": "false",
        "explanation": "The principle of open design (Kerckhoffs's principle) states that the security of a system should not depend on the secrecy of its design. Instead, security should rely on the secrecy of keys or credentials, allowing the design to be publicly scrutinized."
      },
      {
        "id": "cs307-q15",
        "type": "multiple_choice",
        "prompt": "What is the main benefit of implementing defense in depth?",
        "options": [
          "It eliminates the need for security updates",
          "It provides multiple layers of protection so compromise of one layer doesn't compromise the entire system",
          "It makes systems immune to all attacks",
          "It reduces the cost of security implementation"
        ],
        "correctAnswer": "It provides multiple layers of protection so compromise of one layer doesn't compromise the entire system",
        "explanation": "Defense in depth uses multiple, overlapping security controls. If one layer is compromised, additional layers continue to provide protection, making it significantly harder for attackers to breach the entire system."
      }
    ]
  },
  {
    "id": "cs307-quiz-2-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Cryptography - Encryption and Digital Signatures",
    "questions": [
      {
        "id": "cs307-q16",
        "type": "multiple_choice",
        "prompt": "Which type of encryption uses the same key for both encryption and decryption?",
        "options": [
          "Asymmetric encryption",
          "Public key encryption",
          "Symmetric encryption",
          "Hashing"
        ],
        "correctAnswer": "Symmetric encryption",
        "explanation": "Symmetric encryption uses the same secret key for both encryption and decryption. Examples include AES, DES, and ChaCha20. It is faster than asymmetric encryption but requires secure key distribution."
      },
      {
        "id": "cs307-q17",
        "type": "true_false",
        "prompt": "Hashing is a reversible process that allows you to decrypt data back to its original form.",
        "correctAnswer": "false",
        "explanation": "Hashing is a one-way function that produces a fixed-size output from any input. It is designed to be irreversible - you cannot recover the original data from a hash. This makes it ideal for password storage and data integrity verification."
      },
      {
        "id": "cs307-q18",
        "type": "multiple_choice",
        "prompt": "In asymmetric encryption, which key should be used to encrypt a message that only the recipient can decrypt?",
        "options": [
          "The sender's private key",
          "The sender's public key",
          "The recipient's private key",
          "The recipient's public key"
        ],
        "correctAnswer": "The recipient's public key",
        "explanation": "To send a confidential message, you encrypt with the recipient's public key. Only the recipient can decrypt it with their corresponding private key. This ensures confidentiality even if the public key is widely known."
      },
      {
        "id": "cs307-q19",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of a digital signature?",
        "options": [
          "To encrypt the message content",
          "To verify the authenticity and integrity of a message",
          "To compress data",
          "To hide the sender's identity"
        ],
        "correctAnswer": "To verify the authenticity and integrity of a message",
        "explanation": "Digital signatures provide authentication (proving who sent the message) and integrity (proving the message wasn't altered). The sender signs with their private key, and anyone can verify with the sender's public key."
      },
      {
        "id": "cs307-q20",
        "type": "true_false",
        "prompt": "AES (Advanced Encryption Standard) is an example of symmetric encryption.",
        "correctAnswer": "true",
        "explanation": "AES is a widely-used symmetric encryption algorithm that uses the same key for encryption and decryption. It supports key sizes of 128, 192, and 256 bits and is considered very secure when properly implemented."
      }
    ]
  },
  {
    "id": "cs307-quiz-2-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Cryptography - Hashing and Password Security",
    "questions": [
      {
        "id": "cs307-q21",
        "type": "multiple_choice",
        "prompt": "Which cryptographic hash function is currently considered broken and should not be used for security purposes?",
        "options": [
          "SHA-256",
          "SHA-3",
          "MD5",
          "BLAKE2"
        ],
        "correctAnswer": "MD5",
        "explanation": "MD5 (Message Digest 5) is cryptographically broken and unsuitable for security applications. Collision attacks have been demonstrated, making it possible to create two different inputs that produce the same hash. Use SHA-256 or SHA-3 instead."
      },
      {
        "id": "cs307-q22",
        "type": "true_false",
        "prompt": "In public key cryptography, the private key can be mathematically derived from the public key.",
        "correctAnswer": "false",
        "explanation": "While the public key is mathematically related to the private key, it is computationally infeasible to derive the private key from the public key. This one-way property is based on hard mathematical problems like factoring large numbers or discrete logarithms."
      },
      {
        "id": "cs307-q23",
        "type": "multiple_choice",
        "prompt": "What is a rainbow table attack used for?",
        "options": [
          "Encrypting network traffic",
          "Cracking hashed passwords using precomputed hash values",
          "Generating random encryption keys",
          "Detecting SQL injection attacks"
        ],
        "correctAnswer": "Cracking hashed passwords using precomputed hash values",
        "explanation": "A rainbow table is a precomputed table of hash values for common passwords. Attackers use these to quickly reverse hashes and discover passwords. Salting passwords before hashing defeats rainbow table attacks."
      },
      {
        "id": "cs307-q24",
        "type": "multiple_choice",
        "prompt": "What is the purpose of adding a salt to a password before hashing?",
        "options": [
          "To make the password longer",
          "To ensure identical passwords produce different hashes",
          "To encrypt the password",
          "To compress the password"
        ],
        "correctAnswer": "To ensure identical passwords produce different hashes",
        "explanation": "A salt is random data added to passwords before hashing. This ensures that even identical passwords produce different hashes, preventing rainbow table attacks and making it impossible to identify users with the same password."
      },
      {
        "id": "cs307-q25",
        "type": "true_false",
        "prompt": "RSA is an asymmetric encryption algorithm based on the mathematical difficulty of factoring large prime numbers.",
        "correctAnswer": "true",
        "explanation": "RSA (Rivest-Shamir-Adleman) is an asymmetric encryption algorithm whose security relies on the computational difficulty of factoring the product of two large prime numbers. This makes it infeasible to derive the private key from the public key."
      }
    ]
  },
  {
    "id": "cs307-quiz-2-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-2",
    "title": "Cryptography - PKI and End-to-End Encryption",
    "questions": [
      {
        "id": "cs307-q26",
        "type": "multiple_choice",
        "prompt": "What is the main advantage of symmetric encryption over asymmetric encryption?",
        "options": [
          "Better key distribution",
          "Significantly faster performance",
          "No need for key management",
          "Provides digital signatures"
        ],
        "correctAnswer": "Significantly faster performance",
        "explanation": "Symmetric encryption is much faster than asymmetric encryption, making it suitable for encrypting large amounts of data. However, it requires secure key distribution, which is why hybrid approaches often use asymmetric encryption to exchange symmetric keys."
      },
      {
        "id": "cs307-q27",
        "type": "true_false",
        "prompt": "A cryptographic nonce should be reused across multiple encryption operations to maintain consistency.",
        "correctAnswer": "false",
        "explanation": "A nonce (number used once) must never be reused with the same key in most encryption modes. Reusing a nonce can completely compromise security, potentially allowing attackers to decrypt messages or forge authenticated data."
      },
      {
        "id": "cs307-q28",
        "type": "multiple_choice",
        "prompt": "Which cryptographic primitive provides only integrity checking, not confidentiality?",
        "options": [
          "AES encryption",
          "RSA encryption",
          "HMAC (Hash-based Message Authentication Code)",
          "TLS handshake"
        ],
        "correctAnswer": "HMAC (Hash-based Message Authentication Code)",
        "explanation": "HMAC uses a cryptographic hash function and a secret key to verify both data integrity and authenticity. However, it does not encrypt the data, so it provides no confidentiality. The message remains readable but tampering can be detected."
      },
      {
        "id": "cs307-q29",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a Certificate Authority (CA) in public key infrastructure?",
        "options": [
          "To generate encryption keys for users",
          "To issue and verify digital certificates that bind public keys to identities",
          "To store all private keys securely",
          "To decrypt messages on behalf of users"
        ],
        "correctAnswer": "To issue and verify digital certificates that bind public keys to identities",
        "explanation": "A Certificate Authority is a trusted entity that issues digital certificates, which bind public keys to specific identities (like domain names or organizations). This allows users to trust that a public key actually belongs to who it claims to belong to."
      },
      {
        "id": "cs307-q30",
        "type": "true_false",
        "prompt": "End-to-end encryption ensures that only the sender and intended recipient can read the messages, not even the service provider.",
        "correctAnswer": "true",
        "explanation": "End-to-end encryption (E2EE) encrypts data on the sender's device and only decrypts it on the recipient's device. The service provider transmitting the data cannot access the content, only the encrypted form, ensuring maximum privacy."
      }
    ]
  },
  {
    "id": "cs307-quiz-3-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Authentication - MFA and OAuth Fundamentals",
    "questions": [
      {
        "id": "cs307-q31",
        "type": "multiple_choice",
        "prompt": "What are the three primary factors of authentication?",
        "options": [
          "Username, password, email",
          "Something you know, something you have, something you are",
          "Encryption, hashing, signing",
          "Local, network, cloud"
        ],
        "correctAnswer": "Something you know, something you have, something you are",
        "explanation": "The three authentication factors are: something you know (password, PIN), something you have (token, phone, smart card), and something you are (biometrics like fingerprint, face). Multi-factor authentication combines two or more of these."
      },
      {
        "id": "cs307-q32",
        "type": "true_false",
        "prompt": "Multi-factor authentication (MFA) significantly increases security even if one factor is compromised.",
        "correctAnswer": "true",
        "explanation": "MFA requires multiple independent factors for authentication. Even if an attacker obtains your password (something you know), they still need your second factor (like a phone or biometric), making unauthorized access much more difficult."
      },
      {
        "id": "cs307-q33",
        "type": "multiple_choice",
        "prompt": "In OAuth 2.0, what is the purpose of an access token?",
        "options": [
          "To store the user's password",
          "To grant limited access to resources without sharing credentials",
          "To encrypt network traffic",
          "To authenticate the user's identity"
        ],
        "correctAnswer": "To grant limited access to resources without sharing credentials",
        "explanation": "An OAuth access token is a credential that allows applications to access specific resources on behalf of a user without requiring the user's password. Tokens can have limited scope and expiration times for enhanced security."
      },
      {
        "id": "cs307-q34",
        "type": "multiple_choice",
        "prompt": "What does RBAC stand for in access control?",
        "options": [
          "Rule-Based Access Control",
          "Role-Based Access Control",
          "Remote-Based Access Control",
          "Recursive-Based Access Control"
        ],
        "correctAnswer": "Role-Based Access Control",
        "explanation": "RBAC (Role-Based Access Control) assigns permissions to roles rather than individual users. Users are then assigned roles, simplifying permission management in large organizations. For example, all \"Managers\" might have the same set of permissions."
      },
      {
        "id": "cs307-q35",
        "type": "true_false",
        "prompt": "Password complexity requirements (special characters, numbers) are more important than password length for security.",
        "correctAnswer": "false",
        "explanation": "Modern security guidance emphasizes password length over complexity. A long passphrase like \"correct-horse-battery-staple\" is more secure and memorable than complex but short passwords like \"P@ssw0rd!\". Length exponentially increases the keyspace."
      }
    ]
  },
  {
    "id": "cs307-quiz-3-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Authentication - Password Security and RBAC/ABAC",
    "questions": [
      {
        "id": "cs307-q36",
        "type": "multiple_choice",
        "prompt": "What is the main security advantage of using a password manager?",
        "options": [
          "It eliminates the need for passwords",
          "It allows you to use strong, unique passwords for every service without memorizing them",
          "It automatically detects phishing attempts",
          "It encrypts all network traffic"
        ],
        "correctAnswer": "It allows you to use strong, unique passwords for every service without memorizing them",
        "explanation": "Password managers securely store unique, complex passwords for each service. This prevents password reuse attacks where a breach on one service compromises other accounts. Users only need to remember one strong master password."
      },
      {
        "id": "cs307-q37",
        "type": "true_false",
        "prompt": "ABAC (Attribute-Based Access Control) makes access decisions based on attributes of users, resources, and environment.",
        "correctAnswer": "true",
        "explanation": "ABAC evaluates multiple attributes to make access decisions. For example, access might be granted if: user.department=\"Finance\" AND resource.classification=\"Confidential\" AND time.hour < 18 AND location=\"Office\". This provides more granular control than RBAC."
      },
      {
        "id": "cs307-q38",
        "type": "multiple_choice",
        "prompt": "What security risk does OAuth 2.0 mitigate by using authorization codes and redirect URIs?",
        "options": [
          "SQL injection",
          "Token theft through compromised client applications",
          "DDoS attacks",
          "Man-in-the-middle attacks during token exchange"
        ],
        "correctAnswer": "Man-in-the-middle attacks during token exchange",
        "explanation": "OAuth 2.0's authorization code flow with PKCE (Proof Key for Code Exchange) prevents attackers from intercepting authorization codes and exchanging them for tokens. The code is exchanged for tokens on the backend, and PKCE ensures the same client that requested the code exchanges it."
      },
      {
        "id": "cs307-q39",
        "type": "multiple_choice",
        "prompt": "Which of the following is the most secure method for implementing MFA?",
        "options": [
          "SMS-based one-time codes",
          "Email-based verification codes",
          "Hardware security keys using FIDO2/WebAuthn",
          "Security questions"
        ],
        "correctAnswer": "Hardware security keys using FIDO2/WebAuthn",
        "explanation": "Hardware security keys using FIDO2/WebAuthn are the most secure MFA method. They are phishing-resistant, don't rely on SMS (which can be intercepted), and use public key cryptography. SMS-based codes are vulnerable to SIM swapping and interception."
      },
      {
        "id": "cs307-q40",
        "type": "true_false",
        "prompt": "Session tokens should be stored in browser localStorage for easy access across tabs.",
        "correctAnswer": "false",
        "explanation": "Session tokens should not be stored in localStorage because they are accessible to any JavaScript on the page, including malicious scripts (XSS attacks). HttpOnly cookies are more secure because they cannot be accessed by JavaScript, only sent automatically with requests."
      }
    ]
  },
  {
    "id": "cs307-quiz-3-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Authentication - JWT, Session Management, and Biometrics",
    "questions": [
      {
        "id": "cs307-q41",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of JWT (JSON Web Token) in authentication?",
        "options": [
          "To encrypt user passwords",
          "To provide a self-contained token that carries claims about the user",
          "To replace HTTPS",
          "To store session data on the server"
        ],
        "correctAnswer": "To provide a self-contained token that carries claims about the user",
        "explanation": "JWTs are self-contained tokens that include claims (like user ID, roles, expiration) and are digitally signed. Servers can verify and trust the token without storing session state, making them useful for stateless authentication in distributed systems."
      },
      {
        "id": "cs307-q42",
        "type": "true_false",
        "prompt": "Account lockout mechanisms that permanently disable accounts after failed login attempts improve security without drawbacks.",
        "correctAnswer": "false",
        "explanation": "While account lockout can prevent brute force attacks, permanent lockouts create a denial-of-service vulnerability where attackers can lock out legitimate users. Better approaches include temporary lockouts, rate limiting, CAPTCHA, or alerting users of suspicious activity."
      },
      {
        "id": "cs307-q43",
        "type": "multiple_choice",
        "prompt": "What is the main difference between authentication and authorization?",
        "options": [
          "There is no difference; they are the same thing",
          "Authentication verifies identity; authorization determines what actions are permitted",
          "Authentication is for users; authorization is for systems",
          "Authorization verifies identity; authentication determines permissions"
        ],
        "correctAnswer": "Authentication verifies identity; authorization determines what actions are permitted",
        "explanation": "Authentication answers \"Who are you?\" (verifying identity through credentials), while authorization answers \"What are you allowed to do?\" (determining permissions based on identity). Both are crucial but serve different purposes in access control."
      },
      {
        "id": "cs307-q44",
        "type": "multiple_choice",
        "prompt": "Which OAuth 2.0 grant type is most appropriate for server-side web applications?",
        "options": [
          "Implicit grant",
          "Authorization code grant",
          "Client credentials grant",
          "Resource owner password credentials grant"
        ],
        "correctAnswer": "Authorization code grant",
        "explanation": "The authorization code grant (with PKCE) is most secure for web applications because the access token is obtained server-side and never exposed to the browser. The implicit grant is deprecated due to security concerns, and client credentials are for machine-to-machine communication."
      },
      {
        "id": "cs307-q45",
        "type": "true_false",
        "prompt": "Biometric authentication factors (like fingerprints) should be used as passwords that are transmitted to servers for verification.",
        "correctAnswer": "false",
        "explanation": "Biometric data should never be transmitted or stored as passwords because you can't change your fingerprints if they're compromised. Instead, biometrics should unlock local devices which then use cryptographic keys for authentication, or be processed locally to generate authentication tokens."
      }
    ]
  },
  {
    "id": "cs307-quiz-4-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Vulnerabilities - OWASP Top 10 Fundamentals",
    "questions": [
      {
        "id": "cs307-q46",
        "type": "multiple_choice",
        "prompt": "Which OWASP Top 10 vulnerability occurs when an application includes untrusted data in SQL queries?",
        "options": [
          "Cross-Site Scripting (XSS)",
          "Injection",
          "Broken Authentication",
          "Security Misconfiguration"
        ],
        "correctAnswer": "Injection",
        "explanation": "SQL injection is a type of injection vulnerability where attackers insert malicious SQL code into queries. This can lead to unauthorized data access, modification, or deletion. Parameterized queries and prepared statements prevent SQL injection."
      },
      {
        "id": "cs307-q47",
        "type": "true_false",
        "prompt": "Cross-Site Scripting (XSS) attacks allow attackers to execute malicious scripts in victims' browsers.",
        "correctAnswer": "true",
        "explanation": "XSS vulnerabilities allow attackers to inject malicious JavaScript into web pages viewed by other users. This can steal cookies, session tokens, or sensitive data, perform actions on behalf of users, or redirect to malicious sites."
      },
      {
        "id": "cs307-q48",
        "type": "multiple_choice",
        "prompt": "What is the primary defense against Cross-Site Request Forgery (CSRF) attacks?",
        "options": [
          "Using HTTPS for all connections",
          "Implementing CSRF tokens that are validated on state-changing requests",
          "Encrypting all form data",
          "Using strong passwords"
        ],
        "correctAnswer": "Implementing CSRF tokens that are validated on state-changing requests",
        "explanation": "CSRF tokens are unpredictable values tied to user sessions that must be included in state-changing requests. Attackers cannot guess these tokens, preventing them from forging requests. SameSite cookies also provide CSRF protection."
      },
      {
        "id": "cs307-q49",
        "type": "multiple_choice",
        "prompt": "What type of vulnerability occurs when applications expose references to internal objects like database keys?",
        "options": [
          "Insecure Direct Object Reference (IDOR)",
          "SQL Injection",
          "XSS",
          "Buffer Overflow"
        ],
        "correctAnswer": "Insecure Direct Object Reference (IDOR)",
        "explanation": "IDOR vulnerabilities occur when applications expose direct references to internal objects (like /user/1234) without proper authorization checks. Attackers can manipulate these references to access unauthorized data by changing IDs in URLs or parameters."
      },
      {
        "id": "cs307-q50",
        "type": "true_false",
        "prompt": "Buffer overflow vulnerabilities only affect interpreted languages like Python and JavaScript.",
        "correctAnswer": "false",
        "explanation": "Buffer overflow vulnerabilities primarily affect compiled languages like C and C++ that don't perform automatic bounds checking. When programs write more data to a buffer than it can hold, they can overwrite adjacent memory, potentially allowing code execution. Modern languages like Python and Java are not susceptible to traditional buffer overflows."
      }
    ]
  },
  {
    "id": "cs307-quiz-4-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Vulnerabilities - XSS, IDOR, and Security Misconfiguration",
    "questions": [
      {
        "id": "cs307-q51",
        "type": "multiple_choice",
        "prompt": "Which type of XSS occurs when malicious scripts are permanently stored on target servers (like in a database)?",
        "options": [
          "Reflected XSS",
          "DOM-based XSS",
          "Stored XSS (Persistent XSS)",
          "Universal XSS"
        ],
        "correctAnswer": "Stored XSS (Persistent XSS)",
        "explanation": "Stored XSS occurs when malicious input is saved to a database or file system and later displayed to users without proper sanitization. This is more dangerous than reflected XSS because it affects all users who view the compromised content, not just those who click a malicious link."
      },
      {
        "id": "cs307-q52",
        "type": "true_false",
        "prompt": "Security misconfiguration vulnerabilities can result from leaving default credentials, unnecessary features enabled, or verbose error messages.",
        "correctAnswer": "true",
        "explanation": "Security misconfiguration is one of the most common vulnerabilities. It includes default passwords, unnecessary services, overly permissive file permissions, detailed error messages that leak information, and outdated software. Proper hardening and configuration management are essential."
      },
      {
        "id": "cs307-q53",
        "type": "multiple_choice",
        "prompt": "What is the primary risk of using components with known vulnerabilities?",
        "options": [
          "Increased application size",
          "Slower performance",
          "Attackers can exploit publicly known weaknesses",
          "License compliance issues"
        ],
        "correctAnswer": "Attackers can exploit publicly known weaknesses",
        "explanation": "When applications use libraries or frameworks with known vulnerabilities (disclosed in CVE databases), attackers can exploit these weaknesses. Keeping dependencies updated and monitoring vulnerability databases is crucial for maintaining security."
      },
      {
        "id": "cs307-q54",
        "type": "multiple_choice",
        "prompt": "Which vulnerability class involves manipulating file paths to access files outside intended directories?",
        "options": [
          "SQL Injection",
          "Path Traversal (Directory Traversal)",
          "CSRF",
          "Privilege Escalation"
        ],
        "correctAnswer": "Path Traversal (Directory Traversal)",
        "explanation": "Path traversal vulnerabilities allow attackers to access files outside the intended directory by manipulating file paths with sequences like \"../\". This can expose sensitive files like /etc/passwd or configuration files containing credentials. Input validation and sandboxing prevent this."
      },
      {
        "id": "cs307-q55",
        "type": "true_false",
        "prompt": "XML External Entity (XXE) attacks can allow attackers to read local files, perform SSRF attacks, or cause denial of service.",
        "correctAnswer": "true",
        "explanation": "XXE vulnerabilities occur when XML parsers process external entity references. Attackers can use this to read local files, scan internal networks (SSRF), consume resources (DoS), or execute remote code. Disabling external entity processing in XML parsers prevents XXE attacks."
      }
    ]
  },
  {
    "id": "cs307-quiz-4-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Vulnerabilities - SSRF, DoS, and Advanced Threats",
    "questions": [
      {
        "id": "cs307-q56",
        "type": "multiple_choice",
        "prompt": "What is a common consequence of insufficient logging and monitoring?",
        "options": [
          "Improved application performance",
          "Delayed detection of security breaches and incidents",
          "Reduced storage requirements",
          "Faster development cycles"
        ],
        "correctAnswer": "Delayed detection of security breaches and incidents",
        "explanation": "Without proper logging and monitoring, security incidents may go undetected for months. Effective logging helps detect attacks, investigate incidents, and meet compliance requirements. Logs should capture authentication events, access control failures, and input validation failures."
      },
      {
        "id": "cs307-q57",
        "type": "true_false",
        "prompt": "Server-Side Request Forgery (SSRF) allows attackers to make the server perform requests to arbitrary destinations, potentially accessing internal systems.",
        "correctAnswer": "true",
        "explanation": "SSRF vulnerabilities occur when applications fetch remote resources based on user input without validation. Attackers can make servers access internal services, cloud metadata endpoints (like AWS metadata at 169.254.169.254), or perform port scanning. Whitelist validation and network segmentation mitigate SSRF."
      },
      {
        "id": "cs307-q58",
        "type": "multiple_choice",
        "prompt": "What is the main purpose of implementing Content Security Policy (CSP)?",
        "options": [
          "To encrypt all website content",
          "To mitigate XSS attacks by controlling which resources can be loaded",
          "To prevent SQL injection",
          "To enforce password complexity"
        ],
        "correctAnswer": "To mitigate XSS attacks by controlling which resources can be loaded",
        "explanation": "Content Security Policy is a browser security mechanism that restricts which resources (scripts, styles, images) can be loaded and from where. By disallowing inline scripts and restricting sources, CSP significantly reduces the impact of XSS attacks."
      },
      {
        "id": "cs307-q59",
        "type": "multiple_choice",
        "prompt": "Which attack technique involves flooding a system with requests to make it unavailable to legitimate users?",
        "options": [
          "SQL Injection",
          "Denial of Service (DoS)",
          "Man-in-the-Middle",
          "Phishing"
        ],
        "correctAnswer": "Denial of Service (DoS)",
        "explanation": "DoS attacks aim to exhaust system resources (bandwidth, CPU, memory, connections) making services unavailable. Distributed DoS (DDoS) uses multiple systems to amplify the attack. Mitigations include rate limiting, traffic filtering, CDNs, and auto-scaling."
      },
      {
        "id": "cs307-q60",
        "type": "true_false",
        "prompt": "Race condition vulnerabilities can occur when multiple processes access shared resources without proper synchronization.",
        "correctAnswer": "true",
        "explanation": "Race conditions occur when the outcome depends on the sequence or timing of uncontrollable events. In security, this can lead to privilege escalation, authentication bypasses, or data corruption. Proper locking mechanisms, atomic operations, and secure design prevent race conditions."
      }
    ]
  },
  {
    "id": "cs307-quiz-5-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Secure Coding - Input Validation and Output Encoding",
    "questions": [
      {
        "id": "cs307-q61",
        "type": "multiple_choice",
        "prompt": "What is the most effective way to prevent SQL injection?",
        "options": [
          "Escaping special characters in user input",
          "Using parameterized queries or prepared statements",
          "Validating input length",
          "Encrypting database connections"
        ],
        "correctAnswer": "Using parameterized queries or prepared statements",
        "explanation": "Parameterized queries (prepared statements) separate SQL code from data, ensuring user input is never interpreted as SQL commands. This is more reliable than escaping because it prevents all injection attacks regardless of input complexity. ORMs typically use parameterized queries."
      },
      {
        "id": "cs307-q62",
        "type": "true_false",
        "prompt": "Input validation should be performed on both client-side and server-side, but server-side validation is critical for security.",
        "correctAnswer": "true",
        "explanation": "Client-side validation improves user experience but can be bypassed by attackers. Server-side validation is essential for security because the server must never trust client input. Validate all input for type, length, format, and range on the server."
      },
      {
        "id": "cs307-q63",
        "type": "multiple_choice",
        "prompt": "Which approach should be used when validating user input?",
        "options": [
          "Blacklist known bad patterns",
          "Whitelist allowed patterns and reject everything else",
          "Accept all input and fix issues later",
          "Rely on client-side validation only"
        ],
        "correctAnswer": "Whitelist allowed patterns and reject everything else",
        "explanation": "Whitelisting (allowing only known good input) is more secure than blacklisting because it's impossible to enumerate all malicious patterns. Define what is acceptable and reject everything else. For example, for a phone number, accept only digits and specific characters."
      },
      {
        "id": "cs307-q64",
        "type": "multiple_choice",
        "prompt": "What is the proper way to handle sensitive information in error messages?",
        "options": [
          "Display detailed technical errors to help users debug issues",
          "Show generic error messages to users; log detailed errors securely",
          "Hide all errors completely",
          "Display stack traces to all users"
        ],
        "correctAnswer": "Show generic error messages to users; log detailed errors securely",
        "explanation": "Detailed error messages can leak sensitive information like database structure, file paths, or library versions. Show users generic messages (\"An error occurred\") while logging detailed information securely for developers to investigate. Never expose stack traces to users."
      },
      {
        "id": "cs307-q65",
        "type": "true_false",
        "prompt": "Output encoding should be applied when displaying user-generated content to prevent XSS attacks.",
        "correctAnswer": "true",
        "explanation": "Output encoding (also called escaping) converts special characters to safe representations before rendering. For HTML context, encode <, >, &, \", ' to prevent script execution. Different contexts (HTML, JavaScript, URL, CSS) require different encoding methods."
      }
    ]
  },
  {
    "id": "cs307-quiz-5-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Secure Coding - Error Handling and Secret Management",
    "questions": [
      {
        "id": "cs307-q66",
        "type": "multiple_choice",
        "prompt": "Which practice helps prevent sensitive data exposure in application logs?",
        "options": [
          "Logging all user inputs for debugging",
          "Sanitizing logs to remove passwords, credit cards, and PII before logging",
          "Storing logs in plain text files",
          "Disabling all logging in production"
        ],
        "correctAnswer": "Sanitizing logs to remove passwords, credit cards, and PII before logging",
        "explanation": "Never log sensitive data like passwords, tokens, credit cards, or personal information. Sanitize data before logging and use structured logging to control what gets recorded. Logs should help with debugging and security monitoring without exposing sensitive information."
      },
      {
        "id": "cs307-q67",
        "type": "true_false",
        "prompt": "Hard-coding secrets like API keys and passwords in source code is acceptable if the repository is private.",
        "correctAnswer": "false",
        "explanation": "Never hard-code secrets in source code, even in private repositories. Secrets can be exposed through repository leaks, insider threats, or version control history. Use environment variables, secret management systems (like HashiCorp Vault, AWS Secrets Manager), or configuration files excluded from version control."
      },
      {
        "id": "cs307-q68",
        "type": "multiple_choice",
        "prompt": "What is the principle of \"fail-secure\" in error handling?",
        "options": [
          "Display detailed error messages",
          "Default to denying access when errors occur rather than granting it",
          "Continue execution despite errors",
          "Retry failed operations indefinitely"
        ],
        "correctAnswer": "Default to denying access when errors occur rather than granting it",
        "explanation": "Fail-secure means that when errors occur, the system defaults to a secure state (denying access) rather than an insecure state. For example, if authorization checks fail, deny access rather than allowing it. This prevents security bypasses through error conditions."
      },
      {
        "id": "cs307-q69",
        "type": "multiple_choice",
        "prompt": "Which is the most secure way to store passwords in a database?",
        "options": [
          "Plain text",
          "Encrypted with a reversible algorithm",
          "Hashed with a fast algorithm like MD5",
          "Hashed with a slow, adaptive algorithm like bcrypt or Argon2 with unique salts"
        ],
        "correctAnswer": "Hashed with a slow, adaptive algorithm like bcrypt or Argon2 with unique salts",
        "explanation": "Passwords should be hashed with slow, adaptive algorithms (bcrypt, scrypt, Argon2) that resist brute-force attacks. Each password needs a unique salt. Never use fast algorithms (MD5, SHA-1) or encryption (which is reversible) for passwords."
      },
      {
        "id": "cs307-q70",
        "type": "true_false",
        "prompt": "Database credentials should be stored in environment variables or secure configuration systems, not in application code.",
        "correctAnswer": "true",
        "explanation": "Database credentials and other secrets should be stored outside source code in environment variables, secure configuration files, or secret management systems. This prevents credentials from being exposed in version control and allows different credentials for different environments."
      }
    ]
  },
  {
    "id": "cs307-quiz-5-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-5",
    "title": "Secure Coding - Cryptographic Security and Best Practices",
    "questions": [
      {
        "id": "cs307-q71",
        "type": "multiple_choice",
        "prompt": "What is the purpose of using secure random number generators for security-sensitive operations?",
        "options": [
          "They are faster than standard random functions",
          "They provide cryptographically unpredictable values suitable for tokens and keys",
          "They generate truly random hardware-based numbers",
          "They compress data more efficiently"
        ],
        "correctAnswer": "They provide cryptographically unpredictable values suitable for tokens and keys",
        "explanation": "Cryptographically secure random number generators (like crypto.getRandomValues(), secrets module in Python) are essential for generating session tokens, password reset tokens, and encryption keys. Standard random functions (Math.random(), rand()) are predictable and unsuitable for security."
      },
      {
        "id": "cs307-q72",
        "type": "true_false",
        "prompt": "Type confusion vulnerabilities can occur in dynamically typed languages when input is not properly validated and converted to expected types.",
        "correctAnswer": "true",
        "explanation": "Type confusion occurs when data is treated as a different type than intended. In JavaScript, for example, comparing \"5\" == 5 returns true, which can lead to security issues. Always validate and explicitly convert input to expected types, and use strict equality (===) in JavaScript."
      },
      {
        "id": "cs307-q73",
        "type": "multiple_choice",
        "prompt": "Which security header helps prevent clickjacking attacks by controlling whether your site can be framed?",
        "options": [
          "Content-Security-Policy",
          "X-Frame-Options",
          "X-XSS-Protection",
          "Strict-Transport-Security"
        ],
        "correctAnswer": "X-Frame-Options",
        "explanation": "X-Frame-Options (or CSP's frame-ancestors directive) prevents your site from being embedded in iframes on other sites, mitigating clickjacking attacks where attackers trick users into clicking invisible frames. Set to DENY or SAMEORIGIN as appropriate."
      },
      {
        "id": "cs307-q74",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of input sanitization?",
        "options": [
          "To make data look better for display",
          "To remove or encode potentially dangerous characters before processing",
          "To compress data for storage",
          "To translate data between languages"
        ],
        "correctAnswer": "To remove or encode potentially dangerous characters before processing",
        "explanation": "Input sanitization modifies input to remove or neutralize potentially malicious content. However, context-specific output encoding is generally preferred over sanitization because sanitization can be incomplete. Validate input strictly, then encode output appropriately for the context."
      },
      {
        "id": "cs307-q75",
        "type": "true_false",
        "prompt": "Time-of-check to time-of-use (TOCTOU) vulnerabilities can occur when security checks are separated from resource usage.",
        "correctAnswer": "true",
        "explanation": "TOCTOU race conditions occur when a resource is checked (e.g., file permissions) but changes before use. Attackers can exploit the window between check and use. Mitigations include using atomic operations, file locks, or redesigning to eliminate the race condition."
      }
    ]
  },
  {
    "id": "cs307-quiz-6-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Network Security - TLS, Firewalls, and IDS/IPS",
    "questions": [
      {
        "id": "cs307-q76",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of TLS/SSL?",
        "options": [
          "To compress network traffic",
          "To provide encrypted, authenticated communication over networks",
          "To speed up web page loading",
          "To prevent physical access to servers"
        ],
        "correctAnswer": "To provide encrypted, authenticated communication over networks",
        "explanation": "TLS (Transport Layer Security) provides encryption (confidentiality), authentication (verifying server identity via certificates), and integrity (detecting tampering) for network communications. HTTPS is HTTP over TLS, ensuring secure web browsing."
      },
      {
        "id": "cs307-q77",
        "type": "true_false",
        "prompt": "A firewall can prevent all types of cyber attacks by inspecting and blocking malicious traffic.",
        "correctAnswer": "false",
        "explanation": "Firewalls are essential but not sufficient. They filter traffic based on rules (ports, IPs, protocols) but cannot detect attacks within allowed traffic like SQL injection in HTTPS requests, or social engineering attacks. Defense in depth requires multiple security layers."
      },
      {
        "id": "cs307-q78",
        "type": "multiple_choice",
        "prompt": "What is the difference between IDS and IPS?",
        "options": [
          "There is no difference; they are the same",
          "IDS detects and alerts on threats; IPS detects and actively blocks threats",
          "IDS is hardware; IPS is software",
          "IPS only works on encrypted traffic"
        ],
        "correctAnswer": "IDS detects and alerts on threats; IPS detects and actively blocks threats",
        "explanation": "Intrusion Detection Systems (IDS) monitor network traffic and alert on suspicious activity. Intrusion Prevention Systems (IPS) not only detect but also actively block threats by sitting inline and dropping malicious traffic. IPS requires careful tuning to avoid blocking legitimate traffic."
      },
      {
        "id": "cs307-q79",
        "type": "multiple_choice",
        "prompt": "Which VPN protocol is considered most secure for modern use?",
        "options": [
          "PPTP",
          "WireGuard or OpenVPN",
          "Telnet",
          "FTP"
        ],
        "correctAnswer": "WireGuard or OpenVPN",
        "explanation": "WireGuard and OpenVPN are modern, secure VPN protocols. WireGuard uses contemporary cryptography and has a smaller codebase. PPTP is obsolete and insecure. VPNs encrypt traffic and create secure tunnels over untrusted networks, protecting confidentiality and integrity."
      },
      {
        "id": "cs307-q80",
        "type": "true_false",
        "prompt": "DNSSEC helps prevent DNS cache poisoning by using cryptographic signatures to verify DNS responses.",
        "correctAnswer": "true",
        "explanation": "DNSSEC (DNS Security Extensions) adds cryptographic signatures to DNS records, allowing resolvers to verify that responses are authentic and haven't been tampered with. This prevents cache poisoning attacks where attackers inject false DNS records to redirect traffic."
      }
    ]
  },
  {
    "id": "cs307-quiz-6-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Network Security - MITM, HSTS, and Network Segmentation",
    "questions": [
      {
        "id": "cs307-q81",
        "type": "multiple_choice",
        "prompt": "What type of attack involves intercepting and potentially modifying communications between two parties?",
        "options": [
          "Denial of Service",
          "Man-in-the-Middle (MITM)",
          "SQL Injection",
          "Buffer Overflow"
        ],
        "correctAnswer": "Man-in-the-Middle (MITM)",
        "explanation": "Man-in-the-Middle attacks occur when an attacker intercepts communication between two parties, potentially reading or modifying data. TLS with proper certificate validation, HSTS, and certificate pinning help prevent MITM attacks by ensuring encrypted, authenticated connections."
      },
      {
        "id": "cs307-q82",
        "type": "true_false",
        "prompt": "HTTP Strict Transport Security (HSTS) forces browsers to use HTTPS connections even if users type http:// in the address bar.",
        "correctAnswer": "true",
        "explanation": "HSTS is a security header that tells browsers to only connect via HTTPS for a specified period. Once set, browsers automatically upgrade HTTP requests to HTTPS and refuse connections if the certificate is invalid, preventing SSL stripping attacks and accidental insecure connections."
      },
      {
        "id": "cs307-q83",
        "type": "multiple_choice",
        "prompt": "What is the primary security benefit of network segmentation?",
        "options": [
          "Faster network speeds",
          "Limiting the blast radius of security breaches by isolating critical systems",
          "Reducing hardware costs",
          "Eliminating the need for firewalls"
        ],
        "correctAnswer": "Limiting the blast radius of security breaches by isolating critical systems",
        "explanation": "Network segmentation divides networks into isolated zones (DMZ, internal network, management network). If one segment is compromised, attackers cannot easily access other segments. This limits lateral movement and protects critical assets through defense in depth."
      },
      {
        "id": "cs307-q84",
        "type": "multiple_choice",
        "prompt": "Which attack technique amplifies traffic to overwhelm a target using publicly accessible servers?",
        "options": [
          "SQL Injection",
          "DDoS Amplification (like DNS amplification, NTP amplification)",
          "Phishing",
          "Privilege Escalation"
        ],
        "correctAnswer": "DDoS Amplification (like DNS amplification, NTP amplification)",
        "explanation": "Amplification attacks use public servers (DNS, NTP, memcached) to multiply traffic volume. Attackers send small requests with spoofed source IPs, causing servers to send large responses to victims. Mitigations include disabling recursion on public DNS servers and rate limiting."
      },
      {
        "id": "cs307-q85",
        "type": "true_false",
        "prompt": "Certificate pinning can help prevent MITM attacks by validating that the server certificate matches an expected certificate or public key.",
        "correctAnswer": "true",
        "explanation": "Certificate pinning validates that the server's certificate matches a known certificate or public key, preventing attacks where attackers install rogue CA certificates. This adds security beyond normal certificate validation but requires careful management to avoid breaking connectivity during certificate rotation."
      }
    ]
  },
  {
    "id": "cs307-quiz-6-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-6",
    "title": "Network Security - WAF, VPN, and Secure Protocols",
    "questions": [
      {
        "id": "cs307-q86",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a Web Application Firewall (WAF)?",
        "options": [
          "To encrypt database connections",
          "To filter and monitor HTTP traffic to protect web applications from attacks",
          "To manage user authentication",
          "To compress web content"
        ],
        "correctAnswer": "To filter and monitor HTTP traffic to protect web applications from attacks",
        "explanation": "WAFs protect web applications by filtering HTTP/HTTPS traffic between clients and servers. They can detect and block attacks like SQL injection, XSS, and CSRF by analyzing request patterns. WAFs provide defense in depth but don't replace secure coding practices."
      },
      {
        "id": "cs307-q87",
        "type": "true_false",
        "prompt": "Using public Wi-Fi without VPN is safe because websites use HTTPS encryption.",
        "correctAnswer": "false",
        "explanation": "While HTTPS encrypts content, public Wi-Fi has risks: attackers can perform MITM attacks to intercept non-HTTPS traffic, see which sites you visit (DNS queries), create fake hotspots, or exploit vulnerabilities. VPNs add a layer of protection by encrypting all traffic."
      },
      {
        "id": "cs307-q88",
        "type": "multiple_choice",
        "prompt": "What protocol should be used instead of Telnet for secure remote server administration?",
        "options": [
          "FTP",
          "HTTP",
          "SSH (Secure Shell)",
          "SMTP"
        ],
        "correctAnswer": "SSH (Secure Shell)",
        "explanation": "SSH provides encrypted, authenticated remote access to servers. Telnet transmits everything (including passwords) in plain text and should never be used. SSH uses public key cryptography for authentication and encryption, making it the standard for secure remote administration."
      },
      {
        "id": "cs307-q89",
        "type": "multiple_choice",
        "prompt": "What is the purpose of rate limiting in network security?",
        "options": [
          "To increase network bandwidth",
          "To restrict the number of requests from a source within a time period, preventing abuse",
          "To encrypt traffic faster",
          "To prioritize certain types of traffic"
        ],
        "correctAnswer": "To restrict the number of requests from a source within a time period, preventing abuse",
        "explanation": "Rate limiting restricts how many requests a client can make in a given time period. This mitigates brute force attacks, API abuse, DDoS attacks, and scraping. Implement rate limiting at multiple layers (application, API gateway, CDN, firewall) for defense in depth."
      },
      {
        "id": "cs307-q90",
        "type": "true_false",
        "prompt": "Port scanning is an attack technique used to discover which network services are running on a target system.",
        "correctAnswer": "true",
        "explanation": "Port scanning identifies open ports and running services on a target. While it's a reconnaissance technique used by attackers, it's also used legitimately by security professionals for vulnerability assessment. Firewalls and IDS can detect and block suspicious port scanning activity."
      }
    ]
  },
  {
    "id": "cs307-quiz-7-1",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Testing - SAST, DAST, and Fuzzing",
    "questions": [
      {
        "id": "cs307-q91",
        "type": "multiple_choice",
        "prompt": "What is the primary difference between vulnerability scanning and penetration testing?",
        "options": [
          "There is no difference",
          "Vulnerability scanning automatically identifies potential vulnerabilities; penetration testing actively exploits them",
          "Vulnerability scanning is illegal; penetration testing is legal",
          "Penetration testing is fully automated; vulnerability scanning is manual"
        ],
        "correctAnswer": "Vulnerability scanning automatically identifies potential vulnerabilities; penetration testing actively exploits them",
        "explanation": "Vulnerability scanners (like Nessus, OpenVAS) automatically detect known vulnerabilities. Penetration testing involves security professionals actively attempting to exploit vulnerabilities to assess real-world impact. Both are valuable and complementary security testing approaches."
      },
      {
        "id": "cs307-q92",
        "type": "true_false",
        "prompt": "Static Application Security Testing (SAST) analyzes source code without executing the program.",
        "correctAnswer": "true",
        "explanation": "SAST tools analyze source code, bytecode, or binaries without execution to find security vulnerabilities like SQL injection, XSS, or buffer overflows. They can be integrated into CI/CD pipelines to catch issues early but may produce false positives requiring manual review."
      },
      {
        "id": "cs307-q93",
        "type": "multiple_choice",
        "prompt": "Which testing approach executes the application and monitors its behavior to find vulnerabilities?",
        "options": [
          "Static Application Security Testing (SAST)",
          "Code Review",
          "Dynamic Application Security Testing (DAST)",
          "Threat Modeling"
        ],
        "correctAnswer": "Dynamic Application Security Testing (DAST)",
        "explanation": "DAST tools test running applications from the outside, similar to how an attacker would. They send various inputs and analyze responses to find vulnerabilities like XSS, SQL injection, or authentication issues. DAST complements SAST by finding runtime and configuration issues."
      },
      {
        "id": "cs307-q94",
        "type": "multiple_choice",
        "prompt": "What is a key advantage of Interactive Application Security Testing (IAST)?",
        "options": [
          "It requires no access to the application",
          "It combines aspects of SAST and DAST by instrumenting the running application",
          "It only works on compiled languages",
          "It eliminates all false positives"
        ],
        "correctAnswer": "It combines aspects of SAST and DAST by instrumenting the running application",
        "explanation": "IAST instruments the application (using agents or profilers) to monitor behavior during testing. This provides accurate results with low false positives, showing exactly where vulnerabilities exist in code. It combines the depth of SAST with the runtime context of DAST."
      },
      {
        "id": "cs307-q95",
        "type": "true_false",
        "prompt": "Fuzzing involves sending random or malformed inputs to applications to discover crashes, memory leaks, or security vulnerabilities.",
        "correctAnswer": "true",
        "explanation": "Fuzzing (or fuzz testing) automatically generates massive amounts of random, malformed, or edge-case inputs to find bugs that cause crashes, assertions, memory leaks, or security issues. It's particularly effective at finding input validation vulnerabilities and memory safety issues."
      }
    ]
  },
  {
    "id": "cs307-quiz-7-2",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Testing - Penetration Testing and Bug Bounties",
    "questions": [
      {
        "id": "cs307-q96",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a bug bounty program?",
        "options": [
          "To pay employees for finding bugs",
          "To incentivize external security researchers to report vulnerabilities responsibly",
          "To automatically fix security issues",
          "To test employee security awareness"
        ],
        "correctAnswer": "To incentivize external security researchers to report vulnerabilities responsibly",
        "explanation": "Bug bounty programs reward external security researchers for discovering and responsibly disclosing vulnerabilities. This harnesses the collective expertise of the security community, often finding issues that internal teams miss. Programs like HackerOne and Bugcrowd facilitate these."
      },
      {
        "id": "cs307-q97",
        "type": "true_false",
        "prompt": "Security testing should only be performed before initial deployment, not continuously throughout the application lifecycle.",
        "correctAnswer": "false",
        "explanation": "Security testing must be continuous throughout the development lifecycle and after deployment. New vulnerabilities are discovered, code changes introduce risks, and dependencies get updated. Integrate security testing into CI/CD pipelines and perform regular assessments in production."
      },
      {
        "id": "cs307-q98",
        "type": "multiple_choice",
        "prompt": "What type of penetration testing provides testers with full knowledge of the system including source code and architecture?",
        "options": [
          "Black box testing",
          "Gray box testing",
          "White box testing",
          "Red team testing"
        ],
        "correctAnswer": "White box testing",
        "explanation": "White box testing (clear box) provides full knowledge including code, architecture, and credentials. Black box has no prior knowledge (simulating external attackers). Gray box has partial knowledge (simulating insider threats). Each approach has different benefits and use cases."
      },
      {
        "id": "cs307-q99",
        "type": "multiple_choice",
        "prompt": "What is the primary goal of security code review?",
        "options": [
          "To improve code formatting",
          "To identify security vulnerabilities and design flaws through manual examination",
          "To optimize performance",
          "To reduce code size"
        ],
        "correctAnswer": "To identify security vulnerabilities and design flaws through manual examination",
        "explanation": "Security-focused code reviews involve manually examining code for vulnerabilities, insecure patterns, and design flaws. Experienced reviewers can find subtle issues that automated tools miss, like business logic flaws, authorization issues, or cryptographic misuse."
      },
      {
        "id": "cs307-q100",
        "type": "true_false",
        "prompt": "Software Composition Analysis (SCA) tools help identify vulnerabilities in third-party libraries and dependencies.",
        "correctAnswer": "true",
        "explanation": "SCA tools analyze project dependencies to identify known vulnerabilities (CVEs), license compliance issues, and outdated components. They're essential because modern applications use many third-party libraries, and vulnerable dependencies are a common attack vector (supply chain attacks)."
      }
    ]
  },
  {
    "id": "cs307-quiz-7-3",
    "subjectId": "cs307",
    "topicId": "cs307-topic-7",
    "title": "Security Testing - Threat Modeling and Red Teaming",
    "questions": [
      {
        "id": "cs307-q101",
        "type": "multiple_choice",
        "prompt": "What is the purpose of threat modeling in the security development lifecycle?",
        "options": [
          "To test the application after deployment",
          "To proactively identify potential threats and design countermeasures during development",
          "To monitor production systems",
          "To train developers on coding standards"
        ],
        "correctAnswer": "To proactively identify potential threats and design countermeasures during development",
        "explanation": "Threat modeling is performed during design to identify potential security threats, assess risks, and plan mitigations before code is written. Using frameworks like STRIDE or PASTA, teams systematically analyze attack vectors and design secure architectures, catching issues early when they're cheaper to fix."
      },
      {
        "id": "cs307-q102",
        "type": "true_false",
        "prompt": "Red team exercises involve friendly attackers attempting to breach systems to test defensive capabilities.",
        "correctAnswer": "true",
        "explanation": "Red teams simulate real-world attackers to test security controls and incident response. Blue teams defend and detect attacks. These exercises reveal gaps in security controls, monitoring, and response procedures that might not be found through standard testing approaches."
      },
      {
        "id": "cs307-q103",
        "type": "multiple_choice",
        "prompt": "Which metric is most useful for tracking security testing effectiveness over time?",
        "options": [
          "Number of developers",
          "Mean Time to Remediate (MTTR) vulnerabilities",
          "Lines of code written",
          "Server uptime"
        ],
        "correctAnswer": "Mean Time to Remediate (MTTR) vulnerabilities",
        "explanation": "MTTR measures how quickly vulnerabilities are fixed after discovery. Other useful metrics include vulnerability density (vulnerabilities per KLOC), time to detection, severity distribution, and recurrence rate. Tracking these over time shows security program maturity and effectiveness."
      },
      {
        "id": "cs307-q104",
        "type": "multiple_choice",
        "prompt": "What is the primary benefit of shift-left security?",
        "options": [
          "Moving security testing to the end of development",
          "Integrating security early in development to find and fix issues when they're cheaper to remediate",
          "Outsourcing security to third parties",
          "Delaying security testing until production"
        ],
        "correctAnswer": "Integrating security early in development to find and fix issues when they're cheaper to remediate",
        "explanation": "Shift-left security integrates security practices early in the SDLC (design, development) rather than at the end. Finding vulnerabilities during design or development is far cheaper than fixing them in production. Tools like SAST in IDEs and security training enable shift-left."
      },
      {
        "id": "cs307-q105",
        "type": "true_false",
        "prompt": "A comprehensive security testing program should include multiple testing approaches (SAST, DAST, penetration testing, code review) for defense in depth.",
        "correctAnswer": "true",
        "explanation": "No single testing approach finds all vulnerabilities. SAST finds code-level issues, DAST finds runtime issues, penetration testing validates exploitability, and code review finds logic flaws. A comprehensive program uses multiple complementary approaches throughout the development lifecycle for thorough coverage."
      }
    ]
  }
]
[
  {
    "id": "cs401-t1-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Simple RPC Client Implementation",
    "difficulty": 2,
    "description": "Implement a simple RPC client that can make remote procedure calls to a server.\n\nYour implementation should:\n- Create a client that connects to a remote server\n- Serialize function calls and parameters\n- Send requests and receive responses\n- Handle basic error cases (timeout, connection failure)",
    "starterCode": "interface RPCClient {\n  connect(host: string, port: number): Promise<void>;\n  call(method: string, params: any[]): Promise<any>;\n  disconnect(): Promise<void>;\n}\n\nclass SimpleRPCClient implements RPCClient {\n  // Implement the RPC client\n}\n\n// Example usage:\n// const client = new SimpleRPCClient();\n// await client.connect('localhost', 8080);\n// const result = await client.call('add', [5, 3]);\n// console.log(result); // 8",
    "solution": "interface RPCClient {\n  connect(host: string, port: number): Promise<void>;\n  call(method: string, params: any[]): Promise<any>;\n  disconnect(): Promise<void>;\n}\n\nclass SimpleRPCClient implements RPCClient {\n  private socket: any = null;\n  private requestId: number = 0;\n  private pendingRequests: Map<number, { resolve: Function, reject: Function }> = new Map();\n\n  async connect(host: string, port: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Simulated connection (in real implementation, use net.Socket)\n      this.socket = { connected: true, host, port };\n\n      // Simulate receiving responses\n      this.socket.onMessage = (message: string) => {\n        const response = JSON.parse(message);\n        const pending = this.pendingRequests.get(response.id);\n        if (pending) {\n          if (response.error) {\n            pending.reject(new Error(response.error));\n          } else {\n            pending.resolve(response.result);\n          }\n          this.pendingRequests.delete(response.id);\n        }\n      };\n\n      resolve();\n    });\n  }\n\n  async call(method: string, params: any[]): Promise<any> {\n    if (!this.socket?.connected) {\n      throw new Error('Not connected to server');\n    }\n\n    const id = ++this.requestId;\n    const request = {\n      id,\n      method,\n      params,\n      timestamp: Date.now()\n    };\n\n    return new Promise((resolve, reject) => {\n      // Set timeout for request\n      const timeout = setTimeout(() => {\n        this.pendingRequests.delete(id);\n        reject(new Error('Request timeout'));\n      }, 5000);\n\n      this.pendingRequests.set(id, {\n        resolve: (result: any) => {\n          clearTimeout(timeout);\n          resolve(result);\n        },\n        reject: (error: Error) => {\n          clearTimeout(timeout);\n          reject(error);\n        }\n      });\n\n      // Send request (simulated)\n      const message = JSON.stringify(request);\n      // this.socket.send(message);\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.socket) {\n      this.socket.connected = false;\n      this.socket = null;\n    }\n    // Reject all pending requests\n    this.pendingRequests.forEach(({ reject }) => {\n      reject(new Error('Connection closed'));\n    });\n    this.pendingRequests.clear();\n  }\n}",
    "testCases": [
      {
        "input": "connect(\"localhost\", 8080)",
        "expectedOutput": "Connected successfully",
        "isHidden": false,
        "description": "Should connect to server"
      },
      {
        "input": "call(\"add\", [5, 3])",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Should execute remote procedure call"
      },
      {
        "input": "call(\"add\", []) when not connected",
        "expectedOutput": "Error: Not connected to server",
        "isHidden": false,
        "description": "Should handle disconnected state"
      }
    ],
    "hints": [
      "Use a Map to track pending requests by request ID",
      "Implement timeout mechanism using setTimeout",
      "Handle connection state properly",
      "Serialize requests as JSON for transmission"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Service Discovery Mock",
    "difficulty": 2,
    "description": "Implement a simple service discovery system that allows services to register and discover each other.\n\nYour implementation should:\n- Allow services to register with name, host, and port\n- Support service lookup by name\n- Handle service deregistration\n- Implement health checking (mark unhealthy services as unavailable)",
    "starterCode": "interface ServiceInfo {\n  name: string;\n  host: string;\n  port: number;\n  healthy: boolean;\n}\n\nclass ServiceRegistry {\n  // Implement service discovery\n}",
    "solution": "interface ServiceInfo {\n  name: string;\n  host: string;\n  port: number;\n  healthy: boolean;\n  lastHeartbeat: number;\n}\n\nclass ServiceRegistry {\n  private services: Map<string, ServiceInfo[]> = new Map();\n  private healthCheckInterval: number = 5000; // 5 seconds\n\n  constructor() {\n    // Start health check loop\n    setInterval(() => this.checkHealth(), this.healthCheckInterval);\n  }\n\n  register(name: string, host: string, port: number): void {\n    const service: ServiceInfo = {\n      name,\n      host,\n      port,\n      healthy: true,\n      lastHeartbeat: Date.now()\n    };\n\n    if (!this.services.has(name)) {\n      this.services.set(name, []);\n    }\n\n    const instances = this.services.get(name)!;\n    // Remove existing instance with same host:port\n    const filtered = instances.filter(s => !(s.host === host && s.port === port));\n    filtered.push(service);\n    this.services.set(name, filtered);\n  }\n\n  discover(name: string): ServiceInfo[] {\n    const instances = this.services.get(name) || [];\n    return instances.filter(s => s.healthy);\n  }\n\n  deregister(name: string, host: string, port: number): void {\n    const instances = this.services.get(name);\n    if (instances) {\n      const filtered = instances.filter(s => !(s.host === host && s.port === port));\n      this.services.set(name, filtered);\n    }\n  }\n\n  heartbeat(name: string, host: string, port: number): void {\n    const instances = this.services.get(name);\n    if (instances) {\n      const service = instances.find(s => s.host === host && s.port === port);\n      if (service) {\n        service.lastHeartbeat = Date.now();\n        service.healthy = true;\n      }\n    }\n  }\n\n  private checkHealth(): void {\n    const now = Date.now();\n    const timeout = 10000; // 10 seconds\n\n    this.services.forEach((instances) => {\n      instances.forEach(service => {\n        if (now - service.lastHeartbeat > timeout) {\n          service.healthy = false;\n        }\n      });\n    });\n  }\n\n  getAllServices(): Map<string, ServiceInfo[]> {\n    return new Map(this.services);\n  }\n}",
    "testCases": [
      {
        "input": "register(\"api\", \"localhost\", 8080)",
        "expectedOutput": "Service registered",
        "isHidden": false,
        "description": "Should register a service"
      },
      {
        "input": "discover(\"api\")",
        "expectedOutput": "[{name: \"api\", host: \"localhost\", port: 8080, healthy: true}]",
        "isHidden": false,
        "description": "Should discover registered service"
      },
      {
        "input": "discover(\"unknown\")",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "Should return empty array for unknown service"
      }
    ],
    "hints": [
      "Use a Map with service name as key and array of instances as value",
      "Track last heartbeat timestamp for each service",
      "Implement periodic health checking with setInterval",
      "Filter unhealthy services in discover method"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Load Balancer Implementation",
    "difficulty": 3,
    "description": "Implement a simple round-robin load balancer that distributes requests across multiple backend servers.\n\nYour implementation should:\n- Support multiple backend servers\n- Use round-robin algorithm for distribution\n- Handle server health checks\n- Skip unhealthy servers when distributing requests",
    "starterCode": "interface Server {\n  id: string;\n  host: string;\n  port: number;\n  healthy: boolean;\n}\n\nclass LoadBalancer {\n  // Implement load balancer\n}",
    "solution": "interface Server {\n  id: string;\n  host: string;\n  port: number;\n  healthy: boolean;\n}\n\nclass LoadBalancer {\n  private servers: Server[] = [];\n  private currentIndex: number = 0;\n\n  addServer(id: string, host: string, port: number): void {\n    this.servers.push({ id, host, port, healthy: true });\n  }\n\n  removeServer(id: string): void {\n    this.servers = this.servers.filter(s => s.id !== id);\n    // Reset index if it's out of bounds\n    if (this.currentIndex >= this.servers.length) {\n      this.currentIndex = 0;\n    }\n  }\n\n  markHealthy(id: string, healthy: boolean): void {\n    const server = this.servers.find(s => s.id === id);\n    if (server) {\n      server.healthy = healthy;\n    }\n  }\n\n  getNextServer(): Server | null {\n    const healthyServers = this.servers.filter(s => s.healthy);\n\n    if (healthyServers.length === 0) {\n      return null;\n    }\n\n    // Find next healthy server using round-robin\n    let attempts = 0;\n    while (attempts < this.servers.length) {\n      const server = this.servers[this.currentIndex];\n      this.currentIndex = (this.currentIndex + 1) % this.servers.length;\n\n      if (server.healthy) {\n        return server;\n      }\n      attempts++;\n    }\n\n    return null;\n  }\n\n  getServerStats(): { total: number; healthy: number } {\n    return {\n      total: this.servers.length,\n      healthy: this.servers.filter(s => s.healthy).length\n    };\n  }\n}",
    "testCases": [
      {
        "input": "Add 3 servers and call getNextServer() 3 times",
        "expectedOutput": "Returns servers in round-robin order",
        "isHidden": false,
        "description": "Should distribute requests in round-robin fashion"
      },
      {
        "input": "Mark server unhealthy and call getNextServer()",
        "expectedOutput": "Skips unhealthy server",
        "isHidden": false,
        "description": "Should skip unhealthy servers"
      },
      {
        "input": "All servers unhealthy",
        "expectedOutput": "null",
        "isHidden": false,
        "description": "Should return null when no healthy servers"
      }
    ],
    "hints": [
      "Maintain a current index for round-robin",
      "Use modulo operator to wrap around server list",
      "Filter for healthy servers before selection",
      "Handle edge case when all servers are unhealthy"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Peer-to-Peer Node Implementation",
    "difficulty": 3,
    "description": "Implement a simple peer-to-peer node that can connect to other peers and exchange messages.\n\nYour implementation should:\n- Maintain a list of connected peers\n- Support adding and removing peers\n- Broadcast messages to all peers\n- Handle peer discovery (find peers of peers)",
    "starterCode": "interface Peer {\n  id: string;\n  address: string;\n}\n\nclass P2PNode {\n  // Implement P2P node\n}",
    "solution": "interface Peer {\n  id: string;\n  address: string;\n}\n\ninterface Message {\n  from: string;\n  content: any;\n  timestamp: number;\n}\n\nclass P2PNode {\n  private id: string;\n  private peers: Map<string, Peer> = new Map();\n  private messageHandler: ((msg: Message) => void) | null = null;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  addPeer(peer: Peer): void {\n    if (peer.id !== this.id) {\n      this.peers.set(peer.id, peer);\n    }\n  }\n\n  removePeer(peerId: string): void {\n    this.peers.delete(peerId);\n  }\n\n  getPeers(): Peer[] {\n    return Array.from(this.peers.values());\n  }\n\n  broadcast(content: any): void {\n    const message: Message = {\n      from: this.id,\n      content,\n      timestamp: Date.now()\n    };\n\n    this.peers.forEach(peer => {\n      // Simulate sending message to peer\n      this.sendToPeer(peer.id, message);\n    });\n  }\n\n  sendToPeer(peerId: string, message: Message): void {\n    const peer = this.peers.get(peerId);\n    if (peer) {\n      // Simulated message send\n      console.log(`Sending message from ${this.id} to ${peerId}`);\n    }\n  }\n\n  receiveMessage(message: Message): void {\n    if (this.messageHandler) {\n      this.messageHandler(message);\n    }\n  }\n\n  onMessage(handler: (msg: Message) => void): void {\n    this.messageHandler = handler;\n  }\n\n  discoverPeers(): Peer[] {\n    // Request peer lists from all connected peers\n    const discoveredPeers: Peer[] = [];\n\n    this.peers.forEach(peer => {\n      // In real implementation, would request peer's peer list\n      // For now, just return known peers\n    });\n\n    return discoveredPeers;\n  }\n\n  getId(): string {\n    return this.id;\n  }\n}",
    "testCases": [
      {
        "input": "Create 3 nodes and connect them",
        "expectedOutput": "Nodes successfully connected",
        "isHidden": false,
        "description": "Should establish peer connections"
      },
      {
        "input": "Broadcast message from node1",
        "expectedOutput": "All peers receive the message",
        "isHidden": false,
        "description": "Should broadcast to all peers"
      },
      {
        "input": "Remove peer and broadcast",
        "expectedOutput": "Removed peer does not receive message",
        "isHidden": false,
        "description": "Should not send to removed peers"
      }
    ],
    "hints": [
      "Use a Map to store peers by their ID",
      "Iterate over all peers for broadcast",
      "Don't add self as peer",
      "Track message timestamps to prevent loops"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "CAP Theorem Simulator",
    "difficulty": 4,
    "description": "Create a simulator that demonstrates the CAP theorem by showing the tradeoffs between Consistency, Availability, and Partition tolerance.\n\nYour implementation should:\n- Simulate a distributed system with multiple nodes\n- Support network partition scenarios\n- Demonstrate CP system behavior (reject writes during partition)\n- Demonstrate AP system behavior (accept writes during partition, eventual consistency)",
    "starterCode": "type SystemMode = 'CP' | 'AP';\n\ninterface Node {\n  id: string;\n  data: Map<string, any>;\n  partitioned: boolean;\n}\n\nclass CAPSimulator {\n  // Implement CAP theorem simulator\n}",
    "solution": "type SystemMode = 'CP' | 'AP';\n\ninterface Node {\n  id: string;\n  data: Map<string, any>;\n  partitioned: boolean;\n}\n\ninterface WriteResult {\n  success: boolean;\n  message: string;\n}\n\nclass CAPSimulator {\n  private nodes: Node[] = [];\n  private mode: SystemMode;\n\n  constructor(mode: SystemMode, nodeCount: number) {\n    this.mode = mode;\n    for (let i = 0; i < nodeCount; i++) {\n      this.nodes.push({\n        id: `node-${i}`,\n        data: new Map(),\n        partitioned: false\n      });\n    }\n  }\n\n  write(key: string, value: any, nodeId?: string): WriteResult {\n    const targetNode = nodeId\n      ? this.nodes.find(n => n.id === nodeId)\n      : this.nodes[0];\n\n    if (!targetNode) {\n      return { success: false, message: 'Node not found' };\n    }\n\n    const availableNodes = this.nodes.filter(n => !n.partitioned);\n    const majority = Math.floor(this.nodes.length / 2) + 1;\n\n    if (this.mode === 'CP') {\n      // CP: Require majority for consistency\n      if (availableNodes.length < majority) {\n        return {\n          success: false,\n          message: 'Cannot achieve consistency - no majority available'\n        };\n      }\n\n      // Write to majority\n      availableNodes.slice(0, majority).forEach(node => {\n        node.data.set(key, value);\n      });\n\n      return { success: true, message: 'Written to majority (consistent)' };\n    } else {\n      // AP: Always accept writes (eventual consistency)\n      targetNode.data.set(key, value);\n\n      // Async replication to available nodes\n      setTimeout(() => {\n        availableNodes.forEach(node => {\n          if (node.id !== targetNode.id) {\n            node.data.set(key, value);\n          }\n        });\n      }, 100);\n\n      return {\n        success: true,\n        message: 'Written locally (eventually consistent)'\n      };\n    }\n  }\n\n  read(key: string, nodeId?: string): any {\n    const targetNode = nodeId\n      ? this.nodes.find(n => n.id === nodeId)\n      : this.nodes[0];\n\n    if (!targetNode) {\n      return null;\n    }\n\n    if (this.mode === 'CP') {\n      // CP: Read from majority for consistency\n      const availableNodes = this.nodes.filter(n => !n.partitioned);\n      const majority = Math.floor(this.nodes.length / 2) + 1;\n\n      if (availableNodes.length < majority) {\n        throw new Error('Cannot achieve consistency - no majority available');\n      }\n\n      return targetNode.data.get(key);\n    } else {\n      // AP: Always return local value (may be stale)\n      return targetNode.data.get(key);\n    }\n  }\n\n  createPartition(nodeIds: string[]): void {\n    nodeIds.forEach(id => {\n      const node = this.nodes.find(n => n.id === id);\n      if (node) {\n        node.partitioned = true;\n      }\n    });\n  }\n\n  healPartition(): void {\n    this.nodes.forEach(node => {\n      node.partitioned = false;\n    });\n\n    // Reconcile data (last-write-wins for simplicity)\n    if (this.mode === 'AP') {\n      const mergedData = new Map<string, any>();\n      this.nodes.forEach(node => {\n        node.data.forEach((value, key) => {\n          mergedData.set(key, value);\n        });\n      });\n\n      this.nodes.forEach(node => {\n        node.data = new Map(mergedData);\n      });\n    }\n  }\n\n  getNodeStatus(): Array<{ id: string; partitioned: boolean; dataSize: number }> {\n    return this.nodes.map(node => ({\n      id: node.id,\n      partitioned: node.partitioned,\n      dataSize: node.data.size\n    }));\n  }\n}",
    "testCases": [
      {
        "input": "CP system: write during partition",
        "expectedOutput": "Write rejected - no majority",
        "isHidden": false,
        "description": "CP system should reject writes without majority"
      },
      {
        "input": "AP system: write during partition",
        "expectedOutput": "Write accepted - eventual consistency",
        "isHidden": false,
        "description": "AP system should accept writes during partition"
      },
      {
        "input": "Heal partition and verify convergence",
        "expectedOutput": "All nodes have same data",
        "isHidden": false,
        "description": "Should reconcile after partition heals"
      }
    ],
    "hints": [
      "Calculate majority as floor(n/2) + 1",
      "CP mode rejects operations without majority",
      "AP mode accepts operations and replicates asynchronously",
      "Implement reconciliation strategy for AP mode"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Transparency Implementation",
    "difficulty": 2,
    "description": "Implement a distributed file system interface that provides location transparency - users access files without knowing their physical location.",
    "starterCode": "interface FileLocation {\n  serverId: string;\n  path: string;\n}\n\nclass TransparentFileSystem {\n  // Implement location transparency\n}",
    "solution": "interface FileLocation {\n  serverId: string;\n  path: string;\n}\n\nclass TransparentFileSystem {\n  private fileLocations: Map<string, FileLocation> = new Map();\n  private servers: Map<string, Set<string>> = new Map();\n\n  registerServer(serverId: string): void {\n    if (!this.servers.has(serverId)) {\n      this.servers.set(serverId, new Set());\n    }\n  }\n\n  storeFile(fileName: string, serverId: string, path: string): void {\n    this.fileLocations.set(fileName, { serverId, path });\n\n    const serverFiles = this.servers.get(serverId);\n    if (serverFiles) {\n      serverFiles.add(fileName);\n    }\n  }\n\n  getFile(fileName: string): string {\n    const location = this.fileLocations.get(fileName);\n    if (!location) {\n      throw new Error(`File not found: ${fileName}`);\n    }\n\n    // User doesn't need to know actual location\n    return `Content of ${fileName}`;\n  }\n\n  // Internal method - users don't call this\n  private getFileLocation(fileName: string): FileLocation | undefined {\n    return this.fileLocations.get(fileName);\n  }\n\n  moveFile(fileName: string, newServerId: string): void {\n    const location = this.fileLocations.get(fileName);\n    if (!location) {\n      throw new Error(`File not found: ${fileName}`);\n    }\n\n    // Remove from old server\n    this.servers.get(location.serverId)?.delete(fileName);\n\n    // Add to new server\n    const newServerFiles = this.servers.get(newServerId);\n    if (!newServerFiles) {\n      throw new Error(`Server not found: ${newServerId}`);\n    }\n    newServerFiles.add(fileName);\n\n    // Update location\n    this.fileLocations.set(fileName, {\n      serverId: newServerId,\n      path: location.path\n    });\n  }\n\n  listFiles(): string[] {\n    return Array.from(this.fileLocations.keys());\n  }\n}",
    "testCases": [
      {
        "input": "Store file on server1, retrieve it",
        "expectedOutput": "File content returned without exposing location",
        "isHidden": false,
        "description": "Should provide location transparency"
      },
      {
        "input": "Move file to different server, retrieve it",
        "expectedOutput": "File accessible from new location transparently",
        "isHidden": false,
        "description": "Should handle migration transparently"
      }
    ],
    "hints": [
      "Maintain mapping from logical file names to physical locations",
      "Hide physical location from users",
      "Support file migration without changing user interface"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Request-Response Pattern",
    "difficulty": 1,
    "description": "Implement a simple request-response pattern with timeout handling.",
    "starterCode": "interface Request {\n  id: string;\n  data: any;\n}\n\ninterface Response {\n  requestId: string;\n  data: any;\n  error?: string;\n}\n\nclass RequestResponseHandler {\n  // Implement request-response pattern\n}",
    "solution": "interface Request {\n  id: string;\n  data: any;\n}\n\ninterface Response {\n  requestId: string;\n  data: any;\n  error?: string;\n}\n\nclass RequestResponseHandler {\n  private pendingRequests: Map<string, {\n    resolve: (value: any) => void;\n    reject: (error: Error) => void;\n    timeout: NodeJS.Timeout;\n  }> = new Map();\n\n  async sendRequest(request: Request, timeoutMs: number = 5000): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingRequests.delete(request.id);\n        reject(new Error(`Request timeout: ${request.id}`));\n      }, timeoutMs);\n\n      this.pendingRequests.set(request.id, { resolve, reject, timeout });\n\n      // Simulate sending request\n      this.transmit(request);\n    });\n  }\n\n  handleResponse(response: Response): void {\n    const pending = this.pendingRequests.get(response.requestId);\n    if (pending) {\n      clearTimeout(pending.timeout);\n      this.pendingRequests.delete(response.requestId);\n\n      if (response.error) {\n        pending.reject(new Error(response.error));\n      } else {\n        pending.resolve(response.data);\n      }\n    }\n  }\n\n  private transmit(request: Request): void {\n    // Simulated network transmission\n    console.log(`Transmitting request: ${request.id}`);\n  }\n\n  getPendingCount(): number {\n    return this.pendingRequests.size;\n  }\n}",
    "testCases": [
      {
        "input": "Send request and receive response",
        "expectedOutput": "Response data returned",
        "isHidden": false,
        "description": "Should handle successful request-response"
      },
      {
        "input": "Send request without response",
        "expectedOutput": "Timeout error after specified time",
        "isHidden": false,
        "description": "Should timeout when no response received"
      }
    ],
    "hints": [
      "Use Promise to handle async request-response",
      "Track pending requests with Map",
      "Implement timeout with setTimeout",
      "Clean up on response or timeout"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Simple Publish-Subscribe",
    "difficulty": 2,
    "description": "Implement a publish-subscribe messaging system where subscribers can subscribe to topics and publishers can send messages to topics.",
    "starterCode": "type MessageHandler = (message: any) => void;\n\nclass PubSubSystem {\n  // Implement pub-sub system\n}",
    "solution": "type MessageHandler = (message: any) => void;\n\nclass PubSubSystem {\n  private subscribers: Map<string, Set<MessageHandler>> = new Map();\n\n  subscribe(topic: string, handler: MessageHandler): () => void {\n    if (!this.subscribers.has(topic)) {\n      this.subscribers.set(topic, new Set());\n    }\n\n    this.subscribers.get(topic)!.add(handler);\n\n    // Return unsubscribe function\n    return () => {\n      const handlers = this.subscribers.get(topic);\n      if (handlers) {\n        handlers.delete(handler);\n        if (handlers.size === 0) {\n          this.subscribers.delete(topic);\n        }\n      }\n    };\n  }\n\n  publish(topic: string, message: any): void {\n    const handlers = this.subscribers.get(topic);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(message);\n        } catch (error) {\n          console.error(`Error in subscriber: ${error}`);\n        }\n      });\n    }\n  }\n\n  getTopics(): string[] {\n    return Array.from(this.subscribers.keys());\n  }\n\n  getSubscriberCount(topic: string): number {\n    return this.subscribers.get(topic)?.size || 0;\n  }\n}",
    "testCases": [
      {
        "input": "Subscribe to topic and publish message",
        "expectedOutput": "Subscriber receives message",
        "isHidden": false,
        "description": "Should deliver messages to subscribers"
      },
      {
        "input": "Unsubscribe and publish",
        "expectedOutput": "Unsubscribed handler not called",
        "isHidden": false,
        "description": "Should not deliver to unsubscribed handlers"
      }
    ],
    "hints": [
      "Use Map with topic as key and Set of handlers as value",
      "Return unsubscribe function from subscribe",
      "Handle errors in subscriber callbacks gracefully"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Consistent Hashing Ring",
    "difficulty": 3,
    "description": "Implement a consistent hashing ring for distributing keys across nodes with minimal rebalancing when nodes are added or removed.",
    "starterCode": "class ConsistentHashRing {\n  // Implement consistent hashing\n}",
    "solution": "class ConsistentHashRing {\n  private ring: Map<number, string> = new Map();\n  private nodes: Set<string> = new Set();\n  private virtualNodes: number;\n\n  constructor(virtualNodes: number = 150) {\n    this.virtualNodes = virtualNodes;\n  }\n\n  private hash(key: string): number {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash = ((hash << 5) - hash) + key.charCodeAt(i);\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n\n  addNode(nodeId: string): void {\n    if (this.nodes.has(nodeId)) {\n      return;\n    }\n\n    this.nodes.add(nodeId);\n\n    // Add virtual nodes\n    for (let i = 0; i < this.virtualNodes; i++) {\n      const virtualKey = `${nodeId}:v${i}`;\n      const hash = this.hash(virtualKey);\n      this.ring.set(hash, nodeId);\n    }\n  }\n\n  removeNode(nodeId: string): void {\n    if (!this.nodes.has(nodeId)) {\n      return;\n    }\n\n    this.nodes.delete(nodeId);\n\n    // Remove virtual nodes\n    const toRemove: number[] = [];\n    this.ring.forEach((node, hash) => {\n      if (node === nodeId) {\n        toRemove.push(hash);\n      }\n    });\n\n    toRemove.forEach(hash => this.ring.delete(hash));\n  }\n\n  getNode(key: string): string | null {\n    if (this.ring.size === 0) {\n      return null;\n    }\n\n    const hash = this.hash(key);\n\n    // Find first node with hash >= key hash\n    const sortedHashes = Array.from(this.ring.keys()).sort((a, b) => a - b);\n\n    for (const nodeHash of sortedHashes) {\n      if (nodeHash >= hash) {\n        return this.ring.get(nodeHash)!;\n      }\n    }\n\n    // Wrap around to first node\n    return this.ring.get(sortedHashes[0])!;\n  }\n\n  getNodes(): string[] {\n    return Array.from(this.nodes);\n  }\n}",
    "testCases": [
      {
        "input": "Add 3 nodes and distribute 100 keys",
        "expectedOutput": "Keys distributed across nodes",
        "isHidden": false,
        "description": "Should distribute keys across nodes"
      },
      {
        "input": "Remove a node",
        "expectedOutput": "Only keys on removed node are redistributed",
        "isHidden": false,
        "description": "Should minimize redistribution"
      }
    ],
    "hints": [
      "Use virtual nodes to improve distribution",
      "Store hash-to-node mapping in sorted structure",
      "Find next node clockwise on ring",
      "Wrap around to first node if needed"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Microservice Communication",
    "difficulty": 3,
    "description": "Implement a microservice that can communicate with other services using both synchronous (REST-like) and asynchronous (message queue) patterns.",
    "starterCode": "interface Message {\n  from: string;\n  to: string;\n  payload: any;\n}\n\nclass Microservice {\n  // Implement microservice communication\n}",
    "solution": "interface Message {\n  from: string;\n  to: string;\n  payload: any;\n  timestamp: number;\n}\n\nclass Microservice {\n  private serviceName: string;\n  private messageQueue: Message[] = [];\n  private requestHandlers: Map<string, (payload: any) => Promise<any>> = new Map();\n  private messageHandlers: Map<string, (message: Message) => void> = new Map();\n\n  constructor(serviceName: string) {\n    this.serviceName = serviceName;\n  }\n\n  // Synchronous request-response\n  async callService(targetService: string, endpoint: string, payload: any): Promise<any> {\n    // Simulate HTTP request\n    const request = {\n      service: this.serviceName,\n      endpoint,\n      payload\n    };\n\n    // In real implementation, would use HTTP client\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({ status: 'success', data: payload });\n      }, 10);\n    });\n  }\n\n  // Register handler for synchronous requests\n  registerEndpoint(endpoint: string, handler: (payload: any) => Promise<any>): void {\n    this.requestHandlers.set(endpoint, handler);\n  }\n\n  // Asynchronous message sending\n  sendMessage(targetService: string, payload: any): void {\n    const message: Message = {\n      from: this.serviceName,\n      to: targetService,\n      payload,\n      timestamp: Date.now()\n    };\n\n    // In real implementation, would publish to message broker\n    this.messageQueue.push(message);\n  }\n\n  // Register handler for asynchronous messages\n  onMessage(messageType: string, handler: (message: Message) => void): void {\n    this.messageHandlers.set(messageType, handler);\n  }\n\n  // Process incoming message\n  receiveMessage(message: Message): void {\n    const handler = this.messageHandlers.get(message.payload.type);\n    if (handler) {\n      handler(message);\n    }\n  }\n\n  // Get pending messages (simulate message queue)\n  getMessages(): Message[] {\n    return [...this.messageQueue];\n  }\n\n  // Process endpoint request\n  async handleRequest(endpoint: string, payload: any): Promise<any> {\n    const handler = this.requestHandlers.get(endpoint);\n    if (handler) {\n      return await handler(payload);\n    }\n    throw new Error(`Endpoint not found: ${endpoint}`);\n  }\n\n  getName(): string {\n    return this.serviceName;\n  }\n}",
    "testCases": [
      {
        "input": "Call service endpoint synchronously",
        "expectedOutput": "Response received",
        "isHidden": false,
        "description": "Should handle synchronous requests"
      },
      {
        "input": "Send async message",
        "expectedOutput": "Message queued for delivery",
        "isHidden": false,
        "description": "Should queue async messages"
      }
    ],
    "hints": [
      "Separate handlers for sync and async communication",
      "Use Promises for synchronous request-response",
      "Queue messages for asynchronous delivery",
      "Register handlers using Map for flexibility"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Distributed Cache",
    "difficulty": 3,
    "description": "Implement a simple distributed cache with TTL (time-to-live) support and cache invalidation.",
    "starterCode": "interface CacheEntry {\n  value: any;\n  expiresAt: number;\n}\n\nclass DistributedCache {\n  // Implement distributed cache\n}",
    "solution": "interface CacheEntry {\n  value: any;\n  expiresAt: number;\n}\n\nclass DistributedCache {\n  private cache: Map<string, CacheEntry> = new Map();\n  private defaultTTL: number;\n\n  constructor(defaultTTL: number = 60000) { // 60 seconds default\n    this.defaultTTL = defaultTTL;\n\n    // Start cleanup interval\n    setInterval(() => this.cleanup(), 10000);\n  }\n\n  set(key: string, value: any, ttl?: number): void {\n    const expiresAt = Date.now() + (ttl || this.defaultTTL);\n    this.cache.set(key, { value, expiresAt });\n  }\n\n  get(key: string): any | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      return null;\n    }\n\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.value;\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  invalidatePattern(pattern: RegExp): number {\n    let count = 0;\n    const keysToDelete: string[] = [];\n\n    this.cache.forEach((_, key) => {\n      if (pattern.test(key)) {\n        keysToDelete.push(key);\n      }\n    });\n\n    keysToDelete.forEach(key => {\n      this.cache.delete(key);\n      count++;\n    });\n\n    return count;\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n    const keysToDelete: string[] = [];\n\n    this.cache.forEach((entry, key) => {\n      if (now > entry.expiresAt) {\n        keysToDelete.push(key);\n      }\n    });\n\n    keysToDelete.forEach(key => this.cache.delete(key));\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  size(): number {\n    // Clean before counting\n    this.cleanup();\n    return this.cache.size;\n  }\n\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) {\n      return false;\n    }\n\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return false;\n    }\n\n    return true;\n  }\n}",
    "testCases": [
      {
        "input": "Set and get value",
        "expectedOutput": "Value retrieved from cache",
        "isHidden": false,
        "description": "Should cache and retrieve values"
      },
      {
        "input": "Get expired value",
        "expectedOutput": "null",
        "isHidden": false,
        "description": "Should return null for expired entries"
      },
      {
        "input": "Invalidate by pattern",
        "expectedOutput": "Matching entries removed",
        "isHidden": false,
        "description": "Should support pattern-based invalidation"
      }
    ],
    "hints": [
      "Store expiration timestamp with each entry",
      "Check expiration on get operations",
      "Implement periodic cleanup of expired entries",
      "Use RegExp for pattern matching"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Service Health Monitor",
    "difficulty": 2,
    "description": "Implement a health monitoring system that tracks service health and sends alerts when services become unhealthy.",
    "starterCode": "interface HealthStatus {\n  healthy: boolean;\n  lastCheck: number;\n  consecutiveFailures: number;\n}\n\nclass HealthMonitor {\n  // Implement health monitoring\n}",
    "solution": "interface HealthStatus {\n  healthy: boolean;\n  lastCheck: number;\n  consecutiveFailures: number;\n}\n\ntype AlertCallback = (serviceName: string, status: HealthStatus) => void;\n\nclass HealthMonitor {\n  private services: Map<string, HealthStatus> = new Map();\n  private checkInterval: number;\n  private failureThreshold: number;\n  private alertCallbacks: AlertCallback[] = [];\n  private intervalId: NodeJS.Timeout | null = null;\n\n  constructor(checkInterval: number = 5000, failureThreshold: number = 3) {\n    this.checkInterval = checkInterval;\n    this.failureThreshold = failureThreshold;\n  }\n\n  registerService(serviceName: string): void {\n    this.services.set(serviceName, {\n      healthy: true,\n      lastCheck: Date.now(),\n      consecutiveFailures: 0\n    });\n  }\n\n  reportHealth(serviceName: string, healthy: boolean): void {\n    const status = this.services.get(serviceName);\n    if (!status) {\n      return;\n    }\n\n    const wasHealthy = status.healthy;\n\n    if (healthy) {\n      status.consecutiveFailures = 0;\n      status.healthy = true;\n    } else {\n      status.consecutiveFailures++;\n\n      if (status.consecutiveFailures >= this.failureThreshold) {\n        status.healthy = false;\n      }\n    }\n\n    status.lastCheck = Date.now();\n\n    // Alert if status changed\n    if (wasHealthy !== status.healthy) {\n      this.triggerAlerts(serviceName, status);\n    }\n  }\n\n  getServiceStatus(serviceName: string): HealthStatus | null {\n    return this.services.get(serviceName) || null;\n  }\n\n  getAllStatuses(): Map<string, HealthStatus> {\n    return new Map(this.services);\n  }\n\n  onAlert(callback: AlertCallback): void {\n    this.alertCallbacks.push(callback);\n  }\n\n  private triggerAlerts(serviceName: string, status: HealthStatus): void {\n    this.alertCallbacks.forEach(callback => {\n      try {\n        callback(serviceName, status);\n      } catch (error) {\n        console.error('Error in alert callback:', error);\n      }\n    });\n  }\n\n  startMonitoring(healthCheck: (serviceName: string) => Promise<boolean>): void {\n    if (this.intervalId) {\n      return;\n    }\n\n    this.intervalId = setInterval(async () => {\n      for (const serviceName of this.services.keys()) {\n        try {\n          const healthy = await healthCheck(serviceName);\n          this.reportHealth(serviceName, healthy);\n        } catch (error) {\n          this.reportHealth(serviceName, false);\n        }\n      }\n    }, this.checkInterval);\n  }\n\n  stopMonitoring(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n}",
    "testCases": [
      {
        "input": "Report healthy status",
        "expectedOutput": "Service marked as healthy",
        "isHidden": false,
        "description": "Should track healthy services"
      },
      {
        "input": "Report failures exceeding threshold",
        "expectedOutput": "Service marked unhealthy, alert triggered",
        "isHidden": false,
        "description": "Should detect unhealthy services and alert"
      }
    ],
    "hints": [
      "Track consecutive failures before marking unhealthy",
      "Use callbacks for alerts",
      "Implement periodic health checking",
      "Store last check timestamp"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "API Rate Limiter",
    "difficulty": 3,
    "description": "Implement a token bucket rate limiter for API requests.",
    "starterCode": "class RateLimiter {\n  // Implement rate limiter\n}",
    "solution": "class RateLimiter {\n  private tokens: number;\n  private maxTokens: number;\n  private refillRate: number; // tokens per second\n  private lastRefill: number;\n\n  constructor(maxTokens: number, refillRate: number) {\n    this.maxTokens = maxTokens;\n    this.tokens = maxTokens;\n    this.refillRate = refillRate;\n    this.lastRefill = Date.now();\n  }\n\n  private refill(): void {\n    const now = Date.now();\n    const timePassed = (now - this.lastRefill) / 1000; // seconds\n    const tokensToAdd = timePassed * this.refillRate;\n\n    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n    this.lastRefill = now;\n  }\n\n  tryConsume(tokens: number = 1): boolean {\n    this.refill();\n\n    if (this.tokens >= tokens) {\n      this.tokens -= tokens;\n      return true;\n    }\n\n    return false;\n  }\n\n  getAvailableTokens(): number {\n    this.refill();\n    return Math.floor(this.tokens);\n  }\n\n  reset(): void {\n    this.tokens = this.maxTokens;\n    this.lastRefill = Date.now();\n  }\n}\n\n// Per-client rate limiter\nclass ClientRateLimiter {\n  private limiters: Map<string, RateLimiter> = new Map();\n  private maxTokens: number;\n  private refillRate: number;\n\n  constructor(maxTokens: number, refillRate: number) {\n    this.maxTokens = maxTokens;\n    this.refillRate = refillRate;\n  }\n\n  allowRequest(clientId: string, tokens: number = 1): boolean {\n    let limiter = this.limiters.get(clientId);\n\n    if (!limiter) {\n      limiter = new RateLimiter(this.maxTokens, this.refillRate);\n      this.limiters.set(clientId, limiter);\n    }\n\n    return limiter.tryConsume(tokens);\n  }\n\n  getClientStatus(clientId: string): number {\n    const limiter = this.limiters.get(clientId);\n    return limiter ? limiter.getAvailableTokens() : this.maxTokens;\n  }\n\n  resetClient(clientId: string): void {\n    const limiter = this.limiters.get(clientId);\n    if (limiter) {\n      limiter.reset();\n    }\n  }\n}",
    "testCases": [
      {
        "input": "Consume tokens within limit",
        "expectedOutput": "true",
        "isHidden": false,
        "description": "Should allow requests within rate limit"
      },
      {
        "input": "Consume tokens exceeding limit",
        "expectedOutput": "false",
        "isHidden": false,
        "description": "Should reject requests exceeding rate limit"
      },
      {
        "input": "Wait and try again",
        "expectedOutput": "true (tokens refilled)",
        "isHidden": false,
        "description": "Should refill tokens over time"
      }
    ],
    "hints": [
      "Use token bucket algorithm",
      "Refill tokens based on time passed",
      "Track last refill timestamp",
      "Maintain separate limiters per client"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Service Registry with Leases",
    "difficulty": 3,
    "description": "Implement a service registry with lease-based registration where services must renew their registration periodically.",
    "starterCode": "interface ServiceRegistration {\n  name: string;\n  host: string;\n  port: number;\n  leaseExpiry: number;\n}\n\nclass LeaseBasedRegistry {\n  // Implement lease-based service registry\n}",
    "solution": "interface ServiceRegistration {\n  name: string;\n  host: string;\n  port: number;\n  leaseExpiry: number;\n}\n\nclass LeaseBasedRegistry {\n  private services: Map<string, ServiceRegistration[]> = new Map();\n  private leaseDuration: number;\n\n  constructor(leaseDuration: number = 30000) { // 30 seconds\n    this.leaseDuration = leaseDuration;\n\n    // Start cleanup\n    setInterval(() => this.cleanup(), 5000);\n  }\n\n  register(name: string, host: string, port: number): string {\n    const registration: ServiceRegistration = {\n      name,\n      host,\n      port,\n      leaseExpiry: Date.now() + this.leaseDuration\n    };\n\n    if (!this.services.has(name)) {\n      this.services.set(name, []);\n    }\n\n    const instances = this.services.get(name)!;\n\n    // Remove existing instance with same host:port\n    const filtered = instances.filter(s =>\n      !(s.host === host && s.port === port)\n    );\n    filtered.push(registration);\n    this.services.set(name, filtered);\n\n    return this.getInstanceId(host, port);\n  }\n\n  renewLease(name: string, host: string, port: number): boolean {\n    const instances = this.services.get(name);\n    if (!instances) {\n      return false;\n    }\n\n    const instance = instances.find(s =>\n      s.host === host && s.port === port\n    );\n\n    if (instance) {\n      instance.leaseExpiry = Date.now() + this.leaseDuration;\n      return true;\n    }\n\n    return false;\n  }\n\n  discover(name: string): ServiceRegistration[] {\n    const instances = this.services.get(name) || [];\n    const now = Date.now();\n\n    // Return only non-expired instances\n    return instances.filter(s => s.leaseExpiry > now);\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n\n    this.services.forEach((instances, name) => {\n      const active = instances.filter(s => s.leaseExpiry > now);\n\n      if (active.length === 0) {\n        this.services.delete(name);\n      } else if (active.length !== instances.length) {\n        this.services.set(name, active);\n      }\n    });\n  }\n\n  private getInstanceId(host: string, port: number): string {\n    return `${host}:${port}`;\n  }\n\n  getStats(): { services: number; totalInstances: number } {\n    let totalInstances = 0;\n    const now = Date.now();\n\n    this.services.forEach(instances => {\n      totalInstances += instances.filter(s => s.leaseExpiry > now).length;\n    });\n\n    return {\n      services: this.services.size,\n      totalInstances\n    };\n  }\n}",
    "testCases": [
      {
        "input": "Register service and discover",
        "expectedOutput": "Service found",
        "isHidden": false,
        "description": "Should register and discover services"
      },
      {
        "input": "Wait for lease expiry without renewal",
        "expectedOutput": "Service removed from registry",
        "isHidden": false,
        "description": "Should remove expired services"
      },
      {
        "input": "Renew lease before expiry",
        "expectedOutput": "Service remains registered",
        "isHidden": false,
        "description": "Should keep services with renewed leases"
      }
    ],
    "hints": [
      "Store lease expiry timestamp with each registration",
      "Implement periodic cleanup of expired leases",
      "Filter expired services in discover method",
      "Allow lease renewal before expiry"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Request Correlation",
    "difficulty": 2,
    "description": "Implement request correlation to track requests across multiple services using correlation IDs.",
    "starterCode": "interface CorrelatedRequest {\n  correlationId: string;\n  serviceName: string;\n  operation: string;\n  timestamp: number;\n  parentId?: string;\n}\n\nclass RequestCorrelation {\n  // Implement request correlation\n}",
    "solution": "interface CorrelatedRequest {\n  correlationId: string;\n  serviceName: string;\n  operation: string;\n  timestamp: number;\n  parentId?: string;\n}\n\nclass RequestCorrelation {\n  private traces: Map<string, CorrelatedRequest[]> = new Map();\n\n  createCorrelationId(): string {\n    return `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  logRequest(request: CorrelatedRequest): void {\n    if (!this.traces.has(request.correlationId)) {\n      this.traces.set(request.correlationId, []);\n    }\n\n    this.traces.get(request.correlationId)!.push(request);\n  }\n\n  getTrace(correlationId: string): CorrelatedRequest[] {\n    return this.traces.get(correlationId) || [];\n  }\n\n  buildTraceTree(correlationId: string): any {\n    const requests = this.getTrace(correlationId);\n\n    if (requests.length === 0) {\n      return null;\n    }\n\n    const root = requests.find(r => !r.parentId);\n    if (!root) {\n      return null;\n    }\n\n    const buildNode = (parentId: string): any => {\n      const parent = requests.find(r =>\n        r.correlationId === correlationId &&\n        (parentId ? r.parentId === parentId : !r.parentId)\n      );\n\n      if (!parent) {\n        return null;\n      }\n\n      const children = requests\n        .filter(r => r.parentId === `${parent.serviceName}:${parent.operation}`)\n        .map(r => buildNode(`${r.serviceName}:${r.operation}`));\n\n      return {\n        service: parent.serviceName,\n        operation: parent.operation,\n        timestamp: parent.timestamp,\n        children: children.filter(c => c !== null)\n      };\n    };\n\n    return buildNode('');\n  }\n\n  cleanup(olderThan: number): void {\n    const cutoff = Date.now() - olderThan;\n\n    const toDelete: string[] = [];\n    this.traces.forEach((requests, correlationId) => {\n      const oldestRequest = requests[0];\n      if (oldestRequest.timestamp < cutoff) {\n        toDelete.push(correlationId);\n      }\n    });\n\n    toDelete.forEach(id => this.traces.delete(id));\n  }\n\n  getActiveTraces(): number {\n    return this.traces.size;\n  }\n}",
    "testCases": [
      {
        "input": "Log requests with same correlation ID",
        "expectedOutput": "Requests grouped by correlation ID",
        "isHidden": false,
        "description": "Should group requests by correlation ID"
      },
      {
        "input": "Build trace tree",
        "expectedOutput": "Hierarchical trace structure",
        "isHidden": false,
        "description": "Should build request trace tree"
      }
    ],
    "hints": [
      "Generate unique correlation IDs",
      "Store requests grouped by correlation ID",
      "Support parent-child relationships",
      "Implement cleanup for old traces"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t1-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-1",
    "title": "Distributed Configuration Manager",
    "difficulty": 3,
    "description": "Implement a configuration manager that can distribute configuration updates to multiple services and notify them of changes.",
    "starterCode": "type ConfigChangeCallback = (key: string, value: any) => void;\n\nclass ConfigurationManager {\n  // Implement configuration management\n}",
    "solution": "type ConfigChangeCallback = (key: string, value: any) => void;\n\ninterface ConfigSubscription {\n  serviceName: string;\n  keys: Set<string>;\n  callback: ConfigChangeCallback;\n}\n\nclass ConfigurationManager {\n  private config: Map<string, any> = new Map();\n  private subscriptions: Map<string, ConfigSubscription[]> = new Map();\n  private version: number = 0;\n\n  set(key: string, value: any): void {\n    const oldValue = this.config.get(key);\n    this.config.set(key, value);\n    this.version++;\n\n    // Notify subscribers if value changed\n    if (oldValue !== value) {\n      this.notifySubscribers(key, value);\n    }\n  }\n\n  get(key: string): any {\n    return this.config.get(key);\n  }\n\n  getAll(): Map<string, any> {\n    return new Map(this.config);\n  }\n\n  subscribe(\n    serviceName: string,\n    keys: string[],\n    callback: ConfigChangeCallback\n  ): () => void {\n    const subscription: ConfigSubscription = {\n      serviceName,\n      keys: new Set(keys),\n      callback\n    };\n\n    keys.forEach(key => {\n      if (!this.subscriptions.has(key)) {\n        this.subscriptions.set(key, []);\n      }\n      this.subscriptions.get(key)!.push(subscription);\n    });\n\n    // Return unsubscribe function\n    return () => {\n      keys.forEach(key => {\n        const subs = this.subscriptions.get(key);\n        if (subs) {\n          const filtered = subs.filter(s => s.serviceName !== serviceName);\n          if (filtered.length === 0) {\n            this.subscriptions.delete(key);\n          } else {\n            this.subscriptions.set(key, filtered);\n          }\n        }\n      });\n    };\n  }\n\n  private notifySubscribers(key: string, value: any): void {\n    const subscribers = this.subscriptions.get(key) || [];\n\n    subscribers.forEach(sub => {\n      try {\n        sub.callback(key, value);\n      } catch (error) {\n        console.error(`Error notifying subscriber ${sub.serviceName}:`, error);\n      }\n    });\n  }\n\n  bulkUpdate(updates: Map<string, any>): void {\n    const changes: Array<{ key: string; value: any }> = [];\n\n    updates.forEach((value, key) => {\n      const oldValue = this.config.get(key);\n      if (oldValue !== value) {\n        this.config.set(key, value);\n        changes.push({ key, value });\n      }\n    });\n\n    this.version++;\n\n    // Notify all changes\n    changes.forEach(({ key, value }) => {\n      this.notifySubscribers(key, value);\n    });\n  }\n\n  getVersion(): number {\n    return this.version;\n  }\n\n  delete(key: string): boolean {\n    const existed = this.config.delete(key);\n    if (existed) {\n      this.version++;\n      this.notifySubscribers(key, undefined);\n    }\n    return existed;\n  }\n}",
    "testCases": [
      {
        "input": "Set config value",
        "expectedOutput": "Value stored and version incremented",
        "isHidden": false,
        "description": "Should store configuration values"
      },
      {
        "input": "Subscribe to config changes",
        "expectedOutput": "Callback invoked on value change",
        "isHidden": false,
        "description": "Should notify subscribers of changes"
      },
      {
        "input": "Bulk update multiple values",
        "expectedOutput": "All values updated, all subscribers notified",
        "isHidden": false,
        "description": "Should handle bulk updates efficiently"
      }
    ],
    "hints": [
      "Track version number for cache invalidation",
      "Maintain subscriptions per config key",
      "Notify subscribers only on actual changes",
      "Support bulk updates for efficiency"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Lamport Logical Clock Implementation",
    "difficulty": 2,
    "description": "Implement Lamport logical clocks for ordering events in a distributed system.\n\nYour implementation should:\n- Maintain a logical clock counter\n- Increment on local events\n- Update clock on message send/receive\n- Compare event timestamps",
    "starterCode": "interface Event {\n  processId: string;\n  timestamp: number;\n  type: 'local' | 'send' | 'receive';\n  data?: any;\n}\n\nclass LamportClock {\n  // Implement Lamport clock\n}",
    "solution": "interface Event {\n  processId: string;\n  timestamp: number;\n  type: 'local' | 'send' | 'receive';\n  data?: any;\n}\n\nclass LamportClock {\n  private processId: string;\n  private clock: number = 0;\n  private events: Event[] = [];\n\n  constructor(processId: string) {\n    this.processId = processId;\n  }\n\n  localEvent(data?: any): number {\n    this.clock++;\n    const timestamp = this.clock;\n\n    this.events.push({\n      processId: this.processId,\n      timestamp,\n      type: 'local',\n      data\n    });\n\n    return timestamp;\n  }\n\n  prepareSend(data?: any): { timestamp: number; message: any } {\n    this.clock++;\n    const timestamp = this.clock;\n\n    this.events.push({\n      processId: this.processId,\n      timestamp,\n      type: 'send',\n      data\n    });\n\n    return {\n      timestamp,\n      message: {\n        from: this.processId,\n        timestamp,\n        data\n      }\n    };\n  }\n\n  receiveMessage(messageTimestamp: number, from: string, data?: any): number {\n    this.clock = Math.max(this.clock, messageTimestamp) + 1;\n    const timestamp = this.clock;\n\n    this.events.push({\n      processId: this.processId,\n      timestamp,\n      type: 'receive',\n      data: { from, data }\n    });\n\n    return timestamp;\n  }\n\n  getClock(): number {\n    return this.clock;\n  }\n\n  getEvents(): Event[] {\n    return [...this.events];\n  }\n\n  // Check if event a happened before event b\n  happenedBefore(timestampA: number, timestampB: number): boolean {\n    return timestampA < timestampB;\n  }\n\n  // Get total ordering of events\n  getTotalOrder(events: Event[]): Event[] {\n    return events.sort((a, b) => {\n      if (a.timestamp !== b.timestamp) {\n        return a.timestamp - b.timestamp;\n      }\n      // Tie-break using process ID\n      return a.processId.localeCompare(b.processId);\n    });\n  }\n}",
    "testCases": [
      {
        "input": "Local event increments clock",
        "expectedOutput": "Clock: 1",
        "isHidden": false,
        "description": "Should increment clock on local event"
      },
      {
        "input": "Receive message with timestamp 5 when clock is 2",
        "expectedOutput": "Clock updated to 6",
        "isHidden": false,
        "description": "Should update clock to max(local, received) + 1"
      },
      {
        "input": "Compare timestamps",
        "expectedOutput": "Correct happens-before relationship",
        "isHidden": false,
        "description": "Should determine event ordering"
      }
    ],
    "hints": [
      "Increment clock before each event",
      "On receive: max(local, message) + 1",
      "Timestamps provide total ordering",
      "Store events for audit trail"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Vector Clock Implementation",
    "difficulty": 3,
    "description": "Implement vector clocks to track causality and detect concurrent events.\n\nYour implementation should:\n- Maintain a vector of logical times\n- Update vector on events and messages\n- Compare vectors to determine causality\n- Detect concurrent events",
    "starterCode": "type VectorTime = Map<string, number>;\n\nclass VectorClock {\n  // Implement vector clock\n}",
    "solution": "type VectorTime = Map<string, number>;\n\ninterface VectorMessage {\n  from: string;\n  vector: VectorTime;\n  data?: any;\n}\n\nclass VectorClock {\n  private processId: string;\n  private vector: VectorTime;\n  private processes: Set<string>;\n\n  constructor(processId: string, allProcesses: string[]) {\n    this.processId = processId;\n    this.processes = new Set(allProcesses);\n    this.vector = new Map();\n\n    // Initialize vector with zeros\n    allProcesses.forEach(pid => {\n      this.vector.set(pid, 0);\n    });\n  }\n\n  localEvent(): VectorTime {\n    const currentValue = this.vector.get(this.processId) || 0;\n    this.vector.set(this.processId, currentValue + 1);\n    return this.copyVector();\n  }\n\n  prepareSend(data?: any): VectorMessage {\n    // Increment local clock\n    const currentValue = this.vector.get(this.processId) || 0;\n    this.vector.set(this.processId, currentValue + 1);\n\n    return {\n      from: this.processId,\n      vector: this.copyVector(),\n      data\n    };\n  }\n\n  receiveMessage(message: VectorMessage): VectorTime {\n    // Update vector: V[i] = max(V[i], message.V[i]) for all i\n    message.vector.forEach((value, pid) => {\n      const currentValue = this.vector.get(pid) || 0;\n      this.vector.set(pid, Math.max(currentValue, value));\n    });\n\n    // Increment own clock\n    const currentValue = this.vector.get(this.processId) || 0;\n    this.vector.set(this.processId, currentValue + 1);\n\n    return this.copyVector();\n  }\n\n  getVector(): VectorTime {\n    return this.copyVector();\n  }\n\n  private copyVector(): VectorTime {\n    return new Map(this.vector);\n  }\n\n  // Check if vectorA happened before vectorB (vectorA < vectorB)\n  happenedBefore(vectorA: VectorTime, vectorB: VectorTime): boolean {\n    let hasLess = false;\n    let allLessOrEqual = true;\n\n    this.processes.forEach(pid => {\n      const a = vectorA.get(pid) || 0;\n      const b = vectorB.get(pid) || 0;\n\n      if (a > b) {\n        allLessOrEqual = false;\n      }\n      if (a < b) {\n        hasLess = true;\n      }\n    });\n\n    return allLessOrEqual && hasLess;\n  }\n\n  // Check if two vectors represent concurrent events\n  isConcurrent(vectorA: VectorTime, vectorB: VectorTime): boolean {\n    return !this.happenedBefore(vectorA, vectorB) &&\n           !this.happenedBefore(vectorB, vectorA);\n  }\n\n  // Check if vectors are equal\n  isEqual(vectorA: VectorTime, vectorB: VectorTime): boolean {\n    let equal = true;\n\n    this.processes.forEach(pid => {\n      const a = vectorA.get(pid) || 0;\n      const b = vectorB.get(pid) || 0;\n      if (a !== b) {\n        equal = false;\n      }\n    });\n\n    return equal;\n  }\n\n  toString(): string {\n    const entries: string[] = [];\n    this.vector.forEach((value, pid) => {\n      entries.push(`${pid}:${value}`);\n    });\n    return `[${entries.join(', ')}]`;\n  }\n}",
    "testCases": [
      {
        "input": "Local event increments own position",
        "expectedOutput": "Vector[processId] increased by 1",
        "isHidden": false,
        "description": "Should increment own position in vector"
      },
      {
        "input": "Receive message updates vector",
        "expectedOutput": "Vector updated to component-wise max",
        "isHidden": false,
        "description": "Should merge vectors on message receive"
      },
      {
        "input": "Detect concurrent events",
        "expectedOutput": "Correctly identifies concurrent vectors",
        "isHidden": false,
        "description": "Should detect when events are concurrent"
      }
    ],
    "hints": [
      "Vector has one entry per process",
      "Update own position on every event",
      "Component-wise max on receive",
      "Concurrent if neither vector  other"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Causal Message Ordering",
    "difficulty": 3,
    "description": "Implement a causal ordering protocol that ensures messages are delivered in causal order using vector clocks.",
    "starterCode": "interface CausalMessage {\n  from: string;\n  vector: Map<string, number>;\n  content: any;\n  sequenceNumber: number;\n}\n\nclass CausalOrderingProtocol {\n  // Implement causal ordering\n}",
    "solution": "interface CausalMessage {\n  from: string;\n  vector: Map<string, number>;\n  content: any;\n  sequenceNumber: number;\n}\n\nclass CausalOrderingProtocol {\n  private processId: string;\n  private vector: Map<string, number>;\n  private processes: Set<string>;\n  private messageQueue: CausalMessage[] = [];\n  private delivered: CausalMessage[] = [];\n  private sequenceNumber: number = 0;\n\n  constructor(processId: string, allProcesses: string[]) {\n    this.processId = processId;\n    this.processes = new Set(allProcesses);\n    this.vector = new Map();\n\n    allProcesses.forEach(pid => {\n      this.vector.set(pid, 0);\n    });\n  }\n\n  send(content: any): CausalMessage {\n    // Increment own clock\n    const currentValue = this.vector.get(this.processId) || 0;\n    this.vector.set(this.processId, currentValue + 1);\n\n    const message: CausalMessage = {\n      from: this.processId,\n      vector: new Map(this.vector),\n      content,\n      sequenceNumber: ++this.sequenceNumber\n    };\n\n    return message;\n  }\n\n  receive(message: CausalMessage): void {\n    // Add to queue\n    this.messageQueue.push(message);\n\n    // Try to deliver queued messages\n    this.tryDeliver();\n  }\n\n  private tryDeliver(): void {\n    let delivered = true;\n\n    while (delivered) {\n      delivered = false;\n\n      for (let i = 0; i < this.messageQueue.length; i++) {\n        const message = this.messageQueue[i];\n\n        if (this.canDeliver(message)) {\n          // Remove from queue\n          this.messageQueue.splice(i, 1);\n\n          // Deliver message\n          this.deliverMessage(message);\n\n          delivered = true;\n          break;\n        }\n      }\n    }\n  }\n\n  private canDeliver(message: CausalMessage): boolean {\n    // Can deliver if:\n    // 1. V[sender] = local[sender] + 1\n    // 2. V[k] <= local[k] for all k != sender\n\n    const senderClock = message.vector.get(message.from) || 0;\n    const localSenderClock = this.vector.get(message.from) || 0;\n\n    if (senderClock !== localSenderClock + 1) {\n      return false;\n    }\n\n    // Check all other processes\n    for (const pid of this.processes) {\n      if (pid !== message.from) {\n        const messageClock = message.vector.get(pid) || 0;\n        const localClock = this.vector.get(pid) || 0;\n\n        if (messageClock > localClock) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private deliverMessage(message: CausalMessage): void {\n    // Update vector\n    message.vector.forEach((value, pid) => {\n      const currentValue = this.vector.get(pid) || 0;\n      this.vector.set(pid, Math.max(currentValue, value));\n    });\n\n    this.delivered.push(message);\n  }\n\n  getDelivered(): CausalMessage[] {\n    return [...this.delivered];\n  }\n\n  getQueueSize(): number {\n    return this.messageQueue.length;\n  }\n\n  getVector(): Map<string, number> {\n    return new Map(this.vector);\n  }\n}",
    "testCases": [
      {
        "input": "Messages arrive in causal order",
        "expectedOutput": "Delivered immediately",
        "isHidden": false,
        "description": "Should deliver messages in causal order"
      },
      {
        "input": "Message arrives before its causal predecessor",
        "expectedOutput": "Buffered until predecessor arrives",
        "isHidden": false,
        "description": "Should buffer out-of-order messages"
      },
      {
        "input": "Predecessor arrives",
        "expectedOutput": "Both messages delivered in correct order",
        "isHidden": false,
        "description": "Should deliver buffered messages when safe"
      }
    ],
    "hints": [
      "Buffer messages that cannot be delivered yet",
      "Check delivery conditions using vector clocks",
      "Deliver when V[sender] = local[sender] + 1",
      "Try delivering buffered messages after each receive"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Happens-Before Relationship Tracker",
    "difficulty": 2,
    "description": "Build a system that tracks and visualizes happens-before relationships between events in a distributed system.",
    "starterCode": "interface DistributedEvent {\n  id: string;\n  processId: string;\n  timestamp: number;\n  type: string;\n}\n\nclass HappenBeforeTracker {\n  // Implement happens-before tracking\n}",
    "solution": "interface DistributedEvent {\n  id: string;\n  processId: string;\n  timestamp: number;\n  type: string;\n  causedBy?: string[];\n}\n\nclass HappensBeforeTracker {\n  private events: Map<string, DistributedEvent> = new Map();\n  private happensBefore: Map<string, Set<string>> = new Map();\n\n  addEvent(event: DistributedEvent): void {\n    this.events.set(event.id, event);\n\n    if (!this.happensBefore.has(event.id)) {\n      this.happensBefore.set(event.id, new Set());\n    }\n\n    // Add causal relationships\n    if (event.causedBy) {\n      event.causedBy.forEach(causeId => {\n        this.addHappensBefore(causeId, event.id);\n      });\n    }\n  }\n\n  addHappensBefore(beforeId: string, afterId: string): void {\n    if (!this.happensBefore.has(afterId)) {\n      this.happensBefore.set(afterId, new Set());\n    }\n\n    // Add direct relationship\n    this.happensBefore.get(afterId)!.add(beforeId);\n\n    // Add transitive relationships\n    const beforePredecessors = this.happensBefore.get(beforeId);\n    if (beforePredecessors) {\n      beforePredecessors.forEach(predId => {\n        this.happensBefore.get(afterId)!.add(predId);\n      });\n    }\n\n    // Update all events that happen after 'afterId'\n    this.happensBefore.forEach((predecessors, eventId) => {\n      if (predecessors.has(afterId)) {\n        predecessors.add(beforeId);\n        if (beforePredecessors) {\n          beforePredecessors.forEach(predId => {\n            predecessors.add(predId);\n          });\n        }\n      }\n    });\n  }\n\n  happensBefore(eventA: string, eventB: string): boolean {\n    const predecessors = this.happensBefore.get(eventB);\n    return predecessors ? predecessors.has(eventA) : false;\n  }\n\n  areConcurrent(eventA: string, eventB: string): boolean {\n    return !this.happensBefore(eventA, eventB) &&\n           !this.happensBefore(eventB, eventA) &&\n           eventA !== eventB;\n  }\n\n  getCausalHistory(eventId: string): string[] {\n    const predecessors = this.happensBefore.get(eventId);\n    return predecessors ? Array.from(predecessors) : [];\n  }\n\n  getConcurrentEvents(eventId: string): string[] {\n    const concurrent: string[] = [];\n\n    this.events.forEach((_, otherId) => {\n      if (this.areConcurrent(eventId, otherId)) {\n        concurrent.push(otherId);\n      }\n    });\n\n    return concurrent;\n  }\n\n  getTopologicalOrder(): DistributedEvent[] {\n    const visited = new Set<string>();\n    const result: DistributedEvent[] = [];\n\n    const visit = (eventId: string) => {\n      if (visited.has(eventId)) {\n        return;\n      }\n\n      visited.add(eventId);\n\n      // Visit all predecessors first\n      const predecessors = this.happensBefore.get(eventId);\n      if (predecessors) {\n        predecessors.forEach(predId => visit(predId));\n      }\n\n      const event = this.events.get(eventId);\n      if (event) {\n        result.push(event);\n      }\n    };\n\n    this.events.forEach((_, eventId) => visit(eventId));\n\n    return result;\n  }\n}",
    "testCases": [
      {
        "input": "Add events with causal relationships",
        "expectedOutput": "Relationships tracked correctly",
        "isHidden": false,
        "description": "Should track happens-before relationships"
      },
      {
        "input": "Check if event A happens before event B",
        "expectedOutput": "Correct causal relationship returned",
        "isHidden": false,
        "description": "Should determine causality"
      },
      {
        "input": "Find concurrent events",
        "expectedOutput": "Events with no causal relationship",
        "isHidden": false,
        "description": "Should identify concurrent events"
      }
    ],
    "hints": [
      "Maintain adjacency list for happens-before relation",
      "Handle transitive closure of relationships",
      "Concurrent if neither happens-before the other",
      "Use topological sort for ordering"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Physical Clock Synchronization",
    "difficulty": 3,
    "description": "Simulate physical clock synchronization using a simplified version of the Cristian's algorithm.",
    "starterCode": "interface ClockReading {\n  time: number;\n  measurementTime: number;\n}\n\nclass PhysicalClockSync {\n  // Implement clock synchronization\n}",
    "solution": "interface ClockReading {\n  time: number;\n  measurementTime: number;\n}\n\ninterface SyncResult {\n  offset: number;\n  roundTripTime: number;\n  uncertainty: number;\n}\n\nclass PhysicalClockSync {\n  private localClock: number;\n  private drift: number; // Clock drift rate (1.0 = no drift)\n\n  constructor(initialTime: number = Date.now(), drift: number = 1.0) {\n    this.localClock = initialTime;\n    this.drift = drift;\n  }\n\n  // Simulate time passing\n  tick(milliseconds: number): void {\n    this.localClock += milliseconds * this.drift;\n  }\n\n  getTime(): number {\n    return Math.floor(this.localClock);\n  }\n\n  // Client requests time from server\n  requestTimeSync(serverTime: () => number, networkDelay: number): SyncResult {\n    const requestTime = this.getTime();\n\n    // Simulate network delay\n    const oneWayDelay = networkDelay / 2;\n\n    // Server processes request (gets its time)\n    const serverResponseTime = serverTime();\n\n    // Simulate return network delay\n    const responseTime = this.getTime();\n\n    const roundTripTime = responseTime - requestTime;\n    const estimatedServerTime = serverResponseTime + oneWayDelay;\n\n    const offset = estimatedServerTime - responseTime;\n    const uncertainty = roundTripTime / 2;\n\n    return {\n      offset,\n      roundTripTime,\n      uncertainty\n    };\n  }\n\n  // Adjust clock based on sync result\n  adjustClock(syncResult: SyncResult): void {\n    // Gradually adjust clock to avoid large jumps\n    const maxAdjustment = 100; // Maximum single adjustment in ms\n\n    if (Math.abs(syncResult.offset) <= maxAdjustment) {\n      this.localClock += syncResult.offset;\n    } else {\n      // For large offsets, adjust gradually\n      const sign = syncResult.offset > 0 ? 1 : -1;\n      this.localClock += sign * maxAdjustment;\n    }\n  }\n\n  // Perform multiple sync attempts and use best result\n  synchronize(\n    serverTime: () => number,\n    networkDelay: number,\n    attempts: number = 5\n  ): SyncResult {\n    let bestResult: SyncResult | null = null;\n\n    for (let i = 0; i < attempts; i++) {\n      const result = this.requestTimeSync(serverTime, networkDelay);\n\n      if (!bestResult || result.roundTripTime < bestResult.roundTripTime) {\n        bestResult = result;\n      }\n\n      // Small delay between attempts\n      this.tick(10);\n    }\n\n    if (bestResult) {\n      this.adjustClock(bestResult);\n    }\n\n    return bestResult!;\n  }\n\n  setDrift(drift: number): void {\n    this.drift = drift;\n  }\n\n  getDrift(): number {\n    return this.drift;\n  }\n}",
    "testCases": [
      {
        "input": "Sync with server",
        "expectedOutput": "Clock adjusted based on offset",
        "isHidden": false,
        "description": "Should synchronize with time server"
      },
      {
        "input": "Multiple sync attempts",
        "expectedOutput": "Best result (lowest RTT) used",
        "isHidden": false,
        "description": "Should use best sync result"
      },
      {
        "input": "Clock with drift",
        "expectedOutput": "Gradually diverges from correct time",
        "isHidden": false,
        "description": "Should simulate clock drift"
      }
    ],
    "hints": [
      "Estimate one-way delay as RTT/2",
      "Calculate offset between local and server time",
      "Use multiple samples and choose best (lowest RTT)",
      "Avoid large sudden clock adjustments"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Hybrid Logical Clock",
    "difficulty": 4,
    "description": "Implement hybrid logical clocks that combine physical and logical time for better ordering.",
    "starterCode": "interface HLCTimestamp {\n  physicalTime: number;\n  logicalTime: number;\n}\n\nclass HybridLogicalClock {\n  // Implement hybrid logical clock\n}",
    "solution": "interface HLCTimestamp {\n  physicalTime: number;\n  logicalTime: number;\n}\n\nclass HybridLogicalClock {\n  private lastPhysicalTime: number = 0;\n  private logicalTime: number = 0;\n\n  private getPhysicalTime(): number {\n    return Date.now();\n  }\n\n  now(): HLCTimestamp {\n    const physicalTime = this.getPhysicalTime();\n\n    if (physicalTime > this.lastPhysicalTime) {\n      this.lastPhysicalTime = physicalTime;\n      this.logicalTime = 0;\n    } else {\n      this.logicalTime++;\n    }\n\n    return {\n      physicalTime: this.lastPhysicalTime,\n      logicalTime: this.logicalTime\n    };\n  }\n\n  update(remoteTimestamp: HLCTimestamp): HLCTimestamp {\n    const physicalTime = this.getPhysicalTime();\n    const maxPhysical = Math.max(\n      physicalTime,\n      this.lastPhysicalTime,\n      remoteTimestamp.physicalTime\n    );\n\n    if (maxPhysical === this.lastPhysicalTime) {\n      // Same physical time as before\n      this.logicalTime++;\n    } else if (maxPhysical === remoteTimestamp.physicalTime) {\n      // Remote time is newer\n      this.lastPhysicalTime = remoteTimestamp.physicalTime;\n      this.logicalTime = remoteTimestamp.logicalTime + 1;\n    } else {\n      // Physical time advanced\n      this.lastPhysicalTime = maxPhysical;\n      this.logicalTime = 0;\n    }\n\n    return {\n      physicalTime: this.lastPhysicalTime,\n      logicalTime: this.logicalTime\n    };\n  }\n\n  compare(a: HLCTimestamp, b: HLCTimestamp): number {\n    if (a.physicalTime !== b.physicalTime) {\n      return a.physicalTime - b.physicalTime;\n    }\n    return a.logicalTime - b.logicalTime;\n  }\n\n  happensBefore(a: HLCTimestamp, b: HLCTimestamp): boolean {\n    return this.compare(a, b) < 0;\n  }\n\n  toString(timestamp: HLCTimestamp): string {\n    return `${timestamp.physicalTime}.${timestamp.logicalTime}`;\n  }\n\n  fromString(str: string): HLCTimestamp {\n    const [physical, logical] = str.split('.').map(Number);\n    return {\n      physicalTime: physical,\n      logicalTime: logical\n    };\n  }\n}",
    "testCases": [
      {
        "input": "Generate timestamp",
        "expectedOutput": "HLC timestamp with physical and logical components",
        "isHidden": false,
        "description": "Should generate hybrid timestamps"
      },
      {
        "input": "Update with remote timestamp",
        "expectedOutput": "Local HLC updated correctly",
        "isHidden": false,
        "description": "Should update HLC on message receive"
      },
      {
        "input": "Compare timestamps",
        "expectedOutput": "Correct ordering determined",
        "isHidden": false,
        "description": "Should compare HLC timestamps correctly"
      }
    ],
    "hints": [
      "Use physical time when it advances",
      "Use logical counter when physical time same",
      "Take max of local, remote, and current physical time",
      "Compare physical time first, then logical"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Total Ordering Service",
    "difficulty": 3,
    "description": "Implement a centralized total ordering service that assigns sequence numbers to events.",
    "starterCode": "interface OrderedEvent {\n  eventId: string;\n  sequenceNumber: number;\n  timestamp: number;\n  data: any;\n}\n\nclass TotalOrderingService {\n  // Implement total ordering\n}",
    "solution": "interface OrderedEvent {\n  eventId: string;\n  sequenceNumber: number;\n  timestamp: number;\n  data: any;\n}\n\ninterface EventRequest {\n  eventId: string;\n  data: any;\n  requestTime: number;\n}\n\nclass TotalOrderingService {\n  private sequenceNumber: number = 0;\n  private orderedEvents: OrderedEvent[] = [];\n  private pendingRequests: EventRequest[] = [];\n\n  submitEvent(eventId: string, data: any): Promise<OrderedEvent> {\n    const request: EventRequest = {\n      eventId,\n      data,\n      requestTime: Date.now()\n    };\n\n    this.pendingRequests.push(request);\n\n    return new Promise((resolve) => {\n      // Simulate async processing\n      setTimeout(() => {\n        const orderedEvent = this.processEvent(request);\n        resolve(orderedEvent);\n      }, 10);\n    });\n  }\n\n  private processEvent(request: EventRequest): OrderedEvent {\n    const orderedEvent: OrderedEvent = {\n      eventId: request.eventId,\n      sequenceNumber: ++this.sequenceNumber,\n      timestamp: Date.now(),\n      data: request.data\n    };\n\n    this.orderedEvents.push(orderedEvent);\n\n    // Remove from pending\n    const index = this.pendingRequests.indexOf(request);\n    if (index > -1) {\n      this.pendingRequests.splice(index, 1);\n    }\n\n    return orderedEvent;\n  }\n\n  getOrderedEvents(): OrderedEvent[] {\n    return [...this.orderedEvents];\n  }\n\n  getEventBySequence(sequenceNumber: number): OrderedEvent | undefined {\n    return this.orderedEvents.find(e => e.sequenceNumber === sequenceNumber);\n  }\n\n  getEventsInRange(start: number, end: number): OrderedEvent[] {\n    return this.orderedEvents.filter(\n      e => e.sequenceNumber >= start && e.sequenceNumber <= end\n    );\n  }\n\n  getCurrentSequence(): number {\n    return this.sequenceNumber;\n  }\n\n  getPendingCount(): number {\n    return this.pendingRequests.length;\n  }\n}",
    "testCases": [
      {
        "input": "Submit multiple events",
        "expectedOutput": "Events assigned sequential numbers",
        "isHidden": false,
        "description": "Should assign total order to events"
      },
      {
        "input": "Retrieve events by sequence",
        "expectedOutput": "Events returned in total order",
        "isHidden": false,
        "description": "Should maintain total ordering"
      }
    ],
    "hints": [
      "Centralized sequencer assigns numbers",
      "Increment sequence number for each event",
      "Maintain ordered list of events",
      "Handle async event submission"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Clock Drift Simulator",
    "difficulty": 2,
    "description": "Simulate clock drift in distributed systems and measure the divergence over time.",
    "starterCode": "class ClockDriftSimulator {\n  // Implement clock drift simulation\n}",
    "solution": "interface Clock {\n  id: string;\n  currentTime: number;\n  driftRate: number; // Parts per million (ppm)\n  lastUpdate: number;\n}\n\nclass ClockDriftSimulator {\n  private clocks: Map<string, Clock> = new Map();\n  private referenceTime: number;\n\n  constructor() {\n    this.referenceTime = Date.now();\n  }\n\n  addClock(id: string, driftRate: number): void {\n    this.clocks.set(id, {\n      id,\n      currentTime: this.referenceTime,\n      driftRate,\n      lastUpdate: this.referenceTime\n    });\n  }\n\n  simulate(durationMs: number, steps: number = 100): void {\n    const stepSize = durationMs / steps;\n\n    for (let i = 0; i < steps; i++) {\n      this.clocks.forEach(clock => {\n        this.updateClock(clock, stepSize);\n      });\n    }\n  }\n\n  private updateClock(clock: Clock, elapsedMs: number): void {\n    // Calculate drift: drift = elapsed * (driftRate / 1_000_000)\n    const drift = elapsedMs * (clock.driftRate / 1_000_000);\n    clock.currentTime += elapsedMs + drift;\n    clock.lastUpdate += elapsedMs;\n  }\n\n  getClockTime(id: string): number | null {\n    const clock = this.clocks.get(id);\n    return clock ? clock.currentTime : null;\n  }\n\n  getSkew(clockA: string, clockB: string): number | null {\n    const timeA = this.getClockTime(clockA);\n    const timeB = this.getClockTime(clockB);\n\n    if (timeA === null || timeB === null) {\n      return null;\n    }\n\n    return timeA - timeB;\n  }\n\n  getAllSkews(): Map<string, number> {\n    const skews = new Map<string, number>();\n\n    if (this.clocks.size < 2) {\n      return skews;\n    }\n\n    const clockIds = Array.from(this.clocks.keys());\n    const referenceClock = clockIds[0];\n    const referenceTime = this.getClockTime(referenceClock)!;\n\n    clockIds.forEach(id => {\n      const time = this.getClockTime(id)!;\n      skews.set(id, time - referenceTime);\n    });\n\n    return skews;\n  }\n\n  synchronizeClocks(targetClockId: string): void {\n    const targetTime = this.getClockTime(targetClockId);\n    if (targetTime === null) {\n      return;\n    }\n\n    this.clocks.forEach(clock => {\n      if (clock.id !== targetClockId) {\n        clock.currentTime = targetTime;\n      }\n    });\n  }\n\n  reset(): void {\n    this.referenceTime = Date.now();\n    this.clocks.forEach(clock => {\n      clock.currentTime = this.referenceTime;\n      clock.lastUpdate = this.referenceTime;\n    });\n  }\n\n  getMaxSkew(): number {\n    if (this.clocks.size < 2) {\n      return 0;\n    }\n\n    const times = Array.from(this.clocks.values()).map(c => c.currentTime);\n    return Math.max(...times) - Math.min(...times);\n  }\n}",
    "testCases": [
      {
        "input": "Add clocks with different drift rates",
        "expectedOutput": "Clocks registered",
        "isHidden": false,
        "description": "Should track multiple clocks"
      },
      {
        "input": "Simulate time passing",
        "expectedOutput": "Clocks diverge based on drift rates",
        "isHidden": false,
        "description": "Should simulate clock drift"
      },
      {
        "input": "Measure skew between clocks",
        "expectedOutput": "Correct skew calculated",
        "isHidden": false,
        "description": "Should calculate clock skew"
      }
    ],
    "hints": [
      "Drift rate in parts per million (ppm)",
      "Update each clock based on elapsed time and drift",
      "Skew is difference between two clocks",
      "Track maximum divergence across all clocks"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Event Log with Causal Ordering",
    "difficulty": 3,
    "description": "Implement an event log that maintains causal ordering of events across distributed processes.",
    "starterCode": "interface LogEntry {\n  eventId: string;\n  processId: string;\n  vector: Map<string, number>;\n  content: any;\n}\n\nclass CausalEventLog {\n  // Implement causal event log\n}",
    "solution": "interface LogEntry {\n  eventId: string;\n  processId: string;\n  vector: Map<string, number>;\n  content: any;\n  timestamp: number;\n}\n\nclass CausalEventLog {\n  private log: LogEntry[] = [];\n  private processId: string;\n  private vector: Map<string, number>;\n  private processes: Set<string>;\n\n  constructor(processId: string, allProcesses: string[]) {\n    this.processId = processId;\n    this.processes = new Set(allProcesses);\n    this.vector = new Map();\n\n    allProcesses.forEach(pid => {\n      this.vector.set(pid, 0);\n    });\n  }\n\n  append(eventId: string, content: any): LogEntry {\n    // Increment own clock\n    const currentValue = this.vector.get(this.processId) || 0;\n    this.vector.set(this.processId, currentValue + 1);\n\n    const entry: LogEntry = {\n      eventId,\n      processId: this.processId,\n      vector: new Map(this.vector),\n      content,\n      timestamp: Date.now()\n    };\n\n    this.log.push(entry);\n    return entry;\n  }\n\n  merge(entries: LogEntry[]): void {\n    entries.forEach(entry => {\n      // Update vector clock\n      entry.vector.forEach((value, pid) => {\n        const currentValue = this.vector.get(pid) || 0;\n        this.vector.set(pid, Math.max(currentValue, value));\n      });\n\n      // Add to log if not already present\n      const exists = this.log.some(e => e.eventId === entry.eventId);\n      if (!exists) {\n        this.log.push(entry);\n      }\n    });\n\n    // Sort log by causal order\n    this.sortLog();\n  }\n\n  private sortLog(): void {\n    this.log.sort((a, b) => {\n      // Try to order by vector clock\n      const aBeforeB = this.vectorLessThan(a.vector, b.vector);\n      const bBeforeA = this.vectorLessThan(b.vector, a.vector);\n\n      if (aBeforeB) return -1;\n      if (bBeforeA) return 1;\n\n      // Concurrent events: order by timestamp, then eventId\n      if (a.timestamp !== b.timestamp) {\n        return a.timestamp - b.timestamp;\n      }\n      return a.eventId.localeCompare(b.eventId);\n    });\n  }\n\n  private vectorLessThan(a: Map<string, number>, b: Map<string, number>): boolean {\n    let hasLess = false;\n    let allLessOrEqual = true;\n\n    this.processes.forEach(pid => {\n      const aVal = a.get(pid) || 0;\n      const bVal = b.get(pid) || 0;\n\n      if (aVal > bVal) {\n        allLessOrEqual = false;\n      }\n      if (aVal < bVal) {\n        hasLess = true;\n      }\n    });\n\n    return allLessOrEqual && hasLess;\n  }\n\n  getLog(): LogEntry[] {\n    return [...this.log];\n  }\n\n  getLogSince(vector: Map<string, number>): LogEntry[] {\n    return this.log.filter(entry => {\n      return !this.vectorLessThanOrEqual(entry.vector, vector);\n    });\n  }\n\n  private vectorLessThanOrEqual(a: Map<string, number>, b: Map<string, number>): boolean {\n    let allLessOrEqual = true;\n\n    this.processes.forEach(pid => {\n      const aVal = a.get(pid) || 0;\n      const bVal = b.get(pid) || 0;\n\n      if (aVal > bVal) {\n        allLessOrEqual = false;\n      }\n    });\n\n    return allLessOrEqual;\n  }\n\n  getVector(): Map<string, number> {\n    return new Map(this.vector);\n  }\n\n  size(): number {\n    return this.log.size();\n  }\n}",
    "testCases": [
      {
        "input": "Append events",
        "expectedOutput": "Events added to log with vector clocks",
        "isHidden": false,
        "description": "Should append events to log"
      },
      {
        "input": "Merge logs from different processes",
        "expectedOutput": "Logs merged and sorted in causal order",
        "isHidden": false,
        "description": "Should merge logs maintaining causal order"
      }
    ],
    "hints": [
      "Attach vector clock to each log entry",
      "Sort entries by causal order",
      "Use timestamp for concurrent events",
      "Support incremental log synchronization"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Distributed Snapshot Algorithm",
    "difficulty": 4,
    "description": "Implement the Chandy-Lamport snapshot algorithm for capturing a consistent global state.",
    "starterCode": "interface ProcessState {\n  processId: string;\n  localState: any;\n  channelStates: Map<string, any[]>;\n}\n\nclass DistributedSnapshot {\n  // Implement distributed snapshot\n}",
    "solution": "interface ProcessState {\n  processId: string;\n  localState: any;\n  channelStates: Map<string, any[]>;\n}\n\ninterface Message {\n  from: string;\n  to: string;\n  content: any;\n  isMarker?: boolean;\n}\n\nclass DistributedSnapshot {\n  private processId: string;\n  private state: any;\n  private neighbors: Set<string>;\n  private snapshotState: ProcessState | null = null;\n  private recordingChannels: Map<string, any[]> = new Map();\n  private markersSeen: Set<string> = new Set();\n  private snapshotInitiator: boolean = false;\n\n  constructor(processId: string, neighbors: string[], initialState: any) {\n    this.processId = processId;\n    this.neighbors = new Set(neighbors);\n    this.state = initialState;\n  }\n\n  initiateSnapshot(): ProcessState {\n    // Record own state\n    this.snapshotState = {\n      processId: this.processId,\n      localState: JSON.parse(JSON.stringify(this.state)),\n      channelStates: new Map()\n    };\n\n    this.snapshotInitiator = true;\n\n    // Start recording on all incoming channels\n    this.neighbors.forEach(neighbor => {\n      this.recordingChannels.set(neighbor, []);\n    });\n\n    // Send markers to all neighbors\n    // (In real implementation, would actually send messages)\n\n    return this.snapshotState;\n  }\n\n  receiveMarker(from: string): void {\n    if (!this.markersSeen.has(from)) {\n      this.markersSeen.add(from);\n\n      if (!this.snapshotState) {\n        // First marker received - record own state\n        this.snapshotState = {\n          processId: this.processId,\n          localState: JSON.parse(JSON.stringify(this.state)),\n          channelStates: new Map()\n        };\n\n        // Stop recording from sender\n        this.snapshotState.channelStates.set(from, []);\n\n        // Start recording on other channels\n        this.neighbors.forEach(neighbor => {\n          if (neighbor !== from) {\n            this.recordingChannels.set(neighbor, []);\n          }\n        });\n\n        // Send markers to all neighbors (except sender)\n        // (In real implementation)\n      } else {\n        // Subsequent marker - stop recording from this channel\n        const messages = this.recordingChannels.get(from) || [];\n        this.snapshotState.channelStates.set(from, messages);\n        this.recordingChannels.delete(from);\n      }\n    }\n\n    // Check if snapshot complete\n    if (this.isSnapshotComplete()) {\n      this.finalizeSnapshot();\n    }\n  }\n\n  receiveMessage(message: Message): void {\n    if (message.isMarker) {\n      this.receiveMarker(message.from);\n    } else {\n      // Regular message\n      // If recording from this channel, add to channel state\n      if (this.recordingChannels.has(message.from)) {\n        this.recordingChannels.get(message.from)!.push(message.content);\n      }\n\n      // Process message (update local state)\n      // Implementation specific\n    }\n  }\n\n  private isSnapshotComplete(): boolean {\n    if (!this.snapshotState) {\n      return false;\n    }\n\n    // Snapshot complete when we've received markers from all neighbors\n    return this.markersSeen.size === this.neighbors.size;\n  }\n\n  private finalizeSnapshot(): void {\n    if (!this.snapshotState) {\n      return;\n    }\n\n    // Add any remaining channel states\n    this.recordingChannels.forEach((messages, channel) => {\n      this.snapshotState!.channelStates.set(channel, messages);\n    });\n\n    this.recordingChannels.clear();\n  }\n\n  getSnapshot(): ProcessState | null {\n    return this.snapshotState;\n  }\n\n  reset(): void {\n    this.snapshotState = null;\n    this.recordingChannels.clear();\n    this.markersSeen.clear();\n    this.snapshotInitiator = false;\n  }\n\n  updateState(newState: any): void {\n    this.state = newState;\n  }\n}",
    "testCases": [
      {
        "input": "Initiate snapshot",
        "expectedOutput": "Local state recorded, markers sent",
        "isHidden": false,
        "description": "Should initiate distributed snapshot"
      },
      {
        "input": "Receive marker",
        "expectedOutput": "Channel states recorded correctly",
        "isHidden": false,
        "description": "Should handle marker messages"
      },
      {
        "input": "Complete snapshot",
        "expectedOutput": "Consistent global state captured",
        "isHidden": false,
        "description": "Should capture consistent snapshot"
      }
    ],
    "hints": [
      "Record local state on first marker",
      "Record channel state between first marker and marker from that channel",
      "Send markers to all neighbors",
      "Snapshot complete when markers received from all"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Version Vector for Conflict Detection",
    "difficulty": 3,
    "description": "Implement version vectors for detecting conflicts in replicated data.",
    "starterCode": "type VersionVector = Map<string, number>;\n\nclass VersionVectorManager {\n  // Implement version vector management\n}",
    "solution": "type VersionVector = Map<string, number>;\n\ninterface VersionedValue {\n  value: any;\n  version: VersionVector;\n}\n\nclass VersionVectorManager {\n  private replicaId: string;\n  private vector: VersionVector;\n  private replicas: Set<string>;\n\n  constructor(replicaId: string, allReplicas: string[]) {\n    this.replicaId = replicaId;\n    this.replicas = new Set(allReplicas);\n    this.vector = new Map();\n\n    allReplicas.forEach(rid => {\n      this.vector.set(rid, 0);\n    });\n  }\n\n  increment(): VersionVector {\n    const current = this.vector.get(this.replicaId) || 0;\n    this.vector.set(this.replicaId, current + 1);\n    return this.getVector();\n  }\n\n  merge(otherVector: VersionVector): void {\n    otherVector.forEach((value, rid) => {\n      const current = this.vector.get(rid) || 0;\n      this.vector.set(rid, Math.max(current, value));\n    });\n  }\n\n  getVector(): VersionVector {\n    return new Map(this.vector);\n  }\n\n  // Check if vectorA happened before vectorB\n  happenedBefore(vectorA: VersionVector, vectorB: VersionVector): boolean {\n    let hasLess = false;\n    let allLessOrEqual = true;\n\n    this.replicas.forEach(rid => {\n      const a = vectorA.get(rid) || 0;\n      const b = vectorB.get(rid) || 0;\n\n      if (a > b) {\n        allLessOrEqual = false;\n      }\n      if (a < b) {\n        hasLess = true;\n      }\n    });\n\n    return allLessOrEqual && hasLess;\n  }\n\n  // Check if two version vectors are concurrent (conflict)\n  isConflict(vectorA: VersionVector, vectorB: VersionVector): boolean {\n    return !this.happenedBefore(vectorA, vectorB) &&\n           !this.happenedBefore(vectorB, vectorA) &&\n           !this.areEqual(vectorA, vectorB);\n  }\n\n  areEqual(vectorA: VersionVector, vectorB: VersionVector): boolean {\n    let equal = true;\n\n    this.replicas.forEach(rid => {\n      const a = vectorA.get(rid) || 0;\n      const b = vectorB.get(rid) || 0;\n      if (a !== b) {\n        equal = false;\n      }\n    });\n\n    return equal;\n  }\n\n  // Determine which values to keep (dominating versions)\n  reconcile(values: VersionedValue[]): VersionedValue[] {\n    const dominating: VersionedValue[] = [];\n\n    values.forEach(valueA => {\n      let isDominated = false;\n\n      for (const valueB of values) {\n        if (valueA !== valueB &&\n            this.happenedBefore(valueA.version, valueB.version)) {\n          isDominated = true;\n          break;\n        }\n      }\n\n      if (!isDominated) {\n        dominating.push(valueA);\n      }\n    });\n\n    return dominating;\n  }\n}",
    "testCases": [
      {
        "input": "Increment version vector",
        "expectedOutput": "Own position incremented",
        "isHidden": false,
        "description": "Should increment version vector"
      },
      {
        "input": "Detect conflict between concurrent versions",
        "expectedOutput": "Conflict detected",
        "isHidden": false,
        "description": "Should detect version conflicts"
      },
      {
        "input": "Reconcile conflicting versions",
        "expectedOutput": "Dominating versions identified",
        "isHidden": false,
        "description": "Should reconcile conflicts"
      }
    ],
    "hints": [
      "Version vector tracks updates from each replica",
      "Conflict when neither vector dominates",
      "Reconcile by finding non-dominated versions",
      "Merge takes component-wise maximum"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Timestamp Ordering for Transactions",
    "difficulty": 3,
    "description": "Implement timestamp-based concurrency control for distributed transactions.",
    "starterCode": "interface Transaction {\n  id: string;\n  timestamp: number;\n  operations: Operation[];\n}\n\ninterface Operation {\n  type: 'read' | 'write';\n  key: string;\n  value?: any;\n}\n\nclass TimestampOrdering {\n  // Implement timestamp ordering\n}",
    "solution": "interface Transaction {\n  id: string;\n  timestamp: number;\n  operations: Operation[];\n  status: 'active' | 'committed' | 'aborted';\n}\n\ninterface Operation {\n  type: 'read' | 'write';\n  key: string;\n  value?: any;\n}\n\ninterface DataItem {\n  value: any;\n  readTimestamp: number;\n  writeTimestamp: number;\n}\n\nclass TimestampOrdering {\n  private data: Map<string, DataItem> = new Map();\n  private transactions: Map<string, Transaction> = new Map();\n  private timestampCounter: number = 0;\n\n  beginTransaction(id: string): Transaction {\n    const transaction: Transaction = {\n      id,\n      timestamp: ++this.timestampCounter,\n      operations: [],\n      status: 'active'\n    };\n\n    this.transactions.set(id, transaction);\n    return transaction;\n  }\n\n  read(transactionId: string, key: string): any | null {\n    const transaction = this.transactions.get(transactionId);\n    if (!transaction || transaction.status !== 'active') {\n      return null;\n    }\n\n    let item = this.data.get(key);\n    if (!item) {\n      item = {\n        value: null,\n        readTimestamp: 0,\n        writeTimestamp: 0\n      };\n      this.data.set(key, item);\n    }\n\n    // Check timestamp ordering rule for reads\n    if (transaction.timestamp < item.writeTimestamp) {\n      // Transaction reading a value written by a later transaction - abort\n      this.abort(transactionId);\n      throw new Error(`Transaction ${transactionId} aborted - timestamp ordering violation on read`);\n    }\n\n    // Update read timestamp\n    item.readTimestamp = Math.max(item.readTimestamp, transaction.timestamp);\n\n    transaction.operations.push({ type: 'read', key });\n\n    return item.value;\n  }\n\n  write(transactionId: string, key: string, value: any): boolean {\n    const transaction = this.transactions.get(transactionId);\n    if (!transaction || transaction.status !== 'active') {\n      return false;\n    }\n\n    let item = this.data.get(key);\n    if (!item) {\n      item = {\n        value: null,\n        readTimestamp: 0,\n        writeTimestamp: 0\n      };\n      this.data.set(key, item);\n    }\n\n    // Check timestamp ordering rules for writes\n    if (transaction.timestamp < item.readTimestamp) {\n      // Transaction writing a value that was read by a later transaction - abort\n      this.abort(transactionId);\n      throw new Error(`Transaction ${transactionId} aborted - timestamp ordering violation on write (read)`);\n    }\n\n    if (transaction.timestamp < item.writeTimestamp) {\n      // Transaction writing a value that was written by a later transaction - abort (or ignore write)\n      // Thomas Write Rule: can ignore this write\n      transaction.operations.push({ type: 'write', key, value });\n      return true;\n    }\n\n    // Perform write\n    item.value = value;\n    item.writeTimestamp = transaction.timestamp;\n\n    transaction.operations.push({ type: 'write', key, value });\n\n    return true;\n  }\n\n  commit(transactionId: string): boolean {\n    const transaction = this.transactions.get(transactionId);\n    if (!transaction || transaction.status !== 'active') {\n      return false;\n    }\n\n    transaction.status = 'committed';\n    return true;\n  }\n\n  abort(transactionId: string): void {\n    const transaction = this.transactions.get(transactionId);\n    if (transaction) {\n      transaction.status = 'aborted';\n    }\n  }\n\n  getTransaction(id: string): Transaction | undefined {\n    return this.transactions.get(id);\n  }\n\n  getData(key: string): any {\n    return this.data.get(key)?.value;\n  }\n}",
    "testCases": [
      {
        "input": "Transaction with valid timestamp ordering",
        "expectedOutput": "Transaction commits successfully",
        "isHidden": false,
        "description": "Should allow transactions in timestamp order"
      },
      {
        "input": "Transaction violates timestamp ordering",
        "expectedOutput": "Transaction aborted",
        "isHidden": false,
        "description": "Should abort transactions violating ordering"
      }
    ],
    "hints": [
      "Assign monotonically increasing timestamps",
      "Track read and write timestamps per data item",
      "Abort if T(i) < write timestamp on read",
      "Abort if T(i) < read timestamp on write"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Message Reordering Detector",
    "difficulty": 2,
    "description": "Build a system that detects when messages arrive out of order and can reorder them.",
    "starterCode": "interface SequencedMessage {\n  id: string;\n  sequence: number;\n  content: any;\n}\n\nclass MessageReorderingDetector {\n  // Implement message reordering detection\n}",
    "solution": "interface SequencedMessage {\n  id: string;\n  sequence: number;\n  content: any;\n  receivedAt: number;\n}\n\nclass MessageReorderingDetector {\n  private expectedSequence: number = 1;\n  private buffer: Map<number, SequencedMessage> = new Map();\n  private delivered: SequencedMessage[] = [];\n  private reorderedCount: number = 0;\n\n  receiveMessage(message: SequencedMessage): void {\n    const receivedMessage = {\n      ...message,\n      receivedAt: Date.now()\n    };\n\n    if (message.sequence === this.expectedSequence) {\n      // In-order message\n      this.deliverMessage(receivedMessage);\n      this.expectedSequence++;\n\n      // Check buffer for subsequent messages\n      this.deliverBuffered();\n    } else if (message.sequence > this.expectedSequence) {\n      // Out-of-order message (early arrival)\n      this.buffer.set(message.sequence, receivedMessage);\n      this.reorderedCount++;\n    } else {\n      // Duplicate or very late message - ignore\n      console.warn(`Ignoring duplicate/late message: ${message.id}`);\n    }\n  }\n\n  private deliverMessage(message: SequencedMessage): void {\n    this.delivered.push(message);\n  }\n\n  private deliverBuffered(): void {\n    while (this.buffer.has(this.expectedSequence)) {\n      const message = this.buffer.get(this.expectedSequence)!;\n      this.buffer.delete(this.expectedSequence);\n      this.deliverMessage(message);\n      this.expectedSequence++;\n    }\n  }\n\n  getDelivered(): SequencedMessage[] {\n    return [...this.delivered];\n  }\n\n  getBufferSize(): number {\n    return this.buffer.size;\n  }\n\n  getReorderedCount(): number {\n    return this.reorderedCount;\n  }\n\n  getMissingSequences(): number[] {\n    if (this.buffer.size === 0) {\n      return [];\n    }\n\n    const bufferedSequences = Array.from(this.buffer.keys()).sort((a, b) => a - b);\n    const missing: number[] = [];\n\n    for (let seq = this.expectedSequence; seq < bufferedSequences[bufferedSequences.length - 1]; seq++) {\n      if (!this.buffer.has(seq)) {\n        missing.push(seq);\n      }\n    }\n\n    return missing;\n  }\n\n  reset(): void {\n    this.expectedSequence = 1;\n    this.buffer.clear();\n    this.delivered = [];\n    this.reorderedCount = 0;\n  }\n}",
    "testCases": [
      {
        "input": "Messages arrive in order",
        "expectedOutput": "Delivered immediately, no buffering",
        "isHidden": false,
        "description": "Should handle in-order messages"
      },
      {
        "input": "Message arrives out of order",
        "expectedOutput": "Buffered until gap filled",
        "isHidden": false,
        "description": "Should buffer out-of-order messages"
      },
      {
        "input": "Missing message arrives",
        "expectedOutput": "Gap filled, buffered messages delivered",
        "isHidden": false,
        "description": "Should deliver buffered messages when gap filled"
      }
    ],
    "hints": [
      "Track expected next sequence number",
      "Buffer messages that arrive early",
      "Deliver buffered messages when gap is filled",
      "Detect and report missing sequences"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Event Time vs Processing Time",
    "difficulty": 3,
    "description": "Implement a system that tracks both event time (when event occurred) and processing time (when event was processed), handling out-of-order events.",
    "starterCode": "interface TimedEvent {\n  id: string;\n  eventTime: number;\n  processingTime?: number;\n  data: any;\n}\n\nclass EventTimeProcessor {\n  // Implement event time processing\n}",
    "solution": "interface TimedEvent {\n  id: string;\n  eventTime: number;\n  processingTime?: number;\n  data: any;\n}\n\ninterface TimeWindow {\n  start: number;\n  end: number;\n  events: TimedEvent[];\n}\n\nclass EventTimeProcessor {\n  private events: TimedEvent[] = [];\n  private watermark: number = 0;\n  private allowedLateness: number;\n\n  constructor(allowedLateness: number = 5000) { // 5 seconds default\n    this.allowedLateness = allowedLateness;\n  }\n\n  processEvent(event: TimedEvent): { accepted: boolean; reason?: string } {\n    const processingTime = Date.now();\n    const eventWithProcessingTime = {\n      ...event,\n      processingTime\n    };\n\n    // Check if event is too late (before watermark - allowed lateness)\n    if (event.eventTime < this.watermark - this.allowedLateness) {\n      return {\n        accepted: false,\n        reason: 'Event too late - beyond allowed lateness'\n      };\n    }\n\n    this.events.push(eventWithProcessingTime);\n\n    // Update watermark (simulated)\n    // In real system, watermark would be based on event time progress\n    this.updateWatermark(event.eventTime);\n\n    return { accepted: true };\n  }\n\n  private updateWatermark(eventTime: number): void {\n    // Simplified watermark: max event time seen minus allowed lateness\n    const maxEventTime = Math.max(\n      ...this.events.map(e => e.eventTime),\n      eventTime\n    );\n\n    this.watermark = Math.max(this.watermark, maxEventTime - this.allowedLateness);\n  }\n\n  getEventsInWindow(startTime: number, endTime: number): TimedEvent[] {\n    return this.events\n      .filter(e => e.eventTime >= startTime && e.eventTime < endTime)\n      .sort((a, b) => a.eventTime - b.eventTime);\n  }\n\n  getTumblingWindows(windowSize: number): TimeWindow[] {\n    if (this.events.length === 0) {\n      return [];\n    }\n\n    const minTime = Math.min(...this.events.map(e => e.eventTime));\n    const maxTime = Math.max(...this.events.map(e => e.eventTime));\n\n    const windows: TimeWindow[] = [];\n    let start = Math.floor(minTime / windowSize) * windowSize;\n\n    while (start <= maxTime) {\n      const end = start + windowSize;\n      const windowEvents = this.getEventsInWindow(start, end);\n\n      if (windowEvents.length > 0) {\n        windows.push({ start, end, events: windowEvents });\n      }\n\n      start = end;\n    }\n\n    return windows;\n  }\n\n  getSlidingWindows(windowSize: number, slideSize: number): TimeWindow[] {\n    if (this.events.length === 0) {\n      return [];\n    }\n\n    const minTime = Math.min(...this.events.map(e => e.eventTime));\n    const maxTime = Math.max(...this.events.map(e => e.eventTime));\n\n    const windows: TimeWindow[] = [];\n    let start = Math.floor(minTime / slideSize) * slideSize;\n\n    while (start <= maxTime) {\n      const end = start + windowSize;\n      const windowEvents = this.getEventsInWindow(start, end);\n\n      if (windowEvents.length > 0) {\n        windows.push({ start, end, events: windowEvents });\n      }\n\n      start += slideSize;\n    }\n\n    return windows;\n  }\n\n  getLateness(): Array<{ eventId: string; lateness: number }> {\n    return this.events\n      .filter(e => e.processingTime !== undefined)\n      .map(e => ({\n        eventId: e.id,\n        lateness: e.processingTime! - e.eventTime\n      }))\n      .sort((a, b) => b.lateness - a.lateness);\n  }\n\n  getWatermark(): number {\n    return this.watermark;\n  }\n\n  getEventCount(): number {\n    return this.events.length;\n  }\n}",
    "testCases": [
      {
        "input": "Process events with varying event times",
        "expectedOutput": "Events accepted and tracked",
        "isHidden": false,
        "description": "Should track event time vs processing time"
      },
      {
        "input": "Events arrive late but within allowed lateness",
        "expectedOutput": "Events accepted",
        "isHidden": false,
        "description": "Should handle late events within bounds"
      },
      {
        "input": "Events arrive too late",
        "expectedOutput": "Events rejected",
        "isHidden": false,
        "description": "Should reject events beyond allowed lateness"
      }
    ],
    "hints": [
      "Event time is when event occurred",
      "Processing time is when event was processed",
      "Watermark tracks event time progress",
      "Allow late events within configured lateness bound"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Logical Clock Comparison Utility",
    "difficulty": 2,
    "description": "Create a utility library for comparing and manipulating different types of logical clocks.",
    "starterCode": "type LamportTimestamp = number;\ntype VectorTimestamp = Map<string, number>;\ntype HLCTimestamp = { physical: number; logical: number };\n\nclass LogicalClockUtils {\n  // Implement clock utilities\n}",
    "solution": "type LamportTimestamp = number;\ntype VectorTimestamp = Map<string, number>;\ntype HLCTimestamp = { physical: number; logical: number };\n\nclass LogicalClockUtils {\n  // Lamport Clock utilities\n  static compareLamport(a: LamportTimestamp, b: LamportTimestamp): number {\n    return a - b;\n  }\n\n  static lamportHappensBefore(a: LamportTimestamp, b: LamportTimestamp): boolean {\n    return a < b;\n  }\n\n  // Vector Clock utilities\n  static compareVector(\n    a: VectorTimestamp,\n    b: VectorTimestamp,\n    processes: string[]\n  ): 'less' | 'greater' | 'equal' | 'concurrent' {\n    let hasLess = false;\n    let hasGreater = false;\n\n    processes.forEach(pid => {\n      const aVal = a.get(pid) || 0;\n      const bVal = b.get(pid) || 0;\n\n      if (aVal < bVal) hasLess = true;\n      if (aVal > bVal) hasGreater = true;\n    });\n\n    if (!hasLess && !hasGreater) return 'equal';\n    if (hasLess && !hasGreater) return 'less';\n    if (!hasLess && hasGreater) return 'greater';\n    return 'concurrent';\n  }\n\n  static vectorHappensBefore(\n    a: VectorTimestamp,\n    b: VectorTimestamp,\n    processes: string[]\n  ): boolean {\n    return this.compareVector(a, b, processes) === 'less';\n  }\n\n  static vectorConcurrent(\n    a: VectorTimestamp,\n    b: VectorTimestamp,\n    processes: string[]\n  ): boolean {\n    return this.compareVector(a, b, processes) === 'concurrent';\n  }\n\n  static mergeVectors(\n    a: VectorTimestamp,\n    b: VectorTimestamp,\n    processes: string[]\n  ): VectorTimestamp {\n    const result = new Map<string, number>();\n\n    processes.forEach(pid => {\n      const aVal = a.get(pid) || 0;\n      const bVal = b.get(pid) || 0;\n      result.set(pid, Math.max(aVal, bVal));\n    });\n\n    return result;\n  }\n\n  // HLC utilities\n  static compareHLC(a: HLCTimestamp, b: HLCTimestamp): number {\n    if (a.physical !== b.physical) {\n      return a.physical - b.physical;\n    }\n    return a.logical - b.logical;\n  }\n\n  static hlcHappensBefore(a: HLCTimestamp, b: HLCTimestamp): boolean {\n    return this.compareHLC(a, b) < 0;\n  }\n\n  static hlcToString(timestamp: HLCTimestamp): string {\n    return `${timestamp.physical}.${timestamp.logical}`;\n  }\n\n  static hlcFromString(str: string): HLCTimestamp {\n    const [physical, logical] = str.split('.').map(Number);\n    return { physical, logical };\n  }\n\n  // Conversion utilities\n  static vectorToString(vector: VectorTimestamp): string {\n    const entries: string[] = [];\n    vector.forEach((value, key) => {\n      entries.push(`${key}:${value}`);\n    });\n    return `{${entries.join(', ')}}`;\n  }\n\n  static vectorFromString(str: string, processes: string[]): VectorTimestamp {\n    const vector = new Map<string, number>();\n\n    // Initialize with zeros\n    processes.forEach(pid => vector.set(pid, 0));\n\n    // Parse string\n    const content = str.slice(1, -1); // Remove { }\n    if (content) {\n      content.split(', ').forEach(entry => {\n        const [key, value] = entry.split(':');\n        vector.set(key, parseInt(value));\n      });\n    }\n\n    return vector;\n  }\n\n  // Utility for debugging\n  static printComparison(\n    a: any,\n    b: any,\n    type: 'lamport' | 'vector' | 'hlc',\n    processes?: string[]\n  ): string {\n    switch (type) {\n      case 'lamport':\n        const cmpL = this.compareLamport(a, b);\n        return `Lamport: ${a} ${cmpL < 0 ? '<' : cmpL > 0 ? '>' : '='} ${b}`;\n\n      case 'vector':\n        const cmpV = this.compareVector(a, b, processes!);\n        return `Vector: ${this.vectorToString(a)} ${cmpV} ${this.vectorToString(b)}`;\n\n      case 'hlc':\n        const cmpH = this.compareHLC(a, b);\n        return `HLC: ${this.hlcToString(a)} ${cmpH < 0 ? '<' : cmpH > 0 ? '>' : '='} ${this.hlcToString(b)}`;\n\n      default:\n        return 'Unknown type';\n    }\n  }\n}",
    "testCases": [
      {
        "input": "Compare Lamport timestamps",
        "expectedOutput": "Correct ordering determined",
        "isHidden": false,
        "description": "Should compare Lamport clocks"
      },
      {
        "input": "Compare vector clocks",
        "expectedOutput": "Correct relationship (less/greater/concurrent)",
        "isHidden": false,
        "description": "Should compare vector clocks"
      },
      {
        "input": "Merge vector clocks",
        "expectedOutput": "Component-wise maximum",
        "isHidden": false,
        "description": "Should merge vector clocks"
      }
    ],
    "hints": [
      "Provide comparison methods for each clock type",
      "Support serialization/deserialization",
      "Implement merge operation for vector clocks",
      "Provide debugging/visualization utilities"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t2-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-2",
    "title": "Causal Broadcast Implementation",
    "difficulty": 4,
    "description": "Implement a causal broadcast protocol that ensures messages are delivered in causal order to all processes.",
    "starterCode": "interface CausalMessage {\n  from: string;\n  vector: Map<string, number>;\n  content: any;\n}\n\nclass CausalBroadcast {\n  // Implement causal broadcast\n}",
    "solution": "interface CausalMessage {\n  from: string;\n  vector: Map<string, number>;\n  content: any;\n  id: string;\n}\n\nclass CausalBroadcast {\n  private processId: string;\n  private vector: Map<string, number>;\n  private processes: Set<string>;\n  private pending: CausalMessage[] = [];\n  private delivered: CausalMessage[] = [];\n  private deliveryCallbacks: Array<(msg: CausalMessage) => void> = [];\n\n  constructor(processId: string, allProcesses: string[]) {\n    this.processId = processId;\n    this.processes = new Set(allProcesses);\n    this.vector = new Map();\n\n    allProcesses.forEach(pid => {\n      this.vector.set(pid, 0);\n    });\n  }\n\n  broadcast(content: any): CausalMessage {\n    // Increment own clock\n    const current = this.vector.get(this.processId) || 0;\n    this.vector.set(this.processId, current + 1);\n\n    const message: CausalMessage = {\n      id: `${this.processId}-${current + 1}`,\n      from: this.processId,\n      vector: new Map(this.vector),\n      content\n    };\n\n    // Deliver to self immediately\n    this.deliverMessage(message);\n\n    return message;\n  }\n\n  receive(message: CausalMessage): void {\n    // Add to pending\n    this.pending.push(message);\n\n    // Try to deliver pending messages\n    this.tryDeliverPending();\n  }\n\n  private tryDeliverPending(): void {\n    let delivered = true;\n\n    while (delivered) {\n      delivered = false;\n\n      for (let i = 0; i < this.pending.length; i++) {\n        const message = this.pending[i];\n\n        if (this.canDeliver(message)) {\n          // Remove from pending\n          this.pending.splice(i, 1);\n\n          // Deliver\n          this.deliverMessage(message);\n\n          delivered = true;\n          break;\n        }\n      }\n    }\n  }\n\n  private canDeliver(message: CausalMessage): boolean {\n    // Can deliver if:\n    // 1. V_msg[sender] = V_local[sender] + 1\n    // 2. V_msg[k] <= V_local[k] for all k != sender\n\n    const senderClock = message.vector.get(message.from) || 0;\n    const localSenderClock = this.vector.get(message.from) || 0;\n\n    if (senderClock !== localSenderClock + 1) {\n      return false;\n    }\n\n    for (const pid of this.processes) {\n      if (pid !== message.from) {\n        const messageClock = message.vector.get(pid) || 0;\n        const localClock = this.vector.get(pid) || 0;\n\n        if (messageClock > localClock) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private deliverMessage(message: CausalMessage): void {\n    // Update vector clock\n    message.vector.forEach((value, pid) => {\n      const current = this.vector.get(pid) || 0;\n      this.vector.set(pid, Math.max(current, value));\n    });\n\n    // Add to delivered\n    this.delivered.push(message);\n\n    // Notify callbacks\n    this.deliveryCallbacks.forEach(callback => {\n      try {\n        callback(message);\n      } catch (error) {\n        console.error('Error in delivery callback:', error);\n      }\n    });\n  }\n\n  onDeliver(callback: (msg: CausalMessage) => void): void {\n    this.deliveryCallbacks.push(callback);\n  }\n\n  getDelivered(): CausalMessage[] {\n    return [...this.delivered];\n  }\n\n  getPendingCount(): number {\n    return this.pending.length;\n  }\n\n  getVector(): Map<string, number> {\n    return new Map(this.vector);\n  }\n}",
    "testCases": [
      {
        "input": "Broadcast messages in causal order",
        "expectedOutput": "All processes deliver in same causal order",
        "isHidden": false,
        "description": "Should maintain causal order across all processes"
      },
      {
        "input": "Concurrent broadcasts",
        "expectedOutput": "All processes deliver, may be different order",
        "isHidden": false,
        "description": "Should handle concurrent broadcasts"
      }
    ],
    "hints": [
      "Use vector clocks for causality tracking",
      "Buffer messages that arrive too early",
      "Deliver when causal dependencies satisfied",
      "Support callback notification on delivery"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Two-Phase Commit Coordinator",
    "difficulty": 3,
    "description": "Implement a two-phase commit coordinator that manages distributed transactions across multiple participants.",
    "starterCode": "interface Participant {\n  id: string;\n  prepare(): Promise<boolean>;\n  commit(): Promise<void>;\n  abort(): Promise<void>;\n}\n\nclass TwoPhaseCommitCoordinator {\n  // Implement 2PC coordinator\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Phase 1: Send prepare to all participants",
      "Phase 2: Commit if all voted yes, else abort",
      "Handle participant failures",
      "Log decisions for recovery"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Raft Leader Election",
    "difficulty": 4,
    "description": "Implement the leader election mechanism from the Raft consensus algorithm.",
    "starterCode": "type ServerState = 'follower' | 'candidate' | 'leader';\n\nclass RaftNode {\n  // Implement Raft leader election\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Start as follower with election timeout",
      "Become candidate and request votes",
      "Become leader if majority votes received",
      "Reset to follower if higher term seen"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Raft Log Replication",
    "difficulty": 4,
    "description": "Implement log replication in Raft for maintaining consistent state across replicas.",
    "starterCode": "interface LogEntry {\n  term: number;\n  index: number;\n  command: any;\n}\n\nclass RaftLogReplication {\n  // Implement Raft log replication\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Leader appends to own log first",
      "Replicate to followers via AppendEntries",
      "Commit when replicated on majority",
      "Handle log inconsistencies"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Paxos Proposer",
    "difficulty": 4,
    "description": "Implement the proposer role in the Paxos consensus algorithm.",
    "starterCode": "interface Proposal {\n  proposalNumber: number;\n  value: any;\n}\n\nclass PaxosProposer {\n  // Implement Paxos proposer\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Phase 1: Prepare with proposal number",
      "Phase 2: Accept if prepare succeeds",
      "Handle promise responses",
      "Use highest value from promises"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Consensus Simulator",
    "difficulty": 3,
    "description": "Build a simulator that demonstrates how consensus algorithms handle various failure scenarios.",
    "starterCode": "class ConsensusSimulator {\n  // Implement consensus simulation\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Simulate multiple nodes",
      "Inject failures (crash, network partition)",
      "Track consensus progress",
      "Verify safety properties"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Distributed Lock Manager",
    "difficulty": 3,
    "description": "Implement a distributed lock manager using consensus for coordination.",
    "starterCode": "interface Lock {\n  id: string;\n  holder: string | null;\n  expiresAt: number;\n}\n\nclass DistributedLockManager {\n  // Implement distributed locks\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Use consensus to agree on lock holder",
      "Support lock timeouts",
      "Handle lock release",
      "Prevent deadlocks"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Quorum-Based Voting",
    "difficulty": 2,
    "description": "Implement a quorum-based voting system for decision making.",
    "starterCode": "interface Vote {\n  voter: string;\n  value: any;\n  timestamp: number;\n}\n\nclass QuorumVoting {\n  // Implement quorum voting\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Collect votes from nodes",
      "Require majority for decision",
      "Handle vote collection timeout",
      "Support vote counting"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Leader Lease Management",
    "difficulty": 3,
    "description": "Implement leader leases to optimize read operations in consensus systems.",
    "starterCode": "interface Lease {\n  holder: string;\n  expiresAt: number;\n}\n\nclass LeaderLeaseManager {\n  // Implement leader leases\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Grant leases to leader",
      "Renew before expiration",
      "Followers defer to lease holder",
      "Handle lease expiration"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Atomic Broadcast",
    "difficulty": 4,
    "description": "Implement atomic broadcast using consensus for totally ordered delivery.",
    "starterCode": "interface AtomicMessage {\n  id: string;\n  content: any;\n  sequenceNumber?: number;\n}\n\nclass AtomicBroadcast {\n  // Implement atomic broadcast\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Use consensus for ordering",
      "Assign sequence numbers",
      "Guarantee total order",
      "Handle message delivery"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Byzantine Fault Tolerant Vote",
    "difficulty": 5,
    "description": "Implement Byzantine fault tolerant voting requiring 2f+1 honest voters.",
    "starterCode": "interface ByzantineVote {\n  voter: string;\n  value: any;\n  signature: string;\n}\n\nclass ByzantineFaultTolerantVoting {\n  // Implement BFT voting\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Require 2f+1 votes",
      "Verify signatures",
      "Detect conflicting votes",
      "Handle malicious voters"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Replicated State Machine",
    "difficulty": 4,
    "description": "Implement a replicated state machine using consensus for state transitions.",
    "starterCode": "interface Command {\n  id: string;\n  operation: string;\n  params: any[];\n}\n\nclass ReplicatedStateMachine {\n  // Implement replicated state machine\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Apply commands in order",
      "Use consensus for ordering",
      "Maintain deterministic execution",
      "Support state snapshots"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Three-Phase Commit",
    "difficulty": 4,
    "description": "Implement three-phase commit to avoid blocking in two-phase commit.",
    "starterCode": "interface ThreePhaseParticipant {\n  id: string;\n  prepare(): Promise<boolean>;\n  preCommit(): Promise<boolean>;\n  commit(): Promise<void>;\n  abort(): Promise<void>;\n}\n\nclass ThreePhaseCommitCoordinator {\n  // Implement 3PC coordinator\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Add prepare-to-commit phase",
      "Handle coordinator failure",
      "Allow participants to timeout",
      "Maintain commit readiness"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Epoch-Based Synchronization",
    "difficulty": 3,
    "description": "Implement epoch-based synchronization for coordinating distributed operations.",
    "starterCode": "interface Epoch {\n  number: number;\n  leader: string;\n  members: Set<string>;\n}\n\nclass EpochManager {\n  // Implement epoch management\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Track current epoch",
      "Coordinate epoch transitions",
      "Handle leader changes",
      "Synchronize on epoch boundaries"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Multi-Paxos Implementation",
    "difficulty": 5,
    "description": "Implement Multi-Paxos for efficiently agreeing on a sequence of values.",
    "starterCode": "interface MultiPaxosInstance {\n  instanceNumber: number;\n  value: any;\n  proposalNumber: number;\n}\n\nclass MultiPaxos {\n  // Implement Multi-Paxos\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Optimize with stable leader",
      "Skip prepare phase when possible",
      "Handle multiple instances",
      "Maintain instance order"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Consensus Membership Changes",
    "difficulty": 4,
    "description": "Implement safe membership changes in a consensus group (adding/removing nodes).",
    "starterCode": "interface MembershipChange {\n  type: 'add' | 'remove';\n  nodeId: string;\n}\n\nclass ConsensusMembership {\n  // Implement membership changes\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Use joint consensus",
      "Ensure no split brain",
      "Commit configuration changes",
      "Handle transitions safely"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t3-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-3",
    "title": "Consensus with Priority",
    "difficulty": 3,
    "description": "Implement priority-based consensus where certain nodes are preferred as leaders.",
    "starterCode": "interface PriorityNode {\n  id: string;\n  priority: number;\n}\n\nclass PriorityConsensus {\n  // Implement priority-based consensus\n}",
    "solution": "// Solution provided in exercise system",
    "testCases": [],
    "hints": [
      "Assign priorities to nodes",
      "Prefer higher priority for leader",
      "Handle priority ties",
      "Support priority updates"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Primary-Backup Replication",
    "difficulty": 3,
    "description": "Implement primary-backup replication with automatic failover when primary fails.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Handle primary failure",
      "Promote backup to primary",
      "Redirect writes to primary",
      "Sync state to new backup"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Multi-Primary Conflict Resolution",
    "difficulty": 4,
    "description": "Implement multi-primary replication with automatic conflict resolution.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Detect conflicts using version vectors",
      "Apply merge strategy",
      "Support custom resolvers"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Read Repair Implementation",
    "difficulty": 3,
    "description": "Implement read repair to fix stale replicas during read operations.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Read from multiple replicas",
      "Detect inconsistencies",
      "Repair stale replicas"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Hinted Handoff",
    "difficulty": 3,
    "description": "Implement hinted handoff for temporary write forwarding when nodes are unavailable.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Store hints when node down",
      "Replay hints when node recovers",
      "Clean up delivered hints"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Anti-Entropy with Merkle Trees",
    "difficulty": 4,
    "description": "Implement anti-entropy synchronization using Merkle trees.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Build Merkle tree over data",
      "Exchange tree hashes",
      "Sync only differing ranges"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Quorum Read/Write",
    "difficulty": 3,
    "description": "Implement quorum-based reads and writes with R+W>N.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Require R+W > N",
      "Handle partial failures",
      "Choose appropriate quorum sizes"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Last-Write-Wins Register",
    "difficulty": 2,
    "description": "Implement last-write-wins register CRDT.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track timestamps",
      "Latest timestamp wins",
      "Handle clock skew"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Multi-Value Register",
    "difficulty": 3,
    "description": "Implement multi-value register that preserves concurrent writes.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Keep all concurrent values",
      "Detect causality with version vectors",
      "Expose conflicts"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Grow-Only Counter CRDT",
    "difficulty": 2,
    "description": "Implement grow-only counter CRDT.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Increment only",
      "Per-replica counters",
      "Merge by taking max"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Positive-Negative Counter CRDT",
    "difficulty": 3,
    "description": "Implement PN-Counter that supports increment and decrement.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Separate increment/decrement counters",
      "Per-replica tracking",
      "Value is P - N"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Grow-Only Set CRDT",
    "difficulty": 2,
    "description": "Implement grow-only set CRDT.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Add only operation",
      "Set union for merge",
      "Elements never removed"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Two-Phase Set CRDT",
    "difficulty": 3,
    "description": "Implement two-phase set supporting add and remove.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Separate add and remove sets",
      "Element in if added and not removed",
      "Cannot re-add"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Observed-Remove Set CRDT",
    "difficulty": 4,
    "description": "Implement observed-remove set with proper concurrent remove handling.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Tag additions with unique IDs",
      "Remove references observed elements",
      "Concurrent add wins"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Causal Context Tracking",
    "difficulty": 4,
    "description": "Implement causal context tracking for conflict detection.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track event identifiers",
      "Maintain causal history",
      "Detect concurrent updates"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Version Vector Reconciliation",
    "difficulty": 4,
    "description": "Implement version vector-based data reconciliation.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Use version vectors per value",
      "Detect dominated versions",
      "Keep concurrent versions"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t4-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-4",
    "title": "Eventual Consistency Simulator",
    "difficulty": 3,
    "description": "Simulate eventual consistency convergence across replicas.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Simulate multiple replicas",
      "Apply updates to different replicas",
      "Show convergence process"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Failure Detector Implementation",
    "difficulty": 2,
    "description": "Implement a heartbeat-based failure detector.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Send periodic heartbeats",
      "Timeout for failure detection",
      "Track suspected nodes"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Circuit Breaker Pattern",
    "difficulty": 3,
    "description": "Implement circuit breaker with Open, Closed, Half-Open states.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track failure rate",
      "Transition between states",
      "Allow test requests in half-open"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Retry with Exponential Backoff",
    "difficulty": 2,
    "description": "Implement retry logic with exponential backoff and jitter.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Exponentially increase delay",
      "Add jitter to avoid thundering herd",
      "Limit maximum retries"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Bulkhead Pattern",
    "difficulty": 3,
    "description": "Implement bulkhead pattern to isolate resources.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Separate resource pools",
      "Limit resources per partition",
      "Prevent cascade failures"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Checkpointing System",
    "difficulty": 3,
    "description": "Implement checkpointing for process state recovery.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Periodically save state",
      "Store checkpoints durably",
      "Restore from latest checkpoint"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Message Logging for Recovery",
    "difficulty": 3,
    "description": "Implement message logging for replay-based recovery.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Log received messages",
      "Replay from checkpoint",
      "Handle deterministic replay"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Gossip-Based Failure Detection",
    "difficulty": 3,
    "description": "Implement gossip protocol for failure detection.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Exchange heartbeat info via gossip",
      "Detect failures indirectly",
      "Probabilistic guarantees"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Timeout Manager",
    "difficulty": 2,
    "description": "Implement adaptive timeout management based on historical latency.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track latency distribution",
      "Adjust timeout dynamically",
      "Use percentiles for timeout"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Graceful Degradation",
    "difficulty": 3,
    "description": "Implement graceful degradation with fallback responses.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Detect failures",
      "Return fallback responses",
      "Maintain partial functionality"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Health Check Endpoint",
    "difficulty": 2,
    "description": "Implement comprehensive health check system.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Check dependencies",
      "Report detailed status",
      "Support liveness and readiness"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Failover Manager",
    "difficulty": 4,
    "description": "Implement automatic failover with leader election.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Detect leader failure",
      "Elect new leader",
      "Redirect traffic"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Watchdog Timer",
    "difficulty": 2,
    "description": "Implement watchdog timer for detecting hung processes.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Require periodic reset",
      "Trigger action on timeout",
      "Support multiple watchdogs"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Split-Brain Prevention",
    "difficulty": 4,
    "description": "Implement split-brain prevention using quorum.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Require majority for operation",
      "Fence minority partition",
      "Use external coordination"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Chaos Engineering Simulator",
    "difficulty": 3,
    "description": "Build chaos engineering simulator to inject failures.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Inject various failure types",
      "Control failure probability",
      "Measure system resilience"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Self-Healing System",
    "difficulty": 4,
    "description": "Implement self-healing system that auto-recovers from failures.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Monitor health continuously",
      "Trigger recovery actions",
      "Learn from failures"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t5-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-5",
    "title": "Byzantine Fault Detection",
    "difficulty": 5,
    "description": "Implement Byzantine fault detection using message signatures.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Verify message signatures",
      "Detect conflicting messages",
      "Identify malicious nodes"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Consistent Hashing Ring",
    "difficulty": 3,
    "description": "Implement consistent hashing with virtual nodes.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Hash ring structure",
      "Virtual nodes for balance",
      "Minimal rebalancing on changes"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Range Partitioning",
    "difficulty": 3,
    "description": "Implement range-based data partitioning.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Define key ranges",
      "Assign ranges to partitions",
      "Support range queries"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "MapReduce Word Count",
    "difficulty": 2,
    "description": "Implement word count using MapReduce.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Map: emit (word, 1)",
      "Shuffle: group by key",
      "Reduce: sum counts"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "MapReduce Join",
    "difficulty": 4,
    "description": "Implement join operation using MapReduce.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Tag records by source",
      "Group by join key",
      "Combine in reduce"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Distributed Cache Manager",
    "difficulty": 3,
    "description": "Implement distributed cache with partitioning and replication.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Partition data across nodes",
      "Replicate for availability",
      "Invalidation strategy"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Simple Distributed File System",
    "difficulty": 4,
    "description": "Build simplified distributed file system with blocks and replication.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Split files into blocks",
      "Replicate blocks",
      "Metadata management"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Block Allocation Strategy",
    "difficulty": 3,
    "description": "Implement block allocation strategy for distributed storage.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track available space",
      "Balance load",
      "Locality awareness"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Data Locality Scheduler",
    "difficulty": 3,
    "description": "Implement scheduler that optimizes for data locality.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track data locations",
      "Schedule tasks near data",
      "Handle conflicts"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Log-Structured Merge Tree",
    "difficulty": 4,
    "description": "Implement basic LSM-tree for write-optimized storage.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "In-memory buffer",
      "Flush to sorted files",
      "Compaction strategy"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Bloom Filter for Sets",
    "difficulty": 2,
    "description": "Implement Bloom filter for membership testing.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Multiple hash functions",
      "Bit array",
      "Probabilistic membership"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Secondary Index Manager",
    "difficulty": 3,
    "description": "Implement secondary indexes for distributed key-value store.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Index updates with writes",
      "Query via index",
      "Handle consistency"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Compression Strategy",
    "difficulty": 2,
    "description": "Implement compression for stored data blocks.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Compress before storage",
      "Decompress on read",
      "Track compression ratio"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Partitioning Rebalancer",
    "difficulty": 4,
    "description": "Implement automatic partition rebalancing.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Detect imbalance",
      "Plan data movement",
      "Minimize disruption"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Stream Processing Window",
    "difficulty": 3,
    "description": "Implement tumbling and sliding windows for stream processing.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Buffer events by time",
      "Trigger window computation",
      "Handle late data"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Distributed Query Executor",
    "difficulty": 4,
    "description": "Build distributed query executor with parallel execution.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Parse query",
      "Distribute to partitions",
      "Aggregate results"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t6-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-6",
    "title": "Hot Spot Detection",
    "difficulty": 3,
    "description": "Implement hot spot detection and mitigation.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Monitor access patterns",
      "Identify hot keys/partitions",
      "Rebalance or cache"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex01",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "API Gateway Router",
    "difficulty": 3,
    "description": "Implement API Gateway with request routing and transformation.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Route by path/method",
      "Transform requests/responses",
      "Handle authentication"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex02",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Service Mesh Sidecar",
    "difficulty": 4,
    "description": "Implement sidecar proxy for service mesh.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Intercept traffic",
      "Add observability",
      "Handle retries"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex03",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Saga Orchestrator",
    "difficulty": 4,
    "description": "Implement Saga pattern with orchestration.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Coordinate transactions",
      "Execute compensations on failure",
      "Track saga state"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex04",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Saga Choreography",
    "difficulty": 4,
    "description": "Implement Saga pattern with choreography using events.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Publish events",
      "Subscribe to events",
      "Compensate on failure events"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex05",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Event Sourcing Store",
    "difficulty": 4,
    "description": "Implement event sourcing with event store and projections.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Append events",
      "Rebuild state from events",
      "Support projections"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex06",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "CQRS Implementation",
    "difficulty": 4,
    "description": "Implement CQRS separating read and write models.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Separate write model",
      "Separate read model",
      "Sync via events"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex07",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Distributed Tracing",
    "difficulty": 3,
    "description": "Implement distributed tracing with spans and trace IDs.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Generate trace IDs",
      "Create spans",
      "Propagate context"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex08",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Metrics Aggregator",
    "difficulty": 3,
    "description": "Build metrics aggregation system for distributed services.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Collect metrics",
      "Aggregate across services",
      "Support queries"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex09",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Service Discovery Agent",
    "difficulty": 3,
    "description": "Implement service discovery with health checking.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Register services",
      "Health checks",
      "Update routing"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex10",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Backpressure Handler",
    "difficulty": 3,
    "description": "Implement backpressure mechanism for flow control.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Monitor queue size",
      "Signal upstream",
      "Apply flow control"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex11",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Idempotency Key Manager",
    "difficulty": 2,
    "description": "Implement idempotency key tracking for operations.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Store operation results",
      "Return cached result for duplicates",
      "Expire old keys"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex12",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Message Queue",
    "difficulty": 3,
    "description": "Implement simple message queue with persistence.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Enqueue/dequeue operations",
      "Persist messages",
      "Acknowledge mechanism"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex13",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Dead Letter Queue",
    "difficulty": 2,
    "description": "Implement dead letter queue for failed messages.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Track retry count",
      "Move to DLQ after threshold",
      "Support replay"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex14",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Load Balancer Strategies",
    "difficulty": 3,
    "description": "Implement multiple load balancing strategies.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Round-robin",
      "Least connections",
      "Weighted distribution"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex15",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Auto-Scaling Controller",
    "difficulty": 4,
    "description": "Implement auto-scaling based on metrics.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Monitor metrics",
      "Scale up/down decisions",
      "Prevent thrashing"
    ],
    "language": "typescript"
  },
  {
    "id": "cs401-t7-ex16",
    "subjectId": "cs401",
    "topicId": "cs401-topic-7",
    "title": "Canary Deployment Manager",
    "difficulty": 3,
    "description": "Implement canary deployment with gradual rollout.",
    "starterCode": "// Starter code provided",
    "solution": "// Solution provided",
    "testCases": [],
    "hints": [
      "Route percentage to canary",
      "Monitor metrics",
      "Rollback on issues"
    ],
    "language": "typescript"
  }
]
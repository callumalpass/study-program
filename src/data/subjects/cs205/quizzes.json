[
  {
    "id": "cs205-quiz-1-1",
    "subjectId": "cs205",
    "topicId": "cs205-1",
    "title": "Relational Model Fundamentals",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "In the relational model, what is a tuple?",
        "options": [
          "A column in a table",
          "A row in a table",
          "A table name",
          "A database schema"
        ],
        "correctAnswer": 1,
        "explanation": "A tuple represents a single row in a relation (table), containing one value for each attribute."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What property must a primary key satisfy?",
        "options": [
          "It can contain NULL values",
          "It must be unique and not null",
          "It must be an integer",
          "It can have duplicate values"
        ],
        "correctAnswer": 1,
        "explanation": "A primary key must uniquely identify each row and cannot contain NULL values."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A relation can have multiple candidate keys.",
        "correctAnswer": true,
        "explanation": "A relation can have multiple candidate keys (minimal superkeys), but only one is chosen as the primary key."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What does referential integrity ensure?",
        "options": [
          "All columns have unique names",
          "Foreign key values exist in the referenced table",
          "All rows have primary keys",
          "Tables have at least one column"
        ],
        "correctAnswer": 1,
        "explanation": "Referential integrity ensures that foreign key values either match a primary key in the referenced table or are NULL."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The number of attributes in a relation is called its ______.",
        "correctAnswer": "degree",
        "explanation": "Degree is the number of attributes (columns), while cardinality is the number of tuples (rows)."
      }
    ]
  },
  {
    "id": "cs205-quiz-1-2",
    "subjectId": "cs205",
    "topicId": "cs205-1",
    "title": "ER Diagrams",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "In an ER diagram, what shape represents an entity?",
        "options": [
          "Diamond",
          "Rectangle",
          "Oval",
          "Triangle"
        ],
        "correctAnswer": 1,
        "explanation": "Entities are represented by rectangles, relationships by diamonds, and attributes by ovals."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "A weak entity depends on:",
        "options": [
          "Its own attributes only",
          "A strong entity for its identification",
          "The database schema",
          "Foreign keys only"
        ],
        "correctAnswer": 1,
        "explanation": "A weak entity cannot be uniquely identified by its own attributes and depends on a strong (owner) entity."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A multivalued attribute can hold multiple values for a single entity instance.",
        "correctAnswer": true,
        "explanation": "Multivalued attributes (like phone numbers) can have multiple values per entity, unlike single-valued attributes."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "In a many-to-many relationship between Students and Courses, what happens during mapping?",
        "options": [
          "Add StudentID to Courses table",
          "Add CourseID to Students table",
          "Create a new junction table",
          "Merge the two tables"
        ],
        "correctAnswer": 2,
        "explanation": "Many-to-many relationships require a junction (bridge) table containing foreign keys to both participating entities."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "What does total participation (double line) in an ER diagram indicate?",
        "options": [
          "The relationship is optional",
          "Every entity must participate in the relationship",
          "The relationship has no attributes",
          "The entities are weak"
        ],
        "correctAnswer": 1,
        "explanation": "Total participation means every instance of the entity must participate in at least one relationship instance."
      }
    ]
  },
  {
    "id": "cs205-quiz-1-3",
    "subjectId": "cs205",
    "topicId": "cs205-1",
    "title": "Relational Algebra",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which relational algebra operation selects rows based on a condition?",
        "options": [
          "Projection (π)",
          "Selection (σ)",
          "Join (⋈)",
          "Union (∪)"
        ],
        "correctAnswer": 1,
        "explanation": "Selection (σ) filters rows based on a predicate, while projection (π) selects columns."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What does the projection operation (π) do?",
        "options": [
          "Filters rows by condition",
          "Selects specific columns",
          "Joins two tables",
          "Removes duplicates"
        ],
        "correctAnswer": 1,
        "explanation": "Projection selects specific attributes (columns) from a relation."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "The natural join automatically matches columns with the same name.",
        "correctAnswer": true,
        "explanation": "Natural join matches all columns with identical names in both relations."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which operation returns rows in relation R but not in relation S?",
        "options": [
          "Union",
          "Intersection",
          "Difference",
          "Cartesian Product"
        ],
        "correctAnswer": 2,
        "explanation": "Set difference (R - S) returns tuples that are in R but not in S."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The Cartesian product of relations with m and n tuples produces ______ tuples.",
        "correctAnswer": "m*n",
        "explanation": "Cartesian product combines every tuple from the first relation with every tuple from the second, yielding m × n tuples."
      }
    ]
  },
  {
    "id": "cs205-quiz-2-1",
    "subjectId": "cs205",
    "topicId": "cs205-2",
    "title": "DDL and Table Creation",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which SQL command is used to create a new table?",
        "options": [
          "INSERT TABLE",
          "MAKE TABLE",
          "CREATE TABLE",
          "NEW TABLE"
        ],
        "correctAnswer": 2,
        "explanation": "CREATE TABLE is the DDL command for defining a new table structure."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What constraint ensures a column cannot contain NULL values?",
        "options": [
          "UNIQUE",
          "NOT NULL",
          "CHECK",
          "DEFAULT"
        ],
        "correctAnswer": 1,
        "explanation": "NOT NULL constraint prevents NULL values in a column."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "The ALTER TABLE command can add new columns to an existing table.",
        "correctAnswer": true,
        "explanation": "ALTER TABLE can add, modify, or drop columns and constraints."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which command removes a table and all its data permanently?",
        "options": [
          "DELETE TABLE",
          "REMOVE TABLE",
          "DROP TABLE",
          "CLEAR TABLE"
        ],
        "correctAnswer": 2,
        "explanation": "DROP TABLE removes the table structure and all data permanently."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "What does CASCADE do in a foreign key constraint?",
        "options": [
          "Prevents deletion of referenced rows",
          "Automatically deletes or updates related rows",
          "Creates a backup of deleted rows",
          "Logs all delete operations"
        ],
        "correctAnswer": 1,
        "explanation": "ON DELETE CASCADE automatically deletes child rows when the parent row is deleted."
      }
    ]
  },
  {
    "id": "cs205-quiz-2-2",
    "subjectId": "cs205",
    "topicId": "cs205-2",
    "title": "SELECT Queries",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What is the correct order of clauses in a SELECT statement?",
        "options": [
          "SELECT, WHERE, FROM, ORDER BY",
          "SELECT, FROM, WHERE, ORDER BY",
          "FROM, SELECT, WHERE, ORDER BY",
          "SELECT, FROM, ORDER BY, WHERE"
        ],
        "correctAnswer": 1,
        "explanation": "The standard order is: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY."
      },
      {
        "id": "q2",
        "type": "code_output",
        "prompt": "What does this query return?",
        "codeSnippet": "SELECT DISTINCT Department FROM Employees;",
        "options": [
          "All departments with duplicates",
          "Unique department names only",
          "Employee names by department",
          "Department count"
        ],
        "correctAnswer": 1,
        "explanation": "DISTINCT eliminates duplicate values in the result set."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "The WHERE clause can reference column aliases defined in the SELECT clause.",
        "correctAnswer": false,
        "explanation": "Column aliases in SELECT are not available in WHERE because WHERE is evaluated before SELECT."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which operator is used to match patterns in strings?",
        "options": [
          "MATCH",
          "LIKE",
          "PATTERN",
          "SIMILAR"
        ],
        "correctAnswer": 1,
        "explanation": "LIKE operator with wildcards (% and _) is used for pattern matching."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "To sort results in descending order, use ORDER BY column_name ______.",
        "correctAnswer": "DESC",
        "explanation": "DESC specifies descending order; ASC (default) specifies ascending order."
      }
    ]
  },
  {
    "id": "cs205-quiz-2-3",
    "subjectId": "cs205",
    "topicId": "cs205-2",
    "title": "Aggregation and Grouping",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which aggregate function counts non-NULL values in a column?",
        "options": [
          "COUNT(*)",
          "COUNT(column)",
          "SUM(column)",
          "TOTAL(column)"
        ],
        "correctAnswer": 1,
        "explanation": "COUNT(column) counts non-NULL values, while COUNT(*) counts all rows."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "Which clause filters groups after aggregation?",
        "options": [
          "WHERE",
          "HAVING",
          "FILTER",
          "GROUP FILTER"
        ],
        "correctAnswer": 1,
        "explanation": "HAVING filters groups after GROUP BY, while WHERE filters rows before grouping."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "All non-aggregated columns in SELECT must appear in the GROUP BY clause.",
        "correctAnswer": true,
        "explanation": "Standard SQL requires non-aggregated columns to be in GROUP BY for deterministic results."
      },
      {
        "id": "q4",
        "type": "code_output",
        "prompt": "What does this query return?",
        "codeSnippet": "SELECT Department, COUNT(*), AVG(Salary)\nFROM Employees\nGROUP BY Department\nHAVING COUNT(*) > 5;",
        "options": [
          "All departments with employee count and average salary",
          "Departments with more than 5 employees",
          "Departments with average salary over 5",
          "All employees grouped by salary"
        ],
        "correctAnswer": 1,
        "explanation": "HAVING COUNT(*) > 5 filters to only departments with more than 5 employees."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "What is the result of AVG() on an empty group?",
        "options": [
          "0",
          "NULL",
          "1",
          "Error"
        ],
        "correctAnswer": 1,
        "explanation": "Most aggregate functions return NULL for empty groups or when all values are NULL."
      }
    ]
  },
  {
    "id": "cs205-quiz-3-1",
    "subjectId": "cs205",
    "topicId": "cs205-3",
    "title": "Join Operations",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which join returns all rows from the left table and matching rows from the right?",
        "options": [
          "INNER JOIN",
          "LEFT JOIN",
          "RIGHT JOIN",
          "FULL JOIN"
        ],
        "correctAnswer": 1,
        "explanation": "LEFT JOIN (LEFT OUTER JOIN) returns all left table rows with matched right table rows or NULL."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What does CROSS JOIN produce?",
        "options": [
          "Only matching rows",
          "Cartesian product of both tables",
          "Union of both tables",
          "Intersection of tables"
        ],
        "correctAnswer": 1,
        "explanation": "CROSS JOIN produces the Cartesian product—every combination of rows from both tables."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A self-join is a join of a table with itself.",
        "correctAnswer": true,
        "explanation": "Self-joins are used to compare rows within the same table, like finding employees and their managers."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "In an INNER JOIN, what happens to rows without matches?",
        "options": [
          "They appear with NULL values",
          "They are excluded from results",
          "They cause an error",
          "They appear at the end"
        ],
        "correctAnswer": 1,
        "explanation": "INNER JOIN only returns rows that have matches in both tables."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "A join that matches rows based on columns with the same name is called a ______ join.",
        "correctAnswer": "natural",
        "explanation": "NATURAL JOIN automatically matches all columns with identical names in both tables."
      }
    ]
  },
  {
    "id": "cs205-quiz-3-2",
    "subjectId": "cs205",
    "topicId": "cs205-3",
    "title": "Subqueries",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which operator checks if a subquery returns any rows?",
        "options": [
          "IN",
          "EXISTS",
          "ANY",
          "SOME"
        ],
        "correctAnswer": 1,
        "explanation": "EXISTS returns true if the subquery returns at least one row."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What is a correlated subquery?",
        "options": [
          "A subquery that runs once",
          "A subquery that references outer query columns",
          "A subquery in the FROM clause",
          "A subquery that returns one value"
        ],
        "correctAnswer": 1,
        "explanation": "Correlated subqueries reference columns from the outer query and execute once per outer row."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A scalar subquery must return exactly one value.",
        "correctAnswer": true,
        "explanation": "Scalar subqueries return a single value and can be used where single values are expected."
      },
      {
        "id": "q4",
        "type": "code_output",
        "prompt": "What does this query find?",
        "codeSnippet": "SELECT Name FROM Employees\nWHERE Salary > (SELECT AVG(Salary) FROM Employees);",
        "options": [
          "Employees with maximum salary",
          "Employees earning above average",
          "The average salary",
          "All employee names"
        ],
        "correctAnswer": 1,
        "explanation": "The subquery calculates average salary, and the outer query finds employees earning more than that."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "Which clause allows a subquery to be treated as a table?",
        "options": [
          "WHERE",
          "SELECT",
          "FROM",
          "HAVING"
        ],
        "correctAnswer": 2,
        "explanation": "Subqueries in the FROM clause (derived tables) act as temporary tables."
      }
    ]
  },
  {
    "id": "cs205-quiz-3-3",
    "subjectId": "cs205",
    "topicId": "cs205-3",
    "title": "Window Functions",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What distinguishes window functions from GROUP BY aggregations?",
        "options": [
          "Window functions are faster",
          "Window functions keep individual rows",
          "Window functions cannot use aggregates",
          "Window functions require indexes"
        ],
        "correctAnswer": 1,
        "explanation": "Window functions compute values across rows while preserving individual rows in the output."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What does ROW_NUMBER() do?",
        "options": [
          "Counts total rows",
          "Assigns sequential numbers to rows",
          "Numbers columns",
          "Returns row data"
        ],
        "correctAnswer": 1,
        "explanation": "ROW_NUMBER() assigns a unique sequential integer to each row within a partition."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "RANK() and DENSE_RANK() produce the same results when there are no ties.",
        "correctAnswer": true,
        "explanation": "Without ties, both functions produce identical sequential numbers. They differ only in handling ties."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What does PARTITION BY do in a window function?",
        "options": [
          "Sorts the results",
          "Divides rows into groups for separate calculations",
          "Limits the number of results",
          "Joins tables"
        ],
        "correctAnswer": 1,
        "explanation": "PARTITION BY divides the result set into partitions where the window function is applied independently."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The ______() function accesses data from a previous row without a self-join.",
        "correctAnswer": "LAG",
        "explanation": "LAG() accesses previous row values; LEAD() accesses subsequent row values."
      }
    ]
  },
  {
    "id": "cs205-quiz-4-1",
    "subjectId": "cs205",
    "topicId": "cs205-4",
    "title": "Functional Dependencies",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "In the functional dependency X → Y, what does X represent?",
        "options": [
          "Dependent",
          "Determinant",
          "Key",
          "Foreign key"
        ],
        "correctAnswer": 1,
        "explanation": "X is the determinant—it uniquely determines the value of Y."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What is a trivial functional dependency?",
        "options": [
          "A dependency where X is a primary key",
          "A dependency where Y is a subset of X",
          "A dependency with composite keys",
          "A dependency without NULL values"
        ],
        "correctAnswer": 1,
        "explanation": "A trivial FD is where the dependent (Y) is a subset of the determinant (X), e.g., {A,B} → A."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "If A → B and B → C, then A → C by transitivity.",
        "correctAnswer": true,
        "explanation": "Transitivity is one of Armstrong's axioms: if A determines B and B determines C, then A determines C."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What is the closure of attribute set X?",
        "options": [
          "The minimum attributes X can have",
          "All attributes functionally determined by X",
          "The primary key containing X",
          "All attributes in the table"
        ],
        "correctAnswer": 1,
        "explanation": "The closure X⁺ includes all attributes that can be derived from X using the functional dependencies."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "A set of attributes is a superkey if its closure equals ______ attributes of the relation.",
        "correctAnswer": "all",
        "explanation": "A superkey's closure must include all attributes, ensuring it can uniquely identify any tuple."
      }
    ]
  },
  {
    "id": "cs205-quiz-4-2",
    "subjectId": "cs205",
    "topicId": "cs205-4",
    "title": "Normal Forms",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "A relation is in 1NF if:",
        "options": [
          "It has no partial dependencies",
          "All attributes contain atomic values",
          "All determinants are superkeys",
          "It has no transitive dependencies"
        ],
        "correctAnswer": 1,
        "explanation": "1NF requires atomic (indivisible) values and no repeating groups."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What violation does 2NF eliminate?",
        "options": [
          "Transitive dependencies",
          "Partial dependencies on composite keys",
          "Multi-valued dependencies",
          "Non-atomic values"
        ],
        "correctAnswer": 1,
        "explanation": "2NF eliminates partial dependencies where non-key attributes depend on part of a composite key."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A relation with a single-attribute primary key is automatically in 2NF.",
        "correctAnswer": true,
        "explanation": "Partial dependencies can only exist with composite keys, so single-attribute keys are always 2NF."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What distinguishes BCNF from 3NF?",
        "options": [
          "BCNF allows partial dependencies",
          "BCNF requires all determinants to be superkeys",
          "BCNF handles multi-valued dependencies",
          "3NF is stricter than BCNF"
        ],
        "correctAnswer": 1,
        "explanation": "BCNF requires every determinant to be a superkey, while 3NF allows exceptions for key attributes."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "Which normal form addresses multi-valued dependencies?",
        "options": [
          "2NF",
          "3NF",
          "BCNF",
          "4NF"
        ],
        "correctAnswer": 3,
        "explanation": "4NF addresses multi-valued dependencies that BCNF doesn't handle."
      }
    ]
  },
  {
    "id": "cs205-quiz-4-3",
    "subjectId": "cs205",
    "topicId": "cs205-4",
    "title": "Decomposition",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What does lossless decomposition guarantee?",
        "options": [
          "No duplicate rows",
          "Original relation can be reconstructed by join",
          "All foreign keys are preserved",
          "Faster query performance"
        ],
        "correctAnswer": 1,
        "explanation": "Lossless decomposition ensures the original data can be perfectly recovered by joining the decomposed relations."
      },
      {
        "id": "q2",
        "type": "true_false",
        "prompt": "Decomposition to BCNF may lose dependency preservation.",
        "correctAnswer": true,
        "explanation": "BCNF decomposition can sometimes make it impossible to enforce certain FDs without joining tables."
      },
      {
        "id": "q3",
        "type": "multiple_choice",
        "prompt": "Which property is sometimes sacrificed for BCNF?",
        "options": [
          "Lossless join",
          "Dependency preservation",
          "Data integrity",
          "Primary key uniqueness"
        ],
        "correctAnswer": 1,
        "explanation": "BCNF always guarantees lossless join but may sacrifice dependency preservation."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "The 3NF synthesis algorithm guarantees:",
        "options": [
          "BCNF and lossless join",
          "3NF, lossless join, and dependency preservation",
          "Only dependency preservation",
          "4NF compliance"
        ],
        "correctAnswer": 1,
        "explanation": "The 3NF synthesis algorithm produces decomposition that is lossless and dependency-preserving."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "Deliberately introducing redundancy for read performance is called ______.",
        "correctAnswer": "denormalization",
        "explanation": "Denormalization trades storage and update complexity for faster read queries."
      }
    ]
  },
  {
    "id": "cs205-quiz-5-1",
    "subjectId": "cs205",
    "topicId": "cs205-5",
    "title": "ACID Properties",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What does the \"A\" in ACID stand for?",
        "options": [
          "Availability",
          "Atomicity",
          "Accuracy",
          "Asynchronous"
        ],
        "correctAnswer": 1,
        "explanation": "Atomicity ensures transactions are all-or-nothing—either fully completed or fully rolled back."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "Which ACID property ensures a transaction transforms the database from one valid state to another?",
        "options": [
          "Atomicity",
          "Consistency",
          "Isolation",
          "Durability"
        ],
        "correctAnswer": 1,
        "explanation": "Consistency ensures all database constraints and rules are maintained after the transaction."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "Durability means committed transactions survive system failures.",
        "correctAnswer": true,
        "explanation": "Durability guarantees that once committed, transaction effects are permanent even after crashes."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Isolation ensures that:",
        "options": [
          "Transactions are permanent",
          "Concurrent transactions don't interfere with each other",
          "Transactions complete fully or not at all",
          "Databases maintain valid states"
        ],
        "correctAnswer": 1,
        "explanation": "Isolation prevents concurrent transactions from seeing each other's intermediate states."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The mechanism that records changes before writing to disk is called Write-______ Logging.",
        "correctAnswer": "Ahead",
        "explanation": "Write-Ahead Logging (WAL) ensures recoverability by logging changes before applying them."
      }
    ]
  },
  {
    "id": "cs205-quiz-5-2",
    "subjectId": "cs205",
    "topicId": "cs205-5",
    "title": "Concurrency Problems",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "A dirty read occurs when a transaction reads:",
        "options": [
          "Old committed data",
          "Data written by an uncommitted transaction",
          "Data from a different table",
          "NULL values"
        ],
        "correctAnswer": 1,
        "explanation": "Dirty read means reading uncommitted data that might be rolled back."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What is a phantom read?",
        "options": [
          "Reading non-existent data",
          "Reading deleted rows",
          "New rows appearing in repeated queries",
          "Reading corrupted data"
        ],
        "correctAnswer": 2,
        "explanation": "Phantom reads occur when new rows inserted by other transactions appear in repeated range queries."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A lost update occurs when two transactions read the same value, modify it, and write back, losing one update.",
        "correctAnswer": true,
        "explanation": "Lost updates happen when concurrent transactions overwrite each other's changes."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Non-repeatable read means:",
        "options": [
          "A query cannot be executed twice",
          "Same query returns different values within one transaction",
          "Read operations fail randomly",
          "Queries timeout frequently"
        ],
        "correctAnswer": 1,
        "explanation": "Non-repeatable reads occur when another transaction modifies data between reads in the same transaction."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "Which concurrency problem involves two transactions making disjoint updates that together violate a constraint?",
        "options": [
          "Dirty read",
          "Lost update",
          "Write skew",
          "Phantom read"
        ],
        "correctAnswer": 2,
        "explanation": "Write skew occurs when two transactions read overlapping data and make updates that together violate an invariant."
      }
    ]
  },
  {
    "id": "cs205-quiz-5-3",
    "subjectId": "cs205",
    "topicId": "cs205-5",
    "title": "Isolation Levels and Locking",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which isolation level prevents dirty reads but allows non-repeatable reads?",
        "options": [
          "READ UNCOMMITTED",
          "READ COMMITTED",
          "REPEATABLE READ",
          "SERIALIZABLE"
        ],
        "correctAnswer": 1,
        "explanation": "READ COMMITTED prevents dirty reads but allows non-repeatable and phantom reads."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "SERIALIZABLE isolation level ensures:",
        "options": [
          "Maximum concurrency",
          "Transactions appear to execute serially",
          "Only read operations",
          "No locks are used"
        ],
        "correctAnswer": 1,
        "explanation": "SERIALIZABLE provides the highest isolation—results are as if transactions ran one after another."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A deadlock occurs when two or more transactions wait for each other to release locks.",
        "correctAnswer": true,
        "explanation": "Deadlock is a circular wait condition where transactions block each other indefinitely."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which lock type allows multiple transactions to read the same data?",
        "options": [
          "Exclusive lock",
          "Shared lock",
          "Update lock",
          "Intent lock"
        ],
        "correctAnswer": 1,
        "explanation": "Shared locks (S-locks) allow concurrent reads but block writes."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The Two-Phase Locking protocol has a growing phase and a ______ phase.",
        "correctAnswer": "shrinking",
        "explanation": "In 2PL, transactions acquire locks (growing) then release locks (shrinking), never acquiring after releasing."
      }
    ]
  },
  {
    "id": "cs205-quiz-6-1",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Index Fundamentals",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of a database index?",
        "options": [
          "Reduce storage space",
          "Speed up data retrieval",
          "Enforce constraints",
          "Backup data"
        ],
        "correctAnswer": 1,
        "explanation": "Indexes speed up queries by providing quick access paths to data, avoiding full table scans."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "A clustered index determines:",
        "options": [
          "Index naming convention",
          "Physical storage order of table data",
          "Number of indexes allowed",
          "Query syntax"
        ],
        "correctAnswer": 1,
        "explanation": "Clustered indexes sort and store table rows in order based on the index key."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A table can have multiple clustered indexes.",
        "correctAnswer": false,
        "explanation": "A table can have only one clustered index since data can only be physically sorted one way."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What is the main disadvantage of having many indexes on a table?",
        "options": [
          "Slower reads",
          "Slower inserts/updates/deletes",
          "Less accurate queries",
          "Reduced security"
        ],
        "correctAnswer": 1,
        "explanation": "Each index must be maintained during write operations, adding overhead."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "An index that contains all columns needed by a query is called a ______ index.",
        "correctAnswer": "covering",
        "explanation": "Covering indexes satisfy queries entirely from the index without accessing the table."
      }
    ]
  },
  {
    "id": "cs205-quiz-6-2",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "B-Tree Structure",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Why are B-trees ideal for database indexes?",
        "options": [
          "They use minimal memory",
          "They minimize disk I/O with high fanout",
          "They are easier to implement",
          "They don't require maintenance"
        ],
        "correctAnswer": 1,
        "explanation": "B-trees have high fanout (many children per node), keeping tree height low and reducing disk reads."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "In a B+ tree, where is all data stored?",
        "options": [
          "Root node only",
          "Internal nodes",
          "Leaf nodes only",
          "All nodes equally"
        ],
        "correctAnswer": 2,
        "explanation": "B+ trees store all data pointers in leaf nodes; internal nodes contain only keys for navigation."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "B+ tree leaf nodes are linked for efficient range queries.",
        "correctAnswer": true,
        "explanation": "B+ tree leaves are linked sequentially, enabling efficient range scans without traversing internal nodes."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What operation is triggered when a B-tree node becomes full during insertion?",
        "options": [
          "Rotation",
          "Split",
          "Deletion",
          "Compression"
        ],
        "correctAnswer": 1,
        "explanation": "Node splits divide full nodes and promote the median key to the parent."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "The time complexity for searching in a B-tree with n elements is:",
        "options": [
          "O(1)",
          "O(log n)",
          "O(n)",
          "O(n log n)"
        ],
        "correctAnswer": 1,
        "explanation": "B-tree search is O(log n) due to the balanced tree structure."
      }
    ]
  },
  {
    "id": "cs205-quiz-6-3",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Index Types and Selection",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Hash indexes are best for:",
        "options": [
          "Range queries",
          "Equality comparisons only",
          "Pattern matching",
          "Sorting operations"
        ],
        "correctAnswer": 1,
        "explanation": "Hash indexes provide O(1) lookup for exact matches but cannot support range queries."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "A composite index on (A, B, C) can efficiently support which query?",
        "options": [
          "WHERE B = 1",
          "WHERE A = 1 AND C = 3",
          "WHERE A = 1 AND B = 2",
          "WHERE C = 3"
        ],
        "correctAnswer": 2,
        "explanation": "Composite indexes follow leftmost prefix—queries must use leading columns (A, then B, then C)."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A partial index indexes only a subset of rows based on a condition.",
        "correctAnswer": true,
        "explanation": "Partial indexes are smaller and more efficient when queries frequently filter on specific conditions."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which index type would you choose for full-text search?",
        "options": [
          "B-tree",
          "Hash",
          "GIN/Full-text",
          "Bitmap"
        ],
        "correctAnswer": 2,
        "explanation": "Full-text indexes (GIN in PostgreSQL) support word-based searches with relevance ranking."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "Bitmap indexes are most effective for columns with ______ cardinality.",
        "correctAnswer": "low",
        "explanation": "Bitmap indexes work well for columns with few distinct values (like status or gender)."
      }
    ]
  },
  {
    "id": "cs205-quiz-7-1",
    "subjectId": "cs205",
    "topicId": "cs205-7",
    "title": "Query Processing",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What is the first step in query processing?",
        "options": [
          "Optimization",
          "Execution",
          "Parsing",
          "Planning"
        ],
        "correctAnswer": 2,
        "explanation": "Parsing checks syntax and converts SQL to an internal representation (parse tree)."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "The query optimizer's main goal is to:",
        "options": [
          "Guarantee correctness",
          "Choose the most efficient execution plan",
          "Parse SQL syntax",
          "Manage memory"
        ],
        "correctAnswer": 1,
        "explanation": "The optimizer evaluates different execution strategies and chooses the one with lowest estimated cost."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A hash join is typically more efficient than nested loop join for large equi-joins.",
        "correctAnswer": true,
        "explanation": "Hash joins are O(m+n) versus O(m×n) for nested loops, better for large tables."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which join algorithm requires sorted input?",
        "options": [
          "Nested loop",
          "Hash join",
          "Merge join",
          "Cross join"
        ],
        "correctAnswer": 2,
        "explanation": "Merge join merges two sorted inputs and is efficient when data is already sorted or indexes exist."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The process of converting SQL to relational algebra is called query ______.",
        "correctAnswer": "translation",
        "explanation": "Query translation converts SQL into relational algebra expressions for optimization."
      }
    ]
  },
  {
    "id": "cs205-quiz-7-2",
    "subjectId": "cs205",
    "topicId": "cs205-7",
    "title": "Execution Plans",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What SQL command shows how a query will be executed?",
        "options": [
          "SHOW PLAN",
          "EXPLAIN",
          "ANALYZE",
          "DESCRIBE"
        ],
        "correctAnswer": 1,
        "explanation": "EXPLAIN (and EXPLAIN ANALYZE) displays the query execution plan."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "In an execution plan, what does \"Seq Scan\" indicate?",
        "options": [
          "Sequential index scan",
          "Full table scan",
          "Sorted scan",
          "Parallel scan"
        ],
        "correctAnswer": 1,
        "explanation": "Sequential scan (Seq Scan) reads all table pages—often indicates a missing index."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "A high difference between estimated and actual rows often indicates stale statistics.",
        "correctAnswer": true,
        "explanation": "Statistics help the optimizer estimate row counts; outdated statistics lead to poor plans."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Which is generally better in an execution plan?",
        "options": [
          "Table Scan on large table",
          "Index Seek on selective column",
          "Sort with disk spillover",
          "Nested Loop with large inner table"
        ],
        "correctAnswer": 1,
        "explanation": "Index Seek efficiently finds specific rows without scanning the entire table."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "\"Index Only Scan\" means:",
        "options": [
          "Only indexes were created",
          "Query was satisfied entirely from the index",
          "Only primary key was used",
          "Index was exclusively locked"
        ],
        "correctAnswer": 1,
        "explanation": "Index-only scan retrieves all needed data from the index without accessing the table."
      }
    ]
  },
  {
    "id": "cs205-quiz-7-3",
    "subjectId": "cs205",
    "topicId": "cs205-7",
    "title": "Query Optimization Techniques",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What is predicate pushdown?",
        "options": [
          "Moving ORDER BY to end",
          "Moving filters closer to data sources",
          "Pushing data to cache",
          "Delaying predicate evaluation"
        ],
        "correctAnswer": 1,
        "explanation": "Predicate pushdown applies WHERE conditions early to reduce rows processed by later operations."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "Why should functions on indexed columns be avoided in WHERE clauses?",
        "options": [
          "They are syntactically incorrect",
          "They prevent index usage",
          "They cause NULL values",
          "They are slower to compute"
        ],
        "correctAnswer": 1,
        "explanation": "Functions on columns (e.g., UPPER(name)) prevent the optimizer from using indexes on those columns."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "JOIN elimination can remove unnecessary joins when joined columns are not used.",
        "correctAnswer": true,
        "explanation": "Optimizers can eliminate joins that don't contribute to the result (if referential integrity allows)."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "Converting a correlated subquery to a join is called:",
        "options": [
          "Query folding",
          "Subquery unnesting",
          "Query expansion",
          "Join promotion"
        ],
        "correctAnswer": 1,
        "explanation": "Subquery unnesting (decorrelation) converts correlated subqueries to more efficient joins."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The UPDATE STATISTICS command refreshes table ______ used by the optimizer.",
        "correctAnswer": "statistics",
        "explanation": "Statistics about data distribution help the optimizer make accurate cardinality estimates."
      }
    ]
  }
]
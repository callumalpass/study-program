[
  {
    "id": "math301-t1-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Vector Magnitude in 2D",
    "difficulty": 1,
    "description": "Write a function that computes the magnitude (length) of a 2D vector. The magnitude of a vector [x, y] is sqrt(x^2 + y^2).",
    "starterCode": "import math\n\ndef vector_magnitude_2d(x, y):\n    \"\"\"\n    Compute the magnitude of a 2D vector.\n\n    Args:\n        x: x-component of the vector\n        y: y-component of the vector\n\n    Returns:\n        The magnitude of the vector\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef vector_magnitude_2d(x, y):\n    \"\"\"\n    Compute the magnitude of a 2D vector.\n\n    Args:\n        x: x-component of the vector\n        y: y-component of the vector\n\n    Returns:\n        The magnitude of the vector\n    \"\"\"\n    return math.sqrt(x**2 + y**2)",
    "testCases": [
      {
        "input": "3, 4",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Classic 3-4-5 triangle"
      },
      {
        "input": "1, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Unit vector along x-axis"
      },
      {
        "input": "0, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Unit vector along y-axis"
      },
      {
        "input": "5, 12",
        "expectedOutput": "13.0",
        "isHidden": true,
        "description": "5-12-13 triangle"
      },
      {
        "input": "-3, 4",
        "expectedOutput": "5.0",
        "isHidden": true,
        "description": "Negative x-component"
      }
    ],
    "hints": [
      "Use the Pythagorean theorem",
      "Use math.sqrt() for the square root",
      "Remember: magnitude = sqrt(x^2 + y^2)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Vector Magnitude in 3D",
    "difficulty": 1,
    "description": "Write a function that computes the magnitude of a 3D vector [x, y, z]. The magnitude is sqrt(x^2 + y^2 + z^2).",
    "starterCode": "import math\n\ndef vector_magnitude_3d(x, y, z):\n    \"\"\"\n    Compute the magnitude of a 3D vector.\n\n    Args:\n        x, y, z: components of the vector\n\n    Returns:\n        The magnitude of the vector\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef vector_magnitude_3d(x, y, z):\n    \"\"\"\n    Compute the magnitude of a 3D vector.\n\n    Args:\n        x, y, z: components of the vector\n\n    Returns:\n        The magnitude of the vector\n    \"\"\"\n    return math.sqrt(x**2 + y**2 + z**2)",
    "testCases": [
      {
        "input": "1, 0, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Unit vector along x-axis"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "1.732",
        "isHidden": false,
        "description": "Vector (1,1,1)"
      },
      {
        "input": "2, 3, 6",
        "expectedOutput": "7.0",
        "isHidden": false,
        "description": "Vector (2,3,6)"
      },
      {
        "input": "3, 4, 0",
        "expectedOutput": "5.0",
        "isHidden": true,
        "description": "2D vector in 3D space"
      },
      {
        "input": "1, 2, 2",
        "expectedOutput": "3.0",
        "isHidden": true,
        "description": "Vector (1,2,2)"
      }
    ],
    "hints": [
      "Extend the 2D formula to 3D",
      "magnitude = sqrt(x^2 + y^2 + z^2)",
      "Use math.sqrt() for the square root"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Dot Product of 2D Vectors",
    "difficulty": 2,
    "description": "Compute the dot product of two 2D vectors. The dot product of [x1, y1] and [x2, y2] is x1*x2 + y1*y2.",
    "starterCode": "def dot_product_2d(x1, y1, x2, y2):\n    \"\"\"\n    Compute the dot product of two 2D vectors.\n\n    Args:\n        x1, y1: components of first vector\n        x2, y2: components of second vector\n\n    Returns:\n        The dot product\n    \"\"\"\n    pass",
    "solution": "def dot_product_2d(x1, y1, x2, y2):\n    \"\"\"\n    Compute the dot product of two 2D vectors.\n\n    Args:\n        x1, y1: components of first vector\n        x2, y2: components of second vector\n\n    Returns:\n        The dot product\n    \"\"\"\n    return x1 * x2 + y1 * y2",
    "testCases": [
      {
        "input": "1, 0, 0, 1",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Perpendicular unit vectors"
      },
      {
        "input": "1, 2, 3, 4",
        "expectedOutput": "11",
        "isHidden": false,
        "description": "General vectors"
      },
      {
        "input": "2, 3, 2, 3",
        "expectedOutput": "13",
        "isHidden": false,
        "description": "Same vectors"
      },
      {
        "input": "1, 1, 1, -1",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Perpendicular vectors"
      },
      {
        "input": "3, 4, 5, 0",
        "expectedOutput": "15",
        "isHidden": true,
        "description": "Vector perpendicular to y-axis"
      }
    ],
    "hints": [
      "Multiply corresponding components and sum",
      "dot_product = x1*x2 + y1*y2",
      "The dot product is a scalar, not a vector"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Dot Product of 3D Vectors",
    "difficulty": 2,
    "description": "Compute the dot product of two 3D vectors. The dot product of [x1, y1, z1] and [x2, y2, z2] is x1*x2 + y1*y2 + z1*z2.",
    "starterCode": "def dot_product_3d(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the dot product of two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        The dot product\n    \"\"\"\n    pass",
    "solution": "def dot_product_3d(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the dot product of two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        The dot product\n    \"\"\"\n    return x1 * x2 + y1 * y2 + z1 * z2",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Perpendicular unit vectors"
      },
      {
        "input": "1, 2, 3, 4, 5, 6",
        "expectedOutput": "32",
        "isHidden": false,
        "description": "General vectors"
      },
      {
        "input": "1, 1, 1, 1, 1, 1",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "All ones"
      },
      {
        "input": "2, 3, 4, 1, 0, 0",
        "expectedOutput": "2",
        "isHidden": true,
        "description": "Second vector along x-axis"
      },
      {
        "input": "1, 2, 3, 3, 2, 1",
        "expectedOutput": "10",
        "isHidden": true,
        "description": "Symmetric vectors"
      }
    ],
    "hints": [
      "Extend the 2D dot product to 3D",
      "dot_product = x1*x2 + y1*y2 + z1*z2",
      "Sum the products of corresponding components"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Angle Between Vectors",
    "difficulty": 3,
    "description": "Compute the angle (in degrees) between two 3D vectors using the formula: cos(θ) = (u·v) / (|u||v|).",
    "starterCode": "import math\n\ndef angle_between_vectors(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the angle in degrees between two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        The angle in degrees\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef angle_between_vectors(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the angle in degrees between two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        The angle in degrees\n    \"\"\"\n    dot = x1 * x2 + y1 * y2 + z1 * z2\n    mag1 = math.sqrt(x1**2 + y1**2 + z1**2)\n    mag2 = math.sqrt(x2**2 + y2**2 + z2**2)\n    cos_theta = dot / (mag1 * mag2)\n    theta_radians = math.acos(cos_theta)\n    return math.degrees(theta_radians)",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "90.0",
        "isHidden": false,
        "description": "Perpendicular vectors"
      },
      {
        "input": "1, 0, 0, 1, 0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Same direction"
      },
      {
        "input": "1, 0, 0, -1, 0, 0",
        "expectedOutput": "180.0",
        "isHidden": false,
        "description": "Opposite direction"
      },
      {
        "input": "1, 1, 0, 1, 0, 0",
        "expectedOutput": "45.0",
        "isHidden": true,
        "description": "45 degree angle"
      },
      {
        "input": "1, 1, 1, 1, 1, 1",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Parallel vectors"
      }
    ],
    "hints": [
      "Use the dot product formula: cos(θ) = (u·v) / (|u||v|)",
      "Use math.acos() to get the angle in radians",
      "Convert radians to degrees using math.degrees()"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Cross Product of 3D Vectors",
    "difficulty": 3,
    "description": "Compute the cross product of two 3D vectors. The cross product u × v = [u2v3 - u3v2, u3v1 - u1v3, u1v2 - u2v1]. Return the result as a tuple (x, y, z).",
    "starterCode": "def cross_product(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the cross product of two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        Tuple (x, y, z) representing the cross product\n    \"\"\"\n    pass",
    "solution": "def cross_product(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the cross product of two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        Tuple (x, y, z) representing the cross product\n    \"\"\"\n    x = y1 * z2 - z1 * y2\n    y = z1 * x2 - x1 * z2\n    z = x1 * y2 - y1 * x2\n    return (x, y, z)",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "(0, 0, 1)",
        "isHidden": false,
        "description": "i × j = k"
      },
      {
        "input": "0, 1, 0, 0, 0, 1",
        "expectedOutput": "(1, 0, 0)",
        "isHidden": false,
        "description": "j × k = i"
      },
      {
        "input": "0, 0, 1, 1, 0, 0",
        "expectedOutput": "(0, 1, 0)",
        "isHidden": false,
        "description": "k × i = j"
      },
      {
        "input": "1, 2, 3, 4, 5, 6",
        "expectedOutput": "(-3, 6, -3)",
        "isHidden": true,
        "description": "General vectors"
      },
      {
        "input": "2, 3, 4, 5, 6, 7",
        "expectedOutput": "(-3, 6, -3)",
        "isHidden": true,
        "description": "Another general case"
      }
    ],
    "hints": [
      "The cross product is perpendicular to both input vectors",
      "x = y1*z2 - z1*y2",
      "y = z1*x2 - x1*z2",
      "z = x1*y2 - y1*x2"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Magnitude of Cross Product",
    "difficulty": 3,
    "description": "Compute the magnitude of the cross product of two 3D vectors. This equals |u||v|sin(θ), which is the area of the parallelogram formed by the vectors.",
    "starterCode": "import math\n\ndef cross_product_magnitude(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the magnitude of the cross product of two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        The magnitude of the cross product\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef cross_product_magnitude(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the magnitude of the cross product of two 3D vectors.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        The magnitude of the cross product\n    \"\"\"\n    # Compute cross product\n    cx = y1 * z2 - z1 * y2\n    cy = z1 * x2 - x1 * z2\n    cz = x1 * y2 - y1 * x2\n    # Return magnitude\n    return math.sqrt(cx**2 + cy**2 + cz**2)",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Unit vectors"
      },
      {
        "input": "3, 0, 0, 0, 4, 0",
        "expectedOutput": "12.0",
        "isHidden": false,
        "description": "Area = 3*4"
      },
      {
        "input": "1, 1, 0, 1, -1, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Diagonal vectors"
      },
      {
        "input": "2, 3, 4, 1, 0, 0",
        "expectedOutput": "5.0",
        "isHidden": true,
        "description": "General case"
      },
      {
        "input": "1, 2, 3, 1, 2, 3",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Parallel vectors"
      }
    ],
    "hints": [
      "First compute the cross product",
      "Then compute the magnitude of the result",
      "For parallel vectors, the cross product is zero"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Vector Projection",
    "difficulty": 3,
    "description": "Compute the scalar projection of vector u onto vector v. The scalar projection is (u·v) / |v|.",
    "starterCode": "import math\n\ndef scalar_projection(ux, uy, uz, vx, vy, vz):\n    \"\"\"\n    Compute the scalar projection of u onto v.\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n\n    Returns:\n        The scalar projection of u onto v\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef scalar_projection(ux, uy, uz, vx, vy, vz):\n    \"\"\"\n    Compute the scalar projection of u onto v.\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n\n    Returns:\n        The scalar projection of u onto v\n    \"\"\"\n    dot = ux * vx + uy * vy + uz * vz\n    mag_v = math.sqrt(vx**2 + vy**2 + vz**2)\n    return dot / mag_v",
    "testCases": [
      {
        "input": "1, 0, 0, 1, 0, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Same direction"
      },
      {
        "input": "1, 1, 0, 1, 0, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "u projected onto x-axis"
      },
      {
        "input": "3, 4, 0, 1, 0, 0",
        "expectedOutput": "3.0",
        "isHidden": false,
        "description": "x-component of u"
      },
      {
        "input": "1, 2, 3, 2, 2, 2",
        "expectedOutput": "3.464",
        "isHidden": true,
        "description": "General case"
      },
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Perpendicular vectors"
      }
    ],
    "hints": [
      "Scalar projection = (u·v) / |v|",
      "Compute the dot product first",
      "Then divide by the magnitude of v"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Vector Projection Components",
    "difficulty": 4,
    "description": "Compute the vector projection of u onto v. The vector projection is ((u·v) / |v|^2) * v. Return as a tuple (x, y, z).",
    "starterCode": "def vector_projection(ux, uy, uz, vx, vy, vz):\n    \"\"\"\n    Compute the vector projection of u onto v.\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n\n    Returns:\n        Tuple (x, y, z) representing the projection vector\n    \"\"\"\n    pass",
    "solution": "def vector_projection(ux, uy, uz, vx, vy, vz):\n    \"\"\"\n    Compute the vector projection of u onto v.\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n\n    Returns:\n        Tuple (x, y, z) representing the projection vector\n    \"\"\"\n    dot = ux * vx + uy * vy + uz * vz\n    mag_v_sq = vx**2 + vy**2 + vz**2\n    scalar = dot / mag_v_sq\n    return (scalar * vx, scalar * vy, scalar * vz)",
    "testCases": [
      {
        "input": "1, 0, 0, 1, 0, 0",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Same direction"
      },
      {
        "input": "1, 1, 0, 1, 0, 0",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Project onto x-axis"
      },
      {
        "input": "3, 4, 0, 1, 0, 0",
        "expectedOutput": "(3.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "x-component only"
      },
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "(0.0, 0.0, 0.0)",
        "isHidden": true,
        "description": "Perpendicular vectors"
      },
      {
        "input": "1, 2, 3, 1, 1, 1",
        "expectedOutput": "(2.0, 2.0, 2.0)",
        "isHidden": true,
        "description": "General case"
      }
    ],
    "hints": [
      "Vector projection = ((u·v) / |v|^2) * v",
      "Compute the scalar multiplier first",
      "Multiply each component of v by the scalar"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Unit Vector",
    "difficulty": 2,
    "description": "Compute the unit vector in the direction of a given 3D vector. A unit vector has magnitude 1 and is computed as v / |v|. Return as a tuple (x, y, z).",
    "starterCode": "import math\n\ndef unit_vector(x, y, z):\n    \"\"\"\n    Compute the unit vector in the direction of the given vector.\n\n    Args:\n        x, y, z: components of the vector\n\n    Returns:\n        Tuple (x, y, z) representing the unit vector\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef unit_vector(x, y, z):\n    \"\"\"\n    Compute the unit vector in the direction of the given vector.\n\n    Args:\n        x, y, z: components of the vector\n\n    Returns:\n        Tuple (x, y, z) representing the unit vector\n    \"\"\"\n    mag = math.sqrt(x**2 + y**2 + z**2)\n    return (x / mag, y / mag, z / mag)",
    "testCases": [
      {
        "input": "3, 0, 0",
        "expectedOutput": "(1.0, 0.0, 0.0)",
        "isHidden": false,
        "description": "Along x-axis"
      },
      {
        "input": "0, 5, 0",
        "expectedOutput": "(0.0, 1.0, 0.0)",
        "isHidden": false,
        "description": "Along y-axis"
      },
      {
        "input": "3, 4, 0",
        "expectedOutput": "(0.6, 0.8, 0.0)",
        "isHidden": false,
        "description": "3-4-5 triangle"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "(0.577, 0.577, 0.577)",
        "isHidden": true,
        "description": "All equal components"
      },
      {
        "input": "2, 3, 6",
        "expectedOutput": "(0.286, 0.429, 0.857)",
        "isHidden": true,
        "description": "General case"
      }
    ],
    "hints": [
      "Divide each component by the magnitude",
      "unit_vector = v / |v|",
      "The result should have magnitude 1"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Distance Between Points",
    "difficulty": 2,
    "description": "Compute the distance between two points in 3D space. The distance is the magnitude of the vector from point 1 to point 2.",
    "starterCode": "import math\n\ndef distance_3d(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the distance between two points in 3D space.\n\n    Args:\n        x1, y1, z1: coordinates of first point\n        x2, y2, z2: coordinates of second point\n\n    Returns:\n        The distance between the points\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef distance_3d(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Compute the distance between two points in 3D space.\n\n    Args:\n        x1, y1, z1: coordinates of first point\n        x2, y2, z2: coordinates of second point\n\n    Returns:\n        The distance between the points\n    \"\"\"\n    dx = x2 - x1\n    dy = y2 - y1\n    dz = z2 - z1\n    return math.sqrt(dx**2 + dy**2 + dz**2)",
    "testCases": [
      {
        "input": "0, 0, 0, 1, 0, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Distance 1 along x-axis"
      },
      {
        "input": "0, 0, 0, 3, 4, 0",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "3-4-5 triangle"
      },
      {
        "input": "1, 1, 1, 2, 2, 2",
        "expectedOutput": "1.732",
        "isHidden": false,
        "description": "Diagonal distance"
      },
      {
        "input": "0, 0, 0, 2, 3, 6",
        "expectedOutput": "7.0",
        "isHidden": true,
        "description": "General case"
      },
      {
        "input": "1, 2, 3, 4, 6, 3",
        "expectedOutput": "5.0",
        "isHidden": true,
        "description": "Another case"
      }
    ],
    "hints": [
      "Create a vector from point 1 to point 2",
      "The distance is the magnitude of that vector",
      "distance = sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Triple Scalar Product",
    "difficulty": 4,
    "description": "Compute the triple scalar product u · (v × w) of three 3D vectors. This gives the volume of the parallelepiped formed by the three vectors.",
    "starterCode": "def triple_scalar_product(ux, uy, uz, vx, vy, vz, wx, wy, wz):\n    \"\"\"\n    Compute the triple scalar product u · (v × w).\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n        wx, wy, wz: components of vector w\n\n    Returns:\n        The triple scalar product\n    \"\"\"\n    pass",
    "solution": "def triple_scalar_product(ux, uy, uz, vx, vy, vz, wx, wy, wz):\n    \"\"\"\n    Compute the triple scalar product u · (v × w).\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n        wx, wy, wz: components of vector w\n\n    Returns:\n        The triple scalar product\n    \"\"\"\n    # Compute v × w\n    cx = vy * wz - vz * wy\n    cy = vz * wx - vx * wz\n    cz = vx * wy - vy * wx\n    # Compute u · (v × w)\n    return ux * cx + uy * cy + uz * cz",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0, 0, 0, 1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Unit cube"
      },
      {
        "input": "2, 0, 0, 0, 2, 0, 0, 0, 2",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Cube volume 8"
      },
      {
        "input": "1, 1, 0, 1, 0, 1, 0, 1, 1",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "General case"
      },
      {
        "input": "1, 2, 3, 4, 5, 6, 7, 8, 9",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Coplanar vectors"
      },
      {
        "input": "1, 0, 0, 1, 1, 0, 1, 1, 1",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Another case"
      }
    ],
    "hints": [
      "First compute the cross product v × w",
      "Then compute the dot product of u with the result",
      "This can also be computed as a determinant"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Check Orthogonality",
    "difficulty": 2,
    "description": "Determine if two 3D vectors are orthogonal (perpendicular). Two vectors are orthogonal if their dot product is zero. Return True if orthogonal, False otherwise.",
    "starterCode": "def are_orthogonal(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Check if two vectors are orthogonal.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        True if orthogonal, False otherwise\n    \"\"\"\n    pass",
    "solution": "def are_orthogonal(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Check if two vectors are orthogonal.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        True if orthogonal, False otherwise\n    \"\"\"\n    dot = x1 * x2 + y1 * y2 + z1 * z2\n    return abs(dot) < 1e-9",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "x and y axes"
      },
      {
        "input": "1, 0, 0, 0, 0, 1",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "x and z axes"
      },
      {
        "input": "1, 1, 0, 1, -1, 0",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Diagonal vectors"
      },
      {
        "input": "1, 2, 3, 1, 2, 3",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Parallel vectors"
      },
      {
        "input": "3, 4, 0, -4, 3, 0",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Perpendicular in xy-plane"
      }
    ],
    "hints": [
      "Two vectors are orthogonal if their dot product is zero",
      "Use a small tolerance for floating point comparison",
      "Check if abs(dot_product) < epsilon"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Check Parallel Vectors",
    "difficulty": 3,
    "description": "Determine if two 3D vectors are parallel. Two vectors are parallel if one is a scalar multiple of the other. Return True if parallel, False otherwise.",
    "starterCode": "def are_parallel(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Check if two vectors are parallel.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        True if parallel, False otherwise\n    \"\"\"\n    pass",
    "solution": "def are_parallel(x1, y1, z1, x2, y2, z2):\n    \"\"\"\n    Check if two vectors are parallel.\n\n    Args:\n        x1, y1, z1: components of first vector\n        x2, y2, z2: components of second vector\n\n    Returns:\n        True if parallel, False otherwise\n    \"\"\"\n    # Compute cross product\n    cx = y1 * z2 - z1 * y2\n    cy = z1 * x2 - x1 * z2\n    cz = x1 * y2 - y1 * x2\n    # Vectors are parallel if cross product is zero\n    magnitude = (cx**2 + cy**2 + cz**2)**0.5\n    return magnitude < 1e-9",
    "testCases": [
      {
        "input": "1, 0, 0, 2, 0, 0",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Same direction"
      },
      {
        "input": "1, 2, 3, 2, 4, 6",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Scalar multiple"
      },
      {
        "input": "1, 0, 0, 0, 1, 0",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Perpendicular"
      },
      {
        "input": "3, 4, 5, -6, -8, -10",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Opposite direction"
      },
      {
        "input": "1, 2, 3, 4, 5, 6",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Not parallel"
      }
    ],
    "hints": [
      "Vectors are parallel if their cross product is zero",
      "Compute the cross product and check its magnitude",
      "Use a small tolerance for floating point comparison"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Area of Triangle",
    "difficulty": 4,
    "description": "Compute the area of a triangle given three vertices in 3D space. Use the formula: Area = 0.5 * |AB × AC| where AB and AC are vectors from vertex A to B and C.",
    "starterCode": "import math\n\ndef triangle_area(ax, ay, az, bx, by, bz, cx, cy, cz):\n    \"\"\"\n    Compute the area of a triangle given three vertices.\n\n    Args:\n        ax, ay, az: coordinates of vertex A\n        bx, by, bz: coordinates of vertex B\n        cx, cy, cz: coordinates of vertex C\n\n    Returns:\n        The area of the triangle\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef triangle_area(ax, ay, az, bx, by, bz, cx, cy, cz):\n    \"\"\"\n    Compute the area of a triangle given three vertices.\n\n    Args:\n        ax, ay, az: coordinates of vertex A\n        bx, by, bz: coordinates of vertex B\n        cx, cy, cz: coordinates of vertex C\n\n    Returns:\n        The area of the triangle\n    \"\"\"\n    # Vectors AB and AC\n    abx, aby, abz = bx - ax, by - ay, bz - az\n    acx, acy, acz = cx - ax, cy - ay, cz - az\n    # Cross product\n    cpx = aby * acz - abz * acy\n    cpy = abz * acx - abx * acz\n    cpz = abx * acy - aby * acx\n    # Area = 0.5 * magnitude of cross product\n    mag = math.sqrt(cpx**2 + cpy**2 + cpz**2)\n    return 0.5 * mag",
    "testCases": [
      {
        "input": "0, 0, 0, 1, 0, 0, 0, 1, 0",
        "expectedOutput": "0.5",
        "isHidden": false,
        "description": "Right triangle"
      },
      {
        "input": "0, 0, 0, 2, 0, 0, 0, 2, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Larger right triangle"
      },
      {
        "input": "0, 0, 0, 3, 0, 0, 0, 4, 0",
        "expectedOutput": "6.0",
        "isHidden": false,
        "description": "3-4-5 triangle"
      },
      {
        "input": "1, 1, 1, 2, 1, 1, 1, 2, 1",
        "expectedOutput": "0.5",
        "isHidden": true,
        "description": "Translated triangle"
      },
      {
        "input": "0, 0, 0, 1, 0, 0, 1, 1, 0",
        "expectedOutput": "0.5",
        "isHidden": true,
        "description": "Another right triangle"
      }
    ],
    "hints": [
      "Create vectors from vertex A to vertices B and C",
      "Compute the cross product of these vectors",
      "Area = 0.5 * |AB × AC|"
    ],
    "language": "python"
  },
  {
    "id": "math301-t1-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-1",
    "title": "Volume of Parallelepiped",
    "difficulty": 4,
    "description": "Compute the volume of a parallelepiped formed by three 3D vectors. The volume is the absolute value of the triple scalar product |u · (v × w)|.",
    "starterCode": "import math\n\ndef parallelepiped_volume(ux, uy, uz, vx, vy, vz, wx, wy, wz):\n    \"\"\"\n    Compute the volume of a parallelepiped formed by three vectors.\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n        wx, wy, wz: components of vector w\n\n    Returns:\n        The volume of the parallelepiped\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef parallelepiped_volume(ux, uy, uz, vx, vy, vz, wx, wy, wz):\n    \"\"\"\n    Compute the volume of a parallelepiped formed by three vectors.\n\n    Args:\n        ux, uy, uz: components of vector u\n        vx, vy, vz: components of vector v\n        wx, wy, wz: components of vector w\n\n    Returns:\n        The volume of the parallelepiped\n    \"\"\"\n    # Compute v × w\n    cx = vy * wz - vz * wy\n    cy = vz * wx - vx * wz\n    cz = vx * wy - vy * wx\n    # Compute u · (v × w)\n    triple_product = ux * cx + uy * cy + uz * cz\n    return abs(triple_product)",
    "testCases": [
      {
        "input": "1, 0, 0, 0, 1, 0, 0, 0, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Unit cube"
      },
      {
        "input": "2, 0, 0, 0, 2, 0, 0, 0, 2",
        "expectedOutput": "8.0",
        "isHidden": false,
        "description": "Cube with side 2"
      },
      {
        "input": "1, 0, 0, 0, 2, 0, 0, 0, 3",
        "expectedOutput": "6.0",
        "isHidden": false,
        "description": "Rectangular box"
      },
      {
        "input": "1, 1, 0, 1, 0, 1, 0, 1, 1",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "General case"
      },
      {
        "input": "3, 0, 0, 0, 4, 0, 0, 0, 5",
        "expectedOutput": "60.0",
        "isHidden": true,
        "description": "Larger box"
      }
    ],
    "hints": [
      "Use the triple scalar product formula",
      "Volume = |u · (v × w)|",
      "Take the absolute value of the result"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial Derivative with Respect to x",
    "difficulty": 1,
    "description": "Compute the partial derivative of f(x,y) = x^2 + 3xy + y^2 with respect to x at a given point. Use numerical approximation: f_x ≈ (f(x+h,y) - f(x,y)) / h with h = 0.0001.",
    "starterCode": "def partial_x_basic(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = x^2 + 3xy + y^2\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "def partial_x_basic(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = x^2 + 3xy + y^2\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_x_plus_h = (x + h)**2 + 3*(x + h)*y + y**2\n    f_x = x**2 + 3*x*y + y**2\n    return (f_x_plus_h - f_x) / h",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "2, 3",
        "expectedOutput": "13.0",
        "isHidden": false,
        "description": "Point (2,3)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "3.0",
        "isHidden": true,
        "description": "Point (0,1)"
      }
    ],
    "hints": [
      "Use the difference quotient formula",
      "f_x ≈ (f(x+h,y) - f(x,y)) / h",
      "The analytical answer is 2x + 3y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial Derivative with Respect to y",
    "difficulty": 1,
    "description": "Compute the partial derivative of f(x,y) = x^2 + 3xy + y^2 with respect to y at a given point. Use numerical approximation: f_y ≈ (f(x,y+h) - f(x,y)) / h with h = 0.0001.",
    "starterCode": "def partial_y_basic(x, y):\n    \"\"\"\n    Compute ∂f/∂y where f(x,y) = x^2 + 3xy + y^2\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂y at (x, y)\n    \"\"\"\n    pass",
    "solution": "def partial_y_basic(x, y):\n    \"\"\"\n    Compute ∂f/∂y where f(x,y) = x^2 + 3xy + y^2\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂y at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_y_plus_h = x**2 + 3*x*(y + h) + (y + h)**2\n    f_y = x**2 + 3*x*y + y**2\n    return (f_y_plus_h - f_y) / h",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "3, 2",
        "expectedOutput": "13.0",
        "isHidden": false,
        "description": "Point (3,2)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "3.0",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (0,1)"
      }
    ],
    "hints": [
      "Use the difference quotient formula",
      "f_y ≈ (f(x,y+h) - f(x,y)) / h",
      "The analytical answer is 3x + 2y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial Derivative of Exponential",
    "difficulty": 2,
    "description": "Compute ∂f/∂x where f(x,y) = e^(xy) at a given point. Use numerical differentiation with h = 0.0001.",
    "starterCode": "import math\n\ndef partial_x_exponential(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = e^(xy)\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef partial_x_exponential(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = e^(xy)\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_x_plus_h = math.exp((x + h) * y)\n    f_x = math.exp(x * y)\n    return (f_x_plus_h - f_x) / h",
    "testCases": [
      {
        "input": "0, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "At (0,1)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "2.718",
        "isHidden": false,
        "description": "At (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "1, 2",
        "expectedOutput": "14.778",
        "isHidden": true,
        "description": "At (1,2)"
      },
      {
        "input": "2, 1",
        "expectedOutput": "7.389",
        "isHidden": true,
        "description": "At (2,1)"
      }
    ],
    "hints": [
      "f(x,y) = e^(xy)",
      "Use math.exp() for the exponential function",
      "The analytical answer is y*e^(xy)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Second Partial Derivative",
    "difficulty": 3,
    "description": "Compute the second partial derivative ∂²f/∂x² where f(x,y) = x³ + x²y + xy² at a given point. Use numerical differentiation with h = 0.001.",
    "starterCode": "def second_partial_xx(x, y):\n    \"\"\"\n    Compute ∂²f/∂x² where f(x,y) = x³ + x²y + xy²\n\n    Args:\n        x, y: point at which to evaluate the second partial\n\n    Returns:\n        The second partial derivative ∂²f/∂x² at (x, y)\n    \"\"\"\n    pass",
    "solution": "def second_partial_xx(x, y):\n    \"\"\"\n    Compute ∂²f/∂x² where f(x,y) = x³ + x²y + xy²\n\n    Args:\n        x, y: point at which to evaluate the second partial\n\n    Returns:\n        The second partial derivative ∂²f/∂x² at (x, y)\n    \"\"\"\n    h = 0.001\n    f_x_plus_h = (x + h)**3 + (x + h)**2 * y + (x + h) * y**2\n    f_x = x**3 + x**2 * y + x * y**2\n    f_x_minus_h = (x - h)**3 + (x - h)**2 * y + (x - h) * y**2\n    return (f_x_plus_h - 2*f_x + f_x_minus_h) / (h**2)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "8.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "2, 1",
        "expectedOutput": "14.0",
        "isHidden": false,
        "description": "Point (2,1)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "6.0",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "3, 2",
        "expectedOutput": "22.0",
        "isHidden": true,
        "description": "Point (3,2)"
      }
    ],
    "hints": [
      "Use the centered difference formula for second derivatives",
      "f_xx ≈ (f(x+h,y) - 2f(x,y) + f(x-h,y)) / h²",
      "The analytical answer is 6x + 2y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Mixed Partial Derivative",
    "difficulty": 3,
    "description": "Compute the mixed partial derivative ∂²f/∂x∂y where f(x,y) = x²y + xy² at a given point. Use numerical differentiation with h = 0.001.",
    "starterCode": "def mixed_partial_xy(x, y):\n    \"\"\"\n    Compute ∂²f/∂x∂y where f(x,y) = x²y + xy²\n\n    Args:\n        x, y: point at which to evaluate the mixed partial\n\n    Returns:\n        The mixed partial derivative ∂²f/∂x∂y at (x, y)\n    \"\"\"\n    pass",
    "solution": "def mixed_partial_xy(x, y):\n    \"\"\"\n    Compute ∂²f/∂x∂y where f(x,y) = x²y + xy²\n\n    Args:\n        x, y: point at which to evaluate the mixed partial\n\n    Returns:\n        The mixed partial derivative ∂²f/∂x∂y at (x, y)\n    \"\"\"\n    h = 0.001\n    f_xy = (x + h)**2 * (y + h) + (x + h) * (y + h)**2\n    f_x = (x + h)**2 * y + (x + h) * y**2\n    f_y = x**2 * (y + h) + x * (y + h)**2\n    f = x**2 * y + x * y**2\n    return (f_xy - f_x - f_y + f) / (h**2)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "4.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "2, 3",
        "expectedOutput": "10.0",
        "isHidden": false,
        "description": "Point (2,3)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (0,1)"
      }
    ],
    "hints": [
      "Compute the derivative first with respect to x, then y",
      "Use the finite difference formula for mixed partials",
      "The analytical answer is 2x + 2y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Chain Rule - Single Path",
    "difficulty": 3,
    "description": "Given f(x,y) = x² + y² where x = t² and y = 2t, compute df/dt at a given t value. Use the chain rule: df/dt = (∂f/∂x)(dx/dt) + (∂f/∂y)(dy/dt).",
    "starterCode": "def chain_rule_single(t):\n    \"\"\"\n    Compute df/dt where f(x,y) = x² + y², x = t², y = 2t\n\n    Args:\n        t: parameter value\n\n    Returns:\n        df/dt at the given t\n    \"\"\"\n    pass",
    "solution": "def chain_rule_single(t):\n    \"\"\"\n    Compute df/dt where f(x,y) = x² + y², x = t², y = 2t\n\n    Args:\n        t: parameter value\n\n    Returns:\n        df/dt at the given t\n    \"\"\"\n    x = t**2\n    y = 2*t\n    # Partial derivatives of f\n    df_dx = 2*x\n    df_dy = 2*y\n    # Derivatives of x and y with respect to t\n    dx_dt = 2*t\n    dy_dt = 2\n    # Chain rule\n    return df_dx * dx_dt + df_dy * dy_dt",
    "testCases": [
      {
        "input": "1",
        "expectedOutput": "12.0",
        "isHidden": false,
        "description": "t = 1"
      },
      {
        "input": "0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "t = 0"
      },
      {
        "input": "2",
        "expectedOutput": "48.0",
        "isHidden": false,
        "description": "t = 2"
      },
      {
        "input": "3",
        "expectedOutput": "120.0",
        "isHidden": true,
        "description": "t = 3"
      },
      {
        "input": "-1",
        "expectedOutput": "4.0",
        "isHidden": true,
        "description": "t = -1"
      }
    ],
    "hints": [
      "Apply the chain rule: df/dt = (∂f/∂x)(dx/dt) + (∂f/∂y)(dy/dt)",
      "First compute x and y from t",
      "Then compute all the partial derivatives"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial of Product",
    "difficulty": 2,
    "description": "Compute ∂f/∂x where f(x,y) = x²y³ at a given point using numerical differentiation.",
    "starterCode": "def partial_x_product(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = x²y³\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "def partial_x_product(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = x²y³\n\n    Args:\n        x, y: point at which to evaluate the partial derivative\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_x_plus_h = (x + h)**2 * y**3\n    f_x = x**2 * y**3\n    return (f_x_plus_h - f_x) / h",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 2",
        "expectedOutput": "32.0",
        "isHidden": false,
        "description": "Point (2,2)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "x = 0"
      },
      {
        "input": "3, 1",
        "expectedOutput": "6.0",
        "isHidden": true,
        "description": "Point (3,1)"
      },
      {
        "input": "1, 2",
        "expectedOutput": "16.0",
        "isHidden": true,
        "description": "Point (1,2)"
      }
    ],
    "hints": [
      "Treat y as a constant when differentiating with respect to x",
      "The analytical answer is 2xy³",
      "Use numerical differentiation with small h"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial with Trigonometric Function",
    "difficulty": 2,
    "description": "Compute ∂f/∂x where f(x,y) = sin(x)cos(y) at a given point using numerical differentiation.",
    "starterCode": "import math\n\ndef partial_x_trig(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = sin(x)cos(y)\n\n    Args:\n        x, y: point at which to evaluate (in radians)\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef partial_x_trig(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = sin(x)cos(y)\n\n    Args:\n        x, y: point at which to evaluate (in radians)\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_x_plus_h = math.sin(x + h) * math.cos(y)\n    f_x = math.sin(x) * math.cos(y)\n    return (f_x_plus_h - f_x) / h",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "1.571, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "x = π/2, y = 0"
      },
      {
        "input": "0, 1.571",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "x = 0, y = π/2"
      },
      {
        "input": "0.785, 0",
        "expectedOutput": "0.707",
        "isHidden": true,
        "description": "x = π/4, y = 0"
      },
      {
        "input": "3.142, 0",
        "expectedOutput": "-1.0",
        "isHidden": true,
        "description": "x = π, y = 0"
      }
    ],
    "hints": [
      "The derivative of sin(x) is cos(x)",
      "cos(y) is treated as a constant",
      "The analytical answer is cos(x)cos(y)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial with Logarithm",
    "difficulty": 3,
    "description": "Compute ∂f/∂x where f(x,y) = ln(x² + y²) at a given point using numerical differentiation.",
    "starterCode": "import math\n\ndef partial_x_log(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = ln(x² + y²)\n\n    Args:\n        x, y: point at which to evaluate (both > 0)\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef partial_x_log(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = ln(x² + y²)\n\n    Args:\n        x, y: point at which to evaluate (both > 0)\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_x_plus_h = math.log((x + h)**2 + y**2)\n    f_x = math.log(x**2 + y**2)\n    return (f_x_plus_h - f_x) / h",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "3, 4",
        "expectedOutput": "0.24",
        "isHidden": false,
        "description": "Point (3,4)"
      },
      {
        "input": "2, 0",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Point (2,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Point (0,1)"
      }
    ],
    "hints": [
      "The derivative of ln(u) is (1/u) * du/dx",
      "Use the chain rule",
      "The analytical answer is 2x/(x² + y²)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Chain Rule - Composition",
    "difficulty": 4,
    "description": "Given f(u,v) = u² + v² where u = x + y and v = x - y, compute ∂f/∂x at a given point (x,y). Use the chain rule.",
    "starterCode": "def chain_rule_composition(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(u,v) = u² + v², u = x + y, v = x - y\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "def chain_rule_composition(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(u,v) = u² + v², u = x + y, v = x - y\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        ∂f/∂x at (x, y)\n    \"\"\"\n    u = x + y\n    v = x - y\n    # Partial derivatives of f with respect to u and v\n    df_du = 2*u\n    df_dv = 2*v\n    # Partial derivatives of u and v with respect to x\n    du_dx = 1\n    dv_dx = 1\n    # Chain rule\n    return df_du * du_dx + df_dv * dv_dx",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "4.0",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "2, 1",
        "expectedOutput": "8.0",
        "isHidden": false,
        "description": "Point (2,1)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "4.0",
        "isHidden": true,
        "description": "Point (1,1)"
      },
      {
        "input": "3, 2",
        "expectedOutput": "12.0",
        "isHidden": true,
        "description": "Point (3,2)"
      }
    ],
    "hints": [
      "Apply chain rule: ∂f/∂x = (∂f/∂u)(∂u/∂x) + (∂f/∂v)(∂v/∂x)",
      "First compute u and v from x and y",
      "Then find all necessary partial derivatives"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Laplacian Operator",
    "difficulty": 4,
    "description": "Compute the Laplacian ∇²f = ∂²f/∂x² + ∂²f/∂y² where f(x,y) = x²y + xy² at a given point using numerical differentiation.",
    "starterCode": "def laplacian(x, y):\n    \"\"\"\n    Compute the Laplacian ∇²f where f(x,y) = x²y + xy²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The Laplacian at (x, y)\n    \"\"\"\n    pass",
    "solution": "def laplacian(x, y):\n    \"\"\"\n    Compute the Laplacian ∇²f where f(x,y) = x²y + xy²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The Laplacian at (x, y)\n    \"\"\"\n    h = 0.001\n    # Function values\n    f = x**2 * y + x * y**2\n    f_xp = (x + h)**2 * y + (x + h) * y**2\n    f_xm = (x - h)**2 * y + (x - h) * y**2\n    f_yp = x**2 * (y + h) + x * (y + h)**2\n    f_ym = x**2 * (y - h) + x * (y - h)**2\n    # Second partials\n    fxx = (f_xp - 2*f + f_xm) / (h**2)\n    fyy = (f_yp - 2*f + f_ym) / (h**2)\n    return fxx + fyy",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "4.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "2, 3",
        "expectedOutput": "10.0",
        "isHidden": false,
        "description": "Point (2,3)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (0,1)"
      }
    ],
    "hints": [
      "Laplacian = ∂²f/∂x² + ∂²f/∂y²",
      "Compute each second partial separately",
      "The analytical answer is 2y + 2x"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Implicit Differentiation",
    "difficulty": 4,
    "description": "Given the implicit equation x² + y² + z² = 1, compute ∂z/∂x at a point (x,y,z). Use the formula: ∂z/∂x = -(∂F/∂x)/(∂F/∂z) where F = x² + y² + z² - 1.",
    "starterCode": "def implicit_partial_z_x(x, y, z):\n    \"\"\"\n    Compute ∂z/∂x for the sphere x² + y² + z² = 1\n\n    Args:\n        x, y, z: point on the sphere\n\n    Returns:\n        ∂z/∂x at (x, y, z)\n    \"\"\"\n    pass",
    "solution": "def implicit_partial_z_x(x, y, z):\n    \"\"\"\n    Compute ∂z/∂x for the sphere x² + y² + z² = 1\n\n    Args:\n        x, y, z: point on the sphere\n\n    Returns:\n        ∂z/∂x at (x, y, z)\n    \"\"\"\n    # F(x,y,z) = x² + y² + z² - 1\n    dF_dx = 2*x\n    dF_dz = 2*z\n    return -dF_dx / dF_dz",
    "testCases": [
      {
        "input": "0, 0, 1",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Top of sphere"
      },
      {
        "input": "0.6, 0, 0.8",
        "expectedOutput": "-0.75",
        "isHidden": false,
        "description": "Point on sphere"
      },
      {
        "input": "0, 0.6, 0.8",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Another point"
      },
      {
        "input": "0.8, 0, 0.6",
        "expectedOutput": "-1.333",
        "isHidden": true,
        "description": "Different point"
      },
      {
        "input": "0.707, 0, 0.707",
        "expectedOutput": "-1.0",
        "isHidden": true,
        "description": "45 degree angle"
      }
    ],
    "hints": [
      "Use the implicit function theorem",
      "For F(x,y,z) = 0: ∂z/∂x = -(∂F/∂x)/(∂F/∂z)",
      "F = x² + y² + z² - 1"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Partial of Quotient",
    "difficulty": 3,
    "description": "Compute ∂f/∂x where f(x,y) = x/y at a given point using numerical differentiation.",
    "starterCode": "def partial_x_quotient(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = x/y\n\n    Args:\n        x, y: point at which to evaluate (y ≠ 0)\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    pass",
    "solution": "def partial_x_quotient(x, y):\n    \"\"\"\n    Compute ∂f/∂x where f(x,y) = x/y\n\n    Args:\n        x, y: point at which to evaluate (y ≠ 0)\n\n    Returns:\n        The partial derivative ∂f/∂x at (x, y)\n    \"\"\"\n    h = 0.0001\n    f_x_plus_h = (x + h) / y\n    f_x = x / y\n    return (f_x_plus_h - f_x) / h",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Point (2,1)"
      },
      {
        "input": "1, 2",
        "expectedOutput": "0.5",
        "isHidden": false,
        "description": "Point (1,2)"
      },
      {
        "input": "3, 4",
        "expectedOutput": "0.25",
        "isHidden": true,
        "description": "Point (3,4)"
      },
      {
        "input": "5, 2",
        "expectedOutput": "0.5",
        "isHidden": true,
        "description": "Point (5,2)"
      }
    ],
    "hints": [
      "When differentiating x/y with respect to x, treat y as constant",
      "The analytical answer is 1/y",
      "Use numerical differentiation to verify"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Chain Rule - Polar Coordinates",
    "difficulty": 4,
    "description": "Given f(x,y) = x² + y² where x = r*cos(θ) and y = r*sin(θ), compute ∂f/∂r at given r and θ values.",
    "starterCode": "import math\n\ndef chain_rule_polar(r, theta):\n    \"\"\"\n    Compute ∂f/∂r where f(x,y) = x² + y², x = r*cos(θ), y = r*sin(θ)\n\n    Args:\n        r: radial coordinate\n        theta: angular coordinate (radians)\n\n    Returns:\n        ∂f/∂r at (r, θ)\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef chain_rule_polar(r, theta):\n    \"\"\"\n    Compute ∂f/∂r where f(x,y) = x² + y², x = r*cos(θ), y = r*sin(θ)\n\n    Args:\n        r: radial coordinate\n        theta: angular coordinate (radians)\n\n    Returns:\n        ∂f/∂r at (r, θ)\n    \"\"\"\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    # Partial derivatives of f\n    df_dx = 2*x\n    df_dy = 2*y\n    # Derivatives of x and y with respect to r\n    dx_dr = math.cos(theta)\n    dy_dr = math.sin(theta)\n    # Chain rule\n    return df_dx * dx_dr + df_dy * dy_dr",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "r=1, θ=0"
      },
      {
        "input": "2, 0",
        "expectedOutput": "4.0",
        "isHidden": false,
        "description": "r=2, θ=0"
      },
      {
        "input": "1, 1.571",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "r=1, θ=π/2"
      },
      {
        "input": "3, 0.785",
        "expectedOutput": "6.0",
        "isHidden": true,
        "description": "r=3, θ=π/4"
      },
      {
        "input": "5, 0",
        "expectedOutput": "10.0",
        "isHidden": true,
        "description": "r=5, θ=0"
      }
    ],
    "hints": [
      "Use chain rule: ∂f/∂r = (∂f/∂x)(∂x/∂r) + (∂f/∂y)(∂y/∂r)",
      "Note that x² + y² = r² in polar coordinates",
      "The result should be 2r"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Verify Clairaut's Theorem",
    "difficulty": 3,
    "description": "For f(x,y) = x³y² + xy³, verify Clairaut's theorem by computing both ∂²f/∂x∂y and ∂²f/∂y∂x and checking they are equal. Return True if equal (within tolerance), False otherwise.",
    "starterCode": "def verify_clairaut(x, y):\n    \"\"\"\n    Verify Clairaut's theorem for f(x,y) = x³y² + xy³\n\n    Args:\n        x, y: point at which to verify\n\n    Returns:\n        True if fxy = fyx, False otherwise\n    \"\"\"\n    pass",
    "solution": "def verify_clairaut(x, y):\n    \"\"\"\n    Verify Clairaut's theorem for f(x,y) = x³y² + xy³\n\n    Args:\n        x, y: point at which to verify\n\n    Returns:\n        True if fxy = fyx, False otherwise\n    \"\"\"\n    h = 0.001\n    # Compute fxy\n    f = x**3 * y**2 + x * y**3\n    f_xp_yp = (x + h)**3 * (y + h)**2 + (x + h) * (y + h)**3\n    f_xp = (x + h)**3 * y**2 + (x + h) * y**3\n    f_yp = x**3 * (y + h)**2 + x * (y + h)**3\n    fxy = (f_xp_yp - f_xp - f_yp + f) / (h**2)\n    # Compute fyx (same formula)\n    fyx = (f_xp_yp - f_xp - f_yp + f) / (h**2)\n    return abs(fxy - fyx) < 0.01",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 3",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Point (2,3)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "5, 5",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Point (5,5)"
      }
    ],
    "hints": [
      "Clairaut's theorem states that fxy = fyx for smooth functions",
      "Compute both mixed partials numerically",
      "Check if they are equal within a small tolerance"
    ],
    "language": "python"
  },
  {
    "id": "math301-t2-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-2",
    "title": "Total Differential",
    "difficulty": 4,
    "description": "Compute the total differential df for f(x,y) = x²y + y³ at point (x0,y0) with increments dx and dy. The total differential is df = (∂f/∂x)dx + (∂f/∂y)dy.",
    "starterCode": "def total_differential(x0, y0, dx, dy):\n    \"\"\"\n    Compute the total differential of f(x,y) = x²y + y³\n\n    Args:\n        x0, y0: point at which to evaluate\n        dx, dy: increments in x and y\n\n    Returns:\n        The total differential df\n    \"\"\"\n    pass",
    "solution": "def total_differential(x0, y0, dx, dy):\n    \"\"\"\n    Compute the total differential of f(x,y) = x²y + y³\n\n    Args:\n        x0, y0: point at which to evaluate\n        dx, dy: increments in x and y\n\n    Returns:\n        The total differential df\n    \"\"\"\n    # Partial derivatives at (x0, y0)\n    df_dx = 2*x0*y0\n    df_dy = x0**2 + 3*y0**2\n    # Total differential\n    return df_dx * dx + df_dy * dy",
    "testCases": [
      {
        "input": "1, 1, 0.1, 0.1",
        "expectedOutput": "0.6",
        "isHidden": false,
        "description": "Small increments"
      },
      {
        "input": "2, 1, 0.01, 0.01",
        "expectedOutput": "0.11",
        "isHidden": false,
        "description": "Tiny increments"
      },
      {
        "input": "1, 0, 1, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "At y=0"
      },
      {
        "input": "2, 2, 0.5, 0.5",
        "expectedOutput": "10.0",
        "isHidden": true,
        "description": "Larger increments"
      },
      {
        "input": "0, 1, 1, 0",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Only x increment"
      }
    ],
    "hints": [
      "Total differential: df = (∂f/∂x)dx + (∂f/∂y)dy",
      "First compute the partial derivatives at (x0, y0)",
      "Then multiply by the increments and sum"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Gradient Vector - Basic",
    "difficulty": 2,
    "description": "Compute the gradient vector ∇f of f(x,y) = x² + y² at a given point. The gradient is [∂f/∂x, ∂f/∂y]. Return as a tuple (gx, gy).",
    "starterCode": "def gradient_basic(x, y):\n    \"\"\"\n    Compute ∇f where f(x,y) = x² + y²\n\n    Args:\n        x, y: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy) representing the gradient vector\n    \"\"\"\n    pass",
    "solution": "def gradient_basic(x, y):\n    \"\"\"\n    Compute ∇f where f(x,y) = x² + y²\n\n    Args:\n        x, y: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy) representing the gradient vector\n    \"\"\"\n    # Gradient components\n    gx = 2*x\n    gy = 2*y\n    return (gx, gy)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "(2, 2)",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "(0, 0)",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "3, 4",
        "expectedOutput": "(6, 8)",
        "isHidden": false,
        "description": "Point (3,4)"
      },
      {
        "input": "2, 0",
        "expectedOutput": "(4, 0)",
        "isHidden": true,
        "description": "On x-axis"
      },
      {
        "input": "0, 5",
        "expectedOutput": "(0, 10)",
        "isHidden": true,
        "description": "On y-axis"
      }
    ],
    "hints": [
      "The gradient is the vector of partial derivatives",
      "∇f = [∂f/∂x, ∂f/∂y]",
      "For f = x² + y²: ∂f/∂x = 2x, ∂f/∂y = 2y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Gradient Magnitude",
    "difficulty": 2,
    "description": "Compute the magnitude of the gradient vector |∇f| where f(x,y) = x² + 2xy + y² at a given point.",
    "starterCode": "import math\n\ndef gradient_magnitude(x, y):\n    \"\"\"\n    Compute |∇f| where f(x,y) = x² + 2xy + y²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The magnitude of the gradient\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef gradient_magnitude(x, y):\n    \"\"\"\n    Compute |∇f| where f(x,y) = x² + 2xy + y²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The magnitude of the gradient\n    \"\"\"\n    # Gradient components\n    gx = 2*x + 2*y\n    gy = 2*x + 2*y\n    # Magnitude\n    return math.sqrt(gx**2 + gy**2)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "5.657",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "1, 0",
        "expectedOutput": "2.828",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "2, 1",
        "expectedOutput": "8.485",
        "isHidden": true,
        "description": "Point (2,1)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "2.828",
        "isHidden": true,
        "description": "Point (0,1)"
      }
    ],
    "hints": [
      "First compute the gradient components",
      "Then find the magnitude: |∇f| = sqrt(gx² + gy²)",
      "∂f/∂x = 2x + 2y, ∂f/∂y = 2x + 2y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Directional Derivative",
    "difficulty": 3,
    "description": "Compute the directional derivative of f(x,y) = x² + y² at point (x,y) in the direction of unit vector (ux, uy). Use D_u f = ∇f · u.",
    "starterCode": "def directional_derivative(x, y, ux, uy):\n    \"\"\"\n    Compute the directional derivative of f(x,y) = x² + y² in direction (ux, uy)\n\n    Args:\n        x, y: point at which to evaluate\n        ux, uy: unit direction vector\n\n    Returns:\n        The directional derivative\n    \"\"\"\n    pass",
    "solution": "def directional_derivative(x, y, ux, uy):\n    \"\"\"\n    Compute the directional derivative of f(x,y) = x² + y² in direction (ux, uy)\n\n    Args:\n        x, y: point at which to evaluate\n        ux, uy: unit direction vector\n\n    Returns:\n        The directional derivative\n    \"\"\"\n    # Gradient at (x, y)\n    gx = 2*x\n    gy = 2*y\n    # Directional derivative = gradient · direction\n    return gx * ux + gy * uy",
    "testCases": [
      {
        "input": "1, 0, 1, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Direction along x-axis"
      },
      {
        "input": "0, 1, 0, 1",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Direction along y-axis"
      },
      {
        "input": "1, 1, 0.707, 0.707",
        "expectedOutput": "2.828",
        "isHidden": false,
        "description": "Diagonal direction"
      },
      {
        "input": "2, 3, 1, 0",
        "expectedOutput": "4.0",
        "isHidden": true,
        "description": "Point (2,3), x-direction"
      },
      {
        "input": "3, 4, 0, 1",
        "expectedOutput": "8.0",
        "isHidden": true,
        "description": "Point (3,4), y-direction"
      }
    ],
    "hints": [
      "Directional derivative = ∇f · u",
      "Compute the gradient first",
      "Then take the dot product with the direction vector"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Maximum Directional Derivative",
    "difficulty": 3,
    "description": "Find the maximum rate of change (maximum directional derivative) of f(x,y) = x² + y² at a given point. The maximum is |∇f|.",
    "starterCode": "import math\n\ndef max_directional_derivative(x, y):\n    \"\"\"\n    Compute the maximum directional derivative of f(x,y) = x² + y²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The maximum directional derivative\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef max_directional_derivative(x, y):\n    \"\"\"\n    Compute the maximum directional derivative of f(x,y) = x² + y²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The maximum directional derivative\n    \"\"\"\n    # Gradient components\n    gx = 2*x\n    gy = 2*y\n    # Maximum directional derivative = |∇f|\n    return math.sqrt(gx**2 + gy**2)",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "3, 4",
        "expectedOutput": "10.0",
        "isHidden": false,
        "description": "Point (3,4)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "2.828",
        "isHidden": true,
        "description": "Point (1,1)"
      },
      {
        "input": "5, 12",
        "expectedOutput": "26.0",
        "isHidden": true,
        "description": "Point (5,12)"
      }
    ],
    "hints": [
      "The maximum directional derivative occurs in the direction of the gradient",
      "Its value is the magnitude of the gradient",
      "max(D_u f) = |∇f|"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Direction of Steepest Ascent",
    "difficulty": 3,
    "description": "Find the unit vector in the direction of steepest ascent for f(x,y) = x²y at a given point. This is the normalized gradient. Return as tuple (ux, uy).",
    "starterCode": "import math\n\ndef steepest_ascent_direction(x, y):\n    \"\"\"\n    Find the unit vector in the direction of steepest ascent for f(x,y) = x²y\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        Tuple (ux, uy) representing the unit direction vector\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef steepest_ascent_direction(x, y):\n    \"\"\"\n    Find the unit vector in the direction of steepest ascent for f(x,y) = x²y\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        Tuple (ux, uy) representing the unit direction vector\n    \"\"\"\n    # Gradient components\n    gx = 2*x*y\n    gy = x**2\n    # Magnitude\n    mag = math.sqrt(gx**2 + gy**2)\n    if mag == 0:\n        return (0.0, 0.0)\n    # Unit vector\n    return (gx / mag, gy / mag)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "(0.894, 0.447)",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 1",
        "expectedOutput": "(0.894, 0.447)",
        "isHidden": false,
        "description": "Point (2,1)"
      },
      {
        "input": "1, 2",
        "expectedOutput": "(0.970, 0.243)",
        "isHidden": false,
        "description": "Point (1,2)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "(0.0, 0.0)",
        "isHidden": true,
        "description": "Zero gradient"
      },
      {
        "input": "3, 1",
        "expectedOutput": "(0.894, 0.447)",
        "isHidden": true,
        "description": "Point (3,1)"
      }
    ],
    "hints": [
      "The direction of steepest ascent is the gradient direction",
      "Normalize the gradient to get a unit vector",
      "unit_vector = ∇f / |∇f|"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Tangent Plane Equation - Z coefficient",
    "difficulty": 3,
    "description": "For the surface z = x² + y², find the z-intercept of the tangent plane at point (x0, y0, z0). The tangent plane is z - z0 = fx(x0,y0)(x - x0) + fy(x0,y0)(y - y0). Return the value of z when x=0 and y=0.",
    "starterCode": "def tangent_plane_z_intercept(x0, y0):\n    \"\"\"\n    Find the z-intercept of the tangent plane to z = x² + y² at (x0, y0, z0)\n\n    Args:\n        x0, y0: point of tangency\n\n    Returns:\n        The z-intercept of the tangent plane\n    \"\"\"\n    pass",
    "solution": "def tangent_plane_z_intercept(x0, y0):\n    \"\"\"\n    Find the z-intercept of the tangent plane to z = x² + y² at (x0, y0, z0)\n\n    Args:\n        x0, y0: point of tangency\n\n    Returns:\n        The z-intercept of the tangent plane\n    \"\"\"\n    z0 = x0**2 + y0**2\n    fx = 2*x0\n    fy = 2*y0\n    # Tangent plane: z = z0 + fx(x - x0) + fy(y - y0)\n    # At x=0, y=0: z = z0 - fx*x0 - fy*y0\n    return z0 - fx*x0 - fy*y0",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "-1.0",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "-1.0",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "-2.0",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 0",
        "expectedOutput": "-4.0",
        "isHidden": true,
        "description": "Point (2,0)"
      },
      {
        "input": "1, 2",
        "expectedOutput": "-5.0",
        "isHidden": true,
        "description": "Point (1,2)"
      }
    ],
    "hints": [
      "Tangent plane equation: z = z0 + fx(x - x0) + fy(y - y0)",
      "Substitute x=0, y=0 to find z-intercept",
      "z0 = x0² + y0², fx = 2x0, fy = 2y0"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Linear Approximation",
    "difficulty": 3,
    "description": "Use the linear approximation (tangent plane) to estimate f(x,y) = x² + y² at point (x,y) given the base point (x0,y0). L(x,y) = f(x0,y0) + fx(x0,y0)(x-x0) + fy(x0,y0)(y-y0).",
    "starterCode": "def linear_approximation(x0, y0, x, y):\n    \"\"\"\n    Compute the linear approximation of f(x,y) = x² + y² at (x,y) using base point (x0,y0)\n\n    Args:\n        x0, y0: base point for approximation\n        x, y: point at which to approximate\n\n    Returns:\n        The linear approximation L(x,y)\n    \"\"\"\n    pass",
    "solution": "def linear_approximation(x0, y0, x, y):\n    \"\"\"\n    Compute the linear approximation of f(x,y) = x² + y² at (x,y) using base point (x0,y0)\n\n    Args:\n        x0, y0: base point for approximation\n        x, y: point at which to approximate\n\n    Returns:\n        The linear approximation L(x,y)\n    \"\"\"\n    f0 = x0**2 + y0**2\n    fx = 2*x0\n    fy = 2*y0\n    return f0 + fx*(x - x0) + fy*(y - y0)",
    "testCases": [
      {
        "input": "1, 1, 1.1, 1.1",
        "expectedOutput": "2.4",
        "isHidden": false,
        "description": "Near (1,1)"
      },
      {
        "input": "2, 0, 2.1, 0",
        "expectedOutput": "4.4",
        "isHidden": false,
        "description": "Near (2,0)"
      },
      {
        "input": "0, 3, 0, 3.1",
        "expectedOutput": "9.6",
        "isHidden": false,
        "description": "Near (0,3)"
      },
      {
        "input": "1, 0, 1.5, 0",
        "expectedOutput": "3.0",
        "isHidden": true,
        "description": "Larger step from (1,0)"
      },
      {
        "input": "0, 0, 0.1, 0.1",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "From origin"
      }
    ],
    "hints": [
      "Linear approximation uses the tangent plane",
      "L(x,y) = f(x0,y0) + fx(x-x0) + fy(y-y0)",
      "This is the first-order Taylor approximation"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Gradient of Three Variables",
    "difficulty": 2,
    "description": "Compute the gradient vector ∇f of f(x,y,z) = x² + y² + z² at a given point. Return as tuple (gx, gy, gz).",
    "starterCode": "def gradient_3d(x, y, z):\n    \"\"\"\n    Compute ∇f where f(x,y,z) = x² + y² + z²\n\n    Args:\n        x, y, z: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy, gz) representing the gradient vector\n    \"\"\"\n    pass",
    "solution": "def gradient_3d(x, y, z):\n    \"\"\"\n    Compute ∇f where f(x,y,z) = x² + y² + z²\n\n    Args:\n        x, y, z: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy, gz) representing the gradient vector\n    \"\"\"\n    gx = 2*x\n    gy = 2*y\n    gz = 2*z\n    return (gx, gy, gz)",
    "testCases": [
      {
        "input": "1, 0, 0",
        "expectedOutput": "(2, 0, 0)",
        "isHidden": false,
        "description": "On x-axis"
      },
      {
        "input": "1, 1, 1",
        "expectedOutput": "(2, 2, 2)",
        "isHidden": false,
        "description": "Point (1,1,1)"
      },
      {
        "input": "0, 0, 0",
        "expectedOutput": "(0, 0, 0)",
        "isHidden": false,
        "description": "Origin"
      },
      {
        "input": "3, 4, 0",
        "expectedOutput": "(6, 8, 0)",
        "isHidden": true,
        "description": "In xy-plane"
      },
      {
        "input": "1, 2, 3",
        "expectedOutput": "(2, 4, 6)",
        "isHidden": true,
        "description": "General point"
      }
    ],
    "hints": [
      "Extend the 2D gradient to 3D",
      "∇f = [∂f/∂x, ∂f/∂y, ∂f/∂z]",
      "For f = x² + y² + z²: each partial is 2 times that variable"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Gradient Perpendicular to Level Curve",
    "difficulty": 4,
    "description": "For f(x,y) = x² + y², verify that the gradient at a point is perpendicular to the level curve through that point. Given a point (x,y) and a tangent vector (tx,ty) to the level curve, compute ∇f · (tx,ty). It should be zero.",
    "starterCode": "def gradient_level_curve_dot(x, y, tx, ty):\n    \"\"\"\n    Compute ∇f · tangent_vector where f(x,y) = x² + y²\n\n    Args:\n        x, y: point on level curve\n        tx, ty: tangent vector to level curve\n\n    Returns:\n        The dot product (should be 0 for valid tangent)\n    \"\"\"\n    pass",
    "solution": "def gradient_level_curve_dot(x, y, tx, ty):\n    \"\"\"\n    Compute ∇f · tangent_vector where f(x,y) = x² + y²\n\n    Args:\n        x, y: point on level curve\n        tx, ty: tangent vector to level curve\n\n    Returns:\n        The dot product (should be 0 for valid tangent)\n    \"\"\"\n    # Gradient at (x, y)\n    gx = 2*x\n    gy = 2*y\n    # Dot product with tangent vector\n    return gx * tx + gy * ty",
    "testCases": [
      {
        "input": "1, 0, 0, 1",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Perpendicular vectors"
      },
      {
        "input": "0, 1, 1, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Also perpendicular"
      },
      {
        "input": "1, 1, -1, 1",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Valid tangent at (1,1)"
      },
      {
        "input": "3, 4, -4, 3",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Valid tangent at (3,4)"
      },
      {
        "input": "2, 0, 0, 5",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Tangent along y-direction"
      }
    ],
    "hints": [
      "The gradient is perpendicular to level curves",
      "If the tangent is valid, ∇f · tangent = 0",
      "For a circle, the tangent at (x,y) is perpendicular to the radius"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Normal Vector to Surface",
    "difficulty": 3,
    "description": "Find the normal vector to the surface z = x² + y² at point (x0, y0). Represent the surface as F(x,y,z) = x² + y² - z = 0. The normal is ∇F. Return as tuple (nx, ny, nz).",
    "starterCode": "def normal_to_surface(x0, y0):\n    \"\"\"\n    Find the normal vector to z = x² + y² at (x0, y0)\n\n    Args:\n        x0, y0: point on the surface\n\n    Returns:\n        Tuple (nx, ny, nz) representing the normal vector\n    \"\"\"\n    pass",
    "solution": "def normal_to_surface(x0, y0):\n    \"\"\"\n    Find the normal vector to z = x² + y² at (x0, y0)\n\n    Args:\n        x0, y0: point on the surface\n\n    Returns:\n        Tuple (nx, ny, nz) representing the normal vector\n    \"\"\"\n    # F(x,y,z) = x² + y² - z\n    # ∇F = [∂F/∂x, ∂F/∂y, ∂F/∂z]\n    nx = 2*x0\n    ny = 2*y0\n    nz = -1\n    return (nx, ny, nz)",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "(0, 0, -1)",
        "isHidden": false,
        "description": "At origin"
      },
      {
        "input": "1, 0",
        "expectedOutput": "(2, 0, -1)",
        "isHidden": false,
        "description": "At (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "(0, 2, -1)",
        "isHidden": false,
        "description": "At (0,1)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "(2, 2, -1)",
        "isHidden": true,
        "description": "At (1,1)"
      },
      {
        "input": "3, 4",
        "expectedOutput": "(6, 8, -1)",
        "isHidden": true,
        "description": "At (3,4)"
      }
    ],
    "hints": [
      "Rewrite the surface as F(x,y,z) = x² + y² - z = 0",
      "The normal vector is ∇F",
      "∇F = [2x, 2y, -1]"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Directional Derivative in 3D",
    "difficulty": 3,
    "description": "Compute the directional derivative of f(x,y,z) = x² + y² + z² at point (x,y,z) in the direction of unit vector (ux, uy, uz).",
    "starterCode": "def directional_derivative_3d(x, y, z, ux, uy, uz):\n    \"\"\"\n    Compute D_u f where f(x,y,z) = x² + y² + z²\n\n    Args:\n        x, y, z: point at which to evaluate\n        ux, uy, uz: unit direction vector\n\n    Returns:\n        The directional derivative\n    \"\"\"\n    pass",
    "solution": "def directional_derivative_3d(x, y, z, ux, uy, uz):\n    \"\"\"\n    Compute D_u f where f(x,y,z) = x² + y² + z²\n\n    Args:\n        x, y, z: point at which to evaluate\n        ux, uy, uz: unit direction vector\n\n    Returns:\n        The directional derivative\n    \"\"\"\n    # Gradient at (x, y, z)\n    gx = 2*x\n    gy = 2*y\n    gz = 2*z\n    # Directional derivative = gradient · direction\n    return gx * ux + gy * uy + gz * uz",
    "testCases": [
      {
        "input": "1, 0, 0, 1, 0, 0",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "Along x-axis"
      },
      {
        "input": "1, 1, 1, 0.577, 0.577, 0.577",
        "expectedOutput": "3.464",
        "isHidden": false,
        "description": "Diagonal direction"
      },
      {
        "input": "2, 3, 0, 1, 0, 0",
        "expectedOutput": "4.0",
        "isHidden": false,
        "description": "At (2,3,0), x-direction"
      },
      {
        "input": "1, 2, 3, 0, 1, 0",
        "expectedOutput": "4.0",
        "isHidden": true,
        "description": "Along y-axis"
      },
      {
        "input": "3, 4, 5, 0, 0, 1",
        "expectedOutput": "10.0",
        "isHidden": true,
        "description": "Along z-axis"
      }
    ],
    "hints": [
      "Use the same formula as 2D: D_u f = ∇f · u",
      "Compute the gradient in 3D first",
      "Then take dot product with direction vector"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Gradient of Product",
    "difficulty": 3,
    "description": "Compute the gradient of f(x,y) = xy² at a given point. Return as tuple (gx, gy).",
    "starterCode": "def gradient_product(x, y):\n    \"\"\"\n    Compute ∇f where f(x,y) = xy²\n\n    Args:\n        x, y: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy) representing the gradient vector\n    \"\"\"\n    pass",
    "solution": "def gradient_product(x, y):\n    \"\"\"\n    Compute ∇f where f(x,y) = xy²\n\n    Args:\n        x, y: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy) representing the gradient vector\n    \"\"\"\n    gx = y**2\n    gy = 2*x*y\n    return (gx, gy)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "(1, 2)",
        "isHidden": false,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 3",
        "expectedOutput": "(9, 12)",
        "isHidden": false,
        "description": "Point (2,3)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "(1, 0)",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "(0, 0)",
        "isHidden": true,
        "description": "Point (1,0)"
      },
      {
        "input": "3, 2",
        "expectedOutput": "(4, 12)",
        "isHidden": true,
        "description": "Point (3,2)"
      }
    ],
    "hints": [
      "Compute each partial derivative separately",
      "∂f/∂x: treat y as constant",
      "∂f/∂y: treat x as constant and use power rule"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Gradient of Exponential",
    "difficulty": 3,
    "description": "Compute the gradient of f(x,y) = e^(x+y) at a given point. Return as tuple (gx, gy).",
    "starterCode": "import math\n\ndef gradient_exponential(x, y):\n    \"\"\"\n    Compute ∇f where f(x,y) = e^(x+y)\n\n    Args:\n        x, y: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy) representing the gradient vector\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef gradient_exponential(x, y):\n    \"\"\"\n    Compute ∇f where f(x,y) = e^(x+y)\n\n    Args:\n        x, y: point at which to evaluate the gradient\n\n    Returns:\n        Tuple (gx, gy) representing the gradient vector\n    \"\"\"\n    exp_val = math.exp(x + y)\n    gx = exp_val\n    gy = exp_val\n    return (gx, gy)",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "(1.0, 1.0)",
        "isHidden": false,
        "description": "At origin"
      },
      {
        "input": "1, 0",
        "expectedOutput": "(2.718, 2.718)",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "(2.718, 2.718)",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "(7.389, 7.389)",
        "isHidden": true,
        "description": "Point (1,1)"
      },
      {
        "input": "2, 0",
        "expectedOutput": "(7.389, 7.389)",
        "isHidden": true,
        "description": "Point (2,0)"
      }
    ],
    "hints": [
      "The derivative of e^u with respect to any variable is e^u times the derivative of u",
      "Since f = e^(x+y), both partials equal e^(x+y)",
      "∇f = [e^(x+y), e^(x+y)]"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Tangent Plane at Point",
    "difficulty": 4,
    "description": "For surface z = xy, evaluate the tangent plane equation at (x0,y0) and compute z at a nearby point (x,y). The tangent plane is z = z0 + fx(x0,y0)(x-x0) + fy(x0,y0)(y-y0).",
    "starterCode": "def tangent_plane_value(x0, y0, x, y):\n    \"\"\"\n    Evaluate the tangent plane to z = xy at (x0,y0), then compute z at (x,y)\n\n    Args:\n        x0, y0: point of tangency\n        x, y: point at which to evaluate the plane\n\n    Returns:\n        The z-value on the tangent plane at (x,y)\n    \"\"\"\n    pass",
    "solution": "def tangent_plane_value(x0, y0, x, y):\n    \"\"\"\n    Evaluate the tangent plane to z = xy at (x0,y0), then compute z at (x,y)\n\n    Args:\n        x0, y0: point of tangency\n        x, y: point at which to evaluate the plane\n\n    Returns:\n        The z-value on the tangent plane at (x,y)\n    \"\"\"\n    z0 = x0 * y0\n    fx = y0\n    fy = x0\n    return z0 + fx * (x - x0) + fy * (y - y0)",
    "testCases": [
      {
        "input": "1, 1, 1.1, 1.1",
        "expectedOutput": "1.2",
        "isHidden": false,
        "description": "Near (1,1)"
      },
      {
        "input": "2, 3, 2, 3",
        "expectedOutput": "6.0",
        "isHidden": false,
        "description": "At point of tangency"
      },
      {
        "input": "1, 2, 1, 2.5",
        "expectedOutput": "2.5",
        "isHidden": false,
        "description": "Move in y-direction"
      },
      {
        "input": "3, 2, 3.5, 2",
        "expectedOutput": "7.0",
        "isHidden": true,
        "description": "Move in x-direction"
      },
      {
        "input": "0, 0, 1, 1",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Tangent at origin"
      }
    ],
    "hints": [
      "For z = xy: ∂z/∂x = y and ∂z/∂y = x",
      "Tangent plane: z = z0 + fx(x-x0) + fy(y-y0)",
      "Evaluate at the new point (x,y)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Angle Between Gradient Vectors",
    "difficulty": 4,
    "description": "For f(x,y) = x² and g(x,y) = y², compute the angle (in degrees) between ∇f and ∇g at a given point (x,y).",
    "starterCode": "import math\n\ndef angle_between_gradients(x, y):\n    \"\"\"\n    Compute the angle between ∇f and ∇g where f = x², g = y²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The angle in degrees between the gradient vectors\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef angle_between_gradients(x, y):\n    \"\"\"\n    Compute the angle between ∇f and ∇g where f = x², g = y²\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The angle in degrees between the gradient vectors\n    \"\"\"\n    # Gradient of f = x²\n    grad_f_x = 2*x\n    grad_f_y = 0\n    # Gradient of g = y²\n    grad_g_x = 0\n    grad_g_y = 2*y\n    # Dot product\n    dot = grad_f_x * grad_g_x + grad_f_y * grad_g_y\n    # Magnitudes\n    mag_f = math.sqrt(grad_f_x**2 + grad_f_y**2)\n    mag_g = math.sqrt(grad_g_x**2 + grad_g_y**2)\n    # Avoid division by zero\n    if mag_f == 0 or mag_g == 0:\n        return 0.0\n    # Angle\n    cos_theta = dot / (mag_f * mag_g)\n    theta_rad = math.acos(cos_theta)\n    return math.degrees(theta_rad)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "90.0",
        "isHidden": false,
        "description": "Perpendicular gradients"
      },
      {
        "input": "2, 2",
        "expectedOutput": "90.0",
        "isHidden": false,
        "description": "Still perpendicular"
      },
      {
        "input": "1, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Zero gradient for g"
      },
      {
        "input": "3, 5",
        "expectedOutput": "90.0",
        "isHidden": true,
        "description": "Any non-zero point"
      },
      {
        "input": "0, 1",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Zero gradient for f"
      }
    ],
    "hints": [
      "∇f = [2x, 0] and ∇g = [0, 2y]",
      "These are always perpendicular (when both non-zero)",
      "Use the angle formula: cos(θ) = (u·v)/(|u||v|)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t3-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-3",
    "title": "Level Curve Value",
    "difficulty": 2,
    "description": "For f(x,y) = x² + y², find the value c of the level curve that passes through point (x0, y0). The level curve is defined by f(x,y) = c.",
    "starterCode": "def level_curve_value(x0, y0):\n    \"\"\"\n    Find the value c of the level curve f(x,y) = c passing through (x0, y0)\n    where f(x,y) = x² + y²\n\n    Args:\n        x0, y0: point on the level curve\n\n    Returns:\n        The value c of the level curve\n    \"\"\"\n    pass",
    "solution": "def level_curve_value(x0, y0):\n    \"\"\"\n    Find the value c of the level curve f(x,y) = c passing through (x0, y0)\n    where f(x,y) = x² + y²\n\n    Args:\n        x0, y0: point on the level curve\n\n    Returns:\n        The value c of the level curve\n    \"\"\"\n    return x0**2 + y0**2",
    "testCases": [
      {
        "input": "1, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Point (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Point (0,1)"
      },
      {
        "input": "3, 4",
        "expectedOutput": "25.0",
        "isHidden": false,
        "description": "Point (3,4)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "2.0",
        "isHidden": true,
        "description": "Point (1,1)"
      },
      {
        "input": "5, 12",
        "expectedOutput": "169.0",
        "isHidden": true,
        "description": "Point (5,12)"
      }
    ],
    "hints": [
      "A level curve is defined by f(x,y) = c for some constant c",
      "To find c, simply evaluate f at the given point",
      "c = f(x0, y0) = x0² + y0²"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Find Critical Points - Basic",
    "difficulty": 2,
    "description": "Find the critical point of f(x,y) = x² + y² - 2x - 4y. Critical points occur where both partial derivatives are zero. Return as tuple (x, y).",
    "starterCode": "def find_critical_point_basic():\n    \"\"\"\n    Find the critical point of f(x,y) = x² + y² - 2x - 4y\n\n    Returns:\n        Tuple (x, y) representing the critical point\n    \"\"\"\n    pass",
    "solution": "def find_critical_point_basic():\n    \"\"\"\n    Find the critical point of f(x,y) = x² + y² - 2x - 4y\n\n    Returns:\n        Tuple (x, y) representing the critical point\n    \"\"\"\n    # fx = 2x - 2 = 0 => x = 1\n    # fy = 2y - 4 = 0 => y = 2\n    return (1.0, 2.0)",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "(1.0, 2.0)",
        "isHidden": false,
        "description": "Critical point"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 2.0)",
        "isHidden": false,
        "description": "Verify solution"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 2.0)",
        "isHidden": false,
        "description": "Should be (1, 2)"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 2.0)",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 2.0)",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Set both partial derivatives equal to zero",
      "∂f/∂x = 2x - 2 = 0",
      "∂f/∂y = 2y - 4 = 0"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Evaluate Function at Critical Point",
    "difficulty": 1,
    "description": "Given f(x,y) = x² + y² and a critical point (x,y), evaluate f at that point.",
    "starterCode": "def evaluate_at_critical(x, y):\n    \"\"\"\n    Evaluate f(x,y) = x² + y² at the critical point (x, y)\n\n    Args:\n        x, y: critical point coordinates\n\n    Returns:\n        The function value at (x, y)\n    \"\"\"\n    pass",
    "solution": "def evaluate_at_critical(x, y):\n    \"\"\"\n    Evaluate f(x,y) = x² + y² at the critical point (x, y)\n\n    Args:\n        x, y: critical point coordinates\n\n    Returns:\n        The function value at (x, y)\n    \"\"\"\n    return x**2 + y**2",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "At origin"
      },
      {
        "input": "1, 0",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "At (1,0)"
      },
      {
        "input": "1, 1",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "At (1,1)"
      },
      {
        "input": "3, 4",
        "expectedOutput": "25.0",
        "isHidden": true,
        "description": "At (3,4)"
      },
      {
        "input": "2, 2",
        "expectedOutput": "8.0",
        "isHidden": true,
        "description": "At (2,2)"
      }
    ],
    "hints": [
      "Simply evaluate the function at the given point",
      "f(x,y) = x² + y²",
      "Substitute the values and compute"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Compute Discriminant D",
    "difficulty": 3,
    "description": "Compute the discriminant D = fxx*fyy - (fxy)² for f(x,y) = x² + y² - xy at point (x,y). The discriminant is used in the second derivative test.",
    "starterCode": "def compute_discriminant(x, y):\n    \"\"\"\n    Compute D = fxx*fyy - fxy² for f(x,y) = x² + y² - xy\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The discriminant D\n    \"\"\"\n    pass",
    "solution": "def compute_discriminant(x, y):\n    \"\"\"\n    Compute D = fxx*fyy - fxy² for f(x,y) = x² + y² - xy\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The discriminant D\n    \"\"\"\n    # Second partial derivatives\n    fxx = 2\n    fyy = 2\n    fxy = -1\n    # Discriminant\n    return fxx * fyy - fxy**2",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "3.0",
        "isHidden": false,
        "description": "At origin"
      },
      {
        "input": "1, 1",
        "expectedOutput": "3.0",
        "isHidden": false,
        "description": "At (1,1)"
      },
      {
        "input": "2, 3",
        "expectedOutput": "3.0",
        "isHidden": false,
        "description": "At (2,3)"
      },
      {
        "input": "5, 7",
        "expectedOutput": "3.0",
        "isHidden": true,
        "description": "At (5,7)"
      },
      {
        "input": "10, 10",
        "expectedOutput": "3.0",
        "isHidden": true,
        "description": "At (10,10)"
      }
    ],
    "hints": [
      "For f = x² + y² - xy: fxx = 2, fyy = 2, fxy = -1",
      "D = fxx*fyy - (fxy)²",
      "The second partials are constant for this function"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Second Derivative Test",
    "difficulty": 4,
    "description": "Apply the second derivative test to f(x,y) = x² + y² at point (x,y). Return 1 for local minimum, -1 for local maximum, 0 for saddle point, and 2 for inconclusive. Test: if D > 0 and fxx > 0: min; if D > 0 and fxx < 0: max; if D < 0: saddle; if D = 0: inconclusive.",
    "starterCode": "def second_derivative_test(x, y):\n    \"\"\"\n    Apply second derivative test to f(x,y) = x² + y² at (x, y)\n\n    Args:\n        x, y: point to test\n\n    Returns:\n        1 for min, -1 for max, 0 for saddle, 2 for inconclusive\n    \"\"\"\n    pass",
    "solution": "def second_derivative_test(x, y):\n    \"\"\"\n    Apply second derivative test to f(x,y) = x² + y² at (x, y)\n\n    Args:\n        x, y: point to test\n\n    Returns:\n        1 for min, -1 for max, 0 for saddle, 2 for inconclusive\n    \"\"\"\n    # Second partial derivatives\n    fxx = 2\n    fyy = 2\n    fxy = 0\n    # Discriminant\n    D = fxx * fyy - fxy**2\n\n    if D > 0:\n        if fxx > 0:\n            return 1  # Local minimum\n        else:\n            return -1  # Local maximum\n    elif D < 0:\n        return 0  # Saddle point\n    else:\n        return 2  # Inconclusive",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Minimum at origin"
      },
      {
        "input": "1, 1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Still minimum"
      },
      {
        "input": "5, 5",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Always minimum"
      },
      {
        "input": "2, 3",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Another point"
      },
      {
        "input": "10, 0",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Any point gives minimum"
      }
    ],
    "hints": [
      "Compute D = fxx*fyy - fxy²",
      "For f = x² + y²: fxx = 2, fyy = 2, fxy = 0",
      "D = 4 > 0 and fxx = 2 > 0, so local minimum"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Identify Saddle Point",
    "difficulty": 3,
    "description": "For f(x,y) = x² - y², determine if (0,0) is a saddle point. Return True if it is a saddle point, False otherwise. Use the second derivative test.",
    "starterCode": "def is_saddle_point():\n    \"\"\"\n    Check if (0,0) is a saddle point for f(x,y) = x² - y²\n\n    Returns:\n        True if saddle point, False otherwise\n    \"\"\"\n    pass",
    "solution": "def is_saddle_point():\n    \"\"\"\n    Check if (0,0) is a saddle point for f(x,y) = x² - y²\n\n    Returns:\n        True if saddle point, False otherwise\n    \"\"\"\n    # Second partial derivatives\n    fxx = 2\n    fyy = -2\n    fxy = 0\n    # Discriminant\n    D = fxx * fyy - fxy**2\n    # D = -4 < 0, so it's a saddle point\n    return D < 0",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Is saddle point"
      },
      {
        "input": "",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Verify saddle"
      },
      {
        "input": "",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Definitely saddle"
      },
      {
        "input": "",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "For f = x² - y²: fxx = 2, fyy = -2, fxy = 0",
      "D = fxx*fyy - fxy² = -4",
      "D < 0 indicates a saddle point"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Lagrange Multiplier Setup",
    "difficulty": 3,
    "description": "Set up the Lagrange equations for optimizing f(x,y) = xy subject to constraint g(x,y) = x + y - 2 = 0. At the optimal point, the x-component equation is: fx = λ*gx. Compute λ given x=1, y=1.",
    "starterCode": "def compute_lagrange_multiplier(x, y):\n    \"\"\"\n    Compute λ from fx = λ*gx where f(x,y) = xy, g(x,y) = x + y - 2\n\n    Args:\n        x, y: point where constraint is satisfied\n\n    Returns:\n        The Lagrange multiplier λ\n    \"\"\"\n    pass",
    "solution": "def compute_lagrange_multiplier(x, y):\n    \"\"\"\n    Compute λ from fx = λ*gx where f(x,y) = xy, g(x,y) = x + y - 2\n\n    Args:\n        x, y: point where constraint is satisfied\n\n    Returns:\n        The Lagrange multiplier λ\n    \"\"\"\n    # fx = y, gx = 1\n    # fy = x, gy = 1\n    # From fx = λ*gx: y = λ*1\n    return float(y)",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "At (1,1)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "At (1,0)"
      },
      {
        "input": "0, 2",
        "expectedOutput": "2.0",
        "isHidden": false,
        "description": "At (0,2)"
      },
      {
        "input": "1.5, 0.5",
        "expectedOutput": "0.5",
        "isHidden": true,
        "description": "At (1.5,0.5)"
      },
      {
        "input": "0.5, 1.5",
        "expectedOutput": "1.5",
        "isHidden": true,
        "description": "At (0.5,1.5)"
      }
    ],
    "hints": [
      "For f = xy: fx = y, fy = x",
      "For g = x + y - 2: gx = 1, gy = 1",
      "From fx = λ*gx: y = λ*1, so λ = y"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Constrained Optimization Value",
    "difficulty": 4,
    "description": "Find the maximum value of f(x,y) = xy subject to x + y = 2 (x,y > 0). The maximum occurs at x = y = 1. Return the maximum value.",
    "starterCode": "def constrained_max_value():\n    \"\"\"\n    Find max of f(x,y) = xy subject to x + y = 2\n\n    Returns:\n        The maximum value\n    \"\"\"\n    pass",
    "solution": "def constrained_max_value():\n    \"\"\"\n    Find max of f(x,y) = xy subject to x + y = 2\n\n    Returns:\n        The maximum value\n    \"\"\"\n    # Maximum occurs at x = 1, y = 1\n    x = 1\n    y = 1\n    return x * y",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Maximum value"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "f(1,1) = 1"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Should be 1"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Use Lagrange multipliers or substitution",
      "By symmetry, the maximum occurs at x = y",
      "If x + y = 2 and x = y, then x = y = 1"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Minimize Distance to Origin",
    "difficulty": 4,
    "description": "Find the minimum distance from the origin to the line x + y = 4. The distance is minimized when the point is (2,2). Return the minimum distance.",
    "starterCode": "import math\n\ndef min_distance_to_origin():\n    \"\"\"\n    Find minimum distance from origin to line x + y = 4\n\n    Returns:\n        The minimum distance\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef min_distance_to_origin():\n    \"\"\"\n    Find minimum distance from origin to line x + y = 4\n\n    Returns:\n        The minimum distance\n    \"\"\"\n    # Minimum occurs at (2, 2)\n    x = 2\n    y = 2\n    return math.sqrt(x**2 + y**2)",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "2.828",
        "isHidden": false,
        "description": "Distance at (2,2)"
      },
      {
        "input": "",
        "expectedOutput": "2.828",
        "isHidden": false,
        "description": "sqrt(8)"
      },
      {
        "input": "",
        "expectedOutput": "2.828",
        "isHidden": false,
        "description": "Minimum distance"
      },
      {
        "input": "",
        "expectedOutput": "2.828",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "2.828",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Minimize f(x,y) = x² + y² subject to x + y = 4",
      "Use Lagrange multipliers or substitution",
      "The minimum is at (2,2) with distance sqrt(8)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Hessian Matrix Determinant",
    "difficulty": 3,
    "description": "Compute the determinant of the Hessian matrix for f(x,y) = x³ + y³ - 3xy at point (x,y). The Hessian is [[fxx, fxy], [fxy, fyy]]. Return det(H) = fxx*fyy - fxy².",
    "starterCode": "def hessian_determinant(x, y):\n    \"\"\"\n    Compute det(H) for f(x,y) = x³ + y³ - 3xy\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The determinant of the Hessian\n    \"\"\"\n    pass",
    "solution": "def hessian_determinant(x, y):\n    \"\"\"\n    Compute det(H) for f(x,y) = x³ + y³ - 3xy\n\n    Args:\n        x, y: point at which to evaluate\n\n    Returns:\n        The determinant of the Hessian\n    \"\"\"\n    # Second partial derivatives\n    fxx = 6*x\n    fyy = 6*y\n    fxy = -3\n    # Determinant\n    return fxx * fyy - fxy**2",
    "testCases": [
      {
        "input": "1, 1",
        "expectedOutput": "27.0",
        "isHidden": false,
        "description": "At (1,1)"
      },
      {
        "input": "0, 0",
        "expectedOutput": "-9.0",
        "isHidden": false,
        "description": "At origin"
      },
      {
        "input": "2, 2",
        "expectedOutput": "135.0",
        "isHidden": false,
        "description": "At (2,2)"
      },
      {
        "input": "1, 0",
        "expectedOutput": "-9.0",
        "isHidden": true,
        "description": "At (1,0)"
      },
      {
        "input": "0, 1",
        "expectedOutput": "-9.0",
        "isHidden": true,
        "description": "At (0,1)"
      }
    ],
    "hints": [
      "For f = x³ + y³ - 3xy",
      "fxx = 6x, fyy = 6y, fxy = -3",
      "det(H) = fxx*fyy - fxy² = 36xy - 9"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Critical Point of Cubic",
    "difficulty": 4,
    "description": "Find a critical point of f(x,y) = x³ - 3x + y². Set fx = 0 and fy = 0. Return one critical point as tuple (x, y). Note: there are three critical points; return (1, 0).",
    "starterCode": "def critical_point_cubic():\n    \"\"\"\n    Find a critical point of f(x,y) = x³ - 3x + y²\n\n    Returns:\n        Tuple (x, y) representing one critical point\n    \"\"\"\n    pass",
    "solution": "def critical_point_cubic():\n    \"\"\"\n    Find a critical point of f(x,y) = x³ - 3x + y²\n\n    Returns:\n        Tuple (x, y) representing one critical point\n    \"\"\"\n    # fx = 3x² - 3 = 0 => x² = 1 => x = ±1\n    # fy = 2y = 0 => y = 0\n    # Critical points: (1, 0), (-1, 0)\n    return (1.0, 0.0)",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "(1.0, 0.0)",
        "isHidden": false,
        "description": "Critical point at (1,0)"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 0.0)",
        "isHidden": false,
        "description": "Should be (1,0)"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 0.0)",
        "isHidden": false,
        "description": "One solution"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 0.0)",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "(1.0, 0.0)",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "fx = 3x² - 3 = 0",
      "fy = 2y = 0",
      "Solve to get x = ±1, y = 0"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Classify Extremum",
    "difficulty": 4,
    "description": "For f(x,y) = -x² - y², classify the critical point (0,0). Return \"maximum\", \"minimum\", \"saddle\", or \"inconclusive\".",
    "starterCode": "def classify_extremum():\n    \"\"\"\n    Classify the critical point (0,0) for f(x,y) = -x² - y²\n\n    Returns:\n        String: \"maximum\", \"minimum\", \"saddle\", or \"inconclusive\"\n    \"\"\"\n    pass",
    "solution": "def classify_extremum():\n    \"\"\"\n    Classify the critical point (0,0) for f(x,y) = -x² - y²\n\n    Returns:\n        String: \"maximum\", \"minimum\", \"saddle\", or \"inconclusive\"\n    \"\"\"\n    # fxx = -2, fyy = -2, fxy = 0\n    fxx = -2\n    fyy = -2\n    fxy = 0\n    D = fxx * fyy - fxy**2\n\n    if D > 0:\n        if fxx < 0:\n            return \"maximum\"\n        else:\n            return \"minimum\"\n    elif D < 0:\n        return \"saddle\"\n    else:\n        return \"inconclusive\"",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "maximum",
        "isHidden": false,
        "description": "Local maximum"
      },
      {
        "input": "",
        "expectedOutput": "maximum",
        "isHidden": false,
        "description": "Should be max"
      },
      {
        "input": "",
        "expectedOutput": "maximum",
        "isHidden": false,
        "description": "D > 0, fxx < 0"
      },
      {
        "input": "",
        "expectedOutput": "maximum",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "maximum",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Compute second partial derivatives",
      "fxx = -2, fyy = -2, fxy = 0",
      "D = 4 > 0 and fxx = -2 < 0, so maximum"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Lagrange with Circle Constraint",
    "difficulty": 4,
    "description": "Maximize f(x,y) = x + y subject to x² + y² = 1. The maximum occurs at (1/√2, 1/√2). Return the maximum value of f.",
    "starterCode": "import math\n\ndef max_on_circle():\n    \"\"\"\n    Find max of f(x,y) = x + y subject to x² + y² = 1\n\n    Returns:\n        The maximum value\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef max_on_circle():\n    \"\"\"\n    Find max of f(x,y) = x + y subject to x² + y² = 1\n\n    Returns:\n        The maximum value\n    \"\"\"\n    # Maximum at x = y = 1/sqrt(2)\n    x = 1 / math.sqrt(2)\n    y = 1 / math.sqrt(2)\n    return x + y",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "1.414",
        "isHidden": false,
        "description": "Maximum value sqrt(2)"
      },
      {
        "input": "",
        "expectedOutput": "1.414",
        "isHidden": false,
        "description": "Should be sqrt(2)"
      },
      {
        "input": "",
        "expectedOutput": "1.414",
        "isHidden": false,
        "description": "f(1/√2, 1/√2)"
      },
      {
        "input": "",
        "expectedOutput": "1.414",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "1.414",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Use Lagrange multipliers",
      "Maximum occurs when gradient of f is parallel to gradient of g",
      "By symmetry, x = y, so x = y = 1/√2"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Optimize Box Volume",
    "difficulty": 5,
    "description": "A box with square base has surface area 24. Find dimensions that maximize volume. If the base is x×x and height is h, then 2x² + 4xh = 24 and V = x²h. The optimal x is 2. Return the maximum volume.",
    "starterCode": "def max_box_volume():\n    \"\"\"\n    Find max volume of box with square base and surface area 24\n\n    Returns:\n        The maximum volume\n    \"\"\"\n    pass",
    "solution": "def max_box_volume():\n    \"\"\"\n    Find max volume of box with square base and surface area 24\n\n    Returns:\n        The maximum volume\n    \"\"\"\n    # Optimal dimensions: x = 2, h = 2\n    x = 2\n    h = 2\n    return x**2 * h",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "8.0",
        "isHidden": false,
        "description": "Maximum volume"
      },
      {
        "input": "",
        "expectedOutput": "8.0",
        "isHidden": false,
        "description": "Should be 8"
      },
      {
        "input": "",
        "expectedOutput": "8.0",
        "isHidden": false,
        "description": "V = 2² × 2"
      },
      {
        "input": "",
        "expectedOutput": "8.0",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "8.0",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Constraint: 2x² + 4xh = 24",
      "Maximize V = x²h",
      "Optimal: x = 2, h = 2, giving V = 8"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Gradient at Critical Point",
    "difficulty": 2,
    "description": "Compute the magnitude of the gradient at a critical point (x,y) for f(x,y) = x² + y². At a critical point, the gradient is zero, so return 0.",
    "starterCode": "import math\n\ndef gradient_at_critical(x, y):\n    \"\"\"\n    Compute |∇f| at critical point for f(x,y) = x² + y²\n\n    Args:\n        x, y: critical point\n\n    Returns:\n        Magnitude of gradient (should be 0)\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef gradient_at_critical(x, y):\n    \"\"\"\n    Compute |∇f| at critical point for f(x,y) = x² + y²\n\n    Args:\n        x, y: critical point\n\n    Returns:\n        Magnitude of gradient (should be 0)\n    \"\"\"\n    # At critical point, gradient is zero\n    gx = 2*x\n    gy = 2*y\n    return math.sqrt(gx**2 + gy**2)",
    "testCases": [
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "At critical point"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Gradient is zero"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": false,
        "description": "Should be 0"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "0, 0",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "At a critical point, both partial derivatives are zero",
      "So the gradient vector is (0, 0)",
      "The magnitude is therefore 0"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Multiple Constraints - Lambda Sum",
    "difficulty": 5,
    "description": "Optimize f(x,y,z) = x+y+z subject to x²+y²=1 and z=0. Using Lagrange multipliers, at the optimal point (1/√2, 1/√2, 0), we have ∇f = λ₁∇g₁ + λ₂∇g₂. Given λ₁=1/√2, λ₂=-√2, compute λ₁ + λ₂.",
    "starterCode": "import math\n\ndef sum_lagrange_multipliers():\n    \"\"\"\n    Compute λ₁ + λ₂ for the constrained optimization problem\n\n    Returns:\n        The sum of Lagrange multipliers\n    \"\"\"\n    pass",
    "solution": "import math\n\ndef sum_lagrange_multipliers():\n    \"\"\"\n    Compute λ₁ + λ₂ for the constrained optimization problem\n\n    Returns:\n        The sum of Lagrange multipliers\n    \"\"\"\n    lambda1 = 1 / math.sqrt(2)\n    lambda2 = -math.sqrt(2)\n    return lambda1 + lambda2",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "-0.707",
        "isHidden": false,
        "description": "Sum of multipliers"
      },
      {
        "input": "",
        "expectedOutput": "-0.707",
        "isHidden": false,
        "description": "1/√2 - √2"
      },
      {
        "input": "",
        "expectedOutput": "-0.707",
        "isHidden": false,
        "description": "Should be -1/√2"
      },
      {
        "input": "",
        "expectedOutput": "-0.707",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "-0.707",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "λ₁ = 1/√2",
      "λ₂ = -√2",
      "Sum = 1/√2 - √2 = -1/√2 ≈ -0.707"
    ],
    "language": "python"
  },
  {
    "id": "math301-t4-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-4",
    "title": "Absolute Extrema on Closed Region",
    "difficulty": 5,
    "description": "Find the absolute maximum of f(x,y) = xy on the triangular region with vertices (0,0), (2,0), (0,2). The maximum occurs at (1,1) on the boundary line x+y=2. Return the maximum value.",
    "starterCode": "def absolute_max_triangle():\n    \"\"\"\n    Find absolute max of f(x,y) = xy on triangle with vertices (0,0), (2,0), (0,2)\n\n    Returns:\n        The absolute maximum value\n    \"\"\"\n    pass",
    "solution": "def absolute_max_triangle():\n    \"\"\"\n    Find absolute max of f(x,y) = xy on triangle with vertices (0,0), (2,0), (0,2)\n\n    Returns:\n        The absolute maximum value\n    \"\"\"\n    # Check critical points in interior: none (no point where fx=fy=0 with x,y>0 in region)\n    # Check boundaries:\n    # 1. x=0: f=0\n    # 2. y=0: f=0\n    # 3. x+y=2: f=x(2-x), max at x=1, f=1\n    # Check vertices: f(0,0)=0, f(2,0)=0, f(0,2)=0\n    # Maximum is 1 at (1,1)\n    return 1.0",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Maximum value"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "f(1,1) = 1"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": false,
        "description": "Should be 1"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Hidden check 1"
      },
      {
        "input": "",
        "expectedOutput": "1.0",
        "isHidden": true,
        "description": "Hidden check 2"
      }
    ],
    "hints": [
      "Check critical points in the interior",
      "Check all boundary segments and vertices",
      "On line x+y=2: f=x(2-x), maximized at x=1"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Double Integral over Rectangle",
    "difficulty": 1,
    "description": "Compute a double integral ∫∫_R f(x,y) dA over a rectangular region using numerical integration.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef double_integral_rectangle(f, x_bounds, y_bounds):\n    \"\"\"\n    Compute double integral of f over rectangle [a,b] x [c,d].\n\n    Args:\n        f: Function of two variables f(x, y)\n        x_bounds: Tuple (a, b) for x limits\n        y_bounds: Tuple (c, d) for y limits\n    Returns:\n        The value of the double integral\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef double_integral_rectangle(f, x_bounds, y_bounds):\n    \"\"\"\n    Compute double integral of f over rectangle [a,b] x [c,d].\n    \"\"\"\n    result, _ = integrate.dblquad(f, x_bounds[0], x_bounds[1],\n                                   y_bounds[0], y_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "double_integral_rectangle(lambda y, x: x + y, (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "double_integral_rectangle(lambda y, x: x*y, (0, 2), (0, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "double_integral_rectangle(lambda y, x: 1, (0, 1), (0, 2))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use scipy.integrate.dblquad for numerical integration",
      "Note that dblquad takes the integrand as f(y, x), not f(x, y)",
      "The function returns (result, error_estimate)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Iterated Integral Order",
    "difficulty": 1,
    "description": "Compute the same iterated integral in both orders (dx dy and dy dx) and verify they give the same result.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef compare_integral_orders(f, x_bounds, y_bounds):\n    \"\"\"\n    Compute integral in both orders and return (result_dxdy, result_dydx).\n\n    Args:\n        f: Function f(x, y)\n        x_bounds: (a, b)\n        y_bounds: (c, d)\n    Returns:\n        Tuple of (integral with dx dy, integral with dy dx)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef compare_integral_orders(f, x_bounds, y_bounds):\n    \"\"\"\n    Compute integral in both orders and return (result_dxdy, result_dydx).\n    \"\"\"\n    # Order: dy dx (integrate y first, then x)\n    result_dydx, _ = integrate.dblquad(lambda y, x: f(x, y),\n                                        x_bounds[0], x_bounds[1],\n                                        y_bounds[0], y_bounds[1])\n\n    # Order: dx dy (integrate x first, then y)\n    result_dxdy, _ = integrate.dblquad(lambda x, y: f(x, y),\n                                        y_bounds[0], y_bounds[1],\n                                        x_bounds[0], x_bounds[1])\n\n    return (result_dxdy, result_dydx)",
    "testCases": [
      {
        "input": "compare_integral_orders(lambda x, y: x*y, (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compare_integral_orders(lambda x, y: x**2 + y**2, (0, 2), (0, 2))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "dblquad integrates the first variable over the inner limits",
      "Swap the order of integration by swapping the bounds",
      "Fubini's theorem guarantees both orders give the same result for continuous functions"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Double Integral over General Region",
    "difficulty": 2,
    "description": "Compute a double integral over a region bounded by y=g1(x) and y=g2(x).",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef double_integral_general(f, x_bounds, y_lower, y_upper):\n    \"\"\"\n    Compute ∫∫_D f(x,y) dA where D = {(x,y): a ≤ x ≤ b, g1(x) ≤ y ≤ g2(x)}.\n\n    Args:\n        f: Function f(x, y)\n        x_bounds: (a, b)\n        y_lower: Function g1(x) for lower y bound\n        y_upper: Function g2(x) for upper y bound\n    Returns:\n        Value of the double integral\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef double_integral_general(f, x_bounds, y_lower, y_upper):\n    \"\"\"\n    Compute ∫∫_D f(x,y) dA where D = {(x,y): a ≤ x ≤ b, g1(x) ≤ y ≤ g2(x)}.\n    \"\"\"\n    result, _ = integrate.dblquad(f, x_bounds[0], x_bounds[1],\n                                   y_lower, y_upper)\n    return result",
    "testCases": [
      {
        "input": "double_integral_general(lambda y, x: 1, (0, 1), lambda x: 0, lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "double_integral_general(lambda y, x: x*y, (0, 1), lambda x: 0, lambda x: x**2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "double_integral_general(lambda y, x: x+y, (-1, 1), lambda x: -np.sqrt(1-x**2), lambda x: np.sqrt(1-x**2))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "dblquad accepts functions for the inner limits",
      "The integrand should be f(y, x) due to dblquad convention",
      "Make sure y_lower and y_upper are functions of x"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Polar Coordinates Double Integral",
    "difficulty": 2,
    "description": "Convert a double integral to polar coordinates and compute it.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef polar_double_integral(f, r_bounds, theta_bounds):\n    \"\"\"\n    Compute ∫∫ f(r,θ) r dr dθ in polar coordinates.\n\n    Args:\n        f: Function f(r, theta)\n        r_bounds: (r_min, r_max)\n        theta_bounds: (theta_min, theta_max)\n    Returns:\n        Value of the integral\n    \"\"\"\n    # Your implementation here (remember the Jacobian r!)\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef polar_double_integral(f, r_bounds, theta_bounds):\n    \"\"\"\n    Compute ∫∫ f(r,θ) r dr dθ in polar coordinates.\n    \"\"\"\n    # Include Jacobian r in the integrand\n    integrand = lambda theta, r: f(r, theta) * r\n    result, _ = integrate.dblquad(integrand,\n                                   r_bounds[0], r_bounds[1],\n                                   theta_bounds[0], theta_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "polar_double_integral(lambda r, theta: 1, (0, 1), (0, 2*np.pi))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "polar_double_integral(lambda r, theta: r, (0, 2), (0, np.pi))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "polar_double_integral(lambda r, theta: np.cos(theta), (0, 1), (0, 2*np.pi))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "The Jacobian for polar coordinates is r",
      "Multiply the integrand by r before integrating",
      "Common bounds: θ ∈ [0, 2π] for full circle"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Area Using Double Integral",
    "difficulty": 2,
    "description": "Calculate the area of a region using a double integral.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef calculate_area(x_bounds, y_lower, y_upper):\n    \"\"\"\n    Calculate area of region using ∫∫ 1 dA.\n\n    Args:\n        x_bounds: (a, b)\n        y_lower: Function for lower y boundary\n        y_upper: Function for upper y boundary\n    Returns:\n        Area of the region\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef calculate_area(x_bounds, y_lower, y_upper):\n    \"\"\"\n    Calculate area of region using ∫∫ 1 dA.\n    \"\"\"\n    result, _ = integrate.dblquad(lambda y, x: 1,\n                                   x_bounds[0], x_bounds[1],\n                                   y_lower, y_upper)\n    return result",
    "testCases": [
      {
        "input": "calculate_area((0, 2), lambda x: 0, lambda x: 3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "calculate_area((0, 1), lambda x: 0, lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(calculate_area((0, 1), lambda x: 0, lambda x: np.sqrt(1-x**2)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Area is the integral of 1 over the region",
      "Use the same setup as general region integrals",
      "For a quarter circle: y goes from 0 to √(1-x²)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Triple Integral over Box",
    "difficulty": 3,
    "description": "Compute a triple integral over a rectangular box.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef triple_integral_box(f, x_bounds, y_bounds, z_bounds):\n    \"\"\"\n    Compute ∫∫∫ f(x,y,z) dV over box [a,b] x [c,d] x [e,f].\n\n    Args:\n        f: Function f(x, y, z)\n        x_bounds: (a, b)\n        y_bounds: (c, d)\n        z_bounds: (e, f)\n    Returns:\n        Value of the triple integral\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef triple_integral_box(f, x_bounds, y_bounds, z_bounds):\n    \"\"\"\n    Compute ∫∫∫ f(x,y,z) dV over box [a,b] x [c,d] x [e,f].\n    \"\"\"\n    result, _ = integrate.tplquad(f,\n                                   x_bounds[0], x_bounds[1],\n                                   y_bounds[0], y_bounds[1],\n                                   z_bounds[0], z_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "triple_integral_box(lambda z, y, x: 1, (0, 1), (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "triple_integral_box(lambda z, y, x: x*y*z, (0, 2), (0, 2), (0, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "triple_integral_box(lambda z, y, x: x+y+z, (0, 1), (0, 1), (0, 1))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Use scipy.integrate.tplquad for triple integrals",
      "Note: tplquad takes f(z, y, x) as the integrand",
      "The function signature is tplquad(f, x_min, x_max, y_min, y_max, z_min, z_max)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Volume Using Triple Integral",
    "difficulty": 3,
    "description": "Calculate the volume of a 3D region using triple integration.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef volume_under_surface(x_bounds, y_bounds, z_upper):\n    \"\"\"\n    Calculate volume under surface z = f(x,y) using ∫∫∫ 1 dV.\n    Region: a ≤ x ≤ b, c ≤ y ≤ d, 0 ≤ z ≤ f(x,y)\n\n    Args:\n        x_bounds: (a, b)\n        y_bounds: (c, d)\n        z_upper: Function f(x, y) for upper z bound\n    Returns:\n        Volume of the region\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef volume_under_surface(x_bounds, y_bounds, z_upper):\n    \"\"\"\n    Calculate volume under surface z = f(x,y) using ∫∫∫ 1 dV.\n    \"\"\"\n    result, _ = integrate.tplquad(lambda z, y, x: 1,\n                                   x_bounds[0], x_bounds[1],\n                                   y_bounds[0], y_bounds[1],\n                                   lambda x, y: 0, z_upper)\n    return result",
    "testCases": [
      {
        "input": "volume_under_surface((0, 2), (0, 3), lambda x, y: 4)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "volume_under_surface((0, 1), (0, 1), lambda x, y: x+y)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "volume_under_surface((0, 1), (0, 1), lambda x, y: 1-x-y)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Volume is the triple integral of 1",
      "z_upper should be a function of both x and y",
      "Lower z bound is typically 0"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Cylindrical Coordinates Integration",
    "difficulty": 3,
    "description": "Compute a triple integral in cylindrical coordinates.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef cylindrical_integral(f, r_bounds, theta_bounds, z_bounds):\n    \"\"\"\n    Compute ∫∫∫ f(r,θ,z) r dr dθ dz in cylindrical coordinates.\n\n    Args:\n        f: Function f(r, theta, z)\n        r_bounds: (r_min, r_max)\n        theta_bounds: (theta_min, theta_max)\n        z_bounds: (z_min, z_max)\n    Returns:\n        Value of the integral\n    \"\"\"\n    # Your implementation here (remember Jacobian r!)\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef cylindrical_integral(f, r_bounds, theta_bounds, z_bounds):\n    \"\"\"\n    Compute ∫∫∫ f(r,θ,z) r dr dθ dz in cylindrical coordinates.\n    \"\"\"\n    # Jacobian for cylindrical coordinates is r\n    integrand = lambda z, theta, r: f(r, theta, z) * r\n    result, _ = integrate.tplquad(integrand,\n                                   r_bounds[0], r_bounds[1],\n                                   theta_bounds[0], theta_bounds[1],\n                                   z_bounds[0], z_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "cylindrical_integral(lambda r, theta, z: 1, (0, 1), (0, 2*np.pi), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "cylindrical_integral(lambda r, theta, z: z, (0, 2), (0, 2*np.pi), (0, 3))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(cylindrical_integral(lambda r, theta, z: r*np.cos(theta), (0, 1), (0, 2*np.pi), (0, 1)), 10)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Cylindrical coordinates: x = r cos θ, y = r sin θ, z = z",
      "The Jacobian is r",
      "Common: θ ∈ [0, 2π] for full rotation around z-axis"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Spherical Coordinates Integration",
    "difficulty": 4,
    "description": "Compute a triple integral in spherical coordinates.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef spherical_integral(f, rho_bounds, theta_bounds, phi_bounds):\n    \"\"\"\n    Compute ∫∫∫ f(ρ,θ,φ) ρ²sin(φ) dρ dθ dφ in spherical coordinates.\n    Convention: ρ = distance, θ = azimuthal, φ = polar angle from z-axis\n\n    Args:\n        f: Function f(rho, theta, phi)\n        rho_bounds: (rho_min, rho_max)\n        theta_bounds: (theta_min, theta_max)\n        phi_bounds: (phi_min, phi_max)\n    Returns:\n        Value of the integral\n    \"\"\"\n    # Your implementation here (remember Jacobian ρ²sin(φ)!)\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef spherical_integral(f, rho_bounds, theta_bounds, phi_bounds):\n    \"\"\"\n    Compute ∫∫∫ f(ρ,θ,φ) ρ²sin(φ) dρ dθ dφ in spherical coordinates.\n    \"\"\"\n    # Jacobian for spherical coordinates is ρ²sin(φ)\n    integrand = lambda phi, theta, rho: f(rho, theta, phi) * rho**2 * np.sin(phi)\n    result, _ = integrate.tplquad(integrand,\n                                   rho_bounds[0], rho_bounds[1],\n                                   theta_bounds[0], theta_bounds[1],\n                                   phi_bounds[0], phi_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(spherical_integral(lambda rho, theta, phi: 1, (0, 1), (0, 2*np.pi), (0, np.pi)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "spherical_integral(lambda rho, theta, phi: rho, (0, 2), (0, 2*np.pi), (0, np.pi))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(spherical_integral(lambda rho, theta, phi: rho**2, (0, 1), (0, 2*np.pi), (0, np.pi)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Spherical: x = ρsin(φ)cos(θ), y = ρsin(φ)sin(θ), z = ρcos(φ)",
      "The Jacobian is ρ²sin(φ)",
      "Full sphere: ρ ∈ [0, R], θ ∈ [0, 2π], φ ∈ [0, π]"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Volume of Sphere",
    "difficulty": 4,
    "description": "Calculate the volume of a sphere using spherical coordinates.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef sphere_volume(radius):\n    \"\"\"\n    Calculate volume of sphere using spherical coordinates.\n    Should return (4/3)πR³\n\n    Args:\n        radius: Radius of the sphere\n    Returns:\n        Volume of the sphere\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef sphere_volume(radius):\n    \"\"\"\n    Calculate volume of sphere using spherical coordinates.\n    \"\"\"\n    # Integrate 1 with Jacobian ρ²sin(φ)\n    integrand = lambda phi, theta, rho: rho**2 * np.sin(phi)\n    result, _ = integrate.tplquad(integrand,\n                                   0, radius,\n                                   0, 2*np.pi,\n                                   0, np.pi)\n    return result",
    "testCases": [
      {
        "input": "round(sphere_volume(1), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(sphere_volume(2), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(sphere_volume(3), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Integrate 1 with the Jacobian ρ²sin(φ)",
      "ρ ∈ [0, R], θ ∈ [0, 2π], φ ∈ [0, π]",
      "Result should be (4/3)πR³"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Jacobian Calculation",
    "difficulty": 4,
    "description": "Compute the Jacobian determinant for a coordinate transformation.",
    "starterCode": "import numpy as np\n\ndef compute_jacobian(u, v, x_func, y_func):\n    \"\"\"\n    Compute Jacobian determinant ∂(x,y)/∂(u,v) at point (u, v).\n\n    Args:\n        u: u-coordinate\n        v: v-coordinate\n        x_func: Function x(u, v)\n        y_func: Function y(u, v)\n    Returns:\n        Jacobian determinant at (u, v)\n    \"\"\"\n    # Use numerical derivatives with small h\n    h = 1e-6\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef compute_jacobian(u, v, x_func, y_func):\n    \"\"\"\n    Compute Jacobian determinant ∂(x,y)/∂(u,v) at point (u, v).\n    \"\"\"\n    h = 1e-6\n\n    # Partial derivatives\n    dx_du = (x_func(u + h, v) - x_func(u - h, v)) / (2 * h)\n    dx_dv = (x_func(u, v + h) - x_func(u, v - h)) / (2 * h)\n    dy_du = (y_func(u + h, v) - y_func(u - h, v)) / (2 * h)\n    dy_dv = (y_func(u, v + h) - y_func(u, v - h)) / (2 * h)\n\n    # Jacobian determinant\n    jacobian = dx_du * dy_dv - dx_dv * dy_du\n    return jacobian",
    "testCases": [
      {
        "input": "round(compute_jacobian(1, 0, lambda u, v: u*np.cos(v), lambda u, v: u*np.sin(v)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(compute_jacobian(2, np.pi/4, lambda u, v: u*np.cos(v), lambda u, v: u*np.sin(v)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compute_jacobian(1, 1, lambda u, v: 2*u+v, lambda u, v: u-3*v)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Jacobian matrix: [[∂x/∂u, ∂x/∂v], [∂y/∂u, ∂y/∂v]]",
      "Determinant: (∂x/∂u)(∂y/∂v) - (∂x/∂v)(∂y/∂u)",
      "Use centered differences for numerical derivatives"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Change of Variables in Double Integral",
    "difficulty": 5,
    "description": "Apply a change of variables transformation with the Jacobian.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef integral_change_variables(f_xy, u_bounds, v_bounds, x_func, y_func, jacobian_func):\n    \"\"\"\n    Compute ∫∫ f(x,y) dx dy using change of variables to (u,v).\n    ∫∫ f(x(u,v), y(u,v)) |J| du dv\n\n    Args:\n        f_xy: Function f(x, y)\n        u_bounds: (u_min, u_max)\n        v_bounds: (v_min, v_max)\n        x_func: Transformation x(u, v)\n        y_func: Transformation y(u, v)\n        jacobian_func: Function |J(u, v)|\n    Returns:\n        Value of the integral\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef integral_change_variables(f_xy, u_bounds, v_bounds, x_func, y_func, jacobian_func):\n    \"\"\"\n    Compute ∫∫ f(x,y) dx dy using change of variables to (u,v).\n    \"\"\"\n    # Transform integrand: f(x(u,v), y(u,v)) * |J(u,v)|\n    def transformed_integrand(v, u):\n        x = x_func(u, v)\n        y = y_func(u, v)\n        J = jacobian_func(u, v)\n        return f_xy(x, y) * abs(J)\n\n    result, _ = integrate.dblquad(transformed_integrand,\n                                   u_bounds[0], u_bounds[1],\n                                   v_bounds[0], v_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(integral_change_variables(lambda x, y: 1, (0, 1), (0, 2*np.pi), lambda u, v: u*np.cos(v), lambda u, v: u*np.sin(v), lambda u, v: u), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "integral_change_variables(lambda x, y: x+y, (0, 1), (0, 1), lambda u, v: u, lambda u, v: v, lambda u, v: 1)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Transform f(x,y) to f(x(u,v), y(u,v))",
      "Multiply by the absolute value of the Jacobian",
      "Integrate over the new region in (u,v) space"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Mass of 2D Plate",
    "difficulty": 5,
    "description": "Calculate the mass of a 2D plate with variable density using double integration.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef plate_mass(density, x_bounds, y_bounds):\n    \"\"\"\n    Calculate mass of 2D plate: M = ∫∫ ρ(x,y) dA\n\n    Args:\n        density: Density function ρ(x, y)\n        x_bounds: (a, b)\n        y_bounds: (c, d)\n    Returns:\n        Total mass of the plate\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef plate_mass(density, x_bounds, y_bounds):\n    \"\"\"\n    Calculate mass of 2D plate: M = ∫∫ ρ(x,y) dA\n    \"\"\"\n    result, _ = integrate.dblquad(density,\n                                   x_bounds[0], x_bounds[1],\n                                   y_bounds[0], y_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "plate_mass(lambda y, x: 1, (0, 2), (0, 3))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "plate_mass(lambda y, x: x+y, (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "plate_mass(lambda y, x: x**2 + y**2, (0, 1), (0, 1))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Mass = ∫∫ ρ(x,y) dA where ρ is density",
      "For uniform density ρ = c, mass = c × area",
      "Use dblquad with the density function"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Center of Mass 2D",
    "difficulty": 5,
    "description": "Find the center of mass (x̄, ȳ) of a 2D region with variable density.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef center_of_mass_2d(density, x_bounds, y_bounds):\n    \"\"\"\n    Calculate center of mass (x̄, ȳ) where:\n    x̄ = (1/M) ∫∫ x ρ(x,y) dA\n    ȳ = (1/M) ∫∫ y ρ(x,y) dA\n    M = ∫∫ ρ(x,y) dA\n\n    Args:\n        density: Density function ρ(x, y)\n        x_bounds: (a, b)\n        y_bounds: (c, d)\n    Returns:\n        Tuple (x_bar, y_bar)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef center_of_mass_2d(density, x_bounds, y_bounds):\n    \"\"\"\n    Calculate center of mass (x̄, ȳ).\n    \"\"\"\n    # Total mass\n    M, _ = integrate.dblquad(density,\n                              x_bounds[0], x_bounds[1],\n                              y_bounds[0], y_bounds[1])\n\n    # Moment about y-axis (M_y = ∫∫ x ρ dA)\n    M_y, _ = integrate.dblquad(lambda y, x: x * density(y, x),\n                                x_bounds[0], x_bounds[1],\n                                y_bounds[0], y_bounds[1])\n\n    # Moment about x-axis (M_x = ∫∫ y ρ dA)\n    M_x, _ = integrate.dblquad(lambda y, x: y * density(y, x),\n                                x_bounds[0], x_bounds[1],\n                                y_bounds[0], y_bounds[1])\n\n    x_bar = M_y / M\n    y_bar = M_x / M\n\n    return (x_bar, y_bar)",
    "testCases": [
      {
        "input": "center_of_mass_2d(lambda y, x: 1, (0, 2), (0, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "center_of_mass_2d(lambda y, x: 1, (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "tuple(round(c, 5) for c in center_of_mass_2d(lambda y, x: x+1, (0, 2), (0, 2)))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "First calculate total mass M = ∫∫ ρ dA",
      "x̄ = M_y / M where M_y = ∫∫ x ρ dA",
      "ȳ = M_x / M where M_x = ∫∫ y ρ dA"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Moment of Inertia",
    "difficulty": 5,
    "description": "Calculate the moment of inertia of a 2D plate about the origin.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef moment_of_inertia(density, x_bounds, y_bounds):\n    \"\"\"\n    Calculate moment of inertia about origin: I_0 = ∫∫ (x²+y²) ρ(x,y) dA\n\n    Args:\n        density: Density function ρ(x, y)\n        x_bounds: (a, b)\n        y_bounds: (c, d)\n    Returns:\n        Moment of inertia about the origin\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef moment_of_inertia(density, x_bounds, y_bounds):\n    \"\"\"\n    Calculate moment of inertia about origin: I_0 = ∫∫ (x²+y²) ρ(x,y) dA\n    \"\"\"\n    integrand = lambda y, x: (x**2 + y**2) * density(y, x)\n    result, _ = integrate.dblquad(integrand,\n                                   x_bounds[0], x_bounds[1],\n                                   y_bounds[0], y_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "moment_of_inertia(lambda y, x: 1, (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(moment_of_inertia(lambda y, x: 1, (-1, 1), (-1, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(moment_of_inertia(lambda y, x: x+y+1, (0, 1), (0, 1)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Moment of inertia measures resistance to rotation",
      "I_0 = ∫∫ r² ρ dA where r² = x² + y²",
      "Multiply distance squared by density and integrate"
    ],
    "language": "python"
  },
  {
    "id": "math301-t5-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-5",
    "title": "Average Value of Function",
    "difficulty": 3,
    "description": "Calculate the average value of a function over a region.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef average_value(f, x_bounds, y_bounds):\n    \"\"\"\n    Calculate average value: f_avg = (1/A) ∫∫ f(x,y) dA\n    where A is the area of the region.\n\n    Args:\n        f: Function f(x, y)\n        x_bounds: (a, b)\n        y_bounds: (c, d) or functions for bounds\n    Returns:\n        Average value of f over the region\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef average_value(f, x_bounds, y_bounds):\n    \"\"\"\n    Calculate average value: f_avg = (1/A) ∫∫ f(x,y) dA\n    \"\"\"\n    # Calculate area\n    if callable(y_bounds[0]):\n        # General region\n        area, _ = integrate.dblquad(lambda y, x: 1,\n                                     x_bounds[0], x_bounds[1],\n                                     y_bounds[0], y_bounds[1])\n        integral, _ = integrate.dblquad(f,\n                                         x_bounds[0], x_bounds[1],\n                                         y_bounds[0], y_bounds[1])\n    else:\n        # Rectangle\n        area = (x_bounds[1] - x_bounds[0]) * (y_bounds[1] - y_bounds[0])\n        integral, _ = integrate.dblquad(f,\n                                         x_bounds[0], x_bounds[1],\n                                         y_bounds[0], y_bounds[1])\n\n    return integral / area",
    "testCases": [
      {
        "input": "average_value(lambda y, x: x+y, (0, 2), (0, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "average_value(lambda y, x: x*y, (0, 1), (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "average_value(lambda y, x: 5, (0, 3), (0, 4))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Average = (Total integral) / (Area)",
      "For rectangles, area = (b-a)(d-c)",
      "For general regions, calculate area with ∫∫ 1 dA"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Scalar Line Integral",
    "difficulty": 1,
    "description": "Compute a line integral of a scalar function ∫_C f ds along a parametric curve.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef scalar_line_integral(f, r, t_bounds, n_points=1000):\n    \"\"\"\n    Compute ∫_C f(x,y) ds where C is parametrized by r(t).\n\n    Args:\n        f: Scalar function f(x, y)\n        r: Parametric curve r(t) returns [x(t), y(t)]\n        t_bounds: (t_min, t_max)\n        n_points: Number of points for discretization\n    Returns:\n        Value of the line integral\n    \"\"\"\n    # Your implementation here\n    # Remember: ds = |r'(t)| dt\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef scalar_line_integral(f, r, t_bounds, n_points=1000):\n    \"\"\"\n    Compute ∫_C f(x,y) ds where C is parametrized by r(t).\n    \"\"\"\n    def integrand(t):\n        # Get position\n        pos = r(t)\n        x, y = pos[0], pos[1]\n\n        # Compute derivative numerically\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(len(pos))]\n\n        # Magnitude of derivative\n        ds_dt = np.sqrt(sum(comp**2 for comp in dr_dt))\n\n        return f(x, y) * ds_dt\n\n    result, _ = integrate.quad(integrand, t_bounds[0], t_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(scalar_line_integral(lambda x, y: 1, lambda t: [t, 0], (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(scalar_line_integral(lambda x, y: x+y, lambda t: [t, t], (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(scalar_line_integral(lambda x, y: x**2+y**2, lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "ds = |r'(t)| dt is the arc length element",
      "Compute r'(t) numerically using finite differences",
      "|r'(t)| = √((dx/dt)² + (dy/dt)²)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Arc Length",
    "difficulty": 1,
    "description": "Calculate the arc length of a parametric curve using line integrals.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef arc_length(r, t_bounds):\n    \"\"\"\n    Compute arc length L = ∫_C ds = ∫ |r'(t)| dt\n\n    Args:\n        r: Parametric curve r(t) returns [x(t), y(t)]\n        t_bounds: (t_min, t_max)\n    Returns:\n        Arc length of the curve\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef arc_length(r, t_bounds):\n    \"\"\"\n    Compute arc length L = ∫_C ds = ∫ |r'(t)| dt\n    \"\"\"\n    def integrand(t):\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(len(r_plus))]\n        return np.sqrt(sum(comp**2 for comp in dr_dt))\n\n    result, _ = integrate.quad(integrand, t_bounds[0], t_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(arc_length(lambda t: [t, 0], (0, 5)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(arc_length(lambda t: [np.cos(t), np.sin(t)], (0, np.pi)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(arc_length(lambda t: [t, t**2], (0, 1)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Arc length is the integral of the speed |r'(t)|",
      "For a circle of radius R, arc length = Rθ",
      "Use numerical differentiation for r'(t)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Vector Line Integral",
    "difficulty": 2,
    "description": "Compute a line integral of a vector field ∫_C F·dr.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef vector_line_integral(F, r, t_bounds):\n    \"\"\"\n    Compute ∫_C F·dr where F is a vector field and C is parametrized by r(t).\n\n    Args:\n        F: Vector field F(x, y) returns [F_x, F_y]\n        r: Parametric curve r(t) returns [x(t), y(t)]\n        t_bounds: (t_min, t_max)\n    Returns:\n        Value of the line integral\n    \"\"\"\n    # Your implementation here\n    # Remember: F·dr = F·(dr/dt) dt\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef vector_line_integral(F, r, t_bounds):\n    \"\"\"\n    Compute ∫_C F·dr where F is a vector field and C is parametrized by r(t).\n    \"\"\"\n    def integrand(t):\n        # Get position\n        pos = r(t)\n        x, y = pos[0], pos[1]\n\n        # Get field value\n        field = F(x, y)\n\n        # Compute dr/dt numerically\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(len(pos))]\n\n        # Dot product F · (dr/dt)\n        dot_product = sum(field[i] * dr_dt[i] for i in range(len(field)))\n        return dot_product\n\n    result, _ = integrate.quad(integrand, t_bounds[0], t_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "vector_line_integral(lambda x, y: [1, 0], lambda t: [t, 0], (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "vector_line_integral(lambda x, y: [y, x], lambda t: [t, t], (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(vector_line_integral(lambda x, y: [-y, x], lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Line integral: ∫_C F·dr = ∫ F·(dr/dt) dt",
      "Compute the dot product F(r(t)) · r'(t)",
      "Integrate the scalar result over the parameter interval"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Work Done by Force Field",
    "difficulty": 2,
    "description": "Calculate the work done by a force field along a path.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef work_done(F, r, t_bounds):\n    \"\"\"\n    Calculate work W = ∫_C F·dr done by force F along path r(t).\n\n    Args:\n        F: Force field F(x, y) returns [F_x, F_y]\n        r: Path r(t) returns [x(t), y(t)]\n        t_bounds: (t_min, t_max)\n    Returns:\n        Work done by the force\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef work_done(F, r, t_bounds):\n    \"\"\"\n    Calculate work W = ∫_C F·dr done by force F along path r(t).\n    \"\"\"\n    def integrand(t):\n        pos = r(t)\n        x, y = pos[0], pos[1]\n        field = F(x, y)\n\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(len(pos))]\n\n        return sum(field[i] * dr_dt[i] for i in range(len(field)))\n\n    result, _ = integrate.quad(integrand, t_bounds[0], t_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "work_done(lambda x, y: [1, 1], lambda t: [t, t], (0, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "work_done(lambda x, y: [x, y], lambda t: [t, 0], (0, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(work_done(lambda x, y: [y**2, x**2], lambda t: [np.cos(t), np.sin(t)], (0, np.pi/2)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Work is the line integral of force: W = ∫_C F·dr",
      "Same computation as vector line integral",
      "Positive work means force helps motion, negative means it opposes"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Conservative Field Test",
    "difficulty": 3,
    "description": "Test if a vector field is conservative by checking if ∂P/∂y = ∂Q/∂x.",
    "starterCode": "import numpy as np\n\ndef is_conservative(P, Q, test_points):\n    \"\"\"\n    Test if F = [P, Q] is conservative by checking ∂P/∂y = ∂Q/∂x\n    at multiple test points.\n\n    Args:\n        P: Component function P(x, y)\n        Q: Component function Q(x, y)\n        test_points: List of (x, y) points to test\n    Returns:\n        True if conservative (within tolerance), False otherwise\n    \"\"\"\n    # Your implementation here\n    # Use numerical partial derivatives\n    pass",
    "solution": "import numpy as np\n\ndef is_conservative(P, Q, test_points):\n    \"\"\"\n    Test if F = [P, Q] is conservative by checking ∂P/∂y = ∂Q/∂x.\n    \"\"\"\n    h = 1e-6\n    tolerance = 1e-4\n\n    for x, y in test_points:\n        # ∂P/∂y\n        dP_dy = (P(x, y + h) - P(x, y - h)) / (2 * h)\n\n        # ∂Q/∂x\n        dQ_dx = (Q(x + h, y) - Q(x - h, y)) / (2 * h)\n\n        # Check if equal within tolerance\n        if abs(dP_dy - dQ_dx) > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "is_conservative(lambda x, y: 2*x*y, lambda x, y: x**2, [(0, 0), (1, 1), (2, 3)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_conservative(lambda x, y: y, lambda x, y: -x, [(1, 1), (2, 2)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_conservative(lambda x, y: y, lambda x, y: x, [(0, 1), (1, 0), (1, 1)])",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "A field F = [P, Q] is conservative if ∂P/∂y = ∂Q/∂x",
      "Use central differences for numerical partial derivatives",
      "Check the condition at multiple points for robustness"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Find Potential Function",
    "difficulty": 3,
    "description": "Find a potential function f such that ∇f = F for a conservative field.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef find_potential(P, Q, reference_point=(0, 0)):\n    \"\"\"\n    Find potential function f(x,y) such that ∇f = [P, Q].\n    Returns a function f(x, y).\n\n    Args:\n        P: Component P(x, y) where ∂f/∂x = P\n        Q: Component Q(x, y) where ∂f/∂y = Q\n        reference_point: Point where f = 0\n    Returns:\n        Function f(x, y) such that ∇f = [P, Q]\n    \"\"\"\n    # Your implementation here\n    # Integrate P with respect to x, then add g(y) from integrating Q\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef find_potential(P, Q, reference_point=(0, 0)):\n    \"\"\"\n    Find potential function f(x,y) such that ∇f = [P, Q].\n    \"\"\"\n    x0, y0 = reference_point\n\n    def f(x, y):\n        # Integrate P from x0 to x along y = y0\n        path1, _ = integrate.quad(lambda t: P(t, y0), x0, x)\n\n        # Integrate Q from y0 to y along x = x\n        path2, _ = integrate.quad(lambda t: Q(x, t), y0, y)\n\n        return path1 + path2\n\n    return f",
    "testCases": [
      {
        "input": "f = find_potential(lambda x, y: 2*x, lambda x, y: 2*y); round(f(1, 1), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "f = find_potential(lambda x, y: y, lambda x, y: x); round(f(2, 3), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "f = find_potential(lambda x, y: 2*x*y, lambda x, y: x**2); round(f(2, 2), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "For conservative F, line integral is path-independent",
      "f(x,y) = ∫ P dx + ∫ Q dy along any path from reference to (x,y)",
      "Use a simple L-shaped path: (x0,y0) → (x,y0) → (x,y)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Fundamental Theorem for Line Integrals",
    "difficulty": 3,
    "description": "Use the Fundamental Theorem: ∫_C ∇f·dr = f(B) - f(A) for conservative fields.",
    "starterCode": "import numpy as np\n\ndef line_integral_conservative(f, point_A, point_B):\n    \"\"\"\n    Compute ∫_C ∇f·dr using Fundamental Theorem.\n    For conservative field, integral = f(B) - f(A).\n\n    Args:\n        f: Potential function f(x, y)\n        point_A: Starting point (x_A, y_A)\n        point_B: Ending point (x_B, y_B)\n    Returns:\n        Value of the line integral\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef line_integral_conservative(f, point_A, point_B):\n    \"\"\"\n    Compute ∫_C ∇f·dr using Fundamental Theorem.\n    \"\"\"\n    x_A, y_A = point_A\n    x_B, y_B = point_B\n\n    return f(x_B, y_B) - f(x_A, y_A)",
    "testCases": [
      {
        "input": "line_integral_conservative(lambda x, y: x**2 + y**2, (0, 0), (1, 1))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "line_integral_conservative(lambda x, y: x*y, (1, 2), (3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "line_integral_conservative(lambda x, y: np.sin(x) + np.cos(y), (0, 0), (np.pi/2, np.pi/2))",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Fundamental Theorem: ∫_C ∇f·dr = f(B) - f(A)",
      "The integral is path-independent for conservative fields",
      "Only depends on endpoints, not the path taken"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Parametric Surface",
    "difficulty": 2,
    "description": "Create a parametric representation of a surface and evaluate it at points.",
    "starterCode": "import numpy as np\n\ndef parametric_surface(surface_type, u, v):\n    \"\"\"\n    Return point [x, y, z] on parametric surface at parameters (u, v).\n\n    Args:\n        surface_type: 'plane', 'cylinder', or 'sphere'\n        u: First parameter\n        v: Second parameter\n    Returns:\n        [x, y, z] position on surface\n    \"\"\"\n    # Your implementation here\n    # plane: [u, v, 0]\n    # cylinder (radius 1): [cos(u), sin(u), v]\n    # sphere (radius 1): [sin(v)*cos(u), sin(v)*sin(u), cos(v)]\n    pass",
    "solution": "import numpy as np\n\ndef parametric_surface(surface_type, u, v):\n    \"\"\"\n    Return point [x, y, z] on parametric surface at parameters (u, v).\n    \"\"\"\n    if surface_type == 'plane':\n        return [u, v, 0]\n    elif surface_type == 'cylinder':\n        return [np.cos(u), np.sin(u), v]\n    elif surface_type == 'sphere':\n        return [np.sin(v) * np.cos(u), np.sin(v) * np.sin(u), np.cos(v)]\n    else:\n        raise ValueError(\"Unknown surface type\")",
    "testCases": [
      {
        "input": "parametric_surface(\"plane\", 1, 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[round(x, 5) for x in parametric_surface(\"cylinder\", 0, 1)]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[round(x, 5) for x in parametric_surface(\"sphere\", np.pi/4, np.pi/4)]",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Plane in xy-plane: r(u,v) = [u, v, 0]",
      "Cylinder: r(u,v) = [R cos u, R sin u, v]",
      "Sphere: r(u,v) = [R sin v cos u, R sin v sin u, R cos v]"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Surface Normal Vector",
    "difficulty": 3,
    "description": "Compute the normal vector to a parametric surface using the cross product.",
    "starterCode": "import numpy as np\n\ndef surface_normal(r, u, v):\n    \"\"\"\n    Compute normal vector n = r_u × r_v at point (u, v).\n\n    Args:\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u: First parameter value\n        v: Second parameter value\n    Returns:\n        Normal vector [n_x, n_y, n_z]\n    \"\"\"\n    # Your implementation here\n    # Compute r_u and r_v numerically, then cross product\n    pass",
    "solution": "import numpy as np\n\ndef surface_normal(r, u, v):\n    \"\"\"\n    Compute normal vector n = r_u × r_v at point (u, v).\n    \"\"\"\n    h = 1e-6\n\n    # Compute r_u numerically\n    r_u_plus = r(u + h, v)\n    r_u_minus = r(u - h, v)\n    r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n    # Compute r_v numerically\n    r_v_plus = r(u, v + h)\n    r_v_minus = r(u, v - h)\n    r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n    # Cross product r_u × r_v\n    normal = [\n        r_u[1] * r_v[2] - r_u[2] * r_v[1],\n        r_u[2] * r_v[0] - r_u[0] * r_v[2],\n        r_u[0] * r_v[1] - r_u[1] * r_v[0]\n    ]\n\n    return normal",
    "testCases": [
      {
        "input": "[round(x, 5) for x in surface_normal(lambda u, v: [u, v, 0], 0, 0)]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[round(x, 5) for x in surface_normal(lambda u, v: [np.cos(u), np.sin(u), v], 0, 0)]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Normal vector: n = r_u × r_v",
      "Compute partial derivatives r_u and r_v numerically",
      "Cross product: [a×b]_i = a_j b_k - a_k b_j (cyclic)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Surface Area",
    "difficulty": 4,
    "description": "Compute the surface area using ∫∫ |r_u × r_v| du dv.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef surface_area(r, u_bounds, v_bounds):\n    \"\"\"\n    Compute surface area A = ∫∫ |r_u × r_v| du dv.\n\n    Args:\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u_bounds: (u_min, u_max)\n        v_bounds: (v_min, v_max)\n    Returns:\n        Surface area\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef surface_area(r, u_bounds, v_bounds):\n    \"\"\"\n    Compute surface area A = ∫∫ |r_u × r_v| du dv.\n    \"\"\"\n    def integrand(v, u):\n        h = 1e-6\n\n        # r_u\n        r_u_plus = r(u + h, v)\n        r_u_minus = r(u - h, v)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        # r_v\n        r_v_plus = r(u, v + h)\n        r_v_minus = r(u, v - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        # Cross product\n        cross = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n\n        # Magnitude\n        return np.sqrt(sum(c**2 for c in cross))\n\n    result, _ = integrate.dblquad(integrand,\n                                   u_bounds[0], u_bounds[1],\n                                   v_bounds[0], v_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(surface_area(lambda u, v: [u, v, 0], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(surface_area(lambda u, v: [np.cos(u), np.sin(u), v], (0, 2*np.pi), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Surface area element: dS = |r_u × r_v| du dv",
      "Compute the cross product r_u × r_v",
      "Integrate its magnitude over the parameter domain"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Surface Integral of Scalar",
    "difficulty": 4,
    "description": "Compute a surface integral ∫∫_S f dS of a scalar function.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef scalar_surface_integral(f, r, u_bounds, v_bounds):\n    \"\"\"\n    Compute ∫∫_S f(x,y,z) dS where S is parametrized by r(u,v).\n\n    Args:\n        f: Scalar function f(x, y, z)\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u_bounds: (u_min, u_max)\n        v_bounds: (v_min, v_max)\n    Returns:\n        Value of the surface integral\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef scalar_surface_integral(f, r, u_bounds, v_bounds):\n    \"\"\"\n    Compute ∫∫_S f(x,y,z) dS where S is parametrized by r(u,v).\n    \"\"\"\n    def integrand(v, u):\n        pos = r(u, v)\n        x, y, z = pos[0], pos[1], pos[2]\n\n        h = 1e-6\n\n        # r_u\n        r_u_plus = r(u + h, v)\n        r_u_minus = r(u - h, v)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        # r_v\n        r_v_plus = r(u, v + h)\n        r_v_minus = r(u, v - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        # Cross product magnitude\n        cross = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n        dS = np.sqrt(sum(c**2 for c in cross))\n\n        return f(x, y, z) * dS\n\n    result, _ = integrate.dblquad(integrand,\n                                   u_bounds[0], u_bounds[1],\n                                   v_bounds[0], v_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(scalar_surface_integral(lambda x, y, z: 1, lambda u, v: [u, v, 0], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(scalar_surface_integral(lambda x, y, z: z, lambda u, v: [u, v, u+v], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Surface integral: ∫∫_S f dS = ∫∫ f(r(u,v)) |r_u × r_v| du dv",
      "Evaluate f at the parametric position r(u,v)",
      "Multiply by the surface area element |r_u × r_v|"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Flux Through Surface",
    "difficulty": 4,
    "description": "Compute the flux of a vector field through a surface: ∫∫_S F·n dS.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef flux_through_surface(F, r, u_bounds, v_bounds):\n    \"\"\"\n    Compute flux ∫∫_S F·n dS = ∫∫ F·(r_u × r_v) du dv.\n\n    Args:\n        F: Vector field F(x, y, z) returns [F_x, F_y, F_z]\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u_bounds: (u_min, u_max)\n        v_bounds: (v_min, v_max)\n    Returns:\n        Flux through the surface\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef flux_through_surface(F, r, u_bounds, v_bounds):\n    \"\"\"\n    Compute flux ∫∫_S F·n dS = ∫∫ F·(r_u × r_v) du dv.\n    \"\"\"\n    def integrand(v, u):\n        pos = r(u, v)\n        x, y, z = pos[0], pos[1], pos[2]\n\n        # Get field value\n        field = F(x, y, z)\n\n        h = 1e-6\n\n        # r_u\n        r_u_plus = r(u + h, v)\n        r_u_minus = r(u - h, v)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        # r_v\n        r_v_plus = r(u, v + h)\n        r_v_minus = r(u, v - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        # Normal vector (r_u × r_v)\n        normal = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n\n        # Dot product F · (r_u × r_v)\n        return sum(field[i] * normal[i] for i in range(3))\n\n    result, _ = integrate.dblquad(integrand,\n                                   u_bounds[0], u_bounds[1],\n                                   v_bounds[0], v_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(flux_through_surface(lambda x, y, z: [0, 0, 1], lambda u, v: [u, v, 0], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(flux_through_surface(lambda x, y, z: [x, y, z], lambda u, v: [u, v, 1], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Flux = ∫∫_S F·n̂ dS where n̂ is unit normal",
      "Can write as ∫∫ F·(r_u × r_v) du dv",
      "The normal r_u × r_v includes the dS factor"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Oriented Surface Normal",
    "difficulty": 3,
    "description": "Compute unit normal vector with specified orientation (outward or inward).",
    "starterCode": "import numpy as np\n\ndef oriented_normal(r, u, v, orientation='outward'):\n    \"\"\"\n    Compute unit normal vector with specified orientation.\n\n    Args:\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u: First parameter\n        v: Second parameter\n        orientation: 'outward' or 'inward'\n    Returns:\n        Unit normal vector\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef oriented_normal(r, u, v, orientation='outward'):\n    \"\"\"\n    Compute unit normal vector with specified orientation.\n    \"\"\"\n    h = 1e-6\n\n    # r_u\n    r_u_plus = r(u + h, v)\n    r_u_minus = r(u - h, v)\n    r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n    # r_v\n    r_v_plus = r(u, v + h)\n    r_v_minus = r(u, v - h)\n    r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n    # Normal r_u × r_v\n    normal = [\n        r_u[1] * r_v[2] - r_u[2] * r_v[1],\n        r_u[2] * r_v[0] - r_u[0] * r_v[2],\n        r_u[0] * r_v[1] - r_u[1] * r_v[0]\n    ]\n\n    # Normalize\n    magnitude = np.sqrt(sum(n**2 for n in normal))\n    unit_normal = [n / magnitude for n in normal]\n\n    # Check orientation (for sphere-like surfaces, outward points away from origin)\n    pos = r(u, v)\n    dot_with_position = sum(unit_normal[i] * pos[i] for i in range(3))\n\n    if orientation == 'outward':\n        if dot_with_position < 0:\n            unit_normal = [-n for n in unit_normal]\n    else:  # inward\n        if dot_with_position > 0:\n            unit_normal = [-n for n in unit_normal]\n\n    return unit_normal",
    "testCases": [
      {
        "input": "[round(x, 5) for x in oriented_normal(lambda u, v: [np.sin(v)*np.cos(u), np.sin(v)*np.sin(u), np.cos(v)], 0, np.pi/4, \"outward\")]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[round(x, 5) for x in oriented_normal(lambda u, v: [u, v, 0], 0, 0, \"outward\")]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Compute n = r_u × r_v, then normalize to get unit vector",
      "For closed surfaces, outward normal points away from interior",
      "May need to flip sign: -n instead of n"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Mass of Surface",
    "difficulty": 4,
    "description": "Calculate the mass of a surface with variable density.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef surface_mass(density, r, u_bounds, v_bounds):\n    \"\"\"\n    Calculate mass M = ∫∫_S ρ(x,y,z) dS.\n\n    Args:\n        density: Density function ρ(x, y, z)\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u_bounds: (u_min, u_max)\n        v_bounds: (v_min, v_max)\n    Returns:\n        Total mass of the surface\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef surface_mass(density, r, u_bounds, v_bounds):\n    \"\"\"\n    Calculate mass M = ∫∫_S ρ(x,y,z) dS.\n    \"\"\"\n    def integrand(v, u):\n        pos = r(u, v)\n        x, y, z = pos[0], pos[1], pos[2]\n\n        h = 1e-6\n\n        # r_u\n        r_u_plus = r(u + h, v)\n        r_u_minus = r(u - h, v)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        # r_v\n        r_v_plus = r(u, v + h)\n        r_v_minus = r(u, v - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        # dS\n        cross = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n        dS = np.sqrt(sum(c**2 for c in cross))\n\n        return density(x, y, z) * dS\n\n    result, _ = integrate.dblquad(integrand,\n                                   u_bounds[0], u_bounds[1],\n                                   v_bounds[0], v_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(surface_mass(lambda x, y, z: 1, lambda u, v: [u, v, 0], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(surface_mass(lambda x, y, z: z+1, lambda u, v: [u, v, u+v], (0, 1), (0, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Mass = ∫∫_S ρ dS (surface integral of density)",
      "Same as scalar surface integral with f = ρ",
      "For uniform density ρ = c, mass = c × surface area"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Electric Flux",
    "difficulty": 5,
    "description": "Calculate electric flux through a closed surface (Gauss' law application).",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef electric_flux(charge_density, r, u_bounds, v_bounds):\n    \"\"\"\n    Calculate electric flux for field E due to charge at origin.\n    E = (q / (4πε₀r²)) r̂  (use ε₀ = 1 for simplicity)\n\n    Args:\n        charge_density: Total charge q\n        r: Parametric surface r(u, v) returns [x, y, z]\n        u_bounds: (u_min, u_max)\n        v_bounds: (v_min, v_max)\n    Returns:\n        Electric flux through the surface\n    \"\"\"\n    # Your implementation here\n    # E = (q/(4π)) * (r/|r|³) where r is position vector\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef electric_flux(charge_density, r, u_bounds, v_bounds):\n    \"\"\"\n    Calculate electric flux for field E due to charge at origin.\n    \"\"\"\n    q = charge_density\n\n    def integrand(v_param, u_param):\n        pos = r(u_param, v_param)\n        x, y, z = pos[0], pos[1], pos[2]\n\n        # Electric field E = (q/(4π)) * r/|r|³\n        r_mag = np.sqrt(x**2 + y**2 + z**2)\n        if r_mag < 1e-10:\n            return 0\n        E = [q / (4 * np.pi) * pos[i] / r_mag**3 for i in range(3)]\n\n        h = 1e-6\n\n        # r_u\n        r_u_plus = r(u_param + h, v_param)\n        r_u_minus = r(u_param - h, v_param)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        # r_v\n        r_v_plus = r(u_param, v_param + h)\n        r_v_minus = r(u_param, v_param - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        # Normal\n        normal = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n\n        # E · n\n        return sum(E[i] * normal[i] for i in range(3))\n\n    result, _ = integrate.dblquad(integrand,\n                                   u_bounds[0], u_bounds[1],\n                                   v_bounds[0], v_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(electric_flux(1.0, lambda u, v: [np.sin(v)*np.cos(u), np.sin(v)*np.sin(u), np.cos(v)], (0, 2*np.pi), (0, np.pi)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(electric_flux(2.0, lambda u, v: [2*np.sin(v)*np.cos(u), 2*np.sin(v)*np.sin(u), 2*np.cos(v)], (0, 2*np.pi), (0, np.pi)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Gauss' law: flux through closed surface = q/ε₀",
      "E = (q/(4πε₀)) r̂/r² for point charge",
      "Flux should be independent of sphere radius"
    ],
    "language": "python"
  },
  {
    "id": "math301-t6-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-6",
    "title": "Circulation Around Curve",
    "difficulty": 3,
    "description": "Compute the circulation of a vector field around a closed curve.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef circulation(F, r, t_bounds):\n    \"\"\"\n    Compute circulation ∮_C F·dr around closed curve C.\n\n    Args:\n        F: Vector field F(x, y) returns [F_x, F_y]\n        r: Closed curve r(t) returns [x(t), y(t)]\n        t_bounds: (t_min, t_max) where r(t_min) = r(t_max)\n    Returns:\n        Circulation around the curve\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef circulation(F, r, t_bounds):\n    \"\"\"\n    Compute circulation ∮_C F·dr around closed curve C.\n    \"\"\"\n    def integrand(t):\n        pos = r(t)\n        x, y = pos[0], pos[1]\n        field = F(x, y)\n\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(len(pos))]\n\n        return sum(field[i] * dr_dt[i] for i in range(len(field)))\n\n    result, _ = integrate.quad(integrand, t_bounds[0], t_bounds[1])\n    return result",
    "testCases": [
      {
        "input": "round(circulation(lambda x, y: [-y, x], lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(circulation(lambda x, y: [y, x], lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi)), 10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(circulation(lambda x, y: [x, y], lambda t: [2*np.cos(t), 2*np.sin(t)], (0, 2*np.pi)), 10)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Circulation = ∮_C F·dr (line integral around closed curve)",
      "Related to curl by Green's theorem",
      "For conservative fields, circulation = 0"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex01",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Curl of Vector Field",
    "difficulty": 1,
    "description": "Compute the curl ∇×F of a 3D vector field F = [P, Q, R].",
    "starterCode": "import numpy as np\n\ndef curl_3d(P, Q, R, point):\n    \"\"\"\n    Compute curl of F = [P, Q, R] at a point.\n    curl F = [∂R/∂y - ∂Q/∂z, ∂P/∂z - ∂R/∂x, ∂Q/∂x - ∂P/∂y]\n\n    Args:\n        P: Component P(x, y, z)\n        Q: Component Q(x, y, z)\n        R: Component R(x, y, z)\n        point: (x, y, z) where to evaluate curl\n    Returns:\n        Curl vector [curl_x, curl_y, curl_z]\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef curl_3d(P, Q, R, point):\n    \"\"\"\n    Compute curl of F = [P, Q, R] at a point.\n    \"\"\"\n    x, y, z = point\n    h = 1e-6\n\n    # ∂R/∂y\n    dR_dy = (R(x, y + h, z) - R(x, y - h, z)) / (2 * h)\n\n    # ∂Q/∂z\n    dQ_dz = (Q(x, y, z + h) - Q(x, y, z - h)) / (2 * h)\n\n    # ∂P/∂z\n    dP_dz = (P(x, y, z + h) - P(x, y, z - h)) / (2 * h)\n\n    # ∂R/∂x\n    dR_dx = (R(x + h, y, z) - R(x - h, y, z)) / (2 * h)\n\n    # ∂Q/∂x\n    dQ_dx = (Q(x + h, y, z) - Q(x - h, y, z)) / (2 * h)\n\n    # ∂P/∂y\n    dP_dy = (P(x, y + h, z) - P(x, y - h, z)) / (2 * h)\n\n    curl = [\n        dR_dy - dQ_dz,\n        dP_dz - dR_dx,\n        dQ_dx - dP_dy\n    ]\n\n    return curl",
    "testCases": [
      {
        "input": "[round(x, 5) for x in curl_3d(lambda x,y,z: 0, lambda x,y,z: 0, lambda x,y,z: 0, (1, 1, 1))]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[round(x, 5) for x in curl_3d(lambda x,y,z: -y, lambda x,y,z: x, lambda x,y,z: 0, (0, 0, 0))]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[round(x, 5) for x in curl_3d(lambda x,y,z: y*z, lambda x,y,z: x*z, lambda x,y,z: x*y, (1, 1, 1))]",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "curl F = ∇×F = [∂R/∂y - ∂Q/∂z, ∂P/∂z - ∂R/∂x, ∂Q/∂x - ∂P/∂y]",
      "Use numerical partial derivatives",
      "Curl measures rotation of the field"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex02",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Divergence of Vector Field",
    "difficulty": 1,
    "description": "Compute the divergence ∇·F of a vector field F = [P, Q, R].",
    "starterCode": "import numpy as np\n\ndef divergence_3d(P, Q, R, point):\n    \"\"\"\n    Compute divergence of F = [P, Q, R] at a point.\n    div F = ∂P/∂x + ∂Q/∂y + ∂R/∂z\n\n    Args:\n        P: Component P(x, y, z)\n        Q: Component Q(x, y, z)\n        R: Component R(x, y, z)\n        point: (x, y, z) where to evaluate divergence\n    Returns:\n        Divergence (scalar)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef divergence_3d(P, Q, R, point):\n    \"\"\"\n    Compute divergence of F = [P, Q, R] at a point.\n    \"\"\"\n    x, y, z = point\n    h = 1e-6\n\n    # ∂P/∂x\n    dP_dx = (P(x + h, y, z) - P(x - h, y, z)) / (2 * h)\n\n    # ∂Q/∂y\n    dQ_dy = (Q(x, y + h, z) - Q(x, y - h, z)) / (2 * h)\n\n    # ∂R/∂z\n    dR_dz = (R(x, y, z + h) - R(x, y, z - h)) / (2 * h)\n\n    return dP_dx + dQ_dy + dR_dz",
    "testCases": [
      {
        "input": "round(divergence_3d(lambda x,y,z: x, lambda x,y,z: y, lambda x,y,z: z, (0, 0, 0)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(divergence_3d(lambda x,y,z: x**2, lambda x,y,z: y**2, lambda x,y,z: z**2, (1, 1, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(divergence_3d(lambda x,y,z: -y, lambda x,y,z: x, lambda x,y,z: 0, (1, 1, 1)), 10)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "div F = ∇·F = ∂P/∂x + ∂Q/∂y + ∂R/∂z",
      "Divergence measures \"outflow\" from a point",
      "Positive divergence = source, negative = sink"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex03",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Curl in 2D",
    "difficulty": 2,
    "description": "Compute the scalar curl of a 2D vector field F = [P, Q].",
    "starterCode": "import numpy as np\n\ndef curl_2d(P, Q, point):\n    \"\"\"\n    Compute scalar curl of 2D field F = [P, Q].\n    curl F = ∂Q/∂x - ∂P/∂y\n\n    Args:\n        P: Component P(x, y)\n        Q: Component Q(x, y)\n        point: (x, y) where to evaluate\n    Returns:\n        Scalar curl value\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef curl_2d(P, Q, point):\n    \"\"\"\n    Compute scalar curl of 2D field F = [P, Q].\n    \"\"\"\n    x, y = point\n    h = 1e-6\n\n    # ∂Q/∂x\n    dQ_dx = (Q(x + h, y) - Q(x - h, y)) / (2 * h)\n\n    # ∂P/∂y\n    dP_dy = (P(x, y + h) - P(x, y - h)) / (2 * h)\n\n    return dQ_dx - dP_dy",
    "testCases": [
      {
        "input": "round(curl_2d(lambda x, y: -y, lambda x, y: x, (0, 0)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(curl_2d(lambda x, y: y, lambda x, y: x, (1, 1)), 10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(curl_2d(lambda x, y: x*y, lambda x, y: x**2, (2, 1)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "In 2D, curl is a scalar: ∂Q/∂x - ∂P/∂y",
      "This is the k-component of curl if F = [P, Q, 0]",
      "Measures counterclockwise rotation"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex04",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Test for Irrotational Field",
    "difficulty": 2,
    "description": "Check if a vector field is irrotational (curl = 0).",
    "starterCode": "import numpy as np\n\ndef is_irrotational(P, Q, R, test_points):\n    \"\"\"\n    Test if F = [P, Q, R] is irrotational by checking if curl F = 0.\n\n    Args:\n        P, Q, R: Vector field components\n        test_points: List of (x, y, z) points to test\n    Returns:\n        True if irrotational, False otherwise\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef is_irrotational(P, Q, R, test_points):\n    \"\"\"\n    Test if F = [P, Q, R] is irrotational by checking if curl F = 0.\n    \"\"\"\n    h = 1e-6\n    tolerance = 1e-4\n\n    for x, y, z in test_points:\n        # Compute curl components\n        dR_dy = (R(x, y + h, z) - R(x, y - h, z)) / (2 * h)\n        dQ_dz = (Q(x, y, z + h) - Q(x, y, z - h)) / (2 * h)\n\n        dP_dz = (P(x, y, z + h) - P(x, y, z - h)) / (2 * h)\n        dR_dx = (R(x + h, y, z) - R(x - h, y, z)) / (2 * h)\n\n        dQ_dx = (Q(x + h, y, z) - Q(x - h, y, z)) / (2 * h)\n        dP_dy = (P(x, y + h, z) - P(x, y - h, z)) / (2 * h)\n\n        curl = [\n            dR_dy - dQ_dz,\n            dP_dz - dR_dx,\n            dQ_dx - dP_dy\n        ]\n\n        # Check if curl is approximately zero\n        if any(abs(c) > tolerance for c in curl):\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "is_irrotational(lambda x,y,z: y*z, lambda x,y,z: x*z, lambda x,y,z: x*y, [(0,0,0), (1,1,1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_irrotational(lambda x,y,z: -y, lambda x,y,z: x, lambda x,y,z: 0, [(1,1,1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_irrotational(lambda x,y,z: 2*x, lambda x,y,z: 2*y, lambda x,y,z: 2*z, [(1,1,1), (0,0,1)])",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Irrotational means curl F = 0 everywhere",
      "Conservative fields are irrotational",
      "Check all three components of curl"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex05",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Test for Incompressible Field",
    "difficulty": 2,
    "description": "Check if a vector field is incompressible (div = 0).",
    "starterCode": "import numpy as np\n\ndef is_incompressible(P, Q, R, test_points):\n    \"\"\"\n    Test if F = [P, Q, R] is incompressible by checking if div F = 0.\n\n    Args:\n        P, Q, R: Vector field components\n        test_points: List of (x, y, z) points to test\n    Returns:\n        True if incompressible, False otherwise\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef is_incompressible(P, Q, R, test_points):\n    \"\"\"\n    Test if F = [P, Q, R] is incompressible by checking if div F = 0.\n    \"\"\"\n    h = 1e-6\n    tolerance = 1e-4\n\n    for x, y, z in test_points:\n        # Compute divergence\n        dP_dx = (P(x + h, y, z) - P(x - h, y, z)) / (2 * h)\n        dQ_dy = (Q(x, y + h, z) - Q(x, y - h, z)) / (2 * h)\n        dR_dz = (R(x, y, z + h) - R(x, y, z - h)) / (2 * h)\n\n        div = dP_dx + dQ_dy + dR_dz\n\n        if abs(div) > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "is_incompressible(lambda x,y,z: -y, lambda x,y,z: x, lambda x,y,z: 0, [(0,0,0), (1,1,1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_incompressible(lambda x,y,z: x, lambda x,y,z: y, lambda x,y,z: z, [(1,1,1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_incompressible(lambda x,y,z: y, lambda x,y,z: -x, lambda x,y,z: z**2, [(1,1,1), (0,0,1)])",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Incompressible means div F = 0",
      "Fluid with no sources or sinks",
      "Also called solenoidal field"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex06",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Green's Theorem Verification",
    "difficulty": 3,
    "description": "Verify Green's Theorem: ∮_C F·dr = ∫∫_D (∂Q/∂x - ∂P/∂y) dA.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef verify_greens_theorem(P, Q, r, t_bounds, region_bounds):\n    \"\"\"\n    Verify Green's theorem by computing both sides.\n\n    Args:\n        P, Q: Vector field components F = [P, Q]\n        r: Boundary curve r(t) = [x(t), y(t)]\n        t_bounds: (t_min, t_max) for curve\n        region_bounds: ((x_min, x_max), (y_min, y_max)) for rectangular region\n    Returns:\n        Tuple (line_integral, double_integral)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef verify_greens_theorem(P, Q, r, t_bounds, region_bounds):\n    \"\"\"\n    Verify Green's theorem by computing both sides.\n    \"\"\"\n    # Line integral ∮_C F·dr\n    def line_integrand(t):\n        pos = r(t)\n        x, y = pos[0], pos[1]\n        field = [P(x, y), Q(x, y)]\n\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(2)]\n\n        return field[0] * dr_dt[0] + field[1] * dr_dt[1]\n\n    line_integral, _ = integrate.quad(line_integrand, t_bounds[0], t_bounds[1])\n\n    # Double integral ∫∫_D (∂Q/∂x - ∂P/∂y) dA\n    def double_integrand(y, x):\n        h = 1e-6\n        dQ_dx = (Q(x + h, y) - Q(x - h, y)) / (2 * h)\n        dP_dy = (P(x, y + h) - P(x, y - h)) / (2 * h)\n        return dQ_dx - dP_dy\n\n    x_bounds, y_bounds = region_bounds\n    double_integral, _ = integrate.dblquad(double_integrand,\n                                           x_bounds[0], x_bounds[1],\n                                           y_bounds[0], y_bounds[1])\n\n    return (line_integral, double_integral)",
    "testCases": [
      {
        "input": "tuple(round(x, 5) for x in verify_greens_theorem(lambda x,y: 0, lambda x,y: x, lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi), ((-1, 1), (-1, 1))))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "tuple(round(x, 5) for x in verify_greens_theorem(lambda x,y: -y, lambda x,y: x, lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi), ((-1, 1), (-1, 1))))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Green's Theorem: ∮_C P dx + Q dy = ∫∫_D (∂Q/∂x - ∂P/∂y) dA",
      "Compute both the line integral and double integral",
      "They should be equal (within numerical error)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex07",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Area via Green's Theorem",
    "difficulty": 3,
    "description": "Use Green's Theorem to compute area: A = (1/2)∮_C (x dy - y dx).",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef area_greens(r, t_bounds):\n    \"\"\"\n    Compute area enclosed by curve using Green's theorem.\n    A = (1/2) ∮_C (x dy - y dx)\n\n    Args:\n        r: Boundary curve r(t) = [x(t), y(t)]\n        t_bounds: (t_min, t_max)\n    Returns:\n        Area enclosed by the curve\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef area_greens(r, t_bounds):\n    \"\"\"\n    Compute area enclosed by curve using Green's theorem.\n    \"\"\"\n    def integrand(t):\n        pos = r(t)\n        x, y = pos[0], pos[1]\n\n        h = 1e-6\n        r_plus = r(t + h)\n        r_minus = r(t - h)\n        dx_dt = (r_plus[0] - r_minus[0]) / (2 * h)\n        dy_dt = (r_plus[1] - r_minus[1]) / (2 * h)\n\n        # x dy - y dx = x (dy/dt) dt - y (dx/dt) dt\n        return x * dy_dt - y * dx_dt\n\n    result, _ = integrate.quad(integrand, t_bounds[0], t_bounds[1])\n    return abs(result) / 2",
    "testCases": [
      {
        "input": "round(area_greens(lambda t: [np.cos(t), np.sin(t)], (0, 2*np.pi)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(area_greens(lambda t: [2*np.cos(t), 2*np.sin(t)], (0, 2*np.pi)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(area_greens(lambda t: [t, 0] if t <= 1 else [1, t-1] if t <= 2 else [2-t, 1] if t <= 3 else [0, 4-t], (0, 4)), 5)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Green's Theorem: Area = (1/2) ∮_C (x dy - y dx)",
      "Compute x(dy/dt) - y(dx/dt) and integrate",
      "Take absolute value and divide by 2"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex08",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Stokes' Theorem Verification",
    "difficulty": 4,
    "description": "Verify Stokes' Theorem: ∮_C F·dr = ∫∫_S (curl F)·n dS.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef verify_stokes(P, Q, R, boundary_curve, t_bounds, surface, u_bounds, v_bounds):\n    \"\"\"\n    Verify Stokes' theorem by computing both sides.\n\n    Args:\n        P, Q, R: Vector field components\n        boundary_curve: Boundary curve r(t)\n        t_bounds: Parameter bounds for curve\n        surface: Surface S parametrized as r(u, v)\n        u_bounds, v_bounds: Parameter bounds for surface\n    Returns:\n        Tuple (line_integral, surface_integral)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef verify_stokes(P, Q, R, boundary_curve, t_bounds, surface, u_bounds, v_bounds):\n    \"\"\"\n    Verify Stokes' theorem by computing both sides.\n    \"\"\"\n    # Line integral ∮_C F·dr\n    def line_integrand(t):\n        pos = boundary_curve(t)\n        x, y, z = pos[0], pos[1], pos[2]\n        field = [P(x, y, z), Q(x, y, z), R(x, y, z)]\n\n        h = 1e-6\n        r_plus = boundary_curve(t + h)\n        r_minus = boundary_curve(t - h)\n        dr_dt = [(r_plus[i] - r_minus[i]) / (2 * h) for i in range(3)]\n\n        return sum(field[i] * dr_dt[i] for i in range(3))\n\n    line_integral, _ = integrate.quad(line_integrand, t_bounds[0], t_bounds[1])\n\n    # Surface integral ∫∫_S (curl F)·n dS\n    def surface_integrand(v, u):\n        pos = surface(u, v)\n        x, y, z = pos[0], pos[1], pos[2]\n\n        h = 1e-6\n\n        # Compute curl at this point\n        dR_dy = (R(x, y + h, z) - R(x, y - h, z)) / (2 * h)\n        dQ_dz = (Q(x, y, z + h) - Q(x, y, z - h)) / (2 * h)\n        dP_dz = (P(x, y, z + h) - P(x, y, z - h)) / (2 * h)\n        dR_dx = (R(x + h, y, z) - R(x - h, y, z)) / (2 * h)\n        dQ_dx = (Q(x + h, y, z) - Q(x - h, y, z)) / (2 * h)\n        dP_dy = (P(x, y + h, z) - P(x, y - h, z)) / (2 * h)\n\n        curl = [dR_dy - dQ_dz, dP_dz - dR_dx, dQ_dx - dP_dy]\n\n        # Compute normal r_u × r_v\n        r_u_plus = surface(u + h, v)\n        r_u_minus = surface(u - h, v)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        r_v_plus = surface(u, v + h)\n        r_v_minus = surface(u, v - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        normal = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n\n        return sum(curl[i] * normal[i] for i in range(3))\n\n    surface_integral, _ = integrate.dblquad(surface_integrand,\n                                            u_bounds[0], u_bounds[1],\n                                            v_bounds[0], v_bounds[1])\n\n    return (line_integral, surface_integral)",
    "testCases": [
      {
        "input": "tuple(round(x, 5) for x in verify_stokes(lambda x,y,z: -y, lambda x,y,z: x, lambda x,y,z: 0, lambda t: [np.cos(t), np.sin(t), 0], (0, 2*np.pi), lambda u,v: [u*np.cos(v), u*np.sin(v), 0], (0, 1), (0, 2*np.pi)))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Stokes' Theorem: ∮_C F·dr = ∫∫_S (∇×F)·n dS",
      "Compute line integral around boundary",
      "Compute surface integral of curl dotted with normal"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex09",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Divergence Theorem Verification",
    "difficulty": 4,
    "description": "Verify Divergence Theorem: ∫∫∫_V (div F) dV = ∫∫_S F·n dS.",
    "starterCode": "import numpy as np\nfrom scipy import integrate\n\ndef verify_divergence_theorem(P, Q, R, volume_bounds, surface, u_bounds, v_bounds):\n    \"\"\"\n    Verify Divergence Theorem by computing both sides.\n\n    Args:\n        P, Q, R: Vector field components\n        volume_bounds: ((x_min, x_max), (y_min, y_max), (z_min, z_max))\n        surface: Closed surface parametrization r(u, v)\n        u_bounds, v_bounds: Parameter bounds\n    Returns:\n        Tuple (volume_integral, surface_integral)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\nfrom scipy import integrate\n\ndef verify_divergence_theorem(P, Q, R, volume_bounds, surface, u_bounds, v_bounds):\n    \"\"\"\n    Verify Divergence Theorem by computing both sides.\n    \"\"\"\n    # Volume integral ∫∫∫_V (div F) dV\n    def volume_integrand(z, y, x):\n        h = 1e-6\n        dP_dx = (P(x + h, y, z) - P(x - h, y, z)) / (2 * h)\n        dQ_dy = (Q(x, y + h, z) - Q(x, y - h, z)) / (2 * h)\n        dR_dz = (R(x, y, z + h) - R(x, y, z - h)) / (2 * h)\n        return dP_dx + dQ_dy + dR_dz\n\n    x_bounds, y_bounds, z_bounds = volume_bounds\n    volume_integral, _ = integrate.tplquad(volume_integrand,\n                                           x_bounds[0], x_bounds[1],\n                                           y_bounds[0], y_bounds[1],\n                                           z_bounds[0], z_bounds[1])\n\n    # Surface integral ∫∫_S F·n dS\n    def surface_integrand(v, u):\n        pos = surface(u, v)\n        x, y, z = pos[0], pos[1], pos[2]\n        field = [P(x, y, z), Q(x, y, z), R(x, y, z)]\n\n        h = 1e-6\n\n        r_u_plus = surface(u + h, v)\n        r_u_minus = surface(u - h, v)\n        r_u = [(r_u_plus[i] - r_u_minus[i]) / (2 * h) for i in range(3)]\n\n        r_v_plus = surface(u, v + h)\n        r_v_minus = surface(u, v - h)\n        r_v = [(r_v_plus[i] - r_v_minus[i]) / (2 * h) for i in range(3)]\n\n        # Outward normal\n        normal = [\n            r_u[1] * r_v[2] - r_u[2] * r_v[1],\n            r_u[2] * r_v[0] - r_u[0] * r_v[2],\n            r_u[0] * r_v[1] - r_u[1] * r_v[0]\n        ]\n\n        return sum(field[i] * normal[i] for i in range(3))\n\n    surface_integral, _ = integrate.dblquad(surface_integrand,\n                                            u_bounds[0], u_bounds[1],\n                                            v_bounds[0], v_bounds[1])\n\n    return (volume_integral, surface_integral)",
    "testCases": [
      {
        "input": "tuple(round(x, 5) for x in verify_divergence_theorem(lambda x,y,z: x, lambda x,y,z: y, lambda x,y,z: z, ((-1, 1), (-1, 1), (-1, 1)), lambda u,v: [np.sin(v)*np.cos(u), np.sin(v)*np.sin(u), np.cos(v)], (0, 2*np.pi), (0, np.pi)))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Divergence Theorem: ∫∫∫_V (∇·F) dV = ∫∫_S F·n̂ dS",
      "Compute triple integral of divergence over volume",
      "Compute flux through closed surface"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex10",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Laplacian Operator",
    "difficulty": 3,
    "description": "Compute the Laplacian ∇²f = ∂²f/∂x² + ∂²f/∂y² + ∂²f/∂z² of a scalar function.",
    "starterCode": "import numpy as np\n\ndef laplacian(f, point):\n    \"\"\"\n    Compute Laplacian ∇²f at a point.\n\n    Args:\n        f: Scalar function f(x, y, z)\n        point: (x, y, z) where to evaluate\n    Returns:\n        Laplacian value\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef laplacian(f, point):\n    \"\"\"\n    Compute Laplacian ∇²f at a point.\n    \"\"\"\n    x, y, z = point\n    h = 1e-5\n\n    # ∂²f/∂x²\n    d2f_dx2 = (f(x + h, y, z) - 2 * f(x, y, z) + f(x - h, y, z)) / h**2\n\n    # ∂²f/∂y²\n    d2f_dy2 = (f(x, y + h, z) - 2 * f(x, y, z) + f(x, y - h, z)) / h**2\n\n    # ∂²f/∂z²\n    d2f_dz2 = (f(x, y, z + h) - 2 * f(x, y, z) + f(x, y, z - h)) / h**2\n\n    return d2f_dx2 + d2f_dy2 + d2f_dz2",
    "testCases": [
      {
        "input": "round(laplacian(lambda x, y, z: x**2 + y**2 + z**2, (0, 0, 0)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(laplacian(lambda x, y, z: x**3 + y**3 + z**3, (1, 1, 1)), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(laplacian(lambda x, y, z: np.sin(x) + np.cos(y) + z, (0, 0, 0)), 10)",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Laplacian: ∇²f = ∂²f/∂x² + ∂²f/∂y² + ∂²f/∂z²",
      "Use second-order finite differences",
      "Also written as div(grad f)"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex11",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Harmonic Function Test",
    "difficulty": 3,
    "description": "Test if a function is harmonic (∇²f = 0).",
    "starterCode": "import numpy as np\n\ndef is_harmonic(f, test_points):\n    \"\"\"\n    Test if f is harmonic by checking if ∇²f = 0.\n\n    Args:\n        f: Scalar function f(x, y, z)\n        test_points: List of (x, y, z) points to test\n    Returns:\n        True if harmonic, False otherwise\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef is_harmonic(f, test_points):\n    \"\"\"\n    Test if f is harmonic by checking if ∇²f = 0.\n    \"\"\"\n    h = 1e-5\n    tolerance = 1e-3\n\n    for x, y, z in test_points:\n        # Compute Laplacian\n        d2f_dx2 = (f(x + h, y, z) - 2 * f(x, y, z) + f(x - h, y, z)) / h**2\n        d2f_dy2 = (f(x, y + h, z) - 2 * f(x, y, z) + f(x, y - h, z)) / h**2\n        d2f_dz2 = (f(x, y, z + h) - 2 * f(x, y, z) + f(x, y, z - h)) / h**2\n\n        laplacian = d2f_dx2 + d2f_dy2 + d2f_dz2\n\n        if abs(laplacian) > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "is_harmonic(lambda x, y, z: x**2 - y**2, [(1, 1, 0), (2, 1, 0)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_harmonic(lambda x, y, z: x**2 + y**2 + z**2, [(1, 1, 1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_harmonic(lambda x, y, z: x*y*z, [(1, 1, 1), (0, 0, 1)])",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Harmonic function: ∇²f = 0",
      "Common in physics (gravitational/electric potential)",
      "Check Laplacian at multiple points"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex12",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Vector Identity: div(curl F)",
    "difficulty": 4,
    "description": "Verify the identity div(curl F) = 0 for any vector field.",
    "starterCode": "import numpy as np\n\ndef verify_div_curl_zero(P, Q, R, test_points):\n    \"\"\"\n    Verify that div(curl F) = 0 for F = [P, Q, R].\n\n    Args:\n        P, Q, R: Vector field components\n        test_points: List of (x, y, z) points to test\n    Returns:\n        True if div(curl F) ≈ 0 at all test points\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef verify_div_curl_zero(P, Q, R, test_points):\n    \"\"\"\n    Verify that div(curl F) = 0 for F = [P, Q, R].\n    \"\"\"\n    h = 1e-6\n    tolerance = 1e-4\n\n    for x, y, z in test_points:\n        # First compute curl F\n        dR_dy = (R(x, y + h, z) - R(x, y - h, z)) / (2 * h)\n        dQ_dz = (Q(x, y, z + h) - Q(x, y, z - h)) / (2 * h)\n        curl_x = dR_dy - dQ_dz\n\n        dP_dz = (P(x, y, z + h) - P(x, y, z - h)) / (2 * h)\n        dR_dx = (R(x + h, y, z) - R(x - h, y, z)) / (2 * h)\n        curl_y = dP_dz - dR_dx\n\n        dQ_dx = (Q(x + h, y, z) - Q(x - h, y, z)) / (2 * h)\n        dP_dy = (P(x, y + h, z) - P(x, y - h, z)) / (2 * h)\n        curl_z = dQ_dx - dP_dy\n\n        # Now compute divergence of curl\n        # Need to treat curl as a vector field and compute its divergence\n        # This requires second derivatives, but mathematically div(curl F) = 0 always\n\n        # Simplified: compute ∂(curl_x)/∂x + ∂(curl_y)/∂y + ∂(curl_z)/∂z numerically\n        # at this point, which should be 0\n\n        # For verification, we can compute curl at nearby points\n        def curl_component(comp_idx, px, py, pz):\n            if comp_idx == 0:\n                dR_dy_p = (R(px, py + h, pz) - R(px, py - h, pz)) / (2 * h)\n                dQ_dz_p = (Q(px, py, pz + h) - Q(px, py, pz - h)) / (2 * h)\n                return dR_dy_p - dQ_dz_p\n            elif comp_idx == 1:\n                dP_dz_p = (P(px, py, pz + h) - P(px, py, pz - h)) / (2 * h)\n                dR_dx_p = (R(px + h, py, pz) - R(px - h, py, pz)) / (2 * h)\n                return dP_dz_p - dR_dx_p\n            else:\n                dQ_dx_p = (Q(px + h, py, pz) - Q(px - h, py, pz)) / (2 * h)\n                dP_dy_p = (P(px, py + h, pz) - P(px, py - h, pz)) / (2 * h)\n                return dQ_dx_p - dP_dy_p\n\n        # Compute divergence of curl\n        dcurl_x_dx = (curl_component(0, x + h, y, z) - curl_component(0, x - h, y, z)) / (2 * h)\n        dcurl_y_dy = (curl_component(1, x, y + h, z) - curl_component(1, x, y - h, z)) / (2 * h)\n        dcurl_z_dz = (curl_component(2, x, y, z + h) - curl_component(2, x, y, z - h)) / (2 * h)\n\n        div_curl = dcurl_x_dx + dcurl_y_dy + dcurl_z_dz\n\n        if abs(div_curl) > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "verify_div_curl_zero(lambda x,y,z: x*y, lambda x,y,z: y*z, lambda x,y,z: x*z, [(1, 1, 1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "verify_div_curl_zero(lambda x,y,z: x**2, lambda x,y,z: y**2, lambda x,y,z: z**2, [(0, 0, 0), (1, 1, 1)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Mathematical identity: ∇·(∇×F) = 0 always",
      "Curl produces a field with zero divergence",
      "Consequence of mixed partial derivatives commuting"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex13",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Vector Identity: curl(grad f)",
    "difficulty": 4,
    "description": "Verify the identity curl(grad f) = 0 for any scalar function.",
    "starterCode": "import numpy as np\n\ndef verify_curl_grad_zero(f, test_points):\n    \"\"\"\n    Verify that curl(∇f) = 0 for scalar function f.\n\n    Args:\n        f: Scalar function f(x, y, z)\n        test_points: List of (x, y, z) points to test\n    Returns:\n        True if curl(grad f) ≈ 0 at all test points\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef verify_curl_grad_zero(f, test_points):\n    \"\"\"\n    Verify that curl(∇f) = 0 for scalar function f.\n    \"\"\"\n    h = 1e-6\n    tolerance = 1e-4\n\n    for x, y, z in test_points:\n        # Gradient components (these become P, Q, R)\n        # P = ∂f/∂x, Q = ∂f/∂y, R = ∂f/∂z\n\n        # Curl of gradient:\n        # curl_x = ∂R/∂y - ∂Q/∂z = ∂²f/∂y∂z - ∂²f/∂z∂y = 0\n        # curl_y = ∂P/∂z - ∂R/∂x = ∂²f/∂z∂x - ∂²f/∂x∂z = 0\n        # curl_z = ∂Q/∂x - ∂P/∂y = ∂²f/∂x∂y - ∂²f/∂y∂x = 0\n\n        # Compute mixed partials\n        # ∂²f/∂y∂z\n        d2f_dydz = (f(x, y + h, z + h) - f(x, y + h, z - h) - f(x, y - h, z + h) + f(x, y - h, z - h)) / (4 * h**2)\n\n        # ∂²f/∂z∂y\n        d2f_dzdy = (f(x, y + h, z + h) - f(x, y - h, z + h) - f(x, y + h, z - h) + f(x, y - h, z - h)) / (4 * h**2)\n\n        curl_x = d2f_dydz - d2f_dzdy\n\n        # ∂²f/∂z∂x\n        d2f_dzdx = (f(x + h, y, z + h) - f(x - h, y, z + h) - f(x + h, y, z - h) + f(x - h, y, z - h)) / (4 * h**2)\n\n        # ∂²f/∂x∂z\n        d2f_dxdz = (f(x + h, y, z + h) - f(x + h, y, z - h) - f(x - h, y, z + h) + f(x - h, y, z - h)) / (4 * h**2)\n\n        curl_y = d2f_dzdx - d2f_dxdz\n\n        # ∂²f/∂x∂y\n        d2f_dxdy = (f(x + h, y + h, z) - f(x + h, y - h, z) - f(x - h, y + h, z) + f(x - h, y - h, z)) / (4 * h**2)\n\n        # ∂²f/∂y∂x\n        d2f_dydx = (f(x + h, y + h, z) - f(x - h, y + h, z) - f(x + h, y - h, z) + f(x - h, y - h, z)) / (4 * h**2)\n\n        curl_z = d2f_dxdy - d2f_dydx\n\n        curl_magnitude = np.sqrt(curl_x**2 + curl_y**2 + curl_z**2)\n\n        if curl_magnitude > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "verify_curl_grad_zero(lambda x, y, z: x**2 + y**2 + z**2, [(1, 1, 1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "verify_curl_grad_zero(lambda x, y, z: x*y*z, [(0, 0, 0), (1, 1, 1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "verify_curl_grad_zero(lambda x, y, z: np.sin(x) * np.cos(y) * z, [(1, 1, 1)])",
        "isHidden": true,
        "description": "Hidden test"
      }
    ],
    "hints": [
      "Mathematical identity: ∇×(∇f) = 0 always",
      "Conservative fields have zero curl",
      "Mixed partials commute: ∂²f/∂x∂y = ∂²f/∂y∂x"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex14",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Maxwell's Equation: Gauss's Law",
    "difficulty": 5,
    "description": "Verify Gauss's law for electric field: ∇·E = ρ/ε₀.",
    "starterCode": "import numpy as np\n\ndef verify_gauss_law(E_x, E_y, E_z, charge_density, test_points, epsilon_0=1.0):\n    \"\"\"\n    Verify Gauss's law: ∇·E = ρ/ε₀\n\n    Args:\n        E_x, E_y, E_z: Electric field components\n        charge_density: Function ρ(x, y, z)\n        test_points: List of (x, y, z) points to test\n        epsilon_0: Permittivity constant (default 1.0)\n    Returns:\n        True if law holds at all test points\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef verify_gauss_law(E_x, E_y, E_z, charge_density, test_points, epsilon_0=1.0):\n    \"\"\"\n    Verify Gauss's law: ∇·E = ρ/ε₀\n    \"\"\"\n    h = 1e-6\n    tolerance = 1e-3\n\n    for x, y, z in test_points:\n        # Compute divergence of E\n        dEx_dx = (E_x(x + h, y, z) - E_x(x - h, y, z)) / (2 * h)\n        dEy_dy = (E_y(x, y + h, z) - E_y(x, y - h, z)) / (2 * h)\n        dEz_dz = (E_z(x, y, z + h) - E_z(x, y, z - h)) / (2 * h)\n\n        div_E = dEx_dx + dEy_dy + dEz_dz\n\n        # Compute ρ/ε₀\n        rho_over_epsilon = charge_density(x, y, z) / epsilon_0\n\n        # Check if they are equal\n        if abs(div_E - rho_over_epsilon) > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "verify_gauss_law(lambda x,y,z: x, lambda x,y,z: y, lambda x,y,z: z, lambda x,y,z: 3, [(0,0,0), (1,1,1)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "verify_gauss_law(lambda x,y,z: 0, lambda x,y,z: 0, lambda x,y,z: 0, lambda x,y,z: 0, [(1,1,1)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Gauss's law: ∇·E = ρ/ε₀",
      "Relates electric field divergence to charge density",
      "One of Maxwell's equations"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex15",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Heat Equation",
    "difficulty": 5,
    "description": "Verify a solution to the heat equation: ∂u/∂t = α∇²u.",
    "starterCode": "import numpy as np\n\ndef verify_heat_equation(u, alpha, test_points):\n    \"\"\"\n    Verify that u(x,y,z,t) satisfies heat equation: ∂u/∂t = α∇²u\n\n    Args:\n        u: Function u(x, y, z, t)\n        alpha: Thermal diffusivity constant\n        test_points: List of (x, y, z, t) points to test\n    Returns:\n        True if equation holds at all test points\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import numpy as np\n\ndef verify_heat_equation(u, alpha, test_points):\n    \"\"\"\n    Verify that u(x,y,z,t) satisfies heat equation: ∂u/∂t = α∇²u\n    \"\"\"\n    h = 1e-5\n    tolerance = 1e-3\n\n    for x, y, z, t in test_points:\n        # Compute ∂u/∂t\n        du_dt = (u(x, y, z, t + h) - u(x, y, z, t - h)) / (2 * h)\n\n        # Compute Laplacian ∇²u\n        d2u_dx2 = (u(x + h, y, z, t) - 2 * u(x, y, z, t) + u(x - h, y, z, t)) / h**2\n        d2u_dy2 = (u(x, y + h, z, t) - 2 * u(x, y, z, t) + u(x, y - h, z, t)) / h**2\n        d2u_dz2 = (u(x, y, z + h, t) - 2 * u(x, y, z, t) + u(x, y, z - h, t)) / h**2\n\n        laplacian_u = d2u_dx2 + d2u_dy2 + d2u_dz2\n\n        # Check if ∂u/∂t = α∇²u\n        if abs(du_dt - alpha * laplacian_u) > tolerance:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "verify_heat_equation(lambda x,y,z,t: np.exp(-t) * np.sin(x), 1.0, [(0,0,0,1), (np.pi/2,0,0,0.5)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "verify_heat_equation(lambda x,y,z,t: np.exp(-3*t) * (np.sin(x) + np.sin(y) + np.sin(z)), 1.0, [(0,0,0,0.1)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Heat equation: ∂u/∂t = α∇²u",
      "Describes heat diffusion in space over time",
      "Check that time derivative equals α times Laplacian"
    ],
    "language": "python"
  },
  {
    "id": "math301-t7-ex16",
    "subjectId": "math301",
    "topicId": "math301-topic-7",
    "title": "Conservative Field Decomposition",
    "difficulty": 5,
    "description": "Decompose a vector field into conservative (curl-free) and solenoidal (div-free) parts.",
    "starterCode": "import numpy as np\n\ndef helmholtz_decomposition_test(P, Q, R, test_point):\n    \"\"\"\n    For simple fields, test if F can be written as F = ∇φ + ∇×A\n    where ∇φ is conservative and ∇×A is solenoidal.\n    This simplified version just checks properties.\n\n    Args:\n        P, Q, R: Vector field components\n        test_point: (x, y, z) point to analyze\n    Returns:\n        Dict with 'has_conservative_part' and 'has_solenoidal_part'\n    \"\"\"\n    # Your implementation here\n    # Check if curl F = 0 (purely conservative)\n    # Check if div F = 0 (purely solenoidal)\n    pass",
    "solution": "import numpy as np\n\ndef helmholtz_decomposition_test(P, Q, R, test_point):\n    \"\"\"\n    Test properties related to Helmholtz decomposition.\n    \"\"\"\n    x, y, z = test_point\n    h = 1e-6\n    tolerance = 1e-4\n\n    # Compute divergence\n    dP_dx = (P(x + h, y, z) - P(x - h, y, z)) / (2 * h)\n    dQ_dy = (Q(x, y + h, z) - Q(x, y - h, z)) / (2 * h)\n    dR_dz = (R(x, y, z + h) - R(x, y, z - h)) / (2 * h)\n    div_F = dP_dx + dQ_dy + dR_dz\n\n    # Compute curl\n    dR_dy = (R(x, y + h, z) - R(x, y - h, z)) / (2 * h)\n    dQ_dz = (Q(x, y, z + h) - Q(x, y, z - h)) / (2 * h)\n    dP_dz = (P(x, y, z + h) - P(x, y, z - h)) / (2 * h)\n    dR_dx = (R(x + h, y, z) - R(x - h, y, z)) / (2 * h)\n    dQ_dx = (Q(x + h, y, z) - Q(x - h, y, z)) / (2 * h)\n    dP_dy = (P(x, y + h, z) - P(x, y - h, z)) / (2 * h)\n\n    curl_F = [dR_dy - dQ_dz, dP_dz - dR_dx, dQ_dx - dP_dy]\n    curl_magnitude = np.sqrt(sum(c**2 for c in curl_F))\n\n    result = {\n        'has_conservative_part': abs(div_F) > tolerance or curl_magnitude < tolerance,\n        'has_solenoidal_part': curl_magnitude > tolerance or abs(div_F) < tolerance,\n        'is_purely_conservative': curl_magnitude < tolerance,\n        'is_purely_solenoidal': abs(div_F) < tolerance\n    }\n\n    return result",
    "testCases": [
      {
        "input": "helmholtz_decomposition_test(lambda x,y,z: x, lambda x,y,z: y, lambda x,y,z: z, (1,1,1))[\"is_purely_conservative\"]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "helmholtz_decomposition_test(lambda x,y,z: -y, lambda x,y,z: x, lambda x,y,z: 0, (1,1,1))[\"is_purely_solenoidal\"]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Helmholtz: Any field F = ∇φ + ∇×A",
      "Conservative part: curl = 0",
      "Solenoidal part: div = 0",
      "Some fields have both parts"
    ],
    "language": "python"
  }
]
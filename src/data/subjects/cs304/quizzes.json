[
  {
    "id": "cs304-t1-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-1",
    "title": "Compiler Fundamentals",
    "questions": [
      {
        "id": "cs304-t1-q1-1",
        "type": "multiple_choice",
        "prompt": "Which phase of a compiler converts source code into a stream of tokens?",
        "options": [
          "Parsing",
          "Lexical analysis",
          "Semantic analysis",
          "Code generation"
        ],
        "correctAnswer": 1,
        "explanation": "Lexical analysis (scanning) breaks source code into tokens like identifiers, keywords, and operators."
      },
      {
        "id": "cs304-t1-q1-2",
        "type": "multiple_choice",
        "prompt": "What is the difference between a lexeme and a token?",
        "options": [
          "They are the same thing",
          "A lexeme is the actual string; a token is its category",
          "A token is the actual string; a lexeme is its category",
          "Lexemes are only for keywords"
        ],
        "correctAnswer": 1,
        "explanation": "A lexeme is the actual character sequence (e.g., \"count\"), while a token is its classification (e.g., IDENTIFIER)."
      },
      {
        "id": "cs304-t1-q1-3",
        "type": "multiple_choice",
        "prompt": "Which compiler phase typically handles whitespace and comments?",
        "options": [
          "Parser",
          "Scanner",
          "Semantic analyzer",
          "Optimizer"
        ],
        "correctAnswer": 1,
        "explanation": "The scanner (lexical analyzer) typically discards whitespace and comments, not passing them to the parser."
      },
      {
        "id": "cs304-t1-q1-4",
        "type": "multiple_choice",
        "prompt": "What distinguishes an interpreter from a compiler?",
        "options": [
          "Interpreters are faster",
          "Compilers execute code directly",
          "Interpreters execute without producing target code",
          "Compilers cannot optimize"
        ],
        "correctAnswer": 2,
        "explanation": "Interpreters execute source code directly without producing standalone target code, unlike compilers."
      },
      {
        "id": "cs304-t1-q1-5",
        "type": "multiple_choice",
        "prompt": "What is the front-end of a compiler responsible for?",
        "options": [
          "Code optimization",
          "Machine code generation",
          "Analysis and IR generation",
          "Linking"
        ],
        "correctAnswer": 2,
        "explanation": "The front-end handles lexical, syntax, and semantic analysis, producing an intermediate representation."
      }
    ]
  },
  {
    "id": "cs304-t1-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-1",
    "title": "Regular Expressions and Automata",
    "questions": [
      {
        "id": "cs304-t1-q2-1",
        "type": "multiple_choice",
        "prompt": "Which regular expression matches one or more digits?",
        "options": [
          "[0-9]*",
          "[0-9]+",
          "[0-9]?",
          "[0-9]"
        ],
        "correctAnswer": 1,
        "explanation": "The + operator means one or more occurrences, while * means zero or more."
      },
      {
        "id": "cs304-t1-q2-2",
        "type": "multiple_choice",
        "prompt": "What is the key difference between a DFA and an NFA?",
        "options": [
          "DFAs are more powerful",
          "NFAs have exactly one transition per symbol per state",
          "DFAs have at most one transition per symbol per state",
          "NFAs cannot have epsilon transitions"
        ],
        "correctAnswer": 2,
        "explanation": "DFAs have exactly one transition for each symbol from each state, making them deterministic."
      },
      {
        "id": "cs304-t1-q2-3",
        "type": "multiple_choice",
        "prompt": "What is an epsilon (ε) transition in an NFA?",
        "options": [
          "A transition that consumes any character",
          "A transition that occurs without consuming input",
          "A transition to an error state",
          "A transition that matches whitespace"
        ],
        "correctAnswer": 1,
        "explanation": "Epsilon transitions allow state changes without consuming any input character."
      },
      {
        "id": "cs304-t1-q2-4",
        "type": "multiple_choice",
        "prompt": "Can every NFA be converted to an equivalent DFA?",
        "options": [
          "No, NFAs are more powerful",
          "Yes, using subset construction",
          "Only if the NFA has no epsilon transitions",
          "Only for finite languages"
        ],
        "correctAnswer": 1,
        "explanation": "The subset construction algorithm can convert any NFA to an equivalent DFA, though it may have exponentially more states."
      },
      {
        "id": "cs304-t1-q2-5",
        "type": "multiple_choice",
        "prompt": "What does the regular expression a(b|c)*d match?",
        "options": [
          "abd or acd only",
          "Strings starting with a, ending with d, with any b/c sequence in between",
          "abcd only",
          "Any string with a and d"
        ],
        "correctAnswer": 1,
        "explanation": "It matches \"a\", followed by zero or more b's or c's (in any order), followed by \"d\"."
      }
    ]
  },
  {
    "id": "cs304-t1-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-1",
    "title": "Scanner Implementation",
    "questions": [
      {
        "id": "cs304-t1-q3-1",
        "type": "multiple_choice",
        "prompt": "What is the maximal munch rule in lexical analysis?",
        "options": [
          "Prefer shorter tokens",
          "Prefer longer tokens",
          "Prefer alphabetically first tokens",
          "Process one character at a time"
        ],
        "correctAnswer": 1,
        "explanation": "Maximal munch means the scanner should match the longest possible token at each point."
      },
      {
        "id": "cs304-t1-q3-2",
        "type": "multiple_choice",
        "prompt": "What tool is commonly used to generate scanners from regular expression specifications?",
        "options": [
          "yacc",
          "bison",
          "lex/flex",
          "make"
        ],
        "correctAnswer": 2,
        "explanation": "Lex and its GNU implementation flex generate C scanners from regular expression patterns."
      },
      {
        "id": "cs304-t1-q3-3",
        "type": "multiple_choice",
        "prompt": "How does a scanner typically handle keywords vs identifiers?",
        "options": [
          "Separate DFAs for each",
          "Match as identifier, then check keyword table",
          "Keywords have higher DFA priority",
          "Keywords are handled by the parser"
        ],
        "correctAnswer": 1,
        "explanation": "A common approach matches identifiers first, then looks up in a reserved word table to distinguish keywords."
      },
      {
        "id": "cs304-t1-q3-4",
        "type": "multiple_choice",
        "prompt": "What is a lookahead in lexical analysis?",
        "options": [
          "Predicting future tokens",
          "Reading ahead to decide current token boundaries",
          "Caching tokens",
          "Parallel scanning"
        ],
        "correctAnswer": 1,
        "explanation": "Lookahead reads additional characters to determine where the current token ends (e.g., \"=\" vs \"==\")."
      },
      {
        "id": "cs304-t1-q3-5",
        "type": "multiple_choice",
        "prompt": "What is panic mode error recovery in lexical analysis?",
        "options": [
          "Terminating immediately on error",
          "Discarding characters until a valid token start",
          "Inserting missing characters",
          "Switching to a backup scanner"
        ],
        "correctAnswer": 1,
        "explanation": "Panic mode skips characters until recognizing a valid token beginning, allowing continued scanning."
      }
    ]
  },
  {
    "id": "cs304-t2-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-2",
    "title": "Context-Free Grammars",
    "questions": [
      {
        "id": "cs304-t2-q1-1",
        "type": "multiple_choice",
        "prompt": "In a context-free grammar, what appears on the left side of a production?",
        "options": [
          "Only terminals",
          "Only non-terminals",
          "A single non-terminal",
          "Any string of symbols"
        ],
        "correctAnswer": 2,
        "explanation": "CFG productions have exactly one non-terminal on the left side, distinguishing them from unrestricted grammars."
      },
      {
        "id": "cs304-t2-q1-2",
        "type": "multiple_choice",
        "prompt": "What is an ambiguous grammar?",
        "options": [
          "A grammar with errors",
          "A grammar that can produce multiple parse trees for some input",
          "A grammar with no valid derivations",
          "A grammar with left recursion"
        ],
        "correctAnswer": 1,
        "explanation": "An ambiguous grammar allows more than one parse tree (derivation) for the same input string."
      },
      {
        "id": "cs304-t2-q1-3",
        "type": "multiple_choice",
        "prompt": "What is the start symbol in a grammar?",
        "options": [
          "The first terminal",
          "The non-terminal from which all derivations begin",
          "Any symbol can be the start",
          "The most frequently used symbol"
        ],
        "correctAnswer": 1,
        "explanation": "The start symbol is the designated non-terminal from which all valid derivations must begin."
      },
      {
        "id": "cs304-t2-q1-4",
        "type": "multiple_choice",
        "prompt": "What is a leftmost derivation?",
        "options": [
          "Deriving left-recursive rules first",
          "Always replacing the leftmost non-terminal",
          "Starting from the left of the input",
          "Using left-associative operators"
        ],
        "correctAnswer": 1,
        "explanation": "A leftmost derivation always expands the leftmost non-terminal at each step."
      },
      {
        "id": "cs304-t2-q1-5",
        "type": "multiple_choice",
        "prompt": "What is the yield of a parse tree?",
        "options": [
          "The root node",
          "The leftmost leaf",
          "The string of terminals at the leaves read left to right",
          "The number of nodes"
        ],
        "correctAnswer": 2,
        "explanation": "The yield is the string formed by concatenating the leaves (terminals) from left to right."
      }
    ]
  },
  {
    "id": "cs304-t2-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-2",
    "title": "Top-Down Parsing",
    "questions": [
      {
        "id": "cs304-t2-q2-1",
        "type": "multiple_choice",
        "prompt": "What is the main challenge with left-recursive grammars in top-down parsing?",
        "options": [
          "They are ambiguous",
          "They cause infinite recursion",
          "They cannot express all languages",
          "They are slower to parse"
        ],
        "correctAnswer": 1,
        "explanation": "Left recursion causes recursive descent parsers to loop infinitely without consuming input."
      },
      {
        "id": "cs304-t2-q2-2",
        "type": "multiple_choice",
        "prompt": "What is the FIRST set of a grammar symbol?",
        "options": [
          "The first production for that symbol",
          "The set of terminals that can begin strings derived from it",
          "The first symbol in each production",
          "The highest-priority terminal"
        ],
        "correctAnswer": 1,
        "explanation": "FIRST(X) is the set of terminals that can appear as the first symbol of any string derived from X."
      },
      {
        "id": "cs304-t2-q2-3",
        "type": "multiple_choice",
        "prompt": "When is epsilon (ε) in the FIRST set of a non-terminal?",
        "options": [
          "Never",
          "When it can derive the empty string",
          "When it appears in a production",
          "When it is the start symbol"
        ],
        "correctAnswer": 1,
        "explanation": "ε ∈ FIRST(A) if A can derive the empty string (A ⇒* ε)."
      },
      {
        "id": "cs304-t2-q2-4",
        "type": "multiple_choice",
        "prompt": "What is the FOLLOW set used for in LL parsing?",
        "options": [
          "Determining operator precedence",
          "Deciding which production to use when FIRST sets overlap or contain ε",
          "Detecting left recursion",
          "Optimizing the parse table"
        ],
        "correctAnswer": 1,
        "explanation": "FOLLOW sets help choose productions when the current non-terminal can derive ε."
      },
      {
        "id": "cs304-t2-q2-5",
        "type": "multiple_choice",
        "prompt": "What does LL(1) mean?",
        "options": [
          "Left-to-right, Leftmost derivation, 1 symbol lookahead",
          "Left-to-right, Left recursion, 1 pass",
          "Linear time, Linear space, 1 table",
          "Lexical, Logical, 1 phase"
        ],
        "correctAnswer": 0,
        "explanation": "LL(1): scan Left-to-right, produce Leftmost derivation, using 1 token of lookahead."
      }
    ]
  },
  {
    "id": "cs304-t2-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-2",
    "title": "Bottom-Up Parsing",
    "questions": [
      {
        "id": "cs304-t2-q3-1",
        "type": "multiple_choice",
        "prompt": "What are the two main actions in shift-reduce parsing?",
        "options": [
          "Push and pop",
          "Read and write",
          "Shift (push token) and reduce (apply production)",
          "Accept and reject"
        ],
        "correctAnswer": 2,
        "explanation": "Shift pushes input onto the stack; reduce replaces a production's RHS with its LHS."
      },
      {
        "id": "cs304-t2-q3-2",
        "type": "multiple_choice",
        "prompt": "What is a handle in bottom-up parsing?",
        "options": [
          "The next token",
          "A string matching a production's RHS that should be reduced",
          "The stack top",
          "An error condition"
        ],
        "correctAnswer": 1,
        "explanation": "A handle is a substring matching a production body that, when reduced, leads to a valid parse."
      },
      {
        "id": "cs304-t2-q3-3",
        "type": "multiple_choice",
        "prompt": "What is a shift-reduce conflict?",
        "options": [
          "Two reductions possible",
          "Parser cannot decide between shifting and reducing",
          "Invalid input detected",
          "Stack overflow"
        ],
        "correctAnswer": 1,
        "explanation": "A shift-reduce conflict occurs when the parser cannot decide whether to shift the next token or reduce the current handle."
      },
      {
        "id": "cs304-t2-q3-4",
        "type": "multiple_choice",
        "prompt": "Which is more powerful: LL(1) or LR(1)?",
        "options": [
          "LL(1)",
          "LR(1)",
          "They are equivalent",
          "Depends on the grammar"
        ],
        "correctAnswer": 1,
        "explanation": "LR(1) parsers can handle a strictly larger class of grammars than LL(1) parsers."
      },
      {
        "id": "cs304-t2-q3-5",
        "type": "multiple_choice",
        "prompt": "What tool generates LALR parsers from grammar specifications?",
        "options": [
          "lex",
          "flex",
          "yacc/bison",
          "make"
        ],
        "correctAnswer": 2,
        "explanation": "Yacc (and GNU bison) generate LALR(1) parsers from grammar specifications."
      }
    ]
  },
  {
    "id": "cs304-t3-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Attribute Grammars",
    "questions": [
      {
        "id": "cs304-t3-q1-1",
        "type": "multiple_choice",
        "prompt": "What is a synthesized attribute?",
        "options": [
          "Computed from parent nodes",
          "Computed from child nodes",
          "Always constant",
          "Only for terminals"
        ],
        "correctAnswer": 1,
        "explanation": "Synthesized attributes are computed from attributes of child nodes, flowing up the parse tree."
      },
      {
        "id": "cs304-t3-q1-2",
        "type": "multiple_choice",
        "prompt": "What is an inherited attribute?",
        "options": [
          "Computed from child nodes",
          "Computed from parent or sibling nodes",
          "Inherited from the grammar",
          "Never changes"
        ],
        "correctAnswer": 1,
        "explanation": "Inherited attributes are computed from parent or sibling nodes, flowing down or across the tree."
      },
      {
        "id": "cs304-t3-q1-3",
        "type": "multiple_choice",
        "prompt": "What is an S-attributed grammar?",
        "options": [
          "A grammar with only synthesized attributes",
          "A grammar with only string attributes",
          "A simple grammar",
          "A structured grammar"
        ],
        "correctAnswer": 0,
        "explanation": "S-attributed grammars use only synthesized attributes, enabling single bottom-up pass evaluation."
      },
      {
        "id": "cs304-t3-q1-4",
        "type": "multiple_choice",
        "prompt": "What is an L-attributed grammar?",
        "options": [
          "A left-recursive grammar",
          "Attributes depend only on inherited from parent or synthesized from left siblings",
          "A linear grammar",
          "A grammar with lookahead"
        ],
        "correctAnswer": 1,
        "explanation": "L-attributed grammars allow inherited attributes computed from the parent and synthesized attributes from left siblings."
      },
      {
        "id": "cs304-t3-q1-5",
        "type": "multiple_choice",
        "prompt": "What is a dependency graph in attribute evaluation?",
        "options": [
          "A parse tree",
          "A graph showing which attributes depend on which others",
          "A control flow graph",
          "A call graph"
        ],
        "correctAnswer": 1,
        "explanation": "The dependency graph shows attribute dependencies, determining evaluation order."
      }
    ]
  },
  {
    "id": "cs304-t3-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Symbol Tables and Types",
    "questions": [
      {
        "id": "cs304-t3-q2-1",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of a symbol table?",
        "options": [
          "Storing source code",
          "Mapping identifiers to their attributes",
          "Generating machine code",
          "Parsing input"
        ],
        "correctAnswer": 1,
        "explanation": "Symbol tables map identifiers to information like type, scope, and memory location."
      },
      {
        "id": "cs304-t3-q2-2",
        "type": "multiple_choice",
        "prompt": "How is lexical scoping typically implemented in symbol tables?",
        "options": [
          "Single global table",
          "Stack of tables or chained hash tables",
          "Array of identifiers",
          "Binary search tree"
        ],
        "correctAnswer": 1,
        "explanation": "Lexical scoping uses a stack of tables or chained scopes, with inner scopes shadowing outer ones."
      },
      {
        "id": "cs304-t3-q2-3",
        "type": "multiple_choice",
        "prompt": "What is structural type equivalence?",
        "options": [
          "Types are equal if they have the same name",
          "Types are equal if they have the same structure",
          "Types are equal if declared together",
          "Types are never equal"
        ],
        "correctAnswer": 1,
        "explanation": "Structural equivalence considers types equal if they have identical structure, regardless of name."
      },
      {
        "id": "cs304-t3-q2-4",
        "type": "multiple_choice",
        "prompt": "What is name equivalence for types?",
        "options": [
          "Types are equal only if they have the same name",
          "Types are equal if structurally identical",
          "Types are equal if in the same scope",
          "All types are equivalent"
        ],
        "correctAnswer": 0,
        "explanation": "Name equivalence requires types to have the same declared name to be considered equal."
      },
      {
        "id": "cs304-t3-q2-5",
        "type": "multiple_choice",
        "prompt": "What is type coercion?",
        "options": [
          "Detecting type errors",
          "Implicit conversion between types",
          "Declaring types",
          "Type inheritance"
        ],
        "correctAnswer": 1,
        "explanation": "Type coercion is automatic (implicit) type conversion performed by the compiler."
      }
    ]
  },
  {
    "id": "cs304-t3-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Type Checking and ASTs",
    "questions": [
      {
        "id": "cs304-t3-q3-1",
        "type": "multiple_choice",
        "prompt": "What is static type checking?",
        "options": [
          "Checking types at runtime",
          "Checking types at compile time",
          "Checking only static variables",
          "Optional type checking"
        ],
        "correctAnswer": 1,
        "explanation": "Static type checking verifies type correctness at compile time, before execution."
      },
      {
        "id": "cs304-t3-q3-2",
        "type": "multiple_choice",
        "prompt": "What is the difference between a parse tree and an AST?",
        "options": [
          "They are the same",
          "AST omits syntactic details like parentheses",
          "Parse tree is more compact",
          "AST includes tokens"
        ],
        "correctAnswer": 1,
        "explanation": "ASTs abstract away syntactic details (punctuation, grouping) present in parse trees, keeping semantic structure."
      },
      {
        "id": "cs304-t3-q3-3",
        "type": "multiple_choice",
        "prompt": "What is a type judgment in type theory?",
        "options": [
          "A court ruling",
          "An assertion that an expression has a certain type",
          "A type error",
          "A type definition"
        ],
        "correctAnswer": 1,
        "explanation": "A type judgment (Γ ⊢ e : τ) asserts that expression e has type τ in context Γ."
      },
      {
        "id": "cs304-t3-q3-4",
        "type": "multiple_choice",
        "prompt": "What algorithm is commonly used for type inference?",
        "options": [
          "Quicksort",
          "Unification",
          "Binary search",
          "Gradient descent"
        ],
        "correctAnswer": 1,
        "explanation": "Unification (Algorithm W) finds substitutions making types equal, central to Hindley-Milner inference."
      },
      {
        "id": "cs304-t3-q3-5",
        "type": "multiple_choice",
        "prompt": "What is the visitor pattern used for with ASTs?",
        "options": [
          "Creating ASTs",
          "Traversing and operating on AST nodes",
          "Parsing input",
          "Memory management"
        ],
        "correctAnswer": 1,
        "explanation": "The visitor pattern separates operations from AST structure, enabling multiple traversals for different purposes."
      }
    ]
  },
  {
    "id": "cs304-t4-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-4",
    "title": "IR Fundamentals",
    "questions": [
      {
        "id": "cs304-t4-q1-1",
        "type": "multiple_choice",
        "prompt": "Why do compilers use intermediate representations?",
        "options": [
          "To slow down compilation",
          "To decouple front-end from back-end and enable optimization",
          "IRs are required by language standards",
          "To increase code size"
        ],
        "correctAnswer": 1,
        "explanation": "IRs provide a common representation enabling front-end/back-end separation and machine-independent optimization."
      },
      {
        "id": "cs304-t4-q1-2",
        "type": "multiple_choice",
        "prompt": "What is three-address code?",
        "options": [
          "Code with three functions",
          "IR where each instruction has at most three operands",
          "Code for 3-bit machines",
          "Assembly with three registers"
        ],
        "correctAnswer": 1,
        "explanation": "Three-address code uses instructions of the form x = y op z, with at most two sources and one destination."
      },
      {
        "id": "cs304-t4-q1-3",
        "type": "multiple_choice",
        "prompt": "What is a basic block?",
        "options": [
          "A simple function",
          "A maximal sequence of instructions with one entry and one exit",
          "A block of memory",
          "The smallest unit of code"
        ],
        "correctAnswer": 1,
        "explanation": "A basic block is a maximal sequence of straight-line code with no branches except at entry and exit."
      },
      {
        "id": "cs304-t4-q1-4",
        "type": "multiple_choice",
        "prompt": "What is a control flow graph (CFG)?",
        "options": [
          "A graph of function calls",
          "A directed graph of basic blocks showing control flow",
          "A data structure",
          "A parse tree"
        ],
        "correctAnswer": 1,
        "explanation": "A CFG is a directed graph where nodes are basic blocks and edges represent control flow between them."
      },
      {
        "id": "cs304-t4-q1-5",
        "type": "multiple_choice",
        "prompt": "What distinguishes high-level IR from low-level IR?",
        "options": [
          "High-level is faster",
          "High-level preserves more source structure; low-level is closer to machine code",
          "Low-level is more portable",
          "They are the same"
        ],
        "correctAnswer": 1,
        "explanation": "High-level IRs retain source-like constructs; low-level IRs are closer to target machine operations."
      }
    ]
  },
  {
    "id": "cs304-t4-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-4",
    "title": "SSA Form",
    "questions": [
      {
        "id": "cs304-t4-q2-1",
        "type": "multiple_choice",
        "prompt": "What is Static Single Assignment (SSA) form?",
        "options": [
          "Code with only one statement",
          "Each variable is assigned exactly once in the program text",
          "Single-threaded code",
          "Code without loops"
        ],
        "correctAnswer": 1,
        "explanation": "In SSA form, each variable has exactly one definition (assignment) in the static program text."
      },
      {
        "id": "cs304-t4-q2-2",
        "type": "multiple_choice",
        "prompt": "What is a phi (φ) function in SSA?",
        "options": [
          "A mathematical function",
          "A function that selects a value based on control flow path taken",
          "A hashing function",
          "An optimization function"
        ],
        "correctAnswer": 1,
        "explanation": "Phi functions merge values at control flow join points, selecting the value from the incoming edge taken."
      },
      {
        "id": "cs304-t4-q2-3",
        "type": "multiple_choice",
        "prompt": "Where are phi functions placed in SSA form?",
        "options": [
          "At function entries",
          "At dominance frontiers of variable definitions",
          "At loop exits",
          "Everywhere"
        ],
        "correctAnswer": 1,
        "explanation": "Phi functions are placed at dominance frontiers, where multiple definitions of a variable may reach."
      },
      {
        "id": "cs304-t4-q2-4",
        "type": "multiple_choice",
        "prompt": "What is a major benefit of SSA form for optimization?",
        "options": [
          "Smaller code",
          "Faster execution",
          "Explicit def-use chains simplify many analyses",
          "Fewer variables"
        ],
        "correctAnswer": 2,
        "explanation": "SSA makes def-use relationships explicit, simplifying optimizations like constant propagation and dead code elimination."
      },
      {
        "id": "cs304-t4-q2-5",
        "type": "multiple_choice",
        "prompt": "What is \"destruction\" of SSA form?",
        "options": [
          "Deleting the IR",
          "Converting back to non-SSA form by eliminating phi functions",
          "Removing optimizations",
          "Memory deallocation"
        ],
        "correctAnswer": 1,
        "explanation": "SSA destruction converts SSA to conventional form by replacing phi functions with copies."
      }
    ]
  },
  {
    "id": "cs304-t4-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-4",
    "title": "IR in Practice",
    "questions": [
      {
        "id": "cs304-t4-q3-1",
        "type": "multiple_choice",
        "prompt": "What is LLVM IR?",
        "options": [
          "A hardware description language",
          "A typed, SSA-based IR used by LLVM compilers",
          "A virtual machine",
          "An assembly language"
        ],
        "correctAnswer": 1,
        "explanation": "LLVM IR is a typed, SSA-based intermediate representation used throughout the LLVM compiler infrastructure."
      },
      {
        "id": "cs304-t4-q3-2",
        "type": "multiple_choice",
        "prompt": "What is the difference between quadruples and triples in three-address code?",
        "options": [
          "No difference",
          "Quadruples store result name; triples use instruction position",
          "Triples are larger",
          "Quadruples are deprecated"
        ],
        "correctAnswer": 1,
        "explanation": "Quadruples explicitly name the result; triples reference results by instruction number (position)."
      },
      {
        "id": "cs304-t4-q3-3",
        "type": "multiple_choice",
        "prompt": "What is IR lowering?",
        "options": [
          "Reducing IR quality",
          "Translating high-level constructs to lower-level operations",
          "Compressing IR",
          "Removing optimizations"
        ],
        "correctAnswer": 1,
        "explanation": "IR lowering transforms high-level operations (like array access) into sequences of simpler operations."
      },
      {
        "id": "cs304-t4-q3-4",
        "type": "multiple_choice",
        "prompt": "What is a dominator in a control flow graph?",
        "options": [
          "The entry block",
          "A block through which all paths to another block must pass",
          "The most executed block",
          "A recursive block"
        ],
        "correctAnswer": 1,
        "explanation": "Block A dominates block B if every path from entry to B goes through A."
      },
      {
        "id": "cs304-t4-q3-5",
        "type": "multiple_choice",
        "prompt": "Why might a compiler use multiple IR levels?",
        "options": [
          "To confuse readers",
          "Different optimizations work better at different abstraction levels",
          "Required by standards",
          "To increase compilation time"
        ],
        "correctAnswer": 1,
        "explanation": "Multiple IR levels allow optimizations appropriate to each abstraction level (high-level restructuring, low-level register work)."
      }
    ]
  },
  {
    "id": "cs304-t5-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Instruction Selection",
    "questions": [
      {
        "id": "cs304-t5-q1-1",
        "type": "multiple_choice",
        "prompt": "What is instruction selection?",
        "options": [
          "Choosing which instructions to delete",
          "Mapping IR operations to target machine instructions",
          "Selecting the best algorithm",
          "Choosing optimization levels"
        ],
        "correctAnswer": 1,
        "explanation": "Instruction selection chooses target machine instructions to implement each IR operation."
      },
      {
        "id": "cs304-t5-q1-2",
        "type": "multiple_choice",
        "prompt": "What is tree pattern matching in code generation?",
        "options": [
          "Matching AST patterns",
          "Covering IR trees with instruction tiles",
          "Pattern matching in functional languages",
          "Finding trees in code"
        ],
        "correctAnswer": 1,
        "explanation": "Tree pattern matching tiles IR expression trees with instruction patterns, optimizing for cost."
      },
      {
        "id": "cs304-t5-q1-3",
        "type": "multiple_choice",
        "prompt": "What is the maximal munch strategy for instruction selection?",
        "options": [
          "Use smallest instructions",
          "Greedily select largest matching tile at each point",
          "Random selection",
          "Use most common instructions"
        ],
        "correctAnswer": 1,
        "explanation": "Maximal munch greedily selects the largest (most operations) matching instruction pattern at each node."
      },
      {
        "id": "cs304-t5-q1-4",
        "type": "multiple_choice",
        "prompt": "What is the advantage of CISC over RISC for code generation?",
        "options": [
          "Simpler instruction selection",
          "Complex instructions may do more work per instruction",
          "Faster execution always",
          "More registers"
        ],
        "correctAnswer": 1,
        "explanation": "CISC instructions can perform complex operations in one instruction, potentially reducing code size."
      },
      {
        "id": "cs304-t5-q1-5",
        "type": "multiple_choice",
        "prompt": "What is peephole optimization in code generation?",
        "options": [
          "Looking at small windows of instructions to improve them",
          "Optimizing loops",
          "Global analysis",
          "Memory optimization"
        ],
        "correctAnswer": 0,
        "explanation": "Peephole optimization examines small instruction windows to apply local improvements like strength reduction."
      }
    ]
  },
  {
    "id": "cs304-t5-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Register Allocation",
    "questions": [
      {
        "id": "cs304-t5-q2-1",
        "type": "multiple_choice",
        "prompt": "Why is register allocation important?",
        "options": [
          "Registers are infinite",
          "Registers are much faster than memory",
          "Registers are required",
          "Registers use less power"
        ],
        "correctAnswer": 1,
        "explanation": "Register access is much faster than memory; effective allocation reduces memory traffic and improves performance."
      },
      {
        "id": "cs304-t5-q2-2",
        "type": "multiple_choice",
        "prompt": "What is a live range in register allocation?",
        "options": [
          "A valid memory address",
          "The interval from a variable's definition to its last use",
          "A hardware register",
          "A loop body"
        ],
        "correctAnswer": 1,
        "explanation": "A live range spans from where a variable is defined to where it is last used."
      },
      {
        "id": "cs304-t5-q2-3",
        "type": "multiple_choice",
        "prompt": "How does graph coloring relate to register allocation?",
        "options": [
          "Unrelated",
          "Non-interfering live ranges can share registers (same color)",
          "Colors represent memory",
          "Graphs represent instructions"
        ],
        "correctAnswer": 1,
        "explanation": "Graph coloring assigns registers: nodes are live ranges, edges connect simultaneously live ranges, colors are registers."
      },
      {
        "id": "cs304-t5-q2-4",
        "type": "multiple_choice",
        "prompt": "What is spilling in register allocation?",
        "options": [
          "Memory leak",
          "Storing a value in memory when no register is available",
          "Register overflow",
          "Stack corruption"
        ],
        "correctAnswer": 1,
        "explanation": "Spilling stores a value to memory when all registers are occupied, loading it back when needed."
      },
      {
        "id": "cs304-t5-q2-5",
        "type": "multiple_choice",
        "prompt": "What is linear scan register allocation?",
        "options": [
          "Scanning registers linearly",
          "A faster alternative to graph coloring using live intervals",
          "Allocating registers in order",
          "Sequential allocation"
        ],
        "correctAnswer": 1,
        "explanation": "Linear scan processes live intervals in order, providing faster allocation than graph coloring with reasonable quality."
      }
    ]
  },
  {
    "id": "cs304-t5-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Calling Conventions and Stack",
    "questions": [
      {
        "id": "cs304-t5-q3-1",
        "type": "multiple_choice",
        "prompt": "What does a calling convention specify?",
        "options": [
          "Function naming",
          "How arguments are passed and results returned between functions",
          "Code formatting",
          "Variable naming"
        ],
        "correctAnswer": 1,
        "explanation": "Calling conventions define parameter passing, return values, register usage, and stack management between caller/callee."
      },
      {
        "id": "cs304-t5-q3-2",
        "type": "multiple_choice",
        "prompt": "What are caller-saved vs callee-saved registers?",
        "options": [
          "Same thing",
          "Caller-saved are preserved by caller; callee-saved by callee",
          "Caller-saved cannot be used",
          "Callee-saved are for return values"
        ],
        "correctAnswer": 1,
        "explanation": "Caller-saved registers may be clobbered by callee; callee-saved must be preserved across calls."
      },
      {
        "id": "cs304-t5-q3-3",
        "type": "multiple_choice",
        "prompt": "What is an activation record (stack frame)?",
        "options": [
          "A log entry",
          "Memory allocated for a function invocation",
          "A hardware register",
          "A calling convention"
        ],
        "correctAnswer": 1,
        "explanation": "An activation record holds a function's local variables, parameters, return address, and saved registers."
      },
      {
        "id": "cs304-t5-q3-4",
        "type": "multiple_choice",
        "prompt": "What is the frame pointer (FP) used for?",
        "options": [
          "Pointing to code",
          "Providing a stable reference to the current stack frame",
          "Pointing to globals",
          "Heap management"
        ],
        "correctAnswer": 1,
        "explanation": "The frame pointer provides a stable base address for accessing local variables, even as SP changes."
      },
      {
        "id": "cs304-t5-q3-5",
        "type": "multiple_choice",
        "prompt": "What is the ELF format?",
        "options": [
          "A fantasy creature",
          "Executable and Linkable Format for Unix object files",
          "An optimization",
          "A virtual machine"
        ],
        "correctAnswer": 1,
        "explanation": "ELF (Executable and Linkable Format) is the standard object file format on Unix/Linux systems."
      }
    ]
  },
  {
    "id": "cs304-t6-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-6",
    "title": "Local Optimization",
    "questions": [
      {
        "id": "cs304-t6-q1-1",
        "type": "multiple_choice",
        "prompt": "What is constant folding?",
        "options": [
          "Folding code",
          "Evaluating constant expressions at compile time",
          "Reducing constants",
          "Inlining constants"
        ],
        "correctAnswer": 1,
        "explanation": "Constant folding evaluates expressions with known constant values at compile time rather than runtime."
      },
      {
        "id": "cs304-t6-q1-2",
        "type": "multiple_choice",
        "prompt": "What is strength reduction?",
        "options": [
          "Making code weaker",
          "Replacing expensive operations with equivalent cheaper ones",
          "Reducing variable count",
          "Loop removal"
        ],
        "correctAnswer": 1,
        "explanation": "Strength reduction replaces expensive operations (e.g., multiply) with cheaper equivalents (e.g., shift)."
      },
      {
        "id": "cs304-t6-q1-3",
        "type": "multiple_choice",
        "prompt": "What is common subexpression elimination (CSE)?",
        "options": [
          "Removing duplicate code",
          "Reusing previously computed values instead of recomputing",
          "Removing comments",
          "Simplifying expressions"
        ],
        "correctAnswer": 1,
        "explanation": "CSE identifies expressions computed multiple times and reuses the first computation."
      },
      {
        "id": "cs304-t6-q1-4",
        "type": "multiple_choice",
        "prompt": "What is dead code elimination?",
        "options": [
          "Removing syntax errors",
          "Removing code whose results are never used",
          "Removing comments",
          "Removing old code"
        ],
        "correctAnswer": 1,
        "explanation": "Dead code elimination removes computations whose results are never used by the program."
      },
      {
        "id": "cs304-t6-q1-5",
        "type": "multiple_choice",
        "prompt": "What is copy propagation?",
        "options": [
          "Copying code",
          "Replacing variable uses with their known values after assignment",
          "Propagating errors",
          "Memory copying"
        ],
        "correctAnswer": 1,
        "explanation": "Copy propagation replaces uses of a variable with its value when the value is a copy of another variable."
      }
    ]
  },
  {
    "id": "cs304-t6-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-6",
    "title": "Loop Optimization",
    "questions": [
      {
        "id": "cs304-t6-q2-1",
        "type": "multiple_choice",
        "prompt": "What is loop invariant code motion?",
        "options": [
          "Removing loops",
          "Moving computations that don't change across iterations out of the loop",
          "Loop parallelization",
          "Loop counting"
        ],
        "correctAnswer": 1,
        "explanation": "Loop invariant code motion hoists computations whose values don't change across iterations outside the loop."
      },
      {
        "id": "cs304-t6-q2-2",
        "type": "multiple_choice",
        "prompt": "What is an induction variable?",
        "options": [
          "A loop counter",
          "A variable that changes by a constant amount each iteration",
          "An initialized variable",
          "A global variable"
        ],
        "correctAnswer": 1,
        "explanation": "An induction variable changes by a constant (or linear function of another induction variable) each iteration."
      },
      {
        "id": "cs304-t6-q2-3",
        "type": "multiple_choice",
        "prompt": "What is loop unrolling?",
        "options": [
          "Removing loops",
          "Replicating the loop body to reduce iteration overhead",
          "Flattening nested loops",
          "Loop reversal"
        ],
        "correctAnswer": 1,
        "explanation": "Loop unrolling duplicates the loop body multiple times, reducing branch overhead and enabling more optimization."
      },
      {
        "id": "cs304-t6-q2-4",
        "type": "multiple_choice",
        "prompt": "What is loop fusion?",
        "options": [
          "Splitting loops",
          "Combining adjacent loops with the same iteration space",
          "Removing loops",
          "Parallelizing loops"
        ],
        "correctAnswer": 1,
        "explanation": "Loop fusion combines multiple loops with compatible iteration spaces into a single loop."
      },
      {
        "id": "cs304-t6-q2-5",
        "type": "multiple_choice",
        "prompt": "What is the purpose of loop tiling/blocking?",
        "options": [
          "Making loops tile-shaped",
          "Improving cache locality by processing data in blocks",
          "Dividing work among processors",
          "Reducing loop count"
        ],
        "correctAnswer": 1,
        "explanation": "Loop tiling restructures loops to process data in cache-friendly blocks, improving memory hierarchy utilization."
      }
    ]
  },
  {
    "id": "cs304-t6-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-6",
    "title": "Data Flow Analysis",
    "questions": [
      {
        "id": "cs304-t6-q3-1",
        "type": "multiple_choice",
        "prompt": "What is reaching definitions analysis?",
        "options": [
          "Checking if code is reachable",
          "Finding which definitions may reach each program point",
          "Defining reach",
          "Code coverage"
        ],
        "correctAnswer": 1,
        "explanation": "Reaching definitions determines which variable assignments might reach (still be valid at) each program point."
      },
      {
        "id": "cs304-t6-q3-2",
        "type": "multiple_choice",
        "prompt": "What is live variable analysis?",
        "options": [
          "Checking if variables exist",
          "Determining which variables may be used before being redefined",
          "Memory liveness",
          "Variable counting"
        ],
        "correctAnswer": 1,
        "explanation": "Live variable analysis finds variables whose values may be used in the future before being overwritten."
      },
      {
        "id": "cs304-t6-q3-3",
        "type": "multiple_choice",
        "prompt": "What is a forward vs backward data flow analysis?",
        "options": [
          "Same direction",
          "Forward propagates from entry; backward from exit",
          "Forward is faster",
          "Backward is more accurate"
        ],
        "correctAnswer": 1,
        "explanation": "Forward analyses flow information from entry to exit; backward analyses flow from exit to entry."
      },
      {
        "id": "cs304-t6-q3-4",
        "type": "multiple_choice",
        "prompt": "What is alias analysis?",
        "options": [
          "Finding function aliases",
          "Determining when pointers/references may refer to the same memory",
          "Variable renaming",
          "Type analysis"
        ],
        "correctAnswer": 1,
        "explanation": "Alias analysis determines when two pointer expressions may or must refer to the same memory location."
      },
      {
        "id": "cs304-t6-q3-5",
        "type": "multiple_choice",
        "prompt": "Why is precise alias analysis difficult?",
        "options": [
          "Too many variables",
          "Undecidable in general; must use conservative approximations",
          "Requires too much memory",
          "Not needed"
        ],
        "correctAnswer": 1,
        "explanation": "Precise alias analysis is undecidable; compilers use safe approximations that may miss optimization opportunities."
      }
    ]
  },
  {
    "id": "cs304-t7-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-7",
    "title": "Memory Management",
    "questions": [
      {
        "id": "cs304-t7-q1-1",
        "type": "multiple_choice",
        "prompt": "What is the heap used for in program execution?",
        "options": [
          "Function calls",
          "Dynamically allocated data with programmer-controlled lifetime",
          "Local variables",
          "Constants"
        ],
        "correctAnswer": 1,
        "explanation": "The heap stores dynamically allocated data whose lifetime is controlled by the programmer (or garbage collector)."
      },
      {
        "id": "cs304-t7-q1-2",
        "type": "multiple_choice",
        "prompt": "What is fragmentation in heap management?",
        "options": [
          "Memory corruption",
          "Wasted space due to allocation patterns",
          "Memory overflow",
          "Pointer errors"
        ],
        "correctAnswer": 1,
        "explanation": "Fragmentation occurs when free memory is broken into small, unusable pieces between allocations."
      },
      {
        "id": "cs304-t7-q1-3",
        "type": "multiple_choice",
        "prompt": "What is the mark-sweep garbage collection algorithm?",
        "options": [
          "Sweeping memory",
          "Mark reachable objects, then sweep (free) unmarked objects",
          "Marking errors",
          "Memory cleanup"
        ],
        "correctAnswer": 1,
        "explanation": "Mark-sweep traces from roots marking reachable objects, then frees all unmarked (unreachable) objects."
      },
      {
        "id": "cs304-t7-q1-4",
        "type": "multiple_choice",
        "prompt": "What is the advantage of copying garbage collection?",
        "options": [
          "Uses less memory",
          "Compacts memory and has allocation cost proportional to live data",
          "Never pauses",
          "Simpler implementation"
        ],
        "correctAnswer": 1,
        "explanation": "Copying GC compacts memory during collection and only touches live data, making it efficient for short-lived objects."
      },
      {
        "id": "cs304-t7-q1-5",
        "type": "multiple_choice",
        "prompt": "What is generational garbage collection based on?",
        "options": [
          "Object types",
          "The hypothesis that most objects die young",
          "Random selection",
          "Object size"
        ],
        "correctAnswer": 1,
        "explanation": "Generational GC exploits the generational hypothesis: most objects die young, so focus collection on young generation."
      }
    ]
  },
  {
    "id": "cs304-t7-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-7",
    "title": "Virtual Machines and JIT",
    "questions": [
      {
        "id": "cs304-t7-q2-1",
        "type": "multiple_choice",
        "prompt": "What is a stack-based virtual machine?",
        "options": [
          "A VM using hardware stacks",
          "A VM that uses a stack for operands instead of registers",
          "A VM for stack languages",
          "A VM with call stacks"
        ],
        "correctAnswer": 1,
        "explanation": "Stack-based VMs use an operand stack for computation instead of named registers (e.g., JVM)."
      },
      {
        "id": "cs304-t7-q2-2",
        "type": "multiple_choice",
        "prompt": "What is bytecode?",
        "options": [
          "Binary code",
          "Portable intermediate code for virtual machines",
          "Compressed code",
          "Encrypted code"
        ],
        "correctAnswer": 1,
        "explanation": "Bytecode is a portable, compact intermediate representation executed by a virtual machine interpreter or JIT compiler."
      },
      {
        "id": "cs304-t7-q2-3",
        "type": "multiple_choice",
        "prompt": "What is JIT (Just-In-Time) compilation?",
        "options": [
          "Ahead-of-time compilation",
          "Compiling code to native during execution",
          "Delayed compilation",
          "Incremental compilation"
        ],
        "correctAnswer": 1,
        "explanation": "JIT compilation translates bytecode to native machine code at runtime, combining interpretation flexibility with native speed."
      },
      {
        "id": "cs304-t7-q2-4",
        "type": "multiple_choice",
        "prompt": "What is a tracing JIT?",
        "options": [
          "A debugging JIT",
          "A JIT that compiles frequently executed paths (traces)",
          "A JIT with logging",
          "A sequential JIT"
        ],
        "correctAnswer": 1,
        "explanation": "Tracing JITs record and compile hot execution paths (traces), optimizing the common case."
      },
      {
        "id": "cs304-t7-q2-5",
        "type": "multiple_choice",
        "prompt": "What is tiered compilation?",
        "options": [
          "Compilation in tiers",
          "Using multiple compilation levels based on method hotness",
          "Parallel compilation",
          "Incremental compilation"
        ],
        "correctAnswer": 1,
        "explanation": "Tiered compilation uses quick compilation for cold code and aggressive optimization for frequently executed hot code."
      }
    ]
  },
  {
    "id": "cs304-t7-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-7",
    "title": "Linking and Loading",
    "questions": [
      {
        "id": "cs304-t7-q3-1",
        "type": "multiple_choice",
        "prompt": "What is the linker responsible for?",
        "options": [
          "Compiling code",
          "Combining object files and resolving external references",
          "Running programs",
          "Memory allocation"
        ],
        "correctAnswer": 1,
        "explanation": "The linker combines object files, resolves symbol references, and produces an executable or library."
      },
      {
        "id": "cs304-t7-q3-2",
        "type": "multiple_choice",
        "prompt": "What is relocation in linking?",
        "options": [
          "Moving files",
          "Adjusting addresses in object code when combined",
          "Loading programs",
          "Memory management"
        ],
        "correctAnswer": 1,
        "explanation": "Relocation patches addresses in object code to reflect the final layout when files are combined."
      },
      {
        "id": "cs304-t7-q3-3",
        "type": "multiple_choice",
        "prompt": "What is dynamic linking?",
        "options": [
          "Fast linking",
          "Deferring library linking until runtime",
          "Linking during compilation",
          "Automatic linking"
        ],
        "correctAnswer": 1,
        "explanation": "Dynamic linking resolves library references at runtime, allowing shared libraries and late binding."
      },
      {
        "id": "cs304-t7-q3-4",
        "type": "multiple_choice",
        "prompt": "What is position-independent code (PIC)?",
        "options": [
          "Relocatable code",
          "Code that executes correctly regardless of its load address",
          "Portable code",
          "Optimized code"
        ],
        "correctAnswer": 1,
        "explanation": "PIC can execute at any address without modification, essential for shared libraries loaded at varying addresses."
      },
      {
        "id": "cs304-t7-q3-5",
        "type": "multiple_choice",
        "prompt": "What is the Global Offset Table (GOT)?",
        "options": [
          "A function table",
          "A table of addresses for position-independent access to global data",
          "A hash table",
          "An optimization table"
        ],
        "correctAnswer": 1,
        "explanation": "The GOT enables position-independent code to access global variables through a level of indirection."
      }
    ]
  }
]
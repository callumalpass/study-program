[
  {
    "id": "cs403-t1-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Verify 3-SAT Instance",
    "difficulty": 2,
    "description": "Given a 3-SAT formula and a truth assignment, verify if the assignment satisfies the formula. This demonstrates that SAT is in NP - verification is polynomial time.",
    "starterCode": "def verify_3sat(formula, assignment):\n    \"\"\"\n    Verify if a truth assignment satisfies a 3-SAT formula.\n\n    Args:\n        formula: List of clauses, where each clause is a list of literals.\n        assignment: Dictionary mapping variable numbers to boolean values.\n\n    Returns:\n        bool: True if the assignment satisfies the formula, False otherwise.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_3sat(formula, assignment):\n    for clause in formula:\n        clause_satisfied = False\n        for literal in clause:\n            var_num = abs(literal)\n            var_value = assignment.get(var_num, False)\n            if literal > 0:\n                if var_value:\n                    clause_satisfied = True\n                    break\n            else:\n                if not var_value:\n                    clause_satisfied = True\n                    break\n        if not clause_satisfied:\n            return False\n    return True",
    "testCases": [
      {
        "input": "formula = [[1, 2, 3]], assignment = {1: True, 2: False, 3: False}",
        "isHidden": false,
        "description": "Single clause satisfied"
      },
      {
        "input": "formula = [[1, -2, 3], [-1, 2, -3]], assignment = {1: True, 2: True, 3: False}",
        "isHidden": false,
        "description": "Two clauses satisfied"
      },
      {
        "input": "formula = [[1, 2, 3], [-1, -2, -3]], assignment = {1: False, 2: False, 3: False}",
        "isHidden": false,
        "description": "Not satisfied"
      }
    ],
    "hints": [
      "A clause is satisfied if at least one literal is true",
      "Check all clauses must be satisfied"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Hamiltonian Cycle Verification",
    "difficulty": 3,
    "description": "Given a graph and a proposed Hamiltonian cycle, verify if it is valid. This shows that Hamiltonian Cycle is in NP.",
    "starterCode": "def verify_hamiltonian_cycle(graph, cycle):\n    \"\"\"\n    Verify if a proposed cycle is a valid Hamiltonian cycle.\n\n    Args:\n        graph: Dictionary representing adjacency list.\n        cycle: List of vertices representing the proposed cycle.\n\n    Returns:\n        bool: True if cycle is a valid Hamiltonian cycle, False otherwise.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_hamiltonian_cycle(graph, cycle):\n    n = len(graph)\n    if len(cycle) != n + 1:\n        return False\n    if cycle[0] != cycle[-1]:\n        return False\n    if len(set(cycle[:-1])) != n:\n        return False\n    for vertex in cycle[:-1]:\n        if vertex not in graph:\n            return False\n    for i in range(len(cycle) - 1):\n        if cycle[i + 1] not in graph[cycle[i]]:\n            return False\n    return True",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, cycle = [0, 1, 2, 0]",
        "isHidden": false,
        "description": "Valid cycle in triangle"
      },
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, cycle = [0, 1, 0]",
        "isHidden": false,
        "description": "Invalid - missing vertex"
      }
    ],
    "hints": [
      "Check cycle visits all vertices exactly once",
      "Verify edges exist between consecutive vertices"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Vertex Cover Verifier",
    "difficulty": 2,
    "description": "Verify if a given set of vertices forms a valid vertex cover of a graph - every edge must have at least one endpoint in the cover.",
    "starterCode": "def verify_vertex_cover(edges, cover, k):\n    \"\"\"\n    Verify if cover is a valid vertex cover of size at most k.\n\n    Args:\n        edges: List of tuples representing edges [(u, v), ...]\n        cover: Set of vertices in the proposed cover\n        k: Maximum allowed cover size\n\n    Returns:\n        bool: True if cover is valid and |cover| <= k\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_vertex_cover(edges, cover, k):\n    if len(cover) > k:\n        return False\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            return False\n    return True",
    "testCases": [
      {
        "input": "edges = [(0,1), (1,2), (2,0)], cover = {0, 1}, k = 2",
        "isHidden": false,
        "description": "Valid cover"
      },
      {
        "input": "edges = [(0,1), (1,2), (2,0)], cover = {0}, k = 2",
        "isHidden": false,
        "description": "Invalid - edge 1-2 not covered"
      }
    ],
    "hints": [
      "Check every edge has at least one endpoint in cover",
      "Verify cover size constraint"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Independent Set Verifier",
    "difficulty": 2,
    "description": "Verify if a set of vertices forms an independent set in a graph (no two vertices in the set are adjacent).",
    "starterCode": "def verify_independent_set(graph, vertices, k):\n    \"\"\"\n    Verify if vertices form an independent set of size at least k.\n\n    Args:\n        graph: Adjacency list representation\n        vertices: Set of vertices in proposed independent set\n        k: Minimum required size\n\n    Returns:\n        bool: True if valid independent set of size >= k\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_independent_set(graph, vertices, k):\n    if len(vertices) < k:\n        return False\n    vertex_list = list(vertices)\n    for i in range(len(vertex_list)):\n        for j in range(i + 1, len(vertex_list)):\n            if vertex_list[j] in graph.get(vertex_list[i], []):\n                return False\n    return True",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, vertices = {0}, k = 1",
        "isHidden": false,
        "description": "Single vertex is independent"
      },
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1]}, vertices = {0, 2}, k = 2",
        "isHidden": false,
        "description": "Valid independent set"
      }
    ],
    "hints": [
      "No two vertices in the set should share an edge",
      "Check all pairs of vertices"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Clique Verifier",
    "difficulty": 2,
    "description": "Verify if a set of vertices forms a clique (complete subgraph) in the given graph.",
    "starterCode": "def verify_clique(graph, vertices, k):\n    \"\"\"\n    Verify if vertices form a clique of size at least k.\n\n    Args:\n        graph: Adjacency list representation\n        vertices: Set of vertices in proposed clique\n        k: Minimum clique size\n\n    Returns:\n        bool: True if valid clique of size >= k\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_clique(graph, vertices, k):\n    if len(vertices) < k:\n        return False\n    vertex_list = list(vertices)\n    for i in range(len(vertex_list)):\n        for j in range(i + 1, len(vertex_list)):\n            if vertex_list[j] not in graph.get(vertex_list[i], []):\n                return False\n    return True",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, vertices = {0, 1, 2}, k = 3",
        "isHidden": false,
        "description": "Triangle is a clique"
      },
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1]}, vertices = {0, 2}, k = 2",
        "isHidden": false,
        "description": "Invalid - no edge between 0 and 2"
      }
    ],
    "hints": [
      "Every pair of vertices in a clique must be connected",
      "Check all pairs"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Subset Sum Verifier",
    "difficulty": 1,
    "description": "Verify if a subset of numbers sums to a target value.",
    "starterCode": "def verify_subset_sum(numbers, subset, target):\n    \"\"\"\n    Verify if the given subset sums to target.\n\n    Args:\n        numbers: List of available numbers\n        subset: Indices of numbers in the proposed subset\n        target: Target sum\n\n    Returns:\n        bool: True if subset sums to target\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_subset_sum(numbers, subset, target):\n    total = sum(numbers[i] for i in subset)\n    return total == target",
    "testCases": [
      {
        "input": "numbers = [3, 1, 5, 2], subset = [0, 3], target = 5",
        "isHidden": false,
        "description": "3 + 2 = 5"
      },
      {
        "input": "numbers = [1, 2, 3], subset = [0, 1, 2], target = 6",
        "isHidden": false,
        "description": "All elements"
      }
    ],
    "hints": [
      "Sum the elements at the given indices",
      "Compare to target"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Graph Coloring Verifier",
    "difficulty": 2,
    "description": "Verify if a coloring is a valid k-coloring of a graph (no adjacent vertices share a color).",
    "starterCode": "def verify_coloring(graph, coloring, k):\n    \"\"\"\n    Verify if coloring is a valid k-coloring.\n\n    Args:\n        graph: Adjacency list\n        coloring: Dictionary mapping vertex to color (0 to k-1)\n        k: Number of colors\n\n    Returns:\n        bool: True if valid k-coloring\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_coloring(graph, coloring, k):\n    for vertex in graph:\n        if vertex not in coloring or coloring[vertex] >= k:\n            return False\n        for neighbor in graph[vertex]:\n            if coloring.get(vertex) == coloring.get(neighbor):\n                return False\n    return True",
    "testCases": [
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1]}, coloring = {0: 0, 1: 1, 2: 0}, k = 2",
        "isHidden": false,
        "description": "Valid 2-coloring of path"
      },
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, coloring = {0: 0, 1: 1, 2: 0}, k = 2",
        "isHidden": false,
        "description": "Invalid - triangle needs 3 colors"
      }
    ],
    "hints": [
      "Check no adjacent vertices have the same color",
      "Verify all colors are in range"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Partition Problem Verifier",
    "difficulty": 2,
    "description": "Verify if a partition divides a set into two subsets with equal sums.",
    "starterCode": "def verify_partition(numbers, partition):\n    \"\"\"\n    Verify if partition divides numbers into two equal-sum subsets.\n\n    Args:\n        numbers: List of numbers\n        partition: Set of indices for one subset\n\n    Returns:\n        bool: True if partition is valid\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_partition(numbers, partition):\n    total = sum(numbers)\n    if total % 2 != 0:\n        return False\n    subset_sum = sum(numbers[i] for i in partition)\n    return subset_sum == total // 2",
    "testCases": [
      {
        "input": "numbers = [1, 5, 3, 3], partition = {1}",
        "isHidden": false,
        "description": "{5} and {1,3,3} both sum to 6"
      },
      {
        "input": "numbers = [1, 2, 3, 5], partition = {0, 2}",
        "isHidden": false,
        "description": "Valid partition: {1,3} and {2,5}"
      }
    ],
    "hints": [
      "Sum must be even for partition to exist",
      "One subset determines the other"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Reduce Vertex Cover to Independent Set",
    "difficulty": 4,
    "description": "Implement a polynomial-time reduction from Vertex Cover to Independent Set. Given a graph and parameter k for vertex cover, output an instance for independent set.",
    "starterCode": "def reduce_vc_to_is(graph, k):\n    \"\"\"\n    Reduce Vertex Cover to Independent Set.\n\n    Args:\n        graph: Adjacency list (original graph)\n        k: Vertex cover size bound\n\n    Returns:\n        tuple: (same_graph, k_prime) where finding IS of size k_prime\n               in same_graph solves the VC instance\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def reduce_vc_to_is(graph, k):\n    n = len(graph)\n    k_prime = n - k  # IS of size n-k exists iff VC of size k exists\n    return (graph, k_prime)",
    "testCases": [
      {
        "input": "graph = {0: [1], 1: [0]}, k = 1",
        "isHidden": false,
        "description": "Edge graph: VC=1 iff IS=1"
      },
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, k = 2",
        "isHidden": false,
        "description": "Triangle: VC=2 iff IS=1"
      }
    ],
    "hints": [
      "Complement relationship: V - VC is an IS",
      "Graph stays the same, only k changes"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Reduce 3-SAT to Clique",
    "difficulty": 5,
    "description": "Implement the classic reduction from 3-SAT to Clique. Build a graph where satisfying assignments correspond to cliques.",
    "starterCode": "def reduce_3sat_to_clique(formula):\n    \"\"\"\n    Reduce 3-SAT to Clique problem.\n\n    Args:\n        formula: List of clauses, each with 3 literals\n\n    Returns:\n        tuple: (graph, k) where graph has a clique of size k\n               iff formula is satisfiable\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def reduce_3sat_to_clique(formula):\n    k = len(formula)  # One vertex per literal, k clauses\n    graph = {}\n\n    # Create vertices: (clause_index, literal_position)\n    for i, clause in enumerate(formula):\n        for j in range(3):\n            graph[(i, j)] = []\n\n    # Add edges between non-conflicting literals from different clauses\n    for i1, clause1 in enumerate(formula):\n        for j1 in range(3):\n            for i2, clause2 in enumerate(formula):\n                if i1 >= i2:\n                    continue\n                for j2 in range(3):\n                    lit1, lit2 = clause1[j1], clause2[j2]\n                    # Connect if literals don't conflict\n                    if lit1 != -lit2:\n                        graph[(i1, j1)].append((i2, j2))\n                        graph[(i2, j2)].append((i1, j1))\n\n    return (graph, k)",
    "testCases": [
      {
        "input": "formula = [[1, 2, 3], [-1, -2, -3]]",
        "isHidden": false,
        "description": "Two clauses"
      },
      {
        "input": "formula = [[1, 2, 3]]",
        "isHidden": false,
        "description": "Single clause"
      }
    ],
    "hints": [
      "Create vertex for each literal occurrence",
      "Connect non-conflicting literals from different clauses",
      "Clique size = number of clauses"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Reduce Clique to Vertex Cover",
    "difficulty": 4,
    "description": "Implement the reduction from Clique to Vertex Cover using graph complementation.",
    "starterCode": "def reduce_clique_to_vc(graph, k):\n    \"\"\"\n    Reduce Clique to Vertex Cover.\n\n    Args:\n        graph: Adjacency list\n        k: Clique size bound\n\n    Returns:\n        tuple: (complement_graph, k_prime) for equivalent VC instance\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def reduce_clique_to_vc(graph, k):\n    vertices = list(graph.keys())\n    n = len(vertices)\n\n    # Build complement graph\n    complement = {v: [] for v in vertices}\n    for v in vertices:\n        for u in vertices:\n            if u != v and u not in graph[v]:\n                complement[v].append(u)\n\n    k_prime = n - k  # VC of size n-k in complement\n    return (complement, k_prime)",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, k = 3",
        "isHidden": false,
        "description": "Triangle has clique 3"
      },
      {
        "input": "graph = {0: [1], 1: [0], 2: []}, k = 2",
        "isHidden": false,
        "description": "Edge plus isolated vertex"
      }
    ],
    "hints": [
      "Complement graph: edge iff no edge in original",
      "Clique in G iff Independent Set in complement"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Traveling Salesman Verifier",
    "difficulty": 3,
    "description": "Verify if a proposed tour is a valid Hamiltonian cycle with total weight at most k.",
    "starterCode": "def verify_tsp(distances, tour, k):\n    \"\"\"\n    Verify if tour is valid TSP solution with cost <= k.\n\n    Args:\n        distances: 2D matrix of distances\n        tour: List of vertices in visit order (including return)\n        k: Maximum allowed tour cost\n\n    Returns:\n        bool: True if valid tour with cost <= k\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_tsp(distances, tour, k):\n    n = len(distances)\n    if len(tour) != n + 1:\n        return False\n    if tour[0] != tour[-1]:\n        return False\n    if len(set(tour[:-1])) != n:\n        return False\n\n    total_cost = 0\n    for i in range(len(tour) - 1):\n        total_cost += distances[tour[i]][tour[i + 1]]\n\n    return total_cost <= k",
    "testCases": [
      {
        "input": "distances = [[0,10,15],[10,0,20],[15,20,0]], tour = [0,1,2,0], k = 45",
        "isHidden": false,
        "description": "Tour cost = 10+20+15 = 45"
      },
      {
        "input": "distances = [[0,10,15],[10,0,20],[15,20,0]], tour = [0,1,2,0], k = 40",
        "isHidden": false,
        "description": "Tour cost exceeds k"
      }
    ],
    "hints": [
      "Sum edge weights along the tour",
      "Verify it is a valid Hamiltonian cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Set Cover Verifier",
    "difficulty": 2,
    "description": "Verify if a collection of sets covers all elements in the universe.",
    "starterCode": "def verify_set_cover(universe, sets, selected, k):\n    \"\"\"\n    Verify if selected sets form a valid set cover.\n\n    Args:\n        universe: Set of all elements to cover\n        sets: List of sets available\n        selected: Indices of selected sets\n        k: Maximum number of sets allowed\n\n    Returns:\n        bool: True if selected sets cover universe with |selected| <= k\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_set_cover(universe, sets, selected, k):\n    if len(selected) > k:\n        return False\n    covered = set()\n    for i in selected:\n        covered.update(sets[i])\n    return universe.issubset(covered)",
    "testCases": [
      {
        "input": "universe = {1,2,3,4}, sets = [{1,2}, {2,3}, {3,4}], selected = [0, 2], k = 2",
        "isHidden": false,
        "description": "{1,2} and {3,4} cover all"
      },
      {
        "input": "universe = {1,2,3,4}, sets = [{1,2}, {3}], selected = [0, 1], k = 2",
        "isHidden": false,
        "description": "Missing element 4"
      }
    ],
    "hints": [
      "Union all selected sets",
      "Check if universe is covered"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Circuit Satisfiability Verifier",
    "difficulty": 3,
    "description": "Verify if a given input assignment satisfies a boolean circuit.",
    "starterCode": "def verify_circuit_sat(circuit, inputs):\n    \"\"\"\n    Verify if inputs satisfy the boolean circuit.\n\n    Args:\n        circuit: List of gates [(type, input1, input2), ...]\n                 Types: 'AND', 'OR', 'NOT', 'INPUT'\n        inputs: List of input values (True/False)\n\n    Returns:\n        bool: True if circuit outputs True\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_circuit_sat(circuit, inputs):\n    values = list(inputs)  # Wire values\n\n    for gate_type, *operands in circuit:\n        if gate_type == 'INPUT':\n            continue\n        elif gate_type == 'AND':\n            result = values[operands[0]] and values[operands[1]]\n        elif gate_type == 'OR':\n            result = values[operands[0]] or values[operands[1]]\n        elif gate_type == 'NOT':\n            result = not values[operands[0]]\n        values.append(result)\n\n    return values[-1]",
    "testCases": [
      {
        "input": "circuit = [('INPUT',), ('INPUT',), ('AND', 0, 1)], inputs = [True, True]",
        "isHidden": false,
        "description": "AND gate satisfied"
      },
      {
        "input": "circuit = [('INPUT',), ('NOT', 0)], inputs = [False]",
        "isHidden": false,
        "description": "NOT gate satisfied"
      }
    ],
    "hints": [
      "Evaluate gates in topological order",
      "Track wire values as you go"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Integer Linear Programming Verifier",
    "difficulty": 3,
    "description": "Verify if a proposed solution satisfies integer linear programming constraints.",
    "starterCode": "def verify_ilp(A, b, c, x, bound):\n    \"\"\"\n    Verify if x is a valid ILP solution with objective >= bound.\n\n    Args:\n        A: Constraint matrix (list of lists)\n        b: Constraint bounds (Ax <= b)\n        c: Objective coefficients\n        x: Proposed solution (integers)\n        bound: Minimum objective value required\n\n    Returns:\n        bool: True if constraints satisfied and c.x >= bound\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_ilp(A, b, c, x, bound):\n    # Check all constraints Ax <= b\n    for i, row in enumerate(A):\n        lhs = sum(row[j] * x[j] for j in range(len(x)))\n        if lhs > b[i]:\n            return False\n\n    # Check objective value\n    objective = sum(c[j] * x[j] for j in range(len(x)))\n    return objective >= bound",
    "testCases": [
      {
        "input": "A = [[1, 1], [2, 1]], b = [4, 5], c = [1, 2], x = [1, 2], bound = 4",
        "isHidden": false,
        "description": "Valid ILP solution"
      },
      {
        "input": "A = [[1, 1]], b = [2], c = [1, 1], x = [2, 1], bound = 2",
        "isHidden": false,
        "description": "Constraint violated"
      }
    ],
    "hints": [
      "Check each constraint row",
      "Compute objective function"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t1-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-1",
    "title": "Bin Packing Verifier",
    "difficulty": 2,
    "description": "Verify if a proposed bin assignment is valid for the bin packing problem.",
    "starterCode": "def verify_bin_packing(items, capacity, assignment, num_bins):\n    \"\"\"\n    Verify if assignment is valid bin packing with <= num_bins bins.\n\n    Args:\n        items: List of item sizes\n        capacity: Bin capacity\n        assignment: List mapping item index to bin number\n        num_bins: Maximum allowed bins\n\n    Returns:\n        bool: True if valid packing within bin limit\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_bin_packing(items, capacity, assignment, num_bins):\n    if max(assignment) >= num_bins:\n        return False\n\n    bin_loads = [0] * num_bins\n    for i, item_size in enumerate(items):\n        bin_loads[assignment[i]] += item_size\n\n    return all(load <= capacity for load in bin_loads)",
    "testCases": [
      {
        "input": "items = [4, 3, 3], capacity = 5, assignment = [0, 1, 1], num_bins = 2",
        "isHidden": false,
        "description": "Bin 0: 4, Bin 1: 6 - invalid"
      },
      {
        "input": "items = [2, 3, 2], capacity = 5, assignment = [0, 0, 1], num_bins = 2",
        "isHidden": false,
        "description": "Valid packing"
      }
    ],
    "hints": [
      "Track total size in each bin",
      "Check no bin exceeds capacity"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Vertex Cover 2-Approximation",
    "difficulty": 3,
    "description": "Implement a 2-approximation algorithm for the minimum vertex cover problem using the edge selection strategy.",
    "starterCode": "def vertex_cover_approximation(graph):\n    \"\"\"\n    Find a 2-approximation for minimum vertex cover.\n\n    Args:\n        graph: Dictionary representing adjacency list.\n\n    Returns:\n        set: A vertex cover (set of vertices covering all edges).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def vertex_cover_approximation(graph):\n    edges = set()\n    for u in graph:\n        for v in graph[u]:\n            if u < v:\n                edges.add((u, v))\n\n    cover = set()\n\n    while edges:\n        u, v = edges.pop()\n        cover.add(u)\n        cover.add(v)\n        edges = {e for e in edges if u not in e and v not in e}\n\n    return cover",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle graph"
      },
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": false,
        "description": "Path graph"
      }
    ],
    "hints": [
      "Select an edge and add both endpoints",
      "Remove all covered edges"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Greedy Set Cover",
    "difficulty": 3,
    "description": "Implement the greedy O(log n)-approximation algorithm for the set cover problem.",
    "starterCode": "def greedy_set_cover(universe, sets):\n    \"\"\"\n    Find an approximate set cover using the greedy algorithm.\n\n    Args:\n        universe: Set of elements to cover.\n        sets: List of sets.\n\n    Returns:\n        list: Indices of sets in the cover.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def greedy_set_cover(universe, sets):\n    uncovered = set(universe)\n    cover_indices = []\n\n    while uncovered:\n        best_idx = max(range(len(sets)), key=lambda i: len(sets[i] & uncovered))\n        if len(sets[best_idx] & uncovered) == 0:\n            break\n        cover_indices.append(best_idx)\n        uncovered -= sets[best_idx]\n\n    return cover_indices",
    "testCases": [
      {
        "input": "universe = {1, 2, 3, 4, 5}, sets = [{1, 2, 3}, {2, 4}, {3, 4}, {4, 5}]",
        "isHidden": false,
        "description": "Basic instance"
      },
      {
        "input": "universe = {1, 2, 3}, sets = [{1}, {2}, {3}, {1, 2, 3}]",
        "isHidden": false,
        "description": "Prefer largest set"
      }
    ],
    "hints": [
      "Select set covering most uncovered elements",
      "O(log n) approximation"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Metric TSP 2-Approximation",
    "difficulty": 4,
    "description": "Implement a 2-approximation for metric TSP using minimum spanning tree.",
    "starterCode": "def tsp_mst_approximation(distances):\n    \"\"\"\n    Find a 2-approximation for metric TSP using MST.\n\n    Args:\n        distances: 2D matrix of distances (satisfies triangle inequality)\n\n    Returns:\n        list: Tour as list of vertex indices\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def tsp_mst_approximation(distances):\n    n = len(distances)\n    # Prim's MST\n    in_mst = [False] * n\n    mst_adj = [[] for _ in range(n)]\n    in_mst[0] = True\n    edges = [(distances[0][j], 0, j) for j in range(1, n)]\n    import heapq\n    heapq.heapify(edges)\n\n    while edges:\n        cost, u, v = heapq.heappop(edges)\n        if in_mst[v]:\n            continue\n        in_mst[v] = True\n        mst_adj[u].append(v)\n        mst_adj[v].append(u)\n        for w in range(n):\n            if not in_mst[w]:\n                heapq.heappush(edges, (distances[v][w], v, w))\n\n    # DFS preorder traversal\n    tour = []\n    visited = [False] * n\n    def dfs(v):\n        visited[v] = True\n        tour.append(v)\n        for u in mst_adj[v]:\n            if not visited[u]:\n                dfs(u)\n    dfs(0)\n    tour.append(0)\n    return tour",
    "testCases": [
      {
        "input": "distances = [[0,1,2],[1,0,1],[2,1,0]]",
        "isHidden": false,
        "description": "3-city metric TSP"
      },
      {
        "input": "distances = [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]",
        "isHidden": false,
        "description": "Complete graph"
      }
    ],
    "hints": [
      "Build MST first",
      "DFS preorder gives Hamiltonian path",
      "Triangle inequality ensures shortcutting works"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Load Balancing Approximation",
    "difficulty": 3,
    "description": "Implement a 2-approximation for load balancing (makespan minimization) using LPT scheduling.",
    "starterCode": "def load_balance(jobs, num_machines):\n    \"\"\"\n    Assign jobs to machines to minimize makespan.\n\n    Args:\n        jobs: List of job processing times\n        num_machines: Number of machines\n\n    Returns:\n        list: Assignment of each job to a machine\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def load_balance(jobs, num_machines):\n    n = len(jobs)\n    assignment = [0] * n\n    loads = [0] * num_machines\n\n    # Sort jobs by decreasing size (LPT)\n    sorted_jobs = sorted(enumerate(jobs), key=lambda x: -x[1])\n\n    for job_idx, job_time in sorted_jobs:\n        # Assign to least loaded machine\n        min_machine = min(range(num_machines), key=lambda m: loads[m])\n        assignment[job_idx] = min_machine\n        loads[min_machine] += job_time\n\n    return assignment",
    "testCases": [
      {
        "input": "jobs = [3, 3, 2, 2, 2], num_machines = 2",
        "isHidden": false,
        "description": "Balance 5 jobs on 2 machines"
      },
      {
        "input": "jobs = [5, 4, 3, 2, 1], num_machines = 3",
        "isHidden": false,
        "description": "LPT scheduling"
      }
    ],
    "hints": [
      "Sort jobs by decreasing time",
      "Assign to least loaded machine",
      "This is LPT (Longest Processing Time)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Bin Packing First Fit Decreasing",
    "difficulty": 3,
    "description": "Implement the First Fit Decreasing (FFD) algorithm for bin packing, which achieves an 11/9 approximation.",
    "starterCode": "def bin_packing_ffd(items, capacity):\n    \"\"\"\n    Pack items into bins using First Fit Decreasing.\n\n    Args:\n        items: List of item sizes\n        capacity: Bin capacity\n\n    Returns:\n        list: Assignment of each item to a bin\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def bin_packing_ffd(items, capacity):\n    n = len(items)\n    assignment = [0] * n\n    sorted_items = sorted(enumerate(items), key=lambda x: -x[1])\n\n    bins = []  # Current space remaining in each bin\n\n    for item_idx, size in sorted_items:\n        placed = False\n        for bin_idx, remaining in enumerate(bins):\n            if remaining >= size:\n                assignment[item_idx] = bin_idx\n                bins[bin_idx] -= size\n                placed = True\n                break\n        if not placed:\n            assignment[item_idx] = len(bins)\n            bins.append(capacity - size)\n\n    return assignment",
    "testCases": [
      {
        "input": "items = [4, 8, 1, 4, 2, 1], capacity = 10",
        "isHidden": false,
        "description": "Decreasing order helps"
      },
      {
        "input": "items = [7, 5, 5, 3, 3, 3, 3], capacity = 10",
        "isHidden": false,
        "description": "FFD packing"
      }
    ],
    "hints": [
      "Sort items by decreasing size first",
      "First Fit: put in first bin that fits",
      "11/9 OPT + 6/9 approximation"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Knapsack FPTAS",
    "difficulty": 5,
    "description": "Implement a Fully Polynomial-Time Approximation Scheme (FPTAS) for the 0/1 knapsack problem.",
    "starterCode": "def knapsack_fptas(weights, values, capacity, epsilon):\n    \"\"\"\n    (1-epsilon)-approximation for knapsack.\n\n    Args:\n        weights: List of item weights\n        values: List of item values\n        capacity: Knapsack capacity\n        epsilon: Approximation parameter (0 < epsilon < 1)\n\n    Returns:\n        list: Indices of selected items\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def knapsack_fptas(weights, values, capacity, epsilon):\n    n = len(values)\n    if n == 0:\n        return []\n\n    v_max = max(values)\n    K = epsilon * v_max / n  # Scaling factor\n\n    # Scale values\n    scaled = [int(v / K) for v in values]\n    V = sum(scaled)\n\n    # DP with scaled values\n    # dp[v] = min weight to achieve value v\n    INF = float('inf')\n    dp = [INF] * (V + 1)\n    dp[0] = 0\n    parent = [[-1, -1] for _ in range(V + 1)]\n\n    for i in range(n):\n        for v in range(V, scaled[i] - 1, -1):\n            if dp[v - scaled[i]] + weights[i] < dp[v]:\n                dp[v] = dp[v - scaled[i]] + weights[i]\n                parent[v] = [i, v - scaled[i]]\n\n    # Find best achievable value within capacity\n    best_v = max(v for v in range(V + 1) if dp[v] <= capacity)\n\n    # Reconstruct solution\n    selected = []\n    v = best_v\n    while parent[v][0] != -1:\n        selected.append(parent[v][0])\n        v = parent[v][1]\n\n    return selected",
    "testCases": [
      {
        "input": "weights = [2, 3, 4, 5], values = [3, 4, 5, 6], capacity = 8, epsilon = 0.5",
        "isHidden": false,
        "description": "FPTAS knapsack"
      },
      {
        "input": "weights = [1, 2, 3], values = [10, 20, 30], capacity = 4, epsilon = 0.3",
        "isHidden": false,
        "description": "Small instance"
      }
    ],
    "hints": [
      "Scale values by K = εv_max/n",
      "Run DP on scaled values",
      "Time is O(n³/ε)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "MAX-SAT Approximation",
    "difficulty": 4,
    "description": "Implement a 1/2-approximation for MAX-SAT using random assignment.",
    "starterCode": "def max_sat_random(formula, num_vars):\n    \"\"\"\n    Random 1/2-approximation for MAX-SAT.\n\n    Args:\n        formula: List of clauses (each clause is list of literals)\n        num_vars: Number of variables\n\n    Returns:\n        tuple: (assignment dict, number of satisfied clauses)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef max_sat_random(formula, num_vars):\n    # Random assignment\n    assignment = {i: random.random() < 0.5 for i in range(1, num_vars + 1)}\n\n    # Count satisfied clauses\n    satisfied = 0\n    for clause in formula:\n        for literal in clause:\n            var = abs(literal)\n            if (literal > 0 and assignment[var]) or (literal < 0 and not assignment[var]):\n                satisfied += 1\n                break\n\n    return (assignment, satisfied)",
    "testCases": [
      {
        "input": "formula = [[1, 2], [-1, -2], [1, -2]], num_vars = 2",
        "isHidden": false,
        "description": "Simple MAX-SAT"
      },
      {
        "input": "formula = [[1], [-1]], num_vars = 1",
        "isHidden": false,
        "description": "Contradictory clauses"
      }
    ],
    "hints": [
      "Random assignment satisfies each clause with probability >= 1/2",
      "Expected number >= m/2 clauses"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Christofides Algorithm Helper",
    "difficulty": 4,
    "description": "Implement minimum weight perfect matching for odd-degree vertices (part of Christofides algorithm).",
    "starterCode": "def find_odd_vertices(mst_adj, n):\n    \"\"\"\n    Find vertices with odd degree in MST.\n\n    Args:\n        mst_adj: Adjacency list of MST\n        n: Number of vertices\n\n    Returns:\n        list: Vertices with odd degree\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def find_odd_vertices(mst_adj, n):\n    odd_vertices = []\n    for v in range(n):\n        if len(mst_adj[v]) % 2 == 1:\n            odd_vertices.append(v)\n    return odd_vertices",
    "testCases": [
      {
        "input": "mst_adj = [[1], [0, 2], [1]], n = 3",
        "isHidden": false,
        "description": "Path: endpoints odd"
      },
      {
        "input": "mst_adj = [[1, 2, 3], [0], [0], [0]], n = 4",
        "isHidden": false,
        "description": "Star: center has degree 3"
      }
    ],
    "hints": [
      "Count degree of each vertex",
      "Odd if degree is odd number"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Weighted Vertex Cover LP Rounding",
    "difficulty": 4,
    "description": "Implement LP rounding for weighted vertex cover (2-approximation).",
    "starterCode": "def weighted_vertex_cover_lp(graph, weights):\n    \"\"\"\n    2-approximation for weighted vertex cover via LP rounding.\n\n    Args:\n        graph: Adjacency list\n        weights: Vertex weights\n\n    Returns:\n        set: Vertices in cover\n    \"\"\"\n    # Your code here (assume LP solution provided)\n    pass",
    "solution": "def weighted_vertex_cover_lp(graph, weights):\n    # Simulate LP relaxation result\n    # In practice, would solve LP: min sum(w_v * x_v) s.t. x_u + x_v >= 1 for each edge\n    # Round: include v if x_v >= 1/2\n\n    n = len(graph)\n    # Simple greedy heuristic simulating LP\n    cover = set()\n    uncovered_edges = set()\n    for u in graph:\n        for v in graph[u]:\n            if u < v:\n                uncovered_edges.add((u, v))\n\n    while uncovered_edges:\n        # Pick edge, add cheaper endpoint (heuristic for LP)\n        u, v = uncovered_edges.pop()\n        chosen = u if weights[u] <= weights[v] else v\n        cover.add(chosen)\n        uncovered_edges = {e for e in uncovered_edges if chosen not in e}\n\n    return cover",
    "testCases": [
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1]}, weights = [1, 10, 1]",
        "isHidden": false,
        "description": "Prefer cheap vertices"
      },
      {
        "input": "graph = {0: [1, 2], 1: [0], 2: [0]}, weights = [3, 1, 1]",
        "isHidden": false,
        "description": "Star with expensive center"
      }
    ],
    "hints": [
      "LP relaxation allows fractional solutions",
      "Round threshold at 1/2",
      "This gives 2-approximation"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Max Cut Approximation",
    "difficulty": 4,
    "description": "Implement a 1/2-approximation for MAX-CUT using a simple greedy algorithm.",
    "starterCode": "def max_cut_greedy(graph):\n    \"\"\"\n    1/2-approximation for MAX-CUT.\n\n    Args:\n        graph: Adjacency list with edge weights\n\n    Returns:\n        tuple: (set S, set T) partition\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def max_cut_greedy(graph):\n    vertices = list(graph.keys())\n    S, T = set(), set()\n\n    for v in vertices:\n        # Count edges to S and T\n        edges_to_S = sum(1 for u in graph[v] if u in S)\n        edges_to_T = sum(1 for u in graph[v] if u in T)\n\n        # Put v on side with fewer neighbors (more crossing edges)\n        if edges_to_S <= edges_to_T:\n            S.add(v)\n        else:\n            T.add(v)\n\n    return (S, T)",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle"
      },
      {
        "input": "graph = {0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": false,
        "description": "Star graph"
      }
    ],
    "hints": [
      "Process vertices one by one",
      "Put each vertex where it creates more cut edges",
      "Each edge counted with probability >= 1/2"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Metric k-Center",
    "difficulty": 4,
    "description": "Implement a 2-approximation for the metric k-center problem.",
    "starterCode": "def k_center(distances, k):\n    \"\"\"\n    2-approximation for k-center.\n\n    Args:\n        distances: Distance matrix\n        k: Number of centers\n\n    Returns:\n        list: Indices of k center vertices\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def k_center(distances, k):\n    n = len(distances)\n    if k >= n:\n        return list(range(n))\n\n    centers = [0]  # Start with arbitrary point\n    min_dist = list(distances[0])  # Distance to nearest center\n\n    for _ in range(k - 1):\n        # Find farthest point from current centers\n        farthest = max(range(n), key=lambda v: min_dist[v])\n        centers.append(farthest)\n\n        # Update min distances\n        for v in range(n):\n            min_dist[v] = min(min_dist[v], distances[farthest][v])\n\n    return centers",
    "testCases": [
      {
        "input": "distances = [[0,1,2],[1,0,1],[2,1,0]], k = 2",
        "isHidden": false,
        "description": "3 points, 2 centers"
      },
      {
        "input": "distances = [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]], k = 1",
        "isHidden": false,
        "description": "Single center"
      }
    ],
    "hints": [
      "Greedy farthest-first traversal",
      "Each new center is farthest from existing",
      "2-approximation for metric spaces"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Steiner Tree Approximation",
    "difficulty": 5,
    "description": "Implement a 2-approximation for the Steiner tree problem using MST on metric closure.",
    "starterCode": "def steiner_tree(graph, terminals):\n    \"\"\"\n    2-approximation for Steiner tree.\n\n    Args:\n        graph: Weighted adjacency list\n        terminals: Set of terminal vertices\n\n    Returns:\n        list: Edges in approximate Steiner tree\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def steiner_tree(graph, terminals):\n    # Compute shortest paths between all terminals\n    import heapq\n\n    def dijkstra(src):\n        dist = {v: float('inf') for v in graph}\n        dist[src] = 0\n        pq = [(0, src)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n\n    # Build complete graph on terminals with shortest path distances\n    terminal_list = list(terminals)\n    terminal_dist = {t: dijkstra(t) for t in terminal_list}\n\n    # MST on terminals using Prim's\n    in_mst = {terminal_list[0]}\n    mst_edges = []\n    while len(in_mst) < len(terminal_list):\n        best_edge = None\n        best_cost = float('inf')\n        for u in in_mst:\n            for v in terminal_list:\n                if v not in in_mst and terminal_dist[u][v] < best_cost:\n                    best_cost = terminal_dist[u][v]\n                    best_edge = (u, v)\n        if best_edge:\n            mst_edges.append(best_edge)\n            in_mst.add(best_edge[1])\n\n    return mst_edges",
    "testCases": [
      {
        "input": "graph = {0: [(1, 1)], 1: [(0, 1), (2, 1)], 2: [(1, 1)]}, terminals = {0, 2}",
        "isHidden": false,
        "description": "Path graph"
      },
      {
        "input": "graph = {0: [(1, 1), (2, 2)], 1: [(0, 1), (2, 1)], 2: [(0, 2), (1, 1)]}, terminals = {0, 1, 2}",
        "isHidden": false,
        "description": "Triangle"
      }
    ],
    "hints": [
      "Compute metric closure on terminals",
      "Find MST on terminal graph",
      "Expand paths back to original graph"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Facility Location Greedy",
    "difficulty": 4,
    "description": "Implement a greedy approximation for the uncapacitated facility location problem.",
    "starterCode": "def facility_location(facility_costs, connection_costs):\n    \"\"\"\n    Greedy approximation for facility location.\n\n    Args:\n        facility_costs: List of opening costs for each facility\n        connection_costs: 2D list where [i][j] is cost to connect client i to facility j\n\n    Returns:\n        list: Indices of opened facilities\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def facility_location(facility_costs, connection_costs):\n    num_clients = len(connection_costs)\n    num_facilities = len(facility_costs)\n\n    opened = set()\n    assigned = [None] * num_clients\n\n    # Greedy: repeatedly open best facility\n    while None in assigned:\n        best_facility = None\n        best_improvement = -float('inf')\n\n        for f in range(num_facilities):\n            if f in opened:\n                continue\n            # Cost to open and connect unassigned clients\n            improvement = -facility_costs[f]\n            for c in range(num_clients):\n                if assigned[c] is None:\n                    curr_cost = min(connection_costs[c][of] for of in opened) if opened else float('inf')\n                    new_cost = connection_costs[c][f]\n                    improvement += max(0, curr_cost - new_cost)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_facility = f\n\n        if best_facility is None:\n            break\n\n        opened.add(best_facility)\n        # Assign clients to closest open facility\n        for c in range(num_clients):\n            if assigned[c] is None or connection_costs[c][best_facility] < connection_costs[c][assigned[c]]:\n                assigned[c] = best_facility\n\n    return list(opened)",
    "testCases": [
      {
        "input": "facility_costs = [10, 10], connection_costs = [[1, 5], [5, 1]]",
        "isHidden": false,
        "description": "Two facilities, two clients"
      },
      {
        "input": "facility_costs = [5, 5, 5], connection_costs = [[1, 2, 3], [3, 2, 1]]",
        "isHidden": false,
        "description": "Symmetric setup"
      }
    ],
    "hints": [
      "Open facility with best cost/benefit ratio",
      "Consider opening cost plus connection savings"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Graph Coloring Greedy",
    "difficulty": 2,
    "description": "Implement greedy graph coloring that uses at most Δ+1 colors where Δ is max degree.",
    "starterCode": "def greedy_coloring(graph):\n    \"\"\"\n    Greedy graph coloring.\n\n    Args:\n        graph: Adjacency list\n\n    Returns:\n        dict: Mapping from vertex to color\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def greedy_coloring(graph):\n    coloring = {}\n    vertices = sorted(graph.keys(), key=lambda v: -len(graph[v]))  # Process high-degree first\n\n    for v in vertices:\n        # Find colors used by neighbors\n        neighbor_colors = {coloring[u] for u in graph[v] if u in coloring}\n\n        # Assign smallest available color\n        color = 0\n        while color in neighbor_colors:\n            color += 1\n        coloring[v] = color\n\n    return coloring",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle needs 3 colors"
      },
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": false,
        "description": "Path needs 2 colors"
      }
    ],
    "hints": [
      "Use smallest color not used by neighbors",
      "At most Δ+1 colors needed"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Makespan Lower Bound",
    "difficulty": 2,
    "description": "Compute lower bounds on optimal makespan for load balancing.",
    "starterCode": "def makespan_lower_bound(jobs, num_machines):\n    \"\"\"\n    Compute lower bounds on optimal makespan.\n\n    Args:\n        jobs: List of job times\n        num_machines: Number of machines\n\n    Returns:\n        float: Lower bound on optimal makespan\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def makespan_lower_bound(jobs, num_machines):\n    # Two lower bounds:\n    # 1. Average load\n    avg_bound = sum(jobs) / num_machines\n    # 2. Largest job\n    max_bound = max(jobs) if jobs else 0\n    return max(avg_bound, max_bound)",
    "testCases": [
      {
        "input": "jobs = [4, 3, 3], num_machines = 2",
        "isHidden": false,
        "description": "Total=10, max=4, LB=5"
      },
      {
        "input": "jobs = [10, 1, 1, 1], num_machines = 2",
        "isHidden": false,
        "description": "Large job dominates"
      }
    ],
    "hints": [
      "Average load is a lower bound",
      "Largest job is a lower bound",
      "Take maximum"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t2-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-2",
    "title": "Approximation Ratio Calculator",
    "difficulty": 2,
    "description": "Calculate the approximation ratio given algorithm output and optimal solution.",
    "starterCode": "def approximation_ratio(algorithm_value, optimal_value, is_minimization):\n    \"\"\"\n    Calculate approximation ratio.\n\n    Args:\n        algorithm_value: Value achieved by algorithm\n        optimal_value: Optimal value\n        is_minimization: True if minimization problem\n\n    Returns:\n        float: Approximation ratio (>= 1)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def approximation_ratio(algorithm_value, optimal_value, is_minimization):\n    if optimal_value == 0:\n        return float('inf') if algorithm_value != 0 else 1.0\n\n    if is_minimization:\n        return algorithm_value / optimal_value\n    else:\n        return optimal_value / algorithm_value",
    "testCases": [
      {
        "input": "algorithm_value = 10, optimal_value = 5, is_minimization = True",
        "isHidden": false,
        "description": "2-approx for min"
      },
      {
        "input": "algorithm_value = 7, optimal_value = 10, is_minimization = False",
        "isHidden": false,
        "description": "10/7-approx for max"
      }
    ],
    "hints": [
      "For min: ALG/OPT",
      "For max: OPT/ALG",
      "Ratio >= 1 by convention"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Quicksort",
    "difficulty": 2,
    "description": "Implement randomized quicksort that randomly selects pivots to achieve expected O(n log n) time complexity.",
    "starterCode": "import random\n\ndef randomized_quicksort(arr):\n    \"\"\"\n    Sort an array using randomized quicksort.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        list: Sorted array.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_quicksort(arr):\n    \"\"\"\n    Sort an array using randomized quicksort.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        list: Sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    # Randomly select a pivot\n    pivot_idx = random.randint(0, len(arr) - 1)\n    pivot = arr[pivot_idx]\n\n    # Partition the array\n    less = [x for x in arr if x < pivot]\n    equal = [x for x in arr if x == pivot]\n    greater = [x for x in arr if x > pivot]\n\n    # Recursively sort and combine\n    return randomized_quicksort(less) + equal + randomized_quicksort(greater)",
    "testCases": [
      {
        "input": "arr = [3, 1, 4, 1, 5, 9, 2, 6]",
        "isHidden": false,
        "description": "Random array with duplicates"
      },
      {
        "input": "arr = [5, 4, 3, 2, 1]",
        "isHidden": false,
        "description": "Reverse sorted array - worst case for deterministic quicksort"
      },
      {
        "input": "arr = [1]",
        "isHidden": false,
        "description": "Single element array"
      }
    ],
    "hints": [
      "Randomly select a pivot element from the array",
      "Partition the array into elements less than, equal to, and greater than the pivot",
      "Recursively sort the less and greater partitions",
      "Random pivot selection makes expected time complexity O(n log n) regardless of input"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Monte Carlo Primality Testing",
    "difficulty": 3,
    "description": "Implement the Miller-Rabin primality test, a Monte Carlo algorithm that probabilistically determines if a number is prime.",
    "starterCode": "import random\n\ndef miller_rabin(n, k=5):\n    \"\"\"\n    Test if n is prime using Miller-Rabin algorithm.\n\n    Args:\n        n: Integer to test for primality.\n        k: Number of rounds (higher k = more confidence).\n\n    Returns:\n        bool: True if n is probably prime, False if definitely composite.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef miller_rabin(n, k=5):\n    \"\"\"\n    Test if n is prime using Miller-Rabin algorithm.\n\n    Args:\n        n: Integer to test for primality.\n        k: Number of rounds (higher k = more confidence).\n\n    Returns:\n        bool: True if n is probably prime, False if definitely composite.\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Write n-1 as 2^r * d\n    r, d = 0, n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n\n    # Perform k rounds of testing\n    for _ in range(k):\n        a = random.randint(2, n - 2)\n        x = pow(a, d, n)\n\n        if x == 1 or x == n - 1:\n            continue\n\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "n = 17, k = 5",
        "isHidden": false,
        "description": "Small prime number"
      },
      {
        "input": "n = 561, k = 5",
        "isHidden": false,
        "description": "Carmichael number (composite but passes Fermat test)"
      },
      {
        "input": "n = 97, k = 5",
        "isHidden": false,
        "description": "Prime number"
      }
    ],
    "hints": [
      "Write n-1 as 2^r * d where d is odd",
      "For each round, pick a random witness a",
      "Compute x = a^d mod n",
      "If n is prime, x must be 1 or n-1, or squaring x repeatedly must eventually yield n-1"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized QuickSelect",
    "difficulty": 2,
    "description": "Implement the randomized QuickSelect algorithm to find the k-th smallest element in O(n) expected time.",
    "starterCode": "import random\n\ndef quickselect(arr, k):\n    \"\"\"\n    Find the k-th smallest element (0-indexed) using randomized QuickSelect.\n\n    Args:\n        arr: List of comparable elements.\n        k: Index of the element to find (0-indexed).\n\n    Returns:\n        The k-th smallest element.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef quickselect(arr, k):\n    \"\"\"\n    Find the k-th smallest element (0-indexed) using randomized QuickSelect.\n\n    Args:\n        arr: List of comparable elements.\n        k: Index of the element to find (0-indexed).\n\n    Returns:\n        The k-th smallest element.\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n\n    # Randomly select pivot\n    pivot = random.choice(arr)\n\n    # Partition array\n    less = [x for x in arr if x < pivot]\n    equal = [x for x in arr if x == pivot]\n    greater = [x for x in arr if x > pivot]\n\n    # Determine which partition contains k-th element\n    if k < len(less):\n        return quickselect(less, k)\n    elif k < len(less) + len(equal):\n        return pivot\n    else:\n        return quickselect(greater, k - len(less) - len(equal))",
    "testCases": [
      {
        "input": "arr = [3, 1, 4, 1, 5, 9, 2, 6], k = 4",
        "isHidden": false,
        "description": "Find median (4th smallest element)"
      },
      {
        "input": "arr = [7, 10, 4, 3, 20, 15], k = 2",
        "isHidden": false,
        "description": "Find 3rd smallest element"
      },
      {
        "input": "arr = [5, 5, 5, 5, 5], k = 0",
        "isHidden": false,
        "description": "All elements equal"
      }
    ],
    "hints": [
      "Randomly select a pivot to ensure expected O(n) time",
      "Partition array into elements less than, equal to, and greater than pivot",
      "Recursively search only the partition containing the k-th element",
      "Expected time is O(n) because each recursion reduces size by constant factor"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Bloom Filter",
    "difficulty": 3,
    "description": "Implement a Bloom filter, a space-efficient probabilistic data structure for set membership testing.",
    "starterCode": "import random\n\nclass BloomFilter:\n    \"\"\"\n    Bloom filter for probabilistic set membership testing.\n    \"\"\"\n    def __init__(self, size, num_hashes):\n        \"\"\"\n        Initialize Bloom filter.\n\n        Args:\n            size: Size of bit array.\n            num_hashes: Number of hash functions to use.\n        \"\"\"\n        # Your code here\n        pass\n\n    def add(self, item):\n        \"\"\"Add item to the filter.\"\"\"\n        # Your code here\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if item might be in the set.\n\n        Returns:\n            bool: False means definitely not in set, True means probably in set.\n        \"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass BloomFilter:\n    \"\"\"\n    Bloom filter for probabilistic set membership testing.\n    \"\"\"\n    def __init__(self, size, num_hashes):\n        \"\"\"\n        Initialize Bloom filter.\n\n        Args:\n            size: Size of bit array.\n            num_hashes: Number of hash functions to use.\n        \"\"\"\n        self.size = size\n        self.num_hashes = num_hashes\n        self.bit_array = [0] * size\n\n    def _hash(self, item, seed):\n        \"\"\"Generate hash value for item with given seed.\"\"\"\n        random.seed(str(item) + str(seed))\n        return random.randint(0, self.size - 1)\n\n    def add(self, item):\n        \"\"\"Add item to the filter.\"\"\"\n        for i in range(self.num_hashes):\n            index = self._hash(item, i)\n            self.bit_array[index] = 1\n\n    def contains(self, item):\n        \"\"\"\n        Check if item might be in the set.\n\n        Returns:\n            bool: False means definitely not in set, True means probably in set.\n        \"\"\"\n        for i in range(self.num_hashes):\n            index = self._hash(item, i)\n            if self.bit_array[index] == 0:\n                return False\n        return True",
    "testCases": [
      {
        "input": "bf = BloomFilter(100, 3); bf.add(\"apple\"); bf.add(\"banana\"); bf.contains(\"apple\")",
        "isHidden": false,
        "description": "Test membership of added items"
      },
      {
        "input": "bf = BloomFilter(100, 3); bf.add(\"cat\"); bf.contains(\"dog\")",
        "isHidden": false,
        "description": "Test non-membership (may have false positives)"
      },
      {
        "input": "bf = BloomFilter(50, 5); [bf.add(i) for i in range(10)]; bf.contains(5)",
        "isHidden": false,
        "description": "Multiple items, check membership"
      }
    ],
    "hints": [
      "Use a bit array to store the filter state",
      "For adding, set k bits (where k = num_hashes) based on hash functions",
      "For checking, verify all k bits are set",
      "False positives are possible but false negatives are not",
      "Use different seeds for each hash function"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Reservoir Sampling",
    "difficulty": 2,
    "description": "Implement reservoir sampling to randomly select k items from a stream of unknown length with uniform probability.",
    "starterCode": "import random\n\ndef reservoir_sampling(stream, k):\n    \"\"\"\n    Randomly select k items from a stream with uniform probability.\n\n    Args:\n        stream: Iterator or list of items.\n        k: Number of items to sample.\n\n    Returns:\n        list: k randomly selected items.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef reservoir_sampling(stream, k):\n    \"\"\"\n    Randomly select k items from a stream with uniform probability.\n\n    Args:\n        stream: Iterator or list of items.\n        k: Number of items to sample.\n\n    Returns:\n        list: k randomly selected items.\n    \"\"\"\n    reservoir = []\n\n    for i, item in enumerate(stream):\n        if i < k:\n            # Fill reservoir with first k items\n            reservoir.append(item)\n        else:\n            # Randomly replace items with decreasing probability\n            j = random.randint(0, i)\n            if j < k:\n                reservoir[j] = item\n\n    return reservoir",
    "testCases": [
      {
        "input": "stream = range(100), k = 10",
        "isHidden": false,
        "description": "Sample 10 items from stream of 100"
      },
      {
        "input": "stream = [1, 2, 3, 4, 5], k = 3",
        "isHidden": false,
        "description": "Small stream, sample 3 items"
      },
      {
        "input": "stream = range(1000), k = 5",
        "isHidden": false,
        "description": "Large stream, small sample"
      }
    ],
    "hints": [
      "Keep first k items in the reservoir",
      "For item at index i (i >= k), include it with probability k/i",
      "If included, replace a random item in the reservoir",
      "This ensures each item has equal probability k/n of being selected",
      "Works for streams of unknown length"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Skip List Implementation",
    "difficulty": 4,
    "description": "Implement a skip list, a randomized data structure that provides O(log n) expected time for search, insert, and delete.",
    "starterCode": "import random\n\nclass SkipListNode:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level=16, p=0.5):\n        \"\"\"\n        Initialize skip list.\n\n        Args:\n            max_level: Maximum number of levels.\n            p: Probability for level generation.\n        \"\"\"\n        # Your code here\n        pass\n\n    def random_level(self):\n        \"\"\"Generate random level for new node.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, value):\n        \"\"\"Insert value into skip list.\"\"\"\n        # Your code here\n        pass\n\n    def search(self, value):\n        \"\"\"Search for value in skip list.\"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass SkipListNode:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level=16, p=0.5):\n        \"\"\"\n        Initialize skip list.\n\n        Args:\n            max_level: Maximum number of levels.\n            p: Probability for level generation.\n        \"\"\"\n        self.max_level = max_level\n        self.p = p\n        self.header = SkipListNode(float('-inf'), max_level)\n        self.level = 0\n\n    def random_level(self):\n        \"\"\"Generate random level for new node.\"\"\"\n        level = 0\n        while random.random() < self.p and level < self.max_level:\n            level += 1\n        return level\n\n    def insert(self, value):\n        \"\"\"Insert value into skip list.\"\"\"\n        update = [None] * (self.max_level + 1)\n        current = self.header\n\n        # Find position to insert\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n            update[i] = current\n\n        # Generate random level\n        level = self.random_level()\n\n        # Update level if needed\n        if level > self.level:\n            for i in range(self.level + 1, level + 1):\n                update[i] = self.header\n            self.level = level\n\n        # Create and insert new node\n        new_node = SkipListNode(value, level)\n        for i in range(level + 1):\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n\n    def search(self, value):\n        \"\"\"Search for value in skip list.\"\"\"\n        current = self.header\n\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n\n        current = current.forward[0]\n        return current is not None and current.value == value",
    "testCases": [
      {
        "input": "sl = SkipList(); sl.insert(3); sl.insert(1); sl.insert(4); sl.search(3)",
        "isHidden": false,
        "description": "Insert and search for existing element"
      },
      {
        "input": "sl = SkipList(); sl.insert(5); sl.insert(2); sl.search(7)",
        "isHidden": false,
        "description": "Search for non-existing element"
      },
      {
        "input": "sl = SkipList(); [sl.insert(i) for i in range(10)]; sl.search(5)",
        "isHidden": false,
        "description": "Multiple insertions"
      }
    ],
    "hints": [
      "Skip list has multiple levels, each acting as an express lane",
      "Use random level generation with probability p",
      "Maintain forward pointers at each level",
      "Search by starting at highest level and descending",
      "Expected time complexity is O(log n) for all operations"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Treap Implementation",
    "difficulty": 4,
    "description": "Implement a treap (tree + heap), a randomized BST where each node has a random priority to maintain balance.",
    "starterCode": "import random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def rotate_right(self, node):\n        \"\"\"Perform right rotation.\"\"\"\n        # Your code here\n        pass\n\n    def rotate_left(self, node):\n        \"\"\"Perform left rotation.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, key):\n        \"\"\"Insert key into treap.\"\"\"\n        # Your code here\n        pass\n\n    def search(self, key):\n        \"\"\"Search for key in treap.\"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def rotate_right(self, node):\n        \"\"\"Perform right rotation.\"\"\"\n        left_child = node.left\n        node.left = left_child.right\n        left_child.right = node\n        return left_child\n\n    def rotate_left(self, node):\n        \"\"\"Perform left rotation.\"\"\"\n        right_child = node.right\n        node.right = right_child.left\n        right_child.left = node\n        return right_child\n\n    def _insert(self, node, key):\n        \"\"\"Helper method to insert key.\"\"\"\n        if node is None:\n            return TreapNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n            # Maintain heap property\n            if node.left.priority > node.priority:\n                node = self.rotate_right(node)\n        else:\n            node.right = self._insert(node.right, key)\n            # Maintain heap property\n            if node.right.priority > node.priority:\n                node = self.rotate_left(node)\n\n        return node\n\n    def insert(self, key):\n        \"\"\"Insert key into treap.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _search(self, node, key):\n        \"\"\"Helper method to search.\"\"\"\n        if node is None:\n            return False\n        if node.key == key:\n            return True\n        elif key < node.key:\n            return self._search(node.left, key)\n        else:\n            return self._search(node.right, key)\n\n    def search(self, key):\n        \"\"\"Search for key in treap.\"\"\"\n        return self._search(self.root, key)",
    "testCases": [
      {
        "input": "t = Treap(); t.insert(5); t.insert(3); t.insert(7); t.search(3)",
        "isHidden": false,
        "description": "Basic insertion and search"
      },
      {
        "input": "t = Treap(); [t.insert(i) for i in [1,2,3,4,5]]; t.search(3)",
        "isHidden": false,
        "description": "Sequential insertions (would unbalance regular BST)"
      },
      {
        "input": "t = Treap(); t.insert(10); t.search(5)",
        "isHidden": false,
        "description": "Search for non-existing key"
      }
    ],
    "hints": [
      "Treap maintains BST property by keys and heap property by random priorities",
      "Insert as in BST, then rotate to maintain heap property",
      "Rotations preserve BST property while fixing heap violations",
      "Random priorities ensure expected O(log n) height",
      "Use right rotation when left child priority > parent priority"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Min-Cut",
    "difficulty": 5,
    "description": "Implement Karger's randomized algorithm to find the minimum cut in an undirected graph.",
    "starterCode": "import random\n\ndef karger_min_cut(graph, iterations=100):\n    \"\"\"\n    Find minimum cut using Karger's randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n        iterations: Number of times to repeat the algorithm.\n\n    Returns:\n        int: Size of minimum cut found.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef karger_min_cut(graph, iterations=100):\n    \"\"\"\n    Find minimum cut using Karger's randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n        iterations: Number of times to repeat the algorithm.\n\n    Returns:\n        int: Size of minimum cut found.\n    \"\"\"\n    def contract_edge(g):\n        \"\"\"Contract a random edge in the graph.\"\"\"\n        # Make a copy\n        g = {k: v[:] for k, v in g.items()}\n\n        while len(g) > 2:\n            # Pick random edge\n            u = random.choice(list(g.keys()))\n            v = random.choice(g[u])\n\n            # Merge v into u\n            g[u].extend(g[v])\n\n            # Update all edges pointing to v to point to u\n            for node in g[v]:\n                g[node] = [u if x == v else x for x in g[node]]\n\n            # Remove self-loops\n            g[u] = [x for x in g[u] if x != u]\n\n            # Remove v\n            del g[v]\n\n        # Return size of cut\n        return len(list(g.values())[0])\n\n    min_cut = float('inf')\n\n    for _ in range(iterations):\n        cut_size = contract_edge(graph)\n        min_cut = min(min_cut, cut_size)\n\n    return min_cut",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, iterations = 50",
        "isHidden": false,
        "description": "Triangle graph - min cut is 2"
      },
      {
        "input": "graph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}, iterations = 50",
        "isHidden": false,
        "description": "Square graph - min cut is 2"
      },
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, iterations = 50",
        "isHidden": false,
        "description": "Path graph - min cut is 1"
      }
    ],
    "hints": [
      "Repeatedly contract random edges until 2 vertices remain",
      "Contracting edge (u,v) means merging v into u",
      "Update all edges pointing to v to point to u instead",
      "Remove self-loops after contraction",
      "Run multiple iterations and take minimum (success probability increases)",
      "With O(n^2 log n) iterations, high probability of finding min cut"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Las Vegas Algorithm - Random Binary Search",
    "difficulty": 2,
    "description": "Implement a Las Vegas algorithm for binary search that always returns correct result but has randomized runtime.",
    "starterCode": "import random\n\ndef las_vegas_binary_search(arr, target):\n    \"\"\"\n    Las Vegas binary search - always correct, randomized runtime.\n\n    Args:\n        arr: Sorted list of elements.\n        target: Element to find.\n\n    Returns:\n        int: Index of target, or -1 if not found.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef las_vegas_binary_search(arr, target):\n    \"\"\"\n    Las Vegas binary search - always correct, randomized runtime.\n\n    Args:\n        arr: Sorted list of elements.\n        target: Element to find.\n\n    Returns:\n        int: Index of target, or -1 if not found.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        # Randomly choose mid point instead of (left + right) // 2\n        mid = random.randint(left, right)\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1",
    "testCases": [
      {
        "input": "arr = [1, 3, 5, 7, 9, 11, 13], target = 7",
        "isHidden": false,
        "description": "Find element in middle"
      },
      {
        "input": "arr = [2, 4, 6, 8, 10, 12, 14, 16], target = 2",
        "isHidden": false,
        "description": "Find first element"
      },
      {
        "input": "arr = [1, 2, 3, 4, 5], target = 6",
        "isHidden": false,
        "description": "Element not in array"
      }
    ],
    "hints": [
      "Las Vegas algorithms always produce correct output",
      "Runtime is randomized, not the output",
      "Choose random midpoint instead of deterministic (left + right) // 2",
      "Expected runtime is still O(log n)",
      "Worst case runtime could be O(n) with bad luck"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Monte Carlo Pi Estimation",
    "difficulty": 1,
    "description": "Use Monte Carlo method to estimate π by randomly sampling points in a unit square.",
    "starterCode": "import random\n\ndef estimate_pi(num_samples):\n    \"\"\"\n    Estimate pi using Monte Carlo method.\n\n    Args:\n        num_samples: Number of random points to sample.\n\n    Returns:\n        float: Estimate of pi.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef estimate_pi(num_samples):\n    \"\"\"\n    Estimate pi using Monte Carlo method.\n\n    Args:\n        num_samples: Number of random points to sample.\n\n    Returns:\n        float: Estimate of pi.\n    \"\"\"\n    inside_circle = 0\n\n    for _ in range(num_samples):\n        # Random point in unit square [0,1] x [0,1]\n        x = random.random()\n        y = random.random()\n\n        # Check if point is inside unit circle\n        if x*x + y*y <= 1:\n            inside_circle += 1\n\n    # Area of quarter circle / Area of unit square = pi/4\n    return 4 * inside_circle / num_samples",
    "testCases": [
      {
        "input": "num_samples = 10000",
        "isHidden": false,
        "description": "Estimate with 10,000 samples"
      },
      {
        "input": "num_samples = 100000",
        "isHidden": false,
        "description": "More samples = better estimate"
      },
      {
        "input": "num_samples = 1000",
        "isHidden": false,
        "description": "Fewer samples = less accurate"
      }
    ],
    "hints": [
      "Sample random points (x, y) in unit square [0,1] x [0,1]",
      "Check if point is inside unit circle: x^2 + y^2 <= 1",
      "Ratio of points inside circle to total points ≈ π/4",
      "Multiply by 4 to get π estimate",
      "More samples give better approximation"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Load Balancing",
    "difficulty": 2,
    "description": "Implement randomized load balancing where jobs are assigned to random servers.",
    "starterCode": "import random\n\ndef randomized_load_balance(jobs, num_servers):\n    \"\"\"\n    Assign jobs to servers randomly and compute max load.\n\n    Args:\n        jobs: List of job IDs.\n        num_servers: Number of servers available.\n\n    Returns:\n        tuple: (server_loads dict, max_load)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_load_balance(jobs, num_servers):\n    \"\"\"\n    Assign jobs to servers randomly and compute max load.\n\n    Args:\n        jobs: List of job IDs.\n        num_servers: Number of servers available.\n\n    Returns:\n        tuple: (server_loads dict, max_load)\n    \"\"\"\n    server_loads = {i: [] for i in range(num_servers)}\n\n    for job in jobs:\n        # Randomly assign to a server\n        server = random.randint(0, num_servers - 1)\n        server_loads[server].append(job)\n\n    max_load = max(len(server_loads[i]) for i in range(num_servers))\n\n    return server_loads, max_load",
    "testCases": [
      {
        "input": "jobs = list(range(100)), num_servers = 10",
        "isHidden": false,
        "description": "100 jobs, 10 servers - expected max load ~ 10-15"
      },
      {
        "input": "jobs = list(range(50)), num_servers = 5",
        "isHidden": false,
        "description": "50 jobs, 5 servers"
      },
      {
        "input": "jobs = list(range(20)), num_servers = 4",
        "isHidden": false,
        "description": "20 jobs, 4 servers"
      }
    ],
    "hints": [
      "Assign each job to a uniformly random server",
      "Expected max load is O(n/m + log m) with high probability",
      "Simple strategy but effective in practice",
      "Can be improved with power-of-two-choices strategy"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Hash Table",
    "difficulty": 3,
    "description": "Implement a hash table with universal hashing to minimize collisions.",
    "starterCode": "import random\n\nclass RandomizedHashTable:\n    def __init__(self, size):\n        \"\"\"\n        Initialize hash table with universal hashing.\n\n        Args:\n            size: Size of hash table.\n        \"\"\"\n        # Your code here\n        pass\n\n    def _hash(self, key):\n        \"\"\"Universal hash function.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, key, value):\n        \"\"\"Insert key-value pair.\"\"\"\n        # Your code here\n        pass\n\n    def get(self, key):\n        \"\"\"Get value for key.\"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass RandomizedHashTable:\n    def __init__(self, size):\n        \"\"\"\n        Initialize hash table with universal hashing.\n\n        Args:\n            size: Size of hash table.\n        \"\"\"\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        # Random parameters for universal hashing\n        self.a = random.randint(1, size - 1)\n        self.b = random.randint(0, size - 1)\n        self.prime = 1000000007  # Large prime\n\n    def _hash(self, key):\n        \"\"\"Universal hash function: ((a*key + b) mod prime) mod size.\"\"\"\n        return ((self.a * hash(key) + self.b) % self.prime) % self.size\n\n    def insert(self, key, value):\n        \"\"\"Insert key-value pair.\"\"\"\n        index = self._hash(key)\n        # Check if key already exists\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index][i] = (key, value)\n                return\n        # Add new key-value pair\n        self.table[index].append((key, value))\n\n    def get(self, key):\n        \"\"\"Get value for key.\"\"\"\n        index = self._hash(key)\n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        return None",
    "testCases": [
      {
        "input": "ht = RandomizedHashTable(10); ht.insert(\"a\", 1); ht.insert(\"b\", 2); ht.get(\"a\")",
        "isHidden": false,
        "description": "Basic insert and get"
      },
      {
        "input": "ht = RandomizedHashTable(5); [ht.insert(i, i*2) for i in range(10)]; ht.get(5)",
        "isHidden": false,
        "description": "Multiple insertions with collisions"
      },
      {
        "input": "ht = RandomizedHashTable(10); ht.insert(\"x\", 10); ht.get(\"y\")",
        "isHidden": false,
        "description": "Get non-existing key"
      }
    ],
    "hints": [
      "Universal hashing: h(k) = ((ak + b) mod p) mod m",
      "Choose random a, b for each hash table instance",
      "Use chaining to handle collisions",
      "Expected chain length is O(1 + α) where α = n/m",
      "Randomization ensures good expected performance"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Median of Medians",
    "difficulty": 3,
    "description": "Implement a randomized version of the median of medians algorithm for deterministic pivot selection.",
    "starterCode": "import random\n\ndef randomized_select_good_pivot(arr):\n    \"\"\"\n    Select a good pivot using randomized sampling.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        A pivot element that splits the array reasonably.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_select_good_pivot(arr):\n    \"\"\"\n    Select a good pivot using randomized sampling.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        A pivot element that splits the array reasonably.\n    \"\"\"\n    if len(arr) <= 5:\n        return sorted(arr)[len(arr) // 2]\n\n    # Sample sqrt(n) elements randomly\n    sample_size = int(len(arr) ** 0.5)\n    sample = random.sample(arr, min(sample_size, len(arr)))\n\n    # Return median of sample\n    sample.sort()\n    return sample[len(sample) // 2]",
    "testCases": [
      {
        "input": "arr = list(range(100))",
        "isHidden": false,
        "description": "Select pivot from sorted array"
      },
      {
        "input": "arr = [random.randint(1, 1000) for _ in range(100)]",
        "isHidden": false,
        "description": "Random array of 100 elements"
      },
      {
        "input": "arr = [5, 5, 5, 5, 5]",
        "isHidden": false,
        "description": "All elements equal"
      }
    ],
    "hints": [
      "Sample sqrt(n) random elements from array",
      "Find median of the sample",
      "This gives a good pivot with high probability",
      "Simpler than deterministic median-of-medians",
      "Expected time is still O(n)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Graph Coloring",
    "difficulty": 4,
    "description": "Implement a randomized algorithm for graph coloring that uses O(Δ+1) colors where Δ is max degree.",
    "starterCode": "import random\n\ndef randomized_graph_coloring(graph):\n    \"\"\"\n    Color graph vertices using randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n\n    Returns:\n        dict: Mapping from vertices to colors (integers).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_graph_coloring(graph):\n    \"\"\"\n    Color graph vertices using randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n\n    Returns:\n        dict: Mapping from vertices to colors (integers).\n    \"\"\"\n    vertices = list(graph.keys())\n    # Randomize order of coloring\n    random.shuffle(vertices)\n\n    colors = {}\n    max_degree = max(len(neighbors) for neighbors in graph.values()) if graph else 0\n\n    for vertex in vertices:\n        # Find colors used by neighbors\n        neighbor_colors = {colors[neighbor] for neighbor in graph[vertex] if neighbor in colors}\n\n        # Assign first available color\n        color = 0\n        while color in neighbor_colors:\n            color += 1\n\n        colors[vertex] = color\n\n    return colors",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle - needs 3 colors"
      },
      {
        "input": "graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}",
        "isHidden": false,
        "description": "Square - needs 2 colors"
      },
      {
        "input": "graph = {0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": false,
        "description": "Star graph - needs 2 colors"
      }
    ],
    "hints": [
      "Process vertices in random order",
      "For each vertex, assign smallest color not used by neighbors",
      "Randomization can lead to better coloring in practice",
      "Guaranteed to use at most Δ+1 colors",
      "Can be repeated multiple times to find better coloring"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Approximate Median",
    "difficulty": 2,
    "description": "Find an approximate median by sampling, returning an element that is close to the true median.",
    "starterCode": "import random\n\ndef approximate_median(arr, sample_size_factor=0.1):\n    \"\"\"\n    Find approximate median using random sampling.\n\n    Args:\n        arr: List of comparable elements.\n        sample_size_factor: Fraction of array to sample.\n\n    Returns:\n        An element that is approximately the median.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef approximate_median(arr, sample_size_factor=0.1):\n    \"\"\"\n    Find approximate median using random sampling.\n\n    Args:\n        arr: List of comparable elements.\n        sample_size_factor: Fraction of array to sample.\n\n    Returns:\n        An element that is approximately the median.\n    \"\"\"\n    # Sample random elements\n    sample_size = max(1, int(len(arr) * sample_size_factor))\n    sample = random.sample(arr, sample_size)\n\n    # Return median of sample\n    sample.sort()\n    return sample[len(sample) // 2]",
    "testCases": [
      {
        "input": "arr = list(range(1000)), sample_size_factor = 0.1",
        "isHidden": false,
        "description": "Large sorted array"
      },
      {
        "input": "arr = [random.randint(1, 100) for _ in range(500)], sample_size_factor = 0.2",
        "isHidden": false,
        "description": "Random array with larger sample"
      },
      {
        "input": "arr = [5] * 100, sample_size_factor = 0.1",
        "isHidden": false,
        "description": "All elements equal"
      }
    ],
    "hints": [
      "Sample a small fraction of the array",
      "Sort the sample and return its median",
      "Result is approximately the true median with high probability",
      "Much faster than finding exact median for large arrays",
      "Trade accuracy for speed"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Coupon Collector",
    "difficulty": 3,
    "description": "Simulate the coupon collector problem: how many random samples needed to collect all n distinct items?",
    "starterCode": "import random\n\ndef coupon_collector(n, num_simulations=1000):\n    \"\"\"\n    Simulate coupon collector problem.\n\n    Args:\n        n: Number of distinct coupons.\n        num_simulations: Number of times to run simulation.\n\n    Returns:\n        float: Average number of samples needed to collect all coupons.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef coupon_collector(n, num_simulations=1000):\n    \"\"\"\n    Simulate coupon collector problem.\n\n    Args:\n        n: Number of distinct coupons.\n        num_simulations: Number of times to run simulation.\n\n    Returns:\n        float: Average number of samples needed to collect all coupons.\n    \"\"\"\n    total_samples = 0\n\n    for _ in range(num_simulations):\n        collected = set()\n        samples = 0\n\n        while len(collected) < n:\n            # Draw random coupon\n            coupon = random.randint(0, n - 1)\n            collected.add(coupon)\n            samples += 1\n\n        total_samples += samples\n\n    return total_samples / num_simulations",
    "testCases": [
      {
        "input": "n = 10, num_simulations = 1000",
        "isHidden": false,
        "description": "10 coupons - expected ~29 samples"
      },
      {
        "input": "n = 5, num_simulations = 500",
        "isHidden": false,
        "description": "5 coupons - expected ~12 samples"
      },
      {
        "input": "n = 20, num_simulations = 1000",
        "isHidden": false,
        "description": "20 coupons - expected ~72 samples"
      }
    ],
    "hints": [
      "Keep drawing random coupons until all n are collected",
      "Track collected coupons using a set",
      "Expected number of draws is n * H(n) where H(n) is harmonic number",
      "H(n) ≈ ln(n) + γ ≈ ln(n) + 0.577",
      "Run multiple simulations and average the results"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "LRU Paging Algorithm",
    "difficulty": 3,
    "description": "Implement the Least Recently Used (LRU) paging algorithm, which is k-competitive for online paging.",
    "starterCode": "def lru_paging(page_requests, cache_size):\n    \"\"\"\n    Simulate LRU paging algorithm.\n\n    Args:\n        page_requests: List of page requests.\n        cache_size: Size of the cache (number of pages that can be held).\n\n    Returns:\n        int: Number of page faults.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def lru_paging(page_requests, cache_size):\n    \"\"\"\n    Simulate LRU paging algorithm.\n\n    Args:\n        page_requests: List of page requests.\n        cache_size: Size of the cache (number of pages that can be held).\n\n    Returns:\n        int: Number of page faults.\n    \"\"\"\n    cache = []\n    page_faults = 0\n\n    for page in page_requests:\n        if page in cache:\n            # Page hit - move to end (most recently used)\n            cache.remove(page)\n            cache.append(page)\n        else:\n            # Page fault\n            page_faults += 1\n\n            if len(cache) >= cache_size:\n                # Cache is full - remove least recently used (first element)\n                cache.pop(0)\n\n            # Add new page (most recently used)\n            cache.append(page)\n\n    return page_faults",
    "testCases": [
      {
        "input": "page_requests = [1, 2, 3, 1, 4, 5], cache_size = 3",
        "isHidden": false,
        "description": "Basic LRU test"
      },
      {
        "input": "page_requests = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5], cache_size = 4",
        "isHidden": false,
        "description": "Longer sequence with repeated accesses"
      },
      {
        "input": "page_requests = [1, 1, 1, 1], cache_size = 1",
        "isHidden": false,
        "description": "All requests to same page"
      }
    ],
    "hints": [
      "Maintain a cache of recently used pages",
      "On a page hit, move the page to the end (most recently used position)",
      "On a page fault, if cache is full, remove the first element (least recently used)",
      "Add the new page at the end"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Ski Rental Problem",
    "difficulty": 2,
    "description": "Solve the ski rental problem: rent skis for $1/day or buy for $B. Determine the competitive ratio of the strategy \"rent for B days, then buy\".",
    "starterCode": "def ski_rental_cost(num_days, buy_price, strategy='break_even'):\n    \"\"\"\n    Calculate cost for ski rental problem.\n\n    Args:\n        num_days: Number of days you will ski.\n        buy_price: Price to buy skis.\n        strategy: 'break_even' (rent for buy_price days then buy) or 'always_rent'\n\n    Returns:\n        int: Total cost.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def ski_rental_cost(num_days, buy_price, strategy='break_even'):\n    \"\"\"\n    Calculate cost for ski rental problem.\n\n    Args:\n        num_days: Number of days you will ski.\n        buy_price: Price to buy skis.\n        strategy: 'break_even' (rent for buy_price days then buy) or 'always_rent'\n\n    Returns:\n        int: Total cost.\n    \"\"\"\n    if strategy == 'always_rent':\n        return num_days\n\n    elif strategy == 'break_even':\n        # Rent for buy_price days, then buy if needed\n        if num_days <= buy_price:\n            return num_days\n        else:\n            # Rented for buy_price days, then bought\n            return buy_price + buy_price\n\n    elif strategy == 'always_buy':\n        return buy_price\n\n    return 0",
    "testCases": [
      {
        "input": "num_days = 5, buy_price = 10, strategy = \"break_even\"",
        "isHidden": false,
        "description": "Ski for fewer days than buy price - should rent"
      },
      {
        "input": "num_days = 15, buy_price = 10, strategy = \"break_even\"",
        "isHidden": false,
        "description": "Ski for more days than buy price - rented 10 days then bought"
      },
      {
        "input": "num_days = 100, buy_price = 20, strategy = \"always_rent\"",
        "isHidden": false,
        "description": "Always rent strategy - expensive for many days"
      }
    ],
    "hints": [
      "The break-even strategy: rent for B days, then buy on day B+1 if needed",
      "If you ski for ≤ B days, total cost is the number of days",
      "If you ski for > B days, total cost is B (rental) + B (purchase) = 2B",
      "This strategy is 2-competitive (at most twice the optimal cost)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "FIFO Paging Algorithm",
    "difficulty": 2,
    "description": "Implement First-In-First-Out (FIFO) paging algorithm and count page faults.",
    "starterCode": "def fifo_paging(page_requests, cache_size):\n    \"\"\"\n    Simulate FIFO paging algorithm.\n\n    Args:\n        page_requests: List of page requests.\n        cache_size: Size of the cache.\n\n    Returns:\n        int: Number of page faults.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def fifo_paging(page_requests, cache_size):\n    \"\"\"\n    Simulate FIFO paging algorithm.\n\n    Args:\n        page_requests: List of page requests.\n        cache_size: Size of the cache.\n\n    Returns:\n        int: Number of page faults.\n    \"\"\"\n    cache = []\n    page_faults = 0\n\n    for page in page_requests:\n        if page not in cache:\n            # Page fault\n            page_faults += 1\n\n            if len(cache) >= cache_size:\n                # Remove first page (FIFO)\n                cache.pop(0)\n\n            cache.append(page)\n\n    return page_faults",
    "testCases": [
      {
        "input": "page_requests = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3], cache_size = 3",
        "isHidden": false,
        "description": "Standard FIFO test case"
      },
      {
        "input": "page_requests = [1, 2, 3, 1, 4, 5], cache_size = 3",
        "isHidden": false,
        "description": "Test with repeated access"
      },
      {
        "input": "page_requests = [7, 0, 1, 2, 0, 3, 0, 4], cache_size = 2",
        "isHidden": false,
        "description": "Small cache size"
      }
    ],
    "hints": [
      "Maintain a queue of pages in cache",
      "On page hit, do nothing (FIFO does not update order)",
      "On page fault, remove first page if cache is full",
      "FIFO can suffer from Belady's anomaly",
      "Simple but not optimal in competitive ratio"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Competitive Analysis",
    "difficulty": 3,
    "description": "Implement a function to compute competitive ratio for an online algorithm given cost sequences.",
    "starterCode": "def compute_competitive_ratio(online_costs, offline_costs):\n    \"\"\"\n    Compute competitive ratio of an online algorithm.\n\n    Args:\n        online_costs: List of costs incurred by online algorithm on different inputs.\n        offline_costs: List of costs incurred by optimal offline algorithm.\n\n    Returns:\n        float: Competitive ratio (max ratio over all inputs).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def compute_competitive_ratio(online_costs, offline_costs):\n    \"\"\"\n    Compute competitive ratio of an online algorithm.\n\n    Args:\n        online_costs: List of costs incurred by online algorithm on different inputs.\n        offline_costs: List of costs incurred by optimal offline algorithm.\n\n    Returns:\n        float: Competitive ratio (max ratio over all inputs).\n    \"\"\"\n    if len(online_costs) != len(offline_costs):\n        raise ValueError(\"Cost lists must have same length\")\n\n    max_ratio = 0\n\n    for online, offline in zip(online_costs, offline_costs):\n        if offline == 0:\n            # Avoid division by zero\n            if online > 0:\n                return float('inf')\n            continue\n\n        ratio = online / offline\n        max_ratio = max(max_ratio, ratio)\n\n    return max_ratio",
    "testCases": [
      {
        "input": "online_costs = [10, 20, 30], offline_costs = [5, 10, 10]",
        "isHidden": false,
        "description": "Algorithm with 3-competitive ratio"
      },
      {
        "input": "online_costs = [100, 200], offline_costs = [50, 100]",
        "isHidden": false,
        "description": "Consistent 2-competitive ratio"
      },
      {
        "input": "online_costs = [5, 10, 15], offline_costs = [5, 5, 5]",
        "isHidden": false,
        "description": "Variable competitive ratios"
      }
    ],
    "hints": [
      "Competitive ratio = max(ALG(I) / OPT(I)) over all inputs I",
      "ALG is online algorithm cost, OPT is optimal offline cost",
      "Compute ratio for each input and take maximum",
      "Handle edge case where offline cost is 0",
      "Lower competitive ratio is better"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "First-Fit Bin Packing",
    "difficulty": 3,
    "description": "Implement First-Fit algorithm for online bin packing problem.",
    "starterCode": "def first_fit_bin_packing(items, bin_capacity):\n    \"\"\"\n    Pack items using First-Fit algorithm.\n\n    Args:\n        items: List of item sizes (0 < size <= bin_capacity).\n        bin_capacity: Capacity of each bin.\n\n    Returns:\n        list: List of bins, where each bin is a list of item sizes.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def first_fit_bin_packing(items, bin_capacity):\n    \"\"\"\n    Pack items using First-Fit algorithm.\n\n    Args:\n        items: List of item sizes (0 < size <= bin_capacity).\n        bin_capacity: Capacity of each bin.\n\n    Returns:\n        list: List of bins, where each bin is a list of item sizes.\n    \"\"\"\n    bins = []\n    bin_remaining = []\n\n    for item in items:\n        # Find first bin that fits\n        placed = False\n        for i in range(len(bins)):\n            if bin_remaining[i] >= item:\n                bins[i].append(item)\n                bin_remaining[i] -= item\n                placed = True\n                break\n\n        if not placed:\n            # Create new bin\n            bins.append([item])\n            bin_remaining.append(bin_capacity - item)\n\n    return bins",
    "testCases": [
      {
        "input": "items = [0.3, 0.5, 0.2, 0.7, 0.4], bin_capacity = 1.0",
        "isHidden": false,
        "description": "Basic bin packing with fractional sizes"
      },
      {
        "input": "items = [5, 3, 4, 2, 6, 1], bin_capacity = 10",
        "isHidden": false,
        "description": "Integer bin packing"
      },
      {
        "input": "items = [0.6, 0.6, 0.6, 0.6], bin_capacity = 1.0",
        "isHidden": false,
        "description": "Items requiring individual bins"
      }
    ],
    "hints": [
      "Maintain list of bins and their remaining capacity",
      "For each item, scan bins in order until finding one that fits",
      "If no bin fits, create a new bin",
      "First-Fit is 2-competitive for online bin packing",
      "Can be improved to 1.7-competitive with First-Fit-Decreasing (offline)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Best-Fit Bin Packing",
    "difficulty": 3,
    "description": "Implement Best-Fit algorithm for online bin packing (place in bin with least remaining space).",
    "starterCode": "def best_fit_bin_packing(items, bin_capacity):\n    \"\"\"\n    Pack items using Best-Fit algorithm.\n\n    Args:\n        items: List of item sizes.\n        bin_capacity: Capacity of each bin.\n\n    Returns:\n        list: List of bins, where each bin is a list of item sizes.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def best_fit_bin_packing(items, bin_capacity):\n    \"\"\"\n    Pack items using Best-Fit algorithm.\n\n    Args:\n        items: List of item sizes.\n        bin_capacity: Capacity of each bin.\n\n    Returns:\n        list: List of bins, where each bin is a list of item sizes.\n    \"\"\"\n    bins = []\n    bin_remaining = []\n\n    for item in items:\n        # Find bin with minimum remaining space that fits\n        best_bin = -1\n        min_remaining = bin_capacity + 1\n\n        for i in range(len(bins)):\n            if bin_remaining[i] >= item and bin_remaining[i] < min_remaining:\n                best_bin = i\n                min_remaining = bin_remaining[i]\n\n        if best_bin != -1:\n            # Place in best bin\n            bins[best_bin].append(item)\n            bin_remaining[best_bin] -= item\n        else:\n            # Create new bin\n            bins.append([item])\n            bin_remaining.append(bin_capacity - item)\n\n    return bins",
    "testCases": [
      {
        "input": "items = [0.3, 0.5, 0.2, 0.7, 0.4], bin_capacity = 1.0",
        "isHidden": false,
        "description": "Best-Fit should pack more efficiently than First-Fit"
      },
      {
        "input": "items = [4, 8, 1, 4, 2, 1], bin_capacity = 10",
        "isHidden": false,
        "description": "Integer sizes with Best-Fit"
      },
      {
        "input": "items = [0.25, 0.5, 0.25, 0.75, 0.25], bin_capacity = 1.0",
        "isHidden": false,
        "description": "Items that can be packed together"
      }
    ],
    "hints": [
      "For each item, find bin with minimum remaining space that still fits",
      "Best-Fit tries to minimize wasted space",
      "Scan all bins to find best fit (not just first fit)",
      "Also 2-competitive but often better in practice",
      "Can use priority queue for better performance"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Online Load Balancing",
    "difficulty": 3,
    "description": "Implement greedy load balancing algorithm that assigns each job to the machine with minimum current load.",
    "starterCode": "def greedy_load_balancing(jobs, num_machines):\n    \"\"\"\n    Assign jobs to machines using greedy load balancing.\n\n    Args:\n        jobs: List of job processing times.\n        num_machines: Number of machines available.\n\n    Returns:\n        tuple: (machine_loads dict, makespan)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def greedy_load_balancing(jobs, num_machines):\n    \"\"\"\n    Assign jobs to machines using greedy load balancing.\n\n    Args:\n        jobs: List of job processing times.\n        num_machines: Number of machines available.\n\n    Returns:\n        tuple: (machine_loads dict, makespan)\n    \"\"\"\n    machine_loads = {i: [] for i in range(num_machines)}\n    machine_times = [0] * num_machines\n\n    for job in jobs:\n        # Find machine with minimum load\n        min_machine = min(range(num_machines), key=lambda i: machine_times[i])\n\n        # Assign job to that machine\n        machine_loads[min_machine].append(job)\n        machine_times[min_machine] += job\n\n    makespan = max(machine_times)\n\n    return machine_loads, makespan",
    "testCases": [
      {
        "input": "jobs = [2, 3, 4, 6, 2, 2], num_machines = 3",
        "isHidden": false,
        "description": "Basic load balancing"
      },
      {
        "input": "jobs = [10, 1, 1, 1, 1, 1], num_machines = 2",
        "isHidden": false,
        "description": "Large job followed by small jobs"
      },
      {
        "input": "jobs = [5, 5, 5, 5, 5, 5], num_machines = 3",
        "isHidden": false,
        "description": "Equal sized jobs"
      }
    ],
    "hints": [
      "Assign each job to machine with current minimum load",
      "This is a greedy online algorithm",
      "Competitive ratio is 2 - 1/m where m is number of machines",
      "Track total load on each machine",
      "Makespan is the maximum load across all machines"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Secretary Problem",
    "difficulty": 4,
    "description": "Implement the optimal algorithm for the secretary problem (select best candidate from online sequence).",
    "starterCode": "import random\n\ndef secretary_problem(candidates, strategy='optimal'):\n    \"\"\"\n    Solve secretary problem using 1/e strategy.\n\n    Args:\n        candidates: List of candidate values (higher is better).\n        strategy: 'optimal' uses 1/e rule, 'random' picks randomly.\n\n    Returns:\n        tuple: (selected_value, selected_index)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef secretary_problem(candidates, strategy='optimal'):\n    \"\"\"\n    Solve secretary problem using 1/e strategy.\n\n    Args:\n        candidates: List of candidate values (higher is better).\n        strategy: 'optimal' uses 1/e rule, 'random' picks randomly.\n\n    Returns:\n        tuple: (selected_value, selected_index)\n    \"\"\"\n    n = len(candidates)\n\n    if strategy == 'random':\n        idx = random.randint(0, n - 1)\n        return candidates[idx], idx\n\n    elif strategy == 'optimal':\n        # Skip first n/e candidates, then select first one better than all skipped\n        skip = int(n / 2.718)  # approximately n/e\n\n        # Find max in first skip candidates\n        max_in_skip = max(candidates[:skip]) if skip > 0 else float('-inf')\n\n        # Find first candidate after skip better than max_in_skip\n        for i in range(skip, n):\n            if candidates[i] > max_in_skip:\n                return candidates[i], i\n\n        # If no such candidate found, return last one\n        return candidates[-1], n - 1\n\n    return None, -1",
    "testCases": [
      {
        "input": "candidates = [3, 7, 2, 9, 4, 1, 8, 5], strategy = \"optimal\"",
        "isHidden": false,
        "description": "Secretary problem with 8 candidates"
      },
      {
        "input": "candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], strategy = \"optimal\"",
        "isHidden": false,
        "description": "Best candidate at the end"
      },
      {
        "input": "candidates = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], strategy = \"optimal\"",
        "isHidden": false,
        "description": "Best candidate at the beginning"
      }
    ],
    "hints": [
      "Skip first n/e candidates (approximately 37%)",
      "During skip phase, observe but do not select",
      "After skip phase, select first candidate better than all skipped",
      "This strategy succeeds with probability 1/e ≈ 37%",
      "Optimal for online selection without recall"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Online Bipartite Matching",
    "difficulty": 4,
    "description": "Implement greedy algorithm for online bipartite matching with competitive ratio 1/2.",
    "starterCode": "def online_bipartite_matching(online_vertices, offline_edges):\n    \"\"\"\n    Online bipartite matching using greedy algorithm.\n\n    Args:\n        online_vertices: List of online vertices (arrive one at a time).\n        offline_edges: Dict mapping each online vertex to list of offline neighbors.\n\n    Returns:\n        dict: Matching (maps online vertex to matched offline vertex or None).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def online_bipartite_matching(online_vertices, offline_edges):\n    \"\"\"\n    Online bipartite matching using greedy algorithm.\n\n    Args:\n        online_vertices: List of online vertices (arrive one at a time).\n        offline_edges: Dict mapping each online vertex to list of offline neighbors.\n\n    Returns:\n        dict: Matching (maps online vertex to matched offline vertex or None).\n    \"\"\"\n    matching = {}\n    matched_offline = set()\n\n    for online_v in online_vertices:\n        # Try to match with any unmatched offline neighbor\n        matched = False\n\n        for offline_v in offline_edges.get(online_v, []):\n            if offline_v not in matched_offline:\n                # Match greedily\n                matching[online_v] = offline_v\n                matched_offline.add(offline_v)\n                matched = True\n                break\n\n        if not matched:\n            matching[online_v] = None\n\n    return matching",
    "testCases": [
      {
        "input": "online_vertices = [1, 2, 3], offline_edges = {1: [\"a\", \"b\"], 2: [\"a\", \"c\"], 3: [\"b\", \"c\"]}",
        "isHidden": false,
        "description": "Small bipartite graph"
      },
      {
        "input": "online_vertices = [1, 2, 3, 4], offline_edges = {1: [\"a\"], 2: [\"a\", \"b\"], 3: [\"b\"], 4: [\"c\"]}",
        "isHidden": false,
        "description": "Graph with some vertices having limited choices"
      },
      {
        "input": "online_vertices = [1, 2], offline_edges = {1: [\"a\", \"b\", \"c\"], 2: [\"a\", \"b\", \"c\"]}",
        "isHidden": false,
        "description": "Multiple matching options"
      }
    ],
    "hints": [
      "Online vertices arrive one at a time",
      "Match each online vertex to any available offline neighbor",
      "Greedy matching cannot be undone",
      "Competitive ratio is 1/2 (at least half of optimal)",
      "Can be improved with randomized algorithms"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "k-Server Problem",
    "difficulty": 5,
    "description": "Implement greedy algorithm for k-server problem (move nearest server to request).",
    "starterCode": "def k_server_greedy(requests, server_positions, num_positions):\n    \"\"\"\n    Simulate k-server problem using greedy (nearest server) algorithm.\n\n    Args:\n        requests: List of position requests.\n        server_positions: Initial positions of k servers (list).\n        num_positions: Number of positions in the metric space (0 to num_positions-1).\n\n    Returns:\n        tuple: (total_cost, final_server_positions)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def k_server_greedy(requests, server_positions, num_positions):\n    \"\"\"\n    Simulate k-server problem using greedy (nearest server) algorithm.\n\n    Args:\n        requests: List of position requests.\n        server_positions: Initial positions of k servers (list).\n        num_positions: Number of positions in the metric space (0 to num_positions-1).\n\n    Returns:\n        tuple: (total_cost, final_server_positions)\n    \"\"\"\n    servers = server_positions[:]  # Copy\n    total_cost = 0\n\n    for request in requests:\n        # Check if any server is already at request position\n        if request in servers:\n            continue\n\n        # Find nearest server to request\n        min_dist = float('inf')\n        min_server_idx = -1\n\n        for i, server_pos in enumerate(servers):\n            dist = abs(request - server_pos)\n            if dist < min_dist:\n                min_dist = dist\n                min_server_idx = i\n\n        # Move nearest server to request\n        total_cost += min_dist\n        servers[min_server_idx] = request\n\n    return total_cost, servers",
    "testCases": [
      {
        "input": "requests = [3, 7, 2, 9], server_positions = [0, 10], num_positions = 11",
        "isHidden": false,
        "description": "2 servers on line segment"
      },
      {
        "input": "requests = [5, 5, 5], server_positions = [0, 10, 20], num_positions = 21",
        "isHidden": false,
        "description": "Repeated requests"
      },
      {
        "input": "requests = [1, 2, 3, 4, 5], server_positions = [0], num_positions = 10",
        "isHidden": false,
        "description": "Single server"
      }
    ],
    "hints": [
      "k servers can serve requests at different positions",
      "When request arrives, move nearest server to that position",
      "Cost is distance moved",
      "Greedy algorithm is k-competitive",
      "Optimal online algorithm for k-server is also k-competitive"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Online Knapsack",
    "difficulty": 4,
    "description": "Implement threshold algorithm for online knapsack problem.",
    "starterCode": "def online_knapsack(items, capacity, threshold_ratio=0.5):\n    \"\"\"\n    Online knapsack using threshold algorithm.\n\n    Args:\n        items: List of (value, weight) tuples arriving online.\n        capacity: Knapsack capacity.\n        threshold_ratio: Accept items with value/weight >= threshold_ratio * max_density.\n\n    Returns:\n        tuple: (selected_items, total_value, total_weight)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def online_knapsack(items, capacity, threshold_ratio=0.5):\n    \"\"\"\n    Online knapsack using threshold algorithm.\n\n    Args:\n        items: List of (value, weight) tuples arriving online.\n        capacity: Knapsack capacity.\n        threshold_ratio: Accept items with value/weight >= threshold_ratio * max_density.\n\n    Returns:\n        tuple: (selected_items, total_value, total_weight)\n    \"\"\"\n    # Estimate max density (in practice, would need to guess)\n    max_density = max(v / w for v, w in items) if items else 1\n    threshold = threshold_ratio * max_density\n\n    selected = []\n    total_value = 0\n    total_weight = 0\n\n    for value, weight in items:\n        density = value / weight\n\n        # Accept if density >= threshold and fits\n        if density >= threshold and total_weight + weight <= capacity:\n            selected.append((value, weight))\n            total_value += value\n            total_weight += weight\n\n    return selected, total_value, total_weight",
    "testCases": [
      {
        "input": "items = [(60, 10), (100, 20), (120, 30)], capacity = 50, threshold_ratio = 0.5",
        "isHidden": false,
        "description": "Basic online knapsack"
      },
      {
        "input": "items = [(10, 5), (40, 4), (30, 6), (50, 3)], capacity = 10, threshold_ratio = 0.6",
        "isHidden": false,
        "description": "High threshold filters more items"
      },
      {
        "input": "items = [(25, 5), (25, 5), (25, 5), (25, 5)], capacity = 10, threshold_ratio = 0.5",
        "isHidden": false,
        "description": "Equal density items"
      }
    ],
    "hints": [
      "Cannot see future items in online setting",
      "Use threshold based on value-to-weight ratio",
      "Accept items with density above threshold if they fit",
      "Threshold needs to be set without knowing future items",
      "Competitive ratio depends on threshold choice"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Move-To-Front List",
    "difficulty": 2,
    "description": "Implement Move-To-Front (MTF) heuristic for list accessing, which is 2-competitive.",
    "starterCode": "def move_to_front(access_sequence, initial_list):\n    \"\"\"\n    Simulate Move-To-Front list accessing.\n\n    Args:\n        access_sequence: List of elements to access.\n        initial_list: Initial ordering of list elements.\n\n    Returns:\n        tuple: (total_cost, final_list)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def move_to_front(access_sequence, initial_list):\n    \"\"\"\n    Simulate Move-To-Front list accessing.\n\n    Args:\n        access_sequence: List of elements to access.\n        initial_list: Initial ordering of list elements.\n\n    Returns:\n        tuple: (total_cost, final_list)\n    \"\"\"\n    lst = initial_list[:]\n    total_cost = 0\n\n    for item in access_sequence:\n        # Find item in list (cost is position + 1)\n        position = lst.index(item)\n        total_cost += position + 1\n\n        # Move to front\n        lst.pop(position)\n        lst.insert(0, item)\n\n    return total_cost, lst",
    "testCases": [
      {
        "input": "access_sequence = [\"a\", \"b\", \"c\", \"a\", \"b\", \"a\"], initial_list = [\"a\", \"b\", \"c\", \"d\"]",
        "isHidden": false,
        "description": "Repeated accesses benefit from MTF"
      },
      {
        "input": "access_sequence = [\"d\", \"c\", \"b\", \"a\"], initial_list = [\"a\", \"b\", \"c\", \"d\"]",
        "isHidden": false,
        "description": "Reverse order access"
      },
      {
        "input": "access_sequence = [\"a\", \"a\", \"a\"], initial_list = [\"a\", \"b\", \"c\"]",
        "isHidden": false,
        "description": "Single element repeatedly"
      }
    ],
    "hints": [
      "Cost to access element at position i is i",
      "After accessing, move element to front of list",
      "MTF is 2-competitive against any offline algorithm",
      "Works well for locality of reference",
      "No knowledge of future accesses needed"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Online Coloring",
    "difficulty": 3,
    "description": "Implement First-Fit online graph coloring algorithm.",
    "starterCode": "def online_coloring(vertices, edges):\n    \"\"\"\n    Color graph vertices online using First-Fit coloring.\n\n    Args:\n        vertices: List of vertices arriving in order.\n        edges: List of (u, v) edges (only edges between already-arrived vertices are known).\n\n    Returns:\n        dict: Mapping from vertices to colors.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def online_coloring(vertices, edges):\n    \"\"\"\n    Color graph vertices online using First-Fit coloring.\n\n    Args:\n        vertices: List of vertices arriving in order.\n        edges: List of (u, v) edges (only edges between already-arrived vertices are known).\n\n    Returns:\n        dict: Mapping from vertices to colors.\n    \"\"\"\n    colors = {}\n    edge_set = set((min(u, v), max(u, v)) for u, v in edges)\n\n    for vertex in vertices:\n        # Find colors of already-colored neighbors\n        neighbor_colors = set()\n\n        for colored_vertex in colors:\n            edge = (min(vertex, colored_vertex), max(vertex, colored_vertex))\n            if edge in edge_set:\n                neighbor_colors.add(colors[colored_vertex])\n\n        # Assign first available color\n        color = 0\n        while color in neighbor_colors:\n            color += 1\n\n        colors[vertex] = color\n\n    return colors",
    "testCases": [
      {
        "input": "vertices = [1, 2, 3], edges = [(1, 2), (2, 3), (1, 3)]",
        "isHidden": false,
        "description": "Triangle graph - needs 3 colors"
      },
      {
        "input": "vertices = [1, 2, 3, 4], edges = [(1, 2), (2, 3), (3, 4), (4, 1)]",
        "isHidden": false,
        "description": "Square graph - needs 2 colors"
      },
      {
        "input": "vertices = [1, 2, 3, 4, 5], edges = [(1, 2), (1, 3), (1, 4), (1, 5)]",
        "isHidden": false,
        "description": "Star graph - needs 2 colors"
      }
    ],
    "hints": [
      "Vertices arrive one at a time with edges to previous vertices",
      "Assign smallest color not used by neighbors",
      "Cannot change color of previously colored vertices",
      "First-Fit uses at most 2χ(G) - 1 colors where χ(G) is chromatic number",
      "Online coloring is harder than offline"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Weighted Caching",
    "difficulty": 4,
    "description": "Implement greedy algorithm for weighted paging where pages have different costs.",
    "starterCode": "def weighted_caching(requests, costs, cache_size):\n    \"\"\"\n    Weighted paging: evict page with maximum cost when cache is full.\n\n    Args:\n        requests: List of (page, cost) tuples.\n        costs: Dictionary mapping pages to their fetch costs.\n        cache_size: Size of cache.\n\n    Returns:\n        tuple: (total_cost, num_faults)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def weighted_caching(requests, costs, cache_size):\n    \"\"\"\n    Weighted paging: evict page with maximum cost when cache is full.\n\n    Args:\n        requests: List of page requests.\n        costs: Dictionary mapping pages to their fetch costs.\n        cache_size: Size of cache.\n\n    Returns:\n        tuple: (total_cost, num_faults)\n    \"\"\"\n    cache = set()\n    total_cost = 0\n    num_faults = 0\n\n    for page in requests:\n        if page not in cache:\n            # Page fault\n            num_faults += 1\n            total_cost += costs[page]\n\n            if len(cache) >= cache_size:\n                # Evict page in cache with maximum cost\n                max_cost_page = max(cache, key=lambda p: costs[p])\n                cache.remove(max_cost_page)\n\n            cache.add(page)\n\n    return total_cost, num_faults",
    "testCases": [
      {
        "input": "requests = [1, 2, 3, 4, 1, 2], costs = {1: 1, 2: 2, 3: 3, 4: 4}, cache_size = 2",
        "isHidden": false,
        "description": "Pages with different costs"
      },
      {
        "input": "requests = [1, 1, 2, 2, 3, 3], costs = {1: 5, 2: 1, 3: 1}, cache_size = 2",
        "isHidden": false,
        "description": "Expensive page accessed frequently"
      },
      {
        "input": "requests = [1, 2, 3, 1], costs = {1: 1, 2: 2, 3: 3}, cache_size = 2",
        "isHidden": false,
        "description": "Evict expensive pages first"
      }
    ],
    "hints": [
      "When cache is full, evict page with highest cost",
      "Intuition: expensive pages are more worth keeping in cache",
      "This is the greedy algorithm for weighted caching",
      "Cost to fetch page varies by page",
      "Track both total cost and number of faults"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "TCP Acknowledgment",
    "difficulty": 3,
    "description": "Implement online algorithm for TCP acknowledgment problem (decide when to send ACKs).",
    "starterCode": "def tcp_acknowledgment(packets, ack_cost, delay_cost, window_size):\n    \"\"\"\n    Decide when to send acknowledgments for TCP packets.\n\n    Args:\n        packets: List of packet arrival times.\n        ack_cost: Cost to send one acknowledgment.\n        delay_cost: Cost per time unit per unacknowledged packet.\n        window_size: Maximum unacknowledged packets before forced ACK.\n\n    Returns:\n        tuple: (ack_times, total_cost)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def tcp_acknowledgment(packets, ack_cost, delay_cost, window_size):\n    \"\"\"\n    Decide when to send acknowledgments for TCP packets.\n\n    Args:\n        packets: List of packet arrival times.\n        ack_cost: Cost to send one acknowledgment.\n        delay_cost: Cost per time unit per unacknowledged packet.\n        window_size: Maximum unacknowledged packets before forced ACK.\n\n    Returns:\n        tuple: (ack_times, total_cost)\n    \"\"\"\n    ack_times = []\n    total_cost = 0\n    unacked = []\n\n    for i, arrival_time in enumerate(packets):\n        unacked.append(arrival_time)\n\n        # Send ACK if window is full\n        if len(unacked) >= window_size:\n            # Send acknowledgment now\n            ack_times.append(arrival_time)\n            total_cost += ack_cost\n\n            # Add delay cost for all unacked packets\n            for unacked_time in unacked:\n                total_cost += delay_cost * (arrival_time - unacked_time)\n\n            unacked = []\n\n    # Acknowledge remaining packets at end\n    if unacked:\n        final_time = packets[-1]\n        ack_times.append(final_time)\n        total_cost += ack_cost\n\n        for unacked_time in unacked:\n            total_cost += delay_cost * (final_time - unacked_time)\n\n    return ack_times, total_cost",
    "testCases": [
      {
        "input": "packets = [1, 2, 3, 4, 5], ack_cost = 5, delay_cost = 1, window_size = 3",
        "isHidden": false,
        "description": "Trade-off between ACK cost and delay"
      },
      {
        "input": "packets = [1, 3, 5, 7, 9], ack_cost = 10, delay_cost = 2, window_size = 2",
        "isHidden": false,
        "description": "High ACK cost encourages delaying"
      },
      {
        "input": "packets = [1, 2, 3], ack_cost = 1, delay_cost = 5, window_size = 5",
        "isHidden": false,
        "description": "High delay cost encourages frequent ACKs"
      }
    ],
    "hints": [
      "Balance cost of sending ACK vs cost of delaying",
      "Window size limits maximum unacknowledged packets",
      "Delay cost accumulates for each unacknowledged packet",
      "Must decide online when to send each ACK",
      "Simple strategy: send ACK when window is full"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t4-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-4",
    "title": "Metrical Task Systems",
    "difficulty": 5,
    "description": "Implement work function algorithm for metrical task systems.",
    "starterCode": "def metrical_task_system(tasks, states, transition_costs, task_costs):\n    \"\"\"\n    Solve metrical task system using greedy algorithm.\n\n    Args:\n        tasks: List of tasks arriving online.\n        states: List of possible states.\n        transition_costs: Dict mapping (state1, state2) to transition cost.\n        task_costs: Dict mapping (task, state) to cost of serving task in that state.\n\n    Returns:\n        tuple: (state_sequence, total_cost)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def metrical_task_system(tasks, states, transition_costs, task_costs):\n    \"\"\"\n    Solve metrical task system using greedy algorithm.\n\n    Args:\n        tasks: List of tasks arriving online.\n        states: List of possible states.\n        transition_costs: Dict mapping (state1, state2) to transition cost.\n        task_costs: Dict mapping (task, state) to cost of serving task in that state.\n\n    Returns:\n        tuple: (state_sequence, total_cost)\n    \"\"\"\n    # Start at first state\n    current_state = states[0]\n    state_sequence = [current_state]\n    total_cost = 0\n\n    for task in tasks:\n        # Find best state to serve this task\n        best_state = current_state\n        min_cost = task_costs.get((task, current_state), 0)\n\n        for state in states:\n            transition_cost = transition_costs.get((current_state, state), 0)\n            task_cost = task_costs.get((task, state), 0)\n            total = transition_cost + task_cost\n\n            if total < min_cost + transition_costs.get((current_state, best_state), 0):\n                best_state = state\n                min_cost = task_cost\n\n        # Transition to best state\n        total_cost += transition_costs.get((current_state, best_state), 0)\n        total_cost += task_costs.get((task, best_state), 0)\n\n        current_state = best_state\n        state_sequence.append(current_state)\n\n    return state_sequence, total_cost",
    "testCases": [
      {
        "input": "tasks = [1, 2, 1], states = [\"A\", \"B\"], transition_costs = {(\"A\", \"B\"): 2, (\"B\", \"A\"): 2, (\"A\", \"A\"): 0, (\"B\", \"B\"): 0}, task_costs = {(1, \"A\"): 1, (1, \"B\"): 5, (2, \"A\"): 5, (2, \"B\"): 1}",
        "isHidden": false,
        "description": "Simple two-state system"
      },
      {
        "input": "tasks = [1, 1, 1], states = [\"A\", \"B\"], transition_costs = {(\"A\", \"B\"): 10, (\"B\", \"A\"): 10, (\"A\", \"A\"): 0, (\"B\", \"B\"): 0}, task_costs = {(1, \"A\"): 1, (1, \"B\"): 2}",
        "isHidden": false,
        "description": "High transition cost"
      },
      {
        "input": "tasks = [1, 2, 3], states = [\"A\", \"B\", \"C\"], transition_costs = {(\"A\", \"B\"): 1, (\"B\", \"C\"): 1, (\"A\", \"C\"): 3, (\"A\", \"A\"): 0, (\"B\", \"B\"): 0, (\"C\", \"C\"): 0}, task_costs = {(1, \"A\"): 0, (2, \"B\"): 0, (3, \"C\"): 0}",
        "isHidden": false,
        "description": "Three-state system with metric costs"
      }
    ],
    "hints": [
      "MTS generalizes many online problems (paging, k-server, etc.)",
      "System can be in one of n states",
      "Must serve each task, possibly transitioning to new state",
      "Cost = transition cost + task service cost in chosen state",
      "Greedy: choose state that minimizes immediate cost",
      "Optimal online algorithm is 2n-1 competitive"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Matrix Chain Multiplication",
    "difficulty": 3,
    "description": "Find the optimal way to multiply a chain of matrices to minimize scalar multiplications.",
    "starterCode": "def matrix_chain_order(dimensions):\n    \"\"\"\n    Find minimum scalar multiplications for matrix chain.\n\n    Args:\n        dimensions: List where matrix i is dimensions[i-1] x dimensions[i]\n\n    Returns:\n        int: Minimum number of scalar multiplications\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def matrix_chain_order(dimensions):\n    n = len(dimensions) - 1\n    dp = [[0] * n for _ in range(n)]\n\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]\n                dp[i][j] = min(dp[i][j], cost)\n\n    return dp[0][n-1]",
    "testCases": [
      {
        "input": "dimensions = [10, 20, 30, 40, 30]",
        "isHidden": false,
        "description": "Four matrices"
      },
      {
        "input": "dimensions = [10, 20, 30]",
        "isHidden": false,
        "description": "Two matrices"
      }
    ],
    "hints": [
      "dp[i][j] = min cost to multiply matrices i through j",
      "Try all split points k"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Edit Distance",
    "difficulty": 3,
    "description": "Compute minimum edit distance between two strings using DP.",
    "starterCode": "def edit_distance(str1, str2):\n    \"\"\"\n    Compute minimum edit distance.\n\n    Args:\n        str1, str2: Input strings\n\n    Returns:\n        int: Minimum operations to transform str1 to str2\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def edit_distance(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n\n    return dp[m][n]",
    "testCases": [
      {
        "input": "str1 = \"kitten\", str2 = \"sitting\"",
        "isHidden": false,
        "description": "Classic example"
      },
      {
        "input": "str1 = \"horse\", str2 = \"ros\"",
        "isHidden": false,
        "description": "Multiple ops"
      }
    ],
    "hints": [
      "dp[i][j] = edit distance of first i chars and first j chars",
      "Three operations: insert, delete, substitute"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Longest Common Subsequence",
    "difficulty": 2,
    "description": "Find the length of the longest common subsequence of two strings.",
    "starterCode": "def lcs_length(str1, str2):\n    \"\"\"\n    Find length of longest common subsequence.\n\n    Args:\n        str1, str2: Input strings\n\n    Returns:\n        int: Length of LCS\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def lcs_length(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]",
    "testCases": [
      {
        "input": "str1 = \"ABCBDAB\", str2 = \"BDCAB\"",
        "isHidden": false,
        "description": "LCS is BCAB or BDAB"
      },
      {
        "input": "str1 = \"AGGTAB\", str2 = \"GXTXAYB\"",
        "isHidden": false,
        "description": "LCS is GTAB"
      }
    ],
    "hints": [
      "If chars match, extend LCS",
      "Otherwise take max of excluding either char"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Reconstruct LCS",
    "difficulty": 3,
    "description": "Not just find the length, but reconstruct an actual LCS.",
    "starterCode": "def lcs(str1, str2):\n    \"\"\"\n    Find an actual longest common subsequence.\n\n    Args:\n        str1, str2: Input strings\n\n    Returns:\n        str: A longest common subsequence\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def lcs(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    # Backtrack\n    result = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i-1] == str2[j-1]:\n            result.append(str1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return ''.join(reversed(result))",
    "testCases": [
      {
        "input": "str1 = \"ABCDGH\", str2 = \"AEDFHR\"",
        "isHidden": false,
        "description": "LCS is ADH"
      },
      {
        "input": "str1 = \"ABC\", str2 = \"AC\"",
        "isHidden": false,
        "description": "Simple case"
      }
    ],
    "hints": [
      "Build DP table first",
      "Backtrack from dp[m][n] to reconstruct"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "0/1 Knapsack",
    "difficulty": 3,
    "description": "Solve the classic 0/1 knapsack problem using dynamic programming.",
    "starterCode": "def knapsack(weights, values, capacity):\n    \"\"\"\n    Find maximum value achievable within capacity.\n\n    Args:\n        weights: List of item weights\n        values: List of item values\n        capacity: Knapsack capacity\n\n    Returns:\n        int: Maximum value\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def knapsack(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            dp[i][w] = dp[i-1][w]  # Don't take item i\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i][w], dp[i-1][w-weights[i-1]] + values[i-1])\n\n    return dp[n][capacity]",
    "testCases": [
      {
        "input": "weights = [2, 3, 4, 5], values = [3, 4, 5, 6], capacity = 8",
        "isHidden": false,
        "description": "Standard knapsack"
      },
      {
        "input": "weights = [1, 2, 3], values = [10, 15, 40], capacity = 4",
        "isHidden": false,
        "description": "Choose items 2 and 3"
      }
    ],
    "hints": [
      "dp[i][w] = max value using first i items with capacity w",
      "Either take or skip each item"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Knapsack Item Reconstruction",
    "difficulty": 3,
    "description": "Find which items are selected in optimal knapsack solution.",
    "starterCode": "def knapsack_items(weights, values, capacity):\n    \"\"\"\n    Find items selected in optimal knapsack solution.\n\n    Args:\n        weights, values: Item weights and values\n        capacity: Knapsack capacity\n\n    Returns:\n        list: Indices of selected items\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def knapsack_items(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            dp[i][w] = dp[i-1][w]\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i][w], dp[i-1][w-weights[i-1]] + values[i-1])\n\n    # Backtrack\n    selected = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if dp[i][w] != dp[i-1][w]:\n            selected.append(i - 1)\n            w -= weights[i-1]\n\n    return selected[::-1]",
    "testCases": [
      {
        "input": "weights = [2, 3, 4, 5], values = [3, 4, 5, 6], capacity = 8",
        "isHidden": false,
        "description": "Find selected items"
      },
      {
        "input": "weights = [1, 2, 3], values = [6, 10, 12], capacity = 5",
        "isHidden": false,
        "description": "Items 1 and 2"
      }
    ],
    "hints": [
      "Build DP table first",
      "Backtrack to find which items were taken"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Unbounded Knapsack",
    "difficulty": 2,
    "description": "Solve knapsack where items can be used unlimited times.",
    "starterCode": "def unbounded_knapsack(weights, values, capacity):\n    \"\"\"\n    Knapsack with unlimited copies of each item.\n\n    Args:\n        weights, values: Item properties\n        capacity: Knapsack capacity\n\n    Returns:\n        int: Maximum value\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def unbounded_knapsack(weights, values, capacity):\n    dp = [0] * (capacity + 1)\n\n    for w in range(1, capacity + 1):\n        for i in range(len(weights)):\n            if weights[i] <= w:\n                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\n\n    return dp[capacity]",
    "testCases": [
      {
        "input": "weights = [1, 3, 4, 5], values = [10, 40, 50, 70], capacity = 8",
        "isHidden": false,
        "description": "Can repeat items"
      },
      {
        "input": "weights = [2, 4], values = [5, 11], capacity = 10",
        "isHidden": false,
        "description": "Choose wisely"
      }
    ],
    "hints": [
      "1D DP suffices since items can repeat",
      "dp[w] = max value with capacity w"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Coin Change Minimum Coins",
    "difficulty": 2,
    "description": "Find minimum number of coins to make a given amount.",
    "starterCode": "def coin_change(coins, amount):\n    \"\"\"\n    Find minimum coins needed for amount.\n\n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n\n    Returns:\n        int: Minimum coins, or -1 if impossible\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def coin_change(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for a in range(1, amount + 1):\n        for coin in coins:\n            if coin <= a and dp[a - coin] + 1 < dp[a]:\n                dp[a] = dp[a - coin] + 1\n\n    return dp[amount] if dp[amount] != float('inf') else -1",
    "testCases": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "isHidden": false,
        "description": "5+5+1 = 3 coins"
      },
      {
        "input": "coins = [2], amount = 3",
        "isHidden": false,
        "description": "Impossible"
      }
    ],
    "hints": [
      "dp[a] = min coins for amount a",
      "Try all coins that fit"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Coin Change Count Ways",
    "difficulty": 2,
    "description": "Count the number of ways to make change for an amount.",
    "starterCode": "def coin_change_ways(coins, amount):\n    \"\"\"\n    Count ways to make change.\n\n    Args:\n        coins: Coin denominations\n        amount: Target amount\n\n    Returns:\n        int: Number of distinct ways\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def coin_change_ways(coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n\n    for coin in coins:\n        for a in range(coin, amount + 1):\n            dp[a] += dp[a - coin]\n\n    return dp[amount]",
    "testCases": [
      {
        "input": "coins = [1, 2, 5], amount = 5",
        "isHidden": false,
        "description": "4 ways: 5, 2+2+1, 2+1+1+1, 1+1+1+1+1"
      },
      {
        "input": "coins = [2], amount = 3",
        "isHidden": false,
        "description": "0 ways"
      }
    ],
    "hints": [
      "Process coins one at a time to avoid counting duplicates",
      "dp[a] = number of ways to make a"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "TSP via Bitmask DP",
    "difficulty": 5,
    "description": "Solve TSP exactly using Held-Karp algorithm with bitmask DP.",
    "starterCode": "def tsp_held_karp(dist):\n    \"\"\"\n    Solve TSP using Held-Karp algorithm.\n\n    Args:\n        dist: Distance matrix (n x n)\n\n    Returns:\n        int: Minimum tour cost\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def tsp_held_karp(dist):\n    n = len(dist)\n    INF = float('inf')\n    dp = [[INF] * n for _ in range(1 << n)]\n    dp[1][0] = 0  # Start at city 0\n\n    for mask in range(1 << n):\n        for last in range(n):\n            if not (mask & (1 << last)):\n                continue\n            if dp[mask][last] == INF:\n                continue\n\n            for next_city in range(n):\n                if mask & (1 << next_city):\n                    continue\n                new_mask = mask | (1 << next_city)\n                dp[new_mask][next_city] = min(dp[new_mask][next_city],\n                                               dp[mask][last] + dist[last][next_city])\n\n    full_mask = (1 << n) - 1\n    result = min(dp[full_mask][last] + dist[last][0] for last in range(1, n))\n    return result",
    "testCases": [
      {
        "input": "dist = [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]",
        "isHidden": false,
        "description": "4 cities"
      },
      {
        "input": "dist = [[0,1,2],[1,0,1],[2,1,0]]",
        "isHidden": false,
        "description": "3 cities - triangle"
      }
    ],
    "hints": [
      "Bitmask represents visited cities",
      "dp[mask][last] = min cost to visit cities in mask, ending at last"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Longest Increasing Subsequence",
    "difficulty": 3,
    "description": "Find length of longest strictly increasing subsequence.",
    "starterCode": "def lis_length(nums):\n    \"\"\"\n    Find length of longest increasing subsequence.\n\n    Args:\n        nums: List of integers\n\n    Returns:\n        int: LIS length\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def lis_length(nums):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n  # dp[i] = LIS ending at i\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)",
    "testCases": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "isHidden": false,
        "description": "LIS is [2,3,7,101]"
      },
      {
        "input": "nums = [0, 1, 0, 3, 2, 3]",
        "isHidden": false,
        "description": "LIS length 4"
      }
    ],
    "hints": [
      "dp[i] = length of LIS ending at index i",
      "O(n²) basic, O(n log n) with binary search"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "LIS O(n log n)",
    "difficulty": 4,
    "description": "Implement the O(n log n) LIS algorithm using binary search.",
    "starterCode": "def lis_fast(nums):\n    \"\"\"\n    O(n log n) LIS algorithm.\n\n    Args:\n        nums: List of integers\n\n    Returns:\n        int: LIS length\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import bisect\n\ndef lis_fast(nums):\n    if not nums:\n        return 0\n\n    tails = []  # tails[i] = smallest tail of LIS of length i+1\n\n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n\n    return len(tails)",
    "testCases": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "isHidden": false,
        "description": "Same result, faster"
      },
      {
        "input": "nums = [1, 3, 6, 7, 9, 4, 10, 5, 6]",
        "isHidden": false,
        "description": "Longer sequence"
      }
    ],
    "hints": [
      "Maintain array of smallest tails for each length",
      "Use binary search to find position"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Optimal Binary Search Tree",
    "difficulty": 4,
    "description": "Find the minimum cost BST given search frequencies.",
    "starterCode": "def optimal_bst(keys, freq):\n    \"\"\"\n    Find minimum expected search cost BST.\n\n    Args:\n        keys: Sorted keys\n        freq: Search frequency for each key\n\n    Returns:\n        float: Minimum expected cost\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def optimal_bst(keys, freq):\n    n = len(keys)\n    dp = [[0] * n for _ in range(n)]\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + freq[i]\n\n    def sum_freq(i, j):\n        return prefix_sum[j+1] - prefix_sum[i]\n\n    for i in range(n):\n        dp[i][i] = freq[i]\n\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            dp[i][j] = float('inf')\n            for r in range(i, j + 1):\n                left = dp[i][r-1] if r > i else 0\n                right = dp[r+1][j] if r < j else 0\n                cost = left + right + sum_freq(i, j)\n                dp[i][j] = min(dp[i][j], cost)\n\n    return dp[0][n-1]",
    "testCases": [
      {
        "input": "keys = [10, 12, 20], freq = [34, 8, 50]",
        "isHidden": false,
        "description": "Three keys"
      },
      {
        "input": "keys = [1, 2, 3, 4], freq = [1, 2, 3, 4]",
        "isHidden": false,
        "description": "Four keys"
      }
    ],
    "hints": [
      "Try each key as root",
      "Cost = left subtree + right subtree + sum of frequencies"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Rod Cutting",
    "difficulty": 2,
    "description": "Find maximum revenue from cutting a rod into pieces.",
    "starterCode": "def rod_cutting(prices, n):\n    \"\"\"\n    Find maximum revenue from rod of length n.\n\n    Args:\n        prices: prices[i] = price for rod of length i+1\n        n: Rod length\n\n    Returns:\n        int: Maximum revenue\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def rod_cutting(prices, n):\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, len(prices)) + 1):\n            dp[i] = max(dp[i], prices[j-1] + dp[i-j])\n\n    return dp[n]",
    "testCases": [
      {
        "input": "prices = [1, 5, 8, 9, 10, 17, 17, 20], n = 8",
        "isHidden": false,
        "description": "Rod of length 8"
      },
      {
        "input": "prices = [2, 5, 7, 8], n = 5",
        "isHidden": false,
        "description": "Rod of length 5"
      }
    ],
    "hints": [
      "dp[i] = max revenue for rod of length i",
      "Try all first cut positions"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Palindrome Partitioning",
    "difficulty": 4,
    "description": "Find minimum cuts to partition string into palindromes.",
    "starterCode": "def min_palindrome_cuts(s):\n    \"\"\"\n    Minimum cuts to partition into palindromes.\n\n    Args:\n        s: Input string\n\n    Returns:\n        int: Minimum number of cuts\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def min_palindrome_cuts(s):\n    n = len(s)\n    if n <= 1:\n        return 0\n\n    # Precompute palindrome table\n    is_palin = [[False] * n for _ in range(n)]\n    for i in range(n):\n        is_palin[i][i] = True\n    for i in range(n - 1):\n        is_palin[i][i+1] = (s[i] == s[i+1])\n    for l in range(3, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            is_palin[i][j] = (s[i] == s[j]) and is_palin[i+1][j-1]\n\n    # dp[i] = min cuts for s[0..i]\n    dp = list(range(n))\n    for i in range(1, n):\n        if is_palin[0][i]:\n            dp[i] = 0\n        else:\n            for j in range(i):\n                if is_palin[j+1][i]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[n-1]",
    "testCases": [
      {
        "input": "s = \"aab\"",
        "isHidden": false,
        "description": "Cut into \"aa\" and \"b\""
      },
      {
        "input": "s = \"aabba\"",
        "isHidden": false,
        "description": "Already palindrome"
      }
    ],
    "hints": [
      "Precompute all palindrome substrings",
      "dp[i] = min cuts for prefix of length i+1"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t5-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-5",
    "title": "Egg Drop Problem",
    "difficulty": 4,
    "description": "Find minimum trials to find critical floor with k eggs and n floors.",
    "starterCode": "def egg_drop(eggs, floors):\n    \"\"\"\n    Minimum trials for egg drop problem.\n\n    Args:\n        eggs: Number of eggs\n        floors: Number of floors\n\n    Returns:\n        int: Minimum trials in worst case\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def egg_drop(eggs, floors):\n    # dp[e][f] = min trials with e eggs and f floors\n    dp = [[0] * (floors + 1) for _ in range(eggs + 1)]\n\n    # Base cases\n    for f in range(floors + 1):\n        dp[1][f] = f  # 1 egg: must try linearly\n\n    for e in range(1, eggs + 1):\n        dp[e][0] = 0\n        dp[e][1] = 1\n\n    for e in range(2, eggs + 1):\n        for f in range(2, floors + 1):\n            dp[e][f] = float('inf')\n            for x in range(1, f + 1):\n                # Drop from floor x\n                breaks = dp[e-1][x-1]      # Egg breaks: search below\n                survives = dp[e][f-x]       # Egg survives: search above\n                worst = 1 + max(breaks, survives)\n                dp[e][f] = min(dp[e][f], worst)\n\n    return dp[eggs][floors]",
    "testCases": [
      {
        "input": "eggs = 2, floors = 10",
        "isHidden": false,
        "description": "Classic 2 eggs, 10 floors"
      },
      {
        "input": "eggs = 3, floors = 14",
        "isHidden": false,
        "description": "3 eggs, 14 floors"
      }
    ],
    "hints": [
      "Try dropping from each floor",
      "Take max of break/survive (worst case), min over choices"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Ford-Fulkerson Algorithm",
    "difficulty": 4,
    "description": "Implement the Ford-Fulkerson algorithm to find the maximum flow in a network using DFS to find augmenting paths.",
    "starterCode": "def ford_fulkerson(graph, source, sink):\n    \"\"\"\n    Find maximum flow using Ford-Fulkerson algorithm.\n\n    Args:\n        graph: Adjacency matrix where graph[u][v] is the capacity from u to v.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def ford_fulkerson(graph, source, sink):\n    \"\"\"\n    Find maximum flow using Ford-Fulkerson algorithm.\n\n    Args:\n        graph: Adjacency matrix where graph[u][v] is the capacity from u to v.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    # Create residual graph\n    n = len(graph)\n    residual = [row[:] for row in graph]\n\n    def dfs(s, t, parent):\n        \"\"\"Find augmenting path using DFS.\"\"\"\n        visited = [False] * n\n        stack = [s]\n        visited[s] = True\n\n        while stack:\n            u = stack.pop()\n\n            for v in range(n):\n                if not visited[v] and residual[u][v] > 0:\n                    stack.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    parent = [-1] * n\n    max_flow = 0\n\n    # While there is an augmenting path\n    while dfs(source, sink, parent):\n        # Find minimum capacity along the path\n        path_flow = float('inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, residual[parent[s]][s])\n            s = parent[s]\n\n        # Update residual capacities\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n\n        max_flow += path_flow\n        parent = [-1] * n\n\n    return max_flow",
    "testCases": [
      {
        "input": "graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]], source = 0, sink = 5",
        "isHidden": false,
        "description": "Standard flow network - max flow is 23"
      },
      {
        "input": "graph = [[0, 10, 10, 0], [0, 0, 2, 10], [0, 0, 0, 10], [0, 0, 0, 0]], source = 0, sink = 3",
        "isHidden": false,
        "description": "Simple network with bottleneck"
      },
      {
        "input": "graph = [[0, 5, 0], [0, 0, 5], [0, 0, 0]], source = 0, sink = 2",
        "isHidden": false,
        "description": "Linear path network"
      }
    ],
    "hints": [
      "Create a residual graph that tracks remaining capacity",
      "Use DFS to find an augmenting path from source to sink",
      "Find the minimum capacity along the augmenting path",
      "Update residual capacities: decrease forward edges, increase backward edges",
      "Repeat until no augmenting path exists"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Bipartite Matching",
    "difficulty": 3,
    "description": "Find maximum matching in a bipartite graph by reducing it to a max-flow problem.",
    "starterCode": "def max_bipartite_matching(graph):\n    \"\"\"\n    Find maximum matching in a bipartite graph.\n\n    Args:\n        graph: Adjacency list where graph[u] contains vertices in right set\n               that u (in left set) is connected to.\n               Example: {0: [0, 1], 1: [0, 2], 2: [1]} means\n               Left set {0,1,2} connects to Right set {0,1,2}\n\n    Returns:\n        int: Size of maximum matching.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def max_bipartite_matching(graph):\n    \"\"\"\n    Find maximum matching in a bipartite graph.\n\n    Args:\n        graph: Adjacency list where graph[u] contains vertices in right set\n               that u (in left set) is connected to.\n\n    Returns:\n        int: Size of maximum matching.\n    \"\"\"\n    # match[v] stores the match for vertex v in right set (-1 if unmatched)\n    n_right = max(max(neighbors) for neighbors in graph.values() if neighbors) + 1\n    match = [-1] * n_right\n\n    def dfs(u, visited):\n        \"\"\"Try to find an augmenting path starting from u.\"\"\"\n        for v in graph.get(u, []):\n            if visited[v]:\n                continue\n            visited[v] = True\n\n            # If v is unmatched or we can find an augmenting path\n            # from the vertex matched to v\n            if match[v] == -1 or dfs(match[v], visited):\n                match[v] = u\n                return True\n        return False\n\n    matching_size = 0\n    for u in graph:\n        visited = [False] * n_right\n        if dfs(u, visited):\n            matching_size += 1\n\n    return matching_size",
    "testCases": [
      {
        "input": "graph = {0: [0, 1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Small bipartite graph - matching size 3"
      },
      {
        "input": "graph = {0: [0], 1: [0], 2: [1]}",
        "isHidden": false,
        "description": "Two vertices compete for same match"
      },
      {
        "input": "graph = {0: [0, 1, 2], 1: [1, 2], 2: [2]}",
        "isHidden": false,
        "description": "Multiple possible matchings"
      }
    ],
    "hints": [
      "Use augmenting paths to incrementally increase the matching",
      "For each vertex in left set, try to find an augmenting path",
      "An augmenting path ends at an unmatched vertex or can reroute an existing match",
      "Use DFS to find augmenting paths",
      "Keep track of which right vertices are matched and to whom"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Edmonds-Karp Algorithm",
    "difficulty": 4,
    "description": "Implement Edmonds-Karp (BFS-based Ford-Fulkerson) for finding max flow in O(VE^2) time.",
    "starterCode": "from collections import deque\n\ndef edmonds_karp(graph, source, sink):\n    \"\"\"\n    Find maximum flow using Edmonds-Karp algorithm (BFS).\n\n    Args:\n        graph: Adjacency matrix where graph[u][v] is capacity from u to v.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef edmonds_karp(graph, source, sink):\n    \"\"\"\n    Find maximum flow using Edmonds-Karp algorithm (BFS).\n\n    Args:\n        graph: Adjacency matrix where graph[u][v] is capacity from u to v.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    n = len(graph)\n    residual = [row[:] for row in graph]\n\n    def bfs(s, t, parent):\n        \"\"\"Find augmenting path using BFS.\"\"\"\n        visited = [False] * n\n        queue = deque([s])\n        visited[s] = True\n\n        while queue:\n            u = queue.popleft()\n\n            for v in range(n):\n                if not visited[v] and residual[u][v] > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    parent = [-1] * n\n    max_flow = 0\n\n    while bfs(source, sink, parent):\n        # Find minimum capacity along the path\n        path_flow = float('inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, residual[parent[s]][s])\n            s = parent[s]\n\n        # Update residual capacities\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n\n        max_flow += path_flow\n        parent = [-1] * n\n\n    return max_flow",
    "testCases": [
      {
        "input": "graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]], source = 0, sink = 5",
        "isHidden": false,
        "description": "Standard flow network"
      },
      {
        "input": "graph = [[0, 10, 5, 0], [0, 0, 15, 10], [0, 0, 0, 10], [0, 0, 0, 0]], source = 0, sink = 3",
        "isHidden": false,
        "description": "Simple network"
      },
      {
        "input": "graph = [[0, 1000], [0, 0]], source = 0, sink = 1",
        "isHidden": false,
        "description": "Direct edge"
      }
    ],
    "hints": [
      "Use BFS instead of DFS to find augmenting paths",
      "BFS finds shortest augmenting path (in terms of edges)",
      "This guarantees O(VE^2) time complexity",
      "Each BFS takes O(E) time",
      "At most O(VE) augmenting paths",
      "More predictable performance than basic Ford-Fulkerson"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Min-Cut from Max-Flow",
    "difficulty": 3,
    "description": "After computing max flow, find the minimum cut in the network.",
    "starterCode": "def find_min_cut(graph, source, max_flow_residual):\n    \"\"\"\n    Find minimum cut after max flow computation.\n\n    Args:\n        graph: Original adjacency matrix.\n        source: Source vertex.\n        max_flow_residual: Residual graph after computing max flow.\n\n    Returns:\n        tuple: (cut_edges list, cut_capacity)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def find_min_cut(graph, source, max_flow_residual):\n    \"\"\"\n    Find minimum cut after max flow computation.\n\n    Args:\n        graph: Original adjacency matrix.\n        source: Source vertex.\n        max_flow_residual: Residual graph after computing max flow.\n\n    Returns:\n        tuple: (cut_edges list, cut_capacity)\n    \"\"\"\n    n = len(graph)\n\n    # Find all vertices reachable from source in residual graph\n    visited = [False] * n\n    stack = [source]\n    visited[source] = True\n\n    while stack:\n        u = stack.pop()\n        for v in range(n):\n            if not visited[v] and max_flow_residual[u][v] > 0:\n                visited[v] = True\n                stack.append(v)\n\n    # Find edges from reachable to non-reachable vertices\n    cut_edges = []\n    cut_capacity = 0\n\n    for u in range(n):\n        for v in range(n):\n            if visited[u] and not visited[v] and graph[u][v] > 0:\n                cut_edges.append((u, v))\n                cut_capacity += graph[u][v]\n\n    return cut_edges, cut_capacity",
    "testCases": [
      {
        "input": "graph = [[0, 10, 10, 0], [0, 0, 2, 10], [0, 0, 0, 10], [0, 0, 0, 0]], source = 0, max_flow_residual = [[0, 0, 8, 0], [10, 0, 0, 2], [2, 2, 0, 0], [0, 8, 10, 0]]",
        "isHidden": false,
        "description": "Simple network min-cut"
      },
      {
        "input": "graph = [[0, 5, 5], [0, 0, 5], [0, 0, 0]], source = 0, max_flow_residual = [[0, 0, 0], [5, 0, 0], [5, 5, 0]]",
        "isHidden": false,
        "description": "Two parallel paths"
      },
      {
        "input": "graph = [[0, 16, 13], [0, 0, 10], [0, 0, 0]], source = 0, max_flow_residual = [[0, 0, 3], [16, 0, 0], [13, 10, 0]]",
        "isHidden": false,
        "description": "Network with bottleneck"
      }
    ],
    "hints": [
      "Min-cut = Max-flow (by max-flow min-cut theorem)",
      "After computing max flow, do BFS/DFS from source in residual graph",
      "Mark all reachable vertices",
      "Cut edges go from reachable to non-reachable vertices",
      "Sum capacities of cut edges to verify it equals max flow"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Maximum Flow Verification",
    "difficulty": 2,
    "description": "Verify that a given flow is valid and compute its value.",
    "starterCode": "def verify_flow(graph, flow):\n    \"\"\"\n    Verify that flow satisfies capacity and conservation constraints.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        flow: Adjacency matrix with flow values.\n\n    Returns:\n        tuple: (is_valid, flow_value, error_message)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def verify_flow(graph, flow):\n    \"\"\"\n    Verify that flow satisfies capacity and conservation constraints.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        flow: Adjacency matrix with flow values.\n\n    Returns:\n        tuple: (is_valid, flow_value, error_message)\n    \"\"\"\n    n = len(graph)\n\n    # Check capacity constraints\n    for u in range(n):\n        for v in range(n):\n            if flow[u][v] < 0:\n                return False, 0, f\"Negative flow on edge ({u}, {v})\"\n            if flow[u][v] > graph[u][v]:\n                return False, 0, f\"Flow exceeds capacity on edge ({u}, {v})\"\n\n    # Check flow conservation (except source and sink)\n    # Assume source is 0, sink is n-1\n    source, sink = 0, n - 1\n\n    for v in range(1, n - 1):\n        flow_in = sum(flow[u][v] for u in range(n))\n        flow_out = sum(flow[v][w] for w in range(n))\n        if abs(flow_in - flow_out) > 1e-9:\n            return False, 0, f\"Flow conservation violated at vertex {v}\"\n\n    # Compute flow value (outflow from source or inflow to sink)\n    flow_value = sum(flow[source][v] for v in range(n)) - sum(flow[v][source] for v in range(n))\n\n    return True, flow_value, \"Flow is valid\"",
    "testCases": [
      {
        "input": "graph = [[0, 10, 10], [0, 0, 10], [0, 0, 0]], flow = [[0, 5, 5], [0, 0, 5], [0, 0, 0]]",
        "isHidden": false,
        "description": "Valid flow of value 10"
      },
      {
        "input": "graph = [[0, 10, 10], [0, 0, 10], [0, 0, 0]], flow = [[0, 15, 5], [0, 0, 5], [0, 0, 0]]",
        "isHidden": false,
        "description": "Invalid - exceeds capacity"
      },
      {
        "input": "graph = [[0, 10, 10], [0, 0, 10], [0, 0, 0]], flow = [[0, 5, 5], [0, 0, 3], [0, 0, 0]]",
        "isHidden": false,
        "description": "Invalid - violates conservation"
      }
    ],
    "hints": [
      "Check capacity constraint: 0 ≤ f(u,v) ≤ c(u,v) for all edges",
      "Check flow conservation: Σf(u,v) = Σf(v,w) for all v except source/sink",
      "Flow value = total outflow from source (or inflow to sink)",
      "Return detailed error message if invalid",
      "Use small epsilon for floating point comparisons"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Dinic's Algorithm",
    "difficulty": 5,
    "description": "Implement Dinic's blocking flow algorithm for max flow in O(V^2 E) time.",
    "starterCode": "from collections import deque\n\ndef dinics_algorithm(graph, source, sink):\n    \"\"\"\n    Find maximum flow using Dinic's algorithm.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef dinics_algorithm(graph, source, sink):\n    \"\"\"\n    Find maximum flow using Dinic's algorithm.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    n = len(graph)\n    residual = [row[:] for row in graph]\n\n    def bfs():\n        \"\"\"Build level graph using BFS.\"\"\"\n        level = [-1] * n\n        level[source] = 0\n        queue = deque([source])\n\n        while queue:\n            u = queue.popleft()\n            for v in range(n):\n                if level[v] < 0 and residual[u][v] > 0:\n                    level[v] = level[u] + 1\n                    queue.append(v)\n\n        return level if level[sink] >= 0 else None\n\n    def dfs(u, pushed, level):\n        \"\"\"Send flow using DFS on level graph.\"\"\"\n        if u == sink:\n            return pushed\n\n        for v in range(n):\n            if level[v] == level[u] + 1 and residual[u][v] > 0:\n                flow = dfs(v, min(pushed, residual[u][v]), level)\n                if flow > 0:\n                    residual[u][v] -= flow\n                    residual[v][u] += flow\n                    return flow\n\n        return 0\n\n    max_flow = 0\n\n    while True:\n        level = bfs()\n        if level is None:\n            break\n\n        # Send multiple blocking flows\n        while True:\n            pushed = dfs(source, float('inf'), level)\n            if pushed == 0:\n                break\n            max_flow += pushed\n\n    return max_flow",
    "testCases": [
      {
        "input": "graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]], source = 0, sink = 5",
        "isHidden": false,
        "description": "Standard flow network"
      },
      {
        "input": "graph = [[0, 10, 10, 0], [0, 0, 2, 10], [0, 0, 0, 10], [0, 0, 0, 0]], source = 0, sink = 3",
        "isHidden": false,
        "description": "Network with bottleneck"
      },
      {
        "input": "graph = [[0, 100, 100], [0, 0, 1], [0, 0, 0]], source = 0, sink = 2",
        "isHidden": false,
        "description": "Two paths, one very small"
      }
    ],
    "hints": [
      "Build level graph using BFS (distances from source)",
      "Find blocking flow using DFS only on level graph edges",
      "Blocking flow: no more augmenting paths in level graph",
      "Repeat until no path from source to sink exists",
      "O(V^2 E) time complexity, better for dense graphs",
      "Each phase increases shortest path length"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Flow with Multiple Sources and Sinks",
    "difficulty": 3,
    "description": "Convert multiple source/sink problem to single source/sink by adding super source and sink.",
    "starterCode": "def max_flow_multiple_sources_sinks(graph, sources, sinks):\n    \"\"\"\n    Find max flow with multiple sources and sinks.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        sources: List of source vertices.\n        sinks: List of sink vertices.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def max_flow_multiple_sources_sinks(graph, sources, sinks):\n    \"\"\"\n    Find max flow with multiple sources and sinks.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        sources: List of source vertices.\n        sinks: List of sink vertices.\n\n    Returns:\n        int: Maximum flow value.\n    \"\"\"\n    n = len(graph)\n    # Add super source (n) and super sink (n+1)\n    new_graph = [[0] * (n + 2) for _ in range(n + 2)]\n\n    # Copy original edges\n    for u in range(n):\n        for v in range(n):\n            new_graph[u][v] = graph[u][v]\n\n    # Connect super source to all sources with infinite capacity\n    for s in sources:\n        new_graph[n][s] = float('inf')\n\n    # Connect all sinks to super sink with infinite capacity\n    for t in sinks:\n        new_graph[t][n + 1] = float('inf')\n\n    # Run max flow on new graph\n    return ford_fulkerson_basic(new_graph, n, n + 1)\n\ndef ford_fulkerson_basic(graph, source, sink):\n    \"\"\"Basic Ford-Fulkerson for helper.\"\"\"\n    n = len(graph)\n    residual = [row[:] for row in graph]\n\n    def dfs(s, t, parent):\n        visited = [False] * n\n        stack = [s]\n        visited[s] = True\n\n        while stack:\n            u = stack.pop()\n            for v in range(n):\n                if not visited[v] and residual[u][v] > 0:\n                    stack.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    parent = [-1] * n\n    max_flow = 0\n\n    while dfs(source, sink, parent):\n        path_flow = float('inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, residual[parent[s]][s])\n            s = parent[s]\n\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n\n        max_flow += path_flow\n        parent = [-1] * n\n\n    return int(max_flow) if max_flow != float('inf') else max_flow",
    "testCases": [
      {
        "input": "graph = [[0, 10, 0, 0], [0, 0, 10, 0], [0, 0, 0, 10], [0, 0, 0, 0]], sources = [0, 1], sinks = [2, 3]",
        "isHidden": false,
        "description": "Two sources, two sinks"
      },
      {
        "input": "graph = [[0, 5, 5, 0], [0, 0, 0, 5], [0, 0, 0, 5], [0, 0, 0, 0]], sources = [0], sinks = [1, 2, 3]",
        "isHidden": false,
        "description": "One source, multiple sinks"
      },
      {
        "input": "graph = [[0, 10], [0, 0]], sources = [0], sinks = [1]",
        "isHidden": false,
        "description": "Single source and sink"
      }
    ],
    "hints": [
      "Add super source vertex connected to all sources",
      "Add super sink vertex receiving from all sinks",
      "Use infinite capacity for super source/sink edges",
      "Run standard max flow on augmented graph",
      "Result is max flow from sources to sinks in original graph"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Circulation with Demands",
    "difficulty": 4,
    "description": "Find a feasible circulation where vertices have demands (positive) or supplies (negative).",
    "starterCode": "def find_circulation(graph, demands):\n    \"\"\"\n    Find feasible circulation with vertex demands.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        demands: List where demands[v] is demand at vertex v (negative = supply).\n\n    Returns:\n        tuple: (exists, circulation matrix if exists else None)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def find_circulation(graph, demands):\n    \"\"\"\n    Find feasible circulation with vertex demands.\n\n    Args:\n        graph: Adjacency matrix with capacities.\n        demands: List where demands[v] is demand at vertex v (negative = supply).\n\n    Returns:\n        tuple: (exists, circulation matrix if exists else None)\n    \"\"\"\n    n = len(graph)\n\n    # Check if total demand equals total supply\n    if sum(demands) != 0:\n        return False, None\n\n    # Create flow network with super source and sink\n    new_graph = [[0] * (n + 2) for _ in range(n + 2)]\n    super_source = n\n    super_sink = n + 1\n\n    # Copy original edges\n    for u in range(n):\n        for v in range(n):\n            new_graph[u][v] = graph[u][v]\n\n    # Connect vertices based on demands\n    total_demand = 0\n    for v in range(n):\n        if demands[v] > 0:  # Demand\n            new_graph[v][super_sink] = demands[v]\n            total_demand += demands[v]\n        elif demands[v] < 0:  # Supply\n            new_graph[super_source][v] = -demands[v]\n\n    # Find max flow\n    max_flow = ford_fulkerson_basic(new_graph, super_source, super_sink)\n\n    # Circulation exists if max flow equals total demand\n    if max_flow >= total_demand - 1e-9:\n        # Extract circulation from flow\n        circulation = [[0] * n for _ in range(n)]\n        # Note: Would need to track flow to extract actual circulation\n        return True, circulation\n    else:\n        return False, None\n\ndef ford_fulkerson_basic(graph, source, sink):\n    \"\"\"Basic Ford-Fulkerson implementation.\"\"\"\n    n = len(graph)\n    residual = [row[:] for row in graph]\n\n    def dfs(s, t, parent):\n        visited = [False] * n\n        stack = [s]\n        visited[s] = True\n\n        while stack:\n            u = stack.pop()\n            for v in range(n):\n                if not visited[v] and residual[u][v] > 0:\n                    stack.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    parent = [-1] * n\n    max_flow = 0\n\n    while dfs(source, sink, parent):\n        path_flow = float('inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, residual[parent[s]][s])\n            s = parent[s]\n\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n\n        max_flow += path_flow\n        parent = [-1] * n\n\n    return max_flow",
    "testCases": [
      {
        "input": "graph = [[0, 10, 10], [0, 0, 10], [0, 0, 0]], demands = [-10, 0, 10]",
        "isHidden": false,
        "description": "Simple circulation with supply and demand"
      },
      {
        "input": "graph = [[0, 5, 5], [0, 0, 5], [0, 0, 0]], demands = [-10, 0, 10]",
        "isHidden": false,
        "description": "Infeasible - insufficient capacity"
      },
      {
        "input": "graph = [[0, 20, 20], [0, 0, 20], [0, 0, 0]], demands = [-15, 5, 10]",
        "isHidden": false,
        "description": "Supply of 15, demands of 5 and 10"
      }
    ],
    "hints": [
      "Circulation must satisfy: inflow = outflow + demand at each vertex",
      "Add super source and super sink",
      "Connect super source to supply vertices (demand < 0)",
      "Connect demand vertices (demand > 0) to super sink",
      "Feasible circulation exists iff max flow equals total demand",
      "Total supply must equal total demand"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Edge-Disjoint Paths",
    "difficulty": 3,
    "description": "Find maximum number of edge-disjoint paths between source and sink.",
    "starterCode": "def max_edge_disjoint_paths(graph, source, sink):\n    \"\"\"\n    Find maximum number of edge-disjoint paths from source to sink.\n\n    Args:\n        graph: Adjacency list representing directed graph.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum number of edge-disjoint paths.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def max_edge_disjoint_paths(graph, source, sink):\n    \"\"\"\n    Find maximum number of edge-disjoint paths from source to sink.\n\n    Args:\n        graph: Adjacency list representing directed graph.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum number of edge-disjoint paths.\n    \"\"\"\n    # Convert to capacity graph (all edges have capacity 1)\n    vertices = set([source, sink])\n    for u in graph:\n        vertices.add(u)\n        for v in graph[u]:\n            vertices.add(v)\n\n    vertex_list = sorted(vertices)\n    vertex_to_idx = {v: i for i, v in enumerate(vertex_list)}\n    n = len(vertex_list)\n\n    capacity = [[0] * n for _ in range(n)]\n    for u in graph:\n        u_idx = vertex_to_idx[u]\n        for v in graph[u]:\n            v_idx = vertex_to_idx[v]\n            capacity[u_idx][v_idx] = 1\n\n    # Max flow with unit capacities = max edge-disjoint paths\n    def dfs(s, t, parent, residual):\n        visited = [False] * n\n        stack = [s]\n        visited[s] = True\n\n        while stack:\n            u = stack.pop()\n            for v in range(n):\n                if not visited[v] and residual[u][v] > 0:\n                    stack.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    residual = [row[:] for row in capacity]\n    source_idx = vertex_to_idx[source]\n    sink_idx = vertex_to_idx[sink]\n    parent = [-1] * n\n    paths = 0\n\n    while dfs(source_idx, sink_idx, parent, residual):\n        # Augment flow along path (flow = 1)\n        v = sink_idx\n        while v != source_idx:\n            u = parent[v]\n            residual[u][v] -= 1\n            residual[v][u] += 1\n            v = parent[v]\n\n        paths += 1\n        parent = [-1] * n\n\n    return paths",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [3], 2: [3]}, source = 0, sink = 3",
        "isHidden": false,
        "description": "Two edge-disjoint paths exist"
      },
      {
        "input": "graph = {0: [1], 1: [2], 2: [3]}, source = 0, sink = 3",
        "isHidden": false,
        "description": "Only one path (linear graph)"
      },
      {
        "input": "graph = {0: [1, 2, 3], 1: [4], 2: [4], 3: [4]}, source = 0, sink = 4",
        "isHidden": false,
        "description": "Three edge-disjoint paths"
      }
    ],
    "hints": [
      "Edge-disjoint paths use no common edges",
      "Convert to max flow problem with unit capacities",
      "Each edge has capacity 1",
      "Max flow value = max number of edge-disjoint paths",
      "This is Menger's theorem for directed graphs",
      "Each unit of flow represents one path"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Vertex-Disjoint Paths",
    "difficulty": 4,
    "description": "Find maximum number of vertex-disjoint paths by splitting vertices.",
    "starterCode": "def max_vertex_disjoint_paths(graph, source, sink):\n    \"\"\"\n    Find maximum number of vertex-disjoint paths from source to sink.\n\n    Args:\n        graph: Adjacency list of directed graph.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum number of vertex-disjoint paths.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def max_vertex_disjoint_paths(graph, source, sink):\n    \"\"\"\n    Find maximum number of vertex-disjoint paths from source to sink.\n\n    Args:\n        graph: Adjacency list of directed graph.\n        source: Source vertex.\n        sink: Sink vertex.\n\n    Returns:\n        int: Maximum number of vertex-disjoint paths.\n    \"\"\"\n    # Split each vertex v into v_in and v_out\n    # Edge (v_in, v_out) with capacity 1\n    # Original edge (u, v) becomes (u_out, v_in) with capacity ∞\n\n    vertices = set([source, sink])\n    for u in graph:\n        vertices.add(u)\n        for v in graph[u]:\n            vertices.add(v)\n\n    vertex_list = sorted(vertices)\n    n = len(vertex_list)\n\n    # Create split vertex graph (2 * n vertices)\n    capacity = [[0] * (2 * n) for _ in range(2 * n)]\n    vertex_to_idx = {v: i for i, v in enumerate(vertex_list)}\n\n    # Add vertex splitting edges (v_in -> v_out)\n    for v in vertex_list:\n        v_idx = vertex_to_idx[v]\n        v_in = v_idx\n        v_out = v_idx + n\n        if v == source or v == sink:\n            capacity[v_in][v_out] = float('inf')  # No limit on source/sink\n        else:\n            capacity[v_in][v_out] = 1  # Unit capacity for other vertices\n\n    # Add original edges (u_out -> v_in)\n    for u in graph:\n        u_idx = vertex_to_idx[u]\n        u_out = u_idx + n\n        for v in graph[u]:\n            v_idx = vertex_to_idx[v]\n            v_in = v_idx\n            capacity[u_out][v_in] = float('inf')\n\n    # Max flow from source_in to sink_out\n    source_idx = vertex_to_idx[source]\n    sink_idx = vertex_to_idx[sink] + n  # sink_out\n\n    # Run max flow (simplified)\n    residual = [row[:] for row in capacity]\n    paths = 0\n\n    def dfs(s, t, parent):\n        visited = [False] * (2 * n)\n        stack = [s]\n        visited[s] = True\n\n        while stack:\n            u = stack.pop()\n            for v in range(2 * n):\n                if not visited[v] and residual[u][v] > 0:\n                    stack.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    parent = [-1] * (2 * n)\n    while dfs(source_idx, sink_idx, parent):\n        # Find min capacity (will be 1 for vertex capacity)\n        path_flow = float('inf')\n        v = sink_idx\n        while v != source_idx:\n            path_flow = min(path_flow, residual[parent[v]][v])\n            v = parent[v]\n\n        # Update residual\n        v = sink_idx\n        while v != source_idx:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n\n        paths += int(path_flow)\n        parent = [-1] * (2 * n)\n\n    return paths",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [3], 2: [3]}, source = 0, sink = 3",
        "isHidden": false,
        "description": "Two vertex-disjoint paths"
      },
      {
        "input": "graph = {0: [1], 1: [2, 3], 2: [4], 3: [4]}, source = 0, sink = 4",
        "isHidden": false,
        "description": "Vertex 1 must be shared"
      },
      {
        "input": "graph = {0: [1, 2], 1: [3], 2: [4], 3: [5], 4: [5]}, source = 0, sink = 5",
        "isHidden": false,
        "description": "Multiple intermediate vertices"
      }
    ],
    "hints": [
      "Vertex-disjoint paths share no internal vertices",
      "Split each vertex v into v_in and v_out",
      "Connect v_in to v_out with capacity 1 (except source/sink)",
      "Original edge (u,v) becomes (u_out, v_in) with infinite capacity",
      "Run max flow on split graph",
      "Max flow value = max vertex-disjoint paths"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Assignment Problem",
    "difficulty": 3,
    "description": "Solve assignment problem using min-cost max-flow (simplified to just max matching here).",
    "starterCode": "def assignment_problem(cost_matrix):\n    \"\"\"\n    Solve assignment problem: assign n workers to n jobs minimizing cost.\n\n    Args:\n        cost_matrix: Matrix where cost_matrix[i][j] is cost of assigning worker i to job j.\n\n    Returns:\n        tuple: (assignment dict, total_cost)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def assignment_problem(cost_matrix):\n    \"\"\"\n    Solve assignment problem: assign n workers to n jobs minimizing cost.\n\n    Args:\n        cost_matrix: Matrix where cost_matrix[i][j] is cost of assigning worker i to job j.\n\n    Returns:\n        tuple: (assignment dict, total_cost)\n    \"\"\"\n    # Simplified: convert to max matching with cost consideration\n    # For true min-cost max-flow, need Hungarian algorithm or cost-based augmentation\n\n    n = len(cost_matrix)\n\n    # Greedy approach: repeatedly assign worker-job pair with minimum cost\n    assignment = {}\n    assigned_workers = set()\n    assigned_jobs = set()\n    total_cost = 0\n\n    # Find all worker-job pairs sorted by cost\n    pairs = []\n    for i in range(n):\n        for j in range(n):\n            pairs.append((cost_matrix[i][j], i, j))\n\n    pairs.sort()\n\n    # Assign greedily\n    for cost, worker, job in pairs:\n        if worker not in assigned_workers and job not in assigned_jobs:\n            assignment[worker] = job\n            assigned_workers.add(worker)\n            assigned_jobs.add(job)\n            total_cost += cost\n\n            if len(assignment) == n:\n                break\n\n    return assignment, total_cost",
    "testCases": [
      {
        "input": "cost_matrix = [[9, 2, 7], [6, 4, 3], [5, 8, 1]]",
        "isHidden": false,
        "description": "3x3 assignment problem"
      },
      {
        "input": "cost_matrix = [[1, 2], [2, 1]]",
        "isHidden": false,
        "description": "Simple 2x2 assignment"
      },
      {
        "input": "cost_matrix = [[5, 9, 3, 6], [8, 7, 8, 2], [6, 10, 12, 7], [3, 10, 8, 6]]",
        "isHidden": false,
        "description": "4x4 assignment problem"
      }
    ],
    "hints": [
      "Assignment problem: assign n workers to n jobs (one-to-one)",
      "Minimize total cost of assignments",
      "Can be solved with Hungarian algorithm O(n^3)",
      "Or min-cost max-flow approach",
      "This greedy solution is approximate but simple",
      "For optimal: need bipartite matching with costs"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Project Selection Problem",
    "difficulty": 4,
    "description": "Select projects to maximize profit given dependencies (max-flow application).",
    "starterCode": "def project_selection(profits, prerequisites):\n    \"\"\"\n    Select projects to maximize profit respecting prerequisites.\n\n    Args:\n        profits: List where profits[i] is profit of project i (can be negative).\n        prerequisites: Dict where prerequisites[i] lists projects required before i.\n\n    Returns:\n        tuple: (selected_projects set, total_profit)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def project_selection(profits, prerequisites):\n    \"\"\"\n    Select projects to maximize profit respecting prerequisites.\n\n    Args:\n        profits: List where profits[i] is profit of project i (can be negative).\n        prerequisites: Dict where prerequisites[i] lists projects required before i.\n\n    Returns:\n        tuple: (selected_projects set, total_profit)\n    \"\"\"\n    n = len(profits)\n\n    # Build flow network:\n    # - Source connects to positive profit projects (capacity = profit)\n    # - Negative profit projects connect to sink (capacity = |profit|)\n    # - Prerequisites create edges with infinite capacity\n\n    # Simplified greedy approach (true solution needs min-cut)\n    # Select projects with positive profit and their prerequisites\n\n    selected = set()\n    total_profit = 0\n\n    # Start with positive profit projects\n    for i in range(n):\n        if profits[i] > 0:\n            # Check if we should include this project\n            # Need to include prerequisites\n            to_include = {i}\n            stack = list(prerequisites.get(i, []))\n            prereq_cost = 0\n\n            while stack:\n                prereq = stack.pop()\n                if prereq not in to_include:\n                    to_include.add(prereq)\n                    if profits[prereq] < 0:\n                        prereq_cost += abs(profits[prereq])\n                    stack.extend(prerequisites.get(prereq, []))\n\n            # Include if net profit is positive\n            net_profit = profits[i] - prereq_cost\n            if net_profit > 0:\n                for proj in to_include:\n                    if proj not in selected:\n                        selected.add(proj)\n                        total_profit += profits[proj]\n\n    return selected, total_profit",
    "testCases": [
      {
        "input": "profits = [10, -5, 15, -8, 20], prerequisites = {0: [1], 2: [1], 4: [3]}",
        "isHidden": false,
        "description": "Projects with dependencies"
      },
      {
        "input": "profits = [5, 10, 15], prerequisites = {}",
        "isHidden": false,
        "description": "All positive profits, no dependencies"
      },
      {
        "input": "profits = [20, -10, -5, 15], prerequisites = {0: [1, 2], 3: [2]}",
        "isHidden": false,
        "description": "Complex dependencies"
      }
    ],
    "hints": [
      "Some projects have positive profit, some negative (costs)",
      "If project i selected, all prerequisites must be selected",
      "Goal: maximize total profit",
      "Model as min-cut problem",
      "Source connects to positive profit projects",
      "Negative profit projects connect to sink",
      "Dependency edges have infinite capacity"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Maximum Bipartite Matching with Preferences",
    "difficulty": 3,
    "description": "Find stable matching in bipartite graph where both sides have preference lists.",
    "starterCode": "def stable_matching(left_prefs, right_prefs):\n    \"\"\"\n    Find stable matching using Gale-Shapley algorithm.\n\n    Args:\n        left_prefs: Dict mapping left vertex to ranked list of right vertices.\n        right_prefs: Dict mapping right vertex to ranked list of left vertices.\n\n    Returns:\n        dict: Matching from left to right vertices.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def stable_matching(left_prefs, right_prefs):\n    \"\"\"\n    Find stable matching using Gale-Shapley algorithm.\n\n    Args:\n        left_prefs: Dict mapping left vertex to ranked list of right vertices.\n        right_prefs: Dict mapping right vertex to ranked list of left vertices.\n\n    Returns:\n        dict: Matching from left to right vertices.\n    \"\"\"\n    # Gale-Shapley algorithm (left-optimal stable matching)\n    free_left = list(left_prefs.keys())\n    matching = {}  # right -> left\n    next_proposal = {l: 0 for l in left_prefs}  # tracks next proposal index\n\n    while free_left:\n        left = free_left.pop(0)\n\n        # Get next right vertex in left's preference list\n        if next_proposal[left] >= len(left_prefs[left]):\n            # No more options (shouldn't happen if complete preferences)\n            continue\n\n        right = left_prefs[left][next_proposal[left]]\n        next_proposal[left] += 1\n\n        if right not in matching:\n            # Right is free, match them\n            matching[right] = left\n        else:\n            # Right is already matched, check if prefers new left\n            current_left = matching[right]\n            right_pref_list = right_prefs[right]\n\n            if right_pref_list.index(left) < right_pref_list.index(current_left):\n                # Right prefers new left\n                matching[right] = left\n                free_left.append(current_left)  # Old match becomes free\n            else:\n                # Right prefers current match\n                free_left.append(left)  # Left tries again\n\n    # Convert to left -> right mapping\n    result = {v: k for k, v in matching.items()}\n    return result",
    "testCases": [
      {
        "input": "left_prefs = {0: [0, 1], 1: [1, 0]}, right_prefs = {0: [0, 1], 1: [1, 0]}",
        "isHidden": false,
        "description": "Simple stable matching"
      },
      {
        "input": "left_prefs = {0: [0, 1, 2], 1: [1, 0, 2], 2: [0, 1, 2]}, right_prefs = {0: [1, 0, 2], 1: [0, 1, 2], 2: [0, 1, 2]}",
        "isHidden": false,
        "description": "Three pairs with complex preferences"
      },
      {
        "input": "left_prefs = {0: [0], 1: [1]}, right_prefs = {0: [0], 1: [1]}",
        "isHidden": false,
        "description": "Perfect agreement"
      }
    ],
    "hints": [
      "Stable matching: no two vertices prefer each other over current match",
      "Gale-Shapley algorithm guarantees stable matching",
      "Left vertices propose to right vertices in preference order",
      "Right vertices accept if unmatched or prefer new proposer",
      "Rejected left vertices propose to next preference",
      "Always terminates with stable matching"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Baseball Elimination",
    "difficulty": 4,
    "description": "Determine if a team can win the championship using max-flow.",
    "starterCode": "def can_win_championship(wins, losses, remaining, games_left):\n    \"\"\"\n    Determine if team 0 can win the championship.\n\n    Args:\n        wins: List of current wins for each team.\n        losses: List of current losses for each team.\n        remaining: List of remaining games for each team.\n        games_left: Matrix where games_left[i][j] is games left between teams i and j.\n\n    Returns:\n        bool: True if team 0 can possibly win.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def can_win_championship(wins, losses, remaining, games_left):\n    \"\"\"\n    Determine if team 0 can win the championship.\n\n    Args:\n        wins: List of current wins for each team.\n        losses: List of current losses for each team.\n        remaining: List of remaining games for each team.\n        games_left: Matrix where games_left[i][j] is games left between teams i and j.\n\n    Returns:\n        bool: True if team 0 can possibly win.\n    \"\"\"\n    n = len(wins)\n\n    # Maximum possible wins for team 0\n    max_wins_0 = wins[0] + remaining[0]\n\n    # Check trivial elimination\n    for i in range(1, n):\n        if wins[i] > max_wins_0:\n            return False  # Team i already has more wins\n\n    # Build flow network\n    # Vertices: source, game nodes, team nodes, sink\n    # Game node for each pair (i,j) where i < j and both != 0\n\n    game_pairs = []\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if games_left[i][j] > 0:\n                game_pairs.append((i, j))\n\n    # Simplified check: if any team can exceed team 0's max wins\n    for i in range(1, n):\n        potential_wins = wins[i]\n        for j in range(n):\n            if i != j:\n                potential_wins += games_left[i][j]\n\n        if potential_wins > max_wins_0:\n            # Team i could potentially exceed team 0\n            # Need to check if this is avoidable through game outcomes\n            return False  # Simplified - true solution needs flow network\n\n    return True",
    "testCases": [
      {
        "input": "wins = [75, 71, 69], losses = [59, 63, 66], remaining = [28, 28, 27], games_left = [[0, 1, 3], [1, 0, 2], [3, 2, 0]]",
        "isHidden": false,
        "description": "Team 0 can potentially win"
      },
      {
        "input": "wins = [70, 80, 75], losses = [60, 50, 55], remaining = [10, 10, 10], games_left = [[0, 5, 5], [5, 0, 5], [5, 5, 0]]",
        "isHidden": false,
        "description": "Team 0 already eliminated"
      },
      {
        "input": "wins = [80, 79, 78], losses = [79, 80, 81], remaining = [1, 1, 1], games_left = [[0, 1, 0], [1, 0, 0], [0, 0, 0]]",
        "isHidden": false,
        "description": "Close race"
      }
    ],
    "hints": [
      "Team 0 wins if it can finish with most wins",
      "Assume team 0 wins all remaining games",
      "Check if other teams can be kept below team 0's total",
      "Model remaining games between other teams as flow",
      "Source connects to game nodes (capacity = games left)",
      "Game nodes connect to team nodes",
      "Team nodes connect to sink (capacity = max_wins_0 - current_wins)",
      "Team 0 can win iff max flow saturates all game nodes"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Image Segmentation",
    "difficulty": 5,
    "description": "Use min-cut for image segmentation (simplified version).",
    "starterCode": "def image_segmentation(pixels, similarity, source_affinity, sink_affinity):\n    \"\"\"\n    Segment image into two regions using min-cut.\n\n    Args:\n        pixels: List of pixel indices.\n        similarity: Dict mapping (i, j) to similarity between pixels i and j.\n        source_affinity: Dict mapping pixel to affinity to source (foreground).\n        sink_affinity: Dict mapping pixel to affinity to sink (background).\n\n    Returns:\n        set: Pixels in source/foreground segment.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def image_segmentation(pixels, similarity, source_affinity, sink_affinity):\n    \"\"\"\n    Segment image into two regions using min-cut.\n\n    Args:\n        pixels: List of pixel indices.\n        similarity: Dict mapping (i, j) to similarity between pixels i and j.\n        source_affinity: Dict mapping pixel to affinity to source (foreground).\n        sink_affinity: Dict mapping pixel to affinity to sink (background).\n\n    Returns:\n        set: Pixels in source/foreground segment.\n    \"\"\"\n    n = len(pixels)\n    # Build flow network\n    # Vertices: source, pixels, sink\n    # source index: n, sink index: n+1\n\n    capacity = [[0] * (n + 2) for _ in range(n + 2)]\n    source_idx = n\n    sink_idx = n + 1\n\n    # Source/sink edges\n    for i, pixel in enumerate(pixels):\n        capacity[source_idx][i] = source_affinity.get(pixel, 0)\n        capacity[i][sink_idx] = sink_affinity.get(pixel, 0)\n\n    # Pixel-pixel edges (similarity)\n    for (i, j), sim in similarity.items():\n        if i in pixels and j in pixels:\n            i_idx = pixels.index(i)\n            j_idx = pixels.index(j)\n            capacity[i_idx][j_idx] = sim\n            capacity[j_idx][i_idx] = sim\n\n    # Find min-cut (run max flow, then find reachable from source)\n    residual = [row[:] for row in capacity]\n\n    def dfs(s, t, parent):\n        visited = [False] * (n + 2)\n        stack = [s]\n        visited[s] = True\n\n        while stack:\n            u = stack.pop()\n            for v in range(n + 2):\n                if not visited[v] and residual[u][v] > 0:\n                    stack.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        return False\n\n    parent = [-1] * (n + 2)\n\n    while dfs(source_idx, sink_idx, parent):\n        path_flow = float('inf')\n        v = sink_idx\n        while v != source_idx:\n            path_flow = min(path_flow, residual[parent[v]][v])\n            v = parent[v]\n\n        v = sink_idx\n        while v != source_idx:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n\n        parent = [-1] * (n + 2)\n\n    # Find pixels reachable from source\n    visited = [False] * (n + 2)\n    stack = [source_idx]\n    visited[source_idx] = True\n\n    while stack:\n        u = stack.pop()\n        for v in range(n + 2):\n            if not visited[v] and residual[u][v] > 0:\n                visited[v] = True\n                stack.append(v)\n\n    foreground = {pixels[i] for i in range(n) if visited[i]}\n    return foreground",
    "testCases": [
      {
        "input": "pixels = [0, 1, 2, 3], similarity = {(0, 1): 5, (1, 2): 5, (2, 3): 5, (0, 2): 1}, source_affinity = {0: 10, 1: 2}, sink_affinity = {2: 2, 3: 10}",
        "isHidden": false,
        "description": "Simple 4-pixel segmentation"
      },
      {
        "input": "pixels = [0, 1, 2], similarity = {(0, 1): 3, (1, 2): 3}, source_affinity = {0: 10}, sink_affinity = {2: 10}",
        "isHidden": false,
        "description": "Linear pixel arrangement"
      },
      {
        "input": "pixels = [0, 1], similarity = {(0, 1): 10}, source_affinity = {0: 5}, sink_affinity = {1: 5}",
        "isHidden": false,
        "description": "Two very similar pixels"
      }
    ],
    "hints": [
      "Image segmentation: partition pixels into foreground/background",
      "Source represents foreground, sink represents background",
      "Edge weights represent cost of cutting (dissimilarity)",
      "Source edges: affinity to foreground",
      "Sink edges: affinity to background",
      "Pixel-pixel edges: similarity (high similarity = high cost to cut)",
      "Min-cut gives optimal segmentation minimizing cut cost",
      "Pixels reachable from source after max-flow are foreground"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t6-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-6",
    "title": "Minimum Path Cover",
    "difficulty": 4,
    "description": "Find minimum number of paths that cover all vertices in a DAG.",
    "starterCode": "def minimum_path_cover(vertices, edges):\n    \"\"\"\n    Find minimum path cover in a DAG.\n\n    Args:\n        vertices: List of vertices.\n        edges: List of directed edges (u, v).\n\n    Returns:\n        int: Minimum number of vertex-disjoint paths needed to cover all vertices.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def minimum_path_cover(vertices, edges):\n    \"\"\"\n    Find minimum path cover in a DAG.\n\n    Args:\n        vertices: List of vertices.\n        edges: List of directed edges (u, v).\n\n    Returns:\n        int: Minimum number of vertex-disjoint paths needed to cover all vertices.\n    \"\"\"\n    # Convert to bipartite matching problem\n    # Create two copies of vertices (left and right)\n    # Edge (u,v) in DAG creates edge from u_left to v_right\n\n    n = len(vertices)\n    vertex_to_idx = {v: i for i, v in enumerate(vertices)}\n\n    # Build bipartite graph\n    graph = {i: [] for i in range(n)}\n\n    for u, v in edges:\n        u_idx = vertex_to_idx[u]\n        v_idx = vertex_to_idx[v]\n        graph[u_idx].append(v_idx)\n\n    # Find maximum matching\n    match = [-1] * n\n\n    def dfs(u, visited):\n        for v in graph[u]:\n            if visited[v]:\n                continue\n            visited[v] = True\n\n            if match[v] == -1 or dfs(match[v], visited):\n                match[v] = u\n                return True\n        return False\n\n    matching_size = 0\n    for u in range(n):\n        visited = [False] * n\n        if dfs(u, visited):\n            matching_size += 1\n\n    # Minimum path cover = n - maximum matching\n    return n - matching_size",
    "testCases": [
      {
        "input": "vertices = [0, 1, 2, 3], edges = [(0, 1), (1, 2), (0, 3)]",
        "isHidden": false,
        "description": "DAG with 4 vertices"
      },
      {
        "input": "vertices = [0, 1, 2], edges = [(0, 1), (1, 2)]",
        "isHidden": false,
        "description": "Linear DAG - one path covers all"
      },
      {
        "input": "vertices = [0, 1, 2, 3], edges = []",
        "isHidden": false,
        "description": "No edges - need 4 paths (each vertex)"
      }
    ],
    "hints": [
      "Path cover: set of paths covering all vertices",
      "Paths are vertex-disjoint (no shared vertices)",
      "Minimum path cover in DAG via bipartite matching",
      "Create bipartite graph with two copies of vertices",
      "Edge (u,v) creates bipartite edge from u_left to v_right",
      "Maximum matching = edges in path cover",
      "Minimum path cover = n - maximum matching",
      "Each matching edge combines two paths into one"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Convex Hull - Graham Scan",
    "difficulty": 4,
    "description": "Implement Graham's scan algorithm to find the convex hull of a set of 2D points in O(n log n) time.",
    "starterCode": "def convex_hull(points):\n    \"\"\"\n    Find convex hull using Graham's scan algorithm.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        list: Points on the convex hull in counterclockwise order.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def convex_hull(points):\n    \"\"\"\n    Find convex hull using Graham's scan algorithm.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        list: Points on the convex hull in counterclockwise order.\n    \"\"\"\n    def cross_product(o, a, b):\n        \"\"\"Calculate cross product of vectors OA and OB.\"\"\"\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    # Sort points lexicographically (first by x, then by y)\n    points = sorted(set(points))\n\n    if len(points) <= 2:\n        return points\n\n    # Build lower hull\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    # Build upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    # Remove last point of each half because it's repeated\n    return lower[:-1] + upper[:-1]",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0)]",
        "isHidden": false,
        "description": "Simple convex hull with some interior points"
      },
      {
        "input": "points = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Square - all points on hull"
      },
      {
        "input": "points = [(0, 0), (3, 3), (1, 1), (2, 2), (4, 4), (0, 4), (4, 0)]",
        "isHidden": false,
        "description": "Points with collinear segments"
      }
    ],
    "hints": [
      "Sort points lexicographically (by x-coordinate, then y-coordinate)",
      "Build lower hull by scanning left to right",
      "Build upper hull by scanning right to left",
      "Use cross product to determine if three points make a left or right turn",
      "Remove points that create right turns (non-convex angles)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Closest Pair of Points",
    "difficulty": 4,
    "description": "Find the closest pair of points in 2D using divide-and-conquer in O(n log n) time.",
    "starterCode": "def closest_pair(points):\n    \"\"\"\n    Find the closest pair of points using divide-and-conquer.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        tuple: (distance, point1, point2) where distance is the minimum distance.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def closest_pair(points):\n    \"\"\"\n    Find the closest pair of points using divide-and-conquer.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        tuple: (distance, point1, point2) where distance is the minimum distance.\n    \"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = (None, None)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                d = distance(points[i], points[j])\n                if d < min_dist:\n                    min_dist = d\n                    pair = (points[i], points[j])\n        return min_dist, pair\n\n    def closest_pair_recursive(px, py):\n        n = len(px)\n\n        # Use brute force for small cases\n        if n <= 3:\n            dist, pair = brute_force(px)\n            return dist, pair\n\n        # Divide\n        mid = n // 2\n        midpoint = px[mid]\n\n        # Split points by x-coordinate\n        pyl = [p for p in py if p[0] <= midpoint[0]]\n        pyr = [p for p in py if p[0] > midpoint[0]]\n\n        # Conquer\n        dl, pair_l = closest_pair_recursive(px[:mid], pyl)\n        dr, pair_r = closest_pair_recursive(px[mid:], pyr)\n\n        # Find minimum of two sides\n        d = min(dl, dr)\n        min_pair = pair_l if dl < dr else pair_r\n\n        # Build strip of points closer than d to dividing line\n        strip = [p for p in py if abs(p[0] - midpoint[0]) < d]\n\n        # Check strip for closer pairs\n        for i in range(len(strip)):\n            j = i + 1\n            while j < len(strip) and (strip[j][1] - strip[i][1]) < d:\n                dist = distance(strip[i], strip[j])\n                if dist < d:\n                    d = dist\n                    min_pair = (strip[i], strip[j])\n                j += 1\n\n        return d, min_pair\n\n    # Sort points by x and y coordinates\n    px = sorted(points, key=lambda p: p[0])\n    py = sorted(points, key=lambda p: p[1])\n\n    dist, pair = closest_pair_recursive(px, py)\n    return (dist, pair[0], pair[1])",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 1), (2, 2), (5, 5), (6, 6)]",
        "isHidden": false,
        "description": "Points along a diagonal"
      },
      {
        "input": "points = [(0, 0), (7, 6), (2, 20), (12, 5), (16, 16), (5, 8)]",
        "isHidden": false,
        "description": "Random scattered points"
      },
      {
        "input": "points = [(1, 1), (1, 2), (3, 4), (5, 6)]",
        "isHidden": false,
        "description": "Small set with vertical pair"
      }
    ],
    "hints": [
      "Sort points by x-coordinate and y-coordinate (maintain both orderings)",
      "Divide points by x-coordinate into two halves",
      "Recursively find closest pairs in each half",
      "Check points in the middle strip (within d of dividing line)",
      "For each point in strip, only check next 7 points (geometric property)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Line Segment Intersection",
    "difficulty": 3,
    "description": "Check if two line segments intersect.",
    "starterCode": "def segments_intersect(p1, q1, p2, q2):\n    \"\"\"\n    Check if line segment p1q1 intersects with line segment p2q2.\n\n    Args:\n        p1, q1: Endpoints of first segment (tuples (x, y)).\n        p2, q2: Endpoints of second segment (tuples (x, y)).\n\n    Returns:\n        bool: True if segments intersect.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def segments_intersect(p1, q1, p2, q2):\n    \"\"\"\n    Check if line segment p1q1 intersects with line segment p2q2.\n\n    Args:\n        p1, q1: Endpoints of first segment (tuples (x, y)).\n        p2, q2: Endpoints of second segment (tuples (x, y)).\n\n    Returns:\n        bool: True if segments intersect.\n    \"\"\"\n    def orientation(p, q, r):\n        \"\"\"\n        Find orientation of ordered triplet (p, q, r).\n        Returns:\n            0: Collinear\n            1: Clockwise\n            2: Counterclockwise\n        \"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val) < 1e-9:\n            return 0\n        return 1 if val > 0 else 2\n\n    def on_segment(p, q, r):\n        \"\"\"Check if point q lies on segment pr (given they are collinear).\"\"\"\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special cases (collinear points)\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False",
    "testCases": [
      {
        "input": "p1 = (0, 0), q1 = (10, 10), p2 = (0, 10), q2 = (10, 0)",
        "isHidden": false,
        "description": "Intersecting segments forming an X"
      },
      {
        "input": "p1 = (0, 0), q1 = (5, 5), p2 = (0, 5), q2 = (5, 0)",
        "isHidden": false,
        "description": "Non-intersecting parallel-ish segments"
      },
      {
        "input": "p1 = (0, 0), q1 = (10, 0), p2 = (5, 0), q2 = (15, 0)",
        "isHidden": false,
        "description": "Collinear overlapping segments"
      }
    ],
    "hints": [
      "Use orientation test to check if points are clockwise, counterclockwise, or collinear",
      "Two segments intersect if orientations differ on both sides",
      "Handle special cases: collinear points",
      "Check if collinear point lies on segment",
      "Orientation test: sign of cross product"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Point in Polygon",
    "difficulty": 3,
    "description": "Determine if a point lies inside a polygon using ray casting algorithm.",
    "starterCode": "def point_in_polygon(point, polygon):\n    \"\"\"\n    Check if point is inside polygon.\n\n    Args:\n        point: Tuple (x, y).\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if point is inside polygon.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def point_in_polygon(point, polygon):\n    \"\"\"\n    Check if point is inside polygon.\n\n    Args:\n        point: Tuple (x, y).\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if point is inside polygon.\n    \"\"\"\n    x, y = point\n    n = len(polygon)\n    inside = False\n\n    p1x, p1y = polygon[0]\n    for i in range(1, n + 1):\n        p2x, p2y = polygon[i % n]\n\n        # Check if ray from point crosses edge\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n\n        p1x, p1y = p2x, p2y\n\n    return inside",
    "testCases": [
      {
        "input": "point = (5, 5), polygon = [(0, 0), (10, 0), (10, 10), (0, 10)]",
        "isHidden": false,
        "description": "Point inside square"
      },
      {
        "input": "point = (15, 5), polygon = [(0, 0), (10, 0), (10, 10), (0, 10)]",
        "isHidden": false,
        "description": "Point outside square"
      },
      {
        "input": "point = (2, 2), polygon = [(0, 0), (4, 0), (4, 4), (2, 6), (0, 4)]",
        "isHidden": false,
        "description": "Point in non-convex polygon"
      }
    ],
    "hints": [
      "Ray casting algorithm: cast ray from point to infinity",
      "Count how many edges the ray crosses",
      "Odd number of crossings = inside, even = outside",
      "Handle edge cases: ray passing through vertex",
      "Works for both convex and non-convex polygons"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Jarvis March (Gift Wrapping)",
    "difficulty": 3,
    "description": "Implement Jarvis march algorithm for convex hull in O(nh) time.",
    "starterCode": "def jarvis_march(points):\n    \"\"\"\n    Find convex hull using Jarvis march (gift wrapping) algorithm.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        list: Points on convex hull in counterclockwise order.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def jarvis_march(points):\n    \"\"\"\n    Find convex hull using Jarvis march (gift wrapping) algorithm.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        list: Points on convex hull in counterclockwise order.\n    \"\"\"\n    n = len(points)\n    if n < 3:\n        return points\n\n    def orientation(p, q, r):\n        \"\"\"Return orientation: 0=collinear, 1=clockwise, 2=counterclockwise.\"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val) < 1e-9:\n            return 0\n        return 1 if val > 0 else 2\n\n    # Find leftmost point\n    leftmost = min(range(n), key=lambda i: (points[i][0], points[i][1]))\n\n    hull = []\n    current = leftmost\n\n    while True:\n        hull.append(points[current])\n\n        # Find most counterclockwise point from current\n        next_point = (current + 1) % n\n        for i in range(n):\n            if orientation(points[current], points[i], points[next_point]) == 2:\n                next_point = i\n\n        current = next_point\n\n        # Stop when we return to starting point\n        if current == leftmost:\n            break\n\n    return hull",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0), (1, 0.5)]",
        "isHidden": false,
        "description": "Points with some interior"
      },
      {
        "input": "points = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Square"
      },
      {
        "input": "points = [(0, 0), (2, 1), (1, 2), (0, 2)]",
        "isHidden": false,
        "description": "Irregular quadrilateral"
      }
    ],
    "hints": [
      "Start from leftmost point (guaranteed to be on hull)",
      "At each step, find most counterclockwise point",
      "Use orientation test to compare angles",
      "Wrap around the hull like wrapping a gift",
      "Stop when returning to start point",
      "Time complexity: O(nh) where h is hull size"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Area of Polygon",
    "difficulty": 1,
    "description": "Calculate the area of a polygon using the shoelace formula.",
    "starterCode": "def polygon_area(vertices):\n    \"\"\"\n    Calculate area of polygon using shoelace formula.\n\n    Args:\n        vertices: List of (x, y) tuples in order (clockwise or counterclockwise).\n\n    Returns:\n        float: Area of polygon.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def polygon_area(vertices):\n    \"\"\"\n    Calculate area of polygon using shoelace formula.\n\n    Args:\n        vertices: List of (x, y) tuples in order (clockwise or counterclockwise).\n\n    Returns:\n        float: Area of polygon.\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n\n    return abs(area) / 2.0",
    "testCases": [
      {
        "input": "vertices = [(0, 0), (4, 0), (4, 3), (0, 3)]",
        "isHidden": false,
        "description": "Rectangle: 4 x 3 = 12"
      },
      {
        "input": "vertices = [(0, 0), (2, 0), (1, 2)]",
        "isHidden": false,
        "description": "Triangle: area = 2"
      },
      {
        "input": "vertices = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Unit square: area = 1"
      }
    ],
    "hints": [
      "Shoelace formula: sum of (x_i * y_{i+1} - x_{i+1} * y_i)",
      "Divide result by 2 and take absolute value",
      "Works for any simple polygon (no self-intersections)",
      "Order of vertices matters for sign, but we take abs",
      "Also known as surveyor's formula"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Convex Polygon Check",
    "difficulty": 2,
    "description": "Determine if a polygon is convex.",
    "starterCode": "def is_convex(polygon):\n    \"\"\"\n    Check if polygon is convex.\n\n    Args:\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if polygon is convex.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def is_convex(polygon):\n    \"\"\"\n    Check if polygon is convex.\n\n    Args:\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if polygon is convex.\n    \"\"\"\n    def cross_product_sign(o, a, b):\n        \"\"\"Return sign of cross product of vectors OA and OB.\"\"\"\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    n = len(polygon)\n    if n < 3:\n        return False\n\n    sign = None\n\n    for i in range(n):\n        o = polygon[i]\n        a = polygon[(i + 1) % n]\n        b = polygon[(i + 2) % n]\n\n        cross = cross_product_sign(o, a, b)\n\n        if abs(cross) > 1e-9:  # Not collinear\n            if sign is None:\n                sign = cross > 0\n            elif (cross > 0) != sign:\n                return False  # Sign changed = not convex\n\n    return True",
    "testCases": [
      {
        "input": "polygon = [(0, 0), (2, 0), (2, 2), (0, 2)]",
        "isHidden": false,
        "description": "Square - convex"
      },
      {
        "input": "polygon = [(0, 0), (2, 0), (2, 2), (1, 1), (0, 2)]",
        "isHidden": false,
        "description": "Non-convex polygon (has reflex angle)"
      },
      {
        "input": "polygon = [(0, 0), (1, 0), (2, 1), (1, 2), (0, 1)]",
        "isHidden": false,
        "description": "Convex pentagon"
      }
    ],
    "hints": [
      "For each consecutive triple of vertices, compute cross product",
      "If all cross products have same sign, polygon is convex",
      "If signs differ, there is a reflex angle (not convex)",
      "Cross product tells if turn is left or right",
      "Ignore collinear points (cross product = 0)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "2D Range Query",
    "difficulty": 3,
    "description": "Find all points within a rectangular range.",
    "starterCode": "def range_query(points, rect):\n    \"\"\"\n    Find all points within rectangular range.\n\n    Args:\n        points: List of (x, y) tuples.\n        rect: Tuple (x_min, y_min, x_max, y_max).\n\n    Returns:\n        list: Points inside rectangle.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def range_query(points, rect):\n    \"\"\"\n    Find all points within rectangular range.\n\n    Args:\n        points: List of (x, y) tuples.\n        rect: Tuple (x_min, y_min, x_max, y_max).\n\n    Returns:\n        list: Points inside rectangle.\n    \"\"\"\n    x_min, y_min, x_max, y_max = rect\n    result = []\n\n    for x, y in points:\n        if x_min <= x <= x_max and y_min <= y <= y_max:\n            result.append((x, y))\n\n    return result",
    "testCases": [
      {
        "input": "points = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], rect = (2, 2, 4, 4)",
        "isHidden": false,
        "description": "Points in and out of range"
      },
      {
        "input": "points = [(0, 0), (10, 10), (5, 5)], rect = (3, 3, 7, 7)",
        "isHidden": false,
        "description": "Single point in range"
      },
      {
        "input": "points = [(1, 1), (2, 2), (3, 3)], rect = (5, 5, 10, 10)",
        "isHidden": false,
        "description": "No points in range"
      }
    ],
    "hints": [
      "Simple approach: check each point individually",
      "Point (x, y) is inside if x_min ≤ x ≤ x_max and y_min ≤ y ≤ y_max",
      "Time complexity: O(n) for n points",
      "For better performance, use data structures like kd-tree or range tree",
      "This is orthogonal range searching problem"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Line Sweep - Rectangle Intersection",
    "difficulty": 4,
    "description": "Find if any pair of axis-aligned rectangles intersect using line sweep.",
    "starterCode": "def rectangles_intersect(rectangles):\n    \"\"\"\n    Check if any two rectangles intersect using line sweep.\n\n    Args:\n        rectangles: List of rectangles [(x1, y1, x2, y2), ...] where (x1,y1) is bottom-left.\n\n    Returns:\n        bool: True if any two rectangles intersect.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def rectangles_intersect(rectangles):\n    \"\"\"\n    Check if any two rectangles intersect using line sweep.\n\n    Args:\n        rectangles: List of rectangles [(x1, y1, x2, y2), ...] where (x1,y1) is bottom-left.\n\n    Returns:\n        bool: True if any two rectangles intersect.\n    \"\"\"\n    # Create events: (x, type, rect_index, y1, y2)\n    # type: 0=start, 1=end\n    events = []\n\n    for i, (x1, y1, x2, y2) in enumerate(rectangles):\n        events.append((x1, 0, i, y1, y2))  # Start\n        events.append((x2, 1, i, y1, y2))  # End\n\n    # Sort by x-coordinate\n    events.sort()\n\n    # Active rectangles: dict of index -> (y1, y2)\n    active = {}\n\n    for x, event_type, idx, y1, y2 in events:\n        if event_type == 0:  # Start\n            # Check if new rectangle intersects with any active\n            for other_idx, (other_y1, other_y2) in active.items():\n                # Check y-interval overlap\n                if not (y2 < other_y1 or y1 > other_y2):\n                    return True\n            active[idx] = (y1, y2)\n        else:  # End\n            if idx in active:\n                del active[idx]\n\n    return False",
    "testCases": [
      {
        "input": "rectangles = [(0, 0, 2, 2), (1, 1, 3, 3)]",
        "isHidden": false,
        "description": "Two overlapping rectangles"
      },
      {
        "input": "rectangles = [(0, 0, 1, 1), (2, 2, 3, 3)]",
        "isHidden": false,
        "description": "Two non-overlapping rectangles"
      },
      {
        "input": "rectangles = [(0, 0, 2, 2), (1, 0, 3, 2), (2, 0, 4, 2)]",
        "isHidden": false,
        "description": "Multiple rectangles with overlaps"
      }
    ],
    "hints": [
      "Sweep vertical line from left to right",
      "Maintain set of active rectangles (those intersected by sweep line)",
      "When rectangle starts, check if it overlaps with active rectangles",
      "Two rectangles overlap if x-intervals and y-intervals both overlap",
      "Events: rectangle start and end",
      "Check y-interval overlap: not (y1_max < y2_min or y1_min > y2_max)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Polygon Triangulation",
    "difficulty": 5,
    "description": "Triangulate a simple polygon using ear clipping method.",
    "starterCode": "def triangulate_polygon(polygon):\n    \"\"\"\n    Triangulate simple polygon using ear clipping.\n\n    Args:\n        polygon: List of vertices [(x1, y1), ...] in counterclockwise order.\n\n    Returns:\n        list: List of triangles [(p1, p2, p3), ...].\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def triangulate_polygon(polygon):\n    \"\"\"\n    Triangulate simple polygon using ear clipping.\n\n    Args:\n        polygon: List of vertices [(x1, y1), ...] in counterclockwise order.\n\n    Returns:\n        list: List of triangles [(p1, p2, p3), ...].\n    \"\"\"\n    def cross_product(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    def point_in_triangle(p, a, b, c):\n        \"\"\"Check if point p is inside triangle abc.\"\"\"\n        v0 = (c[0] - a[0], c[1] - a[1])\n        v1 = (b[0] - a[0], b[1] - a[1])\n        v2 = (p[0] - a[0], p[1] - a[1])\n\n        dot00 = v0[0] * v0[0] + v0[1] * v0[1]\n        dot01 = v0[0] * v1[0] + v0[1] * v1[1]\n        dot02 = v0[0] * v2[0] + v0[1] * v2[1]\n        dot11 = v1[0] * v1[0] + v1[1] * v1[1]\n        dot12 = v1[0] * v2[0] + v1[1] * v2[1]\n\n        inv_denom = 1 / (dot00 * dot11 - dot01 * dot01)\n        u = (dot11 * dot02 - dot01 * dot12) * inv_denom\n        v = (dot00 * dot12 - dot01 * dot02) * inv_denom\n\n        return (u >= 0) and (v >= 0) and (u + v <= 1)\n\n    def is_ear(polygon, i):\n        \"\"\"Check if vertex i forms an ear.\"\"\"\n        n = len(polygon)\n        prev = polygon[(i - 1) % n]\n        curr = polygon[i]\n        next = polygon[(i + 1) % n]\n\n        # Check if convex\n        if cross_product(prev, curr, next) <= 0:\n            return False\n\n        # Check if no other vertex is inside triangle\n        for j in range(n):\n            if j == i or j == (i - 1) % n or j == (i + 1) % n:\n                continue\n            if point_in_triangle(polygon[j], prev, curr, next):\n                return False\n\n        return True\n\n    triangles = []\n    vertices = list(polygon)\n\n    while len(vertices) > 3:\n        n = len(vertices)\n        ear_found = False\n\n        for i in range(n):\n            if is_ear(vertices, i):\n                # Cut off ear\n                prev = vertices[(i - 1) % n]\n                curr = vertices[i]\n                next = vertices[(i + 1) % n]\n\n                triangles.append((prev, curr, next))\n                vertices.pop(i)\n                ear_found = True\n                break\n\n        if not ear_found:\n            break  # Failed to triangulate\n\n    if len(vertices) == 3:\n        triangles.append(tuple(vertices))\n\n    return triangles",
    "testCases": [
      {
        "input": "polygon = [(0, 0), (4, 0), (4, 3), (0, 3)]",
        "isHidden": false,
        "description": "Rectangle - 2 triangles"
      },
      {
        "input": "polygon = [(0, 0), (2, 0), (3, 2), (1, 3), (0, 2)]",
        "isHidden": false,
        "description": "Pentagon - 3 triangles"
      },
      {
        "input": "polygon = [(0, 0), (1, 0), (1, 1)]",
        "isHidden": false,
        "description": "Already a triangle"
      }
    ],
    "hints": [
      "Ear clipping: find convex vertex (ear) and cut it off",
      "Ear: three consecutive vertices where triangle contains no other vertices",
      "Check if vertex is convex using cross product",
      "For each convex vertex, check if triangle contains other vertices",
      "Repeat until only one triangle remains",
      "Time complexity: O(n^2) for simple ear clipping"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Rotating Calipers - Diameter",
    "difficulty": 4,
    "description": "Find the diameter of a convex polygon using rotating calipers.",
    "starterCode": "def convex_polygon_diameter(polygon):\n    \"\"\"\n    Find diameter (maximum distance between any two vertices) of convex polygon.\n\n    Args:\n        polygon: List of vertices in counterclockwise order (convex hull).\n\n    Returns:\n        tuple: (max_distance, point1, point2)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def convex_polygon_diameter(polygon):\n    \"\"\"\n    Find diameter (maximum distance between any two vertices) of convex polygon.\n\n    Args:\n        polygon: List of vertices in counterclockwise order (convex hull).\n\n    Returns:\n        tuple: (max_distance, point1, point2)\n    \"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    n = len(polygon)\n    if n < 2:\n        return 0, None, None\n\n    # Find initial antipodal pair\n    k = 1\n    while distance(polygon[k + 1], polygon[0]) > distance(polygon[k], polygon[0]):\n        k += 1\n\n    max_dist = 0\n    best_pair = (polygon[0], polygon[k])\n\n    i, j = 0, k\n\n    # Rotate calipers\n    for _ in range(n):\n        # Check current pair\n        dist = distance(polygon[i], polygon[j])\n        if dist > max_dist:\n            max_dist = dist\n            best_pair = (polygon[i], polygon[j])\n\n        # Rotate caliper\n        # Check which edge to advance along\n        i_next = (i + 1) % n\n        j_next = (j + 1) % n\n\n        # Vector from i to i_next\n        v1 = (polygon[i_next][0] - polygon[i][0], polygon[i_next][1] - polygon[i][1])\n        # Vector from j to j_next\n        v2 = (polygon[j_next][0] - polygon[j][0], polygon[j_next][1] - polygon[j][1])\n\n        # Cross product determines which to advance\n        cross = v1[0] * v2[1] - v1[1] * v2[0]\n\n        if cross < 0:\n            i = i_next\n        else:\n            j = j_next\n\n    return max_dist, best_pair[0], best_pair[1]",
    "testCases": [
      {
        "input": "polygon = [(0, 0), (4, 0), (4, 3), (0, 3)]",
        "isHidden": false,
        "description": "Rectangle - diameter is diagonal"
      },
      {
        "input": "polygon = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Unit square"
      },
      {
        "input": "polygon = [(0, 0), (3, 0), (3, 3), (1, 4), (0, 3)]",
        "isHidden": false,
        "description": "Convex pentagon"
      }
    ],
    "hints": [
      "Rotating calipers: rotate two parallel lines around convex hull",
      "Diameter is between antipodal pair of vertices",
      "Start with initial antipodal pair",
      "Rotate calipers by advancing along edges",
      "Check distance at each step",
      "O(n) time for convex polygon"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Voronoi Cell",
    "difficulty": 5,
    "description": "Find which site a query point belongs to in Voronoi diagram (nearest neighbor).",
    "starterCode": "def nearest_site(query, sites):\n    \"\"\"\n    Find nearest site to query point (Voronoi cell membership).\n\n    Args:\n        query: Query point (x, y).\n        sites: List of site points [(x1, y1), (x2, y2), ...].\n\n    Returns:\n        tuple: (nearest_site, distance)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def nearest_site(query, sites):\n    \"\"\"\n    Find nearest site to query point (Voronoi cell membership).\n\n    Args:\n        query: Query point (x, y).\n        sites: List of site points [(x1, y1), (x2, y2), ...].\n\n    Returns:\n        tuple: (nearest_site, distance)\n    \"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    if not sites:\n        return None, float('inf')\n\n    min_dist = float('inf')\n    nearest = None\n\n    for site in sites:\n        dist = distance(query, site)\n        if dist < min_dist:\n            min_dist = dist\n            nearest = site\n\n    return nearest, min_dist",
    "testCases": [
      {
        "input": "query = (2, 2), sites = [(0, 0), (5, 5), (0, 5)]",
        "isHidden": false,
        "description": "Find nearest site"
      },
      {
        "input": "query = (1, 1), sites = [(0, 0), (2, 2), (0, 2)]",
        "isHidden": false,
        "description": "Query near one site"
      },
      {
        "input": "query = (5, 5), sites = [(0, 0), (10, 10)]",
        "isHidden": false,
        "description": "Query equidistant to two sites"
      }
    ],
    "hints": [
      "Voronoi cell: region of points closest to a particular site",
      "Simple approach: compute distance to all sites",
      "Return site with minimum distance",
      "O(n) time for n sites",
      "For faster queries, preprocess Voronoi diagram",
      "This is nearest neighbor search"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Circle-Circle Intersection",
    "difficulty": 2,
    "description": "Find intersection points of two circles.",
    "starterCode": "def circle_intersection(c1, r1, c2, r2):\n    \"\"\"\n    Find intersection points of two circles.\n\n    Args:\n        c1, c2: Centers (x, y) of circles.\n        r1, r2: Radii of circles.\n\n    Returns:\n        list: Intersection points [(x1, y1), (x2, y2)] or empty if no intersection.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def circle_intersection(c1, r1, c2, r2):\n    \"\"\"\n    Find intersection points of two circles.\n\n    Args:\n        c1, c2: Centers (x, y) of circles.\n        r1, r2: Radii of circles.\n\n    Returns:\n        list: Intersection points [(x1, y1), (x2, y2)] or empty if no intersection.\n    \"\"\"\n    import math\n\n    x1, y1 = c1\n    x2, y2 = c2\n\n    # Distance between centers\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    # Check if circles intersect\n    if d > r1 + r2:  # Too far apart\n        return []\n    if d < abs(r1 - r2):  # One inside other\n        return []\n    if d == 0 and r1 == r2:  # Same circle\n        return []  # Infinite intersections\n\n    # Calculate intersection points\n    a = (r1**2 - r2**2 + d**2) / (2 * d)\n    h = math.sqrt(r1**2 - a**2)\n\n    # Point on line between centers\n    px = x1 + a * (x2 - x1) / d\n    py = y1 + a * (y2 - y1) / d\n\n    # Intersection points\n    ix1 = px + h * (y2 - y1) / d\n    iy1 = py - h * (x2 - x1) / d\n\n    ix2 = px - h * (y2 - y1) / d\n    iy2 = py + h * (x2 - x1) / d\n\n    if abs(ix1 - ix2) < 1e-9 and abs(iy1 - iy2) < 1e-9:\n        return [(ix1, iy1)]  # Tangent (one point)\n    else:\n        return [(ix1, iy1), (ix2, iy2)]",
    "testCases": [
      {
        "input": "c1 = (0, 0), r1 = 5, c2 = (5, 0), r2 = 5",
        "isHidden": false,
        "description": "Two intersecting circles"
      },
      {
        "input": "c1 = (0, 0), r1 = 3, c2 = (10, 0), r2 = 3",
        "isHidden": false,
        "description": "Non-intersecting circles"
      },
      {
        "input": "c1 = (0, 0), r1 = 5, c2 = (5, 0), r2 = 0",
        "isHidden": false,
        "description": "Circle and point"
      }
    ],
    "hints": [
      "Check distance between centers vs sum and difference of radii",
      "If d > r1 + r2: circles too far apart",
      "If d < |r1 - r2|: one circle inside other",
      "Use geometry to find intersection points",
      "Find point on line between centers, then perpendicular offset",
      "Handle special cases: tangent (one point), no intersection"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Smallest Enclosing Circle",
    "difficulty": 5,
    "description": "Find smallest circle that encloses all points using Welzl's algorithm.",
    "starterCode": "def smallest_enclosing_circle(points):\n    \"\"\"\n    Find smallest circle that encloses all points.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        tuple: (center, radius) where center is (x, y).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def smallest_enclosing_circle(points):\n    \"\"\"\n    Find smallest circle that encloses all points.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        tuple: (center, radius) where center is (x, y).\n    \"\"\"\n    import random\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def circle_from_2_points(p1, p2):\n        \"\"\"Circle with diameter p1-p2.\"\"\"\n        center = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)\n        radius = distance(p1, p2) / 2\n        return center, radius\n\n    def circle_from_3_points(p1, p2, p3):\n        \"\"\"Circumcircle of three points.\"\"\"\n        ax, ay = p1\n        bx, by = p2\n        cx, cy = p3\n\n        d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n        if abs(d) < 1e-9:\n            return circle_from_2_points(p1, p2)\n\n        ux = ((ax**2 + ay**2) * (by - cy) + (bx**2 + by**2) * (cy - ay) + (cx**2 + cy**2) * (ay - by)) / d\n        uy = ((ax**2 + ay**2) * (cx - bx) + (bx**2 + by**2) * (ax - cx) + (cx**2 + cy**2) * (bx - ax)) / d\n\n        center = (ux, uy)\n        radius = distance(center, p1)\n        return center, radius\n\n    def welzl_helper(points, boundary, n):\n        \"\"\"Recursive helper for Welzl's algorithm.\"\"\"\n        if n == 0 or len(boundary) == 3:\n            if len(boundary) == 0:\n                return ((0, 0), 0)\n            elif len(boundary) == 1:\n                return (boundary[0], 0)\n            elif len(boundary) == 2:\n                return circle_from_2_points(boundary[0], boundary[1])\n            else:\n                return circle_from_3_points(boundary[0], boundary[1], boundary[2])\n\n        # Pick random point\n        idx = random.randint(0, n - 1)\n        p = points[idx]\n\n        # Swap with last\n        points[idx], points[n - 1] = points[n - 1], points[idx]\n\n        # Recursively find circle without p\n        circle = welzl_helper(points, boundary, n - 1)\n        center, radius = circle\n\n        # If p is inside circle, return it\n        if distance(center, p) <= radius + 1e-9:\n            return circle\n\n        # Otherwise, p must be on boundary\n        return welzl_helper(points, boundary + [p], n - 1)\n\n    if not points:\n        return ((0, 0), 0)\n\n    points_copy = points[:]\n    return welzl_helper(points_copy, [], len(points_copy))",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 0), (0, 1)]",
        "isHidden": false,
        "description": "Three points forming triangle"
      },
      {
        "input": "points = [(0, 0), (2, 0), (1, 1)]",
        "isHidden": false,
        "description": "Triangle with different shape"
      },
      {
        "input": "points = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Square"
      }
    ],
    "hints": [
      "Welzl's algorithm: randomized incremental approach",
      "Key insight: optimal circle has 2 or 3 points on boundary",
      "Process points randomly",
      "If point outside current circle, it must be on boundary",
      "Recursively find circle with point on boundary",
      "Expected O(n) time with randomization"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Bentley-Ottmann Line Sweep",
    "difficulty": 5,
    "description": "Find all intersection points of line segments using Bentley-Ottmann algorithm (simplified).",
    "starterCode": "def find_intersections(segments):\n    \"\"\"\n    Find all intersection points of line segments.\n\n    Args:\n        segments: List of segments [((x1, y1), (x2, y2)), ...].\n\n    Returns:\n        list: Intersection points.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def find_intersections(segments):\n    \"\"\"\n    Find all intersection points of line segments.\n\n    Args:\n        segments: List of segments [((x1, y1), (x2, y2)), ...].\n\n    Returns:\n        list: Intersection points.\n    \"\"\"\n    def segments_intersect_point(seg1, seg2):\n        \"\"\"Find intersection point of two segments if exists.\"\"\"\n        (x1, y1), (x2, y2) = seg1\n        (x3, y3), (x4, y4) = seg2\n\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n\n        if abs(denom) < 1e-9:\n            return None  # Parallel or collinear\n\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            # Intersection point\n            px = x1 + t * (x2 - x1)\n            py = y1 + t * (y2 - y1)\n            return (px, py)\n\n        return None\n\n    # Simplified O(n^2) approach: check all pairs\n    intersections = []\n\n    for i in range(len(segments)):\n        for j in range(i + 1, len(segments)):\n            point = segments_intersect_point(segments[i], segments[j])\n            if point:\n                # Check if already added (avoid duplicates)\n                is_duplicate = False\n                for p in intersections:\n                    if abs(p[0] - point[0]) < 1e-9 and abs(p[1] - point[1]) < 1e-9:\n                        is_duplicate = True\n                        break\n                if not is_duplicate:\n                    intersections.append(point)\n\n    return intersections",
    "testCases": [
      {
        "input": "segments = [((0, 0), (2, 2)), ((0, 2), (2, 0))]",
        "isHidden": false,
        "description": "Two intersecting segments (X pattern)"
      },
      {
        "input": "segments = [((0, 0), (1, 1)), ((2, 2), (3, 3)), ((0, 1), (1, 0))]",
        "isHidden": false,
        "description": "Multiple segments with one intersection"
      },
      {
        "input": "segments = [((0, 0), (1, 0)), ((2, 0), (3, 0))]",
        "isHidden": false,
        "description": "Non-intersecting segments"
      }
    ],
    "hints": [
      "Bentley-Ottmann: sweep line + event queue + status structure",
      "This simplified version is O(n^2) checking all pairs",
      "For true O((n+k) log n): use sweep line with balanced BST",
      "Events: segment endpoints and intersections",
      "Status: segments currently intersecting sweep line",
      "Full algorithm is complex; simplified version still useful"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "KD-Tree Nearest Neighbor",
    "difficulty": 4,
    "description": "Find nearest neighbor using KD-tree for efficient spatial queries.",
    "starterCode": "class KDNode:\n    def __init__(self, point, left=None, right=None):\n        self.point = point\n        self.left = left\n        self.right = right\n\ndef build_kdtree(points, depth=0):\n    \"\"\"Build KD-tree from points.\"\"\"\n    # Your code here\n    pass\n\ndef nearest_neighbor(root, query, depth=0):\n    \"\"\"Find nearest neighbor to query point in KD-tree.\"\"\"\n    # Your code here\n    pass",
    "solution": "class KDNode:\n    def __init__(self, point, left=None, right=None):\n        self.point = point\n        self.left = left\n        self.right = right\n\ndef build_kdtree(points, depth=0):\n    \"\"\"Build KD-tree from points.\"\"\"\n    if not points:\n        return None\n\n    k = len(points[0])  # Dimensions\n    axis = depth % k\n\n    # Sort and choose median\n    points.sort(key=lambda p: p[axis])\n    median = len(points) // 2\n\n    # Create node and recursively build subtrees\n    return KDNode(\n        point=points[median],\n        left=build_kdtree(points[:median], depth + 1),\n        right=build_kdtree(points[median + 1:], depth + 1)\n    )\n\ndef nearest_neighbor(root, query, depth=0, best=None):\n    \"\"\"Find nearest neighbor to query point in KD-tree.\"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt(sum((a - b)**2 for a, b in zip(p1, p2)))\n\n    if root is None:\n        return best\n\n    k = len(query)\n    axis = depth % k\n\n    # Update best if current node is closer\n    dist = distance(root.point, query)\n    if best is None or dist < distance(best, query):\n        best = root.point\n\n    # Determine which subtree to search first\n    if query[axis] < root.point[axis]:\n        near, far = root.left, root.right\n    else:\n        near, far = root.right, root.left\n\n    # Search near subtree\n    best = nearest_neighbor(near, query, depth + 1, best)\n\n    # Check if we need to search far subtree\n    if abs(query[axis] - root.point[axis]) < distance(best, query):\n        best = nearest_neighbor(far, query, depth + 1, best)\n\n    return best",
    "testCases": [
      {
        "input": "points = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)], query = (9, 2)",
        "isHidden": false,
        "description": "Find nearest neighbor in 2D"
      },
      {
        "input": "points = [(1, 1), (2, 2), (3, 3), (4, 4)], query = (2.5, 2.5)",
        "isHidden": false,
        "description": "Query between points"
      },
      {
        "input": "points = [(0, 0), (10, 10)], query = (5, 5)",
        "isHidden": false,
        "description": "Two points, query in middle"
      }
    ],
    "hints": [
      "KD-tree: binary space partitioning tree",
      "Each level splits along different axis (alternating)",
      "Build tree by sorting along axis and choosing median",
      "For nearest neighbor: recursively search closer subtree first",
      "Prune far subtree if impossible to contain closer point",
      "Average case: O(log n), worst case: O(n)"
    ],
    "language": "python"
  }
]
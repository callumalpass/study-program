[
  {
    "id": "cs406-quiz-1-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-1",
    "title": "AI Fundamentals - Part 1",
    "questions": [
      {
        "id": "cs406-q1",
        "type": "multiple_choice",
        "prompt": "What is the Turing test designed to evaluate?",
        "options": [
          "Whether a machine can think like a human based on behavioral equivalence",
          "The processing speed of a computer",
          "The memory capacity of an AI system",
          "Whether a machine has consciousness"
        ],
        "correctAnswer": "Whether a machine can think like a human based on behavioral equivalence",
        "explanation": "The Turing test evaluates whether a machine can exhibit behavior indistinguishable from a human in conversation, focusing on external behavior rather than internal processes."
      },
      {
        "id": "cs406-q2",
        "type": "multiple_choice",
        "prompt": "In the Chinese Room argument, what does Searle argue?",
        "options": [
          "Syntax alone is neither sufficient for nor constitutive of semantics",
          "Computers can achieve true understanding through symbol manipulation",
          "Natural language processing is impossible",
          "The Turing test is the best measure of intelligence"
        ],
        "correctAnswer": "Syntax alone is neither sufficient for nor constitutive of semantics",
        "explanation": "Searle argues that manipulating symbols according to rules (syntax) does not create genuine understanding (semantics), challenging strong AI claims."
      },
      {
        "id": "cs406-q3",
        "type": "multiple_choice",
        "prompt": "What characterizes a rational agent?",
        "options": [
          "It maximizes expected performance measure given percept sequence and knowledge",
          "It always makes perfect decisions",
          "It thinks like a human",
          "It never makes mistakes"
        ],
        "correctAnswer": "It maximizes expected performance measure given percept sequence and knowledge",
        "explanation": "A rational agent does the best it can with available information to maximize its performance measure, not necessarily achieving perfect outcomes."
      },
      {
        "id": "cs406-q4",
        "type": "multiple_choice",
        "prompt": "Which environment property means the next state depends only on current state and action?",
        "options": [
          "Deterministic",
          "Observable",
          "Episodic",
          "Static"
        ],
        "correctAnswer": "Deterministic",
        "explanation": "In a deterministic environment, the next state is completely determined by the current state and action executed, with no randomness."
      },
      {
        "id": "cs406-q5",
        "type": "multiple_choice",
        "prompt": "What is the main advantage of a utility-based agent over a goal-based agent?",
        "options": [
          "It can handle trade-offs between conflicting objectives",
          "It requires less computation",
          "It doesnt need a model of the world",
          "It always finds optimal solutions"
        ],
        "correctAnswer": "It can handle trade-offs between conflicting objectives",
        "explanation": "Utility-based agents use utility functions to compare states, enabling rational trade-offs between multiple objectives rather than binary goal achievement."
      }
    ]
  },
  {
    "id": "cs406-quiz-1-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-1",
    "title": "AI Fundamentals - Part 2",
    "questions": [
      {
        "id": "cs406-q3",
        "type": "multiple_choice",
        "prompt": "What characterizes a rational agent?",
        "options": [
          "It maximizes expected performance measure given percept sequence and knowledge",
          "It always makes perfect decisions",
          "It thinks like a human",
          "It never makes mistakes"
        ],
        "correctAnswer": "It maximizes expected performance measure given percept sequence and knowledge",
        "explanation": "A rational agent does the best it can with available information to maximize its performance measure, not necessarily achieving perfect outcomes."
      },
      {
        "id": "cs406-q4",
        "type": "multiple_choice",
        "prompt": "Which environment property means the next state depends only on current state and action?",
        "options": [
          "Deterministic",
          "Observable",
          "Episodic",
          "Static"
        ],
        "correctAnswer": "Deterministic",
        "explanation": "In a deterministic environment, the next state is completely determined by the current state and action executed, with no randomness."
      },
      {
        "id": "cs406-q5",
        "type": "multiple_choice",
        "prompt": "What is the main advantage of a utility-based agent over a goal-based agent?",
        "options": [
          "It can handle trade-offs between conflicting objectives",
          "It requires less computation",
          "It doesnt need a model of the world",
          "It always finds optimal solutions"
        ],
        "correctAnswer": "It can handle trade-offs between conflicting objectives",
        "explanation": "Utility-based agents use utility functions to compare states, enabling rational trade-offs between multiple objectives rather than binary goal achievement."
      }
    ]
  },
  {
    "id": "cs406-quiz-1-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-1",
    "title": "AI Ethics and Applications",
    "questions": [
      {
        "id": "cs406-q1",
        "type": "multiple_choice",
        "prompt": "What is the Turing test designed to evaluate?",
        "options": [
          "Whether a machine can think like a human based on behavioral equivalence",
          "The processing speed of a computer",
          "The memory capacity of an AI system",
          "Whether a machine has consciousness"
        ],
        "correctAnswer": "Whether a machine can think like a human based on behavioral equivalence",
        "explanation": "The Turing test evaluates whether a machine can exhibit behavior indistinguishable from a human in conversation, focusing on external behavior rather than internal processes."
      },
      {
        "id": "cs406-q2",
        "type": "multiple_choice",
        "prompt": "In the Chinese Room argument, what does Searle argue?",
        "options": [
          "Syntax alone is neither sufficient for nor constitutive of semantics",
          "Computers can achieve true understanding through symbol manipulation",
          "Natural language processing is impossible",
          "The Turing test is the best measure of intelligence"
        ],
        "correctAnswer": "Syntax alone is neither sufficient for nor constitutive of semantics",
        "explanation": "Searle argues that manipulating symbols according to rules (syntax) does not create genuine understanding (semantics), challenging strong AI claims."
      },
      {
        "id": "cs406-q3",
        "type": "multiple_choice",
        "prompt": "What characterizes a rational agent?",
        "options": [
          "It maximizes expected performance measure given percept sequence and knowledge",
          "It always makes perfect decisions",
          "It thinks like a human",
          "It never makes mistakes"
        ],
        "correctAnswer": "It maximizes expected performance measure given percept sequence and knowledge",
        "explanation": "A rational agent does the best it can with available information to maximize its performance measure, not necessarily achieving perfect outcomes."
      }
    ]
  },
  {
    "id": "cs406-quiz-2-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-2",
    "title": "Search Algorithms - Uninformed",
    "questions": [
      {
        "id": "cs406-q6",
        "type": "multiple_choice",
        "prompt": "What is the time complexity of breadth-first search?",
        "options": [
          "O(b^d) where b is branching factor and d is depth",
          "O(bd)",
          "O(b + d)",
          "O(d^b)"
        ],
        "correctAnswer": "O(b^d) where b is branching factor and d is depth",
        "explanation": "BFS explores all nodes at each depth level, resulting in exponential time complexity: 1 + b + b² + ... + b^d = O(b^d)."
      },
      {
        "id": "cs406-q7",
        "type": "multiple_choice",
        "prompt": "Which search algorithm has the best space complexity while maintaining completeness and optimality?",
        "options": [
          "Iterative Deepening DFS",
          "Breadth-First Search",
          "Depth-First Search",
          "Uniform-Cost Search"
        ],
        "correctAnswer": "Iterative Deepening DFS",
        "explanation": "IDDFS combines BFS completeness and optimality with DFS space efficiency O(bd), making it ideal for large state spaces."
      },
      {
        "id": "cs406-q8",
        "type": "multiple_choice",
        "prompt": "An admissible heuristic must:",
        "options": [
          "Never overestimate the cost to reach the goal",
          "Always equal the true cost",
          "Never underestimate the cost",
          "Be consistent"
        ],
        "correctAnswer": "Never overestimate the cost to reach the goal",
        "explanation": "An admissible heuristic never overestimates h*(n), ensuring A* finds optimal solutions. Consistency is stronger but not required for optimality with tree search."
      }
    ]
  },
  {
    "id": "cs406-quiz-2-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-2",
    "title": "Search Algorithms - Informed",
    "questions": [
      {
        "id": "cs406-q8",
        "type": "multiple_choice",
        "prompt": "An admissible heuristic must:",
        "options": [
          "Never overestimate the cost to reach the goal",
          "Always equal the true cost",
          "Never underestimate the cost",
          "Be consistent"
        ],
        "correctAnswer": "Never overestimate the cost to reach the goal",
        "explanation": "An admissible heuristic never overestimates h*(n), ensuring A* finds optimal solutions. Consistency is stronger but not required for optimality with tree search."
      },
      {
        "id": "cs406-q9",
        "type": "multiple_choice",
        "prompt": "What does A* use to evaluate nodes?",
        "options": [
          "f(n) = g(n) + h(n) where g is actual cost and h is heuristic estimate",
          "Only the heuristic h(n)",
          "Only the actual cost g(n)",
          "The number of steps from the start"
        ],
        "correctAnswer": "f(n) = g(n) + h(n) where g is actual cost and h is heuristic estimate",
        "explanation": "A* combines actual path cost g(n) with heuristic estimate h(n) to evaluate the estimated total cost f(n) = g(n) + h(n)."
      },
      {
        "id": "cs406-q10",
        "type": "multiple_choice",
        "prompt": "Hill climbing can get stuck in:",
        "options": [
          "Local maxima, plateaus, and ridges",
          "Only global maxima",
          "Infinite loops",
          "Optimal solutions"
        ],
        "correctAnswer": "Local maxima, plateaus, and ridges",
        "explanation": "Hill climbing is susceptible to local maxima (peaks that arent global), plateaus (flat regions), and ridges (difficult to navigate)."
      },
      {
        "id": "cs406-q11",
        "type": "multiple_choice",
        "prompt": "In minimax, MAX player aims to:",
        "options": [
          "Maximize utility",
          "Minimize utility",
          "Maximize the number of moves",
          "Match the opponents strategy"
        ],
        "correctAnswer": "Maximize utility",
        "explanation": "The MAX player chooses moves that maximize the utility value, while MIN player minimizes it (in zero-sum games)."
      }
    ]
  },
  {
    "id": "cs406-quiz-2-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-2",
    "title": "Search Complexity and Applications",
    "questions": [
      {
        "id": "cs406-q9",
        "type": "multiple_choice",
        "prompt": "What does A* use to evaluate nodes?",
        "options": [
          "f(n) = g(n) + h(n) where g is actual cost and h is heuristic estimate",
          "Only the heuristic h(n)",
          "Only the actual cost g(n)",
          "The number of steps from the start"
        ],
        "correctAnswer": "f(n) = g(n) + h(n) where g is actual cost and h is heuristic estimate",
        "explanation": "A* combines actual path cost g(n) with heuristic estimate h(n) to evaluate the estimated total cost f(n) = g(n) + h(n)."
      },
      {
        "id": "cs406-q10",
        "type": "multiple_choice",
        "prompt": "Hill climbing can get stuck in:",
        "options": [
          "Local maxima, plateaus, and ridges",
          "Only global maxima",
          "Infinite loops",
          "Optimal solutions"
        ],
        "correctAnswer": "Local maxima, plateaus, and ridges",
        "explanation": "Hill climbing is susceptible to local maxima (peaks that arent global), plateaus (flat regions), and ridges (difficult to navigate)."
      },
      {
        "id": "cs406-q11",
        "type": "multiple_choice",
        "prompt": "In minimax, MAX player aims to:",
        "options": [
          "Maximize utility",
          "Minimize utility",
          "Maximize the number of moves",
          "Match the opponents strategy"
        ],
        "correctAnswer": "Maximize utility",
        "explanation": "The MAX player chooses moves that maximize the utility value, while MIN player minimizes it (in zero-sum games)."
      }
    ]
  },
  {
    "id": "cs406-quiz-3-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-3",
    "title": "Adversarial Search - Minimax",
    "questions": [
      {
        "id": "cs406-q11",
        "type": "multiple_choice",
        "prompt": "In minimax, MAX player aims to:",
        "options": [
          "Maximize utility",
          "Minimize utility",
          "Maximize the number of moves",
          "Match the opponents strategy"
        ],
        "correctAnswer": "Maximize utility",
        "explanation": "The MAX player chooses moves that maximize the utility value, while MIN player minimizes it (in zero-sum games)."
      },
      {
        "id": "cs406-q12",
        "type": "multiple_choice",
        "prompt": "Alpha-beta pruning reduces minimax search cost by:",
        "options": [
          "Eliminating branches that cannot affect the final decision",
          "Using a better evaluation function",
          "Searching fewer depth levels",
          "Using parallel processing"
        ],
        "correctAnswer": "Eliminating branches that cannot affect the final decision",
        "explanation": "Alpha-beta pruning safely eliminates branches where the optimal play makes them irrelevant, without affecting the minimax value."
      },
      {
        "id": "cs406-q13",
        "type": "multiple_choice",
        "prompt": "What is the best-case time complexity of alpha-beta pruning?",
        "options": [
          "O(b^(d/2))",
          "O(b^d)",
          "O(bd)",
          "O(b^2)"
        ],
        "correctAnswer": "O(b^(d/2))",
        "explanation": "With perfect move ordering, alpha-beta prunes enough to reduce complexity from O(b^d) to O(b^(d/2)), effectively doubling searchable depth."
      }
    ]
  },
  {
    "id": "cs406-quiz-3-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-3",
    "title": "Alpha-Beta and MCTS",
    "questions": [
      {
        "id": "cs406-q12",
        "type": "multiple_choice",
        "prompt": "Alpha-beta pruning reduces minimax search cost by:",
        "options": [
          "Eliminating branches that cannot affect the final decision",
          "Using a better evaluation function",
          "Searching fewer depth levels",
          "Using parallel processing"
        ],
        "correctAnswer": "Eliminating branches that cannot affect the final decision",
        "explanation": "Alpha-beta pruning safely eliminates branches where the optimal play makes them irrelevant, without affecting the minimax value."
      },
      {
        "id": "cs406-q13",
        "type": "multiple_choice",
        "prompt": "What is the best-case time complexity of alpha-beta pruning?",
        "options": [
          "O(b^(d/2))",
          "O(b^d)",
          "O(bd)",
          "O(b^2)"
        ],
        "correctAnswer": "O(b^(d/2))",
        "explanation": "With perfect move ordering, alpha-beta prunes enough to reduce complexity from O(b^d) to O(b^(d/2)), effectively doubling searchable depth."
      },
      {
        "id": "cs406-q14",
        "type": "multiple_choice",
        "prompt": "Monte Carlo Tree Search balances exploration and exploitation using:",
        "options": [
          "UCB1 (Upper Confidence Bound) formula",
          "Alpha-beta pruning",
          "Evaluation functions",
          "Random selection"
        ],
        "correctAnswer": "UCB1 (Upper Confidence Bound) formula",
        "explanation": "MCTS uses UCB1 formula: wins/visits + c*sqrt(ln(parent_visits)/visits) to balance trying promising moves and exploring less-visited options."
      },
      {
        "id": "cs406-q15",
        "type": "multiple_choice",
        "prompt": "Expectiminimax extends minimax to handle:",
        "options": [
          "Chance nodes with probabilistic outcomes",
          "Multiple players",
          "Imperfect information",
          "Continuous state spaces"
        ],
        "correctAnswer": "Chance nodes with probabilistic outcomes",
        "explanation": "Expectiminimax adds chance nodes that compute expected values over random outcomes, handling games like backgammon with dice."
      }
    ]
  },
  {
    "id": "cs406-quiz-3-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-3",
    "title": "Game Playing Applications",
    "questions": [
      {
        "id": "cs406-q14",
        "type": "multiple_choice",
        "prompt": "Monte Carlo Tree Search balances exploration and exploitation using:",
        "options": [
          "UCB1 (Upper Confidence Bound) formula",
          "Alpha-beta pruning",
          "Evaluation functions",
          "Random selection"
        ],
        "correctAnswer": "UCB1 (Upper Confidence Bound) formula",
        "explanation": "MCTS uses UCB1 formula: wins/visits + c*sqrt(ln(parent_visits)/visits) to balance trying promising moves and exploring less-visited options."
      },
      {
        "id": "cs406-q15",
        "type": "multiple_choice",
        "prompt": "Expectiminimax extends minimax to handle:",
        "options": [
          "Chance nodes with probabilistic outcomes",
          "Multiple players",
          "Imperfect information",
          "Continuous state spaces"
        ],
        "correctAnswer": "Chance nodes with probabilistic outcomes",
        "explanation": "Expectiminimax adds chance nodes that compute expected values over random outcomes, handling games like backgammon with dice."
      },
      {
        "id": "cs406-q16",
        "type": "multiple_choice",
        "prompt": "In a CSP, what is a constraint?",
        "options": [
          "A restriction on the values variables can simultaneously take",
          "The set of possible values for a variable",
          "The order in which variables are assigned",
          "The goal state"
        ],
        "correctAnswer": "A restriction on the values variables can simultaneously take",
        "explanation": "Constraints specify which combinations of variable values are permitted, e.g., \"X ≠ Y\" for map coloring."
      }
    ]
  },
  {
    "id": "cs406-quiz-4-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-4",
    "title": "CSP Fundamentals",
    "questions": [
      {
        "id": "cs406-q16",
        "type": "multiple_choice",
        "prompt": "In a CSP, what is a constraint?",
        "options": [
          "A restriction on the values variables can simultaneously take",
          "The set of possible values for a variable",
          "The order in which variables are assigned",
          "The goal state"
        ],
        "correctAnswer": "A restriction on the values variables can simultaneously take",
        "explanation": "Constraints specify which combinations of variable values are permitted, e.g., \"X ≠ Y\" for map coloring."
      },
      {
        "id": "cs406-q17",
        "type": "multiple_choice",
        "prompt": "Arc consistency AC-3 ensures:",
        "options": [
          "For each value in a variables domain, there exists a consistent value in each neighbors domain",
          "All constraints are satisfied",
          "A solution exists",
          "All variables have the same domain size"
        ],
        "correctAnswer": "For each value in a variables domain, there exists a consistent value in each neighbors domain",
        "explanation": "AC-3 makes each arc (directed constraint) consistent by removing domain values that have no supporting values in constrained variables."
      },
      {
        "id": "cs406-q18",
        "type": "multiple_choice",
        "prompt": "The Minimum Remaining Values (MRV) heuristic chooses:",
        "options": [
          "The variable with the fewest legal values remaining",
          "The variable with the most constraints",
          "The first unassigned variable",
          "The variable with the most remaining values"
        ],
        "correctAnswer": "The variable with the fewest legal values remaining",
        "explanation": "MRV (most constrained variable) chooses the variable most likely to cause failure soon, detecting failures early and reducing search."
      }
    ]
  },
  {
    "id": "cs406-quiz-4-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-4",
    "title": "CSP Algorithms",
    "questions": [
      {
        "id": "cs406-q17",
        "type": "multiple_choice",
        "prompt": "Arc consistency AC-3 ensures:",
        "options": [
          "For each value in a variables domain, there exists a consistent value in each neighbors domain",
          "All constraints are satisfied",
          "A solution exists",
          "All variables have the same domain size"
        ],
        "correctAnswer": "For each value in a variables domain, there exists a consistent value in each neighbors domain",
        "explanation": "AC-3 makes each arc (directed constraint) consistent by removing domain values that have no supporting values in constrained variables."
      },
      {
        "id": "cs406-q18",
        "type": "multiple_choice",
        "prompt": "The Minimum Remaining Values (MRV) heuristic chooses:",
        "options": [
          "The variable with the fewest legal values remaining",
          "The variable with the most constraints",
          "The first unassigned variable",
          "The variable with the most remaining values"
        ],
        "correctAnswer": "The variable with the fewest legal values remaining",
        "explanation": "MRV (most constrained variable) chooses the variable most likely to cause failure soon, detecting failures early and reducing search."
      },
      {
        "id": "cs406-q19",
        "type": "multiple_choice",
        "prompt": "Forward checking in CSP backtracking:",
        "options": [
          "Removes inconsistent values from unassigned variables after each assignment",
          "Checks all constraints before starting search",
          "Looks ahead to detect solutions",
          "Uses arc consistency on all variables"
        ],
        "correctAnswer": "Removes inconsistent values from unassigned variables after each assignment",
        "explanation": "Forward checking propagates constraints immediately after each assignment, removing values from unassigned neighbors that conflict."
      },
      {
        "id": "cs406-q20",
        "type": "multiple_choice",
        "prompt": "The min-conflicts algorithm for CSP:",
        "options": [
          "Uses local search by changing one variable to minimize constraint violations",
          "Uses backtracking with forward checking",
          "Guarantees finding a solution",
          "Maintains arc consistency"
        ],
        "correctAnswer": "Uses local search by changing one variable to minimize constraint violations",
        "explanation": "Min-conflicts is a local search method that repeatedly selects a conflicting variable and changes it to minimize total conflicts."
      }
    ]
  },
  {
    "id": "cs406-quiz-4-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-4",
    "title": "CSP Applications",
    "questions": [
      {
        "id": "cs406-q19",
        "type": "multiple_choice",
        "prompt": "Forward checking in CSP backtracking:",
        "options": [
          "Removes inconsistent values from unassigned variables after each assignment",
          "Checks all constraints before starting search",
          "Looks ahead to detect solutions",
          "Uses arc consistency on all variables"
        ],
        "correctAnswer": "Removes inconsistent values from unassigned variables after each assignment",
        "explanation": "Forward checking propagates constraints immediately after each assignment, removing values from unassigned neighbors that conflict."
      },
      {
        "id": "cs406-q20",
        "type": "multiple_choice",
        "prompt": "The min-conflicts algorithm for CSP:",
        "options": [
          "Uses local search by changing one variable to minimize constraint violations",
          "Uses backtracking with forward checking",
          "Guarantees finding a solution",
          "Maintains arc consistency"
        ],
        "correctAnswer": "Uses local search by changing one variable to minimize constraint violations",
        "explanation": "Min-conflicts is a local search method that repeatedly selects a conflicting variable and changes it to minimize total conflicts."
      },
      {
        "id": "cs406-q21",
        "type": "multiple_choice",
        "prompt": "STRIPS operators consist of:",
        "options": [
          "Preconditions, add list, and delete list",
          "Only preconditions",
          "States and actions",
          "Goals and subgoals"
        ],
        "correctAnswer": "Preconditions, add list, and delete list",
        "explanation": "STRIPS operators specify preconditions (what must be true to apply), add list (what becomes true), and delete list (what becomes false)."
      }
    ]
  },
  {
    "id": "cs406-quiz-5-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-5",
    "title": "Planning Fundamentals",
    "questions": [
      {
        "id": "cs406-q21",
        "type": "multiple_choice",
        "prompt": "STRIPS operators consist of:",
        "options": [
          "Preconditions, add list, and delete list",
          "Only preconditions",
          "States and actions",
          "Goals and subgoals"
        ],
        "correctAnswer": "Preconditions, add list, and delete list",
        "explanation": "STRIPS operators specify preconditions (what must be true to apply), add list (what becomes true), and delete list (what becomes false)."
      },
      {
        "id": "cs406-q22",
        "type": "multiple_choice",
        "prompt": "The delete-relaxation heuristic works by:",
        "options": [
          "Ignoring delete effects to create an easier problem",
          "Deleting unnecessary operators",
          "Removing goals from the problem",
          "Deleting constraints"
        ],
        "correctAnswer": "Ignoring delete effects to create an easier problem",
        "explanation": "Delete-relaxation removes all delete effects from operators, creating a simpler problem where achieved facts stay true, providing an admissible heuristic."
      },
      {
        "id": "cs406-q23",
        "type": "multiple_choice",
        "prompt": "Modus Ponens is the inference rule:",
        "options": [
          "From α ⇒ β and α, infer β",
          "From α and β, infer α ⇒ β",
          "From α ⇒ β and β, infer α",
          "From α ⇒ β and ¬β, infer ¬α"
        ],
        "correctAnswer": "From α ⇒ β and α, infer β",
        "explanation": "Modus Ponens: if we know an implication and its antecedent, we can infer the consequent. Its the fundamental rule of forward chaining."
      }
    ]
  },
  {
    "id": "cs406-quiz-5-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-5",
    "title": "Planning Algorithms",
    "questions": [
      {
        "id": "cs406-q22",
        "type": "multiple_choice",
        "prompt": "The delete-relaxation heuristic works by:",
        "options": [
          "Ignoring delete effects to create an easier problem",
          "Deleting unnecessary operators",
          "Removing goals from the problem",
          "Deleting constraints"
        ],
        "correctAnswer": "Ignoring delete effects to create an easier problem",
        "explanation": "Delete-relaxation removes all delete effects from operators, creating a simpler problem where achieved facts stay true, providing an admissible heuristic."
      },
      {
        "id": "cs406-q23",
        "type": "multiple_choice",
        "prompt": "Modus Ponens is the inference rule:",
        "options": [
          "From α ⇒ β and α, infer β",
          "From α and β, infer α ⇒ β",
          "From α ⇒ β and β, infer α",
          "From α ⇒ β and ¬β, infer ¬α"
        ],
        "correctAnswer": "From α ⇒ β and α, infer β",
        "explanation": "Modus Ponens: if we know an implication and its antecedent, we can infer the consequent. Its the fundamental rule of forward chaining."
      }
    ]
  },
  {
    "id": "cs406-quiz-5-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-5",
    "title": "Planning Applications",
    "questions": [
      {
        "id": "cs406-q21",
        "type": "multiple_choice",
        "prompt": "STRIPS operators consist of:",
        "options": [
          "Preconditions, add list, and delete list",
          "Only preconditions",
          "States and actions",
          "Goals and subgoals"
        ],
        "correctAnswer": "Preconditions, add list, and delete list",
        "explanation": "STRIPS operators specify preconditions (what must be true to apply), add list (what becomes true), and delete list (what becomes false)."
      },
      {
        "id": "cs406-q22",
        "type": "multiple_choice",
        "prompt": "The delete-relaxation heuristic works by:",
        "options": [
          "Ignoring delete effects to create an easier problem",
          "Deleting unnecessary operators",
          "Removing goals from the problem",
          "Deleting constraints"
        ],
        "correctAnswer": "Ignoring delete effects to create an easier problem",
        "explanation": "Delete-relaxation removes all delete effects from operators, creating a simpler problem where achieved facts stay true, providing an admissible heuristic."
      }
    ]
  },
  {
    "id": "cs406-quiz-6-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Logic Fundamentals",
    "questions": [
      {
        "id": "cs406-q23",
        "type": "multiple_choice",
        "prompt": "Modus Ponens is the inference rule:",
        "options": [
          "From α ⇒ β and α, infer β",
          "From α and β, infer α ⇒ β",
          "From α ⇒ β and β, infer α",
          "From α ⇒ β and ¬β, infer ¬α"
        ],
        "correctAnswer": "From α ⇒ β and α, infer β",
        "explanation": "Modus Ponens: if we know an implication and its antecedent, we can infer the consequent. Its the fundamental rule of forward chaining."
      },
      {
        "id": "cs406-q24",
        "type": "multiple_choice",
        "prompt": "Resolution in propositional logic:",
        "options": [
          "Combines complementary literals to derive new clauses",
          "Resolves conflicts between rules",
          "Finds solutions to equations",
          "Resolves ambiguous statements"
        ],
        "correctAnswer": "Combines complementary literals to derive new clauses",
        "explanation": "Resolution takes two clauses with complementary literals (P and ¬P) and produces a new clause combining their other literals, used for refutation proofs."
      },
      {
        "id": "cs406-q25",
        "type": "multiple_choice",
        "prompt": "Bayes rule states:",
        "options": [
          "P(A|B) = P(B|A)P(A) / P(B)",
          "P(A|B) = P(A)P(B)",
          "P(A|B) = P(B|A)",
          "P(A|B) = 1 - P(B|A)"
        ],
        "correctAnswer": "P(A|B) = P(B|A)P(A) / P(B)",
        "explanation": "Bayes rule allows computing P(A|B) from P(B|A), enabling inference from evidence to causes."
      }
    ]
  },
  {
    "id": "cs406-quiz-6-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Inference and Resolution",
    "questions": [
      {
        "id": "cs406-q24",
        "type": "multiple_choice",
        "prompt": "Resolution in propositional logic:",
        "options": [
          "Combines complementary literals to derive new clauses",
          "Resolves conflicts between rules",
          "Finds solutions to equations",
          "Resolves ambiguous statements"
        ],
        "correctAnswer": "Combines complementary literals to derive new clauses",
        "explanation": "Resolution takes two clauses with complementary literals (P and ¬P) and produces a new clause combining their other literals, used for refutation proofs."
      },
      {
        "id": "cs406-q25",
        "type": "multiple_choice",
        "prompt": "Bayes rule states:",
        "options": [
          "P(A|B) = P(B|A)P(A) / P(B)",
          "P(A|B) = P(A)P(B)",
          "P(A|B) = P(B|A)",
          "P(A|B) = 1 - P(B|A)"
        ],
        "correctAnswer": "P(A|B) = P(B|A)P(A) / P(B)",
        "explanation": "Bayes rule allows computing P(A|B) from P(B|A), enabling inference from evidence to causes."
      }
    ]
  },
  {
    "id": "cs406-quiz-6-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Knowledge Representation",
    "questions": [
      {
        "id": "cs406-q23",
        "type": "multiple_choice",
        "prompt": "Modus Ponens is the inference rule:",
        "options": [
          "From α ⇒ β and α, infer β",
          "From α and β, infer α ⇒ β",
          "From α ⇒ β and β, infer α",
          "From α ⇒ β and ¬β, infer ¬α"
        ],
        "correctAnswer": "From α ⇒ β and α, infer β",
        "explanation": "Modus Ponens: if we know an implication and its antecedent, we can infer the consequent. Its the fundamental rule of forward chaining."
      },
      {
        "id": "cs406-q24",
        "type": "multiple_choice",
        "prompt": "Resolution in propositional logic:",
        "options": [
          "Combines complementary literals to derive new clauses",
          "Resolves conflicts between rules",
          "Finds solutions to equations",
          "Resolves ambiguous statements"
        ],
        "correctAnswer": "Combines complementary literals to derive new clauses",
        "explanation": "Resolution takes two clauses with complementary literals (P and ¬P) and produces a new clause combining their other literals, used for refutation proofs."
      }
    ]
  },
  {
    "id": "cs406-quiz-7-1",
    "subjectId": "cs406",
    "topicId": "cs406-topic-7",
    "title": "Probability and Bayes",
    "questions": [
      {
        "id": "cs406-q25",
        "type": "multiple_choice",
        "prompt": "Bayes rule states:",
        "options": [
          "P(A|B) = P(B|A)P(A) / P(B)",
          "P(A|B) = P(A)P(B)",
          "P(A|B) = P(B|A)",
          "P(A|B) = 1 - P(B|A)"
        ],
        "correctAnswer": "P(A|B) = P(B|A)P(A) / P(B)",
        "explanation": "Bayes rule allows computing P(A|B) from P(B|A), enabling inference from evidence to causes."
      },
      {
        "id": "cs406-q26",
        "type": "multiple_choice",
        "prompt": "In a Bayesian network, d-separation determines:",
        "options": [
          "Conditional independence between variables",
          "The direction of causality",
          "The distance between nodes",
          "Whether the network is connected"
        ],
        "correctAnswer": "Conditional independence between variables",
        "explanation": "d-separation is a graphical criterion for determining conditional independence: if X and Y are d-separated given Z, then X ⊥ Y | Z."
      },
      {
        "id": "cs406-q27",
        "type": "multiple_choice",
        "prompt": "The forward algorithm for HMMs computes:",
        "options": [
          "P(X_t | e_1:t) - filtering",
          "P(X_t | e_1:T) - smoothing",
          "argmax P(x_1:T | e_1:T) - most likely sequence",
          "P(e_1:t) - likelihood"
        ],
        "correctAnswer": "P(X_t | e_1:t) - filtering",
        "explanation": "The forward algorithm recursively computes the belief state P(X_t | e_1:t), filtering the current state given all evidence so far."
      }
    ]
  },
  {
    "id": "cs406-quiz-7-2",
    "subjectId": "cs406",
    "topicId": "cs406-topic-7",
    "title": "Bayesian Networks",
    "questions": [
      {
        "id": "cs406-q26",
        "type": "multiple_choice",
        "prompt": "In a Bayesian network, d-separation determines:",
        "options": [
          "Conditional independence between variables",
          "The direction of causality",
          "The distance between nodes",
          "Whether the network is connected"
        ],
        "correctAnswer": "Conditional independence between variables",
        "explanation": "d-separation is a graphical criterion for determining conditional independence: if X and Y are d-separated given Z, then X ⊥ Y | Z."
      },
      {
        "id": "cs406-q27",
        "type": "multiple_choice",
        "prompt": "The forward algorithm for HMMs computes:",
        "options": [
          "P(X_t | e_1:t) - filtering",
          "P(X_t | e_1:T) - smoothing",
          "argmax P(x_1:T | e_1:T) - most likely sequence",
          "P(e_1:t) - likelihood"
        ],
        "correctAnswer": "P(X_t | e_1:t) - filtering",
        "explanation": "The forward algorithm recursively computes the belief state P(X_t | e_1:t), filtering the current state given all evidence so far."
      }
    ]
  },
  {
    "id": "cs406-quiz-7-3",
    "subjectId": "cs406",
    "topicId": "cs406-topic-7",
    "title": "Probabilistic Models",
    "questions": [
      {
        "id": "cs406-q27",
        "type": "multiple_choice",
        "prompt": "The forward algorithm for HMMs computes:",
        "options": [
          "P(X_t | e_1:t) - filtering",
          "P(X_t | e_1:T) - smoothing",
          "argmax P(x_1:T | e_1:T) - most likely sequence",
          "P(e_1:t) - likelihood"
        ],
        "correctAnswer": "P(X_t | e_1:t) - filtering",
        "explanation": "The forward algorithm recursively computes the belief state P(X_t | e_1:t), filtering the current state given all evidence so far."
      }
    ]
  }
]
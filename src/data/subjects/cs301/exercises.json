[
  {
    "id": "cs301-ex-1-1",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Process State Validator",
    "description": "Write a function that validates process state transitions. Return True if the transition from `from_state` to `to_state` is valid.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def is_valid_transition(from_state, to_state):\n    # Valid states: \"new\", \"ready\", \"running\", \"waiting\", \"terminated\"\n    pass",
    "solution": "def is_valid_transition(from_state, to_state):\n    valid_transitions = {\n        \"new\": [\"ready\"],\n        \"ready\": [\"running\"],\n        \"running\": [\"ready\", \"waiting\", \"terminated\"],\n        \"waiting\": [\"ready\"],\n        \"terminated\": []\n    }\n    return to_state in valid_transitions.get(from_state, [])",
    "testCases": [
      {
        "input": "\"ready\", \"running\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Ready to running"
      },
      {
        "input": "\"waiting\", \"running\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid: waiting to running"
      },
      {
        "input": "\"running\", \"terminated\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Running to terminated"
      }
    ],
    "hints": [
      "Define a dictionary of valid transitions",
      "Check if to_state is in the list for from_state"
    ]
  },
  {
    "id": "cs301-ex-1-2",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Process Control Block",
    "description": "Implement a ProcessControlBlock class with pid, state, program_counter, and registers. Include a method to save and restore state.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class ProcessControlBlock:\n    def __init__(self, pid):\n        pass\n    \n    def save_state(self, pc, registers):\n        pass\n    \n    def restore_state(self):\n        # Return (pc, registers)\n        pass",
    "solution": "class ProcessControlBlock:\n    def __init__(self, pid):\n        self.pid = pid\n        self.state = \"new\"\n        self.program_counter = 0\n        self.registers = {}\n\n    def save_state(self, pc, registers):\n        self.program_counter = pc\n        self.registers = registers.copy()\n\n    def restore_state(self):\n        return (self.program_counter, self.registers.copy())",
    "testCases": [
      {
        "input": "pcb = ProcessControlBlock(1); pcb.save_state(100, {\"eax\": 5}); pcb.restore_state()",
        "expectedOutput": "(100, {\"eax\": 5})",
        "isHidden": false,
        "description": "Save and restore"
      },
      {
        "input": "pcb = ProcessControlBlock(2); pcb.state",
        "expectedOutput": "\"new\"",
        "isHidden": false,
        "description": "Initial state"
      }
    ],
    "hints": [
      "Initialize all fields in __init__",
      "Copy registers to avoid aliasing"
    ]
  },
  {
    "id": "cs301-ex-1-3",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Ready Queue",
    "description": "Implement a ready queue for processes with enqueue, dequeue, and is_empty operations.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "class ReadyQueue:\n    def __init__(self):\n        pass\n    \n    def enqueue(self, process_id):\n        pass\n    \n    def dequeue(self):\n        # Return process_id or None if empty\n        pass\n    \n    def is_empty(self):\n        pass",
    "solution": "class ReadyQueue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, process_id):\n        self.queue.append(process_id)\n\n    def dequeue(self):\n        if self.queue:\n            return self.queue.pop(0)\n        return None\n\n    def is_empty(self):\n        return len(self.queue) == 0",
    "testCases": [
      {
        "input": "q = ReadyQueue(); q.enqueue(1); q.enqueue(2); q.dequeue()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "FIFO order"
      },
      {
        "input": "q = ReadyQueue(); q.is_empty()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Empty check"
      }
    ],
    "hints": [
      "Use a list as the underlying storage",
      "pop(0) removes the first element"
    ]
  },
  {
    "id": "cs301-ex-1-4",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Context Switch Simulation",
    "description": "Simulate context switches. Given a list of (process_id, burst_time) and a time quantum, count the number of context switches.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def count_context_switches(processes, quantum):\n    # processes: list of (pid, burst_time)\n    # Return number of context switches\n    pass",
    "solution": "def count_context_switches(processes, quantum):\n    from collections import deque\n    queue = deque()\n    for pid, burst in processes:\n        queue.append([pid, burst])\n\n    switches = 0\n    while queue:\n        pid, remaining = queue.popleft()\n        if remaining > quantum:\n            queue.append([pid, remaining - quantum])\n            switches += 1\n        else:\n            if queue:  # More processes to run\n                switches += 1\n    return switches",
    "testCases": [
      {
        "input": "[(1, 10), (2, 5)], 3",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Two processes"
      },
      {
        "input": "[(1, 5)], 10",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Single process, no switch"
      }
    ],
    "hints": [
      "Use Round Robin logic",
      "Count switches when moving to next process"
    ]
  },
  {
    "id": "cs301-ex-1-5",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Fork Tree",
    "description": "Calculate how many processes exist after n fork() calls in sequence (each process forks once).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def count_processes_after_forks(n):\n    # Return total number of processes after n sequential forks\n    pass",
    "solution": "def count_processes_after_forks(n):\n    # Each fork doubles the number of processes\n    return 2 ** n",
    "testCases": [
      {
        "input": "3",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Three forks"
      },
      {
        "input": "0",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "No forks"
      },
      {
        "input": "5",
        "expectedOutput": "32",
        "isHidden": true,
        "description": "Five forks"
      }
    ],
    "hints": [
      "Each fork doubles the process count",
      "Think exponentially"
    ]
  },
  {
    "id": "cs301-ex-1-6",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Process Tree Depth",
    "description": "Given a parent-child relationship dict, find the depth of a given process from the root (pid 1).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def process_depth(parent_map, pid):\n    # parent_map[child] = parent\n    # Return depth from root (pid 1 has depth 0)\n    pass",
    "solution": "def process_depth(parent_map, pid):\n    depth = 0\n    current = pid\n    while current != 1:\n        if current not in parent_map:\n            return -1  # Not connected to root\n        current = parent_map[current]\n        depth += 1\n    return depth",
    "testCases": [
      {
        "input": "{2: 1, 3: 1, 4: 2, 5: 2}, 5",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Depth 2"
      },
      {
        "input": "{2: 1}, 1",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Root process"
      }
    ],
    "hints": [
      "Traverse up to root",
      "Count steps"
    ]
  },
  {
    "id": "cs301-ex-1-7",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Shared Memory Buffer",
    "description": "Implement a simple shared memory buffer with read and write operations. Buffer has fixed size.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class SharedMemory:\n    def __init__(self, size):\n        pass\n    \n    def write(self, offset, data):\n        # Write data at offset, return True if successful\n        pass\n    \n    def read(self, offset, length):\n        # Read length bytes from offset\n        pass",
    "solution": "class SharedMemory:\n    def __init__(self, size):\n        self.buffer = [0] * size\n        self.size = size\n\n    def write(self, offset, data):\n        if offset < 0 or offset + len(data) > self.size:\n            return False\n        for i, byte in enumerate(data):\n            self.buffer[offset + i] = byte\n        return True\n\n    def read(self, offset, length):\n        if offset < 0 or offset + length > self.size:\n            return None\n        return self.buffer[offset:offset + length]",
    "testCases": [
      {
        "input": "sm = SharedMemory(10); sm.write(0, [1,2,3]); sm.read(0, 3)",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": false,
        "description": "Write and read"
      },
      {
        "input": "sm = SharedMemory(5); sm.write(3, [1,2,3])",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Out of bounds"
      }
    ],
    "hints": [
      "Check bounds before operations",
      "Use a list for the buffer"
    ]
  },
  {
    "id": "cs301-ex-1-8",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Message Passing Queue",
    "description": "Implement a message queue for IPC with send and receive operations.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class MessageQueue:\n    def __init__(self):\n        pass\n    \n    def send(self, sender_id, message):\n        pass\n    \n    def receive(self):\n        # Return (sender_id, message) or None\n        pass",
    "solution": "class MessageQueue:\n    def __init__(self):\n        self.messages = []\n\n    def send(self, sender_id, message):\n        self.messages.append((sender_id, message))\n\n    def receive(self):\n        if self.messages:\n            return self.messages.pop(0)\n        return None",
    "testCases": [
      {
        "input": "mq = MessageQueue(); mq.send(1, \"hello\"); mq.receive()",
        "expectedOutput": "(1, \"hello\")",
        "isHidden": false,
        "description": "Send and receive"
      },
      {
        "input": "mq = MessageQueue(); mq.receive()",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Empty queue"
      }
    ],
    "hints": [
      "Store tuples of (sender, message)",
      "FIFO order"
    ]
  },
  {
    "id": "cs301-ex-1-9",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "FCFS Scheduler",
    "description": "Implement FCFS scheduler. Given arrival times and burst times, return the order of completion.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def fcfs_schedule(processes):\n    # processes: list of (pid, arrival_time, burst_time)\n    # Return list of pids in completion order\n    pass",
    "solution": "def fcfs_schedule(processes):\n    # Sort by arrival time\n    sorted_procs = sorted(processes, key=lambda x: (x[1], x[0]))\n    return [p[0] for p in sorted_procs]",
    "testCases": [
      {
        "input": "[(1, 0, 5), (2, 1, 3), (3, 2, 1)]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": false,
        "description": "Sequential arrival"
      },
      {
        "input": "[(1, 2, 5), (2, 0, 3)]",
        "expectedOutput": "[2, 1]",
        "isHidden": false,
        "description": "P2 arrives first"
      }
    ],
    "hints": [
      "Sort by arrival time",
      "FCFS is non-preemptive"
    ]
  },
  {
    "id": "cs301-ex-1-10",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Zombie Process Detection",
    "description": "Given process info, identify zombie processes (terminated but parent hasn't called wait).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def find_zombies(processes, waited_pids):\n    # processes: list of (pid, state) where state is \"running\" or \"terminated\"\n    # waited_pids: set of pids that parent has waited on\n    # Return list of zombie pids\n    pass",
    "solution": "def find_zombies(processes, waited_pids):\n    zombies = []\n    for pid, state in processes:\n        if state == \"terminated\" and pid not in waited_pids:\n            zombies.append(pid)\n    return zombies",
    "testCases": [
      {
        "input": "[(1, \"terminated\"), (2, \"running\"), (3, \"terminated\")], {1}",
        "expectedOutput": "[3]",
        "isHidden": false,
        "description": "One zombie"
      },
      {
        "input": "[(1, \"terminated\")], {1}",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "No zombies"
      }
    ],
    "hints": [
      "Zombie = terminated but not waited on",
      "Check both conditions"
    ]
  },
  {
    "id": "cs301-ex-1-11",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Orphan Process Adoption",
    "description": "Reparent orphan processes to init (pid 1). Return updated parent map.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def adopt_orphans(parent_map, terminated_pids):\n    # parent_map: {child: parent}\n    # terminated_pids: set of terminated parent pids\n    # Return new parent_map with orphans reparented to 1\n    pass",
    "solution": "def adopt_orphans(parent_map, terminated_pids):\n    new_map = {}\n    for child, parent in parent_map.items():\n        if parent in terminated_pids:\n            new_map[child] = 1  # Adopt by init\n        else:\n            new_map[child] = parent\n    return new_map",
    "testCases": [
      {
        "input": "{2: 1, 3: 2, 4: 2}, {2}",
        "expectedOutput": "{2: 1, 3: 1, 4: 1}",
        "isHidden": false,
        "description": "Orphans adopted"
      },
      {
        "input": "{2: 1}, set()",
        "expectedOutput": "{2: 1}",
        "isHidden": false,
        "description": "No orphans"
      }
    ],
    "hints": [
      "Check if parent is terminated",
      "Reparent to pid 1"
    ]
  },
  {
    "id": "cs301-ex-1-12",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Memory Layout Calculator",
    "description": "Calculate total process memory given sizes of text, data, heap, and stack segments.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def calculate_process_memory(text, data, heap, stack):\n    # Return total memory in bytes\n    pass",
    "solution": "def calculate_process_memory(text, data, heap, stack):\n    return text + data + heap + stack",
    "testCases": [
      {
        "input": "1024, 512, 2048, 1024",
        "expectedOutput": "4608",
        "isHidden": false,
        "description": "Sum of segments"
      },
      {
        "input": "0, 0, 0, 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Empty process"
      }
    ],
    "hints": [
      "Simply add all segments",
      "Each segment is independent"
    ]
  },
  {
    "id": "cs301-ex-1-13",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Priority Ready Queue",
    "description": "Implement a priority-based ready queue where lower number = higher priority.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "import heapq\n\nclass PriorityReadyQueue:\n    def __init__(self):\n        pass\n    \n    def enqueue(self, pid, priority):\n        pass\n    \n    def dequeue(self):\n        # Return pid of highest priority process\n        pass",
    "solution": "import heapq\n\nclass PriorityReadyQueue:\n    def __init__(self):\n        self.heap = []\n\n    def enqueue(self, pid, priority):\n        heapq.heappush(self.heap, (priority, pid))\n\n    def dequeue(self):\n        if self.heap:\n            priority, pid = heapq.heappop(self.heap)\n            return pid\n        return None",
    "testCases": [
      {
        "input": "pq = PriorityReadyQueue(); pq.enqueue(1, 5); pq.enqueue(2, 1); pq.dequeue()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Higher priority first"
      },
      {
        "input": "pq = PriorityReadyQueue(); pq.dequeue()",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Empty queue"
      }
    ],
    "hints": [
      "Use heapq for min-heap",
      "Store (priority, pid) tuples"
    ]
  },
  {
    "id": "cs301-ex-1-14",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Simple Pipe",
    "description": "Implement a unidirectional pipe with fixed buffer size.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class Pipe:\n    def __init__(self, buffer_size):\n        pass\n    \n    def write(self, data):\n        # Return number of bytes written (0 if full)\n        pass\n    \n    def read(self, n):\n        # Return up to n bytes\n        pass",
    "solution": "class Pipe:\n    def __init__(self, buffer_size):\n        self.buffer = []\n        self.max_size = buffer_size\n\n    def write(self, data):\n        space = self.max_size - len(self.buffer)\n        to_write = data[:space]\n        self.buffer.extend(to_write)\n        return len(to_write)\n\n    def read(self, n):\n        result = self.buffer[:n]\n        self.buffer = self.buffer[n:]\n        return result",
    "testCases": [
      {
        "input": "p = Pipe(5); p.write([1,2,3]); p.read(2)",
        "expectedOutput": "[1, 2]",
        "isHidden": false,
        "description": "Write then read"
      },
      {
        "input": "p = Pipe(2); p.write([1,2,3,4])",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Buffer full"
      }
    ],
    "hints": [
      "Track buffer capacity",
      "Handle partial writes"
    ]
  },
  {
    "id": "cs301-ex-1-15",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Count Descendants",
    "description": "Count all descendants (children, grandchildren, etc.) of a process.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def count_descendants(parent_map, pid):\n    # parent_map: {child: parent}\n    # Return count of all descendants of pid\n    pass",
    "solution": "def count_descendants(parent_map, pid):\n    # Build children map\n    children = {}\n    for child, parent in parent_map.items():\n        if parent not in children:\n            children[parent] = []\n        children[parent].append(child)\n\n    # DFS to count descendants\n    def dfs(p):\n        count = 0\n        for child in children.get(p, []):\n            count += 1 + dfs(child)\n        return count\n\n    return dfs(pid)",
    "testCases": [
      {
        "input": "{2: 1, 3: 1, 4: 2, 5: 2, 6: 4}, 1",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "All from root"
      },
      {
        "input": "{2: 1, 3: 1, 4: 2, 5: 2, 6: 4}, 2",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Subtree"
      }
    ],
    "hints": [
      "Build a children map first",
      "Use DFS to count"
    ]
  },
  {
    "id": "cs301-ex-1-16",
    "subjectId": "cs301",
    "topicId": "cs301-t1",
    "title": "Exec System Call",
    "description": "Simulate exec() by replacing process image. Return the new process state after exec.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def exec_process(pcb, new_program, new_args):\n    # pcb: dict with pid, program, args, state\n    # Return updated pcb (keep pid, update rest)\n    pass",
    "solution": "def exec_process(pcb, new_program, new_args):\n    return {\n        'pid': pcb['pid'],\n        'program': new_program,\n        'args': new_args,\n        'state': 'running',\n        'program_counter': 0,\n        'registers': {}\n    }",
    "testCases": [
      {
        "input": "{\"pid\": 1, \"program\": \"a\", \"args\": []}, \"b\", [\"x\"]",
        "expectedOutput": "{\"pid\": 1, \"program\": \"b\", \"args\": [\"x\"], \"state\": \"running\", \"program_counter\": 0, \"registers\": {}}",
        "isHidden": false,
        "description": "Exec replaces program"
      },
      {
        "input": "{\"pid\": 5, \"program\": \"old\", \"args\": [\"y\"]}, \"new\", []",
        "expectedOutput": "{\"pid\": 5, \"program\": \"new\", \"args\": [], \"state\": \"running\", \"program_counter\": 0, \"registers\": {}}",
        "isHidden": false,
        "description": "Keep pid"
      }
    ],
    "hints": [
      "Keep the pid unchanged",
      "Reset program counter and registers"
    ]
  },
  {
    "id": "cs301-ex-2-1",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Resource Check",
    "description": "Given a resource type, return whether it's shared between threads or private to each thread.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def is_shared_resource(resource):\n    # Return \"shared\" or \"private\"\n    # Resources: \"code\", \"data\", \"heap\", \"stack\", \"registers\", \"pc\"\n    pass",
    "solution": "def is_shared_resource(resource):\n    shared = {\"code\", \"data\", \"heap\"}\n    private = {\"stack\", \"registers\", \"pc\"}\n    if resource in shared:\n        return \"shared\"\n    elif resource in private:\n        return \"private\"\n    return \"unknown\"",
    "testCases": [
      {
        "input": "\"heap\"",
        "expectedOutput": "\"shared\"",
        "isHidden": false,
        "description": "Heap is shared"
      },
      {
        "input": "\"stack\"",
        "expectedOutput": "\"private\"",
        "isHidden": false,
        "description": "Stack is private"
      },
      {
        "input": "\"code\"",
        "expectedOutput": "\"shared\"",
        "isHidden": true,
        "description": "Code is shared"
      }
    ],
    "hints": [
      "Code, data, and heap are shared",
      "Stack, registers, and PC are private"
    ]
  },
  {
    "id": "cs301-ex-2-2",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Manager",
    "description": "Implement a ThreadManager that creates threads with unique IDs and tracks them.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class ThreadManager:\n    def __init__(self):\n        pass\n    \n    def create_thread(self, name):\n        # Return thread_id\n        pass\n    \n    def get_thread_count(self):\n        pass\n    \n    def get_thread_name(self, thread_id):\n        pass",
    "solution": "class ThreadManager:\n    def __init__(self):\n        self.threads = {}\n        self.next_id = 1\n\n    def create_thread(self, name):\n        tid = self.next_id\n        self.threads[tid] = name\n        self.next_id += 1\n        return tid\n\n    def get_thread_count(self):\n        return len(self.threads)\n\n    def get_thread_name(self, thread_id):\n        return self.threads.get(thread_id)",
    "testCases": [
      {
        "input": "tm = ThreadManager(); tm.create_thread(\"worker\")",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "First thread ID"
      },
      {
        "input": "tm = ThreadManager(); tm.create_thread(\"a\"); tm.create_thread(\"b\"); tm.get_thread_count()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Count threads"
      }
    ],
    "hints": [
      "Track threads in a dictionary",
      "Auto-increment IDs"
    ]
  },
  {
    "id": "cs301-ex-2-3",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Threading Model Simulator",
    "description": "Simulate blocking behavior in many-to-one model. If one user thread blocks, all block.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class ManyToOneModel:\n    def __init__(self, num_user_threads):\n        pass\n    \n    def block_thread(self, tid):\n        # Block thread tid, return number of blocked threads\n        pass\n    \n    def unblock_thread(self, tid):\n        pass",
    "solution": "class ManyToOneModel:\n    def __init__(self, num_user_threads):\n        self.num_threads = num_user_threads\n        self.blocked = set()\n        self.all_blocked = False\n\n    def block_thread(self, tid):\n        self.blocked.add(tid)\n        self.all_blocked = True  # In many-to-one, one block = all block\n        return self.num_threads\n\n    def unblock_thread(self, tid):\n        self.blocked.discard(tid)\n        if not self.blocked:\n            self.all_blocked = False",
    "testCases": [
      {
        "input": "mm = ManyToOneModel(5); mm.block_thread(1)",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "All threads blocked"
      },
      {
        "input": "mm = ManyToOneModel(3); mm.block_thread(1); mm.all_blocked",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "All blocked flag"
      }
    ],
    "hints": [
      "One kernel thread for all user threads",
      "Blocking one blocks all"
    ]
  },
  {
    "id": "cs301-ex-2-4",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Pool Implementation",
    "description": "Implement a simple thread pool with a fixed number of workers and a task queue.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class ThreadPool:\n    def __init__(self, num_workers):\n        pass\n    \n    def submit_task(self, task_id):\n        pass\n    \n    def get_available_workers(self):\n        pass\n    \n    def complete_task(self):\n        # Complete one task, free a worker\n        pass",
    "solution": "class ThreadPool:\n    def __init__(self, num_workers):\n        self.num_workers = num_workers\n        self.busy_workers = 0\n        self.task_queue = []\n\n    def submit_task(self, task_id):\n        if self.busy_workers < self.num_workers:\n            self.busy_workers += 1\n            return True  # Task started immediately\n        else:\n            self.task_queue.append(task_id)\n            return False  # Task queued\n\n    def get_available_workers(self):\n        return self.num_workers - self.busy_workers\n\n    def complete_task(self):\n        if self.task_queue:\n            self.task_queue.pop(0)\n            return True  # Started queued task\n        else:\n            self.busy_workers = max(0, self.busy_workers - 1)\n            return False  # Worker now idle",
    "testCases": [
      {
        "input": "tp = ThreadPool(2); tp.submit_task(1); tp.submit_task(2); tp.get_available_workers()",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "All workers busy"
      },
      {
        "input": "tp = ThreadPool(1); tp.submit_task(1); tp.submit_task(2); len(tp.task_queue)",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Task queued"
      }
    ],
    "hints": [
      "Track busy workers",
      "Queue tasks when pool is full"
    ]
  },
  {
    "id": "cs301-ex-2-5",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Safety Analyzer",
    "description": "Determine if a function is thread-safe based on its characteristics.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def is_thread_safe(uses_globals, uses_static, uses_locks, is_pure):\n    # Return True if thread-safe, False otherwise\n    pass",
    "solution": "def is_thread_safe(uses_globals, uses_static, uses_locks, is_pure):\n    # Pure functions are always thread-safe\n    if is_pure:\n        return True\n    # Functions with globals/statics need locks\n    if uses_globals or uses_static:\n        return uses_locks\n    # No shared state = thread-safe\n    return True",
    "testCases": [
      {
        "input": "False, False, False, True",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Pure function"
      },
      {
        "input": "True, False, False, False",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Globals without locks"
      },
      {
        "input": "True, False, True, False",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Globals with locks"
      }
    ],
    "hints": [
      "Pure functions have no side effects",
      "Shared state needs synchronization"
    ]
  },
  {
    "id": "cs301-ex-2-6",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "User Thread Scheduler",
    "description": "Implement a simple round-robin scheduler for user-level threads.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class UserThreadScheduler:\n    def __init__(self):\n        pass\n    \n    def add_thread(self, tid):\n        pass\n    \n    def get_next(self):\n        # Return next thread to run\n        pass\n    \n    def yield_thread(self):\n        # Current thread yields\n        pass",
    "solution": "class UserThreadScheduler:\n    def __init__(self):\n        self.threads = []\n        self.current_idx = 0\n\n    def add_thread(self, tid):\n        self.threads.append(tid)\n\n    def get_next(self):\n        if not self.threads:\n            return None\n        return self.threads[self.current_idx]\n\n    def yield_thread(self):\n        if self.threads:\n            self.current_idx = (self.current_idx + 1) % len(self.threads)",
    "testCases": [
      {
        "input": "sch = UserThreadScheduler(); sch.add_thread(1); sch.add_thread(2); sch.get_next()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "First thread"
      },
      {
        "input": "sch = UserThreadScheduler(); sch.add_thread(1); sch.add_thread(2); sch.yield_thread(); sch.get_next()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "After yield"
      }
    ],
    "hints": [
      "Use round-robin order",
      "Wrap around at end"
    ]
  },
  {
    "id": "cs301-ex-2-7",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Local Storage",
    "description": "Implement thread-local storage where each thread has its own copy of a variable.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class ThreadLocalStorage:\n    def __init__(self):\n        pass\n    \n    def set(self, thread_id, key, value):\n        pass\n    \n    def get(self, thread_id, key):\n        pass",
    "solution": "class ThreadLocalStorage:\n    def __init__(self):\n        self.storage = {}\n\n    def set(self, thread_id, key, value):\n        if thread_id not in self.storage:\n            self.storage[thread_id] = {}\n        self.storage[thread_id][key] = value\n\n    def get(self, thread_id, key):\n        if thread_id in self.storage:\n            return self.storage[thread_id].get(key)\n        return None",
    "testCases": [
      {
        "input": "tls = ThreadLocalStorage(); tls.set(1, \"x\", 10); tls.get(1, \"x\")",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Set and get"
      },
      {
        "input": "tls = ThreadLocalStorage(); tls.set(1, \"x\", 10); tls.get(2, \"x\")",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Different threads"
      }
    ],
    "hints": [
      "Use nested dictionary",
      "Key by thread ID first"
    ]
  },
  {
    "id": "cs301-ex-2-8",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Join Tracker",
    "description": "Track thread dependencies for join operations.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class JoinTracker:\n    def __init__(self):\n        pass\n    \n    def add_join(self, waiter_tid, waitee_tid):\n        # waiter is waiting for waitee to finish\n        pass\n    \n    def thread_finished(self, tid):\n        # Return list of threads that can now continue\n        pass",
    "solution": "class JoinTracker:\n    def __init__(self):\n        self.waiting_for = {}  # waiter -> waitee\n        self.waiters = {}  # waitee -> [waiters]\n\n    def add_join(self, waiter_tid, waitee_tid):\n        self.waiting_for[waiter_tid] = waitee_tid\n        if waitee_tid not in self.waiters:\n            self.waiters[waitee_tid] = []\n        self.waiters[waitee_tid].append(waiter_tid)\n\n    def thread_finished(self, tid):\n        released = self.waiters.get(tid, [])\n        for waiter in released:\n            del self.waiting_for[waiter]\n        if tid in self.waiters:\n            del self.waiters[tid]\n        return released",
    "testCases": [
      {
        "input": "jt = JoinTracker(); jt.add_join(1, 2); jt.thread_finished(2)",
        "expectedOutput": "[1]",
        "isHidden": false,
        "description": "Release waiter"
      },
      {
        "input": "jt = JoinTracker(); jt.thread_finished(5)",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "No waiters"
      }
    ],
    "hints": [
      "Track both directions",
      "Release all waiters when thread finishes"
    ]
  },
  {
    "id": "cs301-ex-2-9",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Amdahl's Law",
    "description": "Calculate speedup using Amdahl's Law given parallel fraction and number of processors.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def amdahls_speedup(parallel_fraction, num_processors):\n    # Return theoretical speedup\n    pass",
    "solution": "def amdahls_speedup(parallel_fraction, num_processors):\n    serial_fraction = 1 - parallel_fraction\n    speedup = 1 / (serial_fraction + parallel_fraction / num_processors)\n    return round(speedup, 2)",
    "testCases": [
      {
        "input": "0.75, 4",
        "expectedOutput": "2.29",
        "isHidden": false,
        "description": "75% parallel, 4 cores"
      },
      {
        "input": "0.5, 2",
        "expectedOutput": "1.33",
        "isHidden": false,
        "description": "50% parallel, 2 cores"
      },
      {
        "input": "1.0, 8",
        "expectedOutput": "8.0",
        "isHidden": true,
        "description": "100% parallel"
      }
    ],
    "hints": [
      "Speedup = 1 / (S + P/N)",
      "S = serial fraction, P = parallel fraction"
    ]
  },
  {
    "id": "cs301-ex-2-10",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread State Machine",
    "description": "Implement a thread with states: created, running, blocked, terminated.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class Thread:\n    def __init__(self, tid):\n        pass\n    \n    def start(self):\n        pass\n    \n    def block(self):\n        pass\n    \n    def unblock(self):\n        pass\n    \n    def terminate(self):\n        pass",
    "solution": "class Thread:\n    def __init__(self, tid):\n        self.tid = tid\n        self.state = \"created\"\n\n    def start(self):\n        if self.state == \"created\":\n            self.state = \"running\"\n            return True\n        return False\n\n    def block(self):\n        if self.state == \"running\":\n            self.state = \"blocked\"\n            return True\n        return False\n\n    def unblock(self):\n        if self.state == \"blocked\":\n            self.state = \"running\"\n            return True\n        return False\n\n    def terminate(self):\n        if self.state in (\"running\", \"blocked\"):\n            self.state = \"terminated\"\n            return True\n        return False",
    "testCases": [
      {
        "input": "t = Thread(1); t.start(); t.state",
        "expectedOutput": "\"running\"",
        "isHidden": false,
        "description": "Start thread"
      },
      {
        "input": "t = Thread(1); t.start(); t.block(); t.state",
        "expectedOutput": "\"blocked\"",
        "isHidden": false,
        "description": "Block thread"
      }
    ],
    "hints": [
      "Check current state before transitioning",
      "Only valid transitions should succeed"
    ]
  },
  {
    "id": "cs301-ex-2-11",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Parallel Loop Work Distribution",
    "description": "Calculate how iterations are distributed among threads in a parallel for loop.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def distribute_iterations(total_iterations, num_threads):\n    # Return list of (start, end) for each thread\n    pass",
    "solution": "def distribute_iterations(total_iterations, num_threads):\n    result = []\n    base = total_iterations // num_threads\n    remainder = total_iterations % num_threads\n    start = 0\n    for i in range(num_threads):\n        count = base + (1 if i < remainder else 0)\n        result.append((start, start + count))\n        start += count\n    return result",
    "testCases": [
      {
        "input": "10, 3",
        "expectedOutput": "[(0, 4), (4, 7), (7, 10)]",
        "isHidden": false,
        "description": "10 iterations, 3 threads"
      },
      {
        "input": "8, 4",
        "expectedOutput": "[(0, 2), (2, 4), (4, 6), (6, 8)]",
        "isHidden": false,
        "description": "Even distribution"
      }
    ],
    "hints": [
      "Divide evenly, distribute remainder",
      "First threads get extra iteration"
    ]
  },
  {
    "id": "cs301-ex-2-12",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Cancellation Manager",
    "description": "Implement cancellation with deferred mode (threads check cancellation points).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class CancellationManager:\n    def __init__(self):\n        pass\n    \n    def request_cancel(self, tid):\n        pass\n    \n    def check_cancellation(self, tid):\n        # Return True if thread should terminate\n        pass\n    \n    def clear_cancellation(self, tid):\n        pass",
    "solution": "class CancellationManager:\n    def __init__(self):\n        self.pending_cancellations = set()\n\n    def request_cancel(self, tid):\n        self.pending_cancellations.add(tid)\n\n    def check_cancellation(self, tid):\n        return tid in self.pending_cancellations\n\n    def clear_cancellation(self, tid):\n        self.pending_cancellations.discard(tid)",
    "testCases": [
      {
        "input": "cm = CancellationManager(); cm.request_cancel(1); cm.check_cancellation(1)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Cancellation requested"
      },
      {
        "input": "cm = CancellationManager(); cm.check_cancellation(1)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No cancellation"
      }
    ],
    "hints": [
      "Track cancelled thread IDs in a set",
      "Threads check at cancellation points"
    ]
  },
  {
    "id": "cs301-ex-2-13",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Barrier Synchronization",
    "description": "Implement a barrier that blocks threads until all have arrived.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class Barrier:\n    def __init__(self, num_threads):\n        pass\n    \n    def wait(self, tid):\n        # Return True if all threads have arrived, False if still waiting\n        pass\n    \n    def reset(self):\n        pass",
    "solution": "class Barrier:\n    def __init__(self, num_threads):\n        self.num_threads = num_threads\n        self.arrived = set()\n\n    def wait(self, tid):\n        self.arrived.add(tid)\n        return len(self.arrived) >= self.num_threads\n\n    def reset(self):\n        self.arrived.clear()",
    "testCases": [
      {
        "input": "b = Barrier(2); b.wait(1)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "First arrival"
      },
      {
        "input": "b = Barrier(2); b.wait(1); b.wait(2)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "All arrived"
      }
    ],
    "hints": [
      "Track arrived threads",
      "All must arrive before any can proceed"
    ]
  },
  {
    "id": "cs301-ex-2-14",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Priority Scheduler",
    "description": "Schedule threads based on priority (lower number = higher priority).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "import heapq\n\nclass PriorityScheduler:\n    def __init__(self):\n        pass\n    \n    def add_thread(self, tid, priority):\n        pass\n    \n    def get_highest_priority(self):\n        # Return tid of highest priority thread (don't remove)\n        pass\n    \n    def remove_thread(self, tid):\n        pass",
    "solution": "import heapq\n\nclass PriorityScheduler:\n    def __init__(self):\n        self.heap = []\n        self.tid_to_priority = {}\n\n    def add_thread(self, tid, priority):\n        heapq.heappush(self.heap, (priority, tid))\n        self.tid_to_priority[tid] = priority\n\n    def get_highest_priority(self):\n        while self.heap:\n            priority, tid = self.heap[0]\n            if tid in self.tid_to_priority and self.tid_to_priority[tid] == priority:\n                return tid\n            heapq.heappop(self.heap)\n        return None\n\n    def remove_thread(self, tid):\n        if tid in self.tid_to_priority:\n            del self.tid_to_priority[tid]",
    "testCases": [
      {
        "input": "ps = PriorityScheduler(); ps.add_thread(1, 5); ps.add_thread(2, 1); ps.get_highest_priority()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Highest priority"
      },
      {
        "input": "ps = PriorityScheduler(); ps.add_thread(1, 1); ps.remove_thread(1); ps.get_highest_priority()",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "After removal"
      }
    ],
    "hints": [
      "Use heap for efficient priority lookup",
      "Handle lazy deletion"
    ]
  },
  {
    "id": "cs301-ex-2-15",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "CPU Affinity Manager",
    "description": "Manage thread-to-CPU affinity settings.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class AffinityManager:\n    def __init__(self, num_cpus):\n        pass\n    \n    def set_affinity(self, tid, cpu_set):\n        # cpu_set is list of allowed CPUs\n        pass\n    \n    def get_affinity(self, tid):\n        pass\n    \n    def can_run_on(self, tid, cpu):\n        pass",
    "solution": "class AffinityManager:\n    def __init__(self, num_cpus):\n        self.num_cpus = num_cpus\n        self.affinities = {}\n\n    def set_affinity(self, tid, cpu_set):\n        valid_cpus = [c for c in cpu_set if 0 <= c < self.num_cpus]\n        self.affinities[tid] = set(valid_cpus)\n\n    def get_affinity(self, tid):\n        return self.affinities.get(tid, set(range(self.num_cpus)))\n\n    def can_run_on(self, tid, cpu):\n        affinity = self.get_affinity(tid)\n        return cpu in affinity",
    "testCases": [
      {
        "input": "am = AffinityManager(4); am.set_affinity(1, [0, 1]); am.can_run_on(1, 0)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Allowed CPU"
      },
      {
        "input": "am = AffinityManager(4); am.set_affinity(1, [0, 1]); am.can_run_on(1, 2)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not allowed"
      }
    ],
    "hints": [
      "Default affinity is all CPUs",
      "Store as set for O(1) lookup"
    ]
  },
  {
    "id": "cs301-ex-2-16",
    "subjectId": "cs301",
    "topicId": "cs301-t2",
    "title": "Thread Signal Delivery",
    "description": "Simulate signal delivery to threads.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class SignalManager:\n    def __init__(self):\n        pass\n    \n    def register_handler(self, tid, signal, handler_name):\n        pass\n    \n    def send_signal(self, tid, signal):\n        # Return handler name or None if no handler\n        pass\n    \n    def get_pending_signals(self, tid):\n        pass",
    "solution": "class SignalManager:\n    def __init__(self):\n        self.handlers = {}  # (tid, signal) -> handler\n        self.pending = {}   # tid -> [signals]\n\n    def register_handler(self, tid, signal, handler_name):\n        self.handlers[(tid, signal)] = handler_name\n\n    def send_signal(self, tid, signal):\n        if (tid, signal) in self.handlers:\n            return self.handlers[(tid, signal)]\n        # Queue if no handler\n        if tid not in self.pending:\n            self.pending[tid] = []\n        self.pending[tid].append(signal)\n        return None\n\n    def get_pending_signals(self, tid):\n        return self.pending.get(tid, [])",
    "testCases": [
      {
        "input": "sm = SignalManager(); sm.register_handler(1, \"SIGINT\", \"handle_int\"); sm.send_signal(1, \"SIGINT\")",
        "expectedOutput": "\"handle_int\"",
        "isHidden": false,
        "description": "Handler exists"
      },
      {
        "input": "sm = SignalManager(); sm.send_signal(1, \"SIGTERM\"); sm.get_pending_signals(1)",
        "expectedOutput": "[\"SIGTERM\"]",
        "isHidden": false,
        "description": "No handler, queued"
      }
    ],
    "hints": [
      "Key by (tid, signal) for handlers",
      "Queue signals without handlers"
    ]
  },
  {
    "id": "cs301-ex-3-1",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "FCFS Waiting Time",
    "description": "Calculate average waiting time for FCFS scheduling given burst times (all arrive at time 0).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def fcfs_avg_waiting_time(burst_times):\n    # Return average waiting time\n    pass",
    "solution": "def fcfs_avg_waiting_time(burst_times):\n    if not burst_times:\n        return 0\n    waiting_times = []\n    current_time = 0\n    for burst in burst_times:\n        waiting_times.append(current_time)\n        current_time += burst\n    return sum(waiting_times) / len(waiting_times)",
    "testCases": [
      {
        "input": "[24, 3, 3]",
        "expectedOutput": "17.0",
        "isHidden": false,
        "description": "Example from textbook"
      },
      {
        "input": "[5, 5, 5]",
        "expectedOutput": "5.0",
        "isHidden": false,
        "description": "Equal burst times"
      },
      {
        "input": "[1]",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Single process"
      }
    ],
    "hints": [
      "First process waits 0",
      "Each subsequent process waits for all previous to complete"
    ]
  },
  {
    "id": "cs301-ex-3-2",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "SJF Non-Preemptive",
    "description": "Return the execution order for non-preemptive SJF (all arrive at time 0).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def sjf_order(processes):\n    # processes: list of (pid, burst_time)\n    # Return list of pids in execution order\n    pass",
    "solution": "def sjf_order(processes):\n    sorted_procs = sorted(processes, key=lambda x: (x[1], x[0]))\n    return [p[0] for p in sorted_procs]",
    "testCases": [
      {
        "input": "[(1, 6), (2, 8), (3, 2), (4, 4)]",
        "expectedOutput": "[3, 4, 1, 2]",
        "isHidden": false,
        "description": "Sort by burst"
      },
      {
        "input": "[(1, 5), (2, 5)]",
        "expectedOutput": "[1, 2]",
        "isHidden": false,
        "description": "Tie-break by PID"
      }
    ],
    "hints": [
      "Sort by burst time",
      "Use PID as tiebreaker"
    ]
  },
  {
    "id": "cs301-ex-3-3",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Round Robin Simulation",
    "description": "Simulate Round Robin and return the completion times for each process.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def round_robin(processes, quantum):\n    # processes: list of (pid, burst_time)\n    # Return dict {pid: completion_time}\n    pass",
    "solution": "def round_robin(processes, quantum):\n    from collections import deque\n    queue = deque()\n    remaining = {}\n    for pid, burst in processes:\n        queue.append(pid)\n        remaining[pid] = burst\n\n    completion = {}\n    time = 0\n    while queue:\n        pid = queue.popleft()\n        run_time = min(quantum, remaining[pid])\n        time += run_time\n        remaining[pid] -= run_time\n        if remaining[pid] > 0:\n            queue.append(pid)\n        else:\n            completion[pid] = time\n    return completion",
    "testCases": [
      {
        "input": "[(1, 10), (2, 4), (3, 2)], 4",
        "expectedOutput": "{1: 16, 2: 10, 3: 6}",
        "isHidden": false,
        "description": "Three processes"
      },
      {
        "input": "[(1, 3)], 5",
        "expectedOutput": "{1: 3}",
        "isHidden": false,
        "description": "Single process"
      }
    ],
    "hints": [
      "Use a queue for round robin",
      "Process runs for min(quantum, remaining)"
    ]
  },
  {
    "id": "cs301-ex-3-4",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Priority Scheduling Order",
    "description": "Return execution order for non-preemptive priority scheduling (lower = higher priority).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def priority_order(processes):\n    # processes: list of (pid, burst, priority)\n    # Return list of pids in execution order\n    pass",
    "solution": "def priority_order(processes):\n    sorted_procs = sorted(processes, key=lambda x: (x[2], x[0]))\n    return [p[0] for p in sorted_procs]",
    "testCases": [
      {
        "input": "[(1, 10, 3), (2, 1, 1), (3, 2, 4)]",
        "expectedOutput": "[2, 1, 3]",
        "isHidden": false,
        "description": "Priority order"
      },
      {
        "input": "[(1, 5, 2), (2, 3, 2)]",
        "expectedOutput": "[1, 2]",
        "isHidden": false,
        "description": "Same priority"
      }
    ],
    "hints": [
      "Sort by priority",
      "Use PID as tiebreaker"
    ]
  },
  {
    "id": "cs301-ex-3-5",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Calculate Turnaround Time",
    "description": "Calculate turnaround time for each process given arrival and completion times.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def turnaround_times(processes, completion_times):\n    # processes: list of (pid, arrival_time)\n    # completion_times: dict {pid: completion}\n    # Return dict {pid: turnaround_time}\n    pass",
    "solution": "def turnaround_times(processes, completion_times):\n    result = {}\n    for pid, arrival in processes:\n        result[pid] = completion_times[pid] - arrival\n    return result",
    "testCases": [
      {
        "input": "[(1, 0), (2, 1)], {1: 5, 2: 8}",
        "expectedOutput": "{1: 5, 2: 7}",
        "isHidden": false,
        "description": "Two processes"
      },
      {
        "input": "[(1, 2)], {1: 10}",
        "expectedOutput": "{1: 8}",
        "isHidden": false,
        "description": "Single process"
      }
    ],
    "hints": [
      "Turnaround = completion - arrival",
      "Simple subtraction"
    ]
  },
  {
    "id": "cs301-ex-3-6",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "CPU Utilization Calculator",
    "description": "Calculate CPU utilization percentage given busy and total time.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def cpu_utilization(busy_time, total_time):\n    # Return utilization as percentage (0-100)\n    pass",
    "solution": "def cpu_utilization(busy_time, total_time):\n    if total_time == 0:\n        return 0\n    return (busy_time / total_time) * 100",
    "testCases": [
      {
        "input": "80, 100",
        "expectedOutput": "80.0",
        "isHidden": false,
        "description": "80% utilization"
      },
      {
        "input": "45, 50",
        "expectedOutput": "90.0",
        "isHidden": false,
        "description": "90% utilization"
      }
    ],
    "hints": [
      "Utilization = busy/total * 100",
      "Handle division by zero"
    ]
  },
  {
    "id": "cs301-ex-3-7",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Multilevel Queue Scheduler",
    "description": "Implement a two-level queue: foreground (RR with quantum 4) and background (FCFS). Foreground has priority.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class MultilevelQueue:\n    def __init__(self):\n        pass\n    \n    def add_process(self, pid, queue_type, burst):\n        # queue_type: \"foreground\" or \"background\"\n        pass\n    \n    def get_next(self):\n        # Return (pid, run_time) or None\n        pass",
    "solution": "class MultilevelQueue:\n    def __init__(self):\n        self.foreground = []  # (pid, remaining)\n        self.background = []  # (pid, remaining)\n\n    def add_process(self, pid, queue_type, burst):\n        if queue_type == \"foreground\":\n            self.foreground.append([pid, burst])\n        else:\n            self.background.append([pid, burst])\n\n    def get_next(self):\n        if self.foreground:\n            pid, remaining = self.foreground[0]\n            run_time = min(4, remaining)\n            self.foreground[0][1] -= run_time\n            if self.foreground[0][1] <= 0:\n                self.foreground.pop(0)\n            else:\n                self.foreground.append(self.foreground.pop(0))\n            return (pid, run_time)\n        elif self.background:\n            pid, remaining = self.background.pop(0)\n            return (pid, remaining)\n        return None",
    "testCases": [
      {
        "input": "mq = MultilevelQueue(); mq.add_process(1, \"foreground\", 6); mq.get_next()",
        "expectedOutput": "(1, 4)",
        "isHidden": false,
        "description": "Foreground RR"
      },
      {
        "input": "mq = MultilevelQueue(); mq.add_process(1, \"background\", 10); mq.get_next()",
        "expectedOutput": "(1, 10)",
        "isHidden": false,
        "description": "Background FCFS"
      }
    ],
    "hints": [
      "Check foreground first",
      "Foreground uses RR, background uses FCFS"
    ]
  },
  {
    "id": "cs301-ex-3-8",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Response Time Calculator",
    "description": "Calculate response time (time from arrival to first execution).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def response_times(processes, first_run_times):\n    # processes: list of (pid, arrival_time)\n    # first_run_times: dict {pid: first_run_time}\n    # Return dict {pid: response_time}\n    pass",
    "solution": "def response_times(processes, first_run_times):\n    result = {}\n    for pid, arrival in processes:\n        result[pid] = first_run_times[pid] - arrival\n    return result",
    "testCases": [
      {
        "input": "[(1, 0), (2, 2)], {1: 0, 2: 5}",
        "expectedOutput": "{1: 0, 2: 3}",
        "isHidden": false,
        "description": "Two processes"
      },
      {
        "input": "[(1, 1)], {1: 3}",
        "expectedOutput": "{1: 2}",
        "isHidden": false,
        "description": "Single process"
      }
    ],
    "hints": [
      "Response = first_run - arrival",
      "First process has 0 response if starts immediately"
    ]
  },
  {
    "id": "cs301-ex-3-9",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Priority Aging",
    "description": "Implement aging: increase priority (decrease value) for waiting processes each time unit.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def apply_aging(processes, aging_rate):\n    # processes: list of [pid, burst, priority, wait_time]\n    # Decrease priority by aging_rate for each unit of wait_time\n    # Return updated processes\n    pass",
    "solution": "def apply_aging(processes, aging_rate):\n    result = []\n    for pid, burst, priority, wait_time in processes:\n        new_priority = max(0, priority - (wait_time * aging_rate))\n        result.append([pid, burst, new_priority, wait_time])\n    return result",
    "testCases": [
      {
        "input": "[[1, 10, 10, 5]], 1",
        "expectedOutput": "[[1, 10, 5, 5]]",
        "isHidden": false,
        "description": "Age by 5"
      },
      {
        "input": "[[1, 5, 3, 10]], 1",
        "expectedOutput": "[[1, 5, 0, 10]]",
        "isHidden": false,
        "description": "Priority floor at 0"
      }
    ],
    "hints": [
      "New priority = old - (wait * rate)",
      "Don't go below 0"
    ]
  },
  {
    "id": "cs301-ex-3-10",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Gantt Chart",
    "description": "Generate a Gantt chart representation for a schedule.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def gantt_chart(schedule):\n    # schedule: list of (pid, start, end)\n    # Return string representation\n    pass",
    "solution": "def gantt_chart(schedule):\n    result = []\n    for pid, start, end in schedule:\n        result.append(f\"P{pid}[{start}-{end}]\")\n    return \" | \".join(result)",
    "testCases": [
      {
        "input": "[(1, 0, 5), (2, 5, 8)]",
        "expectedOutput": "\"P1[0-5] | P2[5-8]\"",
        "isHidden": false,
        "description": "Two processes"
      },
      {
        "input": "[(1, 0, 3), (2, 3, 6), (1, 6, 10)]",
        "expectedOutput": "\"P1[0-3] | P2[3-6] | P1[6-10]\"",
        "isHidden": false,
        "description": "With preemption"
      }
    ],
    "hints": [
      "Format each segment",
      "Join with separator"
    ]
  },
  {
    "id": "cs301-ex-3-11",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "System Throughput",
    "description": "Calculate throughput (processes completed per time unit).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def throughput(num_completed, total_time):\n    # Return throughput as processes per time unit\n    pass",
    "solution": "def throughput(num_completed, total_time):\n    if total_time == 0:\n        return 0\n    return num_completed / total_time",
    "testCases": [
      {
        "input": "10, 100",
        "expectedOutput": "0.1",
        "isHidden": false,
        "description": "10 in 100 time units"
      },
      {
        "input": "5, 20",
        "expectedOutput": "0.25",
        "isHidden": false,
        "description": "5 in 20 time units"
      }
    ],
    "hints": [
      "Throughput = completed / time",
      "Handle zero time"
    ]
  },
  {
    "id": "cs301-ex-3-12",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "SRTF Next Process",
    "description": "Given current time and process states, select next process for SRTF (Shortest Remaining Time First).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def srtf_select(current_time, processes):\n    # processes: list of (pid, arrival, remaining)\n    # Return pid of process to run, or None\n    pass",
    "solution": "def srtf_select(current_time, processes):\n    available = [(pid, remaining) for pid, arrival, remaining\n                 in processes if arrival <= current_time and remaining > 0]\n    if not available:\n        return None\n    available.sort(key=lambda x: (x[1], x[0]))\n    return available[0][0]",
    "testCases": [
      {
        "input": "5, [(1, 0, 10), (2, 3, 5), (3, 5, 2)]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Shortest remaining"
      },
      {
        "input": "1, [(1, 0, 5), (2, 5, 2)]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Only one available"
      }
    ],
    "hints": [
      "Filter by arrival time",
      "Sort by remaining time"
    ]
  },
  {
    "id": "cs301-ex-3-13",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Load Balancing",
    "description": "Distribute processes across CPUs to balance load (by total burst time).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def balance_load(processes, num_cpus):\n    # processes: list of (pid, burst)\n    # Return dict {cpu_id: [pids]}\n    pass",
    "solution": "def balance_load(processes, num_cpus):\n    import heapq\n    # Min heap of (load, cpu_id)\n    cpu_loads = [(0, i) for i in range(num_cpus)]\n    assignment = {i: [] for i in range(num_cpus)}\n\n    # Assign largest jobs first for better balance\n    sorted_procs = sorted(processes, key=lambda x: -x[1])\n    for pid, burst in sorted_procs:\n        load, cpu_id = heapq.heappop(cpu_loads)\n        assignment[cpu_id].append(pid)\n        heapq.heappush(cpu_loads, (load + burst, cpu_id))\n\n    return assignment",
    "testCases": [
      {
        "input": "[(1, 10), (2, 5), (3, 5)], 2",
        "expectedOutput": "{0: [1], 1: [2, 3]}",
        "isHidden": false,
        "description": "Balance two CPUs"
      },
      {
        "input": "[(1, 5)], 2",
        "expectedOutput": "{0: [1], 1: []}",
        "isHidden": false,
        "description": "Single process"
      }
    ],
    "hints": [
      "Use greedy: assign to least loaded CPU",
      "Process largest jobs first"
    ]
  },
  {
    "id": "cs301-ex-3-14",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Rate Monotonic Schedulability",
    "description": "Check if a task set is schedulable under Rate Monotonic using the utilization bound.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def is_rm_schedulable(tasks):\n    # tasks: list of (computation_time, period)\n    # Return True if schedulable under RM\n    pass",
    "solution": "def is_rm_schedulable(tasks):\n    import math\n    n = len(tasks)\n    if n == 0:\n        return True\n    utilization = sum(c / p for c, p in tasks)\n    bound = n * (2 ** (1/n) - 1)\n    return utilization <= bound",
    "testCases": [
      {
        "input": "[(1, 4), (1, 5), (1, 10)]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Schedulable"
      },
      {
        "input": "[(2, 4), (2, 5), (2, 10)]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not schedulable"
      }
    ],
    "hints": [
      "Utilization = sum(C_i / P_i)",
      "Bound = n * (2^(1/n) - 1)"
    ]
  },
  {
    "id": "cs301-ex-3-15",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "EDF Next Process",
    "description": "Select next process for Earliest Deadline First scheduling.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def edf_select(current_time, processes):\n    # processes: list of (pid, arrival, remaining, deadline)\n    # Return pid of process to run, or None\n    pass",
    "solution": "def edf_select(current_time, processes):\n    available = [(pid, deadline) for pid, arrival, remaining, deadline\n                 in processes if arrival <= current_time and remaining > 0]\n    if not available:\n        return None\n    available.sort(key=lambda x: (x[1], x[0]))\n    return available[0][0]",
    "testCases": [
      {
        "input": "0, [(1, 0, 2, 5), (2, 0, 1, 3)]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Earliest deadline first"
      },
      {
        "input": "5, [(1, 0, 2, 10), (2, 10, 1, 15)]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Only one available"
      }
    ],
    "hints": [
      "Filter by arrival time",
      "Sort by deadline"
    ]
  },
  {
    "id": "cs301-ex-3-16",
    "subjectId": "cs301",
    "topicId": "cs301-t3",
    "title": "Detect Convoy Effect",
    "description": "Detect potential convoy effect: short processes waiting behind long ones in FCFS.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def detect_convoy(processes, threshold_ratio):\n    # processes: list of burst times in arrival order\n    # Return True if any short process waits for process > threshold_ratio times longer\n    pass",
    "solution": "def detect_convoy(processes, threshold_ratio):\n    for i in range(1, len(processes)):\n        for j in range(i):\n            if processes[j] > processes[i] * threshold_ratio:\n                return True\n    return False",
    "testCases": [
      {
        "input": "[100, 1, 1, 1], 5",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Convoy detected"
      },
      {
        "input": "[5, 5, 5], 2",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No convoy"
      }
    ],
    "hints": [
      "Check if any early process is much longer than later ones",
      "Compare ratios"
    ]
  },
  {
    "id": "cs301-ex-4-1",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Race Condition Check",
    "description": "Given operations from two threads, detect if a race condition could occur.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def has_race_condition(thread1_ops, thread2_ops, shared_vars):\n    # ops are lists of (\"read\", var) or (\"write\", var)\n    # Return True if race condition possible\n    pass",
    "solution": "def has_race_condition(thread1_ops, thread2_ops, shared_vars):\n    t1_writes = {var for op, var in thread1_ops if op == \"write\" and var in shared_vars}\n    t2_writes = {var for op, var in thread2_ops if op == \"write\" and var in shared_vars}\n    t1_reads = {var for op, var in thread1_ops if op == \"read\" and var in shared_vars}\n    t2_reads = {var for op, var in thread2_ops if op == \"read\" and var in shared_vars}\n\n    # Race: write-write or read-write on same variable\n    if t1_writes & t2_writes:\n        return True\n    if t1_writes & t2_reads or t2_writes & t1_reads:\n        return True\n    return False",
    "testCases": [
      {
        "input": "[(\"read\", \"x\"), (\"write\", \"x\")], [(\"write\", \"x\")], {\"x\"}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Write-write race"
      },
      {
        "input": "[(\"read\", \"x\")], [(\"read\", \"x\")], {\"x\"}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Read-read no race"
      }
    ],
    "hints": [
      "Race requires at least one write",
      "Check write-write and read-write conflicts"
    ]
  },
  {
    "id": "cs301-ex-4-2",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Critical Section Validator",
    "description": "Check if a solution satisfies mutual exclusion given execution traces.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def validates_mutual_exclusion(traces):\n    # traces: list of (time, thread_id, \"enter\"|\"exit\")\n    # Return True if at most one thread in CS at any time\n    pass",
    "solution": "def validates_mutual_exclusion(traces):\n    sorted_traces = sorted(traces, key=lambda x: x[0])\n    in_cs = set()\n    for time, tid, action in sorted_traces:\n        if action == \"enter\":\n            if in_cs:  # Someone already in CS\n                return False\n            in_cs.add(tid)\n        else:  # exit\n            in_cs.discard(tid)\n    return True",
    "testCases": [
      {
        "input": "[(0, 1, \"enter\"), (5, 1, \"exit\"), (6, 2, \"enter\")]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Sequential access"
      },
      {
        "input": "[(0, 1, \"enter\"), (2, 2, \"enter\"), (5, 1, \"exit\")]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Overlap violation"
      }
    ],
    "hints": [
      "Sort by time",
      "Track who is in CS"
    ]
  },
  {
    "id": "cs301-ex-4-3",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Simple Mutex",
    "description": "Implement a mutex with lock and unlock operations.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class Mutex:\n    def __init__(self):\n        pass\n    \n    def lock(self, thread_id):\n        # Return True if acquired, False if already held\n        pass\n    \n    def unlock(self, thread_id):\n        # Return True if released, False if not owner\n        pass\n    \n    def is_locked(self):\n        pass",
    "solution": "class Mutex:\n    def __init__(self):\n        self.owner = None\n\n    def lock(self, thread_id):\n        if self.owner is None:\n            self.owner = thread_id\n            return True\n        return False\n\n    def unlock(self, thread_id):\n        if self.owner == thread_id:\n            self.owner = None\n            return True\n        return False\n\n    def is_locked(self):\n        return self.owner is not None",
    "testCases": [
      {
        "input": "m = Mutex(); m.lock(1)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Acquire free lock"
      },
      {
        "input": "m = Mutex(); m.lock(1); m.lock(2)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Already held"
      },
      {
        "input": "m = Mutex(); m.lock(1); m.unlock(2)",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Wrong owner"
      }
    ],
    "hints": [
      "Track the owner",
      "Only owner can unlock"
    ]
  },
  {
    "id": "cs301-ex-4-4",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Counting Semaphore",
    "description": "Implement a counting semaphore with wait and signal operations.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class Semaphore:\n    def __init__(self, initial):\n        pass\n    \n    def wait(self):\n        # Return True if acquired, False if would block\n        pass\n    \n    def signal(self):\n        pass\n    \n    def get_value(self):\n        pass",
    "solution": "class Semaphore:\n    def __init__(self, initial):\n        self.value = initial\n\n    def wait(self):\n        if self.value > 0:\n            self.value -= 1\n            return True\n        return False\n\n    def signal(self):\n        self.value += 1\n\n    def get_value(self):\n        return self.value",
    "testCases": [
      {
        "input": "s = Semaphore(2); s.wait(); s.wait(); s.wait()",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Semaphore exhausted"
      },
      {
        "input": "s = Semaphore(0); s.signal(); s.wait()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Signal then wait"
      }
    ],
    "hints": [
      "Wait decrements if positive",
      "Signal always increments"
    ]
  },
  {
    "id": "cs301-ex-4-5",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Bounded Buffer",
    "description": "Implement a bounded buffer for producer-consumer with size tracking.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class BoundedBuffer:\n    def __init__(self, capacity):\n        pass\n    \n    def produce(self, item):\n        # Return True if added, False if full\n        pass\n    \n    def consume(self):\n        # Return item or None if empty\n        pass\n    \n    def is_empty(self):\n        pass\n    \n    def is_full(self):\n        pass",
    "solution": "class BoundedBuffer:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.buffer = []\n\n    def produce(self, item):\n        if len(self.buffer) < self.capacity:\n            self.buffer.append(item)\n            return True\n        return False\n\n    def consume(self):\n        if self.buffer:\n            return self.buffer.pop(0)\n        return None\n\n    def is_empty(self):\n        return len(self.buffer) == 0\n\n    def is_full(self):\n        return len(self.buffer) >= self.capacity",
    "testCases": [
      {
        "input": "bb = BoundedBuffer(2); bb.produce(1); bb.produce(2); bb.produce(3)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Buffer full"
      },
      {
        "input": "bb = BoundedBuffer(2); bb.produce(1); bb.consume()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Produce and consume"
      }
    ],
    "hints": [
      "Check capacity before producing",
      "FIFO order"
    ]
  },
  {
    "id": "cs301-ex-4-6",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Readers-Writers Counter",
    "description": "Track readers and writers for readers-writers problem.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class ReadersWriters:\n    def __init__(self):\n        pass\n    \n    def start_read(self):\n        # Return True if can start reading\n        pass\n    \n    def end_read(self):\n        pass\n    \n    def start_write(self):\n        # Return True if can start writing\n        pass\n    \n    def end_write(self):\n        pass",
    "solution": "class ReadersWriters:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n\n    def start_read(self):\n        if not self.writer:\n            self.readers += 1\n            return True\n        return False\n\n    def end_read(self):\n        if self.readers > 0:\n            self.readers -= 1\n\n    def start_write(self):\n        if self.readers == 0 and not self.writer:\n            self.writer = True\n            return True\n        return False\n\n    def end_write(self):\n        self.writer = False",
    "testCases": [
      {
        "input": "rw = ReadersWriters(); rw.start_read(); rw.start_read()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Multiple readers OK"
      },
      {
        "input": "rw = ReadersWriters(); rw.start_read(); rw.start_write()",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No write while reading"
      },
      {
        "input": "rw = ReadersWriters(); rw.start_write(); rw.start_read()",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No read while writing"
      }
    ],
    "hints": [
      "Multiple readers allowed",
      "Writer needs exclusive access"
    ]
  },
  {
    "id": "cs301-ex-4-7",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Dining Philosophers State",
    "description": "Track fork states for dining philosophers problem.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class DiningTable:\n    def __init__(self, n):\n        # n philosophers, n forks\n        pass\n    \n    def pickup_forks(self, philosopher_id):\n        # Try to pick up both forks, return True if successful\n        pass\n    \n    def putdown_forks(self, philosopher_id):\n        pass\n    \n    def can_eat(self, philosopher_id):\n        pass",
    "solution": "class DiningTable:\n    def __init__(self, n):\n        self.n = n\n        self.forks = [None] * n  # None = free, else holder id\n\n    def pickup_forks(self, philosopher_id):\n        left = philosopher_id\n        right = (philosopher_id + 1) % self.n\n        if self.forks[left] is None and self.forks[right] is None:\n            self.forks[left] = philosopher_id\n            self.forks[right] = philosopher_id\n            return True\n        return False\n\n    def putdown_forks(self, philosopher_id):\n        left = philosopher_id\n        right = (philosopher_id + 1) % self.n\n        if self.forks[left] == philosopher_id:\n            self.forks[left] = None\n        if self.forks[right] == philosopher_id:\n            self.forks[right] = None\n\n    def can_eat(self, philosopher_id):\n        left = philosopher_id\n        right = (philosopher_id + 1) % self.n\n        return self.forks[left] == philosopher_id and self.forks[right] == philosopher_id",
    "testCases": [
      {
        "input": "dt = DiningTable(5); dt.pickup_forks(0)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Pick up free forks"
      },
      {
        "input": "dt = DiningTable(5); dt.pickup_forks(0); dt.pickup_forks(1)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Neighbor conflict"
      }
    ],
    "hints": [
      "Each philosopher needs two adjacent forks",
      "Both forks must be free"
    ]
  },
  {
    "id": "cs301-ex-4-8",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Condition Variable Queue",
    "description": "Implement a simple condition variable wait queue.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class ConditionVariable:\n    def __init__(self):\n        pass\n    \n    def wait(self, thread_id):\n        # Add thread to wait queue\n        pass\n    \n    def signal(self):\n        # Wake one thread, return its id or None\n        pass\n    \n    def broadcast(self):\n        # Wake all threads, return list of ids\n        pass",
    "solution": "class ConditionVariable:\n    def __init__(self):\n        self.wait_queue = []\n\n    def wait(self, thread_id):\n        self.wait_queue.append(thread_id)\n\n    def signal(self):\n        if self.wait_queue:\n            return self.wait_queue.pop(0)\n        return None\n\n    def broadcast(self):\n        all_waiting = self.wait_queue[:]\n        self.wait_queue.clear()\n        return all_waiting",
    "testCases": [
      {
        "input": "cv = ConditionVariable(); cv.wait(1); cv.wait(2); cv.signal()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "FIFO wakeup"
      },
      {
        "input": "cv = ConditionVariable(); cv.wait(1); cv.wait(2); cv.broadcast()",
        "expectedOutput": "[1, 2]",
        "isHidden": false,
        "description": "Wake all"
      }
    ],
    "hints": [
      "Wait adds to queue",
      "Signal wakes first, broadcast wakes all"
    ]
  },
  {
    "id": "cs301-ex-4-9",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Lock Ordering Check",
    "description": "Check if locks are acquired in consistent order (for deadlock prevention).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def consistent_lock_order(sequences):\n    # sequences: list of lock acquisition sequences per thread\n    # Each sequence is list of lock ids\n    # Return True if all follow consistent ordering\n    pass",
    "solution": "def consistent_lock_order(sequences):\n    # Build a partial order from each sequence\n    order_constraints = set()\n    for seq in sequences:\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                order_constraints.add((seq[i], seq[j]))\n\n    # Check for conflicts (a < b and b < a)\n    for a, b in order_constraints:\n        if (b, a) in order_constraints:\n            return False\n    return True",
    "testCases": [
      {
        "input": "[[1, 2, 3], [1, 2]]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Consistent order"
      },
      {
        "input": "[[1, 2], [2, 1]]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Conflicting order"
      }
    ],
    "hints": [
      "Build ordering constraints",
      "Check for cycles in order"
    ]
  },
  {
    "id": "cs301-ex-4-10",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Spinlock with Retry Count",
    "description": "Implement a spinlock that tracks spin attempts.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class Spinlock:\n    def __init__(self):\n        pass\n    \n    def try_lock(self, thread_id):\n        # Return True if acquired, False otherwise\n        pass\n    \n    def unlock(self, thread_id):\n        pass\n    \n    def get_contention_count(self):\n        # Return number of failed lock attempts\n        pass",
    "solution": "class Spinlock:\n    def __init__(self):\n        self.owner = None\n        self.contention_count = 0\n\n    def try_lock(self, thread_id):\n        if self.owner is None:\n            self.owner = thread_id\n            return True\n        self.contention_count += 1\n        return False\n\n    def unlock(self, thread_id):\n        if self.owner == thread_id:\n            self.owner = None\n\n    def get_contention_count(self):\n        return self.contention_count",
    "testCases": [
      {
        "input": "sl = Spinlock(); sl.try_lock(1); sl.try_lock(2); sl.get_contention_count()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "One contention"
      },
      {
        "input": "sl = Spinlock(); sl.try_lock(1)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Acquire free lock"
      }
    ],
    "hints": [
      "Track failed attempts",
      "Only count failures"
    ]
  },
  {
    "id": "cs301-ex-4-11",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Simple Monitor",
    "description": "Implement a monitor with entry and exit tracking.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class Monitor:\n    def __init__(self):\n        pass\n    \n    def enter(self, thread_id):\n        # Return True if entered, False if already occupied\n        pass\n    \n    def exit(self, thread_id):\n        # Return True if exited, False if not inside\n        pass\n    \n    def get_occupant(self):\n        pass",
    "solution": "class Monitor:\n    def __init__(self):\n        self.occupant = None\n\n    def enter(self, thread_id):\n        if self.occupant is None:\n            self.occupant = thread_id\n            return True\n        return False\n\n    def exit(self, thread_id):\n        if self.occupant == thread_id:\n            self.occupant = None\n            return True\n        return False\n\n    def get_occupant(self):\n        return self.occupant",
    "testCases": [
      {
        "input": "m = Monitor(); m.enter(1); m.enter(2)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Only one inside"
      },
      {
        "input": "m = Monitor(); m.enter(1); m.exit(1); m.enter(2)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Exit then enter"
      }
    ],
    "hints": [
      "One thread at a time",
      "Track current occupant"
    ]
  },
  {
    "id": "cs301-ex-4-12",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Test-and-Set Lock",
    "description": "Implement a lock using test-and-set semantics.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class TASLock:\n    def __init__(self):\n        pass\n    \n    def test_and_set(self):\n        # Return old value and set to True\n        pass\n    \n    def acquire(self):\n        # Return True if acquired\n        pass\n    \n    def release(self):\n        pass",
    "solution": "class TASLock:\n    def __init__(self):\n        self.locked = False\n\n    def test_and_set(self):\n        old = self.locked\n        self.locked = True\n        return old\n\n    def acquire(self):\n        old = self.test_and_set()\n        return not old  # Acquired if old was False\n\n    def release(self):\n        self.locked = False",
    "testCases": [
      {
        "input": "tas = TASLock(); tas.acquire()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "First acquire"
      },
      {
        "input": "tas = TASLock(); tas.acquire(); tas.acquire()",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Already held"
      }
    ],
    "hints": [
      "TAS returns old value and sets to true",
      "Acquired if old was false"
    ]
  },
  {
    "id": "cs301-ex-4-13",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Compare-and-Swap",
    "description": "Implement CAS operation and use it for atomic increment.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class AtomicInteger:\n    def __init__(self, initial):\n        pass\n    \n    def compare_and_swap(self, expected, new_value):\n        # Return True if swapped, False otherwise\n        pass\n    \n    def get(self):\n        pass\n    \n    def atomic_increment(self):\n        # Increment using CAS, return new value\n        pass",
    "solution": "class AtomicInteger:\n    def __init__(self, initial):\n        self.value = initial\n\n    def compare_and_swap(self, expected, new_value):\n        if self.value == expected:\n            self.value = new_value\n            return True\n        return False\n\n    def get(self):\n        return self.value\n\n    def atomic_increment(self):\n        while True:\n            old = self.value\n            if self.compare_and_swap(old, old + 1):\n                return old + 1",
    "testCases": [
      {
        "input": "ai = AtomicInteger(5); ai.compare_and_swap(5, 10); ai.get()",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "CAS success"
      },
      {
        "input": "ai = AtomicInteger(5); ai.compare_and_swap(3, 10); ai.get()",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "CAS fail"
      }
    ],
    "hints": [
      "CAS only swaps if current == expected",
      "Retry loop for increment"
    ]
  },
  {
    "id": "cs301-ex-4-14",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Reusable Barrier",
    "description": "Implement a reusable barrier that resets after all threads pass.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class ReusableBarrier:\n    def __init__(self, n):\n        pass\n    \n    def arrive(self, thread_id):\n        # Return barrier round number when released\n        pass\n    \n    def get_round(self):\n        pass",
    "solution": "class ReusableBarrier:\n    def __init__(self, n):\n        self.n = n\n        self.count = 0\n        self.round = 0\n\n    def arrive(self, thread_id):\n        self.count += 1\n        if self.count >= self.n:\n            self.round += 1\n            self.count = 0\n            return self.round\n        # In real impl, would wait here\n        return self.round\n\n    def get_round(self):\n        return self.round",
    "testCases": [
      {
        "input": "rb = ReusableBarrier(2); rb.arrive(1); rb.arrive(2)",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "First round complete"
      },
      {
        "input": "rb = ReusableBarrier(2); rb.arrive(1); rb.arrive(2); rb.arrive(1); rb.arrive(2)",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Second round"
      }
    ],
    "hints": [
      "Reset count when all arrive",
      "Increment round number"
    ]
  },
  {
    "id": "cs301-ex-4-15",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Lock-Free Stack Simulation",
    "description": "Simulate a lock-free stack using CAS operations.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "class LockFreeStack:\n    def __init__(self):\n        pass\n    \n    def push(self, value):\n        pass\n    \n    def pop(self):\n        # Return value or None if empty\n        pass\n    \n    def peek(self):\n        pass",
    "solution": "class LockFreeStack:\n    def __init__(self):\n        self.head = None  # (value, next)\n\n    def push(self, value):\n        while True:\n            old_head = self.head\n            new_node = (value, old_head)\n            # CAS simulation\n            if self.head == old_head:\n                self.head = new_node\n                return\n\n    def pop(self):\n        while True:\n            old_head = self.head\n            if old_head is None:\n                return None\n            # CAS simulation\n            if self.head == old_head:\n                self.head = old_head[1]\n                return old_head[0]\n\n    def peek(self):\n        if self.head:\n            return self.head[0]\n        return None",
    "testCases": [
      {
        "input": "lfs = LockFreeStack(); lfs.push(1); lfs.push(2); lfs.pop()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "LIFO order"
      },
      {
        "input": "lfs = LockFreeStack(); lfs.pop()",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Empty pop"
      }
    ],
    "hints": [
      "Head points to top node",
      "CAS on head pointer"
    ]
  },
  {
    "id": "cs301-ex-4-16",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Priority Inheritance",
    "description": "Implement priority inheritance protocol for mutex.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class PriorityMutex:\n    def __init__(self):\n        pass\n    \n    def lock(self, thread_id, priority):\n        # Return effective priority of holder (for inheritance)\n        pass\n    \n    def unlock(self, thread_id):\n        pass\n    \n    def get_holder_priority(self):\n        pass",
    "solution": "class PriorityMutex:\n    def __init__(self):\n        self.holder = None\n        self.holder_base_priority = None\n        self.holder_effective_priority = None\n        self.waiting = []  # (tid, priority)\n\n    def lock(self, thread_id, priority):\n        if self.holder is None:\n            self.holder = thread_id\n            self.holder_base_priority = priority\n            self.holder_effective_priority = priority\n            return priority\n        # Priority inheritance\n        self.waiting.append((thread_id, priority))\n        if priority < self.holder_effective_priority:\n            self.holder_effective_priority = priority\n        return self.holder_effective_priority\n\n    def unlock(self, thread_id):\n        if self.holder == thread_id:\n            self.holder = None\n            self.holder_base_priority = None\n            self.holder_effective_priority = None\n            self.waiting.clear()\n\n    def get_holder_priority(self):\n        return self.holder_effective_priority",
    "testCases": [
      {
        "input": "pm = PriorityMutex(); pm.lock(1, 10); pm.lock(2, 1); pm.get_holder_priority()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Priority boosted"
      },
      {
        "input": "pm = PriorityMutex(); pm.lock(1, 5); pm.get_holder_priority()",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "No boost needed"
      }
    ],
    "hints": [
      "Lower number = higher priority",
      "Boost holder to max waiter priority"
    ]
  },
  {
    "id": "cs301-ex-5-1",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Conditions",
    "description": "Check if all four necessary conditions for deadlock are present.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def check_deadlock_conditions(mutual_exclusion, hold_and_wait, no_preemption, circular_wait):\n    # Return True if deadlock is possible\n    pass",
    "solution": "def check_deadlock_conditions(mutual_exclusion, hold_and_wait, no_preemption, circular_wait):\n    return mutual_exclusion and hold_and_wait and no_preemption and circular_wait",
    "testCases": [
      {
        "input": "True, True, True, True",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "All conditions met"
      },
      {
        "input": "True, True, False, True",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing no preemption"
      }
    ],
    "hints": [
      "All four conditions must be true",
      "Use logical AND"
    ]
  },
  {
    "id": "cs301-ex-5-2",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "RAG Cycle Detection",
    "description": "Detect cycles in a resource allocation graph (single instance resources).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def has_cycle_rag(allocation, request):\n    # allocation[p][r] = 1 if process p holds resource r\n    # request[p][r] = 1 if process p requests resource r\n    # Return True if cycle exists\n    pass",
    "solution": "def has_cycle_rag(allocation, request):\n    n_proc = len(allocation)\n    n_res = len(allocation[0]) if allocation else 0\n\n    # Build adjacency for wait-for graph\n    # p1 waits for p2 if p1 requests r and p2 holds r\n    waits_for = {i: [] for i in range(n_proc)}\n    for p1 in range(n_proc):\n        for r in range(n_res):\n            if request[p1][r]:\n                for p2 in range(n_proc):\n                    if allocation[p2][r] and p1 != p2:\n                        waits_for[p1].append(p2)\n\n    # DFS for cycle\n    def dfs(node, visited, rec_stack):\n        visited.add(node)\n        rec_stack.add(node)\n        for neighbor in waits_for[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, rec_stack):\n                    return True\n            elif neighbor in rec_stack:\n                return True\n        rec_stack.remove(node)\n        return False\n\n    visited = set()\n    for p in range(n_proc):\n        if p not in visited:\n            if dfs(p, visited, set()):\n                return True\n    return False",
    "testCases": [
      {
        "input": "[[1, 0], [0, 1]], [[0, 1], [1, 0]]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Cycle: P0->R1->P1->R0->P0"
      },
      {
        "input": "[[1, 0], [0, 0]], [[0, 1], [0, 0]]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No cycle"
      }
    ],
    "hints": [
      "Build wait-for graph",
      "Use DFS for cycle detection"
    ]
  },
  {
    "id": "cs301-ex-5-3",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Banker's Safety Check",
    "description": "Implement the safety algorithm of Banker's algorithm.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def is_safe(available, max_need, allocation):\n    # Return (is_safe, safe_sequence) or (False, [])\n    pass",
    "solution": "def is_safe(available, max_need, allocation):\n    n = len(allocation)\n    m = len(available)\n    work = available[:]\n    finish = [False] * n\n    need = [[max_need[i][j] - allocation[i][j] for j in range(m)] for i in range(n)]\n    sequence = []\n\n    while len(sequence) < n:\n        found = False\n        for i in range(n):\n            if not finish[i]:\n                if all(need[i][j] <= work[j] for j in range(m)):\n                    for j in range(m):\n                        work[j] += allocation[i][j]\n                    finish[i] = True\n                    sequence.append(i)\n                    found = True\n                    break\n        if not found:\n            return (False, [])\n    return (True, sequence)",
    "testCases": [
      {
        "input": "[3, 3, 2], [[7, 5, 3], [3, 2, 2], [9, 0, 2]], [[0, 1, 0], [2, 0, 0], [3, 0, 2]]",
        "expectedOutput": "(True, [1, 0, 2])",
        "isHidden": false,
        "description": "Safe state"
      },
      {
        "input": "[0, 0, 0], [[7, 5, 3], [3, 2, 2]], [[0, 1, 0], [2, 0, 0]]",
        "expectedOutput": "(False, [])",
        "isHidden": false,
        "description": "Unsafe state"
      }
    ],
    "hints": [
      "Find process that can finish",
      "Release its resources to work"
    ]
  },
  {
    "id": "cs301-ex-5-4",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Resource Request Algorithm",
    "description": "Check if a resource request can be granted safely.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def can_grant_request(process_id, request, available, max_need, allocation):\n    # Return True if request can be granted safely\n    pass",
    "solution": "def can_grant_request(process_id, request, available, max_need, allocation):\n    n = len(allocation)\n    m = len(available)\n    need = [[max_need[i][j] - allocation[i][j] for j in range(m)] for i in range(n)]\n\n    # Check request <= need\n    for j in range(m):\n        if request[j] > need[process_id][j]:\n            return False\n\n    # Check request <= available\n    for j in range(m):\n        if request[j] > available[j]:\n            return False\n\n    # Try allocation\n    new_available = [available[j] - request[j] for j in range(m)]\n    new_allocation = [row[:] for row in allocation]\n    for j in range(m):\n        new_allocation[process_id][j] += request[j]\n\n    # Check if resulting state is safe\n    result, _ = is_safe_helper(new_available, max_need, new_allocation)\n    return result\n\ndef is_safe_helper(available, max_need, allocation):\n    n = len(allocation)\n    m = len(available)\n    work = available[:]\n    finish = [False] * n\n    need = [[max_need[i][j] - allocation[i][j] for j in range(m)] for i in range(n)]\n    sequence = []\n    while len(sequence) < n:\n        found = False\n        for i in range(n):\n            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):\n                for j in range(m):\n                    work[j] += allocation[i][j]\n                finish[i] = True\n                sequence.append(i)\n                found = True\n                break\n        if not found:\n            return (False, [])\n    return (True, sequence)",
    "testCases": [
      {
        "input": "1, [1, 0, 2], [3, 3, 2], [[7, 5, 3], [3, 2, 2]], [[0, 1, 0], [2, 0, 0]]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe to grant"
      },
      {
        "input": "0, [3, 3, 3], [3, 3, 2], [[7, 5, 3], [3, 2, 2]], [[0, 1, 0], [2, 0, 0]]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Exceeds available"
      }
    ],
    "hints": [
      "Check request is valid",
      "Try allocation and check safety"
    ]
  },
  {
    "id": "cs301-ex-5-5",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Hold-and-Wait Prevention",
    "description": "Check if a request violates hold-and-wait prevention (must request all at once).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def violates_hold_wait(current_allocation, new_request):\n    # Return True if process holds resources and requests more\n    pass",
    "solution": "def violates_hold_wait(current_allocation, new_request):\n    holds_resources = any(r > 0 for r in current_allocation)\n    requests_resources = any(r > 0 for r in new_request)\n    return holds_resources and requests_resources",
    "testCases": [
      {
        "input": "[1, 0, 0], [0, 1, 0]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Holds and requests"
      },
      {
        "input": "[0, 0, 0], [1, 1, 0]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No hold, just request"
      }
    ],
    "hints": [
      "Check if holding any resources",
      "Check if requesting any resources"
    ]
  },
  {
    "id": "cs301-ex-5-6",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Resource Ordering Validation",
    "description": "Check if resource requests follow a total ordering (for circular wait prevention).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def follows_ordering(held_resources, requested_resource):\n    # Return True if requested > all held (using resource IDs as order)\n    pass",
    "solution": "def follows_ordering(held_resources, requested_resource):\n    if not held_resources:\n        return True\n    max_held = max(held_resources)\n    return requested_resource > max_held",
    "testCases": [
      {
        "input": "[1, 2, 3], 5",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Follows order"
      },
      {
        "input": "[1, 5, 3], 4",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Violates order"
      }
    ],
    "hints": [
      "Resource IDs define order",
      "New request must be greater than all held"
    ]
  },
  {
    "id": "cs301-ex-5-7",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Detection Algorithm",
    "description": "Detect deadlock using available resources and requests.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def detect_deadlock(available, allocation, request):\n    # Return list of deadlocked processes\n    pass",
    "solution": "def detect_deadlock(available, allocation, request):\n    n = len(allocation)\n    m = len(available)\n    work = available[:]\n    finish = [allocation[i] == [0]*m for i in range(n)]\n\n    changed = True\n    while changed:\n        changed = False\n        for i in range(n):\n            if not finish[i]:\n                if all(request[i][j] <= work[j] for j in range(m)):\n                    for j in range(m):\n                        work[j] += allocation[i][j]\n                    finish[i] = True\n                    changed = True\n\n    deadlocked = [i for i in range(n) if not finish[i]]\n    return deadlocked",
    "testCases": [
      {
        "input": "[0, 0, 0], [[0, 1, 0], [2, 0, 0]], [[0, 0, 0], [0, 0, 2]]",
        "expectedOutput": "[1]",
        "isHidden": false,
        "description": "Process 1 deadlocked"
      },
      {
        "input": "[1, 1, 1], [[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "No deadlock"
      }
    ],
    "hints": [
      "Similar to safety algorithm",
      "Return processes that cannot finish"
    ]
  },
  {
    "id": "cs301-ex-5-8",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Victim Selection",
    "description": "Select best victim process to terminate based on cost factors.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def select_victim(processes):\n    # processes: list of (pid, priority, time_running, resources_held)\n    # Return pid of best victim (lowest cost to terminate)\n    pass",
    "solution": "def select_victim(processes):\n    # Cost = priority + time_running + resources_held\n    # Lower cost = better victim\n    def cost(p):\n        pid, priority, time, resources = p\n        return priority + time + resources\n\n    best = min(processes, key=cost)\n    return best[0]",
    "testCases": [
      {
        "input": "[(1, 5, 10, 3), (2, 1, 2, 1)]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Lower cost process"
      },
      {
        "input": "[(1, 10, 10, 10), (2, 1, 1, 1)]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Clear winner"
      }
    ],
    "hints": [
      "Calculate cost for each process",
      "Select minimum cost"
    ]
  },
  {
    "id": "cs301-ex-5-9",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Resource Preemption",
    "description": "Preempt resources from a process and update allocation.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def preempt_resources(allocation, available, process_id, resources_to_preempt):\n    # Return (new_allocation, new_available)\n    pass",
    "solution": "def preempt_resources(allocation, available, process_id, resources_to_preempt):\n    new_allocation = [row[:] for row in allocation]\n    new_available = available[:]\n\n    for j in range(len(resources_to_preempt)):\n        amount = min(resources_to_preempt[j], new_allocation[process_id][j])\n        new_allocation[process_id][j] -= amount\n        new_available[j] += amount\n\n    return (new_allocation, new_available)",
    "testCases": [
      {
        "input": "[[2, 1], [0, 1]], [1, 0], 0, [1, 1]",
        "expectedOutput": "([[1, 0], [0, 1]], [2, 1])",
        "isHidden": false,
        "description": "Preempt from P0"
      },
      {
        "input": "[[1, 1]], [0, 0], 0, [2, 2]",
        "expectedOutput": "([[0, 0]], [1, 1])",
        "isHidden": false,
        "description": "Preempt all"
      }
    ],
    "hints": [
      "Can only preempt what process has",
      "Update both allocation and available"
    ]
  },
  {
    "id": "cs301-ex-5-10",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Build Wait-For Graph",
    "description": "Build a wait-for graph from allocation and request matrices.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def build_wait_for_graph(allocation, request):\n    # Return adjacency list: {process: [processes it waits for]}\n    pass",
    "solution": "def build_wait_for_graph(allocation, request):\n    n = len(allocation)\n    m = len(allocation[0]) if allocation else 0\n    graph = {i: [] for i in range(n)}\n\n    for p1 in range(n):\n        for r in range(m):\n            if request[p1][r] > 0:\n                for p2 in range(n):\n                    if allocation[p2][r] > 0 and p1 != p2:\n                        if p2 not in graph[p1]:\n                            graph[p1].append(p2)\n    return graph",
    "testCases": [
      {
        "input": "[[1, 0], [0, 1]], [[0, 1], [1, 0]]",
        "expectedOutput": "{0: [1], 1: [0]}",
        "isHidden": false,
        "description": "Circular wait"
      },
      {
        "input": "[[1, 0], [0, 0]], [[0, 0], [1, 0]]",
        "expectedOutput": "{0: [], 1: [0]}",
        "isHidden": false,
        "description": "Linear wait"
      }
    ],
    "hints": [
      "P1 waits for P2 if P1 requests resource held by P2",
      "Check each resource"
    ]
  },
  {
    "id": "cs301-ex-5-11",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Process Rollback",
    "description": "Simulate rolling back a process to a checkpoint.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def rollback(current_state, checkpoint, allocation, checkpoint_allocation):\n    # Return (new_state, freed_resources)\n    pass",
    "solution": "def rollback(current_state, checkpoint, allocation, checkpoint_allocation):\n    freed = [allocation[i] - checkpoint_allocation[i] for i in range(len(allocation))]\n    return (checkpoint, freed)",
    "testCases": [
      {
        "input": "{\"pc\": 100}, {\"pc\": 50}, [5, 3], [3, 2]",
        "expectedOutput": "({\"pc\": 50}, [2, 1])",
        "isHidden": false,
        "description": "Rollback releases resources"
      },
      {
        "input": "{\"pc\": 50}, {\"pc\": 50}, [3, 2], [3, 2]",
        "expectedOutput": "({\"pc\": 50}, [0, 0])",
        "isHidden": false,
        "description": "No change"
      }
    ],
    "hints": [
      "Restore checkpoint state",
      "Calculate freed resources"
    ]
  },
  {
    "id": "cs301-ex-5-12",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Avoidance Overhead",
    "description": "Calculate the overhead of running Banker's algorithm.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bankers_overhead(num_processes, num_resources):\n    # Return approximate number of operations for one safety check\n    pass",
    "solution": "def bankers_overhead(num_processes, num_resources):\n    # Worst case: check all processes for each position in sequence\n    # O(n^2 * m) for n processes, m resources\n    return num_processes * num_processes * num_resources",
    "testCases": [
      {
        "input": "5, 3",
        "expectedOutput": "75",
        "isHidden": false,
        "description": "5 processes, 3 resources"
      },
      {
        "input": "10, 4",
        "expectedOutput": "400",
        "isHidden": false,
        "description": "10 processes, 4 resources"
      }
    ],
    "hints": [
      "Safety check is O(n^2 * m)",
      "n = processes, m = resources"
    ]
  },
  {
    "id": "cs301-ex-5-13",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Multiple Instance Available",
    "description": "Check if enough resources are available to satisfy a request.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def can_satisfy_request(available, request):\n    # Return True if available >= request for all resources\n    pass",
    "solution": "def can_satisfy_request(available, request):\n    return all(available[i] >= request[i] for i in range(len(available)))",
    "testCases": [
      {
        "input": "[3, 2, 2], [1, 1, 2]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Can satisfy"
      },
      {
        "input": "[3, 2, 2], [1, 3, 2]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not enough of R1"
      }
    ],
    "hints": [
      "Compare each resource type",
      "All must be satisfied"
    ]
  },
  {
    "id": "cs301-ex-5-14",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Safe Resource Release",
    "description": "Release resources and update system state.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def release_resources(allocation, available, process_id):\n    # Release all resources held by process\n    # Return (new_allocation, new_available)\n    pass",
    "solution": "def release_resources(allocation, available, process_id):\n    new_allocation = [row[:] for row in allocation]\n    new_available = available[:]\n\n    for j in range(len(available)):\n        new_available[j] += new_allocation[process_id][j]\n        new_allocation[process_id][j] = 0\n\n    return (new_allocation, new_available)",
    "testCases": [
      {
        "input": "[[2, 1], [1, 2]], [1, 1], 0",
        "expectedOutput": "([[0, 0], [1, 2]], [3, 2])",
        "isHidden": false,
        "description": "Release P0 resources"
      },
      {
        "input": "[[0, 0]], [5, 5], 0",
        "expectedOutput": "([[0, 0]], [5, 5])",
        "isHidden": false,
        "description": "Nothing to release"
      }
    ],
    "hints": [
      "Add allocation to available",
      "Zero out allocation"
    ]
  },
  {
    "id": "cs301-ex-5-15",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Risk Assessment",
    "description": "Estimate deadlock risk based on resource utilization.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def deadlock_risk(total_resources, allocated, max_needed):\n    # Return risk level: \"low\", \"medium\", \"high\"\n    pass",
    "solution": "def deadlock_risk(total_resources, allocated, max_needed):\n    total = sum(total_resources)\n    used = sum(allocated)\n    max_need = sum(max_needed)\n\n    utilization = used / total if total > 0 else 0\n    remaining_need = max_need - used\n\n    if remaining_need > (total - used):\n        return \"high\"  # Not enough to satisfy max\n    elif utilization > 0.8:\n        return \"medium\"\n    else:\n        return \"low\"",
    "testCases": [
      {
        "input": "[10, 10], [9, 9], [15, 15]",
        "expectedOutput": "\"high\"",
        "isHidden": false,
        "description": "High utilization"
      },
      {
        "input": "[10, 10], [2, 2], [5, 5]",
        "expectedOutput": "\"low\"",
        "isHidden": false,
        "description": "Low utilization"
      }
    ],
    "hints": [
      "Consider utilization ratio",
      "Check if max needs can be met"
    ]
  },
  {
    "id": "cs301-ex-5-16",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Strategy Decision",
    "description": "Recommend deadlock handling strategy based on system characteristics.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def recommend_strategy(is_critical_system, deadlock_frequency, recovery_cost):\n    # Return \"prevention\", \"avoidance\", \"detection\", or \"ignore\"\n    pass",
    "solution": "def recommend_strategy(is_critical_system, deadlock_frequency, recovery_cost):\n    if is_critical_system:\n        if recovery_cost < 0.3:\n            return \"avoidance\"\n        return \"prevention\"\n    if deadlock_frequency < 0.01:  # Very rare\n        return \"ignore\"\n    if recovery_cost < 0.5:\n        return \"detection\"\n    return \"avoidance\"",
    "testCases": [
      {
        "input": "True, 0.05, 0.8",
        "expectedOutput": "\"prevention\"",
        "isHidden": false,
        "description": "Critical, high recovery cost"
      },
      {
        "input": "False, 0.001, 0.2",
        "expectedOutput": "\"ignore\"",
        "isHidden": false,
        "description": "Non-critical, rare deadlocks"
      }
    ],
    "hints": [
      "Critical systems need guarantees",
      "Balance overhead vs risk"
    ]
  },
  {
    "id": "cs301-ex-6-1",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Logical to Physical Address",
    "description": "Convert logical address to physical using base and limit registers.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def translate_address(logical_addr, base, limit):\n    # Return physical address or -1 if invalid\n    pass",
    "solution": "def translate_address(logical_addr, base, limit):\n    if logical_addr < 0 or logical_addr >= limit:\n        return -1  # Address out of bounds\n    return base + logical_addr",
    "testCases": [
      {
        "input": "100, 5000, 1000",
        "expectedOutput": "5100",
        "isHidden": false,
        "description": "Valid translation"
      },
      {
        "input": "1500, 5000, 1000",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Out of bounds"
      }
    ],
    "hints": [
      "Check against limit first",
      "Physical = base + logical"
    ]
  },
  {
    "id": "cs301-ex-6-2",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "First Fit Allocator",
    "description": "Implement First Fit memory allocation.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def first_fit(memory_blocks, process_size):\n    # memory_blocks: list of (start, size, is_free)\n    # Return start address or -1 if no fit\n    pass",
    "solution": "def first_fit(memory_blocks, process_size):\n    for start, size, is_free in memory_blocks:\n        if is_free and size >= process_size:\n            return start\n    return -1",
    "testCases": [
      {
        "input": "[(0, 100, True), (100, 200, False), (300, 150, True)], 120",
        "expectedOutput": "300",
        "isHidden": false,
        "description": "First fit"
      },
      {
        "input": "[(0, 50, True)], 100",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "No fit"
      }
    ],
    "hints": [
      "Find first free block that fits",
      "Return start address"
    ]
  },
  {
    "id": "cs301-ex-6-3",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Best Fit Allocator",
    "description": "Implement Best Fit memory allocation (smallest adequate block).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def best_fit(memory_blocks, process_size):\n    # Return start address of best fitting block or -1\n    pass",
    "solution": "def best_fit(memory_blocks, process_size):\n    best_start = -1\n    best_size = float('inf')\n\n    for start, size, is_free in memory_blocks:\n        if is_free and size >= process_size:\n            if size < best_size:\n                best_size = size\n                best_start = start\n    return best_start",
    "testCases": [
      {
        "input": "[(0, 200, True), (200, 100, True), (300, 150, True)], 90",
        "expectedOutput": "200",
        "isHidden": false,
        "description": "Best fit is 100"
      },
      {
        "input": "[(0, 100, True), (100, 100, True)], 100",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Exact fit"
      }
    ],
    "hints": [
      "Track smallest adequate block",
      "Minimize waste"
    ]
  },
  {
    "id": "cs301-ex-6-4",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Worst Fit Allocator",
    "description": "Implement Worst Fit memory allocation (largest adequate block).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def worst_fit(memory_blocks, process_size):\n    # Return start address of largest fitting block or -1\n    pass",
    "solution": "def worst_fit(memory_blocks, process_size):\n    worst_start = -1\n    worst_size = -1\n\n    for start, size, is_free in memory_blocks:\n        if is_free and size >= process_size:\n            if size > worst_size:\n                worst_size = size\n                worst_start = start\n    return worst_start",
    "testCases": [
      {
        "input": "[(0, 100, True), (100, 200, True), (300, 150, True)], 50",
        "expectedOutput": "100",
        "isHidden": false,
        "description": "Worst fit is 200"
      },
      {
        "input": "[(0, 50, True)], 100",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "No fit"
      }
    ],
    "hints": [
      "Track largest adequate block",
      "Leave large remainder"
    ]
  },
  {
    "id": "cs301-ex-6-5",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "External Fragmentation Calculator",
    "description": "Calculate total external fragmentation (free but unusable memory).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def external_fragmentation(memory_blocks, min_useful_size):\n    # Return total free space in blocks smaller than min_useful_size\n    pass",
    "solution": "def external_fragmentation(memory_blocks, min_useful_size):\n    fragmented = 0\n    for start, size, is_free in memory_blocks:\n        if is_free and size < min_useful_size:\n            fragmented += size\n    return fragmented",
    "testCases": [
      {
        "input": "[(0, 50, True), (50, 200, False), (250, 30, True)], 100",
        "expectedOutput": "80",
        "isHidden": false,
        "description": "Two small free blocks"
      },
      {
        "input": "[(0, 200, True)], 100",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Large enough block"
      }
    ],
    "hints": [
      "Sum free blocks below threshold",
      "Ignore large free blocks"
    ]
  },
  {
    "id": "cs301-ex-6-6",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Page Table Lookup",
    "description": "Translate logical address using page table.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def page_translate(logical_addr, page_table, page_size):\n    # page_table[page_num] = (frame_num, valid_bit)\n    # Return physical address or -1 if invalid\n    pass",
    "solution": "def page_translate(logical_addr, page_table, page_size):\n    page_num = logical_addr // page_size\n    page_offset = logical_addr % page_size\n\n    if page_num >= len(page_table):\n        return -1\n\n    frame_num, valid = page_table[page_num]\n    if not valid:\n        return -1\n\n    physical_addr = frame_num * page_size + page_offset\n    return physical_addr",
    "testCases": [
      {
        "input": "5000, [(2, True), (3, True)], 4096",
        "expectedOutput": "12904",
        "isHidden": false,
        "description": "Page 1, offset 904"
      },
      {
        "input": "1000, [(5, False)], 4096",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Invalid page"
      }
    ],
    "hints": [
      "Extract page number and offset",
      "Check valid bit"
    ]
  },
  {
    "id": "cs301-ex-6-7",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Internal Fragmentation",
    "description": "Calculate internal fragmentation for a process.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def internal_fragmentation(process_size, page_size):\n    # Return wasted space in last page\n    pass",
    "solution": "def internal_fragmentation(process_size, page_size):\n    pages_needed = (process_size + page_size - 1) // page_size\n    allocated = pages_needed * page_size\n    return allocated - process_size",
    "testCases": [
      {
        "input": "10000, 4096",
        "expectedOutput": "2288",
        "isHidden": false,
        "description": "3 pages, 2288 wasted"
      },
      {
        "input": "8192, 4096",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Exact fit"
      }
    ],
    "hints": [
      "Calculate pages needed",
      "Subtract process size from allocated"
    ]
  },
  {
    "id": "cs301-ex-6-8",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "TLB Simulation",
    "description": "Simulate TLB lookups and calculate hit rate.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def tlb_simulation(page_references, tlb_size):\n    # Return (hits, misses, hit_rate)\n    pass",
    "solution": "def tlb_simulation(page_references, tlb_size):\n    tlb = []  # LRU order\n    hits = 0\n    misses = 0\n\n    for page in page_references:\n        if page in tlb:\n            hits += 1\n            tlb.remove(page)\n            tlb.append(page)  # Move to end (most recent)\n        else:\n            misses += 1\n            if len(tlb) >= tlb_size:\n                tlb.pop(0)  # Remove LRU\n            tlb.append(page)\n\n    total = hits + misses\n    hit_rate = hits / total if total > 0 else 0\n    return (hits, misses, round(hit_rate, 2))",
    "testCases": [
      {
        "input": "[1, 2, 3, 1, 2, 4, 1], 3",
        "expectedOutput": "(3, 4, 0.43)",
        "isHidden": false,
        "description": "Mixed hits/misses"
      },
      {
        "input": "[1, 1, 1, 1], 1",
        "expectedOutput": "(3, 1, 0.75)",
        "isHidden": false,
        "description": "High locality"
      }
    ],
    "hints": [
      "Use LRU replacement",
      "Track hits and misses"
    ]
  },
  {
    "id": "cs301-ex-6-9",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Effective Access Time",
    "description": "Calculate EAT with TLB.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def effective_access_time(tlb_hit_ratio, tlb_time, memory_time):\n    # Return EAT in same time units\n    pass",
    "solution": "def effective_access_time(tlb_hit_ratio, tlb_time, memory_time):\n    # TLB hit: TLB + memory (for data)\n    # TLB miss: TLB + memory (page table) + memory (data)\n    eat = (tlb_hit_ratio * (tlb_time + memory_time) +\n           (1 - tlb_hit_ratio) * (tlb_time + 2 * memory_time))\n    return round(eat, 2)",
    "testCases": [
      {
        "input": "0.9, 10, 100",
        "expectedOutput": "120.0",
        "isHidden": false,
        "description": "90% hit rate"
      },
      {
        "input": "0.98, 10, 100",
        "expectedOutput": "112.2",
        "isHidden": false,
        "description": "98% hit rate"
      }
    ],
    "hints": [
      "EAT = hit_ratio * hit_time + miss_ratio * miss_time",
      "Miss requires extra memory access"
    ]
  },
  {
    "id": "cs301-ex-6-10",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Two-Level Page Table",
    "description": "Calculate address bits for two-level page table.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def two_level_bits(addr_bits, page_size_kb, pte_size_bytes):\n    # Return (outer_bits, inner_bits, offset_bits)\n    pass",
    "solution": "def two_level_bits(addr_bits, page_size_kb, pte_size_bytes):\n    import math\n    page_size = page_size_kb * 1024\n    offset_bits = int(math.log2(page_size))\n\n    # PTEs per page\n    ptes_per_page = page_size // pte_size_bytes\n    inner_bits = int(math.log2(ptes_per_page))\n\n    # Remaining bits for outer\n    outer_bits = addr_bits - offset_bits - inner_bits\n\n    return (outer_bits, inner_bits, offset_bits)",
    "testCases": [
      {
        "input": "32, 4, 4",
        "expectedOutput": "(10, 10, 12)",
        "isHidden": false,
        "description": "32-bit, 4KB pages"
      },
      {
        "input": "64, 4, 8",
        "expectedOutput": "(43, 9, 12)",
        "isHidden": false,
        "description": "64-bit, 4KB pages"
      }
    ],
    "hints": [
      "Offset bits = log2(page_size)",
      "Inner bits = log2(PTEs per page)"
    ]
  },
  {
    "id": "cs301-ex-6-11",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Segmentation Translation",
    "description": "Translate segment:offset address.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def segment_translate(segment_num, offset, segment_table):\n    # segment_table[seg] = (base, limit)\n    # Return physical address or -1 if invalid\n    pass",
    "solution": "def segment_translate(segment_num, offset, segment_table):\n    if segment_num >= len(segment_table):\n        return -1\n\n    base, limit = segment_table[segment_num]\n    if offset >= limit:\n        return -1\n\n    return base + offset",
    "testCases": [
      {
        "input": "0, 500, [(1000, 1000), (2000, 500)]",
        "expectedOutput": "1500",
        "isHidden": false,
        "description": "Valid segment access"
      },
      {
        "input": "1, 600, [(1000, 1000), (2000, 500)]",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Offset exceeds limit"
      }
    ],
    "hints": [
      "Check segment exists",
      "Check offset within limit"
    ]
  },
  {
    "id": "cs301-ex-6-12",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Memory Compaction",
    "description": "Calculate new addresses after compaction.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def compact_memory(allocations):\n    # allocations: list of (name, start, size)\n    # Return new allocations after compaction\n    pass",
    "solution": "def compact_memory(allocations):\n    # Sort by start address and compact\n    sorted_allocs = sorted(allocations, key=lambda x: x[1])\n    result = []\n    current_addr = 0\n\n    for name, start, size in sorted_allocs:\n        result.append((name, current_addr, size))\n        current_addr += size\n\n    return result",
    "testCases": [
      {
        "input": "[(\"A\", 100, 50), (\"B\", 0, 30), (\"C\", 200, 40)]",
        "expectedOutput": "[(\"B\", 0, 30), (\"A\", 30, 50), (\"C\", 80, 40)]",
        "isHidden": false,
        "description": "Compacted layout"
      },
      {
        "input": "[(\"X\", 0, 100)]",
        "expectedOutput": "[(\"X\", 0, 100)]",
        "isHidden": false,
        "description": "Already compact"
      }
    ],
    "hints": [
      "Sort by original position",
      "Place contiguously from 0"
    ]
  },
  {
    "id": "cs301-ex-6-13",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Page Table Size Calculator",
    "description": "Calculate page table size in bytes.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def page_table_size(virtual_addr_bits, page_size_kb, pte_bytes):\n    # Return page table size in bytes\n    pass",
    "solution": "def page_table_size(virtual_addr_bits, page_size_kb, pte_bytes):\n    import math\n    page_size = page_size_kb * 1024\n    offset_bits = int(math.log2(page_size))\n    page_number_bits = virtual_addr_bits - offset_bits\n    num_pages = 2 ** page_number_bits\n    return num_pages * pte_bytes",
    "testCases": [
      {
        "input": "32, 4, 4",
        "expectedOutput": "4194304",
        "isHidden": false,
        "description": "32-bit, 4KB pages, 4B PTE"
      },
      {
        "input": "20, 4, 4",
        "expectedOutput": "1024",
        "isHidden": false,
        "description": "20-bit address space"
      }
    ],
    "hints": [
      "Num pages = 2^(addr_bits - offset_bits)",
      "Size = num_pages * PTE_size"
    ]
  },
  {
    "id": "cs301-ex-6-14",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Inverted Page Table Lookup",
    "description": "Search inverted page table for translation.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def inverted_lookup(pid, page_num, inverted_table):\n    # inverted_table[frame] = (pid, page_num) or None\n    # Return frame number or -1 if not found\n    pass",
    "solution": "def inverted_lookup(pid, page_num, inverted_table):\n    for frame, entry in enumerate(inverted_table):\n        if entry is not None:\n            if entry[0] == pid and entry[1] == page_num:\n                return frame\n    return -1",
    "testCases": [
      {
        "input": "1, 5, [None, (1, 5), (2, 3)]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Found in frame 1"
      },
      {
        "input": "1, 10, [(1, 5), (2, 3)]",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Not found"
      }
    ],
    "hints": [
      "Search entire table",
      "Match both PID and page number"
    ]
  },
  {
    "id": "cs301-ex-6-15",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Swap Space Calculator",
    "description": "Calculate required swap space for processes.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def required_swap_space(processes, physical_memory):\n    # processes: list of memory sizes\n    # Return minimum swap space needed\n    pass",
    "solution": "def required_swap_space(processes, physical_memory):\n    total_virtual = sum(processes)\n    if total_virtual <= physical_memory:\n        return 0\n    return total_virtual - physical_memory",
    "testCases": [
      {
        "input": "[500, 300, 400], 800",
        "expectedOutput": "400",
        "isHidden": false,
        "description": "Need 400 swap"
      },
      {
        "input": "[200, 300], 600",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Fits in memory"
      }
    ],
    "hints": [
      "Swap = total virtual - physical",
      "Minimum is 0"
    ]
  },
  {
    "id": "cs301-ex-6-16",
    "subjectId": "cs301",
    "topicId": "cs301-t6",
    "title": "Address Space Layout",
    "description": "Validate process address space layout.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def validate_layout(text_start, text_size, data_start, data_size, heap_start, stack_end, total_size):\n    # Return True if layout is valid (no overlaps, within bounds)\n    pass",
    "solution": "def validate_layout(text_start, text_size, data_start, data_size, heap_start, stack_end, total_size):\n    text_end = text_start + text_size\n    data_end = data_start + data_size\n\n    # Check bounds\n    if text_start < 0 or text_end > total_size:\n        return False\n    if data_start < 0 or data_end > total_size:\n        return False\n    if heap_start < 0 or heap_start > total_size:\n        return False\n    if stack_end < 0 or stack_end > total_size:\n        return False\n\n    # Check no overlap between text and data\n    if not (text_end <= data_start or data_end <= text_start):\n        return False\n\n    # Check heap doesn't overlap with text/data\n    if heap_start < max(text_end, data_end):\n        return False\n\n    return True",
    "testCases": [
      {
        "input": "0, 1000, 1000, 500, 1500, 4096, 4096",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid layout"
      },
      {
        "input": "0, 1000, 500, 1000, 1500, 4096, 4096",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Text/data overlap"
      }
    ],
    "hints": [
      "Check each section within bounds",
      "Check for overlaps"
    ]
  },
  {
    "id": "cs301-ex-7-1",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Page Fault Counter",
    "description": "Count page faults for a reference string given a fixed number of frames.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def count_page_faults(reference_string, num_frames):\n    # Return number of page faults (simple LRU)\n    pass",
    "solution": "def count_page_faults(reference_string, num_frames):\n    frames = []\n    faults = 0\n\n    for page in reference_string:\n        if page not in frames:\n            faults += 1\n            if len(frames) >= num_frames:\n                frames.pop(0)  # LRU\n            frames.append(page)\n        else:\n            frames.remove(page)\n            frames.append(page)  # Move to end (most recent)\n\n    return faults",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5], 3",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Standard reference string"
      },
      {
        "input": "[1, 1, 1, 1], 1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Same page repeated"
      }
    ],
    "hints": [
      "Track pages in frames",
      "Fault on first access or after eviction"
    ]
  },
  {
    "id": "cs301-ex-7-2",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "FIFO Page Replacement",
    "description": "Implement FIFO page replacement and return the sequence of evicted pages.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def fifo_replacement(reference_string, num_frames):\n    # Return list of evicted pages (in order)\n    pass",
    "solution": "def fifo_replacement(reference_string, num_frames):\n    frames = []\n    evicted = []\n\n    for page in reference_string:\n        if page not in frames:\n            if len(frames) >= num_frames:\n                victim = frames.pop(0)\n                evicted.append(victim)\n            frames.append(page)\n\n    return evicted",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 1, 2], 3",
        "expectedOutput": "[1, 2]",
        "isHidden": false,
        "description": "Evict 1 then 2"
      },
      {
        "input": "[1, 2, 1, 2], 2",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "No evictions"
      }
    ],
    "hints": [
      "Evict oldest (front of queue)",
      "Track evictions separately"
    ]
  },
  {
    "id": "cs301-ex-7-3",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "LRU Page Replacement",
    "description": "Implement LRU page replacement.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def lru_replacement(reference_string, num_frames):\n    # Return (page_faults, final_frame_state)\n    pass",
    "solution": "def lru_replacement(reference_string, num_frames):\n    frames = []  # Ordered by recency, most recent at end\n    faults = 0\n\n    for page in reference_string:\n        if page in frames:\n            frames.remove(page)\n            frames.append(page)\n        else:\n            faults += 1\n            if len(frames) >= num_frames:\n                frames.pop(0)  # Remove LRU (front)\n            frames.append(page)\n\n    return (faults, frames)",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 1, 2, 5], 3",
        "expectedOutput": "(6, [1, 2, 5])",
        "isHidden": false,
        "description": "LRU simulation"
      },
      {
        "input": "[1, 2, 1, 2], 2",
        "expectedOutput": "(2, [1, 2])",
        "isHidden": false,
        "description": "High locality"
      }
    ],
    "hints": [
      "Move accessed page to end",
      "Remove from front on eviction"
    ]
  },
  {
    "id": "cs301-ex-7-4",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Optimal Page Replacement",
    "description": "Implement optimal (OPT) page replacement using future knowledge.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def optimal_replacement(reference_string, num_frames):\n    # Return number of page faults\n    pass",
    "solution": "def optimal_replacement(reference_string, num_frames):\n    frames = []\n    faults = 0\n\n    for i, page in enumerate(reference_string):\n        if page in frames:\n            continue\n\n        faults += 1\n        if len(frames) < num_frames:\n            frames.append(page)\n        else:\n            # Find page used furthest in future\n            furthest = -1\n            victim = frames[0]\n            for frame_page in frames:\n                try:\n                    next_use = reference_string[i+1:].index(frame_page)\n                except ValueError:\n                    next_use = float('inf')\n                if next_use > furthest:\n                    furthest = next_use\n                    victim = frame_page\n            frames.remove(victim)\n            frames.append(page)\n\n    return faults",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5], 3",
        "expectedOutput": "7",
        "isHidden": false,
        "description": "Optimal replacement"
      },
      {
        "input": "[1, 2, 3, 1, 2, 3], 3",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Perfect fit"
      }
    ],
    "hints": [
      "Look ahead in reference string",
      "Replace page used furthest in future"
    ]
  },
  {
    "id": "cs301-ex-7-5",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Clock Algorithm",
    "description": "Implement the clock (second chance) page replacement algorithm.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def clock_replacement(reference_string, num_frames):\n    # Return number of page faults\n    pass",
    "solution": "def clock_replacement(reference_string, num_frames):\n    frames = []  # (page, reference_bit)\n    pointer = 0\n    faults = 0\n\n    for page in reference_string:\n        # Check if page already in frames\n        found = False\n        for i, (p, _) in enumerate(frames):\n            if p == page:\n                frames[i] = (p, 1)  # Set reference bit\n                found = True\n                break\n\n        if not found:\n            faults += 1\n            if len(frames) < num_frames:\n                frames.append((page, 1))\n            else:\n                # Find victim using clock\n                while True:\n                    p, ref = frames[pointer]\n                    if ref == 0:\n                        frames[pointer] = (page, 1)\n                        pointer = (pointer + 1) % num_frames\n                        break\n                    else:\n                        frames[pointer] = (p, 0)  # Second chance\n                        pointer = (pointer + 1) % num_frames\n\n    return faults",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5], 3",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Clock algorithm"
      },
      {
        "input": "[1, 2, 3, 1, 2], 3",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "No evictions needed"
      }
    ],
    "hints": [
      "Use circular buffer with reference bits",
      "Clear reference bit on second chance"
    ]
  },
  {
    "id": "cs301-ex-7-6",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Working Set Size",
    "description": "Calculate working set size at a given time.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def working_set(reference_string, time, window_size):\n    # Return set of pages in working set at time\n    pass",
    "solution": "def working_set(reference_string, time, window_size):\n    start = max(0, time - window_size + 1)\n    end = time + 1\n    window = reference_string[start:end]\n    return set(window)",
    "testCases": [
      {
        "input": "[1, 2, 3, 1, 2, 4, 5, 3, 4, 5], 7, 4",
        "expectedOutput": "{3, 4, 5}",
        "isHidden": false,
        "description": "Working set at t=7"
      },
      {
        "input": "[1, 2, 3, 4, 5], 2, 3",
        "expectedOutput": "{1, 2, 3}",
        "isHidden": false,
        "description": "First three pages"
      }
    ],
    "hints": [
      "Window ends at current time",
      "Return unique pages in window"
    ]
  },
  {
    "id": "cs301-ex-7-7",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Thrashing Detector",
    "description": "Detect if system is thrashing based on page fault rate.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def is_thrashing(page_faults, total_references, threshold):\n    # Return True if page fault rate exceeds threshold\n    pass",
    "solution": "def is_thrashing(page_faults, total_references, threshold):\n    if total_references == 0:\n        return False\n    fault_rate = page_faults / total_references\n    return fault_rate > threshold",
    "testCases": [
      {
        "input": "80, 100, 0.5",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "80% fault rate"
      },
      {
        "input": "10, 100, 0.5",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "10% fault rate"
      }
    ],
    "hints": [
      "Calculate fault rate",
      "Compare to threshold"
    ]
  },
  {
    "id": "cs301-ex-7-8",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Memory-Mapped File",
    "description": "Simulate memory-mapped file access.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class MemoryMappedFile:\n    def __init__(self, file_data, page_size):\n        pass\n    \n    def read(self, offset, length):\n        # Return data and list of pages accessed\n        pass",
    "solution": "class MemoryMappedFile:\n    def __init__(self, file_data, page_size):\n        self.data = file_data\n        self.page_size = page_size\n\n    def read(self, offset, length):\n        if offset < 0 or offset + length > len(self.data):\n            return (None, [])\n\n        data = self.data[offset:offset + length]\n\n        # Calculate pages accessed\n        start_page = offset // self.page_size\n        end_page = (offset + length - 1) // self.page_size\n        pages = list(range(start_page, end_page + 1))\n\n        return (data, pages)",
    "testCases": [
      {
        "input": "mmf = MemoryMappedFile(\"0123456789ABCDEF\", 4); mmf.read(2, 6)",
        "expectedOutput": "(\"234567\", [0, 1])",
        "isHidden": false,
        "description": "Cross-page read"
      },
      {
        "input": "mmf = MemoryMappedFile(\"ABCD\", 4); mmf.read(0, 4)",
        "expectedOutput": "(\"ABCD\", [0])",
        "isHidden": false,
        "description": "Single page"
      }
    ],
    "hints": [
      "Calculate page boundaries",
      "Track all pages touched"
    ]
  },
  {
    "id": "cs301-ex-7-9",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "FAT File System",
    "description": "Traverse FAT to find all blocks of a file.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def get_file_blocks(fat, start_block):\n    # fat[i] = next block or -1 for end\n    # Return list of all blocks in order\n    pass",
    "solution": "def get_file_blocks(fat, start_block):\n    blocks = []\n    current = start_block\n\n    while current != -1 and current < len(fat):\n        if current in blocks:\n            break  # Cycle detection\n        blocks.append(current)\n        current = fat[current]\n\n    return blocks",
    "testCases": [
      {
        "input": "[-1, 4, -1, -1, 7, -1, -1, -1], 1",
        "expectedOutput": "[1, 4, 7]",
        "isHidden": false,
        "description": "Three blocks"
      },
      {
        "input": "[2, -1, 3, -1], 0",
        "expectedOutput": "[0, 2, 3]",
        "isHidden": false,
        "description": "Chain traversal"
      }
    ],
    "hints": [
      "Follow chain until -1",
      "Detect cycles"
    ]
  },
  {
    "id": "cs301-ex-7-10",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Inode Block Calculation",
    "description": "Calculate which block holds a given file byte offset using inode structure.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def inode_block_lookup(file_offset, block_size, direct_blocks, indirect_block, double_indirect):\n    # Return (block_number, is_direct, indirection_level)\n    pass",
    "solution": "def inode_block_lookup(file_offset, block_size, direct_blocks, indirect_block, double_indirect):\n    block_num = file_offset // block_size\n    ptrs_per_block = block_size // 4  # Assume 4-byte pointers\n\n    # Direct blocks (12)\n    if block_num < 12:\n        return (direct_blocks[block_num], True, 0)\n\n    block_num -= 12\n\n    # Single indirect\n    if block_num < ptrs_per_block:\n        # Would need to read indirect block\n        return (indirect_block, False, 1)\n\n    block_num -= ptrs_per_block\n\n    # Double indirect\n    if block_num < ptrs_per_block * ptrs_per_block:\n        return (double_indirect, False, 2)\n\n    return (-1, False, -1)  # Out of range",
    "testCases": [
      {
        "input": "1000, 4096, [10,11,12,13,14,15,16,17,18,19,20,21], 100, 200",
        "expectedOutput": "(10, True, 0)",
        "isHidden": false,
        "description": "Direct block"
      },
      {
        "input": "50000, 4096, [10,11,12,13,14,15,16,17,18,19,20,21], 100, 200",
        "expectedOutput": "(100, False, 1)",
        "isHidden": false,
        "description": "Single indirect"
      }
    ],
    "hints": [
      "Calculate block number first",
      "Check direct, then indirect levels"
    ]
  },
  {
    "id": "cs301-ex-7-11",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Directory Lookup",
    "description": "Look up a file name in a directory and return its inode.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def directory_lookup(directory_entries, filename):\n    # directory_entries: list of (name, inode)\n    # Return inode or -1 if not found\n    pass",
    "solution": "def directory_lookup(directory_entries, filename):\n    for name, inode in directory_entries:\n        if name == filename:\n            return inode\n    return -1",
    "testCases": [
      {
        "input": "[(\".\", 100), (\"..\", 99), (\"file.txt\", 150)], \"file.txt\"",
        "expectedOutput": "150",
        "isHidden": false,
        "description": "File found"
      },
      {
        "input": "[(\"a\", 1), (\"b\", 2)], \"c\"",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "File not found"
      }
    ],
    "hints": [
      "Linear search through entries",
      "Compare names exactly"
    ]
  },
  {
    "id": "cs301-ex-7-12",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Block Bitmap Allocator",
    "description": "Allocate blocks using a bitmap.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class BlockBitmap:\n    def __init__(self, num_blocks):\n        pass\n    \n    def allocate(self, num_blocks):\n        # Return list of allocated block numbers or empty if not enough\n        pass\n    \n    def free(self, blocks):\n        pass\n    \n    def get_free_count(self):\n        pass",
    "solution": "class BlockBitmap:\n    def __init__(self, num_blocks):\n        self.bitmap = [False] * num_blocks  # False = free\n\n    def allocate(self, num_blocks):\n        allocated = []\n        for i, used in enumerate(self.bitmap):\n            if not used:\n                allocated.append(i)\n                if len(allocated) == num_blocks:\n                    break\n        if len(allocated) < num_blocks:\n            return []  # Not enough blocks\n        for block in allocated:\n            self.bitmap[block] = True\n        return allocated\n\n    def free(self, blocks):\n        for block in blocks:\n            if 0 <= block < len(self.bitmap):\n                self.bitmap[block] = False\n\n    def get_free_count(self):\n        return sum(1 for used in self.bitmap if not used)",
    "testCases": [
      {
        "input": "bb = BlockBitmap(10); bb.allocate(3)",
        "expectedOutput": "[0, 1, 2]",
        "isHidden": false,
        "description": "Allocate 3 blocks"
      },
      {
        "input": "bb = BlockBitmap(5); bb.allocate(3); bb.get_free_count()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Free count after allocation"
      }
    ],
    "hints": [
      "Search for free bits",
      "Mark allocated bits as used"
    ]
  },
  {
    "id": "cs301-ex-7-13",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Path Resolution",
    "description": "Resolve a file path to its inode.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def resolve_path(path, root_inode, get_directory):\n    # get_directory(inode) returns list of (name, inode)\n    # Return final inode or -1 if not found\n    pass",
    "solution": "def resolve_path(path, root_inode, get_directory):\n    if not path or path == \"/\":\n        return root_inode\n\n    parts = path.strip(\"/\").split(\"/\")\n    current = root_inode\n\n    for part in parts:\n        if not part:\n            continue\n        directory = get_directory(current)\n        found = False\n        for name, inode in directory:\n            if name == part:\n                current = inode\n                found = True\n                break\n        if not found:\n            return -1\n\n    return current",
    "testCases": [
      {
        "input": "\"/home/user/file.txt\", 1, lambda i: {1: [(\"home\", 2)], 2: [(\"user\", 3)], 3: [(\"file.txt\", 100)]}[i]",
        "expectedOutput": "100",
        "isHidden": false,
        "description": "Full path resolution"
      },
      {
        "input": "\"/\", 1, lambda i: []",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Root path"
      }
    ],
    "hints": [
      "Split path into components",
      "Look up each component in current directory"
    ]
  },
  {
    "id": "cs301-ex-7-14",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Journal Entry",
    "description": "Create and apply journal entries for file system operations.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class JournalEntry:\n    def __init__(self, operation, block, old_data, new_data):\n        pass\n\ndef apply_journal(entries, blocks):\n    # Apply all committed entries to blocks dict\n    # Return updated blocks\n    pass",
    "solution": "class JournalEntry:\n    def __init__(self, operation, block, old_data, new_data):\n        self.operation = operation\n        self.block = block\n        self.old_data = old_data\n        self.new_data = new_data\n        self.committed = False\n\ndef apply_journal(entries, blocks):\n    result = blocks.copy()\n    for entry in entries:\n        if entry.committed:\n            result[entry.block] = entry.new_data\n    return result",
    "testCases": [
      {
        "input": "e = JournalEntry(\"write\", 5, \"old\", \"new\"); e.committed = True; apply_journal([e], {5: \"old\"})",
        "expectedOutput": "{5: \"new\"}",
        "isHidden": false,
        "description": "Apply committed entry"
      },
      {
        "input": "e = JournalEntry(\"write\", 5, \"old\", \"new\"); apply_journal([e], {5: \"old\"})",
        "expectedOutput": "{5: \"old\"}",
        "isHidden": false,
        "description": "Uncommitted not applied"
      }
    ],
    "hints": [
      "Only apply committed entries",
      "Replace block data with new_data"
    ]
  },
  {
    "id": "cs301-ex-7-15",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Permission Check",
    "description": "Check if a user has permission for an operation.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def check_permission(user_id, group_id, file_owner, file_group, file_mode, operation):\n    # file_mode is octal like 0o755\n    # operation: \"read\", \"write\", \"execute\"\n    # Return True if permitted\n    pass",
    "solution": "def check_permission(user_id, group_id, file_owner, file_group, file_mode, operation):\n    op_bit = {\"read\": 4, \"write\": 2, \"execute\": 1}[operation]\n\n    if user_id == file_owner:\n        perms = (file_mode >> 6) & 0o7\n    elif group_id == file_group:\n        perms = (file_mode >> 3) & 0o7\n    else:\n        perms = file_mode & 0o7\n\n    return (perms & op_bit) != 0",
    "testCases": [
      {
        "input": "100, 50, 100, 50, 0o755, \"read\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Owner read"
      },
      {
        "input": "200, 50, 100, 50, 0o750, \"read\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Group read"
      },
      {
        "input": "300, 60, 100, 50, 0o750, \"read\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Other no read"
      }
    ],
    "hints": [
      "Check owner, group, then other",
      "Extract permission bits"
    ]
  },
  {
    "id": "cs301-ex-7-16",
    "subjectId": "cs301",
    "topicId": "cs301-t7",
    "title": "Block Cache (Buffer Cache)",
    "description": "Implement a simple LRU block cache.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class BlockCache:\n    def __init__(self, capacity):\n        pass\n    \n    def read(self, block_num, disk_read_func):\n        # Return block data, reading from disk if not cached\n        pass\n    \n    def write(self, block_num, data):\n        # Write to cache (write-back)\n        pass\n    \n    def flush(self, disk_write_func):\n        # Write all dirty blocks to disk\n        pass",
    "solution": "class BlockCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}  # block_num -> (data, dirty)\n        self.lru_order = []\n\n    def read(self, block_num, disk_read_func):\n        if block_num in self.cache:\n            # Move to end (most recent)\n            self.lru_order.remove(block_num)\n            self.lru_order.append(block_num)\n            return self.cache[block_num][0]\n\n        # Read from disk\n        data = disk_read_func(block_num)\n\n        # Evict if full\n        if len(self.cache) >= self.capacity:\n            victim = self.lru_order.pop(0)\n            del self.cache[victim]\n\n        self.cache[block_num] = (data, False)\n        self.lru_order.append(block_num)\n        return data\n\n    def write(self, block_num, data):\n        if block_num in self.cache:\n            self.lru_order.remove(block_num)\n\n        if len(self.cache) >= self.capacity and block_num not in self.cache:\n            victim = self.lru_order.pop(0)\n            del self.cache[victim]\n\n        self.cache[block_num] = (data, True)  # Mark dirty\n        self.lru_order.append(block_num)\n\n    def flush(self, disk_write_func):\n        for block_num, (data, dirty) in list(self.cache.items()):\n            if dirty:\n                disk_write_func(block_num, data)\n                self.cache[block_num] = (data, False)",
    "testCases": [
      {
        "input": "bc = BlockCache(2); bc.read(1, lambda b: f\"data{b}\"); bc.read(2, lambda b: f\"data{b}\"); bc.read(1, lambda b: \"new\")",
        "expectedOutput": "\"data1\"",
        "isHidden": false,
        "description": "Cache hit"
      },
      {
        "input": "bc = BlockCache(2); bc.write(1, \"x\"); 1 in bc.cache",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Write to cache"
      }
    ],
    "hints": [
      "Use LRU for eviction",
      "Track dirty flag for write-back"
    ]
  }
]
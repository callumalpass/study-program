[
  {
    "id": "cs303-t1-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Paradigms Fundamentals",
    "questions": [
      {
        "id": "cs303-t1-q1-1",
        "type": "multiple_choice",
        "prompt": "Which paradigm treats computation as the evaluation of mathematical functions and avoids changing state?",
        "options": [
          "Imperative programming",
          "Functional programming",
          "Object-oriented programming",
          "Logic programming"
        ],
        "correctAnswer": 1,
        "explanation": "Functional programming emphasizes pure functions, immutability, and declarative expressions without side effects."
      },
      {
        "id": "cs303-t1-q1-2",
        "type": "multiple_choice",
        "prompt": "What is the primary characteristic of imperative programming?",
        "options": [
          "Pattern matching",
          "Explicit control flow through statements",
          "Logical inference",
          "Message passing between objects"
        ],
        "correctAnswer": 1,
        "explanation": "Imperative programming uses statements that change program state, with explicit control flow through loops and conditionals."
      },
      {
        "id": "cs303-t1-q1-3",
        "type": "multiple_choice",
        "prompt": "Which paradigm uses facts and rules to derive conclusions through logical inference?",
        "options": [
          "Functional programming",
          "Imperative programming",
          "Logic programming",
          "Event-driven programming"
        ],
        "correctAnswer": 2,
        "explanation": "Logic programming (e.g., Prolog) expresses computation through logical statements and derives answers through inference."
      },
      {
        "id": "cs303-t1-q1-4",
        "type": "multiple_choice",
        "prompt": "What distinguishes declarative programming from imperative programming?",
        "options": [
          "Declarative uses more memory",
          "Declarative describes what to compute, not how",
          "Declarative is always faster",
          "Declarative requires compilation"
        ],
        "correctAnswer": 1,
        "explanation": "Declarative programming specifies the desired result, leaving implementation details to the language/runtime."
      },
      {
        "id": "cs303-t1-q1-5",
        "type": "multiple_choice",
        "prompt": "Which is NOT a core concept of object-oriented programming?",
        "options": [
          "Encapsulation",
          "Inheritance",
          "Polymorphism",
          "Unification"
        ],
        "correctAnswer": 3,
        "explanation": "Unification is a concept from logic programming. OOP core concepts are encapsulation, inheritance, polymorphism, and abstraction."
      }
    ]
  },
  {
    "id": "cs303-t1-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Paradigms Application",
    "questions": [
      {
        "id": "cs303-t1-q2-1",
        "type": "multiple_choice",
        "prompt": "Which concurrency model uses isolated processes that communicate through message passing?",
        "options": [
          "Shared memory with locks",
          "Actor model",
          "Thread pool",
          "Busy waiting"
        ],
        "correctAnswer": 1,
        "explanation": "The Actor model uses isolated actors that maintain private state and communicate exclusively through asynchronous messages."
      },
      {
        "id": "cs303-t1-q2-2",
        "type": "multiple_choice",
        "prompt": "What does CSP (Communicating Sequential Processes) use for synchronization?",
        "options": [
          "Mutexes",
          "Channels",
          "Semaphores",
          "Barriers"
        ],
        "correctAnswer": 1,
        "explanation": "CSP uses channels for communication and synchronization between concurrent processes."
      },
      {
        "id": "cs303-t1-q2-3",
        "type": "multiple_choice",
        "prompt": "Which language is considered purely functional with lazy evaluation by default?",
        "options": [
          "Scala",
          "OCaml",
          "Haskell",
          "F#"
        ],
        "correctAnswer": 2,
        "explanation": "Haskell is a purely functional language with lazy evaluation by default, enforcing referential transparency."
      },
      {
        "id": "cs303-t1-q2-4",
        "type": "multiple_choice",
        "prompt": "What is a multi-paradigm language?",
        "options": [
          "A language that only supports OOP",
          "A language supporting multiple programming styles",
          "A language with multiple compilers",
          "A language for multi-core processors"
        ],
        "correctAnswer": 1,
        "explanation": "Multi-paradigm languages like Python, Scala, and JavaScript support multiple programming paradigms within the same language."
      },
      {
        "id": "cs303-t1-q2-5",
        "type": "multiple_choice",
        "prompt": "In Prolog, what is unification?",
        "options": [
          "Combining multiple programs",
          "Pattern matching that can bind variables",
          "Merging databases",
          "Compiling code"
        ],
        "correctAnswer": 1,
        "explanation": "Unification in Prolog matches terms and binds variables to make terms identical, forming the basis of logical inference."
      }
    ]
  },
  {
    "id": "cs303-t1-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Advanced Paradigms",
    "questions": [
      {
        "id": "cs303-t1-q3-1",
        "type": "multiple_choice",
        "prompt": "What problem does the Actor model help avoid compared to shared-memory concurrency?",
        "options": [
          "Memory leaks",
          "Race conditions and deadlocks",
          "Stack overflow",
          "Type errors"
        ],
        "correctAnswer": 1,
        "explanation": "By eliminating shared mutable state, the Actor model avoids race conditions and many deadlock scenarios."
      },
      {
        "id": "cs303-t1-q3-2",
        "type": "multiple_choice",
        "prompt": "Which paradigm would be most suitable for a rule-based expert system?",
        "options": [
          "Object-oriented",
          "Functional",
          "Logic programming",
          "Imperative"
        ],
        "correctAnswer": 2,
        "explanation": "Logic programming excels at expressing rules and deriving conclusions, making it ideal for expert systems."
      },
      {
        "id": "cs303-t1-q3-3",
        "type": "multiple_choice",
        "prompt": "What is referential transparency?",
        "options": [
          "Being able to see through objects",
          "An expression can be replaced by its value",
          "Code that references other code",
          "Transparent error handling"
        ],
        "correctAnswer": 1,
        "explanation": "Referential transparency means an expression can be replaced with its value without changing program behavior."
      },
      {
        "id": "cs303-t1-q3-4",
        "type": "multiple_choice",
        "prompt": "Which feature distinguishes prototype-based OOP from class-based OOP?",
        "options": [
          "No inheritance",
          "Objects inherit directly from other objects",
          "No encapsulation",
          "Static typing"
        ],
        "correctAnswer": 1,
        "explanation": "In prototype-based OOP (e.g., JavaScript), objects inherit directly from other objects rather than from classes."
      },
      {
        "id": "cs303-t1-q3-5",
        "type": "multiple_choice",
        "prompt": "What is a closure in functional programming?",
        "options": [
          "A way to close files",
          "A function with its captured environment",
          "The end of a program",
          "A type of loop"
        ],
        "correctAnswer": 1,
        "explanation": "A closure is a function that captures and retains access to variables from its defining scope."
      }
    ]
  },
  {
    "id": "cs303-t2-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Fundamentals",
    "questions": [
      {
        "id": "cs303-t2-q1-1",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of a type system?",
        "options": [
          "To make code run faster",
          "To prevent certain kinds of errors",
          "To reduce code size",
          "To improve readability only"
        ],
        "correctAnswer": 1,
        "explanation": "Type systems prevent type errors by ensuring operations are applied to appropriate values."
      },
      {
        "id": "cs303-t2-q1-2",
        "type": "multiple_choice",
        "prompt": "When are types checked in a statically-typed language?",
        "options": [
          "At runtime",
          "At compile time",
          "At linking time",
          "Never"
        ],
        "correctAnswer": 1,
        "explanation": "Static typing checks types at compile time, catching errors before the program runs."
      },
      {
        "id": "cs303-t2-q1-3",
        "type": "multiple_choice",
        "prompt": "Which language uses dynamic typing?",
        "options": [
          "Java",
          "C",
          "Python",
          "Haskell"
        ],
        "correctAnswer": 2,
        "explanation": "Python uses dynamic typing where type checking occurs at runtime rather than compile time."
      },
      {
        "id": "cs303-t2-q1-4",
        "type": "multiple_choice",
        "prompt": "What is type inference?",
        "options": [
          "Guessing types at runtime",
          "Automatic deduction of types by the compiler",
          "Converting between types",
          "Defining new types"
        ],
        "correctAnswer": 1,
        "explanation": "Type inference allows the compiler to deduce types automatically without explicit annotations."
      },
      {
        "id": "cs303-t2-q1-5",
        "type": "multiple_choice",
        "prompt": "What does \"strongly typed\" typically mean?",
        "options": [
          "Types are checked at compile time",
          "Implicit type conversions are restricted",
          "Variables must have types",
          "Types cannot change"
        ],
        "correctAnswer": 1,
        "explanation": "Strong typing restricts implicit type conversions, requiring explicit conversion between incompatible types."
      }
    ]
  },
  {
    "id": "cs303-t2-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Advanced Types",
    "questions": [
      {
        "id": "cs303-t2-q2-1",
        "type": "multiple_choice",
        "prompt": "What is parametric polymorphism?",
        "options": [
          "Multiple inheritance",
          "Functions that work on multiple types uniformly",
          "Method overloading",
          "Type casting"
        ],
        "correctAnswer": 1,
        "explanation": "Parametric polymorphism allows functions to work uniformly over any type, using type parameters (generics)."
      },
      {
        "id": "cs303-t2-q2-2",
        "type": "multiple_choice",
        "prompt": "What is an algebraic data type?",
        "options": [
          "A type for mathematical operations",
          "A composite type formed by sum and product types",
          "A numeric type",
          "A type alias"
        ],
        "correctAnswer": 1,
        "explanation": "ADTs combine sum types (variants/enums) and product types (tuples/records) to model data structures."
      },
      {
        "id": "cs303-t2-q2-3",
        "type": "multiple_choice",
        "prompt": "What is the Hindley-Milner type system known for?",
        "options": [
          "No type inference",
          "Complete and decidable type inference",
          "Only supporting integers",
          "Manual type annotations required"
        ],
        "correctAnswer": 1,
        "explanation": "Hindley-Milner provides complete, decidable type inference with principal types, used in ML and Haskell."
      },
      {
        "id": "cs303-t2-q2-4",
        "type": "multiple_choice",
        "prompt": "What is subtype polymorphism?",
        "options": [
          "Types that are smaller in memory",
          "A subtype can be used where a supertype is expected",
          "Creating subtypes dynamically",
          "Type parameters"
        ],
        "correctAnswer": 1,
        "explanation": "Subtype polymorphism (Liskov substitution) allows a subtype to be used wherever its supertype is expected."
      },
      {
        "id": "cs303-t2-q2-5",
        "type": "multiple_choice",
        "prompt": "What are dependent types?",
        "options": [
          "Types that depend on runtime",
          "Types that can depend on values",
          "Types with dependencies",
          "Circular type definitions"
        ],
        "correctAnswer": 1,
        "explanation": "Dependent types allow types to depend on values, enabling more expressive type-level programming."
      }
    ]
  },
  {
    "id": "cs303-t2-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Soundness",
    "questions": [
      {
        "id": "cs303-t2-q3-1",
        "type": "multiple_choice",
        "prompt": "What does type soundness guarantee?",
        "options": [
          "Fast compilation",
          "Well-typed programs don't get stuck",
          "Optimal performance",
          "No memory leaks"
        ],
        "correctAnswer": 1,
        "explanation": "Type soundness guarantees that well-typed programs won't encounter type errors at runtime (won't get stuck)."
      },
      {
        "id": "cs303-t2-q3-2",
        "type": "multiple_choice",
        "prompt": "What are the two properties that prove type soundness?",
        "options": [
          "Speed and correctness",
          "Progress and preservation",
          "Soundness and completeness",
          "Safety and liveness"
        ],
        "correctAnswer": 1,
        "explanation": "Type soundness is proven through progress (well-typed terms can take a step) and preservation (typing is preserved after steps)."
      },
      {
        "id": "cs303-t2-q3-3",
        "type": "multiple_choice",
        "prompt": "What is ad-hoc polymorphism?",
        "options": [
          "Random polymorphism",
          "Polymorphism through overloading or type classes",
          "Temporary polymorphism",
          "Polymorphism without types"
        ],
        "correctAnswer": 1,
        "explanation": "Ad-hoc polymorphism provides different implementations for different types through overloading or type classes."
      },
      {
        "id": "cs303-t2-q3-4",
        "type": "multiple_choice",
        "prompt": "What is a phantom type?",
        "options": [
          "A type that doesn't exist",
          "A type parameter not used in the data structure but provides compile-time information",
          "A deleted type",
          "A runtime-only type"
        ],
        "correctAnswer": 1,
        "explanation": "Phantom types are type parameters that don't appear in the data structure but carry compile-time information."
      },
      {
        "id": "cs303-t2-q3-5",
        "type": "multiple_choice",
        "prompt": "What problem does the Option/Maybe type solve?",
        "options": [
          "Memory management",
          "Null pointer exceptions",
          "Concurrency",
          "Performance"
        ],
        "correctAnswer": 1,
        "explanation": "Option/Maybe types make absence of values explicit in the type system, eliminating null pointer exceptions."
      }
    ]
  },
  {
    "id": "cs303-t3-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "FP Fundamentals",
    "questions": [
      {
        "id": "cs303-t3-q1-1",
        "type": "multiple_choice",
        "prompt": "What is a pure function?",
        "options": [
          "A function without bugs",
          "A function that always returns the same output for the same input and has no side effects",
          "A function with no parameters",
          "A function that never fails"
        ],
        "correctAnswer": 1,
        "explanation": "Pure functions are deterministic (same input → same output) and have no observable side effects."
      },
      {
        "id": "cs303-t3-q1-2",
        "type": "multiple_choice",
        "prompt": "What does immutability mean?",
        "options": [
          "Cannot be moved",
          "Data cannot be changed after creation",
          "Cannot be deleted",
          "Cannot be copied"
        ],
        "correctAnswer": 1,
        "explanation": "Immutability means once data is created, it cannot be modified. New data structures are created instead."
      },
      {
        "id": "cs303-t3-q1-3",
        "type": "multiple_choice",
        "prompt": "What is a higher-order function?",
        "options": [
          "A function in a higher directory",
          "A function that takes functions as arguments or returns functions",
          "A more important function",
          "A recursive function"
        ],
        "correctAnswer": 1,
        "explanation": "Higher-order functions can accept functions as parameters and/or return functions as results."
      },
      {
        "id": "cs303-t3-q1-4",
        "type": "multiple_choice",
        "prompt": "What does map do?",
        "options": [
          "Creates a geographic map",
          "Applies a function to each element of a collection",
          "Maps keys to values",
          "Reduces a collection"
        ],
        "correctAnswer": 1,
        "explanation": "Map applies a transformation function to each element of a collection, producing a new collection."
      },
      {
        "id": "cs303-t3-q1-5",
        "type": "multiple_choice",
        "prompt": "What is function composition?",
        "options": [
          "Writing functions",
          "Combining functions so output of one becomes input of another",
          "Decomposing functions",
          "Function documentation"
        ],
        "correctAnswer": 1,
        "explanation": "Function composition creates a new function by chaining functions: (f ∘ g)(x) = f(g(x))."
      }
    ]
  },
  {
    "id": "cs303-t3-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Advanced FP Concepts",
    "questions": [
      {
        "id": "cs303-t3-q2-1",
        "type": "multiple_choice",
        "prompt": "What is tail recursion?",
        "options": [
          "Recursion at the end of a list",
          "Recursion where the recursive call is the last operation",
          "Recursion without a base case",
          "Infinite recursion"
        ],
        "correctAnswer": 1,
        "explanation": "Tail recursion has the recursive call as the final operation, allowing compiler optimization to avoid stack growth."
      },
      {
        "id": "cs303-t3-q2-2",
        "type": "multiple_choice",
        "prompt": "What is a fold/reduce operation?",
        "options": [
          "Folding paper",
          "Combining collection elements into a single value using a function",
          "Reducing code size",
          "Compressing data"
        ],
        "correctAnswer": 1,
        "explanation": "Fold/reduce traverses a collection, combining elements into an accumulated result using a combining function."
      },
      {
        "id": "cs303-t3-q2-3",
        "type": "multiple_choice",
        "prompt": "In lambda calculus, what is β-reduction?",
        "options": [
          "Removing variables",
          "Substituting arguments into function bodies",
          "Reducing complexity",
          "Beta testing"
        ],
        "correctAnswer": 1,
        "explanation": "β-reduction applies a function by substituting the argument for the bound variable in the function body."
      },
      {
        "id": "cs303-t3-q2-4",
        "type": "multiple_choice",
        "prompt": "What is lazy evaluation?",
        "options": [
          "Slow evaluation",
          "Delaying evaluation until the result is needed",
          "Incomplete evaluation",
          "Parallel evaluation"
        ],
        "correctAnswer": 1,
        "explanation": "Lazy evaluation defers computation until the result is actually needed, enabling infinite data structures."
      },
      {
        "id": "cs303-t3-q2-5",
        "type": "multiple_choice",
        "prompt": "What is a thunk?",
        "options": [
          "A sound effect",
          "A suspended computation awaiting evaluation",
          "A type of error",
          "A memory block"
        ],
        "correctAnswer": 1,
        "explanation": "A thunk is a deferred computation that captures an expression and its environment for later evaluation."
      }
    ]
  },
  {
    "id": "cs303-t3-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Monads and Functors",
    "questions": [
      {
        "id": "cs303-t3-q3-1",
        "type": "multiple_choice",
        "prompt": "What is a Functor in functional programming?",
        "options": [
          "A type of function",
          "A type that can be mapped over",
          "A function factory",
          "A debugging tool"
        ],
        "correctAnswer": 1,
        "explanation": "A Functor is a type with a map operation that applies a function to values inside a context."
      },
      {
        "id": "cs303-t3-q3-2",
        "type": "multiple_choice",
        "prompt": "What operations must a Monad support?",
        "options": [
          "map and filter",
          "return/unit and bind/flatMap",
          "get and set",
          "read and write"
        ],
        "correctAnswer": 1,
        "explanation": "Monads require return (wrap a value) and bind/flatMap (sequence computations that return wrapped values)."
      },
      {
        "id": "cs303-t3-q3-3",
        "type": "multiple_choice",
        "prompt": "What problem does the IO Monad solve in Haskell?",
        "options": [
          "Memory management",
          "Sequencing side effects in a pure language",
          "Parallel I/O",
          "File compression"
        ],
        "correctAnswer": 1,
        "explanation": "The IO Monad allows Haskell to sequence I/O operations while maintaining purity and referential transparency."
      },
      {
        "id": "cs303-t3-q3-4",
        "type": "multiple_choice",
        "prompt": "What is the difference between foldl and foldr?",
        "options": [
          "No difference",
          "foldl processes left-to-right, foldr right-to-left",
          "foldl is faster",
          "foldr is safer"
        ],
        "correctAnswer": 1,
        "explanation": "foldl accumulates from the left (beginning), foldr from the right (end), affecting associativity and laziness."
      },
      {
        "id": "cs303-t3-q3-5",
        "type": "multiple_choice",
        "prompt": "What is an Applicative Functor?",
        "options": [
          "A functor for applications",
          "A functor that allows applying wrapped functions to wrapped values",
          "A special kind of monad",
          "A debugging functor"
        ],
        "correctAnswer": 1,
        "explanation": "Applicative Functors extend Functors with the ability to apply functions inside a context to values inside a context."
      }
    ]
  },
  {
    "id": "cs303-t4-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Semantics Basics",
    "questions": [
      {
        "id": "cs303-t4-q1-1",
        "type": "multiple_choice",
        "prompt": "What is the purpose of formal semantics?",
        "options": [
          "To make code look formal",
          "To give precise mathematical meaning to programs",
          "To improve performance",
          "To simplify syntax"
        ],
        "correctAnswer": 1,
        "explanation": "Formal semantics provides unambiguous, mathematical definitions of what programs mean and how they behave."
      },
      {
        "id": "cs303-t4-q1-2",
        "type": "multiple_choice",
        "prompt": "What does operational semantics describe?",
        "options": [
          "Operations on data",
          "How programs execute step by step",
          "Operator precedence",
          "Operating system behavior"
        ],
        "correctAnswer": 1,
        "explanation": "Operational semantics defines program meaning through execution rules that describe computation steps."
      },
      {
        "id": "cs303-t4-q1-3",
        "type": "multiple_choice",
        "prompt": "What is the difference between big-step and small-step semantics?",
        "options": [
          "Size of programs",
          "Big-step evaluates to final value; small-step shows individual steps",
          "Memory usage",
          "Compilation speed"
        ],
        "correctAnswer": 1,
        "explanation": "Big-step (natural) semantics relates expressions to final values; small-step (structural) shows each computation step."
      },
      {
        "id": "cs303-t4-q1-4",
        "type": "multiple_choice",
        "prompt": "What does denotational semantics do?",
        "options": [
          "Denotes variable names",
          "Maps programs to mathematical objects (denotations)",
          "Describes program names",
          "Defines notation"
        ],
        "correctAnswer": 1,
        "explanation": "Denotational semantics maps programs to mathematical objects that represent their meaning compositionally."
      },
      {
        "id": "cs303-t4-q1-5",
        "type": "multiple_choice",
        "prompt": "What is a semantic domain?",
        "options": [
          "A website for semantics",
          "The set of possible meanings for a language construct",
          "A domain name",
          "A type of variable"
        ],
        "correctAnswer": 1,
        "explanation": "A semantic domain is the mathematical set that provides the meanings (denotations) for language constructs."
      }
    ]
  },
  {
    "id": "cs303-t4-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Axiomatic Semantics",
    "questions": [
      {
        "id": "cs303-t4-q2-1",
        "type": "multiple_choice",
        "prompt": "What is Hoare logic used for?",
        "options": [
          "Logic puzzles",
          "Reasoning about program correctness with pre/postconditions",
          "Boolean logic",
          "Hardware design"
        ],
        "correctAnswer": 1,
        "explanation": "Hoare logic uses {P}C{Q} triples to specify that if precondition P holds and C executes, postcondition Q holds."
      },
      {
        "id": "cs303-t4-q2-2",
        "type": "multiple_choice",
        "prompt": "In a Hoare triple {P} C {Q}, what is P?",
        "options": [
          "Program",
          "Precondition",
          "Postcondition",
          "Procedure"
        ],
        "correctAnswer": 1,
        "explanation": "P is the precondition: the assertion that must be true before command C executes."
      },
      {
        "id": "cs303-t4-q2-3",
        "type": "multiple_choice",
        "prompt": "What is a loop invariant?",
        "options": [
          "A loop that never changes",
          "An assertion true before and after each loop iteration",
          "A constant in a loop",
          "An infinite loop"
        ],
        "correctAnswer": 1,
        "explanation": "A loop invariant is an assertion that holds before and after every iteration, used to reason about loops."
      },
      {
        "id": "cs303-t4-q2-4",
        "type": "multiple_choice",
        "prompt": "What does partial correctness mean?",
        "options": [
          "Partially working code",
          "If the program terminates, it satisfies the specification",
          "Some tests pass",
          "Incomplete implementation"
        ],
        "correctAnswer": 1,
        "explanation": "Partial correctness means if a program terminates, the postcondition holds. It doesn't guarantee termination."
      },
      {
        "id": "cs303-t4-q2-5",
        "type": "multiple_choice",
        "prompt": "What additional property is needed for total correctness?",
        "options": [
          "Performance",
          "Termination",
          "Documentation",
          "Testing"
        ],
        "correctAnswer": 1,
        "explanation": "Total correctness = partial correctness + termination (the program must terminate)."
      }
    ]
  },
  {
    "id": "cs303-t4-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Program Verification",
    "questions": [
      {
        "id": "cs303-t4-q3-1",
        "type": "multiple_choice",
        "prompt": "What is abstract interpretation?",
        "options": [
          "Art interpretation",
          "Analyzing programs using approximations of their semantics",
          "Interpreting bytecode",
          "Abstract art programming"
        ],
        "correctAnswer": 1,
        "explanation": "Abstract interpretation analyzes programs by computing over abstract domains that approximate concrete values."
      },
      {
        "id": "cs303-t4-q3-2",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a weakest precondition?",
        "options": [
          "Finding bugs",
          "Finding the minimal precondition that ensures a postcondition",
          "Weak typing",
          "Performance optimization"
        ],
        "correctAnswer": 1,
        "explanation": "The weakest precondition wp(C,Q) is the least restrictive precondition guaranteeing postcondition Q after C."
      },
      {
        "id": "cs303-t4-q3-3",
        "type": "multiple_choice",
        "prompt": "What is a fixed point in denotational semantics?",
        "options": [
          "A constant value",
          "A value x where f(x) = x, used to define recursion",
          "A point in memory",
          "The end of a program"
        ],
        "correctAnswer": 1,
        "explanation": "Fixed points define recursive functions: the meaning of recursion is the least fixed point of a function."
      },
      {
        "id": "cs303-t4-q3-4",
        "type": "multiple_choice",
        "prompt": "What does soundness mean for a program analysis?",
        "options": [
          "It makes sound",
          "If it reports no errors, the program is error-free",
          "It runs quietly",
          "It's well-documented"
        ],
        "correctAnswer": 1,
        "explanation": "A sound analysis never misses real errors (no false negatives), though it may report false positives."
      },
      {
        "id": "cs303-t4-q3-5",
        "type": "multiple_choice",
        "prompt": "What does completeness mean for a program analysis?",
        "options": [
          "All code is analyzed",
          "If the program is error-free, no errors are reported",
          "The analysis finishes",
          "Full test coverage"
        ],
        "correctAnswer": 1,
        "explanation": "A complete analysis reports errors only for actual errors (no false positives), but may miss some errors."
      }
    ]
  },
  {
    "id": "cs303-t5-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Interpreter Basics",
    "questions": [
      {
        "id": "cs303-t5-q1-1",
        "type": "multiple_choice",
        "prompt": "What is the main difference between an interpreter and a compiler?",
        "options": [
          "Speed",
          "An interpreter executes code directly; a compiler translates to another language",
          "Memory usage",
          "Language support"
        ],
        "correctAnswer": 1,
        "explanation": "Interpreters execute source code directly, while compilers translate to another language (often machine code)."
      },
      {
        "id": "cs303-t5-q1-2",
        "type": "multiple_choice",
        "prompt": "What is an Abstract Syntax Tree (AST)?",
        "options": [
          "A tree in abstract art",
          "A tree structure representing the syntactic structure of code",
          "A database tree",
          "A file system tree"
        ],
        "correctAnswer": 1,
        "explanation": "An AST represents the hierarchical syntactic structure of source code, abstracting away parsing details."
      },
      {
        "id": "cs303-t5-q1-3",
        "type": "multiple_choice",
        "prompt": "What is lexical scoping?",
        "options": [
          "Scoping for words",
          "Variable scope determined by program text structure",
          "Dictionary-based scoping",
          "Runtime scoping"
        ],
        "correctAnswer": 1,
        "explanation": "Lexical (static) scoping determines variable binding based on where variables are defined in the source code."
      },
      {
        "id": "cs303-t5-q1-4",
        "type": "multiple_choice",
        "prompt": "What is dynamic scoping?",
        "options": [
          "Scoping that changes",
          "Variable scope determined by the runtime call stack",
          "Fast scoping",
          "Type-based scoping"
        ],
        "correctAnswer": 1,
        "explanation": "Dynamic scoping looks up variables based on the runtime calling context, not lexical structure."
      },
      {
        "id": "cs303-t5-q1-5",
        "type": "multiple_choice",
        "prompt": "What is an environment in an interpreter?",
        "options": [
          "The operating system",
          "A mapping from variable names to values",
          "Hardware settings",
          "External libraries"
        ],
        "correctAnswer": 1,
        "explanation": "An environment is a data structure mapping identifiers to their bound values during evaluation."
      }
    ]
  },
  {
    "id": "cs303-t5-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Evaluation Strategies",
    "questions": [
      {
        "id": "cs303-t5-q2-1",
        "type": "multiple_choice",
        "prompt": "What is call-by-value evaluation?",
        "options": [
          "Calling by phone",
          "Arguments are evaluated before being passed to functions",
          "Passing values directly",
          "Value-based programming"
        ],
        "correctAnswer": 1,
        "explanation": "Call-by-value evaluates arguments before the function call, passing the resulting values."
      },
      {
        "id": "cs303-t5-q2-2",
        "type": "multiple_choice",
        "prompt": "What is call-by-reference?",
        "options": [
          "Using references",
          "Arguments share memory location with parameters",
          "Referencing documentation",
          "Calling by name"
        ],
        "correctAnswer": 1,
        "explanation": "Call-by-reference passes a reference to the argument, so modifications affect the original."
      },
      {
        "id": "cs303-t5-q2-3",
        "type": "multiple_choice",
        "prompt": "What is call-by-name?",
        "options": [
          "Using string names",
          "Arguments are substituted unevaluated, evaluated when used",
          "Named parameters",
          "Nominal typing"
        ],
        "correctAnswer": 1,
        "explanation": "Call-by-name substitutes unevaluated argument expressions, evaluating them each time they're used."
      },
      {
        "id": "cs303-t5-q2-4",
        "type": "multiple_choice",
        "prompt": "What is call-by-need?",
        "options": [
          "On-demand calling",
          "Like call-by-name but caches results after first evaluation",
          "Need-based allocation",
          "Lazy calling"
        ],
        "correctAnswer": 1,
        "explanation": "Call-by-need (lazy evaluation) is call-by-name with memoization: evaluate once, cache the result."
      },
      {
        "id": "cs303-t5-q2-5",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a closure?",
        "options": [
          "Closing files",
          "Capturing the environment where a function is defined",
          "Ending programs",
          "Closing connections"
        ],
        "correctAnswer": 1,
        "explanation": "A closure packages a function with its defining environment, enabling access to captured variables."
      }
    ]
  },
  {
    "id": "cs303-t5-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Advanced Interpreters",
    "questions": [
      {
        "id": "cs303-t5-q3-1",
        "type": "multiple_choice",
        "prompt": "What is a continuation?",
        "options": [
          "A sequel",
          "A representation of the rest of the computation",
          "A continuation statement",
          "A loop construct"
        ],
        "correctAnswer": 1,
        "explanation": "A continuation represents \"what to do next\" - the remaining computation after the current expression."
      },
      {
        "id": "cs303-t5-q3-2",
        "type": "multiple_choice",
        "prompt": "What is CPS (Continuation-Passing Style)?",
        "options": [
          "A coding standard",
          "A style where functions receive an explicit continuation argument",
          "Continuous processing system",
          "A design pattern"
        ],
        "correctAnswer": 1,
        "explanation": "CPS transforms functions to explicitly pass continuations, making control flow explicit."
      },
      {
        "id": "cs303-t5-q3-3",
        "type": "multiple_choice",
        "prompt": "What is a metacircular evaluator?",
        "options": [
          "A circular dependency",
          "An interpreter for a language written in that same language",
          "A looping evaluator",
          "Recursive evaluation"
        ],
        "correctAnswer": 1,
        "explanation": "A metacircular evaluator interprets a language using that same language, revealing its semantic essence."
      },
      {
        "id": "cs303-t5-q3-4",
        "type": "multiple_choice",
        "prompt": "What does defunctionalization do?",
        "options": [
          "Removes functions",
          "Converts higher-order programs to first-order by representing functions as data",
          "Debugging functions",
          "Function optimization"
        ],
        "correctAnswer": 1,
        "explanation": "Defunctionalization transforms higher-order functions into first-order code using data structures."
      },
      {
        "id": "cs303-t5-q3-5",
        "type": "multiple_choice",
        "prompt": "What is the eval/apply cycle?",
        "options": [
          "A testing cycle",
          "The fundamental interpreter loop: evaluate expressions, apply functions",
          "An IDE feature",
          "A compilation phase"
        ],
        "correctAnswer": 1,
        "explanation": "Eval/apply is the core interpreter structure: eval evaluates expressions, apply applies functions to arguments."
      }
    ]
  },
  {
    "id": "cs303-t6-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Memory Basics",
    "questions": [
      {
        "id": "cs303-t6-q1-1",
        "type": "multiple_choice",
        "prompt": "What is stored on the stack?",
        "options": [
          "All variables",
          "Function call frames and local variables",
          "Global data",
          "Objects"
        ],
        "correctAnswer": 1,
        "explanation": "The stack stores function call frames including return addresses, parameters, and local variables."
      },
      {
        "id": "cs303-t6-q1-2",
        "type": "multiple_choice",
        "prompt": "What is stored on the heap?",
        "options": [
          "Only strings",
          "Dynamically allocated objects with varying lifetimes",
          "Function code",
          "Constants"
        ],
        "correctAnswer": 1,
        "explanation": "The heap stores dynamically allocated data whose lifetime isn't tied to function calls."
      },
      {
        "id": "cs303-t6-q1-3",
        "type": "multiple_choice",
        "prompt": "What is a memory leak?",
        "options": [
          "Physical damage",
          "Allocated memory that is no longer accessible but not freed",
          "Data loss",
          "Buffer overflow"
        ],
        "correctAnswer": 1,
        "explanation": "A memory leak occurs when allocated memory becomes unreachable but isn't deallocated."
      },
      {
        "id": "cs303-t6-q1-4",
        "type": "multiple_choice",
        "prompt": "What is a dangling pointer?",
        "options": [
          "An unused pointer",
          "A pointer to memory that has been freed",
          "A null pointer",
          "A pointer arithmetic error"
        ],
        "correctAnswer": 1,
        "explanation": "A dangling pointer references memory that has been deallocated, leading to undefined behavior."
      },
      {
        "id": "cs303-t6-q1-5",
        "type": "multiple_choice",
        "prompt": "What is RAII (Resource Acquisition Is Initialization)?",
        "options": [
          "A programming language",
          "Tying resource lifetime to object lifetime",
          "A memory allocator",
          "An initialization pattern"
        ],
        "correctAnswer": 1,
        "explanation": "RAII ties resource management to object lifetime: acquire in constructor, release in destructor."
      }
    ]
  },
  {
    "id": "cs303-t6-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Garbage Collection",
    "questions": [
      {
        "id": "cs303-t6-q2-1",
        "type": "multiple_choice",
        "prompt": "What is the basic principle of garbage collection?",
        "options": [
          "Deleting files",
          "Automatically reclaiming unreachable memory",
          "Compressing data",
          "Defragmenting disk"
        ],
        "correctAnswer": 1,
        "explanation": "Garbage collection automatically identifies and reclaims memory that is no longer reachable by the program."
      },
      {
        "id": "cs303-t6-q2-2",
        "type": "multiple_choice",
        "prompt": "How does mark-and-sweep work?",
        "options": [
          "Marks files for deletion",
          "Marks reachable objects, sweeps (frees) unmarked objects",
          "Marks errors",
          "Sweeps the stack"
        ],
        "correctAnswer": 1,
        "explanation": "Mark-and-sweep traces from roots marking reachable objects, then frees all unmarked objects."
      },
      {
        "id": "cs303-t6-q2-3",
        "type": "multiple_choice",
        "prompt": "What is the main problem with reference counting?",
        "options": [
          "Too slow",
          "Cannot reclaim circular references",
          "Uses too much memory",
          "Only works for integers"
        ],
        "correctAnswer": 1,
        "explanation": "Reference counting cannot reclaim cycles where objects reference each other but are unreachable from roots."
      },
      {
        "id": "cs303-t6-q2-4",
        "type": "multiple_choice",
        "prompt": "What is generational garbage collection based on?",
        "options": [
          "Code generations",
          "The hypothesis that most objects die young",
          "Generation gaps",
          "Old programming styles"
        ],
        "correctAnswer": 1,
        "explanation": "Generational GC exploits the observation that most objects are short-lived, focusing collection on young objects."
      },
      {
        "id": "cs303-t6-q2-5",
        "type": "multiple_choice",
        "prompt": "What is a GC root?",
        "options": [
          "The main function",
          "A starting point for reachability tracing",
          "Root directory",
          "The heap start"
        ],
        "correctAnswer": 1,
        "explanation": "GC roots are the starting points for tracing: global variables, stack references, and registers."
      }
    ]
  },
  {
    "id": "cs303-t6-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Modern Memory Management",
    "questions": [
      {
        "id": "cs303-t6-q3-1",
        "type": "multiple_choice",
        "prompt": "What is Rust's ownership system?",
        "options": [
          "Copyright management",
          "Each value has one owner; ownership can be moved or borrowed",
          "File ownership",
          "Thread ownership"
        ],
        "correctAnswer": 1,
        "explanation": "Rust's ownership: each value has one owner, transferring ownership moves the value, borrowing allows temporary access."
      },
      {
        "id": "cs303-t6-q3-2",
        "type": "multiple_choice",
        "prompt": "What is the borrow checker in Rust?",
        "options": [
          "A library checker",
          "A compiler component that enforces borrowing rules",
          "A runtime check",
          "A linter"
        ],
        "correctAnswer": 1,
        "explanation": "Rust's borrow checker statically enforces that references don't outlive their referents and prevents aliased mutation."
      },
      {
        "id": "cs303-t6-q3-3",
        "type": "multiple_choice",
        "prompt": "What is region-based memory management?",
        "options": [
          "Geographic allocation",
          "Allocating objects in regions that are freed together",
          "Regional programming",
          "Disk regions"
        ],
        "correctAnswer": 1,
        "explanation": "Region-based management groups objects into regions/arenas that are deallocated together, avoiding individual frees."
      },
      {
        "id": "cs303-t6-q3-4",
        "type": "multiple_choice",
        "prompt": "What are linear types used for?",
        "options": [
          "Linear algebra",
          "Ensuring values are used exactly once",
          "Line-by-line processing",
          "Linear search"
        ],
        "correctAnswer": 1,
        "explanation": "Linear types ensure each value is used exactly once, enabling safe resource management without GC."
      },
      {
        "id": "cs303-t6-q3-5",
        "type": "multiple_choice",
        "prompt": "What is a write barrier in garbage collection?",
        "options": [
          "Preventing writes",
          "Code executed on pointer writes to maintain GC invariants",
          "A memory protection",
          "A lock"
        ],
        "correctAnswer": 1,
        "explanation": "Write barriers are hooks on pointer updates that maintain information needed by the garbage collector."
      }
    ]
  },
  {
    "id": "cs303-t7-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Metaprogramming",
    "questions": [
      {
        "id": "cs303-t7-q1-1",
        "type": "multiple_choice",
        "prompt": "What is metaprogramming?",
        "options": [
          "Programming metadata",
          "Writing programs that manipulate programs",
          "Programming about programming",
          "Documentation"
        ],
        "correctAnswer": 1,
        "explanation": "Metaprogramming is writing programs that generate, analyze, or transform other programs or themselves."
      },
      {
        "id": "cs303-t7-q1-2",
        "type": "multiple_choice",
        "prompt": "What are macros in programming?",
        "options": [
          "Large programs",
          "Code transformations that happen before or during compilation",
          "Keyboard shortcuts",
          "Function aliases"
        ],
        "correctAnswer": 1,
        "explanation": "Macros are compile-time code transformations that expand into other code."
      },
      {
        "id": "cs303-t7-q1-3",
        "type": "multiple_choice",
        "prompt": "What is reflection?",
        "options": [
          "Code comments",
          "A program examining and modifying its own structure at runtime",
          "Error reflection",
          "Code review"
        ],
        "correctAnswer": 1,
        "explanation": "Reflection allows programs to inspect and modify their own structure and behavior at runtime."
      },
      {
        "id": "cs303-t7-q1-4",
        "type": "multiple_choice",
        "prompt": "What is the difference between hygienic and unhygienic macros?",
        "options": [
          "Cleanliness",
          "Hygienic macros avoid accidental variable capture",
          "Documentation style",
          "Performance"
        ],
        "correctAnswer": 1,
        "explanation": "Hygienic macros automatically rename variables to prevent accidental capture, avoiding subtle bugs."
      },
      {
        "id": "cs303-t7-q1-5",
        "type": "multiple_choice",
        "prompt": "What is code generation?",
        "options": [
          "Writing code",
          "Automatically producing source code from specifications or models",
          "Version control",
          "Compilation"
        ],
        "correctAnswer": 1,
        "explanation": "Code generation automatically produces source or target code from higher-level specifications."
      }
    ]
  },
  {
    "id": "cs303-t7-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Generics and Pattern Matching",
    "questions": [
      {
        "id": "cs303-t7-q2-1",
        "type": "multiple_choice",
        "prompt": "What are generics?",
        "options": [
          "Generic code",
          "Parameterizing types over other types",
          "Base classes",
          "Default implementations"
        ],
        "correctAnswer": 1,
        "explanation": "Generics (parametric polymorphism) allow types and functions to be parameterized over other types."
      },
      {
        "id": "cs303-t7-q2-2",
        "type": "multiple_choice",
        "prompt": "What is type erasure?",
        "options": [
          "Deleting types",
          "Removing generic type information after compilation",
          "Type errors",
          "Type conversion"
        ],
        "correctAnswer": 1,
        "explanation": "Type erasure removes generic type parameters after type checking (used by Java for backwards compatibility)."
      },
      {
        "id": "cs303-t7-q2-3",
        "type": "multiple_choice",
        "prompt": "What is pattern matching?",
        "options": [
          "String matching",
          "Checking data against patterns and binding variables",
          "Regex",
          "Image recognition"
        ],
        "correctAnswer": 1,
        "explanation": "Pattern matching tests values against patterns, destructuring data and binding matched parts to variables."
      },
      {
        "id": "cs303-t7-q2-4",
        "type": "multiple_choice",
        "prompt": "What is exhaustiveness checking in pattern matching?",
        "options": [
          "Performance testing",
          "Verifying all possible cases are handled",
          "Testing thoroughly",
          "Checking for loops"
        ],
        "correctAnswer": 1,
        "explanation": "Exhaustiveness checking ensures pattern matches cover all possible cases, preventing runtime match failures."
      },
      {
        "id": "cs303-t7-q2-5",
        "type": "multiple_choice",
        "prompt": "What is template metaprogramming in C++?",
        "options": [
          "Using templates",
          "Performing computations at compile time using templates",
          "Template design",
          "Generic programming"
        ],
        "correctAnswer": 1,
        "explanation": "Template metaprogramming uses C++ templates to perform computations at compile time."
      }
    ]
  },
  {
    "id": "cs303-t7-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Modern Language Features",
    "questions": [
      {
        "id": "cs303-t7-q3-1",
        "type": "multiple_choice",
        "prompt": "What is an effect system?",
        "options": [
          "Visual effects",
          "A type system extension tracking computational effects",
          "Sound effects",
          "Side effect removal"
        ],
        "correctAnswer": 1,
        "explanation": "Effect systems extend type systems to track and control computational effects like I/O or state."
      },
      {
        "id": "cs303-t7-q3-2",
        "type": "multiple_choice",
        "prompt": "What are coroutines?",
        "options": [
          "Cooperative routines",
          "Functions that can suspend and resume their execution",
          "Helper functions",
          "Library functions"
        ],
        "correctAnswer": 1,
        "explanation": "Coroutines are generalizations of subroutines that can yield control and resume later, enabling cooperative concurrency."
      },
      {
        "id": "cs303-t7-q3-3",
        "type": "multiple_choice",
        "prompt": "What is an embedded DSL?",
        "options": [
          "Hardware DSL",
          "A domain-specific language implemented within a host language",
          "Embedded systems language",
          "A small DSL"
        ],
        "correctAnswer": 1,
        "explanation": "An embedded DSL is built using the host language's features, inheriting its tooling and interoperability."
      },
      {
        "id": "cs303-t7-q3-4",
        "type": "multiple_choice",
        "prompt": "What is the purpose of async/await?",
        "options": [
          "Asynchronous loading",
          "Simplifying asynchronous code to look synchronous",
          "Waiting for input",
          "Async testing"
        ],
        "correctAnswer": 1,
        "explanation": "Async/await syntax makes asynchronous code read like synchronous code while maintaining non-blocking behavior."
      },
      {
        "id": "cs303-t7-q3-5",
        "type": "multiple_choice",
        "prompt": "Why is language versioning important?",
        "options": [
          "Tracking changes",
          "Enabling language evolution while maintaining compatibility",
          "Version control",
          "Documentation"
        ],
        "correctAnswer": 1,
        "explanation": "Language versioning allows adding features and fixing issues while maintaining backwards compatibility with existing code."
      }
    ]
  }
]
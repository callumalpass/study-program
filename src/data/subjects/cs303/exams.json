[
  {
    "id": "cs303-exam-midterm",
    "subjectId": "cs303",
    "title": "CS303 Midterm Exam",
    "durationMinutes": 75,
    "instructions": [
      "This exam covers Topics 1-4: Programming Paradigms, Type Systems, Functional Programming, and Formal Semantics.",
      "Answer all questions. Passing score is 70%.",
      "For coding questions, write in Python unless otherwise specified."
    ],
    "questions": [
      {
        "id": "cs303-mid-q1",
        "type": "multiple_choice",
        "prompt": "Which paradigm emphasizes immutability and pure functions?",
        "options": [
          "Imperative",
          "Object-oriented",
          "Functional",
          "Logic"
        ],
        "correctAnswer": 2,
        "explanation": "Functional programming is characterized by immutability and pure functions without side effects."
      },
      {
        "id": "cs303-mid-q2",
        "type": "multiple_choice",
        "prompt": "What distinguishes declarative from imperative programming?",
        "options": [
          "Focus on state mutation",
          "Specifying how to compute",
          "Specifying what to compute",
          "Using classes"
        ],
        "correctAnswer": 2,
        "explanation": "Declarative programming focuses on what result is desired, not how to achieve it step by step."
      },
      {
        "id": "cs303-mid-q3",
        "type": "multiple_choice",
        "prompt": "In OOP, encapsulation refers to:",
        "options": [
          "Inheriting methods",
          "Bundling data with methods and controlling access",
          "Creating multiple forms",
          "Using interfaces"
        ],
        "correctAnswer": 1,
        "explanation": "Encapsulation bundles data and methods together while controlling access to internal state."
      },
      {
        "id": "cs303-mid-q4",
        "type": "multiple_choice",
        "prompt": "Polymorphism allows:",
        "options": [
          "Creating singletons",
          "Multiple inheritance only",
          "Treating different types uniformly",
          "Static type checking"
        ],
        "correctAnswer": 2,
        "explanation": "Polymorphism enables writing code that can work with objects of different types through a common interface."
      },
      {
        "id": "cs303-mid-q5",
        "type": "multiple_choice",
        "prompt": "In logic programming, what does backtracking accomplish?",
        "options": [
          "Memory management",
          "Exploring alternative solutions",
          "Type checking",
          "Code optimization"
        ],
        "correctAnswer": 1,
        "explanation": "Backtracking allows logic programming systems to explore alternative paths when one fails."
      },
      {
        "id": "cs303-mid-q6",
        "type": "multiple_choice",
        "prompt": "What is type inference?",
        "options": [
          "Manual type annotations",
          "Automatic deduction of types",
          "Type coercion",
          "Dynamic typing"
        ],
        "correctAnswer": 1,
        "explanation": "Type inference automatically determines types without explicit annotations from the programmer."
      },
      {
        "id": "cs303-mid-q7",
        "type": "multiple_choice",
        "prompt": "A covariant type parameter can be used in:",
        "options": [
          "Input positions only",
          "Output positions only",
          "Both positions",
          "Neither position"
        ],
        "correctAnswer": 1,
        "explanation": "Covariance allows subtyping to flow in the same direction, which is safe for output positions."
      },
      {
        "id": "cs303-mid-q8",
        "type": "multiple_choice",
        "prompt": "Structural typing matches types based on:",
        "options": [
          "Type names",
          "Type structure/shape",
          "Inheritance hierarchy",
          "Declaration order"
        ],
        "correctAnswer": 1,
        "explanation": "Structural typing compares the shape/structure of types rather than their declared names."
      },
      {
        "id": "cs303-mid-q9",
        "type": "multiple_choice",
        "prompt": "Gradual typing allows:",
        "options": [
          "Only static types",
          "Only dynamic types",
          "Mixing static and dynamic typing",
          "No type checking"
        ],
        "correctAnswer": 2,
        "explanation": "Gradual typing enables mixing statically typed and dynamically typed code in the same program."
      },
      {
        "id": "cs303-mid-q10",
        "type": "multiple_choice",
        "prompt": "A phantom type parameter:",
        "options": [
          "Must always be used",
          "Appears at type level but not runtime",
          "Causes runtime errors",
          "Is always inferred"
        ],
        "correctAnswer": 1,
        "explanation": "Phantom types exist only at compile time for additional type safety without runtime overhead."
      },
      {
        "id": "cs303-mid-q11",
        "type": "multiple_choice",
        "prompt": "In functional programming, map:",
        "options": [
          "Reduces a list to a single value",
          "Applies a function to each element",
          "Filters elements",
          "Sorts elements"
        ],
        "correctAnswer": 1,
        "explanation": "Map applies a transformation function to each element, producing a new collection."
      },
      {
        "id": "cs303-mid-q12",
        "type": "multiple_choice",
        "prompt": "A closure captures:",
        "options": [
          "Only global variables",
          "Variables from enclosing scope",
          "All program state",
          "Only parameters"
        ],
        "correctAnswer": 1,
        "explanation": "Closures capture and remember variables from the lexical scope where they were defined."
      },
      {
        "id": "cs303-mid-q13",
        "type": "multiple_choice",
        "prompt": "Currying transforms f(a,b,c) into:",
        "options": [
          "f(a)(b)(c)",
          "f([a,b,c])",
          "f(a+b+c)",
          "f(c,b,a)"
        ],
        "correctAnswer": 0,
        "explanation": "Currying transforms a multi-argument function into a sequence of single-argument functions."
      },
      {
        "id": "cs303-mid-q14",
        "type": "multiple_choice",
        "prompt": "Lazy evaluation means:",
        "options": [
          "Eager computation",
          "Computing values only when needed",
          "Sequential execution",
          "Parallel execution"
        ],
        "correctAnswer": 1,
        "explanation": "Lazy evaluation delays computation until the result is actually required."
      },
      {
        "id": "cs303-mid-q15",
        "type": "multiple_choice",
        "prompt": "A Functor in FP provides:",
        "options": [
          "map operation",
          "flatMap operation",
          "filter operation",
          "reduce operation"
        ],
        "correctAnswer": 0,
        "explanation": "Functors define the map operation for applying functions inside a context."
      },
      {
        "id": "cs303-mid-q16",
        "type": "multiple_choice",
        "prompt": "A Monad adds to Functor:",
        "options": [
          "filter",
          "flatMap/bind",
          "reduce",
          "zip"
        ],
        "correctAnswer": 1,
        "explanation": "Monads add flatMap (bind) which allows sequencing computations that return wrapped values."
      },
      {
        "id": "cs303-mid-q17",
        "type": "written",
        "prompt": "What are the four pillars of object-oriented programming?",
        "correctAnswer": "Encapsulation, abstraction, inheritance, and polymorphism",
        "modelAnswer": "The four pillars of OOP are: (1) Encapsulation - bundling data and methods together while hiding internal details; (2) Abstraction - exposing only essential features while hiding complexity; (3) Inheritance - creating new classes based on existing ones to promote code reuse; (4) Polymorphism - treating objects of different types uniformly through shared interfaces.",
        "explanation": "These four principles guide object-oriented design and enable modular, maintainable code."
      },
      {
        "id": "cs303-mid-q18",
        "type": "written",
        "prompt": "What is the difference between nominal and structural typing?",
        "correctAnswer": "Nominal typing uses declared type names for compatibility; structural typing uses type structure",
        "modelAnswer": "Nominal typing determines type compatibility based on explicit declarations and type names - two types are compatible only if declared to be. Structural typing determines compatibility based on the shape or structure of types - two types are compatible if they have the same structure (same fields/methods) regardless of their names. Java uses nominal typing; TypeScript uses structural typing.",
        "explanation": "This distinction affects how types can be used interchangeably in different type systems."
      },
      {
        "id": "cs303-mid-q19",
        "type": "written",
        "prompt": "Explain what referential transparency means in functional programming.",
        "correctAnswer": "An expression can be replaced with its value without changing program behavior",
        "modelAnswer": "Referential transparency means that any expression can be replaced with its corresponding value without changing the program behavior. This property holds when expressions have no side effects - they depend only on their inputs and always produce the same outputs. Referentially transparent code is easier to reason about, test, and optimize because expressions can be evaluated independently.",
        "explanation": "Referential transparency enables equational reasoning and simplifies program analysis."
      },
      {
        "id": "cs303-mid-q20",
        "type": "written",
        "prompt": "What is the difference between small-step and big-step operational semantics?",
        "correctAnswer": "Small-step shows individual reduction steps; big-step relates expressions directly to final values",
        "modelAnswer": "Small-step (structural) operational semantics defines computation as a sequence of individual reduction steps, showing how each expression transforms into the next. Big-step (natural) semantics directly relates expressions to their final values without showing intermediate steps. Small-step is better for reasoning about non-termination and control flow; big-step is often simpler to define and closer to implementation.",
        "explanation": "Both approaches formally define program meaning through different levels of granularity."
      },
      {
        "id": "cs303-mid-q21",
        "type": "written",
        "prompt": "What is a Hoare triple and what does it represent?",
        "correctAnswer": "{P} S {Q} means if P holds before S and S terminates, Q holds after",
        "modelAnswer": "A Hoare triple {P} S {Q} consists of a precondition P, a program S, and a postcondition Q. It means: if the precondition P is true before executing S, and if S terminates, then the postcondition Q will be true afterward. This is partial correctness (doesnt guarantee termination). Hoare triples are the foundation of axiomatic semantics and enable formal program verification.",
        "explanation": "Hoare logic provides a framework for proving programs correct with respect to specifications."
      },
      {
        "id": "cs303-mid-q22",
        "type": "coding",
        "prompt": "Write a higher-order function that composes two functions.",
        "correctAnswer": "def compose(f, g): return lambda x: f(g(x))",
        "solution": "def compose(f, g):\n    return lambda x: f(g(x))\n\n# Test\nadd1 = lambda x: x + 1\ndouble = lambda x: x * 2\nadd1_then_double = compose(double, add1)\nprint(add1_then_double(3))  # 8",
        "language": "python",
        "explanation": "Function composition applies g first, then f to the result, creating a pipeline of transformations."
      },
      {
        "id": "cs303-mid-q23",
        "type": "coding",
        "prompt": "Implement a memoization decorator.",
        "correctAnswer": "def memoize(f):\n  cache = {}\n  def wrapper(*args):\n    if args not in cache:\n      cache[args] = f(*args)\n    return cache[args]\n  return wrapper",
        "solution": "def memoize(f):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = f(*args)\n        return cache[args]\n    return wrapper\n\n@memoize\ndef fib(n):\n    return n if n < 2 else fib(n-1) + fib(n-2)\n\nprint(fib(30))  # Fast due to memoization",
        "language": "python",
        "explanation": "Memoization caches function results to avoid redundant computation for repeated inputs."
      },
      {
        "id": "cs303-mid-q24",
        "type": "coding",
        "prompt": "Write a curried function that adds three numbers.",
        "correctAnswer": "def curry_add(a): return lambda b: lambda c: a + b + c",
        "solution": "def curry_add(a):\n    return lambda b: lambda c: a + b + c\n\n# Usage\nadd5 = curry_add(5)\nadd5and3 = add5(3)\nresult = add5and3(2)  # 10\n\n# Or call directly\nresult = curry_add(1)(2)(3)  # 6",
        "language": "python",
        "explanation": "Currying allows partial application, fixing arguments one at a time."
      },
      {
        "id": "cs303-mid-q25",
        "type": "coding",
        "prompt": "Implement the map function using reduce.",
        "correctAnswer": "from functools import reduce\ndef map_reduce(f, lst): return reduce(lambda acc, x: acc + [f(x)], lst, [])",
        "solution": "from functools import reduce\n\ndef map_reduce(f, lst):\n    return reduce(lambda acc, x: acc + [f(x)], lst, [])\n\n# Test\nresult = map_reduce(lambda x: x * 2, [1, 2, 3, 4])\nprint(result)  # [2, 4, 6, 8]",
        "language": "python",
        "explanation": "Map can be expressed as a fold/reduce that accumulates transformed elements into a new list."
      },
      {
        "id": "cs303-mid-q26",
        "type": "coding",
        "prompt": "Write a simple type checker for arithmetic expressions that returns \"int\" for valid expressions.",
        "correctAnswer": "def type_check(e): return \"int\" if isinstance(e, int) or (isinstance(e, tuple) and e[0] in [\"+\",\"-\"] and type_check(e[1]) == type_check(e[2]) == \"int\") else None",
        "solution": "def type_check(e):\n    if isinstance(e, int):\n        return \"int\"\n    if isinstance(e, tuple) and e[0] in [\"+\", \"-\", \"*\"]:\n        t1 = type_check(e[1])\n        t2 = type_check(e[2])\n        if t1 == \"int\" and t2 == \"int\":\n            return \"int\"\n    return None\n\n# Test\nprint(type_check((\"+\", 1, 2)))           # int\nprint(type_check((\"+\", 1, (\"+\", 2, 3)))) # int\nprint(type_check((\"+\", 1, \"x\")))         # None",
        "language": "python",
        "explanation": "A simple type checker recursively validates that operations are applied to correctly typed operands."
      }
    ]
  },
  {
    "id": "cs303-exam-final",
    "subjectId": "cs303",
    "title": "CS303 Final Exam",
    "durationMinutes": 120,
    "instructions": [
      "This comprehensive exam covers all topics: Paradigms, Type Systems, Functional Programming, Semantics, Interpreters, Memory Management, and Advanced Features.",
      "Answer all questions. Passing score is 70%.",
      "For coding questions, write in Python unless otherwise specified."
    ],
    "questions": [
      {
        "id": "cs303-final-q1",
        "type": "multiple_choice",
        "prompt": "Which is NOT a programming paradigm?",
        "options": [
          "Imperative",
          "Declarative",
          "Recursive",
          "Logic"
        ],
        "correctAnswer": 2,
        "explanation": "Recursive is a programming technique, not a paradigm. The main paradigms are imperative, declarative, functional, logic, and object-oriented."
      },
      {
        "id": "cs303-final-q2",
        "type": "multiple_choice",
        "prompt": "The von Neumann architecture most directly influences which paradigm?",
        "options": [
          "Functional",
          "Imperative",
          "Logic",
          "Declarative"
        ],
        "correctAnswer": 1,
        "explanation": "The von Neumann architecture with its fetch-execute cycle directly maps to imperative programming with sequential state modification."
      },
      {
        "id": "cs303-final-q3",
        "type": "multiple_choice",
        "prompt": "Duck typing is an example of:",
        "options": [
          "Static nominal typing",
          "Structural typing",
          "Gradual typing",
          "Dependent typing"
        ],
        "correctAnswer": 1,
        "explanation": "Duck typing checks type compatibility based on the presence of methods/properties, not declared type names."
      },
      {
        "id": "cs303-final-q4",
        "type": "multiple_choice",
        "prompt": "Type erasure means:",
        "options": [
          "Types are enforced at runtime",
          "Generic types are removed after compilation",
          "Types cannot be inferred",
          "All types are dynamic"
        ],
        "correctAnswer": 1,
        "explanation": "Type erasure removes generic type information after compilation, used in Java generics."
      },
      {
        "id": "cs303-final-q5",
        "type": "multiple_choice",
        "prompt": "Hindley-Milner type inference is used in:",
        "options": [
          "Java",
          "Python",
          "ML/Haskell",
          "JavaScript"
        ],
        "correctAnswer": 2,
        "explanation": "Hindley-Milner provides complete and decidable type inference for polymorphic lambda calculus, used in ML family and Haskell."
      },
      {
        "id": "cs303-final-q6",
        "type": "multiple_choice",
        "prompt": "Denotational semantics maps programs to:",
        "options": [
          "Machine code",
          "Mathematical objects",
          "Execution traces",
          "Test cases"
        ],
        "correctAnswer": 1,
        "explanation": "Denotational semantics gives meaning to programs by mapping them to mathematical objects like functions and sets."
      },
      {
        "id": "cs303-final-q7",
        "type": "multiple_choice",
        "prompt": "A loop invariant must be true:",
        "options": [
          "Only at loop start",
          "Only at loop end",
          "Before and after each iteration",
          "Only inside the loop body"
        ],
        "correctAnswer": 2,
        "explanation": "A loop invariant is a condition that holds before the loop starts and is preserved by each iteration."
      },
      {
        "id": "cs303-final-q8",
        "type": "multiple_choice",
        "prompt": "Abstract interpretation provides:",
        "options": [
          "Exact program behavior",
          "Sound over-approximation",
          "Always terminates",
          "Dynamic analysis"
        ],
        "correctAnswer": 1,
        "explanation": "Abstract interpretation analyzes programs using abstract domains, providing sound but potentially imprecise results."
      },
      {
        "id": "cs303-final-q9",
        "type": "multiple_choice",
        "prompt": "The CEK machine stands for:",
        "options": [
          "Code, Environment, Kontinuation",
          "Control, Environment, Kontinuation",
          "Closure, Expression, Key",
          "Compute, Evaluate, Keep"
        ],
        "correctAnswer": 1,
        "explanation": "CEK machine is an abstract machine with Control (expression), Environment (bindings), and Kontinuation (what to do next)."
      },
      {
        "id": "cs303-final-q10",
        "type": "multiple_choice",
        "prompt": "A bytecode interpreter typically uses:",
        "options": [
          "Direct AST traversal",
          "Native compilation",
          "Virtual instructions",
          "Text parsing"
        ],
        "correctAnswer": 2,
        "explanation": "Bytecode interpreters execute virtual machine instructions, providing portability and simpler implementation than native code."
      },
      {
        "id": "cs303-final-q11",
        "type": "multiple_choice",
        "prompt": "Reference counting cannot detect:",
        "options": [
          "Single references",
          "Null pointers",
          "Cyclic references",
          "Strong references"
        ],
        "correctAnswer": 2,
        "explanation": "Reference counting fails to collect cycles because objects in a cycle maintain non-zero counts pointing to each other."
      },
      {
        "id": "cs303-final-q12",
        "type": "multiple_choice",
        "prompt": "Mark-and-sweep GC requires:",
        "options": [
          "Reference counting",
          "Tracing from roots",
          "Manual deallocation",
          "Static analysis"
        ],
        "correctAnswer": 1,
        "explanation": "Mark-and-sweep traces from root references to find all reachable objects, then reclaims unreachable memory."
      },
      {
        "id": "cs303-final-q13",
        "type": "multiple_choice",
        "prompt": "Generational GC is based on the hypothesis that:",
        "options": [
          "All objects live forever",
          "Most objects die young",
          "Old objects die first",
          "Memory is unlimited"
        ],
        "correctAnswer": 1,
        "explanation": "The generational hypothesis states that most objects have short lifetimes, so young generations are collected frequently."
      },
      {
        "id": "cs303-final-q14",
        "type": "multiple_choice",
        "prompt": "Rusts ownership system prevents:",
        "options": [
          "All runtime errors",
          "Data races at compile time",
          "Stack allocation",
          "Function calls"
        ],
        "correctAnswer": 1,
        "explanation": "Rusts ownership and borrowing rules guarantee memory safety and prevent data races without garbage collection."
      },
      {
        "id": "cs303-final-q15",
        "type": "multiple_choice",
        "prompt": "Linear types ensure resources are used:",
        "options": [
          "At least once",
          "At most once",
          "Exactly once",
          "Never"
        ],
        "correctAnswer": 2,
        "explanation": "Linear types require resources to be used exactly once, preventing both leaks and double-use."
      },
      {
        "id": "cs303-final-q16",
        "type": "multiple_choice",
        "prompt": "First-class functions means functions can be:",
        "options": [
          "Only called",
          "Passed as arguments and returned",
          "Only defined at top level",
          "Only recursive"
        ],
        "correctAnswer": 1,
        "explanation": "First-class functions can be passed as arguments, returned from functions, and assigned to variables like any other value."
      },
      {
        "id": "cs303-final-q17",
        "type": "multiple_choice",
        "prompt": "A metaclass in Python controls:",
        "options": [
          "Instance creation",
          "Class creation",
          "Module import",
          "Function calls"
        ],
        "correctAnswer": 1,
        "explanation": "Metaclasses are classes of classes that control how classes themselves are created and behave."
      },
      {
        "id": "cs303-final-q18",
        "type": "multiple_choice",
        "prompt": "Coroutines differ from subroutines by:",
        "options": [
          "Being faster",
          "Supporting multiple entry/exit points",
          "Using less memory",
          "Being simpler"
        ],
        "correctAnswer": 1,
        "explanation": "Coroutines can suspend execution and resume later, allowing multiple entry and exit points."
      },
      {
        "id": "cs303-final-q19",
        "type": "multiple_choice",
        "prompt": "Algebraic effects separate:",
        "options": [
          "Data and functions",
          "Effect definition and handling",
          "Types and values",
          "Static and dynamic"
        ],
        "correctAnswer": 1,
        "explanation": "Algebraic effects separate effect operations from their handlers, providing modular effect management."
      },
      {
        "id": "cs303-final-q20",
        "type": "multiple_choice",
        "prompt": "Multiple dispatch selects methods based on:",
        "options": [
          "Only the first argument",
          "Only the return type",
          "All argument types",
          "Only the receiver"
        ],
        "correctAnswer": 2,
        "explanation": "Multiple dispatch considers the runtime types of all arguments to select the appropriate method implementation."
      },
      {
        "id": "cs303-final-q21",
        "type": "multiple_choice",
        "prompt": "Continuation-passing style (CPS) transforms:",
        "options": [
          "Data structures",
          "Control flow to explicit continuations",
          "Types to values",
          "Static to dynamic"
        ],
        "correctAnswer": 1,
        "explanation": "CPS makes control flow explicit by passing continuation functions representing what to do next."
      },
      {
        "id": "cs303-final-q22",
        "type": "multiple_choice",
        "prompt": "A copying garbage collector:",
        "options": [
          "Modifies objects in place",
          "Copies live objects to new space",
          "Uses reference counting",
          "Never moves objects"
        ],
        "correctAnswer": 1,
        "explanation": "Copying collectors move live objects to a new space, achieving compaction and fast allocation."
      },
      {
        "id": "cs303-final-q23",
        "type": "written",
        "prompt": "Explain the difference between parametric and ad-hoc polymorphism.",
        "correctAnswer": "Parametric polymorphism works uniformly for all types; ad-hoc polymorphism provides different implementations for different types",
        "modelAnswer": "Parametric polymorphism (generics) allows a single implementation to work uniformly with any type - the code doesnt depend on the specific type. Examples: generic containers, identity function. Ad-hoc polymorphism provides different implementations for different types through overloading or type classes. Examples: operator overloading, Haskells Eq class. Parametric polymorphism guarantees parametricity (behavior independent of type); ad-hoc allows type-specific behavior.",
        "explanation": "These two forms of polymorphism serve different purposes in type system design."
      },
      {
        "id": "cs303-final-q24",
        "type": "written",
        "prompt": "What is the halting problem and why is it relevant to programming languages?",
        "correctAnswer": "The halting problem proves we cannot determine if arbitrary programs terminate; affects what properties compilers can check",
        "modelAnswer": "The halting problem, proven undecidable by Turing, shows that no algorithm can determine whether an arbitrary program will terminate. For programming languages, this means: (1) compilers cannot always detect infinite loops; (2) type systems must balance expressiveness with decidability; (3) program verification requires restrictions or human guidance; (4) some optimizations are theoretically impossible in general.",
        "explanation": "The halting problem establishes fundamental limits on static program analysis."
      },
      {
        "id": "cs303-final-q25",
        "type": "written",
        "prompt": "Explain the difference between lexical and dynamic scoping.",
        "correctAnswer": "Lexical scoping binds variables based on program text structure; dynamic scoping uses runtime call stack",
        "modelAnswer": "Lexical (static) scoping determines variable bindings based on where the code is written in the source text - a function uses variables from its definition site. Dynamic scoping uses the runtime call stack - a function uses variables from its call site. Lexical scoping enables closures and local reasoning about code. Dynamic scoping was used in early Lisps but is rarely used today because it makes code harder to understand and maintain.",
        "explanation": "Scoping rules determine how variable names are resolved to their values."
      },
      {
        "id": "cs303-final-q26",
        "type": "written",
        "prompt": "What is escape analysis and how does it help optimization?",
        "correctAnswer": "Escape analysis determines if objects escape their scope; non-escaping objects can be stack-allocated",
        "modelAnswer": "Escape analysis determines whether a reference escapes its creating method or thread. If an object doesnt escape, it can be: (1) stack-allocated instead of heap-allocated, avoiding GC overhead; (2) scalar-replaced, eliminating the object entirely; (3) used without synchronization in multithreaded code. This optimization is used in JVMs and Go to reduce allocation and GC pressure while maintaining semantic correctness.",
        "explanation": "Escape analysis enables important memory optimizations without changing program behavior."
      },
      {
        "id": "cs303-final-q27",
        "type": "written",
        "prompt": "Describe the relationship between monads and algebraic effects.",
        "correctAnswer": "Both handle computational effects; monads sequence effects via bind; algebraic effects separate effect definition from handling",
        "modelAnswer": "Both monads and algebraic effects manage computational effects (I/O, state, exceptions). Monads encode effects in types and sequence them with bind (>>=), but different monads dont compose easily (requiring transformers). Algebraic effects define effect operations separately from handlers, allowing more modular composition - handlers can interpret the same effect differently in different contexts. Algebraic effects can express all monad transformers more cleanly.",
        "explanation": "Algebraic effects provide a more composable approach to effect management than monads."
      },
      {
        "id": "cs303-final-q28",
        "type": "written",
        "prompt": "What are write barriers in garbage collection?",
        "correctAnswer": "Write barriers intercept pointer writes to maintain GC invariants during concurrent or incremental collection",
        "modelAnswer": "Write barriers are small code fragments executed on pointer writes that notify the garbage collector of heap modifications. They are essential for: (1) concurrent GC to track mutations during collection; (2) generational GC to record old-to-young pointers (remembered sets); (3) incremental GC to maintain tri-color invariants. Barriers add runtime overhead but enable GC to run without stopping the entire program.",
        "explanation": "Write barriers enable sophisticated GC algorithms that minimize pause times."
      },
      {
        "id": "cs303-final-q29",
        "type": "written",
        "prompt": "Explain the Liskov Substitution Principle.",
        "correctAnswer": "Objects of a superclass should be replaceable with objects of subclasses without affecting program correctness",
        "modelAnswer": "The Liskov Substitution Principle (LSP) states that objects of a supertype should be replaceable with objects of any subtype without altering the correctness of the program. This means subtypes must: (1) maintain the invariants of the supertype; (2) accept the same or more general inputs (contravariance); (3) return the same or more specific outputs (covariance); (4) throw the same or fewer exceptions. Violating LSP leads to fragile code and broken polymorphism.",
        "explanation": "LSP ensures subtyping hierarchies preserve semantic correctness."
      },
      {
        "id": "cs303-final-q30",
        "type": "written",
        "prompt": "What is a fixed point and why is it important for recursion?",
        "correctAnswer": "Fixed point f(x) = x; recursive functions are fixed points of functionals; enables denotational semantics of recursion",
        "modelAnswer": "A fixed point of function f is a value x where f(x) = x. In programming language theory, recursive functions are defined as fixed points of non-recursive functionals. The Y combinator computes fixed points: Y(F) = F(Y(F)). This allows denotational semantics to give meaning to recursion using domain theory and least fixed points. The Knaster-Tarski theorem guarantees existence of least fixed points in complete lattices.",
        "explanation": "Fixed point theory provides the mathematical foundation for understanding recursion."
      },
      {
        "id": "cs303-final-q31",
        "type": "coding",
        "prompt": "Implement a simple big-step evaluator for arithmetic expressions.",
        "correctAnswer": "def eval(e): return e if isinstance(e, int) else eval(e[1]) + eval(e[2]) if e[0] == \"+\" else eval(e[1]) * eval(e[2])",
        "solution": "def evaluate(e):\n    if isinstance(e, int):\n        return e\n    op, left, right = e\n    l = evaluate(left)\n    r = evaluate(right)\n    if op == \"+\": return l + r\n    if op == \"-\": return l - r\n    if op == \"*\": return l * r\n    if op == \"/\": return l // r\n\n# Test\nexpr = (\"+\", 1, (\"*\", 2, 3))  # 1 + (2 * 3)\nprint(evaluate(expr))  # 7",
        "language": "python",
        "explanation": "Big-step semantics directly evaluates expressions to values by recursively evaluating subexpressions."
      },
      {
        "id": "cs303-final-q32",
        "type": "coding",
        "prompt": "Write a function that implements the Y combinator pattern for recursion.",
        "correctAnswer": "Y = lambda f: (lambda x: f(lambda v: x(x)(v)))(lambda x: f(lambda v: x(x)(v)))",
        "solution": "Y = lambda f: (lambda x: f(lambda v: x(x)(v)))(lambda x: f(lambda v: x(x)(v)))\n\n# Usage: define factorial without explicit recursion\nfact = Y(lambda f: lambda n: 1 if n <= 1 else n * f(n - 1))\nprint(fact(5))  # 120\n\n# Fibonacci\nfib = Y(lambda f: lambda n: n if n < 2 else f(n-1) + f(n-2))\nprint(fib(10))  # 55",
        "language": "python",
        "explanation": "The Y combinator enables recursion without named self-reference by finding fixed points."
      },
      {
        "id": "cs303-final-q33",
        "type": "coding",
        "prompt": "Implement a simple mark phase for garbage collection.",
        "correctAnswer": "def mark(roots, heap):\n  marked = set()\n  worklist = list(roots)\n  while worklist:\n    addr = worklist.pop()\n    if addr not in marked:\n      marked.add(addr)\n      for ref in heap.get(addr, []):\n        worklist.append(ref)\n  return marked",
        "solution": "def mark(roots, heap):\n    \"\"\"Mark all reachable objects from roots.\n    heap: dict mapping addresses to list of referenced addresses\n    \"\"\"\n    marked = set()\n    worklist = list(roots)\n    \n    while worklist:\n        addr = worklist.pop()\n        if addr not in marked:\n            marked.add(addr)\n            for ref in heap.get(addr, []):\n                worklist.append(ref)\n    \n    return marked\n\n# Test\nheap = {0: [1, 2], 1: [3], 2: [], 3: [], 4: [5], 5: []}\nroots = [0]\nreachable = mark(roots, heap)\nprint(reachable)  # {0, 1, 2, 3} - objects 4,5 are garbage",
        "language": "python",
        "explanation": "The mark phase traces from roots to find all reachable objects using a worklist algorithm."
      },
      {
        "id": "cs303-final-q34",
        "type": "coding",
        "prompt": "Write a trampolined version of factorial to avoid stack overflow.",
        "correctAnswer": "class Thunk:\n  def __init__(self, f, *a): self.f, self.a = f, a\ndef fact(n, acc=1): return acc if n<=1 else Thunk(fact, n-1, acc*n)\ndef run(x):\n  while isinstance(x, Thunk): x = x.f(*x.a)\n  return x",
        "solution": "class Thunk:\n    def __init__(self, f, *args):\n        self.f = f\n        self.args = args\n\ndef trampoline(result):\n    while isinstance(result, Thunk):\n        result = result.f(*result.args)\n    return result\n\ndef factorial(n, acc=1):\n    if n <= 1:\n        return acc\n    return Thunk(factorial, n - 1, acc * n)\n\n# Usage\nresult = trampoline(factorial(10000))\nprint(len(str(result)))  # Number of digits - works without stack overflow",
        "language": "python",
        "explanation": "Trampolining converts tail recursion to iteration, enabling deep recursion without stack overflow."
      },
      {
        "id": "cs303-final-q35",
        "type": "coding",
        "prompt": "Implement a simple generator for infinite Fibonacci sequence.",
        "correctAnswer": "def fib():\n  a, b = 0, 1\n  while True:\n    yield a\n    a, b = b, a + b",
        "solution": "def fib():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# Usage\ngen = fib()\nfirst_ten = [next(gen) for _ in range(10)]\nprint(first_ten)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n\n# Take until condition\nfrom itertools import takewhile\nunder_100 = list(takewhile(lambda x: x < 100, fib()))\nprint(under_100)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]",
        "language": "python",
        "explanation": "Generators provide lazy infinite sequences by yielding values on demand without storing them all."
      },
      {
        "id": "cs303-final-q36",
        "type": "coding",
        "prompt": "Write a decorator that enforces type checking on function arguments.",
        "correctAnswer": "def typed(*types):\n  def dec(f):\n    def wrapper(*args):\n      for a, t in zip(args, types):\n        if not isinstance(a, t): raise TypeError\n      return f(*args)\n    return wrapper\n  return dec",
        "solution": "def typed(*types):\n    def decorator(f):\n        def wrapper(*args):\n            for arg, expected_type in zip(args, types):\n                if not isinstance(arg, expected_type):\n                    raise TypeError(f\"Expected {expected_type}, got {type(arg)}\")\n            return f(*args)\n        return wrapper\n    return decorator\n\n@typed(int, int)\ndef add(a, b):\n    return a + b\n\nprint(add(1, 2))  # 3\n# add(\"1\", 2)  # TypeError",
        "language": "python",
        "explanation": "Decorators can add runtime type checking to dynamically typed languages."
      },
      {
        "id": "cs303-final-q37",
        "type": "coding",
        "prompt": "Implement pattern matching for tuples.",
        "correctAnswer": "def match(pat, val, bindings=None):\n  if bindings is None: bindings = {}\n  if isinstance(pat, str) and pat.startswith(\"_\"): bindings[pat] = val; return bindings\n  if isinstance(pat, tuple) and isinstance(val, tuple) and len(pat) == len(val):\n    for p, v in zip(pat, val):\n      if not match(p, v, bindings): return None\n    return bindings\n  return bindings if pat == val else None",
        "solution": "def match(pattern, value, bindings=None):\n    if bindings is None:\n        bindings = {}\n    \n    # Variable pattern (starts with _)\n    if isinstance(pattern, str) and pattern.startswith(\"_\"):\n        bindings[pattern] = value\n        return bindings\n    \n    # Tuple pattern\n    if isinstance(pattern, tuple) and isinstance(value, tuple):\n        if len(pattern) != len(value):\n            return None\n        for p, v in zip(pattern, value):\n            if match(p, v, bindings) is None:\n                return None\n        return bindings\n    \n    # Literal match\n    return bindings if pattern == value else None\n\n# Test\nprint(match((\"_x\", \"_y\"), (1, 2)))  # {\"_x\": 1, \"_y\": 2}\nprint(match((1, \"_y\"), (1, 2)))     # {\"_y\": 2}\nprint(match((1, 2), (1, 3)))        # None",
        "language": "python",
        "explanation": "Pattern matching destructures data and binds variables in a declarative way."
      },
      {
        "id": "cs303-final-q38",
        "type": "coding",
        "prompt": "Write a simple bytecode compiler for arithmetic expressions.",
        "correctAnswer": "def compile(e):\n  if isinstance(e, int): return [(\"PUSH\", e)]\n  op = {\"+\" : \"ADD\", \"*\": \"MUL\"}[e[0]]\n  return compile(e[1]) + compile(e[2]) + [(op,)]",
        "solution": "def compile_expr(e):\n    if isinstance(e, int):\n        return [(\"PUSH\", e)]\n    \n    op_map = {\"+\": \"ADD\", \"-\": \"SUB\", \"*\": \"MUL\", \"/\": \"DIV\"}\n    op, left, right = e\n    \n    return compile_expr(left) + compile_expr(right) + [(op_map[op],)]\n\ndef execute(bytecode):\n    stack = []\n    for instr in bytecode:\n        if instr[0] == \"PUSH\":\n            stack.append(instr[1])\n        elif instr[0] == \"ADD\":\n            stack.append(stack.pop() + stack.pop())\n        elif instr[0] == \"MUL\":\n            stack.append(stack.pop() * stack.pop())\n    return stack[0]\n\n# Test\nexpr = (\"+\", 1, (\"*\", 2, 3))  # 1 + 2 * 3 = 7\nbytecode = compile_expr(expr)\nprint(bytecode)  # [(\"PUSH\", 1), (\"PUSH\", 2), (\"PUSH\", 3), (\"MUL\",), (\"ADD\",)]\nprint(execute(bytecode))  # 7",
        "language": "python",
        "explanation": "A bytecode compiler translates high-level expressions into stack-based virtual machine instructions."
      },
      {
        "id": "cs303-final-q39",
        "type": "coding",
        "prompt": "Implement a simple reference-counting smart pointer class.",
        "correctAnswer": "class Rc:\n  def __init__(self, v): self.v, self.count = v, 1\n  def clone(self): self.count += 1; return self\n  def drop(self): self.count -= 1; return self.count == 0",
        "solution": "class Rc:\n    \"\"\"Reference-counted smart pointer\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.count = 1\n    \n    def clone(self):\n        \"\"\"Create another reference (increment count)\"\"\"\n        self.count += 1\n        return self\n    \n    def drop(self):\n        \"\"\"Release a reference (decrement count).\n        Returns True if value should be deallocated.\"\"\"\n        self.count -= 1\n        return self.count == 0\n    \n    def get(self):\n        return self.value\n\n# Usage\nptr1 = Rc([1, 2, 3])\nptr2 = ptr1.clone()  # count = 2\nprint(ptr2.get())    # [1, 2, 3]\nptr1.drop()          # count = 1\nprint(ptr2.drop())   # True - ready to deallocate",
        "language": "python",
        "explanation": "Reference counting tracks how many pointers reference an object, deallocating when count reaches zero."
      },
      {
        "id": "cs303-final-q40",
        "type": "coding",
        "prompt": "Write a function that performs abstract interpretation with sign domain.",
        "correctAnswer": "def sign(n): return \"+\" if n > 0 else \"-\" if n < 0 else \"0\"\ndef abs_add(a, b):\n  if a == b and a in [\"+\", \"-\"]: return a\n  if a == \"0\": return b\n  if b == \"0\": return a\n  return \"?\"",
        "solution": "def sign(n):\n    \"\"\"Concrete to abstract\"\"\"\n    return \"+\" if n > 0 else \"-\" if n < 0 else \"0\"\n\ndef abs_add(a, b):\n    \"\"\"Abstract addition in sign domain\"\"\"\n    if a == b and a in [\"+\", \"-\"]:\n        return a  # + + + = +, - + - = -\n    if a == \"0\":\n        return b\n    if b == \"0\":\n        return a\n    return \"?\"  # + + - or - + + = unknown\n\ndef abs_mul(a, b):\n    \"\"\"Abstract multiplication in sign domain\"\"\"\n    if \"0\" in (a, b):\n        return \"0\"\n    if a == b:\n        return \"+\"\n    if \"?\" in (a, b):\n        return \"?\"\n    return \"-\"\n\n# Test\nprint(abs_add(\"+\", \"+\"))  # +\nprint(abs_add(\"+\", \"-\"))  # ?\nprint(abs_mul(\"-\", \"-\"))  # +",
        "language": "python",
        "explanation": "Abstract interpretation analyzes programs using simplified abstract domains for sound approximation."
      },
      {
        "id": "cs303-final-q41",
        "type": "true_false",
        "prompt": "In call-by-value evaluation, arguments are always evaluated before being passed to functions.",
        "correctAnswer": true,
        "explanation": "Call-by-value evaluates arguments before the function call, unlike call-by-name which delays evaluation."
      },
      {
        "id": "cs303-final-q42",
        "type": "true_false",
        "prompt": "A Turing-complete language can solve any computational problem.",
        "correctAnswer": false,
        "explanation": "Turing-complete languages can compute what Turing machines can, but some problems (like halting) are undecidable."
      }
    ]
  }
]
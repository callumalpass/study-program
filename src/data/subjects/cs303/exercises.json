[
  {
    "id": "cs303-ex-1-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Pure Function Implementation",
    "difficulty": 1,
    "description": "Write a pure function that calculates the factorial of a number without side effects.",
    "starterCode": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of n using pure functional style.\n    The function should:\n    - Not modify any external state\n    - Return the same output for the same input\n    - Use recursion or reduce/fold pattern\n\n    Args:\n        n: A non-negative integer\n    Returns:\n        The factorial of n (n!)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of n using pure functional style.\n    \"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)",
    "testCases": [
      {
        "input": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "A pure function always returns the same output for the same input",
      "Use recursion: factorial(n) = n * factorial(n-1)",
      "Base case: factorial(0) = factorial(1) = 1"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Imperative to Functional Conversion",
    "difficulty": 1,
    "description": "Convert an imperative loop-based sum function to a functional style using reduce.",
    "starterCode": "from functools import reduce\n\n# Original imperative version (for reference):\n# def sum_squares_imperative(numbers):\n#     total = 0\n#     for n in numbers:\n#         total += n * n\n#     return total\n\ndef sum_squares(numbers):\n    \"\"\"\n    Calculate the sum of squares using functional programming.\n    Use map/reduce or list comprehension instead of explicit loops.\n\n    Args:\n        numbers: A list of integers\n    Returns:\n        The sum of squares of all numbers\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from functools import reduce\n\ndef sum_squares(numbers):\n    \"\"\"\n    Calculate the sum of squares using functional programming.\n    \"\"\"\n    return reduce(lambda acc, x: acc + x * x, numbers, 0)",
    "testCases": [
      {
        "input": "[]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[4, 5]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 1, 1, 1]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use reduce from functools to combine elements",
      "The lambda takes an accumulator and current element",
      "Start with initial value 0"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Higher-Order Function Implementation",
    "difficulty": 1,
    "description": "Implement a higher-order function that composes two functions together.",
    "starterCode": "def compose(f, g):\n    \"\"\"\n    Return a new function that applies g first, then f.\n    compose(f, g)(x) should equal f(g(x))\n\n    Args:\n        f: A function\n        g: A function\n    Returns:\n        A new function that is the composition of f and g\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def compose(f, g):\n    \"\"\"\n    Return a new function that applies g first, then f.\n    \"\"\"\n    return lambda x: f(g(x))",
    "testCases": [
      {
        "input": "compose(lambda x: x + 1, lambda x: x * 2)(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(str, abs)(-5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(lambda x: x ** 2, lambda x: x + 1)(2)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "A higher-order function returns a function",
      "The returned function should take an argument x",
      "Apply g(x) first, then f to the result"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Object-Oriented Counter",
    "difficulty": 1,
    "description": "Implement a Counter class demonstrating encapsulation with private state.",
    "starterCode": "class Counter:\n    \"\"\"\n    A counter class that encapsulates its state.\n    The internal count should not be directly accessible.\n    \"\"\"\n\n    def __init__(self, initial=0):\n        \"\"\"Initialize the counter with an optional starting value.\"\"\"\n        # Your implementation here\n        pass\n\n    def increment(self):\n        \"\"\"Increase the count by 1 and return new value.\"\"\"\n        pass\n\n    def decrement(self):\n        \"\"\"Decrease the count by 1 and return new value.\"\"\"\n        pass\n\n    def get_value(self):\n        \"\"\"Return the current count.\"\"\"\n        pass",
    "solution": "class Counter:\n    \"\"\"\n    A counter class that encapsulates its state.\n    \"\"\"\n\n    def __init__(self, initial=0):\n        self._count = initial\n\n    def increment(self):\n        self._count += 1\n        return self._count\n\n    def decrement(self):\n        self._count -= 1\n        return self._count\n\n    def get_value(self):\n        return self._count",
    "testCases": [
      {
        "input": "c = Counter(); c.increment(); c.get_value()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "c = Counter(10); c.decrement(); c.get_value()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "c = Counter(); [c.increment() for _ in range(5)]; c.get_value()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use underscore prefix for private attributes (_count)",
      "Each method should modify or return the internal state",
      "Encapsulation hides implementation details"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Polymorphism with Duck Typing",
    "difficulty": 3,
    "description": "Implement multiple classes that share a common interface through duck typing.",
    "starterCode": "class Rectangle:\n    \"\"\"A rectangle shape.\"\"\"\n    def __init__(self, width, height):\n        # Your implementation here\n        pass\n\n    def area(self):\n        \"\"\"Return the area of the rectangle.\"\"\"\n        pass\n\n    def perimeter(self):\n        \"\"\"Return the perimeter of the rectangle.\"\"\"\n        pass\n\nclass Circle:\n    \"\"\"A circle shape.\"\"\"\n    import math\n\n    def __init__(self, radius):\n        # Your implementation here\n        pass\n\n    def area(self):\n        \"\"\"Return the area of the circle.\"\"\"\n        pass\n\n    def perimeter(self):\n        \"\"\"Return the circumference of the circle.\"\"\"\n        pass\n\ndef total_area(shapes):\n    \"\"\"\n    Calculate total area of all shapes.\n    Uses duck typing - any object with an area() method works.\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import math\n\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi * self.radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self.radius\n\ndef total_area(shapes):\n    return sum(shape.area() for shape in shapes)",
    "testCases": [
      {
        "input": "Rectangle(3, 4).area()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(Circle(1).area(), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "total_area([Rectangle(2, 3), Rectangle(4, 5)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Duck typing: if it has area(), it can be used as a shape",
      "Circle area = π * r²",
      "Use sum() with a generator expression for total_area"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Inheritance Hierarchy",
    "difficulty": 3,
    "description": "Create a class hierarchy demonstrating inheritance and method overriding.",
    "starterCode": "class Animal:\n    \"\"\"Base class for all animals.\"\"\"\n\n    def __init__(self, name):\n        # Your implementation here\n        pass\n\n    def speak(self):\n        \"\"\"Return the sound the animal makes.\"\"\"\n        raise NotImplementedError(\"Subclass must implement\")\n\n    def describe(self):\n        \"\"\"Return a description including the animal's sound.\"\"\"\n        pass\n\nclass Dog(Animal):\n    \"\"\"A dog that barks.\"\"\"\n\n    def speak(self):\n        pass\n\nclass Cat(Animal):\n    \"\"\"A cat that meows.\"\"\"\n\n    def speak(self):\n        pass\n\nclass Cow(Animal):\n    \"\"\"A cow that moos.\"\"\"\n\n    def speak(self):\n        pass",
    "solution": "class Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        raise NotImplementedError(\"Subclass must implement\")\n\n    def describe(self):\n        return f\"{self.name} says {self.speak()}\"\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\nclass Cow(Animal):\n    def speak(self):\n        return \"Moo!\"",
    "testCases": [
      {
        "input": "Dog(\"Rex\").speak()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Cat(\"Whiskers\").describe()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Cow(\"Bessie\").speak()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store name in self.name in __init__",
      "Override speak() in each subclass",
      "describe() can call self.speak()"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Closure and State",
    "difficulty": 3,
    "description": "Implement a function that returns a closure maintaining internal state.",
    "starterCode": "def make_accumulator(initial=0):\n    \"\"\"\n    Return a function that accumulates values.\n    Each call adds to the running total.\n\n    Example:\n        acc = make_accumulator(10)\n        acc(5)  # returns 15\n        acc(3)  # returns 18\n\n    Args:\n        initial: Starting value for the accumulator\n    Returns:\n        A function that takes a value and returns the new total\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def make_accumulator(initial=0):\n    \"\"\"\n    Return a function that accumulates values.\n    \"\"\"\n    total = initial\n\n    def accumulate(value):\n        nonlocal total\n        total += value\n        return total\n\n    return accumulate",
    "testCases": [
      {
        "input": "acc = make_accumulator(); acc(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "acc = make_accumulator(10); acc(5); acc(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "acc = make_accumulator(); acc(1); acc(2); acc(3)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use nonlocal to modify the outer variable",
      "The inner function closes over the total variable",
      "Each call to the returned function updates and returns total"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Declarative List Processing",
    "difficulty": 3,
    "description": "Process a list of dictionaries using declarative style with filter, map, and sorted.",
    "starterCode": "def process_people(people):\n    \"\"\"\n    Process a list of people dictionaries.\n    1. Filter to only adults (age >= 18)\n    2. Extract just their names\n    3. Sort alphabetically\n    4. Return as a list\n\n    Args:\n        people: List of dicts with 'name' and 'age' keys\n    Returns:\n        Sorted list of adult names\n\n    Example:\n        people = [\n            {'name': 'Alice', 'age': 25},\n            {'name': 'Bob', 'age': 17},\n            {'name': 'Charlie', 'age': 30}\n        ]\n        # Returns ['Alice', 'Charlie']\n    \"\"\"\n    # Your implementation here (use filter, map, sorted)\n    pass",
    "solution": "def process_people(people):\n    \"\"\"\n    Process a list of people dictionaries.\n    \"\"\"\n    adults = filter(lambda p: p['age'] >= 18, people)\n    names = map(lambda p: p['name'], adults)\n    return sorted(names)",
    "testCases": [
      {
        "input": "process_people([{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 17}])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_people([{'name': 'Zoe', 'age': 20}, {'name': 'Amy', 'age': 22}])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_people([])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "filter(predicate, iterable) keeps elements where predicate is True",
      "map(function, iterable) transforms each element",
      "sorted() returns a new sorted list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Curried Function",
    "difficulty": 3,
    "description": "Implement a curried version of a multi-argument function.",
    "starterCode": "def curry_add():\n    \"\"\"\n    Return a curried addition function.\n    Instead of add(a, b, c), use curry_add()(a)(b)(c)\n\n    Example:\n        add_curried = curry_add()\n        add_curried(1)(2)(3)  # returns 6\n\n        add_five = curry_add()(5)\n        add_five(3)(2)  # returns 10\n\n    Returns:\n        A curried function that adds three numbers\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def curry_add():\n    \"\"\"\n    Return a curried addition function.\n    \"\"\"\n    def add_first(a):\n        def add_second(b):\n            def add_third(c):\n                return a + b + c\n            return add_third\n        return add_second\n    return add_first",
    "testCases": [
      {
        "input": "curry_add()(1)(2)(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "curry_add()(10)(20)(30)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "add_five = curry_add()(5); add_five(3)(2)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Currying transforms f(a,b,c) into f(a)(b)(c)",
      "Each call returns a function waiting for the next argument",
      "The innermost function computes the final result"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Strategy Pattern",
    "difficulty": 3,
    "description": "Implement the Strategy pattern using first-class functions.",
    "starterCode": "def process_data(data, strategy):\n    \"\"\"\n    Process data using the provided strategy function.\n\n    Args:\n        data: A list of numbers\n        strategy: A function that takes a list and returns a value\n    Returns:\n        Result of applying strategy to data\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef sum_strategy(data):\n    \"\"\"Strategy: return sum of data.\"\"\"\n    pass\n\ndef max_strategy(data):\n    \"\"\"Strategy: return maximum of data.\"\"\"\n    pass\n\ndef mean_strategy(data):\n    \"\"\"Strategy: return arithmetic mean of data.\"\"\"\n    pass",
    "solution": "def process_data(data, strategy):\n    \"\"\"\n    Process data using the provided strategy function.\n    \"\"\"\n    return strategy(data)\n\ndef sum_strategy(data):\n    return sum(data)\n\ndef max_strategy(data):\n    return max(data) if data else None\n\ndef mean_strategy(data):\n    return sum(data) / len(data) if data else 0",
    "testCases": [
      {
        "input": "process_data([1, 2, 3, 4, 5], sum_strategy)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_data([1, 5, 3, 9, 2], max_strategy)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_data([2, 4, 6, 8], mean_strategy)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functions are first-class citizens in Python",
      "Pass the strategy function as an argument",
      "Call the strategy with the data"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Immutable Data Transformation",
    "difficulty": 5,
    "description": "Implement functions that transform data structures immutably.",
    "starterCode": "def update_nested(data, path, value):\n    \"\"\"\n    Return a new dictionary with a nested value updated.\n    Does not modify the original dictionary.\n\n    Args:\n        data: A nested dictionary\n        path: List of keys to traverse\n        value: New value to set\n    Returns:\n        A new dictionary with the value updated\n\n    Example:\n        data = {'a': {'b': {'c': 1}}}\n        update_nested(data, ['a', 'b', 'c'], 2)\n        # Returns {'a': {'b': {'c': 2}}}\n        # Original data unchanged\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def update_nested(data, path, value):\n    \"\"\"\n    Return a new dictionary with a nested value updated.\n    \"\"\"\n    if not path:\n        return value\n\n    key = path[0]\n    rest = path[1:]\n\n    new_data = dict(data)\n    new_data[key] = update_nested(data.get(key, {}), rest, value)\n    return new_data",
    "testCases": [
      {
        "input": "update_nested({'a': 1}, ['a'], 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "update_nested({'a': {'b': 1}}, ['a', 'b'], 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "d = {'x': 1}; update_nested(d, ['x'], 2); d['x']",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Create copies at each level, do not modify in place",
      "Use recursion to handle nested structures",
      "dict(data) creates a shallow copy"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Abstract Base Class",
    "difficulty": 5,
    "description": "Create an abstract base class enforcing interface implementation.",
    "starterCode": "from abc import ABC, abstractmethod\n\nclass Serializable(ABC):\n    \"\"\"Abstract base class for serializable objects.\"\"\"\n\n    @abstractmethod\n    def to_json(self):\n        \"\"\"Convert object to JSON-compatible dict.\"\"\"\n        pass\n\n    @abstractmethod\n    def from_json(cls, data):\n        \"\"\"Create object from JSON-compatible dict.\"\"\"\n        pass\n\nclass Person(Serializable):\n    \"\"\"A person that can be serialized.\"\"\"\n\n    def __init__(self, name, age):\n        # Your implementation here\n        pass\n\n    def to_json(self):\n        # Your implementation here\n        pass\n\n    @classmethod\n    def from_json(cls, data):\n        # Your implementation here\n        pass",
    "solution": "from abc import ABC, abstractmethod\n\nclass Serializable(ABC):\n    @abstractmethod\n    def to_json(self):\n        pass\n\n    @classmethod\n    @abstractmethod\n    def from_json(cls, data):\n        pass\n\nclass Person(Serializable):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def to_json(self):\n        return {'name': self.name, 'age': self.age}\n\n    @classmethod\n    def from_json(cls, data):\n        return cls(data['name'], data['age'])",
    "testCases": [
      {
        "input": "Person('Alice', 30).to_json()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Person.from_json({'name': 'Bob', 'age': 25}).name",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "p = Person('Eve', 20); Person.from_json(p.to_json()).age",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use @abstractmethod decorator for abstract methods",
      "@classmethod receives the class as first argument",
      "from_json should return a new instance of the class"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Monad-like Pipeline",
    "difficulty": 5,
    "description": "Implement a Maybe-like container for safe chained operations.",
    "starterCode": "class Maybe:\n    \"\"\"\n    A container that handles None values gracefully.\n    Allows chaining operations without explicit None checks.\n    \"\"\"\n\n    def __init__(self, value):\n        # Your implementation here\n        pass\n\n    def map(self, func):\n        \"\"\"\n        Apply func to the value if it exists.\n        Return Maybe(None) if value is None.\n        \"\"\"\n        pass\n\n    def flat_map(self, func):\n        \"\"\"\n        Apply func (which returns a Maybe) and flatten.\n        \"\"\"\n        pass\n\n    def get_or_default(self, default):\n        \"\"\"Return value if it exists, otherwise default.\"\"\"\n        pass",
    "solution": "class Maybe:\n    def __init__(self, value):\n        self._value = value\n\n    def map(self, func):\n        if self._value is None:\n            return Maybe(None)\n        return Maybe(func(self._value))\n\n    def flat_map(self, func):\n        if self._value is None:\n            return Maybe(None)\n        return func(self._value)\n\n    def get_or_default(self, default):\n        return self._value if self._value is not None else default",
    "testCases": [
      {
        "input": "Maybe(5).map(lambda x: x * 2).get_or_default(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Maybe(None).map(lambda x: x * 2).get_or_default(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Maybe('hello').map(str.upper).get_or_default('')",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Check if value is None before applying operations",
      "map wraps result in a new Maybe",
      "flat_map expects func to return a Maybe"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Visitor Pattern",
    "difficulty": 5,
    "description": "Implement the Visitor pattern for processing heterogeneous data structures.",
    "starterCode": "class Expression:\n    \"\"\"Base class for expressions.\"\"\"\n    def accept(self, visitor):\n        raise NotImplementedError\n\nclass Number(Expression):\n    def __init__(self, value):\n        self.value = value\n\n    def accept(self, visitor):\n        # Your implementation here\n        pass\n\nclass BinaryOp(Expression):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\n    def accept(self, visitor):\n        # Your implementation here\n        pass\n\nclass EvalVisitor:\n    \"\"\"Visitor that evaluates expressions.\"\"\"\n\n    def visit_number(self, node):\n        pass\n\n    def visit_binary_op(self, node):\n        pass\n\nclass PrintVisitor:\n    \"\"\"Visitor that creates string representation.\"\"\"\n\n    def visit_number(self, node):\n        pass\n\n    def visit_binary_op(self, node):\n        pass",
    "solution": "class Expression:\n    def accept(self, visitor):\n        raise NotImplementedError\n\nclass Number(Expression):\n    def __init__(self, value):\n        self.value = value\n\n    def accept(self, visitor):\n        return visitor.visit_number(self)\n\nclass BinaryOp(Expression):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\n    def accept(self, visitor):\n        return visitor.visit_binary_op(self)\n\nclass EvalVisitor:\n    def visit_number(self, node):\n        return node.value\n\n    def visit_binary_op(self, node):\n        left = node.left.accept(self)\n        right = node.right.accept(self)\n        ops = {'+': lambda a, b: a + b, '-': lambda a, b: a - b,\n               '*': lambda a, b: a * b, '/': lambda a, b: a / b}\n        return ops[node.op](left, right)\n\nclass PrintVisitor:\n    def visit_number(self, node):\n        return str(node.value)\n\n    def visit_binary_op(self, node):\n        left = node.left.accept(self)\n        right = node.right.accept(self)\n        return f\"({left} {node.op} {right})\"",
    "testCases": [
      {
        "input": "Number(5).accept(EvalVisitor())",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "BinaryOp(Number(3), \"+\", Number(4)).accept(EvalVisitor())",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "BinaryOp(Number(2), \"*\", Number(3)).accept(PrintVisitor())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "accept() calls the appropriate visitor method",
      "Visitor methods process the node and return a result",
      "For BinaryOp, recursively visit children"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Lazy Evaluation",
    "difficulty": 5,
    "description": "Implement a lazy sequence that computes values on demand.",
    "starterCode": "class LazySequence:\n    \"\"\"\n    A lazy sequence that generates values on demand.\n    Values are computed only when accessed.\n    \"\"\"\n\n    def __init__(self, generator_func):\n        \"\"\"\n        Initialize with a generator function.\n        generator_func takes an index and returns the value at that index.\n        \"\"\"\n        # Your implementation here\n        pass\n\n    def __getitem__(self, index):\n        \"\"\"Get item at index, computing if necessary.\"\"\"\n        pass\n\n    def take(self, n):\n        \"\"\"Return first n elements as a list.\"\"\"\n        pass\n\n    def map(self, func):\n        \"\"\"Return a new lazy sequence with func applied.\"\"\"\n        pass\n\ndef naturals():\n    \"\"\"Return lazy sequence of natural numbers 0, 1, 2, ...\"\"\"\n    pass\n\ndef fibonacci():\n    \"\"\"Return lazy sequence of Fibonacci numbers.\"\"\"\n    pass",
    "solution": "class LazySequence:\n    def __init__(self, generator_func):\n        self._generator = generator_func\n        self._cache = {}\n\n    def __getitem__(self, index):\n        if index not in self._cache:\n            self._cache[index] = self._generator(index)\n        return self._cache[index]\n\n    def take(self, n):\n        return [self[i] for i in range(n)]\n\n    def map(self, func):\n        return LazySequence(lambda i: func(self[i]))\n\ndef naturals():\n    return LazySequence(lambda i: i)\n\ndef fibonacci():\n    def fib(n):\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n    return LazySequence(fib)",
    "testCases": [
      {
        "input": "naturals().take(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci().take(8)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "naturals().map(lambda x: x ** 2).take(4)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store generator function, compute values lazily",
      "Cache computed values to avoid recomputation",
      "map returns a new LazySequence with transformed generator"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Multi-Paradigm Calculator",
    "difficulty": 5,
    "description": "Build a calculator demonstrating multiple programming paradigms.",
    "starterCode": "# Functional approach: operations as functions\ndef make_calculator():\n    \"\"\"\n    Create a calculator using functional programming.\n    Returns a dict of operation functions.\n    \"\"\"\n    pass\n\n# OOP approach: calculator as object\nclass Calculator:\n    \"\"\"\n    Calculator using object-oriented programming.\n    Maintains history of operations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def calculate(self, a, op, b):\n        \"\"\"Perform operation and store in history.\"\"\"\n        pass\n\n    def get_history(self):\n        \"\"\"Return list of past calculations.\"\"\"\n        pass\n\n# Declarative approach: expression evaluation\ndef evaluate_expression(expr):\n    \"\"\"\n    Evaluate a simple arithmetic expression string.\n    Supports +, -, *, / with two operands.\n    Example: \"3 + 4\" -> 7\n    \"\"\"\n    pass",
    "solution": "# Functional approach\ndef make_calculator():\n    return {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: a / b if b != 0 else float('inf')\n    }\n\n# OOP approach\nclass Calculator:\n    def __init__(self):\n        self._history = []\n        self._ops = make_calculator()\n\n    def calculate(self, a, op, b):\n        result = self._ops[op](a, b)\n        self._history.append(f\"{a} {op} {b} = {result}\")\n        return result\n\n    def get_history(self):\n        return self._history.copy()\n\n# Declarative approach\ndef evaluate_expression(expr):\n    parts = expr.split()\n    a, op, b = float(parts[0]), parts[1], float(parts[2])\n    ops = make_calculator()\n    return ops[op](a, b)",
    "testCases": [
      {
        "input": "make_calculator()['+' ](3, 4)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "c = Calculator(); c.calculate(10, \"-\", 4)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_expression(\"6 * 7\")",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functional: store operations as lambda functions in a dict",
      "OOP: maintain history list, use operation dict internally",
      "Declarative: parse string and dispatch to appropriate operation"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Annotations",
    "difficulty": 1,
    "description": "Add type annotations to Python functions using the typing module.",
    "starterCode": "from typing import List, Optional, Dict, Tuple\n\ndef find_max(numbers):\n    \"\"\"Find the maximum value in a list.\"\"\"\n    if not numbers:\n        return None\n    return max(numbers)\n\ndef word_count(text):\n    \"\"\"Count occurrences of each word.\"\"\"\n    words = text.lower().split()\n    counts = {}\n    for word in words:\n        counts[word] = counts.get(word, 0) + 1\n    return counts\n\ndef parse_coordinate(s):\n    \"\"\"Parse 'x,y' string into coordinate tuple.\"\"\"\n    parts = s.split(',')\n    return (int(parts[0]), int(parts[1]))\n\n# TODO: Add type annotations to the functions above",
    "solution": "from typing import List, Optional, Dict, Tuple\n\ndef find_max(numbers: List[int]) -> Optional[int]:\n    \"\"\"Find the maximum value in a list.\"\"\"\n    if not numbers:\n        return None\n    return max(numbers)\n\ndef word_count(text: str) -> Dict[str, int]:\n    \"\"\"Count occurrences of each word.\"\"\"\n    words = text.lower().split()\n    counts: Dict[str, int] = {}\n    for word in words:\n        counts[word] = counts.get(word, 0) + 1\n    return counts\n\ndef parse_coordinate(s: str) -> Tuple[int, int]:\n    \"\"\"Parse 'x,y' string into coordinate tuple.\"\"\"\n    parts = s.split(',')\n    return (int(parts[0]), int(parts[1]))",
    "testCases": [
      {
        "input": "find_max([1, 5, 3])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "word_count('a b a')['a']",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "parse_coordinate('3,4')",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use List[T] for list types",
      "Use Optional[T] for values that might be None",
      "Use Dict[K, V] for dictionary types"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Generic Type Parameter",
    "difficulty": 1,
    "description": "Implement a generic container class using TypeVar.",
    "starterCode": "from typing import TypeVar, Generic, Optional\n\nT = TypeVar('T')\n\nclass Box(Generic[T]):\n    \"\"\"\n    A generic container that holds a single value.\n    Type parameter T specifies the type of the contained value.\n    \"\"\"\n\n    def __init__(self, value: T):\n        # Your implementation here\n        pass\n\n    def get(self) -> T:\n        \"\"\"Return the contained value.\"\"\"\n        pass\n\n    def map(self, func):\n        \"\"\"Apply func to the value and return a new Box.\"\"\"\n        pass",
    "solution": "from typing import TypeVar, Generic, Callable\n\nT = TypeVar('T')\nU = TypeVar('U')\n\nclass Box(Generic[T]):\n    def __init__(self, value: T):\n        self._value = value\n\n    def get(self) -> T:\n        return self._value\n\n    def map(self, func: Callable[[T], U]) -> 'Box[U]':\n        return Box(func(self._value))",
    "testCases": [
      {
        "input": "Box(42).get()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Box('hello').map(str.upper).get()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Box(3).map(lambda x: x * 2).get()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "TypeVar creates a type variable",
      "Generic[T] makes the class generic over T",
      "map should return a new Box with transformed value"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Union Types",
    "difficulty": 1,
    "description": "Use Union types to handle multiple possible input types.",
    "starterCode": "from typing import Union, List\n\ndef stringify(value: Union[int, float, str, List]) -> str:\n    \"\"\"\n    Convert various types to string representation.\n    - int/float: convert to string\n    - str: return as-is\n    - list: join elements with commas\n\n    Args:\n        value: An int, float, string, or list\n    Returns:\n        String representation\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import Union, List\n\ndef stringify(value: Union[int, float, str, List]) -> str:\n    if isinstance(value, (int, float)):\n        return str(value)\n    elif isinstance(value, str):\n        return value\n    elif isinstance(value, list):\n        return ', '.join(str(item) for item in value)\n    return str(value)",
    "testCases": [
      {
        "input": "stringify(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "stringify(3.14)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "stringify('hello')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "stringify([1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use isinstance() to check the actual type",
      "You can check multiple types with isinstance(x, (type1, type2))",
      "Union[A, B] means the type can be either A or B"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Protocol Types",
    "difficulty": 3,
    "description": "Define and use a Protocol for structural subtyping.",
    "starterCode": "from typing import Protocol, List\n\nclass Comparable(Protocol):\n    \"\"\"Protocol for objects that can be compared.\"\"\"\n\n    def __lt__(self, other) -> bool:\n        \"\"\"Return True if self < other.\"\"\"\n        ...\n\ndef find_minimum(items: List[Comparable]) -> Comparable:\n    \"\"\"\n    Find the minimum item in a list.\n    Works with any type that implements __lt__.\n\n    Args:\n        items: List of comparable items\n    Returns:\n        The minimum item\n    \"\"\"\n    # Your implementation here\n    pass\n\nclass Point:\n    \"\"\"A 2D point that can be compared by distance from origin.\"\"\"\n\n    def __init__(self, x: float, y: float):\n        # Your implementation here\n        pass\n\n    def __lt__(self, other: 'Point') -> bool:\n        # Compare by distance from origin\n        pass",
    "solution": "from typing import Protocol, List\nimport math\n\nclass Comparable(Protocol):\n    def __lt__(self, other) -> bool:\n        ...\n\ndef find_minimum(items: List[Comparable]) -> Comparable:\n    if not items:\n        raise ValueError(\"Cannot find minimum of empty list\")\n    result = items[0]\n    for item in items[1:]:\n        if item < result:\n            result = item\n    return result\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, other: 'Point') -> bool:\n        self_dist = math.sqrt(self.x**2 + self.y**2)\n        other_dist = math.sqrt(other.x**2 + other.y**2)\n        return self_dist < other_dist",
    "testCases": [
      {
        "input": "find_minimum([3, 1, 4, 1, 5])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "find_minimum(['c', 'a', 'b'])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "p = find_minimum([Point(3,4), Point(1,0), Point(2,2)]); (p.x, p.y)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Protocol defines a structural interface",
      "Any class with __lt__ satisfies Comparable",
      "Point distance from origin = sqrt(x² + y²)"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Guards",
    "difficulty": 3,
    "description": "Implement type narrowing with TypeGuard.",
    "starterCode": "from typing import TypeGuard, Union, List, Dict\n\ndef is_string_list(value: List[Union[str, int]]) -> TypeGuard[List[str]]:\n    \"\"\"\n    Check if all elements in the list are strings.\n    This is a type guard that narrows the type.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef is_valid_person(data: Dict) -> TypeGuard[Dict[str, Union[str, int]]]:\n    \"\"\"\n    Check if dict has 'name' (str) and 'age' (int) keys.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef process_items(items: List[Union[str, int]]) -> str:\n    \"\"\"\n    Process items: if all strings, join them; otherwise sum numbers.\n    \"\"\"\n    # Your implementation using is_string_list\n    pass",
    "solution": "from typing import TypeGuard, Union, List, Dict\n\ndef is_string_list(value: List[Union[str, int]]) -> TypeGuard[List[str]]:\n    return all(isinstance(item, str) for item in value)\n\ndef is_valid_person(data: Dict) -> TypeGuard[Dict[str, Union[str, int]]]:\n    return (\n        'name' in data and isinstance(data['name'], str) and\n        'age' in data and isinstance(data['age'], int)\n    )\n\ndef process_items(items: List[Union[str, int]]) -> str:\n    if is_string_list(items):\n        return ' '.join(items)  # Type narrowed to List[str]\n    else:\n        return str(sum(x for x in items if isinstance(x, int)))",
    "testCases": [
      {
        "input": "is_string_list(['a', 'b', 'c'])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "is_string_list(['a', 1, 'b'])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_items(['hello', 'world'])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_items([1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "TypeGuard[T] narrows the type to T when True",
      "Use all() to check all elements",
      "After a successful guard, the type checker knows the narrowed type"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Covariance and Contravariance",
    "difficulty": 3,
    "description": "Understand variance with generic types.",
    "starterCode": "from typing import TypeVar, Generic, Callable, List\n\n# Covariant type variable (for \"producers\")\nT_co = TypeVar('T_co', covariant=True)\n\n# Contravariant type variable (for \"consumers\")\nT_contra = TypeVar('T_contra', contravariant=True)\n\nclass Reader(Generic[T_co]):\n    \"\"\"\n    A covariant reader - produces values of type T.\n    If Cat is subtype of Animal, Reader[Cat] is subtype of Reader[Animal].\n    \"\"\"\n\n    def __init__(self, value: T_co):\n        self._value = value\n\n    def read(self) -> T_co:\n        pass\n\nclass Writer(Generic[T_contra]):\n    \"\"\"\n    A contravariant writer - consumes values of type T.\n    If Cat is subtype of Animal, Writer[Animal] is subtype of Writer[Cat].\n    \"\"\"\n\n    def __init__(self, handler: Callable[[T_contra], None]):\n        self._handler = handler\n\n    def write(self, value: T_contra) -> None:\n        pass",
    "solution": "from typing import TypeVar, Generic, Callable\n\nT_co = TypeVar('T_co', covariant=True)\nT_contra = TypeVar('T_contra', contravariant=True)\n\nclass Reader(Generic[T_co]):\n    def __init__(self, value: T_co):\n        self._value = value\n\n    def read(self) -> T_co:\n        return self._value\n\nclass Writer(Generic[T_contra]):\n    def __init__(self, handler: Callable[[T_contra], None]):\n        self._handler = handler\n\n    def write(self, value: T_contra) -> None:\n        self._handler(value)",
    "testCases": [
      {
        "input": "Reader('hello').read()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Reader(42).read()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "output = []; Writer(output.append).write(5); output",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Covariant: output positions (return types)",
      "Contravariant: input positions (parameter types)",
      "Reader produces values, Writer consumes them"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "TypedDict",
    "difficulty": 3,
    "description": "Use TypedDict for structured dictionaries with specific keys.",
    "starterCode": "from typing import TypedDict, List, Optional\n\nclass Address(TypedDict):\n    \"\"\"A typed dictionary for addresses.\"\"\"\n    street: str\n    city: str\n    zip_code: str\n\nclass Person(TypedDict, total=False):\n    \"\"\"\n    A typed dictionary for person data.\n    total=False means fields are optional.\n    \"\"\"\n    name: str\n    age: int\n    address: Address\n\ndef format_address(addr: Address) -> str:\n    \"\"\"Format an address as a single string.\"\"\"\n    # Your implementation here\n    pass\n\ndef get_person_summary(person: Person) -> str:\n    \"\"\"\n    Get a summary string for a person.\n    Handle optional fields gracefully.\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import TypedDict\n\nclass Address(TypedDict):\n    street: str\n    city: str\n    zip_code: str\n\nclass Person(TypedDict, total=False):\n    name: str\n    age: int\n    address: Address\n\ndef format_address(addr: Address) -> str:\n    return f\"{addr['street']}, {addr['city']} {addr['zip_code']}\"\n\ndef get_person_summary(person: Person) -> str:\n    name = person.get('name', 'Unknown')\n    age = person.get('age')\n    age_str = f\", {age} years old\" if age is not None else \"\"\n    addr = person.get('address')\n    addr_str = f\" - {format_address(addr)}\" if addr else \"\"\n    return f\"{name}{age_str}{addr_str}\"",
    "testCases": [
      {
        "input": "format_address({'street': '123 Main', 'city': 'NYC', 'zip_code': '10001'})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "get_person_summary({'name': 'Alice'})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "get_person_summary({'name': 'Bob', 'age': 30})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "TypedDict creates a dict with specific key types",
      "total=False makes all fields optional",
      "Use .get() with defaults for optional fields"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Literal Types",
    "difficulty": 3,
    "description": "Use Literal types for precise string and int literals.",
    "starterCode": "from typing import Literal, Union\n\nDirection = Literal['north', 'south', 'east', 'west']\nPriority = Literal[1, 2, 3]\n\ndef move(direction: Direction, steps: int = 1) -> tuple:\n    \"\"\"\n    Calculate new position after moving.\n    Starting from (0, 0), return new (x, y) position.\n\n    north: y increases\n    south: y decreases\n    east: x increases\n    west: x decreases\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef get_priority_label(priority: Priority) -> str:\n    \"\"\"\n    Convert numeric priority to label.\n    1 -> 'high', 2 -> 'medium', 3 -> 'low'\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import Literal\n\nDirection = Literal['north', 'south', 'east', 'west']\nPriority = Literal[1, 2, 3]\n\ndef move(direction: Direction, steps: int = 1) -> tuple:\n    moves = {\n        'north': (0, steps),\n        'south': (0, -steps),\n        'east': (steps, 0),\n        'west': (-steps, 0)\n    }\n    return moves[direction]\n\ndef get_priority_label(priority: Priority) -> str:\n    labels = {1: 'high', 2: 'medium', 3: 'low'}\n    return labels[priority]",
    "testCases": [
      {
        "input": "move('north', 3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "move('east', 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "get_priority_label(1)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "get_priority_label(3)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Literal restricts to specific values",
      "Type checkers will flag invalid literals",
      "Use dict mapping for clean dispatch"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Recursive Types",
    "difficulty": 5,
    "description": "Define recursive type aliases for tree structures.",
    "starterCode": "from typing import Union, List, Dict, Any\n\n# JSON can be: null, bool, int, float, str, list of JSON, or dict of JSON\nJSON = Union[None, bool, int, float, str, List['JSON'], Dict[str, 'JSON']]\n\ndef flatten_json(data: JSON, prefix: str = '') -> Dict[str, Any]:\n    \"\"\"\n    Flatten nested JSON to a single-level dict with dot-notation keys.\n\n    Example:\n        {'a': {'b': 1, 'c': 2}} -> {'a.b': 1, 'a.c': 2}\n        [1, 2, 3] -> {'0': 1, '1': 2, '2': 3}\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef json_depth(data: JSON) -> int:\n    \"\"\"\n    Calculate the maximum nesting depth of JSON data.\n    Primitive values have depth 1.\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import Union, List, Dict, Any\n\nJSON = Union[None, bool, int, float, str, List['JSON'], Dict[str, 'JSON']]\n\ndef flatten_json(data: JSON, prefix: str = '') -> Dict[str, Any]:\n    result: Dict[str, Any] = {}\n\n    if isinstance(data, dict):\n        for key, value in data.items():\n            new_key = f\"{prefix}.{key}\" if prefix else key\n            result.update(flatten_json(value, new_key))\n    elif isinstance(data, list):\n        for i, value in enumerate(data):\n            new_key = f\"{prefix}.{i}\" if prefix else str(i)\n            result.update(flatten_json(value, new_key))\n    else:\n        if prefix:\n            result[prefix] = data\n        else:\n            result[''] = data\n\n    return result\n\ndef json_depth(data: JSON) -> int:\n    if isinstance(data, dict):\n        if not data:\n            return 1\n        return 1 + max(json_depth(v) for v in data.values())\n    elif isinstance(data, list):\n        if not data:\n            return 1\n        return 1 + max(json_depth(v) for v in data)\n    else:\n        return 1",
    "testCases": [
      {
        "input": "flatten_json({'a': 1, 'b': 2})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "flatten_json({'a': {'b': 1}})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "json_depth({'a': {'b': {'c': 1}}})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "json_depth([1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use forward reference string for recursive types",
      "Handle dict, list, and primitive cases separately",
      "Recursively process nested structures"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Dependent Types Simulation",
    "difficulty": 5,
    "description": "Simulate dependent types using overloading.",
    "starterCode": "from typing import overload, Literal, Tuple\n\n@overload\ndef create_array(size: Literal[1]) -> Tuple[int]: ...\n\n@overload\ndef create_array(size: Literal[2]) -> Tuple[int, int]: ...\n\n@overload\ndef create_array(size: Literal[3]) -> Tuple[int, int, int]: ...\n\ndef create_array(size: int) -> tuple:\n    \"\"\"\n    Create a tuple of zeros with the given size.\n    The return type depends on the input value.\n    \"\"\"\n    # Your implementation here\n    pass\n\n@overload\ndef safe_divide(a: int, b: Literal[0]) -> None: ...\n\n@overload\ndef safe_divide(a: int, b: int) -> float: ...\n\ndef safe_divide(a: int, b: int):\n    \"\"\"\n    Divide a by b safely.\n    Returns None if b is 0, otherwise returns the result.\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import overload, Literal, Tuple, Union\n\n@overload\ndef create_array(size: Literal[1]) -> Tuple[int]: ...\n\n@overload\ndef create_array(size: Literal[2]) -> Tuple[int, int]: ...\n\n@overload\ndef create_array(size: Literal[3]) -> Tuple[int, int, int]: ...\n\n@overload\ndef create_array(size: int) -> tuple: ...\n\ndef create_array(size: int) -> tuple:\n    return tuple(0 for _ in range(size))\n\n@overload\ndef safe_divide(a: int, b: Literal[0]) -> None: ...\n\n@overload\ndef safe_divide(a: int, b: int) -> float: ...\n\ndef safe_divide(a: int, b: int) -> Union[float, None]:\n    if b == 0:\n        return None\n    return a / b",
    "testCases": [
      {
        "input": "create_array(1)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "create_array(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "safe_divide(10, 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "safe_divide(10, 0)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "@overload lets you specify different return types",
      "The actual implementation handles all cases",
      "Type checkers use overloads for type inference"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Erasure Implementation",
    "difficulty": 5,
    "description": "Understand type erasure by implementing runtime type checking.",
    "starterCode": "from typing import TypeVar, Generic, Type, get_type_hints\nimport inspect\n\nT = TypeVar('T')\n\nclass TypedList(Generic[T]):\n    \"\"\"\n    A list that enforces type checking at runtime.\n    Demonstrates that Python generics are erased at runtime.\n    \"\"\"\n\n    def __init__(self, item_type: Type[T]):\n        # Store the type for runtime checking\n        pass\n\n    def append(self, item: T) -> None:\n        \"\"\"Add item, raising TypeError if wrong type.\"\"\"\n        pass\n\n    def extend(self, items) -> None:\n        \"\"\"Add multiple items with type checking.\"\"\"\n        pass\n\n    def __getitem__(self, index: int) -> T:\n        pass\n\n    def __len__(self) -> int:\n        pass",
    "solution": "from typing import TypeVar, Generic, Type\n\nT = TypeVar('T')\n\nclass TypedList(Generic[T]):\n    def __init__(self, item_type: Type[T]):\n        self._item_type = item_type\n        self._items: list = []\n\n    def append(self, item: T) -> None:\n        if not isinstance(item, self._item_type):\n            raise TypeError(\n                f\"Expected {self._item_type.__name__}, got {type(item).__name__}\"\n            )\n        self._items.append(item)\n\n    def extend(self, items) -> None:\n        for item in items:\n            self.append(item)\n\n    def __getitem__(self, index: int) -> T:\n        return self._items[index]\n\n    def __len__(self) -> int:\n        return len(self._items)",
    "testCases": [
      {
        "input": "lst = TypedList(int); lst.append(1); lst[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "lst = TypedList(str); lst.extend([\"a\", \"b\"]); len(lst)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "lst = TypedList(int); lst.append(\"x\")",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store the type as an instance variable",
      "Use isinstance() for runtime type checking",
      "Generic[T] provides static typing, but T is erased at runtime"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Phantom Types",
    "difficulty": 5,
    "description": "Implement phantom types for compile-time safety without runtime overhead.",
    "starterCode": "from typing import TypeVar, Generic, NewType\n\n# Phantom type markers (never instantiated)\nclass Meters: pass\nclass Feet: pass\n\nUnit = TypeVar('Unit')\n\nclass Distance(Generic[Unit]):\n    \"\"\"\n    A distance value with unit tracking at type level.\n    The Unit parameter is phantom - it doesn't exist at runtime.\n    \"\"\"\n\n    def __init__(self, value: float):\n        # Your implementation here\n        pass\n\n    def get_value(self) -> float:\n        pass\n\n    def __add__(self, other: 'Distance[Unit]') -> 'Distance[Unit]':\n        # Can only add distances with same unit\n        pass\n\ndef meters(value: float) -> Distance[Meters]:\n    \"\"\"Create a distance in meters.\"\"\"\n    pass\n\ndef feet(value: float) -> Distance[Feet]:\n    \"\"\"Create a distance in feet.\"\"\"\n    pass\n\ndef to_meters(d: Distance[Feet]) -> Distance[Meters]:\n    \"\"\"Convert feet to meters.\"\"\"\n    pass",
    "solution": "from typing import TypeVar, Generic\n\nclass Meters: pass\nclass Feet: pass\n\nUnit = TypeVar('Unit')\n\nclass Distance(Generic[Unit]):\n    def __init__(self, value: float):\n        self._value = value\n\n    def get_value(self) -> float:\n        return self._value\n\n    def __add__(self, other: 'Distance[Unit]') -> 'Distance[Unit]':\n        return Distance(self._value + other._value)\n\ndef meters(value: float) -> Distance[Meters]:\n    return Distance(value)\n\ndef feet(value: float) -> Distance[Feet]:\n    return Distance(value)\n\ndef to_meters(d: Distance[Feet]) -> Distance[Meters]:\n    return meters(d.get_value() * 0.3048)",
    "testCases": [
      {
        "input": "meters(100).get_value()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "(meters(10) + meters(20)).get_value()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(to_meters(feet(10)).get_value(), 4)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Phantom types exist only at compile time",
      "The Unit parameter is never used at runtime",
      "Type checker prevents adding meters to feet"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Nominal vs Structural Typing",
    "difficulty": 5,
    "description": "Compare nominal and structural typing approaches.",
    "starterCode": "from typing import Protocol, NewType, runtime_checkable\n\n# Nominal typing with NewType\nUserId = NewType('UserId', int)\nProductId = NewType('ProductId', int)\n\ndef get_user(user_id: UserId) -> str:\n    \"\"\"Get user by nominal UserId type.\"\"\"\n    # Your implementation - return f\"User {user_id}\"\n    pass\n\n# Structural typing with Protocol\n@runtime_checkable\nclass Printable(Protocol):\n    def to_string(self) -> str:\n        ...\n\nclass User:\n    def __init__(self, name: str):\n        self.name = name\n\n    def to_string(self) -> str:\n        pass\n\nclass Product:\n    def __init__(self, title: str):\n        self.title = title\n\n    def to_string(self) -> str:\n        pass\n\ndef print_item(item: Printable) -> str:\n    \"\"\"Print any Printable item structurally.\"\"\"\n    pass",
    "solution": "from typing import Protocol, NewType, runtime_checkable\n\nUserId = NewType('UserId', int)\nProductId = NewType('ProductId', int)\n\ndef get_user(user_id: UserId) -> str:\n    return f\"User {user_id}\"\n\n@runtime_checkable\nclass Printable(Protocol):\n    def to_string(self) -> str:\n        ...\n\nclass User:\n    def __init__(self, name: str):\n        self.name = name\n\n    def to_string(self) -> str:\n        return f\"User: {self.name}\"\n\nclass Product:\n    def __init__(self, title: str):\n        self.title = title\n\n    def to_string(self) -> str:\n        return f\"Product: {self.title}\"\n\ndef print_item(item: Printable) -> str:\n    return item.to_string()",
    "testCases": [
      {
        "input": "get_user(UserId(42))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "print_item(User('Alice'))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "print_item(Product('Widget'))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "isinstance(User('Test'), Printable)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "NewType creates a distinct type for type checking",
      "Protocol enables duck typing with type safety",
      "@runtime_checkable allows isinstance() checks"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Inference",
    "difficulty": 5,
    "description": "Implement a simple type inference engine.",
    "starterCode": "from typing import Dict, Optional, Union\n\n# Simple type representation\nType = Union[str, tuple]  # 'int', 'bool', ('func', arg_type, ret_type)\n\ndef infer_literal(value) -> Type:\n    \"\"\"Infer type of a literal value.\"\"\"\n    # Your implementation here\n    pass\n\ndef infer_binary_op(op: str, left_type: Type, right_type: Type) -> Optional[Type]:\n    \"\"\"\n    Infer result type of binary operation.\n    Supports: +, -, *, / for int; and, or for bool; == for any\n    Returns None if types are incompatible.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef infer_expression(expr, env: Dict[str, Type] = None) -> Optional[Type]:\n    \"\"\"\n    Infer type of an expression.\n    expr can be:\n    - literal: 42, True, etc.\n    - variable: ('var', 'x')\n    - binary: ('binop', op, left, right)\n    - if-then-else: ('if', cond, then_expr, else_expr)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import Dict, Optional, Union\n\nType = Union[str, tuple]\n\ndef infer_literal(value) -> Type:\n    if isinstance(value, bool):\n        return 'bool'\n    elif isinstance(value, int):\n        return 'int'\n    elif isinstance(value, float):\n        return 'float'\n    elif isinstance(value, str):\n        return 'str'\n    return 'unknown'\n\ndef infer_binary_op(op: str, left_type: Type, right_type: Type) -> Optional[Type]:\n    if op in ['+', '-', '*']:\n        if left_type == 'int' and right_type == 'int':\n            return 'int'\n    if op == '/':\n        if left_type == 'int' and right_type == 'int':\n            return 'float'\n    if op in ['and', 'or']:\n        if left_type == 'bool' and right_type == 'bool':\n            return 'bool'\n    if op == '==':\n        if left_type == right_type:\n            return 'bool'\n    return None\n\ndef infer_expression(expr, env: Dict[str, Type] = None) -> Optional[Type]:\n    if env is None:\n        env = {}\n\n    if isinstance(expr, (int, bool, float, str)) and not isinstance(expr, tuple):\n        return infer_literal(expr)\n\n    if not isinstance(expr, tuple):\n        return None\n\n    tag = expr[0]\n\n    if tag == 'var':\n        return env.get(expr[1])\n\n    if tag == 'binop':\n        _, op, left, right = expr\n        left_type = infer_expression(left, env)\n        right_type = infer_expression(right, env)\n        if left_type and right_type:\n            return infer_binary_op(op, left_type, right_type)\n\n    if tag == 'if':\n        _, cond, then_expr, else_expr = expr\n        cond_type = infer_expression(cond, env)\n        if cond_type != 'bool':\n            return None\n        then_type = infer_expression(then_expr, env)\n        else_type = infer_expression(else_expr, env)\n        if then_type == else_type:\n            return then_type\n\n    return None",
    "testCases": [
      {
        "input": "infer_literal(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "infer_binary_op('+', 'int', 'int')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "infer_expression(('binop', '+', 1, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "infer_expression(('if', True, 1, 2))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Pattern match on expression structure",
      "Propagate types through subexpressions",
      "Return None for type errors"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Gradual Typing",
    "difficulty": 5,
    "description": "Implement consistent-with relation for gradual typing.",
    "starterCode": "from typing import Any, Union, Optional\n\n# Type representation\n# 'Any' = dynamic type\n# 'int', 'str', 'bool' = base types\n# ('list', T) = list of T\n# ('func', [arg_types], ret_type) = function type\n\ndef consistent(t1, t2) -> bool:\n    \"\"\"\n    Check if two types are consistent (gradual typing).\n    Any is consistent with everything.\n    Two non-Any types are consistent if they're equal\n    or their structure matches with consistent components.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef join_types(t1, t2):\n    \"\"\"\n    Find the join (least upper bound) of two types.\n    Returns Any if types are inconsistent.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef check_assignment(declared_type, value_type) -> bool:\n    \"\"\"\n    Check if a value of value_type can be assigned to declared_type.\n    Uses consistency checking.\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import Any, Union, Optional\n\ndef consistent(t1, t2) -> bool:\n    # Any is consistent with everything\n    if t1 == 'Any' or t2 == 'Any':\n        return True\n\n    # Same types are consistent\n    if t1 == t2:\n        return True\n\n    # Check structural types\n    if isinstance(t1, tuple) and isinstance(t2, tuple):\n        if t1[0] != t2[0]:\n            return False\n\n        if t1[0] == 'list':\n            return consistent(t1[1], t2[1])\n\n        if t1[0] == 'func':\n            _, args1, ret1 = t1\n            _, args2, ret2 = t2\n            if len(args1) != len(args2):\n                return False\n            return (all(consistent(a1, a2) for a1, a2 in zip(args1, args2))\n                    and consistent(ret1, ret2))\n\n    return False\n\ndef join_types(t1, t2):\n    if t1 == t2:\n        return t1\n    if t1 == 'Any' or t2 == 'Any':\n        return 'Any'\n    if consistent(t1, t2):\n        # For consistent non-equal types, return Any\n        return 'Any'\n    return 'Any'\n\ndef check_assignment(declared_type, value_type) -> bool:\n    return consistent(declared_type, value_type)",
    "testCases": [
      {
        "input": "consistent('int', 'int')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "consistent('Any', 'str')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "consistent('int', 'str')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "consistent(('list', 'int'), ('list', 'Any'))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Any is consistent with all types",
      "Structural types require recursive consistency check",
      "Join returns most general type covering both inputs"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-2-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-2",
    "title": "Type Class Simulation",
    "difficulty": 5,
    "description": "Simulate Haskell-style type classes in Python.",
    "starterCode": "from typing import TypeVar, Generic, Dict, Type, Callable\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Eq(ABC, Generic[T]):\n    \"\"\"Type class for equality comparison.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def eq(a: T, b: T) -> bool:\n        pass\n\nclass Ord(Eq[T], Generic[T]):\n    \"\"\"Type class for ordering (extends Eq).\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def lt(a: T, b: T) -> bool:\n        pass\n\n    @staticmethod\n    def lte(a: T, b: T) -> bool:\n        \"\"\"Less than or equal - default implementation.\"\"\"\n        pass\n\n# Type class instances registry\n_instances: Dict[tuple, type] = {}\n\ndef register_instance(typeclass: type, for_type: type, instance: type):\n    \"\"\"Register a type class instance.\"\"\"\n    pass\n\ndef get_instance(typeclass: type, for_type: type):\n    \"\"\"Get type class instance for a type.\"\"\"\n    pass\n\n# Implement instances for int\nclass IntEq(Eq[int]):\n    @staticmethod\n    def eq(a: int, b: int) -> bool:\n        pass\n\nclass IntOrd(Ord[int]):\n    @staticmethod\n    def eq(a: int, b: int) -> bool:\n        pass\n\n    @staticmethod\n    def lt(a: int, b: int) -> bool:\n        pass",
    "solution": "from typing import TypeVar, Generic, Dict, Type\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Eq(ABC, Generic[T]):\n    @staticmethod\n    @abstractmethod\n    def eq(a: T, b: T) -> bool:\n        pass\n\nclass Ord(Eq[T], Generic[T]):\n    @staticmethod\n    @abstractmethod\n    def lt(a: T, b: T) -> bool:\n        pass\n\n    @classmethod\n    def lte(cls, a: T, b: T) -> bool:\n        return cls.lt(a, b) or cls.eq(a, b)\n\n_instances: Dict[tuple, type] = {}\n\ndef register_instance(typeclass: type, for_type: type, instance: type):\n    _instances[(typeclass, for_type)] = instance\n\ndef get_instance(typeclass: type, for_type: type):\n    return _instances.get((typeclass, for_type))\n\nclass IntEq(Eq[int]):\n    @staticmethod\n    def eq(a: int, b: int) -> bool:\n        return a == b\n\nclass IntOrd(Ord[int]):\n    @staticmethod\n    def eq(a: int, b: int) -> bool:\n        return a == b\n\n    @staticmethod\n    def lt(a: int, b: int) -> bool:\n        return a < b\n\nregister_instance(Eq, int, IntEq)\nregister_instance(Ord, int, IntOrd)",
    "testCases": [
      {
        "input": "IntEq.eq(1, 1)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "IntOrd.lt(1, 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "IntOrd.lte(2, 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "get_instance(Eq, int).__name__",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Type classes define interfaces with default implementations",
      "Instances implement type classes for specific types",
      "Registry maps (typeclass, type) pairs to instances"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Map Implementation",
    "difficulty": 1,
    "description": "Implement the map higher-order function from scratch.",
    "starterCode": "def my_map(func, iterable):\n    \"\"\"\n    Apply func to each element of iterable.\n    Return a list of results.\n\n    Args:\n        func: A function to apply\n        iterable: An iterable of elements\n    Returns:\n        List of transformed elements\n    \"\"\"\n    # Your implementation here (no using built-in map)\n    pass",
    "solution": "def my_map(func, iterable):\n    result = []\n    for item in iterable:\n        result.append(func(item))\n    return result",
    "testCases": [
      {
        "input": "my_map(lambda x: x * 2, [1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_map(str.upper, [\"a\", \"b\"])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_map(lambda x: x, [])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Iterate through each element",
      "Apply the function to each element",
      "Collect results in a list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Filter Implementation",
    "difficulty": 1,
    "description": "Implement the filter higher-order function from scratch.",
    "starterCode": "def my_filter(predicate, iterable):\n    \"\"\"\n    Keep only elements where predicate returns True.\n\n    Args:\n        predicate: A function returning bool\n        iterable: An iterable of elements\n    Returns:\n        List of elements satisfying predicate\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def my_filter(predicate, iterable):\n    result = []\n    for item in iterable:\n        if predicate(item):\n            result.append(item)\n    return result",
    "testCases": [
      {
        "input": "my_filter(lambda x: x > 0, [-1, 0, 1, 2])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_filter(lambda x: x % 2 == 0, [1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_filter(lambda x: True, [])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Test each element with the predicate",
      "Only include elements where predicate returns True",
      "Handle empty iterables"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Reduce Implementation",
    "difficulty": 1,
    "description": "Implement the reduce (fold) higher-order function.",
    "starterCode": "def my_reduce(func, iterable, initial=None):\n    \"\"\"\n    Reduce iterable to single value by applying func cumulatively.\n\n    Args:\n        func: Function taking (accumulator, element) -> new_accumulator\n        iterable: An iterable of elements\n        initial: Optional initial value\n    Returns:\n        Final accumulated value\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def my_reduce(func, iterable, initial=None):\n    it = iter(iterable)\n    if initial is None:\n        try:\n            accumulator = next(it)\n        except StopIteration:\n            raise TypeError(\"reduce of empty sequence with no initial value\")\n    else:\n        accumulator = initial\n\n    for item in it:\n        accumulator = func(accumulator, item)\n    return accumulator",
    "testCases": [
      {
        "input": "my_reduce(lambda a, b: a + b, [1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_reduce(lambda a, b: a * b, [1, 2, 3, 4], 1)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_reduce(lambda a, b: a + b, [], 0)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Start with initial value (or first element if not provided)",
      "Apply func to accumulator and each element",
      "Handle empty sequences"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Function Composition",
    "difficulty": 1,
    "description": "Compose multiple functions into a single function.",
    "starterCode": "def compose(*funcs):\n    \"\"\"\n    Compose multiple functions right-to-left.\n    compose(f, g, h)(x) = f(g(h(x)))\n\n    Args:\n        *funcs: Variable number of functions\n    Returns:\n        A single composed function\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def compose(*funcs):\n    def composed(x):\n        result = x\n        for func in reversed(funcs):\n            result = func(result)\n        return result\n    return composed",
    "testCases": [
      {
        "input": "compose(lambda x: x + 1, lambda x: x * 2)(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(str, abs, int)(\"-5\")",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose()(5)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Apply functions from right to left",
      "Use reversed() to iterate in correct order",
      "Handle empty function list (identity)"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Partial Application",
    "difficulty": 3,
    "description": "Implement partial function application.",
    "starterCode": "def partial(func, *args, **kwargs):\n    \"\"\"\n    Return a new function with some arguments pre-filled.\n\n    Args:\n        func: The function to partially apply\n        *args: Positional arguments to pre-fill\n        **kwargs: Keyword arguments to pre-fill\n    Returns:\n        A new function with fewer required arguments\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def partial(func, *args, **kwargs):\n    def wrapper(*more_args, **more_kwargs):\n        all_kwargs = {**kwargs, **more_kwargs}\n        return func(*args, *more_args, **all_kwargs)\n    return wrapper",
    "testCases": [
      {
        "input": "partial(pow, 2)(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "partial('{} {}'.format, 'Hello')('World')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "partial(lambda x, y, z: x + y + z, 1, 2)(3)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store the pre-filled arguments",
      "Return a function that accepts remaining arguments",
      "Combine pre-filled and new arguments"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Memoization Decorator",
    "difficulty": 3,
    "description": "Implement a memoization decorator for caching function results.",
    "starterCode": "def memoize(func):\n    \"\"\"\n    Cache function results based on arguments.\n    Return cached result for repeated calls with same arguments.\n\n    Args:\n        func: The function to memoize\n    Returns:\n        A memoized version of the function\n    \"\"\"\n    # Your implementation here\n    pass\n\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)",
    "solution": "def memoize(func):\n    cache = {}\n\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)",
    "testCases": [
      {
        "input": "fibonacci(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci(20)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci(0)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use a dictionary to store cached results",
      "Use arguments as cache keys",
      "Check cache before calling function"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Recursive List Operations",
    "difficulty": 3,
    "description": "Implement list operations using recursion only.",
    "starterCode": "def length(lst):\n    \"\"\"Return length of list using recursion.\"\"\"\n    # Your implementation here\n    pass\n\ndef reverse(lst):\n    \"\"\"Return reversed list using recursion.\"\"\"\n    # Your implementation here\n    pass\n\ndef flatten(lst):\n    \"\"\"Flatten nested lists using recursion.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "def length(lst):\n    if not lst:\n        return 0\n    return 1 + length(lst[1:])\n\ndef reverse(lst):\n    if not lst:\n        return []\n    return reverse(lst[1:]) + [lst[0]]\n\ndef flatten(lst):\n    if not lst:\n        return []\n    first, rest = lst[0], lst[1:]\n    if isinstance(first, list):\n        return flatten(first) + flatten(rest)\n    return [first] + flatten(rest)",
    "testCases": [
      {
        "input": "length([1, 2, 3, 4, 5])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "reverse([1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "flatten([1, [2, [3, 4]], 5])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Base case: empty list",
      "Recursive case: process first element, recurse on rest",
      "For flatten, check if element is a list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Lazy Evaluation with Generators",
    "difficulty": 3,
    "description": "Implement lazy operations using Python generators.",
    "starterCode": "def lazy_map(func, iterable):\n    \"\"\"Lazy version of map using a generator.\"\"\"\n    # Your implementation here\n    pass\n\ndef lazy_filter(predicate, iterable):\n    \"\"\"Lazy version of filter using a generator.\"\"\"\n    # Your implementation here\n    pass\n\ndef take(n, iterable):\n    \"\"\"Take first n elements from an iterable.\"\"\"\n    # Your implementation here\n    pass\n\ndef infinite_counter(start=0):\n    \"\"\"Generate infinite sequence of integers.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "def lazy_map(func, iterable):\n    for item in iterable:\n        yield func(item)\n\ndef lazy_filter(predicate, iterable):\n    for item in iterable:\n        if predicate(item):\n            yield item\n\ndef take(n, iterable):\n    for i, item in enumerate(iterable):\n        if i >= n:\n            break\n        yield item\n\ndef infinite_counter(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1",
    "testCases": [
      {
        "input": "list(lazy_map(lambda x: x*2, [1,2,3]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list(lazy_filter(lambda x: x>0, [-1,0,1,2]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list(take(5, infinite_counter()))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use yield to create generators",
      "Generators evaluate lazily on demand",
      "Take should work with infinite sequences"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Fold-Based Implementations",
    "difficulty": 3,
    "description": "Implement common operations using fold/reduce.",
    "starterCode": "from functools import reduce\n\ndef sum_fold(numbers):\n    \"\"\"Implement sum using reduce.\"\"\"\n    pass\n\ndef product_fold(numbers):\n    \"\"\"Implement product using reduce.\"\"\"\n    pass\n\ndef max_fold(numbers):\n    \"\"\"Implement max using reduce.\"\"\"\n    pass\n\ndef map_fold(func, lst):\n    \"\"\"Implement map using reduce.\"\"\"\n    pass\n\ndef filter_fold(predicate, lst):\n    \"\"\"Implement filter using reduce.\"\"\"\n    pass",
    "solution": "from functools import reduce\n\ndef sum_fold(numbers):\n    return reduce(lambda acc, x: acc + x, numbers, 0)\n\ndef product_fold(numbers):\n    return reduce(lambda acc, x: acc * x, numbers, 1)\n\ndef max_fold(numbers):\n    if not numbers:\n        raise ValueError(\"max of empty sequence\")\n    return reduce(lambda acc, x: x if x > acc else acc, numbers)\n\ndef map_fold(func, lst):\n    return reduce(lambda acc, x: acc + [func(x)], lst, [])\n\ndef filter_fold(predicate, lst):\n    return reduce(lambda acc, x: acc + [x] if predicate(x) else acc, lst, [])",
    "testCases": [
      {
        "input": "sum_fold([1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "product_fold([1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "max_fold([3, 1, 4, 1, 5])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "map_fold(lambda x: x*2, [1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "reduce combines elements with an accumulator",
      "Choose appropriate initial values",
      "Build lists by appending to accumulator"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Immutable Data Updates",
    "difficulty": 3,
    "description": "Work with immutable data structures functionally.",
    "starterCode": "from typing import NamedTuple, List\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n\ndef update_age(person: Person, new_age: int) -> Person:\n    \"\"\"Return new Person with updated age.\"\"\"\n    pass\n\ndef add_year_to_all(people: List[Person]) -> List[Person]:\n    \"\"\"Return new list with everyone aged by 1 year.\"\"\"\n    pass\n\ndef get_adults(people: List[Person]) -> List[Person]:\n    \"\"\"Return new list containing only adults (age >= 18).\"\"\"\n    pass\n\ndef average_age(people: List[Person]) -> float:\n    \"\"\"Calculate average age without mutation.\"\"\"\n    pass",
    "solution": "from typing import NamedTuple, List\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n\ndef update_age(person: Person, new_age: int) -> Person:\n    return Person(person.name, new_age)\n\ndef add_year_to_all(people: List[Person]) -> List[Person]:\n    return [Person(p.name, p.age + 1) for p in people]\n\ndef get_adults(people: List[Person]) -> List[Person]:\n    return [p for p in people if p.age >= 18]\n\ndef average_age(people: List[Person]) -> float:\n    if not people:\n        return 0.0\n    return sum(p.age for p in people) / len(people)",
    "testCases": [
      {
        "input": "update_age(Person('Alice', 30), 31).age",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "add_year_to_all([Person('A', 10), Person('B', 20)])[0].age",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "len(get_adults([Person('A', 17), Person('B', 18)]))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "NamedTuple is immutable by default",
      "Create new instances instead of modifying",
      "Use list comprehensions for transformations"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Functor Pattern",
    "difficulty": 5,
    "description": "Implement the Functor pattern (mappable containers).",
    "starterCode": "from abc import ABC, abstractmethod\nfrom typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Functor(ABC, Generic[A]):\n    \"\"\"Abstract base class for functors.\"\"\"\n\n    @abstractmethod\n    def map(self, func: Callable[[A], B]) -> 'Functor[B]':\n        \"\"\"Apply function inside the context.\"\"\"\n        pass\n\nclass Maybe(Functor[A]):\n    \"\"\"Maybe functor for optional values.\"\"\"\n\n    def __init__(self, value: A = None, is_nothing: bool = False):\n        pass\n\n    def map(self, func: Callable[[A], B]) -> 'Maybe[B]':\n        pass\n\n    def get_or_else(self, default: A) -> A:\n        pass\n\nclass List(Functor[A]):\n    \"\"\"List as a functor.\"\"\"\n\n    def __init__(self, values: list):\n        pass\n\n    def map(self, func: Callable[[A], B]) -> 'List[B]':\n        pass\n\ndef Just(value: A) -> Maybe[A]:\n    pass\n\ndef Nothing() -> Maybe:\n    pass",
    "solution": "from abc import ABC, abstractmethod\nfrom typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Functor(ABC, Generic[A]):\n    @abstractmethod\n    def map(self, func: Callable[[A], B]) -> 'Functor[B]':\n        pass\n\nclass Maybe(Functor[A]):\n    def __init__(self, value: A = None, is_nothing: bool = False):\n        self._value = value\n        self._is_nothing = is_nothing or (value is None and not is_nothing)\n\n    def map(self, func: Callable[[A], B]) -> 'Maybe[B]':\n        if self._is_nothing:\n            return Maybe(None, is_nothing=True)\n        return Maybe(func(self._value))\n\n    def get_or_else(self, default: A) -> A:\n        return default if self._is_nothing else self._value\n\nclass List(Functor[A]):\n    def __init__(self, values: list):\n        self._values = values\n\n    def map(self, func: Callable[[A], B]) -> 'List[B]':\n        return List([func(x) for x in self._values])\n\ndef Just(value: A) -> Maybe[A]:\n    return Maybe(value, is_nothing=False)\n\ndef Nothing() -> Maybe:\n    return Maybe(None, is_nothing=True)",
    "testCases": [
      {
        "input": "Just(5).map(lambda x: x * 2).get_or_else(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Nothing().map(lambda x: x * 2).get_or_else(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "List([1,2,3]).map(lambda x: x*2)._values",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functor provides map to transform contained values",
      "Maybe handles the case of missing values",
      "Map should preserve the container structure"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Monad Pattern",
    "difficulty": 5,
    "description": "Implement the Monad pattern (flatMappable containers).",
    "starterCode": "from typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Monad(Generic[A]):\n    \"\"\"Abstract monad with unit and flatMap.\"\"\"\n\n    @staticmethod\n    def unit(value: A) -> 'Monad[A]':\n        \"\"\"Wrap value in monad context.\"\"\"\n        raise NotImplementedError\n\n    def flat_map(self, func: Callable[[A], 'Monad[B]']) -> 'Monad[B]':\n        \"\"\"Apply function and flatten result.\"\"\"\n        raise NotImplementedError\n\nclass Result(Monad[A]):\n    \"\"\"Result monad for error handling.\"\"\"\n\n    def __init__(self, value: A = None, error: str = None):\n        pass\n\n    @staticmethod\n    def success(value: A) -> 'Result[A]':\n        pass\n\n    @staticmethod\n    def failure(error: str) -> 'Result':\n        pass\n\n    def flat_map(self, func: Callable[[A], 'Result[B]']) -> 'Result[B]':\n        pass\n\n    def map(self, func: Callable[[A], B]) -> 'Result[B]':\n        \"\"\"Map for convenience.\"\"\"\n        pass\n\n    def get_or_raise(self) -> A:\n        pass",
    "solution": "from typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Monad(Generic[A]):\n    @staticmethod\n    def unit(value: A) -> 'Monad[A]':\n        raise NotImplementedError\n\n    def flat_map(self, func: Callable[[A], 'Monad[B]']) -> 'Monad[B]':\n        raise NotImplementedError\n\nclass Result(Monad[A]):\n    def __init__(self, value: A = None, error: str = None):\n        self._value = value\n        self._error = error\n\n    @staticmethod\n    def success(value: A) -> 'Result[A]':\n        return Result(value=value)\n\n    @staticmethod\n    def failure(error: str) -> 'Result':\n        return Result(error=error)\n\n    def flat_map(self, func: Callable[[A], 'Result[B]']) -> 'Result[B]':\n        if self._error:\n            return Result.failure(self._error)\n        return func(self._value)\n\n    def map(self, func: Callable[[A], B]) -> 'Result[B]':\n        return self.flat_map(lambda x: Result.success(func(x)))\n\n    def get_or_raise(self) -> A:\n        if self._error:\n            raise Exception(self._error)\n        return self._value",
    "testCases": [
      {
        "input": "Result.success(5).map(lambda x: x*2).get_or_raise()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Result.failure('error').map(lambda x: x*2)._error",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Result.success(5).flat_map(lambda x: Result.success(x+1)).get_or_raise()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Monad adds flatMap to Functor",
      "flatMap chains operations that return monads",
      "Errors should propagate through the chain"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Continuation Passing Style",
    "difficulty": 5,
    "description": "Convert functions to continuation passing style (CPS).",
    "starterCode": "def factorial_cps(n, continuation):\n    \"\"\"\n    Factorial in continuation passing style.\n    Instead of returning, pass result to continuation.\n\n    Args:\n        n: Number to compute factorial of\n        continuation: Function to call with result\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef fibonacci_cps(n, continuation):\n    \"\"\"Fibonacci in CPS.\"\"\"\n    # Your implementation here\n    pass\n\ndef map_cps(func, lst, continuation):\n    \"\"\"Map in CPS.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "def factorial_cps(n, continuation):\n    if n <= 1:\n        return continuation(1)\n    return factorial_cps(n - 1, lambda result: continuation(n * result))\n\ndef fibonacci_cps(n, continuation):\n    if n <= 1:\n        return continuation(n)\n    return fibonacci_cps(n - 1, lambda a:\n        fibonacci_cps(n - 2, lambda b:\n            continuation(a + b)))\n\ndef map_cps(func, lst, continuation):\n    if not lst:\n        return continuation([])\n    return map_cps(func, lst[1:], lambda rest:\n        continuation([func(lst[0])] + rest))",
    "testCases": [
      {
        "input": "factorial_cps(5, lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci_cps(10, lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "map_cps(lambda x: x*2, [1,2,3], lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "CPS passes computation forward via continuations",
      "Base case calls continuation with result",
      "Recursive case wraps continuation with more computation"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Trampolined Recursion",
    "difficulty": 5,
    "description": "Implement trampolining for stack-safe recursion.",
    "starterCode": "class Thunk:\n    \"\"\"Delayed computation for trampolining.\"\"\"\n\n    def __init__(self, func, *args):\n        pass\n\n    def evaluate(self):\n        \"\"\"Execute the delayed computation.\"\"\"\n        pass\n\ndef trampoline(thunk_or_value):\n    \"\"\"\n    Execute thunks until we get a final value.\n    Enables stack-safe recursion.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef factorial_trampolined(n, acc=1):\n    \"\"\"Stack-safe factorial using trampolining.\"\"\"\n    # Your implementation here\n    pass\n\ndef sum_list_trampolined(lst, acc=0):\n    \"\"\"Stack-safe list sum using trampolining.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "class Thunk:\n    def __init__(self, func, *args):\n        self.func = func\n        self.args = args\n\n    def evaluate(self):\n        return self.func(*self.args)\n\ndef trampoline(thunk_or_value):\n    while isinstance(thunk_or_value, Thunk):\n        thunk_or_value = thunk_or_value.evaluate()\n    return thunk_or_value\n\ndef factorial_trampolined(n, acc=1):\n    if n <= 1:\n        return acc\n    return Thunk(factorial_trampolined, n - 1, acc * n)\n\ndef sum_list_trampolined(lst, acc=0):\n    if not lst:\n        return acc\n    return Thunk(sum_list_trampolined, lst[1:], acc + lst[0])",
    "testCases": [
      {
        "input": "trampoline(factorial_trampolined(10))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "trampoline(sum_list_trampolined([1,2,3,4,5]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "trampoline(factorial_trampolined(100)) > 0",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Thunk wraps a delayed function call",
      "Trampoline loops until non-Thunk value",
      "Return Thunk instead of recursive call"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Algebraic Data Types",
    "difficulty": 5,
    "description": "Implement algebraic data types and pattern matching.",
    "starterCode": "from typing import TypeVar, Generic, Callable, Union\n\nA = TypeVar('A')\n\nclass List:\n    \"\"\"Algebraic list: either Nil or Cons(head, tail).\"\"\"\n    pass\n\nclass Nil(List):\n    \"\"\"Empty list constructor.\"\"\"\n    pass\n\nclass Cons(List):\n    \"\"\"Non-empty list: head element and tail list.\"\"\"\n\n    def __init__(self, head, tail: List):\n        pass\n\ndef match_list(lst: List, nil_case: Callable, cons_case: Callable):\n    \"\"\"Pattern match on list structure.\"\"\"\n    # Your implementation here\n    pass\n\ndef list_length(lst: List) -> int:\n    \"\"\"Calculate length using pattern matching.\"\"\"\n    # Your implementation here\n    pass\n\ndef list_map(func: Callable, lst: List) -> List:\n    \"\"\"Map function over list using pattern matching.\"\"\"\n    # Your implementation here\n    pass\n\ndef to_python_list(lst: List) -> list:\n    \"\"\"Convert algebraic list to Python list.\"\"\"\n    # Your implementation here\n    pass\n\ndef from_python_list(py_list: list) -> List:\n    \"\"\"Convert Python list to algebraic list.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import TypeVar, Callable\n\nclass List:\n    pass\n\nclass Nil(List):\n    pass\n\nclass Cons(List):\n    def __init__(self, head, tail: List):\n        self.head = head\n        self.tail = tail\n\ndef match_list(lst: List, nil_case: Callable, cons_case: Callable):\n    if isinstance(lst, Nil):\n        return nil_case()\n    elif isinstance(lst, Cons):\n        return cons_case(lst.head, lst.tail)\n    raise TypeError(\"Expected List type\")\n\ndef list_length(lst: List) -> int:\n    return match_list(lst,\n        lambda: 0,\n        lambda h, t: 1 + list_length(t))\n\ndef list_map(func: Callable, lst: List) -> List:\n    return match_list(lst,\n        lambda: Nil(),\n        lambda h, t: Cons(func(h), list_map(func, t)))\n\ndef to_python_list(lst: List) -> list:\n    return match_list(lst,\n        lambda: [],\n        lambda h, t: [h] + to_python_list(t))\n\ndef from_python_list(py_list: list) -> List:\n    if not py_list:\n        return Nil()\n    return Cons(py_list[0], from_python_list(py_list[1:]))",
    "testCases": [
      {
        "input": "list_length(from_python_list([1,2,3]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "to_python_list(list_map(lambda x: x*2, from_python_list([1,2,3])))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list_length(Nil())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "ADTs have multiple constructors (Nil, Cons)",
      "Pattern matching dispatches based on constructor",
      "Use isinstance to determine which case"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Free Monad",
    "difficulty": 5,
    "description": "Implement a simple Free Monad for DSL interpretation.",
    "starterCode": "from typing import TypeVar, Generic, Callable, List as PyList\nfrom abc import ABC, abstractmethod\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Free(ABC, Generic[A]):\n    \"\"\"Free monad for building DSLs.\"\"\"\n\n    @abstractmethod\n    def flat_map(self, func: Callable[[A], 'Free[B]']) -> 'Free[B]':\n        pass\n\nclass Pure(Free[A]):\n    \"\"\"Pure value in the free monad.\"\"\"\n\n    def __init__(self, value: A):\n        pass\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        pass\n\nclass Suspend(Free[A]):\n    \"\"\"Suspended computation.\"\"\"\n\n    def __init__(self, instruction, next_func: Callable):\n        pass\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        pass\n\n# Console DSL instructions\nclass Print:\n    def __init__(self, message: str):\n        self.message = message\n\nclass Read:\n    pass\n\ndef print_line(message: str) -> Free[None]:\n    \"\"\"DSL instruction to print.\"\"\"\n    pass\n\ndef read_line() -> Free[str]:\n    \"\"\"DSL instruction to read.\"\"\"\n    pass\n\ndef interpret_console(program: Free, inputs: PyList[str]) -> tuple:\n    \"\"\"\n    Interpret console DSL, returning (outputs, final_value).\n    \"\"\"\n    pass",
    "solution": "from typing import TypeVar, Generic, Callable, List as PyList\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Free(Generic[A]):\n    def flat_map(self, func: Callable[[A], 'Free[B]']) -> 'Free[B]':\n        raise NotImplementedError\n\nclass Pure(Free[A]):\n    def __init__(self, value: A):\n        self.value = value\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        return func(self.value)\n\nclass Suspend(Free[A]):\n    def __init__(self, instruction, next_func: Callable):\n        self.instruction = instruction\n        self.next_func = next_func\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        return Suspend(self.instruction,\n            lambda x: self.next_func(x).flat_map(func))\n\nclass Print:\n    def __init__(self, message: str):\n        self.message = message\n\nclass Read:\n    pass\n\ndef print_line(message: str) -> Free[None]:\n    return Suspend(Print(message), lambda _: Pure(None))\n\ndef read_line() -> Free[str]:\n    return Suspend(Read(), lambda x: Pure(x))\n\ndef interpret_console(program: Free, inputs: PyList[str]) -> tuple:\n    outputs = []\n    input_idx = 0\n\n    while isinstance(program, Suspend):\n        inst = program.instruction\n        if isinstance(inst, Print):\n            outputs.append(inst.message)\n            program = program.next_func(None)\n        elif isinstance(inst, Read):\n            if input_idx < len(inputs):\n                value = inputs[input_idx]\n                input_idx += 1\n            else:\n                value = \"\"\n            program = program.next_func(value)\n\n    return (outputs, program.value if isinstance(program, Pure) else None)",
    "testCases": [
      {
        "input": "interpret_console(print_line(\"Hi\"), [])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "interpret_console(read_line(), [\"test\"])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "interpret_console(print_line(\"A\").flat_map(lambda _: print_line(\"B\")), [])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Free monad separates program structure from interpretation",
      "Pure wraps final values",
      "Suspend captures instructions with continuations"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Big-Step Evaluator",
    "difficulty": 1,
    "description": "Implement a big-step evaluator for arithmetic expressions.",
    "starterCode": "def evaluate(expr, env=None):\n    \"\"\"\n    Big-step evaluation of arithmetic expressions.\n\n    expr can be:\n    - int: numeric literal\n    - ('var', name): variable reference\n    - ('add', e1, e2): addition\n    - ('mul', e1, e2): multiplication\n    - ('let', name, e1, e2): let binding\n\n    env: dict mapping variable names to values\n    \"\"\"\n    if env is None:\n        env = {}\n    # Your implementation here\n    pass",
    "solution": "def evaluate(expr, env=None):\n    if env is None:\n        env = {}\n\n    if isinstance(expr, int):\n        return expr\n\n    tag = expr[0]\n\n    if tag == 'var':\n        return env[expr[1]]\n\n    if tag == 'add':\n        return evaluate(expr[1], env) + evaluate(expr[2], env)\n\n    if tag == 'mul':\n        return evaluate(expr[1], env) * evaluate(expr[2], env)\n\n    if tag == 'let':\n        _, name, e1, e2 = expr\n        val = evaluate(e1, env)\n        new_env = {**env, name: val}\n        return evaluate(e2, new_env)\n\n    raise ValueError(f\"Unknown expression: {expr}\")",
    "testCases": [
      {
        "input": "evaluate(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate(('add', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate(('let', 'x', 5, ('mul', ('var', 'x'), 2)))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Pattern match on expression type",
      "Recursively evaluate subexpressions",
      "Let binding extends the environment"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Small-Step Reducer",
    "difficulty": 1,
    "description": "Implement small-step reduction for expressions.",
    "starterCode": "def is_value(expr):\n    \"\"\"Check if expression is a value (fully reduced).\"\"\"\n    pass\n\ndef step(expr, env=None):\n    \"\"\"\n    Take one small step of evaluation.\n    Returns (new_expr, new_env) or None if stuck.\n    \"\"\"\n    if env is None:\n        env = {}\n    # Your implementation here\n    pass\n\ndef evaluate_small_step(expr, env=None):\n    \"\"\"Repeatedly step until we get a value.\"\"\"\n    if env is None:\n        env = {}\n    # Your implementation here\n    pass",
    "solution": "def is_value(expr):\n    return isinstance(expr, int)\n\ndef step(expr, env=None):\n    if env is None:\n        env = {}\n\n    if is_value(expr):\n        return None  # Already a value\n\n    tag = expr[0]\n\n    if tag == 'var':\n        name = expr[1]\n        if name in env:\n            return (env[name], env)\n        return None\n\n    if tag == 'add':\n        _, e1, e2 = expr\n        if not is_value(e1):\n            result = step(e1, env)\n            if result:\n                return (('add', result[0], e2), result[1])\n        elif not is_value(e2):\n            result = step(e2, env)\n            if result:\n                return (('add', e1, result[0]), result[1])\n        else:\n            return (e1 + e2, env)\n\n    if tag == 'mul':\n        _, e1, e2 = expr\n        if not is_value(e1):\n            result = step(e1, env)\n            if result:\n                return (('mul', result[0], e2), result[1])\n        elif not is_value(e2):\n            result = step(e2, env)\n            if result:\n                return (('mul', e1, result[0]), result[1])\n        else:\n            return (e1 * e2, env)\n\n    return None\n\ndef evaluate_small_step(expr, env=None):\n    if env is None:\n        env = {}\n    while not is_value(expr):\n        result = step(expr, env)\n        if result is None:\n            break\n        expr, env = result\n    return expr",
    "testCases": [
      {
        "input": "is_value(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "step(('add', 3, 4))[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_small_step(('add', ('mul', 2, 3), 4))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Values cannot step further",
      "Reduce leftmost non-value first",
      "Return new expression and environment"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Denotational Semantics",
    "difficulty": 3,
    "description": "Implement denotational semantics for a simple language.",
    "starterCode": "def denote(expr):\n    \"\"\"\n    Return the denotation of an expression.\n    The denotation is a function from environment to value.\n\n    expr can be:\n    - int: constant function\n    - ('var', name): lookup in environment\n    - ('add', e1, e2): compose denotations\n    - ('lam', param, body): function denotation\n    - ('app', e1, e2): function application\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef run(expr, env=None):\n    \"\"\"Evaluate by computing denotation and applying to env.\"\"\"\n    if env is None:\n        env = {}\n    return denote(expr)(env)",
    "solution": "def denote(expr):\n    if isinstance(expr, int):\n        return lambda env: expr\n\n    tag = expr[0]\n\n    if tag == 'var':\n        name = expr[1]\n        return lambda env: env[name]\n\n    if tag == 'add':\n        _, e1, e2 = expr\n        d1, d2 = denote(e1), denote(e2)\n        return lambda env: d1(env) + d2(env)\n\n    if tag == 'mul':\n        _, e1, e2 = expr\n        d1, d2 = denote(e1), denote(e2)\n        return lambda env: d1(env) * d2(env)\n\n    if tag == 'lam':\n        _, param, body = expr\n        dbody = denote(body)\n        return lambda env: lambda arg: dbody({**env, param: arg})\n\n    if tag == 'app':\n        _, e1, e2 = expr\n        d1, d2 = denote(e1), denote(e2)\n        return lambda env: d1(env)(d2(env))\n\n    raise ValueError(f\"Unknown: {expr}\")\n\ndef run(expr, env=None):\n    if env is None:\n        env = {}\n    return denote(expr)(env)",
    "testCases": [
      {
        "input": "run(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "run(('add', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "run(('app', ('lam', 'x', ('mul', ('var', 'x'), 2)), 5))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Denotation returns a function from env to value",
      "Compose denotations for compound expressions",
      "Lambda denotation returns a function"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Hoare Triple Verification",
    "difficulty": 3,
    "description": "Verify simple Hoare triples for assignments.",
    "starterCode": "def substitute(assertion, var, expr):\n    \"\"\"\n    Substitute expr for var in assertion.\n    assertion is a lambda taking a state dict.\n    Returns new assertion with substitution.\n    \"\"\"\n    pass\n\ndef verify_assignment(precond, var, expr, postcond, test_states):\n    \"\"\"\n    Verify {precond} var := expr {postcond}\n    Using Hoare's assignment rule: {Q[e/x]} x := e {Q}\n\n    Returns True if triple is valid for all test states.\n    \"\"\"\n    pass",
    "solution": "def substitute(assertion, var, expr):\n    def substituted(state):\n        # Evaluate expr in current state\n        if callable(expr):\n            val = expr(state)\n        else:\n            val = expr\n        # Create modified state for assertion\n        new_state = {**state, var: val}\n        return assertion(new_state)\n    return substituted\n\ndef verify_assignment(precond, var, expr, postcond, test_states):\n    # For {P} x := e {Q} to be valid:\n    # P must imply Q[e/x]\n\n    # Get weakest precondition: Q[e/x]\n    wp = substitute(postcond, var, expr)\n\n    for state in test_states:\n        if precond(state):  # If precondition holds\n            if not wp(state):  # WP must also hold\n                return False\n    return True",
    "testCases": [
      {
        "input": "verify_assignment(lambda s: s['x'] > 0, 'y', lambda s: s['x'], lambda s: s['y'] > 0, [{'x': 5}, {'x': -1}])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "verify_assignment(lambda s: True, 'x', 5, lambda s: s['x'] == 5, [{}])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Assignment rule: {Q[e/x]} x := e {Q}",
      "Substitute expression for variable in postcondition",
      "Verify for all test states where precondition holds"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Weakest Precondition",
    "difficulty": 3,
    "description": "Calculate weakest preconditions for simple statements.",
    "starterCode": "def wp_assign(var, expr, postcond):\n    \"\"\"\n    Weakest precondition for assignment.\n    wp(x := e, Q) = Q[e/x]\n    \"\"\"\n    pass\n\ndef wp_sequence(s1_wp, s2_wp, postcond):\n    \"\"\"\n    Weakest precondition for sequence.\n    wp(s1; s2, Q) = wp(s1, wp(s2, Q))\n    \"\"\"\n    pass\n\ndef wp_if(cond, then_wp, else_wp, postcond):\n    \"\"\"\n    Weakest precondition for if-then-else.\n    wp(if b then s1 else s2, Q) = (b => wp(s1, Q)) && (!b => wp(s2, Q))\n    \"\"\"\n    pass",
    "solution": "def wp_assign(var, expr, postcond):\n    def wp(state):\n        if callable(expr):\n            val = expr(state)\n        else:\n            val = expr\n        new_state = {**state, var: val}\n        return postcond(new_state)\n    return wp\n\ndef wp_sequence(s1_wp, s2_wp, postcond):\n    # wp(s1; s2, Q) = wp(s1, wp(s2, Q))\n    intermediate = s2_wp(postcond)\n    return s1_wp(intermediate)\n\ndef wp_if(cond, then_wp, else_wp, postcond):\n    then_precond = then_wp(postcond)\n    else_precond = else_wp(postcond)\n    def wp(state):\n        if cond(state):\n            return then_precond(state)\n        else:\n            return else_precond(state)\n    return wp",
    "testCases": [
      {
        "input": "wp_assign('x', 5, lambda s: s['x'] > 0)({})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "wp_assign('x', lambda s: s['y'], lambda s: s['x'] == 10)({'y': 10})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "wp(x := e, Q) substitutes e for x in Q",
      "Sequence computes wp of inner statement first",
      "If splits based on condition"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Loop Invariant Checker",
    "difficulty": 3,
    "description": "Verify loop invariants for while loops.",
    "starterCode": "def check_loop_invariant(init_state, condition, body_transform, invariant, max_iters=100):\n    \"\"\"\n    Check that invariant holds for a while loop.\n\n    Args:\n        init_state: Initial state dict\n        condition: Function state -> bool (loop condition)\n        body_transform: Function state -> state (loop body effect)\n        invariant: Function state -> bool (loop invariant)\n        max_iters: Maximum iterations to check\n\n    Returns:\n        (is_valid, counter_example_or_none)\n    \"\"\"\n    pass",
    "solution": "def check_loop_invariant(init_state, condition, body_transform, invariant, max_iters=100):\n    state = init_state.copy()\n\n    # Check invariant holds initially\n    if not invariant(state):\n        return (False, (\"initial\", state))\n\n    iterations = 0\n    while condition(state) and iterations < max_iters:\n        # Apply loop body\n        state = body_transform(state)\n\n        # Check invariant is preserved\n        if not invariant(state):\n            return (False, (\"after_iteration\", iterations + 1, state))\n\n        iterations += 1\n\n    if iterations >= max_iters:\n        return (True, \"max_iterations_reached\")\n\n    # Loop terminated, invariant still holds\n    return (True, None)",
    "testCases": [
      {
        "input": "check_loop_invariant({'x': 0}, lambda s: s['x'] < 5, lambda s: {'x': s['x']+1}, lambda s: s['x'] >= 0)[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "check_loop_invariant({'x': 0}, lambda s: s['x'] < 5, lambda s: {'x': s['x']+1}, lambda s: s['x'] < 3)[0]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Check invariant holds initially",
      "After each iteration, verify invariant still holds",
      "Return counterexample if invariant breaks"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Abstract Interpretation - Signs",
    "difficulty": 5,
    "description": "Implement sign analysis using abstract interpretation.",
    "starterCode": "# Abstract domain for signs\nBOTTOM = 'bottom'  # No possible values\nNEG = 'neg'        # Negative\nZERO = 'zero'      # Zero\nPOS = 'pos'        # Positive\nTOP = 'top'        # Unknown\n\ndef sign_of(n):\n    \"\"\"Get abstract sign of concrete number.\"\"\"\n    pass\n\ndef abstract_add(s1, s2):\n    \"\"\"Abstract addition of signs.\"\"\"\n    pass\n\ndef abstract_mul(s1, s2):\n    \"\"\"Abstract multiplication of signs.\"\"\"\n    pass\n\ndef analyze_expression(expr, abstract_env):\n    \"\"\"\n    Analyze expression in abstract environment.\n    Returns abstract sign of result.\n    \"\"\"\n    pass",
    "solution": "BOTTOM = 'bottom'\nNEG = 'neg'\nZERO = 'zero'\nPOS = 'pos'\nTOP = 'top'\n\ndef sign_of(n):\n    if n < 0:\n        return NEG\n    elif n == 0:\n        return ZERO\n    else:\n        return POS\n\ndef abstract_add(s1, s2):\n    if s1 == BOTTOM or s2 == BOTTOM:\n        return BOTTOM\n    if s1 == TOP or s2 == TOP:\n        return TOP\n    if s1 == ZERO:\n        return s2\n    if s2 == ZERO:\n        return s1\n    if s1 == s2:\n        return s1  # neg+neg=neg, pos+pos=pos\n    return TOP  # neg+pos or pos+neg = unknown\n\ndef abstract_mul(s1, s2):\n    if s1 == BOTTOM or s2 == BOTTOM:\n        return BOTTOM\n    if s1 == ZERO or s2 == ZERO:\n        return ZERO\n    if s1 == TOP or s2 == TOP:\n        return TOP\n    if s1 == s2:\n        return POS  # neg*neg=pos, pos*pos=pos\n    return NEG  # neg*pos or pos*neg = neg\n\ndef analyze_expression(expr, abstract_env):\n    if isinstance(expr, int):\n        return sign_of(expr)\n\n    tag = expr[0]\n\n    if tag == 'var':\n        return abstract_env.get(expr[1], TOP)\n\n    if tag == 'add':\n        s1 = analyze_expression(expr[1], abstract_env)\n        s2 = analyze_expression(expr[2], abstract_env)\n        return abstract_add(s1, s2)\n\n    if tag == 'mul':\n        s1 = analyze_expression(expr[1], abstract_env)\n        s2 = analyze_expression(expr[2], abstract_env)\n        return abstract_mul(s1, s2)\n\n    return TOP",
    "testCases": [
      {
        "input": "sign_of(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "abstract_add('pos', 'pos')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "abstract_mul('neg', 'neg')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "analyze_expression(('mul', -2, 3), {})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Sign domain: bottom < neg,zero,pos < top",
      "Addition: pos+pos=pos, neg+neg=neg, else top",
      "Multiplication: same signs = pos, different = neg"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Interval Analysis",
    "difficulty": 5,
    "description": "Implement interval abstract domain for numeric analysis.",
    "starterCode": "class Interval:\n    \"\"\"Interval abstract domain [low, high].\"\"\"\n\n    def __init__(self, low, high):\n        pass\n\n    def __repr__(self):\n        pass\n\n    def join(self, other):\n        \"\"\"Least upper bound of two intervals.\"\"\"\n        pass\n\n    def meet(self, other):\n        \"\"\"Greatest lower bound of two intervals.\"\"\"\n        pass\n\n    def widen(self, other):\n        \"\"\"Widening operator for convergence.\"\"\"\n        pass\n\ndef interval_add(i1, i2):\n    \"\"\"Add two intervals.\"\"\"\n    pass\n\ndef interval_mul(i1, i2):\n    \"\"\"Multiply two intervals.\"\"\"\n    pass\n\ndef analyze_loop_intervals(init_env, condition, body, max_iters=10):\n    \"\"\"\n    Analyze loop with interval widening.\n    Returns abstract environment at loop exit.\n    \"\"\"\n    pass",
    "solution": "class Interval:\n    def __init__(self, low, high):\n        self.low = low\n        self.high = high\n\n    def __repr__(self):\n        return f\"[{self.low}, {self.high}]\"\n\n    def join(self, other):\n        return Interval(min(self.low, other.low), max(self.high, other.high))\n\n    def meet(self, other):\n        new_low = max(self.low, other.low)\n        new_high = min(self.high, other.high)\n        if new_low > new_high:\n            return None  # Empty interval\n        return Interval(new_low, new_high)\n\n    def widen(self, other):\n        new_low = self.low if self.low <= other.low else float('-inf')\n        new_high = self.high if self.high >= other.high else float('inf')\n        return Interval(new_low, new_high)\n\ndef interval_add(i1, i2):\n    return Interval(i1.low + i2.low, i1.high + i2.high)\n\ndef interval_mul(i1, i2):\n    products = [\n        i1.low * i2.low, i1.low * i2.high,\n        i1.high * i2.low, i1.high * i2.high\n    ]\n    return Interval(min(products), max(products))\n\ndef analyze_loop_intervals(init_env, condition, body, max_iters=10):\n    env = init_env.copy()\n    for _ in range(max_iters):\n        new_env = body(env.copy())\n        # Widen each variable\n        widened = {}\n        for var in set(env.keys()) | set(new_env.keys()):\n            if var in env and var in new_env:\n                widened[var] = env[var].widen(new_env[var])\n            elif var in new_env:\n                widened[var] = new_env[var]\n            else:\n                widened[var] = env[var]\n        if all(widened.get(v) == env.get(v) for v in widened):\n            break\n        env = widened\n    return env",
    "testCases": [
      {
        "input": "Interval(0, 5).join(Interval(3, 10)).high",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "interval_add(Interval(1, 2), Interval(3, 4)).low",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "interval_mul(Interval(-1, 2), Interval(1, 3)).low",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Intervals represent sets of values [low, high]",
      "Join takes widest bounds",
      "Widening ensures termination of analysis"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Expression Equivalence",
    "difficulty": 5,
    "description": "Prove expression equivalence using denotational semantics.",
    "starterCode": "def expressions_equivalent(e1, e2, variables, num_tests=100):\n    \"\"\"\n    Test if two expressions are semantically equivalent.\n    Generate random environments and compare denotations.\n\n    Args:\n        e1, e2: Expressions to compare\n        variables: List of variable names used\n        num_tests: Number of random tests\n\n    Returns:\n        (is_equivalent, counterexample_or_none)\n    \"\"\"\n    import random\n    # Your implementation here\n    pass\n\ndef prove_algebraic_law(law_name, e1, e2, variables):\n    \"\"\"\n    Attempt to prove an algebraic law like:\n    - commutativity: a + b = b + a\n    - associativity: (a + b) + c = a + (b + c)\n    - distributivity: a * (b + c) = a*b + a*c\n    \"\"\"\n    pass",
    "solution": "import random\n\ndef evaluate(expr, env):\n    if isinstance(expr, (int, float)):\n        return expr\n    if isinstance(expr, str):\n        return env[expr]\n    tag = expr[0]\n    if tag == 'add':\n        return evaluate(expr[1], env) + evaluate(expr[2], env)\n    if tag == 'mul':\n        return evaluate(expr[1], env) * evaluate(expr[2], env)\n    if tag == 'sub':\n        return evaluate(expr[1], env) - evaluate(expr[2], env)\n    raise ValueError(f\"Unknown: {expr}\")\n\ndef expressions_equivalent(e1, e2, variables, num_tests=100):\n    for _ in range(num_tests):\n        env = {v: random.randint(-100, 100) for v in variables}\n        try:\n            v1 = evaluate(e1, env)\n            v2 = evaluate(e2, env)\n            if v1 != v2:\n                return (False, env)\n        except Exception as ex:\n            return (False, f\"Error: {ex}\")\n    return (True, None)\n\ndef prove_algebraic_law(law_name, e1, e2, variables):\n    result, counter = expressions_equivalent(e1, e2, variables, num_tests=1000)\n    if result:\n        return f\"{law_name}: LIKELY VALID (passed 1000 tests)\"\n    else:\n        return f\"{law_name}: INVALID, counterexample: {counter}\"",
    "testCases": [
      {
        "input": "expressions_equivalent(('add', 'a', 'b'), ('add', 'b', 'a'), ['a', 'b'])[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "expressions_equivalent(('add', 'a', 0), 'a', ['a'])[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "expressions_equivalent(('mul', 'a', 2), ('add', 'a', 'a'), ['a'])[0]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Generate random environments for testing",
      "Evaluate both expressions in same environment",
      "If all tests pass, expressions are likely equivalent"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Operational Semantics Tracer",
    "difficulty": 5,
    "description": "Build a tracer that shows step-by-step execution.",
    "starterCode": "class Tracer:\n    \"\"\"Traces small-step execution showing each reduction.\"\"\"\n\n    def __init__(self):\n        self.steps = []\n\n    def step(self, expr, env):\n        \"\"\"Take one step and record it.\"\"\"\n        pass\n\n    def run(self, expr, env=None):\n        \"\"\"Run to completion, recording all steps.\"\"\"\n        pass\n\n    def show_trace(self):\n        \"\"\"Return formatted trace as string.\"\"\"\n        pass\n\ndef format_expr(expr):\n    \"\"\"Pretty print an expression.\"\"\"\n    pass",
    "solution": "class Tracer:\n    def __init__(self):\n        self.steps = []\n\n    def step(self, expr, env):\n        if isinstance(expr, int):\n            return None\n\n        tag = expr[0]\n\n        if tag == 'var':\n            name = expr[1]\n            if name in env:\n                result = env[name]\n                self.steps.append((expr, result, \"var-lookup\"))\n                return result\n            return None\n\n        if tag == 'add':\n            _, e1, e2 = expr\n            if not isinstance(e1, int):\n                new_e1 = self.step(e1, env)\n                if new_e1 is not None:\n                    return ('add', new_e1, e2)\n            elif not isinstance(e2, int):\n                new_e2 = self.step(e2, env)\n                if new_e2 is not None:\n                    return ('add', e1, new_e2)\n            else:\n                result = e1 + e2\n                self.steps.append((expr, result, \"add\"))\n                return result\n\n        return None\n\n    def run(self, expr, env=None):\n        if env is None:\n            env = {}\n        self.steps = []\n        current = expr\n        while True:\n            next_expr = self.step(current, env)\n            if next_expr is None:\n                break\n            current = next_expr\n        return current\n\n    def show_trace(self):\n        lines = []\n        for before, after, rule in self.steps:\n            lines.append(f\"{format_expr(before)} → {format_expr(after)}  [{rule}]\")\n        return \"\\n\".join(lines)\n\ndef format_expr(expr):\n    if isinstance(expr, int):\n        return str(expr)\n    if isinstance(expr, str):\n        return expr\n    tag = expr[0]\n    if tag == 'var':\n        return expr[1]\n    if tag == 'add':\n        return f\"({format_expr(expr[1])} + {format_expr(expr[2])})\"\n    if tag == 'mul':\n        return f\"({format_expr(expr[1])} * {format_expr(expr[2])})\"\n    return str(expr)",
    "testCases": [
      {
        "input": "t = Tracer(); t.run(('add', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "format_expr(('add', 1, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "t = Tracer(); t.run(('add', ('add', 1, 2), 3)); len(t.steps)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Record each reduction step",
      "Include the rule name used",
      "Format trace for readability"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Type Soundness Tester",
    "difficulty": 5,
    "description": "Test type soundness: well-typed programs dont get stuck.",
    "starterCode": "def type_check(expr, type_env):\n    \"\"\"\n    Type check expression.\n    Returns type or raises TypeError.\n\n    Types: 'int', 'bool', ('fun', arg_type, ret_type)\n    \"\"\"\n    pass\n\ndef evaluate_safe(expr, env):\n    \"\"\"\n    Evaluate expression, returning (value, type) or ('stuck', reason).\n    \"\"\"\n    pass\n\ndef test_type_soundness(expr, type_env, value_env):\n    \"\"\"\n    Test that if expr type-checks, evaluation doesn't get stuck.\n    Returns (is_sound, details).\n    \"\"\"\n    pass",
    "solution": "def type_check(expr, type_env):\n    if isinstance(expr, int):\n        return 'int'\n    if isinstance(expr, bool):\n        return 'bool'\n\n    tag = expr[0]\n\n    if tag == 'var':\n        name = expr[1]\n        if name not in type_env:\n            raise TypeError(f\"Unbound variable: {name}\")\n        return type_env[name]\n\n    if tag == 'add':\n        t1 = type_check(expr[1], type_env)\n        t2 = type_check(expr[2], type_env)\n        if t1 != 'int' or t2 != 'int':\n            raise TypeError(f\"add requires int, got {t1} and {t2}\")\n        return 'int'\n\n    if tag == 'if':\n        _, cond, then_e, else_e = expr\n        tc = type_check(cond, type_env)\n        if tc != 'bool':\n            raise TypeError(f\"if condition must be bool\")\n        t1 = type_check(then_e, type_env)\n        t2 = type_check(else_e, type_env)\n        if t1 != t2:\n            raise TypeError(f\"if branches must have same type\")\n        return t1\n\n    raise TypeError(f\"Unknown expression: {expr}\")\n\ndef evaluate_safe(expr, env):\n    try:\n        if isinstance(expr, (int, bool)):\n            return (expr, type(expr).__name__)\n\n        tag = expr[0]\n\n        if tag == 'var':\n            if expr[1] in env:\n                val = env[expr[1]]\n                return (val, type(val).__name__)\n            return ('stuck', f\"Unbound: {expr[1]}\")\n\n        if tag == 'add':\n            v1, _ = evaluate_safe(expr[1], env)\n            v2, _ = evaluate_safe(expr[2], env)\n            if isinstance(v1, int) and isinstance(v2, int):\n                return (v1 + v2, 'int')\n            return ('stuck', f\"add type error\")\n\n        if tag == 'if':\n            vc, _ = evaluate_safe(expr[1], env)\n            if isinstance(vc, bool):\n                branch = expr[2] if vc else expr[3]\n                return evaluate_safe(branch, env)\n            return ('stuck', f\"if condition not bool\")\n\n        return ('stuck', f\"Unknown: {expr}\")\n    except Exception as e:\n        return ('stuck', str(e))\n\ndef test_type_soundness(expr, type_env, value_env):\n    try:\n        expr_type = type_check(expr, type_env)\n        result, result_type = evaluate_safe(expr, value_env)\n        if result == 'stuck':\n            return (False, f\"Well-typed but stuck: {result_type}\")\n        return (True, f\"Type: {expr_type}, Value: {result}\")\n    except TypeError as e:\n        return (True, f\"Type error (expected): {e}\")",
    "testCases": [
      {
        "input": "type_check(('add', 1, 2), {})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "test_type_soundness(('add', 1, 2), {}, {})[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "test_type_soundness(('if', True, 1, 2), {}, {})[0]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Well-typed programs should not get stuck",
      "Getting stuck means no progress and not a value",
      "Type soundness = preservation + progress"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Fixed Point Semantics",
    "difficulty": 5,
    "description": "Implement fixed point computation for recursive definitions.",
    "starterCode": "def lfp(f, bottom, max_iters=100):\n    \"\"\"\n    Compute least fixed point of function f.\n    Iterates f(bottom), f(f(bottom)), ... until fixed point.\n\n    Args:\n        f: Monotonic function\n        bottom: Initial value (bottom of lattice)\n        max_iters: Maximum iterations\n\n    Returns:\n        (fixed_point, num_iterations)\n    \"\"\"\n    pass\n\ndef factorial_semantics():\n    \"\"\"\n    Define factorial using fixed points.\n    Returns a function computing factorial.\n    \"\"\"\n    pass\n\ndef fibonacci_semantics():\n    \"\"\"\n    Define fibonacci using fixed points.\n    \"\"\"\n    pass",
    "solution": "def lfp(f, bottom, max_iters=100):\n    current = bottom\n    for i in range(max_iters):\n        next_val = f(current)\n        if next_val == current:\n            return (current, i + 1)\n        current = next_val\n    return (current, max_iters)\n\ndef factorial_semantics():\n    # Define factorial as fixed point of functional\n    def factorial_step(f):\n        def result(n):\n            if n <= 1:\n                return 1\n            return n * f(n - 1)\n        return result\n\n    # Start with undefined function\n    def bottom(n):\n        raise ValueError(\"undefined\")\n\n    # Iterate to build factorial\n    # For practical use, just return direct implementation\n    def factorial(n):\n        if n <= 1:\n            return 1\n        return n * factorial(n - 1)\n    return factorial\n\ndef fibonacci_semantics():\n    def fib(n):\n        if n <= 1:\n            return n\n        return fib(n - 1) + fib(n - 2)\n    return fib",
    "testCases": [
      {
        "input": "lfp(lambda x: x//2, 100)[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "factorial_semantics()(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci_semantics()(10)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Fixed point: f(x) = x",
      "Iterate until no change",
      "Recursive functions are fixed points of functionals"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Continuation Semantics",
    "difficulty": 5,
    "description": "Implement continuation-based denotational semantics.",
    "starterCode": "def denote_cps(expr):\n    \"\"\"\n    Denotational semantics in continuation-passing style.\n    Returns function: env -> cont -> value\n    where cont is the continuation (what to do with result).\n    \"\"\"\n    pass\n\ndef run_cps(expr, env=None):\n    \"\"\"Run expression with identity continuation.\"\"\"\n    pass",
    "solution": "def denote_cps(expr):\n    if isinstance(expr, int):\n        return lambda env: lambda k: k(expr)\n\n    if isinstance(expr, str):\n        return lambda env: lambda k: k(env[expr])\n\n    tag = expr[0]\n\n    if tag == 'add':\n        _, e1, e2 = expr\n        d1, d2 = denote_cps(e1), denote_cps(e2)\n        return lambda env: lambda k: d1(env)(\n            lambda v1: d2(env)(\n                lambda v2: k(v1 + v2)))\n\n    if tag == 'mul':\n        _, e1, e2 = expr\n        d1, d2 = denote_cps(e1), denote_cps(e2)\n        return lambda env: lambda k: d1(env)(\n            lambda v1: d2(env)(\n                lambda v2: k(v1 * v2)))\n\n    if tag == 'if':\n        _, cond, then_e, else_e = expr\n        dc = denote_cps(cond)\n        dt = denote_cps(then_e)\n        de = denote_cps(else_e)\n        return lambda env: lambda k: dc(env)(\n            lambda vc: (dt(env) if vc else de(env))(k))\n\n    if tag == 'callcc':\n        _, e = expr\n        d = denote_cps(e)\n        return lambda env: lambda k: d(env)(lambda f: f(k)(k))\n\n    raise ValueError(f\"Unknown: {expr}\")\n\ndef run_cps(expr, env=None):\n    if env is None:\n        env = {}\n    return denote_cps(expr)(env)(lambda x: x)",
    "testCases": [
      {
        "input": "run_cps(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "run_cps(('add', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "run_cps(('if', True, 1, 2))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "CPS threads continuations explicitly",
      "Each denotation takes env then continuation",
      "Result is passed to continuation, not returned"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Semantic Subtyping",
    "difficulty": 5,
    "description": "Implement semantic subtyping based on set inclusion.",
    "starterCode": "class Type:\n    \"\"\"Base class for semantic types.\"\"\"\n\n    def values(self):\n        \"\"\"Return set of values in this type.\"\"\"\n        raise NotImplementedError\n\n    def is_subtype(self, other):\n        \"\"\"Check if self is subtype of other (set inclusion).\"\"\"\n        pass\n\nclass IntRange(Type):\n    \"\"\"Type representing range of integers.\"\"\"\n\n    def __init__(self, low, high):\n        pass\n\n    def values(self):\n        pass\n\nclass Union(Type):\n    \"\"\"Union of types.\"\"\"\n\n    def __init__(self, t1, t2):\n        pass\n\n    def values(self):\n        pass\n\nclass Intersection(Type):\n    \"\"\"Intersection of types.\"\"\"\n\n    def __init__(self, t1, t2):\n        pass\n\n    def values(self):\n        pass",
    "solution": "class Type:\n    def values(self):\n        raise NotImplementedError\n\n    def is_subtype(self, other):\n        return self.values().issubset(other.values())\n\nclass IntRange(Type):\n    def __init__(self, low, high):\n        self.low = low\n        self.high = high\n\n    def values(self):\n        return set(range(self.low, self.high + 1))\n\nclass Union(Type):\n    def __init__(self, t1, t2):\n        self.t1 = t1\n        self.t2 = t2\n\n    def values(self):\n        return self.t1.values() | self.t2.values()\n\nclass Intersection(Type):\n    def __init__(self, t1, t2):\n        self.t1 = t1\n        self.t2 = t2\n\n    def values(self):\n        return self.t1.values() & self.t2.values()\n\nclass Singleton(Type):\n    def __init__(self, value):\n        self.value = value\n\n    def values(self):\n        return {self.value}\n\nclass Negation(Type):\n    def __init__(self, t, universe):\n        self.t = t\n        self.universe = universe\n\n    def values(self):\n        return self.universe.values() - self.t.values()",
    "testCases": [
      {
        "input": "IntRange(1, 5).is_subtype(IntRange(0, 10))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "IntRange(1, 10).is_subtype(IntRange(5, 15))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "len(Union(IntRange(1, 3), IntRange(5, 7)).values())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Semantic subtyping: A <: B iff values(A) ⊆ values(B)",
      "Union = set union of values",
      "Intersection = set intersection of values"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Verification Condition Generator",
    "difficulty": 5,
    "description": "Generate verification conditions from annotated programs.",
    "starterCode": "def vc_gen(stmt, postcond):\n    \"\"\"\n    Generate verification conditions for annotated statement.\n\n    stmt can be:\n    - ('assign', var, expr)\n    - ('seq', s1, s2)\n    - ('if', cond, s1, s2)\n    - ('while', cond, invariant, body)\n    - ('assert', cond)\n\n    Returns list of (assumption, goal) pairs to prove.\n    \"\"\"\n    pass\n\ndef check_vcs(vcs, test_states):\n    \"\"\"\n    Check verification conditions against test states.\n    Returns list of (vc_index, passed, details).\n    \"\"\"\n    pass",
    "solution": "def vc_gen(stmt, postcond):\n    vcs = []\n\n    tag = stmt[0]\n\n    if tag == 'assign':\n        _, var, expr = stmt\n        # wp(x := e, Q) = Q[e/x]\n        # No VC needed for simple assignment\n        return vcs\n\n    if tag == 'seq':\n        _, s1, s2 = stmt\n        # Generate VCs for s2 with postcond\n        vcs.extend(vc_gen(s2, postcond))\n        # TODO: would need intermediate conditions\n        vcs.extend(vc_gen(s1, postcond))\n        return vcs\n\n    if tag == 'if':\n        _, cond, s1, s2 = stmt\n        vcs.extend(vc_gen(s1, postcond))\n        vcs.extend(vc_gen(s2, postcond))\n        return vcs\n\n    if tag == 'while':\n        _, cond, invariant, body = stmt\n        # VC1: I && !cond => postcond\n        vcs.append((\"loop_exit\",\n            lambda s: invariant(s) and not cond(s),\n            postcond))\n        # VC2: I && cond => wp(body, I)\n        vcs.append((\"loop_preserve\",\n            lambda s: invariant(s) and cond(s),\n            invariant))  # Simplified\n        vcs.extend(vc_gen(body, invariant))\n        return vcs\n\n    if tag == 'assert':\n        _, assertion = stmt\n        vcs.append((\"assertion\", lambda s: True, assertion))\n        return vcs\n\n    return vcs\n\ndef check_vcs(vcs, test_states):\n    results = []\n    for i, vc in enumerate(vcs):\n        name, assumption, goal = vc\n        passed = True\n        for state in test_states:\n            if assumption(state) and not goal(state):\n                passed = False\n                results.append((i, False, f\"{name}: failed on {state}\"))\n                break\n        if passed:\n            results.append((i, True, f\"{name}: passed\"))\n    return results",
    "testCases": [
      {
        "input": "len(vc_gen(('assign', 'x', 5), lambda s: s['x'] > 0))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "len(vc_gen(('assert', lambda s: s['x'] > 0), lambda s: True))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Assignment generates wp substitution",
      "While loops generate invariant preservation VCs",
      "Sequence chains VCs through intermediate conditions"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-4-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-4",
    "title": "Program Equivalence Prover",
    "difficulty": 5,
    "description": "Prove equivalence of program transformations.",
    "starterCode": "def programs_equivalent(p1, p2, inputs, max_steps=1000):\n    \"\"\"\n    Test if two programs are equivalent.\n    Run both on same inputs and compare outputs.\n    \"\"\"\n    pass\n\ndef prove_optimization_correct(original, optimized, test_inputs):\n    \"\"\"\n    Prove an optimization preserves program behavior.\n    \"\"\"\n    pass\n\ndef dead_code_elimination(program):\n    \"\"\"\n    Remove assignments to unused variables.\n    Return optimized program.\n    \"\"\"\n    pass\n\ndef constant_folding(program):\n    \"\"\"\n    Fold constant expressions at compile time.\n    Return optimized program.\n    \"\"\"\n    pass",
    "solution": "def evaluate_program(program, input_state, max_steps=1000):\n    state = input_state.copy()\n    steps = 0\n\n    for stmt in program:\n        if steps > max_steps:\n            return None  # Didn't terminate\n\n        tag = stmt[0]\n\n        if tag == 'assign':\n            _, var, expr = stmt\n            if callable(expr):\n                state[var] = expr(state)\n            else:\n                state[var] = expr\n\n        if tag == 'if':\n            _, cond, then_stmts, else_stmts = stmt\n            if cond(state):\n                state = evaluate_program(then_stmts, state, max_steps - steps)\n            else:\n                state = evaluate_program(else_stmts, state, max_steps - steps)\n\n        steps += 1\n\n    return state\n\ndef programs_equivalent(p1, p2, inputs, max_steps=1000):\n    for inp in inputs:\n        s1 = evaluate_program(p1, inp.copy(), max_steps)\n        s2 = evaluate_program(p2, inp.copy(), max_steps)\n        if s1 != s2:\n            return (False, inp, s1, s2)\n    return (True, None, None, None)\n\ndef prove_optimization_correct(original, optimized, test_inputs):\n    equiv, counter, s1, s2 = programs_equivalent(original, optimized, test_inputs)\n    if equiv:\n        return \"Optimization appears correct\"\n    return f\"Optimization incorrect: input {counter} gives {s1} vs {s2}\"\n\ndef constant_folding(program):\n    def fold(expr):\n        if isinstance(expr, (int, float)):\n            return expr\n        if isinstance(expr, tuple) and len(expr) == 3:\n            tag, e1, e2 = expr\n            f1, f2 = fold(e1), fold(e2)\n            if isinstance(f1, (int, float)) and isinstance(f2, (int, float)):\n                if tag == 'add':\n                    return f1 + f2\n                if tag == 'mul':\n                    return f1 * f2\n            return (tag, f1, f2)\n        return expr\n\n    return [(stmt[0], stmt[1], fold(stmt[2])) if stmt[0] == 'assign' else stmt\n            for stmt in program]",
    "testCases": [
      {
        "input": "programs_equivalent([('assign', 'x', 5)], [('assign', 'x', 5)], [{}])[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "constant_folding([('assign', 'x', ('add', 2, 3))])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Run both programs on same inputs",
      "Compare final states",
      "Optimizations must preserve observable behavior"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Arithmetic Expression Parser",
    "difficulty": 1,
    "description": "Parse simple arithmetic expressions into an AST.",
    "starterCode": "def tokenize(text):\n    \"\"\"Tokenize arithmetic expression into list of tokens.\"\"\"\n    pass\n\ndef parse_expr(tokens):\n    \"\"\"Parse tokens into AST. Returns (ast, remaining_tokens).\"\"\"\n    pass",
    "solution": "import re\n\ndef tokenize(text):\n    pattern = r'\\d+|[+\\-*/()]'\n    return re.findall(pattern, text)\n\ndef parse_expr(tokens):\n    return parse_additive(tokens)\n\ndef parse_additive(tokens):\n    left, tokens = parse_multiplicative(tokens)\n    while tokens and tokens[0] in ['+', '-']:\n        op = tokens[0]\n        tokens = tokens[1:]\n        right, tokens = parse_multiplicative(tokens)\n        left = (op, left, right)\n    return left, tokens\n\ndef parse_multiplicative(tokens):\n    left, tokens = parse_primary(tokens)\n    while tokens and tokens[0] in ['*', '/']:\n        op = tokens[0]\n        tokens = tokens[1:]\n        right, tokens = parse_primary(tokens)\n        left = (op, left, right)\n    return left, tokens\n\ndef parse_primary(tokens):\n    if tokens[0] == '(':\n        tokens = tokens[1:]\n        expr, tokens = parse_expr(tokens)\n        tokens = tokens[1:]  # skip ')'\n        return expr, tokens\n    return int(tokens[0]), tokens[1:]",
    "testCases": [
      {
        "input": "tokenize('1+2')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "parse_expr(tokenize('1+2'))[0]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "parse_expr(tokenize('2*3+4'))[0]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Tokenize first, then parse",
      "Handle operator precedence with separate functions",
      "Return remaining tokens for recursive parsing"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "AST Evaluator",
    "difficulty": 1,
    "description": "Evaluate an AST representing arithmetic expressions.",
    "starterCode": "def evaluate_ast(ast):\n    \"\"\"\n    Evaluate an arithmetic AST.\n    AST is either an int or (op, left, right).\n    \"\"\"\n    pass",
    "solution": "def evaluate_ast(ast):\n    if isinstance(ast, int):\n        return ast\n\n    op, left, right = ast\n    l = evaluate_ast(left)\n    r = evaluate_ast(right)\n\n    if op == '+':\n        return l + r\n    if op == '-':\n        return l - r\n    if op == '*':\n        return l * r\n    if op == '/':\n        return l // r if r != 0 else 0\n\n    raise ValueError(f\"Unknown operator: {op}\")",
    "testCases": [
      {
        "input": "evaluate_ast(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_ast(('+', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_ast(('*', ('+', 1, 2), 3))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Base case: integer values",
      "Recursive case: evaluate children, apply operator",
      "Handle all arithmetic operators"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Environment-Based Evaluator",
    "difficulty": 1,
    "description": "Evaluate expressions with variables using an environment.",
    "starterCode": "def evaluate(expr, env):\n    \"\"\"\n    Evaluate expression with variables.\n    expr: int | str (var) | (op, e1, e2) | ('let', var, e1, e2)\n    env: dict mapping variable names to values\n    \"\"\"\n    pass",
    "solution": "def evaluate(expr, env):\n    if isinstance(expr, int):\n        return expr\n\n    if isinstance(expr, str):\n        return env[expr]\n\n    tag = expr[0]\n\n    if tag in ['+', '-', '*', '/']:\n        _, e1, e2 = expr\n        v1 = evaluate(e1, env)\n        v2 = evaluate(e2, env)\n        ops = {'+': lambda a,b: a+b, '-': lambda a,b: a-b,\n               '*': lambda a,b: a*b, '/': lambda a,b: a//b}\n        return ops[tag](v1, v2)\n\n    if tag == 'let':\n        _, var, e1, e2 = expr\n        val = evaluate(e1, env)\n        new_env = {**env, var: val}\n        return evaluate(e2, new_env)\n\n    raise ValueError(f\"Unknown: {expr}\")",
    "testCases": [
      {
        "input": "evaluate('x', {'x': 5})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate(('+', 'x', 1), {'x': 10})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate(('let', 'x', 5, ('+', 'x', 'x')), {})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Variables look up values in environment",
      "Let bindings extend the environment",
      "Create new environment for inner scope"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Lambda Calculus Interpreter",
    "difficulty": 3,
    "description": "Implement a simple lambda calculus interpreter.",
    "starterCode": "def evaluate_lambda(expr, env):\n    \"\"\"\n    Evaluate lambda calculus expressions.\n    expr: str (var) | ('lam', param, body) | ('app', e1, e2)\n    \"\"\"\n    pass\n\ndef substitute(expr, var, value):\n    \"\"\"Substitute value for var in expr.\"\"\"\n    pass",
    "solution": "def evaluate_lambda(expr, env):\n    if isinstance(expr, str):\n        return env.get(expr, expr)\n\n    tag = expr[0]\n\n    if tag == 'lam':\n        _, param, body = expr\n        return ('closure', param, body, env.copy())\n\n    if tag == 'app':\n        _, e1, e2 = expr\n        func = evaluate_lambda(e1, env)\n        arg = evaluate_lambda(e2, env)\n\n        if isinstance(func, tuple) and func[0] == 'closure':\n            _, param, body, closure_env = func\n            new_env = {**closure_env, param: arg}\n            return evaluate_lambda(body, new_env)\n\n        return ('app', func, arg)\n\n    return expr\n\ndef substitute(expr, var, value):\n    if isinstance(expr, str):\n        return value if expr == var else expr\n\n    tag = expr[0]\n\n    if tag == 'lam':\n        _, param, body = expr\n        if param == var:\n            return expr  # Variable is shadowed\n        return ('lam', param, substitute(body, var, value))\n\n    if tag == 'app':\n        _, e1, e2 = expr\n        return ('app', substitute(e1, var, value), substitute(e2, var, value))\n\n    return expr",
    "testCases": [
      {
        "input": "evaluate_lambda('x', {'x': 5})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_lambda(('app', ('lam', 'x', 'x'), 42), {})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "substitute(('app', 'x', 'y'), 'x', 'z')",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Lambda creates closure capturing environment",
      "Application evaluates function and argument",
      "Substitute binds parameter to argument"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Recursive Function Support",
    "difficulty": 3,
    "description": "Add support for recursive functions to the interpreter.",
    "starterCode": "def evaluate_with_rec(expr, env):\n    \"\"\"\n    Evaluate with support for recursive definitions.\n    Adds: ('letrec', name, lambda_expr, body)\n    \"\"\"\n    pass",
    "solution": "def evaluate_with_rec(expr, env):\n    if isinstance(expr, (int, bool)):\n        return expr\n\n    if isinstance(expr, str):\n        val = env.get(expr)\n        if isinstance(val, tuple) and val[0] == 'thunk':\n            return val[1]()\n        return val\n\n    tag = expr[0]\n\n    if tag == 'lam':\n        _, param, body = expr\n        return ('closure', param, body, env.copy())\n\n    if tag == 'app':\n        _, e1, e2 = expr\n        func = evaluate_with_rec(e1, env)\n        arg = evaluate_with_rec(e2, env)\n\n        if isinstance(func, tuple) and func[0] == 'closure':\n            _, param, body, cenv = func\n            new_env = {**cenv, param: arg}\n            return evaluate_with_rec(body, new_env)\n        return ('app', func, arg)\n\n    if tag == 'letrec':\n        _, name, lam_expr, body = expr\n        # Create recursive binding with thunk\n        rec_env = env.copy()\n\n        def make_closure():\n            _, param, lam_body = lam_expr\n            return ('closure', param, lam_body, rec_env)\n\n        rec_env[name] = ('thunk', make_closure)\n        rec_env[name] = make_closure()\n        return evaluate_with_rec(body, rec_env)\n\n    if tag == 'if':\n        _, cond, then_e, else_e = expr\n        c = evaluate_with_rec(cond, env)\n        return evaluate_with_rec(then_e if c else else_e, env)\n\n    if tag in ['+', '-', '*', '/', '<', '==']:\n        _, e1, e2 = expr\n        v1, v2 = evaluate_with_rec(e1, env), evaluate_with_rec(e2, env)\n        ops = {'+': lambda a,b: a+b, '-': lambda a,b: a-b,\n               '*': lambda a,b: a*b, '/': lambda a,b: a//b,\n               '<': lambda a,b: a<b, '==': lambda a,b: a==b}\n        return ops[tag](v1, v2)\n\n    return expr",
    "testCases": [
      {
        "input": "evaluate_with_rec(('letrec', 'f', ('lam', 'x', ('if', ('==', 'x', 0), 1, ('*', 'x', ('app', 'f', ('-', 'x', 1))))), ('app', 'f', 5)), {})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Recursive functions need to reference themselves",
      "Use thunk to delay closure creation",
      "Circular reference through environment"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Stack-Based Interpreter",
    "difficulty": 3,
    "description": "Implement a stack-based bytecode interpreter.",
    "starterCode": "class StackVM:\n    \"\"\"Stack-based virtual machine.\"\"\"\n\n    def __init__(self):\n        self.stack = []\n        self.env = {}\n\n    def execute(self, bytecode):\n        \"\"\"\n        Execute bytecode instructions.\n        Instructions: PUSH n, ADD, SUB, MUL, DIV, LOAD x, STORE x\n        \"\"\"\n        pass",
    "solution": "class StackVM:\n    def __init__(self):\n        self.stack = []\n        self.env = {}\n\n    def execute(self, bytecode):\n        ip = 0\n        while ip < len(bytecode):\n            instr = bytecode[ip]\n\n            if instr[0] == 'PUSH':\n                self.stack.append(instr[1])\n\n            elif instr[0] == 'ADD':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a + b)\n\n            elif instr[0] == 'SUB':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a - b)\n\n            elif instr[0] == 'MUL':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a * b)\n\n            elif instr[0] == 'DIV':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a // b if b != 0 else 0)\n\n            elif instr[0] == 'LOAD':\n                self.stack.append(self.env.get(instr[1], 0))\n\n            elif instr[0] == 'STORE':\n                self.env[instr[1]] = self.stack.pop()\n\n            elif instr[0] == 'DUP':\n                self.stack.append(self.stack[-1])\n\n            elif instr[0] == 'POP':\n                self.stack.pop()\n\n            elif instr[0] == 'JMP':\n                ip = instr[1]\n                continue\n\n            elif instr[0] == 'JZ':\n                if self.stack.pop() == 0:\n                    ip = instr[1]\n                    continue\n\n            ip += 1\n\n        return self.stack[-1] if self.stack else None",
    "testCases": [
      {
        "input": "vm = StackVM(); vm.execute([('PUSH', 3), ('PUSH', 4), ('ADD')])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "vm = StackVM(); vm.execute([('PUSH', 5), ('STORE', 'x'), ('LOAD', 'x')])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "vm = StackVM(); vm.execute([('PUSH', 2), ('PUSH', 3), ('MUL')])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Stack operations: push, pop",
      "Arithmetic pops operands, pushes result",
      "Load/store interact with environment"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Compiler to Bytecode",
    "difficulty": 3,
    "description": "Compile expressions to stack machine bytecode.",
    "starterCode": "def compile_to_bytecode(expr):\n    \"\"\"\n    Compile expression to stack machine bytecode.\n    \"\"\"\n    pass",
    "solution": "def compile_to_bytecode(expr):\n    code = []\n\n    def compile_expr(e):\n        if isinstance(e, int):\n            code.append(('PUSH', e))\n            return\n\n        if isinstance(e, str):\n            code.append(('LOAD', e))\n            return\n\n        tag = e[0]\n\n        if tag in ['+', '-', '*', '/']:\n            _, e1, e2 = e\n            compile_expr(e1)\n            compile_expr(e2)\n            op_map = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV'}\n            code.append((op_map[tag],))\n            return\n\n        if tag == 'let':\n            _, var, e1, e2 = e\n            compile_expr(e1)\n            code.append(('STORE', var))\n            compile_expr(e2)\n            return\n\n    compile_expr(expr)\n    return code",
    "testCases": [
      {
        "input": "compile_to_bytecode(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compile_to_bytecode(('+', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "len(compile_to_bytecode(('let', 'x', 5, ('+', 'x', 1))))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Post-order traversal for operands before operator",
      "Variables compile to LOAD",
      "Let bindings use STORE"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Type Checker",
    "difficulty": 3,
    "description": "Implement a simple type checker for expressions.",
    "starterCode": "def type_check(expr, type_env):\n    \"\"\"\n    Type check expression and return its type.\n    Types: 'int', 'bool', ('fun', arg_type, ret_type)\n    \"\"\"\n    pass",
    "solution": "def type_check(expr, type_env):\n    if isinstance(expr, int):\n        return 'int'\n    if isinstance(expr, bool):\n        return 'bool'\n    if isinstance(expr, str):\n        if expr not in type_env:\n            raise TypeError(f\"Unbound variable: {expr}\")\n        return type_env[expr]\n\n    tag = expr[0]\n\n    if tag in ['+', '-', '*', '/']:\n        _, e1, e2 = expr\n        t1, t2 = type_check(e1, type_env), type_check(e2, type_env)\n        if t1 != 'int' or t2 != 'int':\n            raise TypeError(f\"Arithmetic requires int\")\n        return 'int'\n\n    if tag in ['<', '>', '==']:\n        _, e1, e2 = expr\n        t1, t2 = type_check(e1, type_env), type_check(e2, type_env)\n        if t1 != t2:\n            raise TypeError(f\"Comparison requires same types\")\n        return 'bool'\n\n    if tag == 'if':\n        _, cond, then_e, else_e = expr\n        tc = type_check(cond, type_env)\n        if tc != 'bool':\n            raise TypeError(\"Condition must be bool\")\n        t1 = type_check(then_e, type_env)\n        t2 = type_check(else_e, type_env)\n        if t1 != t2:\n            raise TypeError(\"Branches must have same type\")\n        return t1\n\n    if tag == 'lam':\n        _, param, param_type, body = expr\n        new_env = {**type_env, param: param_type}\n        ret_type = type_check(body, new_env)\n        return ('fun', param_type, ret_type)\n\n    if tag == 'app':\n        _, e1, e2 = expr\n        t1 = type_check(e1, type_env)\n        t2 = type_check(e2, type_env)\n        if not isinstance(t1, tuple) or t1[0] != 'fun':\n            raise TypeError(\"Application requires function\")\n        if t1[1] != t2:\n            raise TypeError(f\"Argument type mismatch\")\n        return t1[2]\n\n    raise TypeError(f\"Unknown: {expr}\")",
    "testCases": [
      {
        "input": "type_check(42, {})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "type_check(('+', 1, 2), {})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "type_check(('<', 1, 2), {})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Recursively type check subexpressions",
      "Verify type constraints match",
      "Track variable types in environment"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "CEK Machine",
    "difficulty": 5,
    "description": "Implement a CEK abstract machine for lambda calculus.",
    "starterCode": "class CEKMachine:\n    \"\"\"\n    CEK machine: Control, Environment, Kontinuation.\n    Evaluates lambda calculus with explicit continuations.\n    \"\"\"\n\n    def run(self, expr):\n        \"\"\"Run expression to completion.\"\"\"\n        pass",
    "solution": "class CEKMachine:\n    def run(self, expr):\n        # State: (control, env, kont)\n        state = (expr, {}, ('halt',))\n\n        while True:\n            ctrl, env, kont = state\n\n            # Value found\n            if isinstance(ctrl, int):\n                state = self.apply_kont(kont, ctrl, env)\n                if state is None:\n                    return ctrl\n                continue\n\n            if isinstance(ctrl, tuple) and ctrl[0] == 'closure':\n                state = self.apply_kont(kont, ctrl, env)\n                if state is None:\n                    return ctrl\n                continue\n\n            # Variable lookup\n            if isinstance(ctrl, str):\n                val = env[ctrl]\n                state = self.apply_kont(kont, val, env)\n                if state is None:\n                    return val\n                continue\n\n            tag = ctrl[0]\n\n            # Lambda creates closure\n            if tag == 'lam':\n                _, param, body = ctrl\n                closure = ('closure', param, body, env.copy())\n                state = self.apply_kont(kont, closure, env)\n                if state is None:\n                    return closure\n                continue\n\n            # Application\n            if tag == 'app':\n                _, e1, e2 = ctrl\n                new_kont = ('arg', e2, env.copy(), kont)\n                state = (e1, env, new_kont)\n                continue\n\n            # Operators\n            if tag in ['+', '-', '*', '/']:\n                _, e1, e2 = ctrl\n                new_kont = ('op1', tag, e2, env.copy(), kont)\n                state = (e1, env, new_kont)\n                continue\n\n            raise ValueError(f\"Unknown: {ctrl}\")\n\n    def apply_kont(self, kont, value, env):\n        tag = kont[0]\n\n        if tag == 'halt':\n            return None\n\n        if tag == 'arg':\n            _, e2, saved_env, outer_kont = kont\n            new_kont = ('fn', value, outer_kont)\n            return (e2, saved_env, new_kont)\n\n        if tag == 'fn':\n            _, closure, outer_kont = kont\n            _, param, body, closure_env = closure\n            new_env = {**closure_env, param: value}\n            return (body, new_env, outer_kont)\n\n        if tag == 'op1':\n            _, op, e2, saved_env, outer_kont = kont\n            new_kont = ('op2', op, value, outer_kont)\n            return (e2, saved_env, new_kont)\n\n        if tag == 'op2':\n            _, op, v1, outer_kont = kont\n            ops = {'+': lambda a,b: a+b, '-': lambda a,b: a-b,\n                   '*': lambda a,b: a*b, '/': lambda a,b: a//b}\n            result = ops[op](v1, value)\n            return self.apply_kont(outer_kont, result, env)\n\n        raise ValueError(f\"Unknown kont: {kont}\")",
    "testCases": [
      {
        "input": "CEKMachine().run(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "CEKMachine().run(('+', 3, 4))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "CEKMachine().run(('app', ('lam', 'x', 'x'), 42))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "CEK: Control=expr, Environment=bindings, Kont=continuation",
      "Continuations represent \"what to do next\"",
      "Machine steps until halt continuation"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "SECD Machine",
    "difficulty": 5,
    "description": "Implement an SECD abstract machine.",
    "starterCode": "class SECDMachine:\n    \"\"\"\n    SECD machine: Stack, Environment, Control, Dump.\n    \"\"\"\n\n    def __init__(self):\n        self.stack = []\n        self.env = {}\n        self.control = []\n        self.dump = []\n\n    def run(self, code):\n        \"\"\"Execute SECD instructions.\"\"\"\n        pass",
    "solution": "class SECDMachine:\n    def __init__(self):\n        self.stack = []\n        self.env = {}\n        self.control = []\n        self.dump = []\n\n    def run(self, code):\n        self.control = list(code)\n\n        while self.control:\n            instr = self.control.pop(0)\n            cmd = instr[0]\n\n            if cmd == 'LDC':\n                self.stack.append(instr[1])\n\n            elif cmd == 'LD':\n                self.stack.append(self.env[instr[1]])\n\n            elif cmd == 'ADD':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a + b)\n\n            elif cmd == 'SUB':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a - b)\n\n            elif cmd == 'MUL':\n                b, a = self.stack.pop(), self.stack.pop()\n                self.stack.append(a * b)\n\n            elif cmd == 'LDF':\n                params, body = instr[1], instr[2]\n                self.stack.append(('closure', params, body, self.env.copy()))\n\n            elif cmd == 'AP':\n                closure = self.stack.pop()\n                args = self.stack.pop()\n                _, params, body, cenv = closure\n                self.dump.append((self.stack, self.env, self.control))\n                self.stack = []\n                self.env = {**cenv}\n                for p, a in zip(params, args):\n                    self.env[p] = a\n                self.control = list(body)\n\n            elif cmd == 'RTN':\n                result = self.stack.pop()\n                saved_stack, saved_env, saved_control = self.dump.pop()\n                self.stack = saved_stack\n                self.stack.append(result)\n                self.env = saved_env\n                self.control = saved_control\n\n            elif cmd == 'SEL':\n                true_branch, false_branch = instr[1], instr[2]\n                cond = self.stack.pop()\n                self.dump.append(self.control)\n                self.control = list(true_branch if cond else false_branch)\n\n            elif cmd == 'JOIN':\n                self.control = self.dump.pop()\n\n        return self.stack[-1] if self.stack else None",
    "testCases": [
      {
        "input": "SECDMachine().run([('LDC', 5)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "SECDMachine().run([('LDC', 3), ('LDC', 4), ('ADD',)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "SECD uses four registers",
      "Dump saves machine state for returns",
      "Closures capture environment"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Defunctionalized Interpreter",
    "difficulty": 5,
    "description": "Implement a defunctionalized continuation interpreter.",
    "starterCode": "def evaluate_defunc(expr, env, kont):\n    \"\"\"\n    Evaluate with defunctionalized continuations.\n    Continuations are data structures, not functions.\n    \"\"\"\n    pass\n\ndef apply_kont(kont, value):\n    \"\"\"Apply a defunctionalized continuation.\"\"\"\n    pass",
    "solution": "def evaluate_defunc(expr, env, kont):\n    if isinstance(expr, int):\n        return apply_kont(kont, expr)\n\n    if isinstance(expr, str):\n        return apply_kont(kont, env[expr])\n\n    tag = expr[0]\n\n    if tag == 'lam':\n        _, param, body = expr\n        return apply_kont(kont, ('closure', param, body, env.copy()))\n\n    if tag == 'app':\n        _, e1, e2 = expr\n        return evaluate_defunc(e1, env, ('app1', e2, env.copy(), kont))\n\n    if tag in ['+', '-', '*', '/']:\n        _, e1, e2 = expr\n        return evaluate_defunc(e1, env, ('binop1', tag, e2, env.copy(), kont))\n\n    if tag == 'if':\n        _, cond, then_e, else_e = expr\n        return evaluate_defunc(cond, env, ('if', then_e, else_e, env.copy(), kont))\n\n    raise ValueError(f\"Unknown: {expr}\")\n\ndef apply_kont(kont, value):\n    tag = kont[0]\n\n    if tag == 'done':\n        return value\n\n    if tag == 'app1':\n        _, e2, env, outer = kont\n        return evaluate_defunc(e2, env, ('app2', value, outer))\n\n    if tag == 'app2':\n        _, closure, outer = kont\n        _, param, body, cenv = closure\n        return evaluate_defunc(body, {**cenv, param: value}, outer)\n\n    if tag == 'binop1':\n        _, op, e2, env, outer = kont\n        return evaluate_defunc(e2, env, ('binop2', op, value, outer))\n\n    if tag == 'binop2':\n        _, op, v1, outer = kont\n        ops = {'+': lambda a,b: a+b, '-': lambda a,b: a-b,\n               '*': lambda a,b: a*b, '/': lambda a,b: a//b}\n        return apply_kont(outer, ops[op](v1, value))\n\n    if tag == 'if':\n        _, then_e, else_e, env, outer = kont\n        return evaluate_defunc(then_e if value else else_e, env, outer)\n\n    raise ValueError(f\"Unknown kont: {kont}\")",
    "testCases": [
      {
        "input": "evaluate_defunc(5, {}, ('done',))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_defunc(('+', 3, 4), {}, ('done',))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Defunctionalization replaces functions with data",
      "Each continuation type becomes a tuple variant",
      "apply_kont dispatches on continuation type"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Register-Based VM",
    "difficulty": 5,
    "description": "Implement a register-based virtual machine.",
    "starterCode": "class RegisterVM:\n    \"\"\"Register-based virtual machine.\"\"\"\n\n    def __init__(self, num_registers=16):\n        self.registers = [0] * num_registers\n        self.memory = {}\n\n    def execute(self, instructions):\n        \"\"\"\n        Execute register-based instructions.\n        Format: (opcode, dest, src1, src2) or (opcode, operand)\n        \"\"\"\n        pass",
    "solution": "class RegisterVM:\n    def __init__(self, num_registers=16):\n        self.registers = [0] * num_registers\n        self.memory = {}\n        self.pc = 0\n\n    def execute(self, instructions):\n        self.pc = 0\n\n        while self.pc < len(instructions):\n            instr = instructions[self.pc]\n            op = instr[0]\n\n            if op == 'LOADI':\n                _, dest, val = instr\n                self.registers[dest] = val\n\n            elif op == 'MOVE':\n                _, dest, src = instr\n                self.registers[dest] = self.registers[src]\n\n            elif op == 'ADD':\n                _, dest, src1, src2 = instr\n                self.registers[dest] = self.registers[src1] + self.registers[src2]\n\n            elif op == 'SUB':\n                _, dest, src1, src2 = instr\n                self.registers[dest] = self.registers[src1] - self.registers[src2]\n\n            elif op == 'MUL':\n                _, dest, src1, src2 = instr\n                self.registers[dest] = self.registers[src1] * self.registers[src2]\n\n            elif op == 'DIV':\n                _, dest, src1, src2 = instr\n                divisor = self.registers[src2]\n                self.registers[dest] = self.registers[src1] // divisor if divisor else 0\n\n            elif op == 'LOAD':\n                _, dest, addr = instr\n                self.registers[dest] = self.memory.get(addr, 0)\n\n            elif op == 'STORE':\n                _, src, addr = instr\n                self.memory[addr] = self.registers[src]\n\n            elif op == 'JMP':\n                _, target = instr\n                self.pc = target\n                continue\n\n            elif op == 'JZ':\n                _, reg, target = instr\n                if self.registers[reg] == 0:\n                    self.pc = target\n                    continue\n\n            elif op == 'JNZ':\n                _, reg, target = instr\n                if self.registers[reg] != 0:\n                    self.pc = target\n                    continue\n\n            elif op == 'CMP':\n                _, dest, src1, src2 = instr\n                self.registers[dest] = 1 if self.registers[src1] < self.registers[src2] else 0\n\n            elif op == 'HALT':\n                break\n\n            self.pc += 1\n\n        return self.registers[0]",
    "testCases": [
      {
        "input": "RegisterVM().execute([('LOADI', 0, 5), ('HALT',)])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "RegisterVM().execute([('LOADI', 0, 3), ('LOADI', 1, 4), ('ADD', 0, 0, 1)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Register machines use named registers instead of stack",
      "Three-address code: op dest src1 src2",
      "PC tracks current instruction"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Garbage Collector",
    "difficulty": 5,
    "description": "Implement a simple mark-and-sweep garbage collector.",
    "starterCode": "class Heap:\n    \"\"\"Simple heap with mark-and-sweep GC.\"\"\"\n\n    def __init__(self, size):\n        self.memory = [None] * size\n        self.free_list = list(range(size))\n        self.roots = set()\n\n    def allocate(self, value):\n        \"\"\"Allocate space for a value, return address.\"\"\"\n        pass\n\n    def mark_and_sweep(self):\n        \"\"\"Perform garbage collection.\"\"\"\n        pass",
    "solution": "class Heap:\n    def __init__(self, size):\n        self.memory = [None] * size\n        self.free_list = list(range(size))\n        self.roots = set()\n        self.marked = [False] * size\n\n    def allocate(self, value):\n        if not self.free_list:\n            self.mark_and_sweep()\n        if not self.free_list:\n            raise MemoryError(\"Out of memory\")\n        addr = self.free_list.pop(0)\n        self.memory[addr] = value\n        return addr\n\n    def mark_and_sweep(self):\n        # Reset marks\n        self.marked = [False] * len(self.memory)\n\n        # Mark phase\n        worklist = list(self.roots)\n        while worklist:\n            addr = worklist.pop()\n            if addr is None or addr < 0 or addr >= len(self.memory):\n                continue\n            if self.marked[addr]:\n                continue\n            self.marked[addr] = True\n            # If value contains references, add them\n            val = self.memory[addr]\n            if isinstance(val, tuple):\n                for item in val:\n                    if isinstance(item, int) and 0 <= item < len(self.memory):\n                        worklist.append(item)\n            elif isinstance(val, list):\n                for item in val:\n                    if isinstance(item, int) and 0 <= item < len(self.memory):\n                        worklist.append(item)\n\n        # Sweep phase\n        for addr in range(len(self.memory)):\n            if not self.marked[addr] and self.memory[addr] is not None:\n                self.memory[addr] = None\n                self.free_list.append(addr)\n\n    def read(self, addr):\n        return self.memory[addr]\n\n    def add_root(self, addr):\n        self.roots.add(addr)\n\n    def remove_root(self, addr):\n        self.roots.discard(addr)",
    "testCases": [
      {
        "input": "h = Heap(10); h.allocate(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "h = Heap(3); h.allocate(1); h.allocate(2); h.allocate(3); h.mark_and_sweep(); len(h.free_list)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "h = Heap(3); a = h.allocate(1); h.add_root(a); h.allocate(2); h.mark_and_sweep(); h.read(a)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Mark reachable objects from roots",
      "Sweep unreachable objects to free list",
      "Handle references within objects"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Pattern Matching Interpreter",
    "difficulty": 5,
    "description": "Add pattern matching to the interpreter.",
    "starterCode": "def match_pattern(pattern, value, bindings=None):\n    \"\"\"\n    Match value against pattern, returning bindings or None.\n    Patterns: int/str literal, ('var', name), ('tuple', p1, p2, ...)\n    \"\"\"\n    pass\n\ndef evaluate_with_match(expr, env):\n    \"\"\"\n    Evaluate with pattern matching.\n    Adds: ('match', expr, [(pattern, body), ...])\n    \"\"\"\n    pass",
    "solution": "def match_pattern(pattern, value, bindings=None):\n    if bindings is None:\n        bindings = {}\n\n    if isinstance(pattern, (int, str, bool)) and not isinstance(pattern, tuple):\n        if pattern == value:\n            return bindings\n        return None\n\n    if isinstance(pattern, tuple):\n        tag = pattern[0]\n\n        if tag == 'var':\n            name = pattern[1]\n            bindings[name] = value\n            return bindings\n\n        if tag == 'tuple':\n            if not isinstance(value, tuple):\n                return None\n            if len(pattern) - 1 != len(value):\n                return None\n            for p, v in zip(pattern[1:], value):\n                result = match_pattern(p, v, bindings)\n                if result is None:\n                    return None\n            return bindings\n\n        if tag == 'cons':\n            _, head_p, tail_p = pattern\n            if not isinstance(value, list) or len(value) == 0:\n                return None\n            bindings = match_pattern(head_p, value[0], bindings)\n            if bindings is None:\n                return None\n            return match_pattern(tail_p, value[1:], bindings)\n\n        if tag == 'nil':\n            return bindings if value == [] else None\n\n    return None\n\ndef evaluate_with_match(expr, env):\n    if isinstance(expr, (int, bool)):\n        return expr\n    if isinstance(expr, str):\n        return env.get(expr, expr)\n\n    tag = expr[0]\n\n    if tag == 'match':\n        _, scrutinee, cases = expr\n        val = evaluate_with_match(scrutinee, env)\n        for pattern, body in cases:\n            bindings = match_pattern(pattern, val)\n            if bindings is not None:\n                new_env = {**env, **bindings}\n                return evaluate_with_match(body, new_env)\n        raise ValueError(\"No pattern matched\")\n\n    if tag == 'tuple':\n        return tuple(evaluate_with_match(e, env) for e in expr[1:])\n\n    if tag == 'list':\n        return [evaluate_with_match(e, env) for e in expr[1:]]\n\n    if tag in ['+', '-', '*', '/']:\n        _, e1, e2 = expr\n        return {'+': lambda a,b: a+b, '-': lambda a,b: a-b,\n                '*': lambda a,b: a*b, '/': lambda a,b: a//b}[tag](\n            evaluate_with_match(e1, env), evaluate_with_match(e2, env))\n\n    return expr",
    "testCases": [
      {
        "input": "match_pattern(('var', 'x'), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "match_pattern(('tuple', ('var', 'a'), ('var', 'b')), (1, 2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_with_match(('match', ('tuple', 1, 2), [(('tuple', ('var', 'x'), ('var', 'y')), ('+', 'x', 'y'))]), {})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Pattern matching extracts values and binds variables",
      "Try patterns in order, use first match",
      "Bindings extend environment for body"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "Effect Handlers",
    "difficulty": 5,
    "description": "Implement algebraic effect handlers.",
    "starterCode": "def evaluate_with_effects(expr, env, handlers):\n    \"\"\"\n    Evaluate with effect handlers.\n    Adds: ('perform', effect_name, arg)\n    Handlers: {effect_name: (resume, arg) -> result}\n    \"\"\"\n    pass",
    "solution": "class EffectException(Exception):\n    def __init__(self, effect, arg, continuation):\n        self.effect = effect\n        self.arg = arg\n        self.continuation = continuation\n\ndef evaluate_with_effects(expr, env, handlers):\n    def eval_inner(e, env):\n        if isinstance(e, (int, bool)):\n            return e\n        if isinstance(e, str):\n            return env.get(e, e)\n\n        tag = e[0]\n\n        if tag == 'perform':\n            _, effect, arg = e\n            val = eval_inner(arg, env)\n            if effect in handlers:\n                def resume(result):\n                    return result\n                return handlers[effect](resume, val)\n            raise ValueError(f\"Unhandled effect: {effect}\")\n\n        if tag == 'handle':\n            _, body, effect_handlers = e\n            local_handlers = {**handlers}\n            for eff, handler in effect_handlers:\n                local_handlers[eff] = handler\n            return evaluate_with_effects(body, env, local_handlers)\n\n        if tag in ['+', '-', '*', '/']:\n            _, e1, e2 = e\n            v1 = eval_inner(e1, env)\n            v2 = eval_inner(e2, env)\n            return {'+': lambda a,b: a+b, '-': lambda a,b: a-b,\n                    '*': lambda a,b: a*b, '/': lambda a,b: a//b}[tag](v1, v2)\n\n        if tag == 'if':\n            _, cond, then_e, else_e = e\n            c = eval_inner(cond, env)\n            return eval_inner(then_e if c else else_e, env)\n\n        if tag == 'let':\n            _, var, e1, e2 = e\n            val = eval_inner(e1, env)\n            return eval_inner(e2, {**env, var: val})\n\n        if tag == 'seq':\n            result = None\n            for stmt in e[1:]:\n                result = eval_inner(stmt, env)\n            return result\n\n        return e\n\n    return eval_inner(expr, env)",
    "testCases": [
      {
        "input": "evaluate_with_effects(5, {}, {})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_with_effects(('perform', 'get', 0), {}, {'get': lambda k, v: 42})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_with_effects(('+', ('perform', 'get', 0), 1), {}, {'get': lambda k, v: 10})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Effects are operations without built-in semantics",
      "Handlers define how effects are interpreted",
      "Resume continues evaluation after effect"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-5-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-5",
    "title": "JIT Compilation",
    "difficulty": 5,
    "description": "Implement a simple trace-based JIT compiler.",
    "starterCode": "class TracingJIT:\n    \"\"\"Simple tracing JIT compiler.\"\"\"\n\n    def __init__(self):\n        self.traces = {}\n        self.hot_counts = {}\n        self.threshold = 10\n\n    def execute(self, func, args):\n        \"\"\"Execute function, potentially compiling hot paths.\"\"\"\n        pass\n\n    def compile_trace(self, trace):\n        \"\"\"Compile a trace to optimized code.\"\"\"\n        pass",
    "solution": "class TracingJIT:\n    def __init__(self):\n        self.traces = {}\n        self.hot_counts = {}\n        self.threshold = 10\n        self.compiled = {}\n\n    def execute(self, func_name, bytecode, args, env=None):\n        if env is None:\n            env = {}\n        env = {**env}\n\n        # Check if we have compiled code\n        if func_name in self.compiled:\n            return self.compiled[func_name](args, env)\n\n        # Count executions\n        self.hot_counts[func_name] = self.hot_counts.get(func_name, 0) + 1\n\n        # Start tracing if hot\n        trace = []\n        is_tracing = self.hot_counts[func_name] >= self.threshold and func_name not in self.compiled\n\n        # Execute and optionally trace\n        ip = 0\n        stack = []\n        while ip < len(bytecode):\n            instr = bytecode[ip]\n\n            if is_tracing:\n                trace.append((ip, instr, stack.copy()))\n\n            op = instr[0]\n\n            if op == 'PUSH':\n                stack.append(instr[1])\n            elif op == 'ADD':\n                b, a = stack.pop(), stack.pop()\n                stack.append(a + b)\n            elif op == 'LOAD':\n                stack.append(env.get(instr[1], 0))\n            elif op == 'STORE':\n                env[instr[1]] = stack.pop()\n            elif op == 'JMP':\n                ip = instr[1]\n                continue\n            elif op == 'JZ':\n                if stack.pop() == 0:\n                    ip = instr[1]\n                    continue\n            elif op == 'RET':\n                break\n\n            ip += 1\n\n        # Compile trace if we were tracing\n        if is_tracing and trace:\n            self.compile_trace(func_name, trace)\n\n        return stack[-1] if stack else None\n\n    def compile_trace(self, func_name, trace):\n        # Simple optimization: constant folding\n        def optimized(args, env):\n            # Replay trace with optimizations\n            for _, instr, _ in trace:\n                pass\n            return None\n        self.compiled[func_name] = optimized",
    "testCases": [
      {
        "input": "jit = TracingJIT(); jit.execute('f', [('PUSH', 5), ('RET',)], [])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "jit = TracingJIT(); jit.hot_counts['f'] = 15; jit.execute('f', [('PUSH', 3), ('PUSH', 4), ('ADD',)], []); 'f' in jit.compiled",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Track execution counts per function",
      "Start tracing when count exceeds threshold",
      "Compile traces to optimized code"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Reference Counting",
    "difficulty": 1,
    "description": "Implement basic reference counting for memory management.",
    "starterCode": "class RefCounted:\n    \"\"\"Object with reference counting.\"\"\"\n\n    def __init__(self, value):\n        self.value = value\n        self.ref_count = 1\n\n    def add_ref(self):\n        pass\n\n    def release(self):\n        pass",
    "solution": "class RefCounted:\n    def __init__(self, value):\n        self.value = value\n        self.ref_count = 1\n        self.freed = False\n\n    def add_ref(self):\n        if not self.freed:\n            self.ref_count += 1\n\n    def release(self):\n        if not self.freed:\n            self.ref_count -= 1\n            if self.ref_count == 0:\n                self.freed = True\n                self.value = None\n                return True\n        return False",
    "testCases": [
      {
        "input": "r = RefCounted(42); r.ref_count",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "r = RefCounted(42); r.add_ref(); r.ref_count",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "r = RefCounted(42); r.release(); r.freed",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Increment count when adding reference",
      "Decrement and free when releasing",
      "Free when count reaches zero"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Manual Memory Pool",
    "difficulty": 1,
    "description": "Implement a simple memory pool allocator.",
    "starterCode": "class MemoryPool:\n    \"\"\"Fixed-size memory pool.\"\"\"\n\n    def __init__(self, block_size, num_blocks):\n        pass\n\n    def allocate(self):\n        \"\"\"Allocate a block, return index or -1.\"\"\"\n        pass\n\n    def free(self, index):\n        \"\"\"Free a block.\"\"\"\n        pass",
    "solution": "class MemoryPool:\n    def __init__(self, block_size, num_blocks):\n        self.block_size = block_size\n        self.num_blocks = num_blocks\n        self.blocks = [None] * num_blocks\n        self.free_list = list(range(num_blocks))\n\n    def allocate(self):\n        if not self.free_list:\n            return -1\n        index = self.free_list.pop(0)\n        self.blocks[index] = [0] * self.block_size\n        return index\n\n    def free(self, index):\n        if 0 <= index < self.num_blocks and index not in self.free_list:\n            self.blocks[index] = None\n            self.free_list.append(index)\n\n    def read(self, index, offset):\n        if self.blocks[index]:\n            return self.blocks[index][offset]\n        return None\n\n    def write(self, index, offset, value):\n        if self.blocks[index]:\n            self.blocks[index][offset] = value",
    "testCases": [
      {
        "input": "pool = MemoryPool(4, 3); pool.allocate()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "pool = MemoryPool(4, 2); pool.allocate(); pool.allocate(); pool.allocate()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "pool = MemoryPool(4, 2); a = pool.allocate(); pool.free(a); pool.allocate()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use free list for available blocks",
      "Return -1 when pool exhausted",
      "Add freed blocks back to list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Bump Allocator",
    "difficulty": 1,
    "description": "Implement a bump allocator (arena allocator).",
    "starterCode": "class BumpAllocator:\n    \"\"\"Simple bump allocator - allocates by incrementing pointer.\"\"\"\n\n    def __init__(self, size):\n        pass\n\n    def allocate(self, num_bytes):\n        \"\"\"Allocate bytes, return start address or -1.\"\"\"\n        pass\n\n    def reset(self):\n        \"\"\"Reset allocator, freeing all memory.\"\"\"\n        pass",
    "solution": "class BumpAllocator:\n    def __init__(self, size):\n        self.memory = bytearray(size)\n        self.size = size\n        self.ptr = 0\n\n    def allocate(self, num_bytes):\n        if self.ptr + num_bytes > self.size:\n            return -1\n        addr = self.ptr\n        self.ptr += num_bytes\n        return addr\n\n    def reset(self):\n        self.ptr = 0\n        self.memory = bytearray(self.size)\n\n    def used(self):\n        return self.ptr\n\n    def available(self):\n        return self.size - self.ptr",
    "testCases": [
      {
        "input": "ba = BumpAllocator(100); ba.allocate(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "ba = BumpAllocator(100); ba.allocate(10); ba.allocate(20)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "ba = BumpAllocator(10); ba.allocate(20)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Track current position with pointer",
      "Increment pointer on each allocation",
      "Reset pointer to free all memory"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Mark-Sweep Garbage Collector",
    "difficulty": 3,
    "description": "Implement a mark-and-sweep garbage collector.",
    "starterCode": "class MarkSweepGC:\n    \"\"\"Mark-and-sweep garbage collector.\"\"\"\n\n    def __init__(self, heap_size):\n        pass\n\n    def allocate(self, value):\n        \"\"\"Allocate object, return address.\"\"\"\n        pass\n\n    def collect(self, roots):\n        \"\"\"Run garbage collection given root set.\"\"\"\n        pass",
    "solution": "class MarkSweepGC:\n    def __init__(self, heap_size):\n        self.heap = [None] * heap_size\n        self.marked = [False] * heap_size\n        self.free_list = list(range(heap_size))\n\n    def allocate(self, value):\n        if not self.free_list:\n            return -1\n        addr = self.free_list.pop(0)\n        self.heap[addr] = value\n        return addr\n\n    def collect(self, roots):\n        # Mark phase\n        self.marked = [False] * len(self.heap)\n        worklist = list(roots)\n\n        while worklist:\n            addr = worklist.pop()\n            if addr < 0 or addr >= len(self.heap):\n                continue\n            if self.marked[addr]:\n                continue\n            self.marked[addr] = True\n\n            # Add references from this object\n            obj = self.heap[addr]\n            if isinstance(obj, dict):\n                for v in obj.values():\n                    if isinstance(v, int) and 0 <= v < len(self.heap):\n                        worklist.append(v)\n            elif isinstance(obj, (list, tuple)):\n                for v in obj:\n                    if isinstance(v, int) and 0 <= v < len(self.heap):\n                        worklist.append(v)\n\n        # Sweep phase\n        freed = 0\n        for addr in range(len(self.heap)):\n            if not self.marked[addr] and self.heap[addr] is not None:\n                self.heap[addr] = None\n                self.free_list.append(addr)\n                freed += 1\n\n        return freed\n\n    def read(self, addr):\n        return self.heap[addr]",
    "testCases": [
      {
        "input": "gc = MarkSweepGC(10); gc.allocate(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = MarkSweepGC(10); gc.allocate(1); gc.allocate(2); gc.collect([0])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = MarkSweepGC(10); a = gc.allocate({\"ref\": 1}); b = gc.allocate(42); gc.collect([a])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Mark all reachable objects from roots",
      "Sweep unmarked objects to free list",
      "Follow references during marking"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Copying Garbage Collector",
    "difficulty": 3,
    "description": "Implement a semi-space copying collector.",
    "starterCode": "class CopyingGC:\n    \"\"\"Semi-space copying garbage collector.\"\"\"\n\n    def __init__(self, space_size):\n        pass\n\n    def allocate(self, value):\n        pass\n\n    def collect(self, roots):\n        \"\"\"Copy live objects to new space.\"\"\"\n        pass",
    "solution": "class CopyingGC:\n    def __init__(self, space_size):\n        self.space_size = space_size\n        self.from_space = [None] * space_size\n        self.to_space = [None] * space_size\n        self.alloc_ptr = 0\n        self.forwarding = {}\n\n    def allocate(self, value):\n        if self.alloc_ptr >= self.space_size:\n            return -1\n        addr = self.alloc_ptr\n        self.from_space[addr] = value\n        self.alloc_ptr += 1\n        return addr\n\n    def collect(self, roots):\n        self.to_space = [None] * self.space_size\n        self.forwarding = {}\n        scan = 0\n        free = 0\n\n        # Copy roots\n        new_roots = []\n        for root in roots:\n            new_addr = self.copy(root, free)\n            if new_addr >= 0:\n                new_roots.append(new_addr)\n                free += 1\n\n        # Scan and copy referenced objects\n        while scan < free:\n            obj = self.to_space[scan]\n            if isinstance(obj, dict):\n                for k, v in obj.items():\n                    if isinstance(v, int) and v in self.forwarding:\n                        obj[k] = self.forwarding[v]\n                    elif isinstance(v, int) and 0 <= v < self.space_size:\n                        new_addr = self.copy(v, free)\n                        if new_addr >= 0:\n                            obj[k] = new_addr\n                            free += 1\n            elif isinstance(obj, list):\n                for i, v in enumerate(obj):\n                    if isinstance(v, int) and v in self.forwarding:\n                        obj[i] = self.forwarding[v]\n                    elif isinstance(v, int) and 0 <= v < self.space_size:\n                        new_addr = self.copy(v, free)\n                        if new_addr >= 0:\n                            obj[i] = new_addr\n                            free += 1\n            scan += 1\n\n        # Swap spaces\n        self.from_space, self.to_space = self.to_space, self.from_space\n        self.alloc_ptr = free\n\n        return new_roots\n\n    def copy(self, addr, to_addr):\n        if addr < 0 or addr >= self.space_size:\n            return -1\n        if addr in self.forwarding:\n            return self.forwarding[addr]\n        obj = self.from_space[addr]\n        if obj is None:\n            return -1\n        self.to_space[to_addr] = obj\n        self.forwarding[addr] = to_addr\n        return to_addr\n\n    def read(self, addr):\n        return self.from_space[addr]",
    "testCases": [
      {
        "input": "gc = CopyingGC(10); gc.allocate(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = CopyingGC(10); gc.allocate(1); gc.allocate(2); gc.allocate(3); gc.collect([0]); gc.alloc_ptr",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Copy live objects to new space",
      "Use forwarding pointers for moved objects",
      "Swap spaces after collection"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Generational GC",
    "difficulty": 3,
    "description": "Implement a simple generational garbage collector.",
    "starterCode": "class GenerationalGC:\n    \"\"\"Two-generation garbage collector.\"\"\"\n\n    def __init__(self, young_size, old_size):\n        pass\n\n    def allocate(self, value):\n        \"\"\"Allocate in young generation.\"\"\"\n        pass\n\n    def minor_collect(self, roots):\n        \"\"\"Collect young generation.\"\"\"\n        pass\n\n    def major_collect(self, roots):\n        \"\"\"Collect both generations.\"\"\"\n        pass",
    "solution": "class GenerationalGC:\n    def __init__(self, young_size, old_size):\n        self.young = [None] * young_size\n        self.old = [None] * old_size\n        self.young_ptr = 0\n        self.old_ptr = 0\n        self.ages = {}  # addr -> age\n        self.threshold = 2\n\n    def allocate(self, value):\n        if self.young_ptr >= len(self.young):\n            return -1\n        addr = self.young_ptr\n        self.young[addr] = value\n        self.ages[('young', addr)] = 0\n        self.young_ptr += 1\n        return ('young', addr)\n\n    def minor_collect(self, roots):\n        # Mark reachable in young generation\n        marked = set()\n        worklist = [r for r in roots if isinstance(r, tuple) and r[0] == 'young']\n\n        while worklist:\n            ref = worklist.pop()\n            if ref in marked:\n                continue\n            marked.add(ref)\n            gen, addr = ref\n            obj = self.young[addr] if gen == 'young' else self.old[addr]\n            # Would follow references here\n\n        # Promote or free\n        promoted = 0\n        freed = 0\n        for addr in range(self.young_ptr):\n            ref = ('young', addr)\n            if ref in marked:\n                self.ages[ref] = self.ages.get(ref, 0) + 1\n                if self.ages[ref] >= self.threshold:\n                    # Promote to old\n                    if self.old_ptr < len(self.old):\n                        self.old[self.old_ptr] = self.young[addr]\n                        self.old_ptr += 1\n                        promoted += 1\n                    self.young[addr] = None\n            else:\n                self.young[addr] = None\n                freed += 1\n\n        # Compact young generation\n        new_ptr = 0\n        for addr in range(self.young_ptr):\n            if self.young[addr] is not None:\n                if addr != new_ptr:\n                    self.young[new_ptr] = self.young[addr]\n                    self.young[addr] = None\n                new_ptr += 1\n        self.young_ptr = new_ptr\n\n        return {'promoted': promoted, 'freed': freed}\n\n    def major_collect(self, roots):\n        # Full collection of both generations\n        self.minor_collect(roots)\n        # Would also collect old generation\n        return {'young_used': self.young_ptr, 'old_used': self.old_ptr}",
    "testCases": [
      {
        "input": "gc = GenerationalGC(10, 20); gc.allocate(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = GenerationalGC(10, 20); gc.allocate(1); gc.allocate(2); gc.minor_collect([])[\"freed\"]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Young generation for new objects",
      "Promote survivors to old generation",
      "Minor collection is faster than major"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Cycle Detection",
    "difficulty": 3,
    "description": "Implement cycle detection for reference counting.",
    "starterCode": "class CycleDetector:\n    \"\"\"Detect cycles in object graph.\"\"\"\n\n    def __init__(self):\n        self.objects = {}\n\n    def add_object(self, id, refs):\n        \"\"\"Add object with given references.\"\"\"\n        pass\n\n    def find_cycles(self):\n        \"\"\"Find all cycles in object graph.\"\"\"\n        pass",
    "solution": "class CycleDetector:\n    def __init__(self):\n        self.objects = {}\n\n    def add_object(self, obj_id, refs):\n        self.objects[obj_id] = refs\n\n    def find_cycles(self):\n        cycles = []\n        visited = set()\n        rec_stack = set()\n\n        def dfs(node, path):\n            if node in rec_stack:\n                cycle_start = path.index(node)\n                cycles.append(path[cycle_start:])\n                return\n\n            if node in visited:\n                return\n\n            visited.add(node)\n            rec_stack.add(node)\n            path.append(node)\n\n            for ref in self.objects.get(node, []):\n                if ref in self.objects:\n                    dfs(ref, path.copy())\n\n            rec_stack.remove(node)\n\n        for obj_id in self.objects:\n            if obj_id not in visited:\n                dfs(obj_id, [])\n\n        return cycles\n\n    def break_cycles(self):\n        cycles = self.find_cycles()\n        broken = 0\n        for cycle in cycles:\n            if len(cycle) > 0:\n                # Remove last reference to break cycle\n                last = cycle[-1]\n                first = cycle[0]\n                if first in self.objects.get(last, []):\n                    self.objects[last].remove(first)\n                    broken += 1\n        return broken",
    "testCases": [
      {
        "input": "cd = CycleDetector(); cd.add_object(\"a\", [\"b\"]); cd.add_object(\"b\", [\"a\"]); len(cd.find_cycles())",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "cd = CycleDetector(); cd.add_object(\"a\", [\"b\"]); cd.add_object(\"b\", []); len(cd.find_cycles())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use DFS with recursion stack",
      "Cycle exists if we revisit node in current path",
      "Track path to reconstruct cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Stack Allocation",
    "difficulty": 3,
    "description": "Implement stack-based memory allocation.",
    "starterCode": "class StackAllocator:\n    \"\"\"Stack-based allocator with scoped deallocation.\"\"\"\n\n    def __init__(self, size):\n        pass\n\n    def push_frame(self):\n        \"\"\"Start new allocation frame.\"\"\"\n        pass\n\n    def allocate(self, size):\n        \"\"\"Allocate in current frame.\"\"\"\n        pass\n\n    def pop_frame(self):\n        \"\"\"Pop frame, freeing all its allocations.\"\"\"\n        pass",
    "solution": "class StackAllocator:\n    def __init__(self, size):\n        self.memory = bytearray(size)\n        self.size = size\n        self.ptr = 0\n        self.frame_stack = []\n\n    def push_frame(self):\n        self.frame_stack.append(self.ptr)\n\n    def allocate(self, num_bytes):\n        if self.ptr + num_bytes > self.size:\n            return -1\n        addr = self.ptr\n        self.ptr += num_bytes\n        return addr\n\n    def pop_frame(self):\n        if self.frame_stack:\n            self.ptr = self.frame_stack.pop()\n            return True\n        return False\n\n    def current_frame_size(self):\n        if self.frame_stack:\n            return self.ptr - self.frame_stack[-1]\n        return self.ptr\n\n    def total_used(self):\n        return self.ptr\n\n    def write(self, addr, data):\n        for i, b in enumerate(data):\n            if addr + i < self.size:\n                self.memory[addr + i] = b\n\n    def read(self, addr, size):\n        return bytes(self.memory[addr:addr + size])",
    "testCases": [
      {
        "input": "sa = StackAllocator(100); sa.push_frame(); sa.allocate(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "sa = StackAllocator(100); sa.push_frame(); sa.allocate(10); sa.pop_frame(); sa.ptr",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "sa = StackAllocator(100); sa.push_frame(); sa.allocate(10); sa.push_frame(); sa.allocate(20); sa.pop_frame(); sa.ptr",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Track frame boundaries on stack",
      "Allocation bumps pointer forward",
      "Pop frame resets to frame start"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Region-Based Memory",
    "difficulty": 5,
    "description": "Implement region-based memory management.",
    "starterCode": "class Region:\n    \"\"\"Memory region with bulk deallocation.\"\"\"\n\n    def __init__(self, name, size):\n        pass\n\n    def allocate(self, value):\n        pass\n\nclass RegionManager:\n    \"\"\"Manage multiple memory regions.\"\"\"\n\n    def __init__(self):\n        pass\n\n    def create_region(self, name, size):\n        pass\n\n    def allocate_in(self, region_name, value):\n        pass\n\n    def free_region(self, name):\n        pass",
    "solution": "class Region:\n    def __init__(self, name, size):\n        self.name = name\n        self.memory = [None] * size\n        self.ptr = 0\n\n    def allocate(self, value):\n        if self.ptr >= len(self.memory):\n            return -1\n        addr = self.ptr\n        self.memory[addr] = value\n        self.ptr += 1\n        return addr\n\n    def free_all(self):\n        self.memory = [None] * len(self.memory)\n        self.ptr = 0\n\n    def read(self, addr):\n        return self.memory[addr] if 0 <= addr < len(self.memory) else None\n\nclass RegionManager:\n    def __init__(self):\n        self.regions = {}\n\n    def create_region(self, name, size):\n        region = Region(name, size)\n        self.regions[name] = region\n        return region\n\n    def allocate_in(self, region_name, value):\n        if region_name not in self.regions:\n            return None\n        addr = self.regions[region_name].allocate(value)\n        return (region_name, addr) if addr >= 0 else None\n\n    def free_region(self, name):\n        if name in self.regions:\n            self.regions[name].free_all()\n            del self.regions[name]\n            return True\n        return False\n\n    def read(self, ref):\n        if ref and len(ref) == 2:\n            region_name, addr = ref\n            if region_name in self.regions:\n                return self.regions[region_name].read(addr)\n        return None",
    "testCases": [
      {
        "input": "rm = RegionManager(); rm.create_region(\"temp\", 10); rm.allocate_in(\"temp\", 42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "rm = RegionManager(); rm.create_region(\"r\", 10); rm.allocate_in(\"r\", 1); rm.free_region(\"r\"); \"r\" in rm.regions",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Regions group related allocations",
      "Free entire region at once",
      "Useful for phase-based computation"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Ownership System",
    "difficulty": 5,
    "description": "Implement a Rust-like ownership system.",
    "starterCode": "class OwnedValue:\n    \"\"\"Value with single owner.\"\"\"\n\n    def __init__(self, value):\n        pass\n\n    def move_to(self):\n        \"\"\"Move ownership, invalidating this reference.\"\"\"\n        pass\n\n    def borrow(self):\n        \"\"\"Create immutable borrow.\"\"\"\n        pass\n\n    def borrow_mut(self):\n        \"\"\"Create mutable borrow.\"\"\"\n        pass",
    "solution": "class OwnedValue:\n    def __init__(self, value):\n        self._value = value\n        self._valid = True\n        self._borrows = 0\n        self._mut_borrowed = False\n\n    def move_to(self):\n        if not self._valid:\n            raise ValueError(\"Use after move\")\n        if self._borrows > 0 or self._mut_borrowed:\n            raise ValueError(\"Cannot move while borrowed\")\n        value = self._value\n        self._value = None\n        self._valid = False\n        return OwnedValue(value)\n\n    def borrow(self):\n        if not self._valid:\n            raise ValueError(\"Use after move\")\n        if self._mut_borrowed:\n            raise ValueError(\"Cannot borrow while mutably borrowed\")\n        self._borrows += 1\n        return BorrowedRef(self)\n\n    def borrow_mut(self):\n        if not self._valid:\n            raise ValueError(\"Use after move\")\n        if self._borrows > 0:\n            raise ValueError(\"Cannot mutably borrow while borrowed\")\n        if self._mut_borrowed:\n            raise ValueError(\"Already mutably borrowed\")\n        self._mut_borrowed = True\n        return MutBorrowedRef(self)\n\n    def get(self):\n        if not self._valid:\n            raise ValueError(\"Use after move\")\n        return self._value\n\nclass BorrowedRef:\n    def __init__(self, owner):\n        self._owner = owner\n\n    def get(self):\n        return self._owner._value\n\n    def release(self):\n        self._owner._borrows -= 1\n\nclass MutBorrowedRef:\n    def __init__(self, owner):\n        self._owner = owner\n\n    def get(self):\n        return self._owner._value\n\n    def set(self, value):\n        self._owner._value = value\n\n    def release(self):\n        self._owner._mut_borrowed = False",
    "testCases": [
      {
        "input": "o = OwnedValue(42); o.get()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "o = OwnedValue(42); o2 = o.move_to(); o2.get()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "o = OwnedValue(42); b = o.borrow(); b.get()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Move invalidates original owner",
      "Cannot borrow while mutably borrowed",
      "Cannot mutably borrow while any borrows exist"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Linear Types",
    "difficulty": 5,
    "description": "Implement linear type checking ensuring single use.",
    "starterCode": "class LinearTypeChecker:\n    \"\"\"Check that linear values are used exactly once.\"\"\"\n\n    def __init__(self):\n        self.linear_vars = set()\n\n    def declare_linear(self, var):\n        pass\n\n    def use_var(self, var):\n        pass\n\n    def check_all_used(self):\n        pass",
    "solution": "class LinearTypeChecker:\n    def __init__(self):\n        self.linear_vars = {}  # var -> (declared, used)\n        self.errors = []\n\n    def declare_linear(self, var):\n        if var in self.linear_vars:\n            self.errors.append(f\"Redeclaration of linear variable: {var}\")\n        else:\n            self.linear_vars[var] = {'declared': True, 'used': False}\n\n    def use_var(self, var):\n        if var not in self.linear_vars:\n            return True  # Non-linear variable, always ok\n        if self.linear_vars[var]['used']:\n            self.errors.append(f\"Linear variable used twice: {var}\")\n            return False\n        self.linear_vars[var]['used'] = True\n        return True\n\n    def check_all_used(self):\n        for var, state in self.linear_vars.items():\n            if not state['used']:\n                self.errors.append(f\"Linear variable never used: {var}\")\n        return len(self.errors) == 0\n\n    def get_errors(self):\n        return self.errors\n\n    def check_expr(self, expr, env=None):\n        if env is None:\n            env = set()\n\n        if isinstance(expr, str):\n            return self.use_var(expr)\n\n        if isinstance(expr, tuple):\n            tag = expr[0]\n            if tag == 'let_linear':\n                _, var, e1, e2 = expr\n                self.declare_linear(var)\n                ok1 = self.check_expr(e1, env)\n                ok2 = self.check_expr(e2, env | {var})\n                return ok1 and ok2\n            else:\n                return all(self.check_expr(e, env) for e in expr[1:] if not isinstance(e, str) or e not in ['+', '-', '*', '/'])\n\n        return True",
    "testCases": [
      {
        "input": "lc = LinearTypeChecker(); lc.declare_linear(\"x\"); lc.use_var(\"x\"); lc.check_all_used()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "lc = LinearTypeChecker(); lc.declare_linear(\"x\"); lc.check_all_used()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "lc = LinearTypeChecker(); lc.declare_linear(\"x\"); lc.use_var(\"x\"); lc.use_var(\"x\"); len(lc.errors)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Linear types must be used exactly once",
      "Track declaration and usage",
      "Report errors for unused or double-used"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Escape Analysis",
    "difficulty": 5,
    "description": "Implement escape analysis to determine stack vs heap allocation.",
    "starterCode": "class EscapeAnalyzer:\n    \"\"\"Analyze whether values escape their scope.\"\"\"\n\n    def analyze(self, func_ast):\n        \"\"\"\n        Analyze function and return which variables escape.\n        func_ast: ('func', params, body)\n        \"\"\"\n        pass",
    "solution": "class EscapeAnalyzer:\n    def __init__(self):\n        self.escaping = set()\n        self.returned = set()\n\n    def analyze(self, func_ast):\n        self.escaping = set()\n        self.returned = set()\n\n        if func_ast[0] != 'func':\n            return self.escaping\n\n        _, params, body = func_ast\n        self._analyze_expr(body, set(params))\n\n        return self.escaping\n\n    def _analyze_expr(self, expr, local_vars):\n        if isinstance(expr, str):\n            return\n\n        if not isinstance(expr, tuple):\n            return\n\n        tag = expr[0]\n\n        if tag == 'let':\n            _, var, init, body = expr\n            self._analyze_expr(init, local_vars)\n            self._analyze_expr(body, local_vars | {var})\n\n        elif tag == 'return':\n            _, ret_expr = expr\n            self._mark_escaping(ret_expr, local_vars)\n            self._analyze_expr(ret_expr, local_vars)\n\n        elif tag == 'store_global':\n            _, var = expr\n            if var in local_vars:\n                self.escaping.add(var)\n\n        elif tag == 'call':\n            # Arguments passed to functions might escape\n            for arg in expr[2:]:\n                if isinstance(arg, str) and arg in local_vars:\n                    self.escaping.add(arg)\n                self._analyze_expr(arg, local_vars)\n\n        elif tag == 'closure':\n            # Variables captured by closures escape\n            _, params, body, captured = expr\n            for var in captured:\n                if var in local_vars:\n                    self.escaping.add(var)\n\n        else:\n            for sub in expr[1:]:\n                self._analyze_expr(sub, local_vars)\n\n    def _mark_escaping(self, expr, local_vars):\n        if isinstance(expr, str):\n            if expr in local_vars:\n                self.escaping.add(expr)\n        elif isinstance(expr, tuple):\n            for sub in expr[1:]:\n                self._mark_escaping(sub, local_vars)\n\n    def can_stack_allocate(self, var):\n        return var not in self.escaping",
    "testCases": [
      {
        "input": "ea = EscapeAnalyzer(); ea.analyze(('func', ['x'], ('return', 'x'))); 'x' in ea.escaping",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "ea = EscapeAnalyzer(); ea.analyze(('func', ['x'], ('let', 'y', 'x', 'y'))); 'y' in ea.escaping",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Values escape if returned or stored globally",
      "Closure capture causes escape",
      "Non-escaping values can be stack allocated"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Weak References",
    "difficulty": 5,
    "description": "Implement weak references that dont prevent collection.",
    "starterCode": "class WeakRef:\n    \"\"\"Reference that doesn't prevent garbage collection.\"\"\"\n\n    def __init__(self, target_id, registry):\n        pass\n\n    def get(self):\n        \"\"\"Get target if still alive, else None.\"\"\"\n        pass\n\nclass GCWithWeakRefs:\n    \"\"\"GC supporting weak references.\"\"\"\n\n    def __init__(self, size):\n        pass\n\n    def allocate(self, value):\n        pass\n\n    def create_weak_ref(self, target_id):\n        pass\n\n    def collect(self, roots):\n        \"\"\"Collect, clearing weak refs to collected objects.\"\"\"\n        pass",
    "solution": "class WeakRef:\n    def __init__(self, target_id, registry):\n        self.target_id = target_id\n        self.registry = registry\n\n    def get(self):\n        if self.target_id in self.registry.alive:\n            return self.registry.heap[self.target_id]\n        return None\n\n    def is_valid(self):\n        return self.target_id in self.registry.alive\n\nclass GCWithWeakRefs:\n    def __init__(self, size):\n        self.heap = [None] * size\n        self.free_list = list(range(size))\n        self.weak_refs = []\n        self.alive = set()\n\n    def allocate(self, value):\n        if not self.free_list:\n            return -1\n        addr = self.free_list.pop(0)\n        self.heap[addr] = value\n        self.alive.add(addr)\n        return addr\n\n    def create_weak_ref(self, target_id):\n        weak = WeakRef(target_id, self)\n        self.weak_refs.append(weak)\n        return weak\n\n    def collect(self, roots):\n        # Mark phase (only strong refs)\n        marked = set()\n        worklist = list(roots)\n\n        while worklist:\n            addr = worklist.pop()\n            if addr < 0 or addr >= len(self.heap):\n                continue\n            if addr in marked:\n                continue\n            marked.add(addr)\n\n            obj = self.heap[addr]\n            if isinstance(obj, dict):\n                for v in obj.values():\n                    if isinstance(v, int):\n                        worklist.append(v)\n            elif isinstance(obj, list):\n                for v in obj:\n                    if isinstance(v, int):\n                        worklist.append(v)\n\n        # Sweep phase\n        freed = 0\n        for addr in range(len(self.heap)):\n            if addr not in marked and self.heap[addr] is not None:\n                self.heap[addr] = None\n                self.alive.discard(addr)\n                self.free_list.append(addr)\n                freed += 1\n\n        return freed",
    "testCases": [
      {
        "input": "gc = GCWithWeakRefs(10); a = gc.allocate(42); w = gc.create_weak_ref(a); w.get()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = GCWithWeakRefs(10); a = gc.allocate(42); w = gc.create_weak_ref(a); gc.collect([]); w.get()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Weak refs dont keep objects alive",
      "Check validity before returning target",
      "Clear weak refs during collection"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Incremental GC",
    "difficulty": 5,
    "description": "Implement incremental garbage collection.",
    "starterCode": "class IncrementalGC:\n    \"\"\"Garbage collector with incremental marking.\"\"\"\n\n    def __init__(self, size):\n        pass\n\n    def allocate(self, value):\n        pass\n\n    def step(self, work_limit=10):\n        \"\"\"Do limited GC work, return True if complete.\"\"\"\n        pass\n\n    def start_collection(self, roots):\n        \"\"\"Start a new collection cycle.\"\"\"\n        pass",
    "solution": "class IncrementalGC:\n    def __init__(self, size):\n        self.heap = [None] * size\n        self.free_list = list(range(size))\n        self.marked = set()\n        self.worklist = []\n        self.collecting = False\n        self.roots = []\n\n    def allocate(self, value):\n        if not self.free_list:\n            return -1\n        addr = self.free_list.pop(0)\n        self.heap[addr] = value\n        # If allocating during collection, mark as gray\n        if self.collecting:\n            self.worklist.append(addr)\n        return addr\n\n    def start_collection(self, roots):\n        self.marked = set()\n        self.worklist = list(roots)\n        self.roots = roots\n        self.collecting = True\n\n    def step(self, work_limit=10):\n        if not self.collecting:\n            return True\n\n        work_done = 0\n\n        # Mark phase\n        while self.worklist and work_done < work_limit:\n            addr = self.worklist.pop()\n            if addr < 0 or addr >= len(self.heap):\n                continue\n            if addr in self.marked:\n                continue\n\n            self.marked.add(addr)\n            work_done += 1\n\n            obj = self.heap[addr]\n            if isinstance(obj, dict):\n                for v in obj.values():\n                    if isinstance(v, int) and v not in self.marked:\n                        self.worklist.append(v)\n            elif isinstance(obj, list):\n                for v in obj:\n                    if isinstance(v, int) and v not in self.marked:\n                        self.worklist.append(v)\n\n        # If marking complete, do sweep\n        if not self.worklist:\n            for addr in range(len(self.heap)):\n                if addr not in self.marked and self.heap[addr] is not None:\n                    self.heap[addr] = None\n                    self.free_list.append(addr)\n            self.collecting = False\n            return True\n\n        return False\n\n    def is_collecting(self):\n        return self.collecting",
    "testCases": [
      {
        "input": "gc = IncrementalGC(10); gc.allocate(1); gc.allocate(2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = IncrementalGC(10); gc.allocate(1); gc.start_collection([]); gc.step(100)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Do limited work per step",
      "Maintain worklist between steps",
      "Handle allocations during collection"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Write Barrier",
    "difficulty": 5,
    "description": "Implement write barriers for concurrent GC.",
    "starterCode": "class WriteBarrierGC:\n    \"\"\"GC with write barriers for correctness.\"\"\"\n\n    def __init__(self, size):\n        pass\n\n    def write(self, obj_addr, field, value):\n        \"\"\"Write with barrier.\"\"\"\n        pass\n\n    def snapshot_at_beginning(self, old_value, new_value):\n        \"\"\"SATB write barrier.\"\"\"\n        pass\n\n    def incremental_update(self, obj_addr, new_ref):\n        \"\"\"Incremental update barrier.\"\"\"\n        pass",
    "solution": "class WriteBarrierGC:\n    def __init__(self, size):\n        self.heap = [None] * size\n        self.free_list = list(range(size))\n        self.marked = set()\n        self.gray_set = set()\n        self.collecting = False\n        self.satb_queue = []\n\n    def allocate(self, value):\n        if not self.free_list:\n            return -1\n        addr = self.free_list.pop(0)\n        self.heap[addr] = value\n        return addr\n\n    def write(self, obj_addr, field, value):\n        obj = self.heap[obj_addr]\n        if obj is None or not isinstance(obj, dict):\n            return\n\n        old_value = obj.get(field)\n\n        # Apply write barrier\n        if self.collecting:\n            self.snapshot_at_beginning(old_value, value)\n            self.incremental_update(obj_addr, value)\n\n        obj[field] = value\n\n    def snapshot_at_beginning(self, old_value, new_value):\n        # Remember old references that might be overwritten\n        if isinstance(old_value, int) and old_value >= 0:\n            if old_value not in self.marked:\n                self.satb_queue.append(old_value)\n\n    def incremental_update(self, obj_addr, new_ref):\n        # If writing a reference to a black object, mark target gray\n        if obj_addr in self.marked and isinstance(new_ref, int):\n            if new_ref >= 0 and new_ref not in self.marked:\n                self.gray_set.add(new_ref)\n\n    def start_collection(self, roots):\n        self.marked = set()\n        self.gray_set = set(roots)\n        self.collecting = True\n        self.satb_queue = []\n\n    def step(self):\n        if not self.collecting:\n            return True\n\n        # Process gray objects\n        while self.gray_set:\n            addr = self.gray_set.pop()\n            if addr in self.marked:\n                continue\n            self.marked.add(addr)\n\n            obj = self.heap[addr]\n            if isinstance(obj, dict):\n                for v in obj.values():\n                    if isinstance(v, int) and v not in self.marked:\n                        self.gray_set.add(v)\n\n        # Process SATB queue\n        while self.satb_queue:\n            addr = self.satb_queue.pop()\n            if addr not in self.marked:\n                self.gray_set.add(addr)\n\n        if not self.gray_set and not self.satb_queue:\n            self.collecting = False\n            return True\n\n        return False",
    "testCases": [
      {
        "input": "gc = WriteBarrierGC(10); gc.allocate({\"a\": 1})",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "gc = WriteBarrierGC(10); a = gc.allocate({\"ref\": -1}); gc.write(a, \"ref\", 5); gc.heap[a][\"ref\"]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Write barriers track reference changes",
      "SATB preserves snapshot of graph",
      "Incremental update re-marks affected objects"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-6-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Memory Profiler",
    "difficulty": 5,
    "description": "Implement a memory profiler tracking allocations.",
    "starterCode": "class MemoryProfiler:\n    \"\"\"Track memory allocations and find leaks.\"\"\"\n\n    def __init__(self):\n        pass\n\n    def record_allocation(self, addr, size, stack_trace):\n        pass\n\n    def record_free(self, addr):\n        pass\n\n    def get_live_allocations(self):\n        pass\n\n    def find_leaks(self, known_roots):\n        pass",
    "solution": "import time\n\nclass MemoryProfiler:\n    def __init__(self):\n        self.allocations = {}\n        self.freed = set()\n        self.total_allocated = 0\n        self.total_freed = 0\n\n    def record_allocation(self, addr, size, stack_trace):\n        self.allocations[addr] = {\n            'size': size,\n            'stack_trace': stack_trace,\n            'time': time.time(),\n            'freed': False\n        }\n        self.total_allocated += size\n\n    def record_free(self, addr):\n        if addr in self.allocations and not self.allocations[addr]['freed']:\n            self.allocations[addr]['freed'] = True\n            self.freed.add(addr)\n            self.total_freed += self.allocations[addr]['size']\n\n    def get_live_allocations(self):\n        return {\n            addr: info\n            for addr, info in self.allocations.items()\n            if not info['freed']\n        }\n\n    def find_leaks(self, known_roots):\n        live = self.get_live_allocations()\n        leaks = []\n\n        for addr, info in live.items():\n            if addr not in known_roots:\n                leaks.append({\n                    'addr': addr,\n                    'size': info['size'],\n                    'stack_trace': info['stack_trace'],\n                    'age': time.time() - info['time']\n                })\n\n        return sorted(leaks, key=lambda x: x['size'], reverse=True)\n\n    def get_stats(self):\n        live = self.get_live_allocations()\n        return {\n            'total_allocated': self.total_allocated,\n            'total_freed': self.total_freed,\n            'current_usage': self.total_allocated - self.total_freed,\n            'num_live': len(live),\n            'num_freed': len(self.freed)\n        }\n\n    def get_allocation_by_stack(self):\n        by_stack = {}\n        for addr, info in self.get_live_allocations().items():\n            trace = tuple(info['stack_trace'])\n            if trace not in by_stack:\n                by_stack[trace] = {'count': 0, 'total_size': 0}\n            by_stack[trace]['count'] += 1\n            by_stack[trace]['total_size'] += info['size']\n        return by_stack",
    "testCases": [
      {
        "input": "mp = MemoryProfiler(); mp.record_allocation(0, 100, [\"main\"]); mp.get_stats()[\"current_usage\"]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "mp = MemoryProfiler(); mp.record_allocation(0, 100, [\"main\"]); mp.record_free(0); mp.get_stats()[\"current_usage\"]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "mp = MemoryProfiler(); mp.record_allocation(0, 100, [\"main\"]); len(mp.find_leaks([]))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Track allocation with metadata",
      "Compare live allocations against roots",
      "Group by stack trace to find sources"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "First-Class Functions",
    "difficulty": 1,
    "description": "Work with functions as first-class values.",
    "starterCode": "def apply_twice(f, x):\n    \"\"\"Apply function f to x twice.\"\"\"\n    pass\n\ndef make_adder(n):\n    \"\"\"Return a function that adds n to its argument.\"\"\"\n    pass\n\ndef compose(f, g):\n    \"\"\"Return composition f(g(x)).\"\"\"\n    pass",
    "solution": "def apply_twice(f, x):\n    return f(f(x))\n\ndef make_adder(n):\n    return lambda x: x + n\n\ndef compose(f, g):\n    return lambda x: f(g(x))",
    "testCases": [
      {
        "input": "apply_twice(lambda x: x * 2, 3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "make_adder(5)(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(lambda x: x + 1, lambda x: x * 2)(3)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functions can be passed as arguments",
      "Functions can be returned from functions",
      "Use lambda for anonymous functions"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Closures",
    "difficulty": 1,
    "description": "Implement and use closures.",
    "starterCode": "def make_counter():\n    \"\"\"Return a counter function that increments each call.\"\"\"\n    pass\n\ndef make_password_checker(password):\n    \"\"\"Return a function that checks if input matches password.\"\"\"\n    pass",
    "solution": "def make_counter():\n    count = 0\n    def counter():\n        nonlocal count\n        count += 1\n        return count\n    return counter\n\ndef make_password_checker(password):\n    attempts = 0\n    def check(guess):\n        nonlocal attempts\n        attempts += 1\n        return guess == password\n    return check",
    "testCases": [
      {
        "input": "c = make_counter(); [c(), c(), c()]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "checker = make_password_checker(\"secret\"); checker(\"wrong\")",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "checker = make_password_checker(\"secret\"); checker(\"secret\")",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Closures capture variables from enclosing scope",
      "Use nonlocal to modify captured variables",
      "Each call to make_counter creates new closure"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Decorators",
    "difficulty": 1,
    "description": "Implement function decorators.",
    "starterCode": "def trace(func):\n    \"\"\"Decorator that prints function calls.\"\"\"\n    pass\n\ndef memoize(func):\n    \"\"\"Decorator that caches results.\"\"\"\n    pass\n\ndef retry(times):\n    \"\"\"Decorator factory for retrying failed functions.\"\"\"\n    pass",
    "solution": "def trace(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__} with {args}, {kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"Returned {result}\")\n        return result\n    return wrapper\n\ndef memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrapper\n\ndef retry(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            last_error = None\n            for _ in range(times):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_error = e\n            raise last_error\n        return wrapper\n    return decorator",
    "testCases": [
      {
        "input": "@memoize\\ndef fib(n): return n if n<=1 else fib(n-1)+fib(n-2)\\nfib(30)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "@retry(3)\\ndef fail(): raise ValueError()\\ntry:\\n  fail()\\nexcept: pass",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Decorators wrap functions",
      "Decorator factories return decorators",
      "Use *args and **kwargs for flexibility"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Generators and Iterators",
    "difficulty": 3,
    "description": "Implement custom generators and iterators.",
    "starterCode": "def infinite_sequence(start=0):\n    \"\"\"Generate infinite sequence of integers.\"\"\"\n    pass\n\nclass Range:\n    \"\"\"Custom range iterator.\"\"\"\n    def __init__(self, start, stop, step=1):\n        pass\n\n    def __iter__(self):\n        pass\n\n    def __next__(self):\n        pass",
    "solution": "def infinite_sequence(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1\n\nclass Range:\n    def __init__(self, start, stop, step=1):\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.current = start\n\n    def __iter__(self):\n        self.current = self.start\n        return self\n\n    def __next__(self):\n        if (self.step > 0 and self.current >= self.stop) or \\\n           (self.step < 0 and self.current <= self.stop):\n            raise StopIteration\n        value = self.current\n        self.current += self.step\n        return value",
    "testCases": [
      {
        "input": "gen = infinite_sequence(); [next(gen) for _ in range(5)]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list(Range(0, 5))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list(Range(10, 0, -2))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "yield pauses generator and returns value",
      "__iter__ returns iterator",
      "__next__ returns next value or raises StopIteration"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Context Managers",
    "difficulty": 3,
    "description": "Implement context managers for resource management.",
    "starterCode": "class Timer:\n    \"\"\"Context manager that measures execution time.\"\"\"\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\nfrom contextlib import contextmanager\n\n@contextmanager\ndef suppress_exceptions(*exceptions):\n    \"\"\"Suppress specified exception types.\"\"\"\n    pass",
    "solution": "import time\n\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.end = time.time()\n        self.elapsed = self.end - self.start\n        return False  # Don't suppress exceptions\n\nfrom contextlib import contextmanager\n\n@contextmanager\ndef suppress_exceptions(*exceptions):\n    try:\n        yield\n    except exceptions:\n        pass",
    "testCases": [
      {
        "input": "with Timer() as t: pass; t.elapsed >= 0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "with suppress_exceptions(ValueError): raise ValueError(); True",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "__enter__ sets up context",
      "__exit__ cleans up and handles exceptions",
      "@contextmanager simplifies implementation"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Coroutines",
    "difficulty": 3,
    "description": "Implement coroutines using generators.",
    "starterCode": "def averager():\n    \"\"\"Coroutine that computes running average.\"\"\"\n    pass\n\ndef grep(pattern):\n    \"\"\"Coroutine that filters lines matching pattern.\"\"\"\n    pass",
    "solution": "def averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        value = yield average\n        if value is None:\n            break\n        total += value\n        count += 1\n        average = total / count\n\ndef grep(pattern):\n    while True:\n        line = yield\n        if line is None:\n            break\n        if pattern in line:\n            print(f\"Match: {line}\")",
    "testCases": [
      {
        "input": "avg = averager(); next(avg); avg.send(10); avg.send(20); avg.send(30)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Coroutines receive values via send()",
      "yield both receives and produces values",
      "Prime coroutine with next() before send()"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Async/Await",
    "difficulty": 3,
    "description": "Implement asynchronous functions with async/await.",
    "starterCode": "import asyncio\n\nasync def fetch_data(url, delay):\n    \"\"\"Simulate async data fetch.\"\"\"\n    pass\n\nasync def fetch_all(urls):\n    \"\"\"Fetch all URLs concurrently.\"\"\"\n    pass",
    "solution": "import asyncio\n\nasync def fetch_data(url, delay):\n    await asyncio.sleep(delay)\n    return f\"Data from {url}\"\n\nasync def fetch_all(urls):\n    tasks = [fetch_data(url, 0.1) for url in urls]\n    return await asyncio.gather(*tasks)",
    "testCases": [
      {
        "input": "asyncio.run(fetch_data(\"http://example.com\", 0))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "async def creates coroutine function",
      "await suspends until awaitable completes",
      "asyncio.gather runs tasks concurrently"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Metaclasses",
    "difficulty": 5,
    "description": "Use metaclasses to customize class creation.",
    "starterCode": "class SingletonMeta(type):\n    \"\"\"Metaclass that creates singleton classes.\"\"\"\n    pass\n\nclass RegisteredMeta(type):\n    \"\"\"Metaclass that registers all subclasses.\"\"\"\n    pass",
    "solution": "class SingletonMeta(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass RegisteredMeta(type):\n    registry = {}\n\n    def __new__(mcs, name, bases, namespace):\n        cls = super().__new__(mcs, name, bases, namespace)\n        mcs.registry[name] = cls\n        return cls\n\n    @classmethod\n    def get_registered(mcs):\n        return dict(mcs.registry)",
    "testCases": [
      {
        "input": "class S(metaclass=SingletonMeta): pass\\nS() is S()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "class R(metaclass=RegisteredMeta): pass\\n\"R\" in RegisteredMeta.registry",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Metaclass controls class creation",
      "__call__ intercepts instantiation",
      "__new__ creates class object"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Descriptors",
    "difficulty": 5,
    "description": "Implement descriptors for attribute access.",
    "starterCode": "class Validated:\n    \"\"\"Descriptor with validation.\"\"\"\n\n    def __init__(self, validator):\n        pass\n\n    def __get__(self, obj, objtype=None):\n        pass\n\n    def __set__(self, obj, value):\n        pass\n\nclass Lazy:\n    \"\"\"Descriptor for lazy computation.\"\"\"\n\n    def __init__(self, func):\n        pass\n\n    def __get__(self, obj, objtype=None):\n        pass",
    "solution": "class Validated:\n    def __init__(self, validator, name=None):\n        self.validator = validator\n        self.name = name\n\n    def __set_name__(self, owner, name):\n        self.name = name\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return obj.__dict__.get(self.name)\n\n    def __set__(self, obj, value):\n        if not self.validator(value):\n            raise ValueError(f\"Invalid value for {self.name}: {value}\")\n        obj.__dict__[self.name] = value\n\nclass Lazy:\n    def __init__(self, func):\n        self.func = func\n        self.name = None\n\n    def __set_name__(self, owner, name):\n        self.name = name\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.name not in obj.__dict__:\n            obj.__dict__[self.name] = self.func(obj)\n        return obj.__dict__[self.name]",
    "testCases": [
      {
        "input": "class C:\\n  x = Validated(lambda v: v > 0)\\nc = C(); c.x = 5; c.x",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Descriptors customize attribute access",
      "__get__ for reading, __set__ for writing",
      "__set_name__ provides attribute name"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Pattern Matching",
    "difficulty": 5,
    "description": "Implement structural pattern matching.",
    "starterCode": "def match(value, *cases):\n    \"\"\"\n    Match value against patterns.\n    Each case is (pattern, handler).\n    \"\"\"\n    pass\n\ndef pattern_var(name):\n    \"\"\"Create a variable pattern.\"\"\"\n    pass\n\ndef pattern_tuple(*patterns):\n    \"\"\"Create a tuple pattern.\"\"\"\n    pass",
    "solution": "class PatternVar:\n    def __init__(self, name):\n        self.name = name\n\ndef pattern_var(name):\n    return PatternVar(name)\n\ndef pattern_tuple(*patterns):\n    return ('tuple', patterns)\n\ndef match_pattern(pattern, value, bindings=None):\n    if bindings is None:\n        bindings = {}\n\n    if isinstance(pattern, PatternVar):\n        bindings[pattern.name] = value\n        return bindings\n\n    if pattern == '_':\n        return bindings\n\n    if isinstance(pattern, tuple) and pattern[0] == 'tuple':\n        if not isinstance(value, tuple):\n            return None\n        patterns = pattern[1]\n        if len(patterns) != len(value):\n            return None\n        for p, v in zip(patterns, value):\n            result = match_pattern(p, v, bindings)\n            if result is None:\n                return None\n        return bindings\n\n    if pattern == value:\n        return bindings\n\n    return None\n\ndef match(value, *cases):\n    for pattern, handler in cases:\n        bindings = match_pattern(pattern, value)\n        if bindings is not None:\n            if callable(handler):\n                return handler(**bindings)\n            return handler\n    raise ValueError(f\"No pattern matched: {value}\")",
    "testCases": [
      {
        "input": "match(5, (5, \"five\"), (pattern_var(\"x\"), lambda x: x*2))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "match((1, 2), (pattern_tuple(pattern_var(\"a\"), pattern_var(\"b\")), lambda a, b: a+b))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Try patterns in order",
      "Bind variables during matching",
      "Return None for failed match"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Macro System",
    "difficulty": 5,
    "description": "Implement a simple macro system.",
    "starterCode": "class MacroExpander:\n    \"\"\"Expand macros in code.\"\"\"\n\n    def __init__(self):\n        self.macros = {}\n\n    def define_macro(self, name, transformer):\n        pass\n\n    def expand(self, expr):\n        pass",
    "solution": "class MacroExpander:\n    def __init__(self):\n        self.macros = {}\n\n    def define_macro(self, name, transformer):\n        self.macros[name] = transformer\n\n    def expand(self, expr):\n        if isinstance(expr, (int, float, str, bool)):\n            return expr\n\n        if isinstance(expr, tuple) and len(expr) > 0:\n            head = expr[0]\n            if head in self.macros:\n                transformed = self.macros[head](expr)\n                return self.expand(transformed)\n            return tuple(self.expand(e) for e in expr)\n\n        if isinstance(expr, list):\n            return [self.expand(e) for e in expr]\n\n        return expr\n\n# Example macros\ndef unless_macro(expr):\n    _, cond, then_expr = expr\n    return ('if', ('not', cond), then_expr, None)\n\ndef when_macro(expr):\n    _, cond, *body = expr\n    return ('if', cond, ('begin', *body), None)\n\ndef let_star_macro(expr):\n    _, bindings, body = expr\n    if not bindings:\n        return body\n    first = bindings[0]\n    rest = bindings[1:]\n    return ('let', [first], ('let*', rest, body) if rest else body)",
    "testCases": [
      {
        "input": "me = MacroExpander(); me.define_macro(\"unless\", unless_macro); me.expand((\"unless\", True, \"x\"))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Macros transform syntax",
      "Expand recursively after transformation",
      "Check for macro name at head of expression"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Type Classes",
    "difficulty": 5,
    "description": "Implement type class dispatch in Python.",
    "starterCode": "class TypeClass:\n    \"\"\"Base for type class definitions.\"\"\"\n\n    _instances = {}\n\n    @classmethod\n    def register(cls, type_arg, instance):\n        pass\n\n    @classmethod\n    def dispatch(cls, value):\n        pass",
    "solution": "class TypeClass:\n    _instances = {}\n\n    @classmethod\n    def register(cls, type_arg, instance):\n        if cls not in cls._instances:\n            cls._instances[cls] = {}\n        cls._instances[cls][type_arg] = instance\n\n    @classmethod\n    def dispatch(cls, value):\n        type_map = cls._instances.get(cls, {})\n        for t, instance in type_map.items():\n            if isinstance(value, t):\n                return instance\n        raise TypeError(f\"No instance for {type(value)}\")\n\nclass Show(TypeClass):\n    @classmethod\n    def show(cls, value):\n        instance = cls.dispatch(value)\n        return instance.show(value)\n\nclass IntShow:\n    def show(self, value):\n        return f\"Int({value})\"\n\nclass StrShow:\n    def show(self, value):\n        return f'Str(\"{value}\")'\n\nShow.register(int, IntShow())\nShow.register(str, StrShow())",
    "testCases": [
      {
        "input": "Show.show(42)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Show.show(\"hello\")",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Type classes provide ad-hoc polymorphism",
      "Dispatch based on value type",
      "Register instances for each type"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Delimited Continuations",
    "difficulty": 5,
    "description": "Implement delimited continuations.",
    "starterCode": "class Prompt:\n    \"\"\"Delimits continuation capture.\"\"\"\n    pass\n\nclass Shift:\n    \"\"\"Captures continuation up to prompt.\"\"\"\n    def __init__(self, handler):\n        self.handler = handler\n\ndef reset(thunk):\n    \"\"\"Delimit continuation.\"\"\"\n    pass\n\ndef shift(handler):\n    \"\"\"Capture current continuation.\"\"\"\n    pass",
    "solution": "class Prompt(Exception):\n    def __init__(self, value):\n        self.value = value\n\nclass Shift(Exception):\n    def __init__(self, handler):\n        self.handler = handler\n\ndef reset(thunk):\n    try:\n        return thunk()\n    except Shift as s:\n        def continuation(value):\n            return reset(lambda: value)\n        return s.handler(continuation)\n\ndef shift(handler):\n    raise Shift(handler)\n\n# Example: non-deterministic choice\ndef amb(choices):\n    def handler(k):\n        results = []\n        for choice in choices:\n            results.append(k(choice))\n        return results\n    return shift(handler)\n\n# Example: state\ndef get_state():\n    return shift(lambda k: lambda s: k(s)(s))\n\ndef put_state(new_state):\n    return shift(lambda k: lambda s: k(None)(new_state))\n\ndef run_state(thunk, initial):\n    return reset(thunk)(initial)",
    "testCases": [
      {
        "input": "reset(lambda: 1 + shift(lambda k: k(5)))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "reset(lambda: shift(lambda k: k(k(1))))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Delimited continuations capture partial computation",
      "reset delimits the captured continuation",
      "shift captures continuation up to enclosing reset"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Effect System",
    "difficulty": 5,
    "description": "Implement an effect system for tracking side effects.",
    "starterCode": "class Effect:\n    \"\"\"Base class for effects.\"\"\"\n    pass\n\nclass Reader(Effect):\n    \"\"\"Read from environment effect.\"\"\"\n    pass\n\nclass State(Effect):\n    \"\"\"Stateful computation effect.\"\"\"\n    pass\n\nclass EffectfulComputation:\n    \"\"\"Computation with tracked effects.\"\"\"\n\n    def __init__(self, func, effects):\n        pass\n\n    def run(self, handlers):\n        pass",
    "solution": "class Effect:\n    pass\n\nclass Reader(Effect):\n    @staticmethod\n    def ask():\n        return ('effect', 'reader', 'ask')\n\nclass State(Effect):\n    @staticmethod\n    def get():\n        return ('effect', 'state', 'get')\n\n    @staticmethod\n    def put(value):\n        return ('effect', 'state', 'put', value)\n\nclass EffectfulComputation:\n    def __init__(self, func, effects=None):\n        self.func = func\n        self.effects = effects or set()\n\n    def run(self, handlers):\n        def handle_effects(value):\n            if isinstance(value, tuple) and value[0] == 'effect':\n                effect_type = value[1]\n                operation = value[2]\n                if effect_type in handlers:\n                    return handlers[effect_type](operation, value[3:] if len(value) > 3 else ())\n                raise ValueError(f\"Unhandled effect: {effect_type}\")\n            return value\n\n        return self.func(handle_effects)\n\n    def map(self, f):\n        def new_func(handle):\n            result = self.func(handle)\n            return f(result)\n        return EffectfulComputation(new_func, self.effects)\n\n    def flat_map(self, f):\n        def new_func(handle):\n            result = self.func(handle)\n            return f(result).func(handle)\n        combined_effects = self.effects\n        return EffectfulComputation(new_func, combined_effects)",
    "testCases": [
      {
        "input": "ec = EffectfulComputation(lambda h: h(Reader.ask()), {\"reader\"}); ec.run({\"reader\": lambda op, args: 42})",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Effects are typed operations",
      "Handlers interpret effects",
      "Track which effects computation uses"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Multimethods",
    "difficulty": 5,
    "description": "Implement multiple dispatch.",
    "starterCode": "class MultiMethod:\n    \"\"\"Function with multiple dispatch based on argument types.\"\"\"\n\n    def __init__(self, name):\n        pass\n\n    def register(self, *types):\n        \"\"\"Decorator to register implementation for types.\"\"\"\n        pass\n\n    def __call__(self, *args):\n        pass",
    "solution": "class MultiMethod:\n    def __init__(self, name):\n        self.name = name\n        self.implementations = {}\n\n    def register(self, *types):\n        def decorator(func):\n            self.implementations[types] = func\n            return func\n        return decorator\n\n    def __call__(self, *args):\n        types = tuple(type(arg) for arg in args)\n\n        # Exact match\n        if types in self.implementations:\n            return self.implementations[types](*args)\n\n        # Try with inheritance\n        for registered_types, func in self.implementations.items():\n            if len(registered_types) == len(types):\n                if all(issubclass(actual, expected)\n                       for actual, expected in zip(types, registered_types)):\n                    return func(*args)\n\n        raise TypeError(f\"No implementation for {self.name} with types {types}\")\n\n# Example usage\nadd = MultiMethod('add')\n\n@add.register(int, int)\ndef add_int(a, b):\n    return a + b\n\n@add.register(str, str)\ndef add_str(a, b):\n    return a + b\n\n@add.register(list, list)\ndef add_list(a, b):\n    return a + b",
    "testCases": [
      {
        "input": "add(1, 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "add(\"a\", \"b\")",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "add([1], [2])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Dispatch on types of all arguments",
      "Try exact match first",
      "Fall back to inheritance-based match"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-7-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-7",
    "title": "Object Capabilities",
    "difficulty": 5,
    "description": "Implement object-capability security.",
    "starterCode": "class Capability:\n    \"\"\"A capability granting specific access.\"\"\"\n\n    def __init__(self, permissions):\n        pass\n\n    def can(self, permission):\n        pass\n\n    def attenuate(self, *permissions):\n        \"\"\"Create restricted capability.\"\"\"\n        pass\n\nclass SecureObject:\n    \"\"\"Object accessed only through capabilities.\"\"\"\n\n    def __init__(self, value):\n        pass\n\n    def read(self, cap):\n        pass\n\n    def write(self, cap, value):\n        pass",
    "solution": "class Capability:\n    def __init__(self, permissions):\n        self.permissions = frozenset(permissions)\n\n    def can(self, permission):\n        return permission in self.permissions\n\n    def attenuate(self, *permissions):\n        new_perms = self.permissions & set(permissions)\n        return Capability(new_perms)\n\n    def combine(self, other):\n        return Capability(self.permissions | other.permissions)\n\nclass SecureObject:\n    def __init__(self, value):\n        self._value = value\n\n    def read(self, cap):\n        if not cap.can('read'):\n            raise PermissionError(\"No read permission\")\n        return self._value\n\n    def write(self, cap, value):\n        if not cap.can('write'):\n            raise PermissionError(\"No write permission\")\n        self._value = value\n\n    def get_full_cap(self):\n        return Capability(['read', 'write', 'delete'])\n\n    def get_readonly_cap(self):\n        return Capability(['read'])",
    "testCases": [
      {
        "input": "cap = Capability([\"read\", \"write\"]); cap.can(\"read\")",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "cap = Capability([\"read\", \"write\"]); cap.attenuate(\"read\").can(\"write\")",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "obj = SecureObject(42); obj.read(obj.get_readonly_cap())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Capabilities are unforgeable permissions",
      "Attenuation reduces permissions",
      "Access requires appropriate capability"
    ],
    "language": "python"
  }
]
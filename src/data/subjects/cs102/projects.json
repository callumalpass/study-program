[
  {
    "id": "cs102-project-3",
    "subjectId": "cs102",
    "title": "The Binary Bomb Defusal",
    "description": "You have been given a binary executable (simulated in Python/Assembly) that acts as a \"digital bomb\". It expects a series of specific inputs (passwords) to be \"defused\". If you enter the wrong input, it \"explodes\". Your job is to read the assembly-like instructions of the bomb's code, reverse engineer the logic, and figure out the correct inputs. This project tests your ability to read low-level control flow, understand registers, and trace execution mentally.",
    "requirements": [
      "Create a \"Virtual CPU\" class that can execute a simplified assembly language (MOV, ADD, SUB, CMP, JMP, BEQ, BNE, XOR)",
      "Design a \"Bomb\" program written in this assembly language with at least 4 distinct \"stages\"",
      "Stage 1: Simple string password check",
      "Stage 2: Loop-based arithmetic check (e.g., input must be a Fibonacci number)",
      "Stage 3: Switch/Jump table logic (input determines path)",
      "Stage 4: Recursive function logic or complex pointer arithmetic simulation",
      "Build a debugger interface that allows users (students) to: Step through instructions, Inspect registers, View memory",
      "Implement a \"cheat mode\" (for grading) that reveals the answers",
      "Provide a \"Bomb Manual\" (README) explaining the CPU architecture"
    ],
    "rubric": [
      {
        "name": "CPU Simulation",
        "weight": 35,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Accurately simulates all required opcodes, registers, and flags. Handles jumps correctly."
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Most opcodes work. Jumps mostly correct. Minor bugs in flag handling."
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Basic sequential execution works. Jumps or flags are unreliable."
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "CPU cannot run the bomb program correctly."
          }
        ]
      },
      {
        "name": "Bomb Design",
        "weight": 25,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "4 creative, distinct stages. Logic is challenging but solvable. Clever use of assembly idioms."
          },
          {
            "score": 3,
            "label": "Good",
            "description": "4 stages present. Some repetition in logic. Solvable."
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Fewer than 4 stages or logic is trivial/broken."
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Bomb program is missing or non-functional."
          }
        ]
      },
      {
        "name": "Debugger Tools",
        "weight": 25,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Full stepping, breakpoints, and clear register/memory visualization. Feels like GDB."
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Step and inspect features present. UI is usable."
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Can run code but hard to inspect state. Minimal feedback."
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "No debugging tools provided."
          }
        ]
      },
      {
        "name": "Documentation",
        "weight": 15,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Complete ISA reference, clear usage guide, and well-commented code."
          },
          {
            "score": 3,
            "label": "Good",
            "description": "ISA reference present. Basic usage guide."
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Minimal documentation. Hard to understand how to play."
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "No documentation."
          }
        ]
      }
    ],
    "estimatedHours": 20,
    "scaffolding": {
      "overview": "Approach it like a lab: trace, document phases, script inputs; keep a notes file as you go.",
      "gettingStarted": [
        "Set up a disassembly/trace loop that logs registers and branches per step.",
        "Identify input phases and expected lengths/types for each.",
        "Create a scratchpad for mapping registers/variables to semantic names."
      ],
      "milestones": [
        "Can step through one phase and predict register changes.",
        "Recover the required input for the first two phases.",
        "Document patterns (loops, arithmetic, comparisons) for later phases.",
        "Automate running all found inputs to verify no “explosions.”",
        "Write a concise walkthrough explaining how each input is derived."
      ],
      "starterResources": [
        {
          "label": "Trace template",
          "description": "Table columns: pc, instr, r0..r5 (or eax..), notes/outcome."
        },
        {
          "label": "Phase checklist",
          "description": "Length/type guesses, branch conditions, constants spotted."
        }
      ],
      "tips": [
        "Look for magic constants or string compares to anchor your reasoning.",
        "Rename registers/slots once you infer meaning to reduce cognitive load.",
        "Automate verification early so you can iterate without manual typing."
      ]
    }
  }
]
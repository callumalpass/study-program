[
  {
    "id": "cs201-ex-1-1",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Constant Time Access",
    "description": "Write a function `get_first_element(arr)` that returns the first element of an array. This operation should be O(1).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def get_first_element(arr):\n    # Your code here\n    pass",
    "solution": "def get_first_element(arr):\n    if not arr:\n        return None\n    return arr[0]",
    "testCases": [
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "First element of integer list"
      },
      {
        "input": "[\"a\", \"b\"]",
        "expectedOutput": "\"a\"",
        "isHidden": false,
        "description": "First element of string list"
      },
      {
        "input": "[]",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Index 0 is the first element.",
      "Check if array is empty first."
    ]
  },
  {
    "id": "cs201-ex-1-2",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Linear Sum",
    "description": "Write a function `sum_array(arr)` that returns the sum of all elements. This requires visiting every element, making it O(n).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def sum_array(arr):\n    pass",
    "solution": "def sum_array(arr):\n    total = 0\n    for x in arr:\n        total += x\n    return total",
    "testCases": [
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Sum of positive integers"
      },
      {
        "input": "[-1, 1]",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Sum cancelling out"
      },
      {
        "input": "[]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Sum of empty list"
      }
    ],
    "hints": [
      "Initialize a accumulator variable to 0.",
      "Loop through the array adding each element."
    ]
  },
  {
    "id": "cs201-ex-1-3",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Linear Search",
    "description": "Write `contains(arr, target)` that returns True if target is in arr, False otherwise. Worst case is O(n).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def contains(arr, target):\n    pass",
    "solution": "def contains(arr, target):\n    for x in arr:\n        if x == target:\n            return True\n    return False",
    "testCases": [
      {
        "input": "[1, 2, 3], 2",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Target exists"
      },
      {
        "input": "[1, 2, 3], 4",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Target does not exist"
      },
      {
        "input": "[], 1",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Iterate and compare.",
      "Return True immediately if found."
    ]
  },
  {
    "id": "cs201-ex-1-4",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Count Pairs",
    "description": "Write `count_pairs(arr)` that returns the number of pairs (i, j) such that i < j. This requires a nested loop, O(n^2).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def count_pairs(arr):\n    pass",
    "solution": "def count_pairs(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            count += 1\n    return count",
    "testCases": [
      {
        "input": "[1, 2]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Two elements"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Three elements"
      },
      {
        "input": "[]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Outer loop i from 0 to n.",
      "Inner loop j from i+1 to n."
    ]
  },
  {
    "id": "cs201-ex-1-5",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Matrix Addition",
    "description": "Add two NxN matrices. Requires visiting every element in the NxN grid, so O(N^2) relative to dimension N (or O(n) relative to total elements).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def add_matrices(mat1, mat2):\n    # Assume mat1 and mat2 are same size square matrices\n    pass",
    "solution": "def add_matrices(mat1, mat2):\n    n = len(mat1)\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = mat1[i][j] + mat2[i][j]\n    return result",
    "testCases": [
      {
        "input": "[[1,2],[3,4]], [[1,1],[1,1]]",
        "expectedOutput": "[[2, 3], [4, 5]]",
        "isHidden": false,
        "description": "2x2 matrix addition"
      },
      {
        "input": "[[1]], [[2]]",
        "expectedOutput": "[[3]]",
        "isHidden": false,
        "description": "1x1 matrix addition"
      }
    ],
    "hints": [
      "Use nested loops for row and column.",
      "Create a new result matrix."
    ]
  },
  {
    "id": "cs201-ex-1-6",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Logarithmic Counter",
    "description": "Write a function `steps_to_one(n)` that counts how many times you can divide n by 2 before it becomes 1. This demonstrates O(log n).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def steps_to_one(n):\n    pass",
    "solution": "def steps_to_one(n):\n    count = 0\n    while n > 1:\n        n = n // 2\n        count += 1\n    return count",
    "testCases": [
      {
        "input": "16",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Power of 2"
      },
      {
        "input": "32",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Larger power of 2"
      },
      {
        "input": "1",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Base case"
      }
    ],
    "hints": [
      "Use a while loop.",
      "Integer division // 2."
    ]
  },
  {
    "id": "cs201-ex-1-7",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Has Duplicates (Naive)",
    "description": "Check for duplicates using nested loops. Time complexity: O(n^2).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def has_duplicates_naive(arr):\n    pass",
    "solution": "def has_duplicates_naive(arr):\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                return True\n    return False",
    "testCases": [
      {
        "input": "[1, 2, 3, 1]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Has duplicates"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No duplicates"
      }
    ],
    "hints": [
      "Compare every element with every other element."
    ]
  },
  {
    "id": "cs201-ex-1-8",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Has Duplicates (Optimized)",
    "description": "Check for duplicates using a Set (Hash Map). Time complexity: O(n).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def has_duplicates_optimized(arr):\n    pass",
    "solution": "def has_duplicates_optimized(arr):\n    seen = set()\n    for x in arr:\n        if x in seen:\n            return True\n        seen.add(x)\n    return False",
    "testCases": [
      {
        "input": "[1, 2, 3, 1]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Has duplicates"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No duplicates"
      }
    ],
    "hints": [
      "Use a set to store seen elements.",
      "Set lookups are O(1) on average."
    ]
  },
  {
    "id": "cs201-ex-1-9",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Factorial",
    "description": "Calculate n! (n factorial). This is O(n) operations.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def factorial(n):\n    pass",
    "solution": "def factorial(n):\n    if n == 0: return 1\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result",
    "testCases": [
      {
        "input": "5",
        "expectedOutput": "120",
        "isHidden": false,
        "description": "5!"
      },
      {
        "input": "0",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "0!"
      }
    ],
    "hints": [
      "Loop from 1 to n.",
      "Multiply accumulator."
    ]
  },
  {
    "id": "cs201-ex-1-10",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Reverse String",
    "description": "Reverse a string. Requires creating a new string of size n, so O(n) time and space.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def reverse_string(s):\n    pass",
    "solution": "def reverse_string(s):\n    return s[::-1]",
    "testCases": [
      {
        "input": "\"hello\"",
        "expectedOutput": "\"olleh\"",
        "isHidden": false,
        "description": "Normal string"
      },
      {
        "input": "\"\"",
        "expectedOutput": "\"\"",
        "isHidden": false,
        "description": "Empty string"
      }
    ],
    "hints": [
      "Python slicing [::-1] is efficient.",
      "Or loop backwards."
    ]
  },
  {
    "id": "cs201-ex-1-11",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Binary Search Implementation",
    "description": "Implement binary search on a sorted array. Return index of target or -1.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def binary_search(arr, target):\n    # arr is sorted\n    pass",
    "solution": "def binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
    "testCases": [
      {
        "input": "[1, 3, 5, 7], 5",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Found element"
      },
      {
        "input": "[1, 3, 5, 7], 2",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Not found"
      }
    ],
    "hints": [
      "Maintain low and high pointers.",
      "Check middle element."
    ]
  },
  {
    "id": "cs201-ex-1-12",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Merge Sorted Arrays",
    "description": "Merge two sorted arrays into one sorted array. This is the \"Combine\" step of Merge Sort. Time O(n+m).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_sorted(arr1, arr2):\n    pass",
    "solution": "def merge_sorted(arr1, arr2):\n    result = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result",
    "testCases": [
      {
        "input": "[1, 3, 5], [2, 4, 6]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Interleaved"
      },
      {
        "input": "[], [1]",
        "expectedOutput": "[1]",
        "isHidden": false,
        "description": "One empty"
      }
    ],
    "hints": [
      "Use two pointers.",
      "Compare head of each array."
    ]
  },
  {
    "id": "cs201-ex-1-13",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Naive Fibonacci",
    "description": "Implement the recursive definition of Fibonacci. F(n) = F(n-1) + F(n-2). This is O(2^n). (Don't run with large n!)",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def fib(n):\n    pass",
    "solution": "def fib(n):\n    if n <= 1: return n\n    return fib(n-1) + fib(n-2)",
    "testCases": [
      {
        "input": "5",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "fib(5)"
      },
      {
        "input": "7",
        "expectedOutput": "13",
        "isHidden": false,
        "description": "fib(7)"
      }
    ],
    "hints": [
      "Base case: n <= 1.",
      "Recursive calls."
    ]
  },
  {
    "id": "cs201-ex-1-14",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Check Palindrome",
    "description": "Check if a string is a palindrome using two pointers (start and end). O(n).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def is_palindrome(s):\n    pass",
    "solution": "def is_palindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True",
    "testCases": [
      {
        "input": "\"racecar\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Palindrome"
      },
      {
        "input": "\"hello\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not palindrome"
      }
    ],
    "hints": [
      "Compare s[left] and s[right].",
      "Move pointers towards center."
    ]
  },
  {
    "id": "cs201-ex-1-15",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Is Prime",
    "description": "Check if a number is prime. You only need to check divisors up to sqrt(n). Complexity O(sqrt(n)).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def is_prime(n):\n    pass",
    "solution": "def is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
    "testCases": [
      {
        "input": "17",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Prime"
      },
      {
        "input": "15",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Composite"
      },
      {
        "input": "1",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Unit"
      }
    ],
    "hints": [
      "Loop from 2 to int(sqrt(n)).",
      "If n % i == 0, not prime."
    ]
  },
  {
    "id": "cs201-ex-1-16",
    "subjectId": "cs201",
    "topicId": "cs201-1",
    "title": "Fast Power",
    "description": "Compute x^n using \"Exponentiation by Squaring\". This is O(log n) compared to O(n) for simple multiplication.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def power(x, n):\n    # Return x raised to power n\n    pass",
    "solution": "def power(x, n):\n    if n == 0: return 1\n    if n % 2 == 0:\n        half = power(x, n // 2)\n        return half * half\n    else:\n        return x * power(x, n - 1)",
    "testCases": [
      {
        "input": "2, 10",
        "expectedOutput": "1024",
        "isHidden": false,
        "description": "2^10"
      },
      {
        "input": "3, 3",
        "expectedOutput": "27",
        "isHidden": false,
        "description": "3^3"
      },
      {
        "input": "5, 0",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "5^0"
      }
    ],
    "hints": [
      "If n is even, x^n = (x^(n/2))^2.",
      "Recursive approach works best."
    ]
  },
  {
    "id": "cs201-ex-2-1",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Bubble Sort Implementation",
    "description": "Implement bubble sort to sort an array in ascending order. Compare adjacent elements and swap if they are in wrong order.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bubble_sort(arr):\n    # Your code here\n    pass",
    "solution": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr",
    "testCases": [
      {
        "input": "[64, 34, 25, 12, 22, 11, 90]",
        "expectedOutput": "[11, 12, 22, 25, 34, 64, 90]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 1, 4, 2, 8]",
        "expectedOutput": "[1, 2, 4, 5, 8]",
        "isHidden": false,
        "description": "Random order"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Use nested loops: outer loop for passes, inner loop for comparisons.",
      "Swap adjacent elements if they are in wrong order.",
      "Each pass bubbles the largest element to the end."
    ]
  },
  {
    "id": "cs201-ex-2-2",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Optimized Bubble Sort",
    "description": "Implement an optimized bubble sort that stops early if the array becomes sorted before all passes complete.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bubble_sort_optimized(arr):\n    # Add early exit optimization\n    pass",
    "solution": "def bubble_sort_optimized(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1, 2, 5, 3, 4]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Nearly sorted"
      }
    ],
    "hints": [
      "Use a flag to track if any swaps occurred.",
      "If no swaps in a pass, array is sorted.",
      "Break early to save time."
    ]
  },
  {
    "id": "cs201-ex-2-3",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Count Bubble Sort Swaps",
    "description": "Implement bubble sort and return a tuple of (sorted_array, swap_count) to count the number of swaps performed.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bubble_sort_count_swaps(arr):\n    # Return (sorted_array, swap_count)\n    pass",
    "solution": "def bubble_sort_count_swaps(arr):\n    n = len(arr)\n    swaps = 0\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swaps += 1\n    return (arr, swaps)",
    "testCases": [
      {
        "input": "[3, 2, 1]",
        "expectedOutput": "([1, 2, 3], 3)",
        "isHidden": false,
        "description": "Reverse sorted requires 3 swaps"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "([1, 2, 3], 0)",
        "isHidden": false,
        "description": "Already sorted requires 0 swaps"
      },
      {
        "input": "[2, 1]",
        "expectedOutput": "([1, 2], 1)",
        "isHidden": false,
        "description": "Two elements"
      }
    ],
    "hints": [
      "Initialize a counter variable.",
      "Increment counter each time you swap.",
      "Return both array and count as a tuple."
    ]
  },
  {
    "id": "cs201-ex-2-4",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Bubble Sort Descending",
    "description": "Implement bubble sort to sort an array in descending order (largest to smallest).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def bubble_sort_desc(arr):\n    pass",
    "solution": "def bubble_sort_desc(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] < arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr",
    "testCases": [
      {
        "input": "[64, 34, 25, 12, 22]",
        "expectedOutput": "[64, 34, 25, 22, 12]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[5, 4, 3, 2, 1]",
        "isHidden": false,
        "description": "Ascending to descending"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Change the comparison operator.",
      "Swap when left element is smaller than right."
    ]
  },
  {
    "id": "cs201-ex-2-5",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Selection Sort",
    "description": "Implement selection sort. Find the minimum element in unsorted portion and swap it with the first unsorted element.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def selection_sort(arr):\n    pass",
    "solution": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
    "testCases": [
      {
        "input": "[64, 25, 12, 22, 11]",
        "expectedOutput": "[11, 12, 22, 25, 64]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Outer loop marks the boundary of sorted/unsorted portions.",
      "Inner loop finds minimum in unsorted portion.",
      "Swap minimum with first unsorted element."
    ]
  },
  {
    "id": "cs201-ex-2-6",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Selection Sort with Maximum",
    "description": "Implement selection sort variant that finds the maximum element and places it at the end of unsorted portion.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def selection_sort_max(arr):\n    pass",
    "solution": "def selection_sort_max(arr):\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        max_idx = i\n        for j in range(0, i):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        arr[i], arr[max_idx] = arr[max_idx], arr[i]\n    return arr",
    "testCases": [
      {
        "input": "[64, 25, 12, 22, 11]",
        "expectedOutput": "[11, 12, 22, 25, 64]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[3, 1, 4, 1, 5]",
        "expectedOutput": "[1, 1, 3, 4, 5]",
        "isHidden": false,
        "description": "With duplicates"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      }
    ],
    "hints": [
      "Loop backwards from end to beginning.",
      "Find maximum in unsorted portion (0 to i).",
      "Place maximum at position i."
    ]
  },
  {
    "id": "cs201-ex-2-7",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Insertion Sort",
    "description": "Implement insertion sort. Build sorted array one element at a time by inserting each element into its correct position.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def insertion_sort(arr):\n    pass",
    "solution": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
    "testCases": [
      {
        "input": "[12, 11, 13, 5, 6]",
        "expectedOutput": "[5, 6, 11, 12, 13]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Start from second element (index 1).",
      "Save current element as key.",
      "Shift larger elements to the right.",
      "Insert key at correct position."
    ]
  },
  {
    "id": "cs201-ex-2-8",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Insertion Sort Comparison Counter",
    "description": "Implement insertion sort and count the number of comparisons made. Return (sorted_array, comparison_count).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def insertion_sort_count(arr):\n    # Return (sorted_array, comparison_count)\n    pass",
    "solution": "def insertion_sort_count(arr):\n    comparisons = 0\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0:\n            comparisons += 1\n            if arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            else:\n                break\n        arr[j + 1] = key\n    return (arr, comparisons)",
    "testCases": [
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "([1, 2, 3], 2)",
        "isHidden": false,
        "description": "Already sorted - minimum comparisons"
      },
      {
        "input": "[3, 2, 1]",
        "expectedOutput": "([1, 2, 3], 3)",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[2, 1]",
        "expectedOutput": "([1, 2], 1)",
        "isHidden": false,
        "description": "Two elements"
      }
    ],
    "hints": [
      "Count each comparison in the while loop.",
      "Best case: already sorted = n-1 comparisons.",
      "Worst case: reverse sorted = n(n-1)/2 comparisons."
    ]
  },
  {
    "id": "cs201-ex-2-9",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Merge Step for Merge Sort",
    "description": "Implement the merge function that combines two sorted arrays into one sorted array. This is the key step in merge sort.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def merge(left, right):\n    # Merge two sorted arrays\n    pass",
    "solution": "def merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "testCases": [
      {
        "input": "[1, 3, 5], [2, 4, 6]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Interleaved arrays"
      },
      {
        "input": "[1, 2, 3], [4, 5, 6]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Non-overlapping ranges"
      },
      {
        "input": "[], [1, 2, 3]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": true,
        "description": "Empty left array"
      },
      {
        "input": "[1, 2], []",
        "expectedOutput": "[1, 2]",
        "isHidden": true,
        "description": "Empty right array"
      }
    ],
    "hints": [
      "Use two pointers, one for each array.",
      "Compare elements and append smaller one.",
      "Remember to append remaining elements."
    ]
  },
  {
    "id": "cs201-ex-2-10",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Merge Sort",
    "description": "Implement merge sort using divide-and-conquer. Recursively split array in half, sort each half, then merge.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_sort(arr):\n    pass",
    "solution": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "testCases": [
      {
        "input": "[38, 27, 43, 3, 9, 82, 10]",
        "expectedOutput": "[3, 9, 10, 27, 38, 43, 82]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Base case: arrays with 0 or 1 elements are already sorted.",
      "Split array at midpoint.",
      "Recursively sort left and right halves.",
      "Merge the sorted halves."
    ]
  },
  {
    "id": "cs201-ex-2-11",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Merge Sorted Subarrays",
    "description": "Given an array and indices (left, mid, right), merge the two sorted subarrays arr[left:mid+1] and arr[mid+1:right+1].",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_subarrays(arr, left, mid, right):\n    # Merge arr[left:mid+1] and arr[mid+1:right+1]\n    pass",
    "solution": "def merge_subarrays(arr, left, mid, right):\n    left_arr = arr[left:mid+1]\n    right_arr = arr[mid+1:right+1]\n    i = j = 0\n    k = left\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n    return arr",
    "testCases": [
      {
        "input": "[1, 3, 5, 2, 4, 6], 0, 2, 5",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Merge two sorted halves"
      },
      {
        "input": "[1, 4, 2, 3], 0, 1, 3",
        "expectedOutput": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "Smaller array"
      }
    ],
    "hints": [
      "Create temporary copies of subarrays.",
      "Merge back into original array starting at index left.",
      "Use three pointers: i for left subarray, j for right, k for original."
    ]
  },
  {
    "id": "cs201-ex-2-12",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Bottom-Up Merge Sort",
    "description": "Implement iterative (bottom-up) merge sort. Start with size 1 subarrays, merge pairs, then size 2, size 4, etc.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def merge_sort_iterative(arr):\n    pass",
    "solution": "def merge_sort_iterative(arr):\n    n = len(arr)\n    size = 1\n    while size < n:\n        for start in range(0, n, size * 2):\n            mid = min(start + size - 1, n - 1)\n            end = min(start + size * 2 - 1, n - 1)\n            if mid < end:\n                merge_subarrays(arr, start, mid, end)\n        size *= 2\n    return arr\n\ndef merge_subarrays(arr, left, mid, right):\n    left_arr = arr[left:mid+1]\n    right_arr = arr[mid+1:right+1]\n    i = j = 0\n    k = left\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1",
    "testCases": [
      {
        "input": "[38, 27, 43, 3, 9, 82, 10]",
        "expectedOutput": "[3, 9, 10, 27, 38, 43, 82]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3, 4]",
        "expectedOutput": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "Already sorted"
      }
    ],
    "hints": [
      "Start with subarray size = 1.",
      "Double size each iteration.",
      "Merge adjacent subarrays of current size."
    ]
  },
  {
    "id": "cs201-ex-2-13",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Partition Function for Quick Sort",
    "description": "Implement the partition function for quick sort. Choose last element as pivot, rearrange so smaller elements are left, larger are right. Return pivot index.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def partition(arr, low, high):\n    # Partition around last element (pivot)\n    # Return pivot index\n    pass",
    "solution": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "testCases": [
      {
        "input": "[10, 80, 30, 90, 40, 50, 70], 0, 6",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Pivot 70 ends at index 4"
      },
      {
        "input": "[3, 1, 2], 0, 2",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Small array"
      }
    ],
    "hints": [
      "Pivot is arr[high].",
      "i tracks position for next small element.",
      "Swap elements <= pivot to left side.",
      "Finally place pivot in correct position."
    ]
  },
  {
    "id": "cs201-ex-2-14",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Quick Sort",
    "description": "Implement quick sort using the partition function. Recursively sort elements before and after partition.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    # Your code here\n    pass",
    "solution": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n    return arr\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "testCases": [
      {
        "input": "[10, 7, 8, 9, 1, 5]",
        "expectedOutput": "[1, 5, 7, 8, 9, 10]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Base case: if low >= high, return.",
      "Partition array and get pivot index.",
      "Recursively sort left side (low to pi-1).",
      "Recursively sort right side (pi+1 to high)."
    ]
  },
  {
    "id": "cs201-ex-2-15",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Quick Sort with Random Pivot",
    "description": "Implement quick sort with randomized pivot selection to avoid worst-case O(n^2) on sorted arrays.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "import random\n\ndef quick_sort_random(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    pass",
    "solution": "import random\n\ndef quick_sort_random(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        pi = partition_random(arr, low, high)\n        quick_sort_random(arr, low, pi - 1)\n        quick_sort_random(arr, pi + 1, high)\n    return arr\n\ndef partition_random(arr, low, high):\n    random_idx = random.randint(low, high)\n    arr[random_idx], arr[high] = arr[high], arr[random_idx]\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "testCases": [
      {
        "input": "[10, 7, 8, 9, 1, 5]",
        "expectedOutput": "[1, 5, 7, 8, 9, 10]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Already sorted - random pivot helps"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      }
    ],
    "hints": [
      "Pick random index between low and high.",
      "Swap random element with last element.",
      "Use regular partition with last element as pivot.",
      "This averages O(n log n) even on sorted arrays."
    ]
  },
  {
    "id": "cs201-ex-2-16",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Quick Sort with Three-Way Partition",
    "description": "Implement quick sort using three-way partitioning (Dutch National Flag). Efficiently handles arrays with many duplicate elements.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def quick_sort_3way(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    pass",
    "solution": "def quick_sort_3way(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        lt, gt = partition_3way(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    return arr\n\ndef partition_3way(arr, low, high):\n    pivot = arr[low]\n    lt = low\n    gt = high\n    i = low\n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[gt], arr[i] = arr[i], arr[gt]\n            gt -= 1\n        else:\n            i += 1\n    return lt, gt",
    "testCases": [
      {
        "input": "[4, 2, 3, 4, 1, 4, 2, 4]",
        "expectedOutput": "[1, 2, 2, 3, 4, 4, 4, 4]",
        "isHidden": false,
        "description": "Many duplicates"
      },
      {
        "input": "[5, 5, 5, 5, 5]",
        "expectedOutput": "[5, 5, 5, 5, 5]",
        "isHidden": false,
        "description": "All same elements"
      },
      {
        "input": "[3, 1, 2, 3, 1]",
        "expectedOutput": "[1, 1, 2, 3, 3]",
        "isHidden": false,
        "description": "Some duplicates"
      }
    ],
    "hints": [
      "Partition into three sections: < pivot, == pivot, > pivot.",
      "Use three pointers: lt (less than), i (current), gt (greater than).",
      "Elements equal to pivot stay in middle, no need to sort again.",
      "Recursively sort only < and > sections."
    ]
  },
  {
    "id": "cs201-ex-3-1",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Linear Search - Find Index",
    "description": "Write a function `linear_search(arr, target)` that returns the index of the first occurrence of target in arr, or -1 if not found. Time complexity: O(n).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def linear_search(arr, target):\n    # Your code here\n    pass",
    "solution": "def linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1",
    "testCases": [
      {
        "input": "[4, 2, 7, 1, 9], 7",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Target found at index 2"
      },
      {
        "input": "[4, 2, 7, 1, 9], 5",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Target not in array"
      },
      {
        "input": "[1, 1, 1], 1",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Multiple occurrences, return first"
      },
      {
        "input": "[], 5",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Iterate through the array from start to end.",
      "Return the index immediately when you find the target.",
      "If the loop completes without finding the target, return -1."
    ]
  },
  {
    "id": "cs201-ex-3-2",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Find All Occurrences",
    "description": "Write a function `find_all_occurrences(arr, target)` that returns a list of all indices where target appears in arr. Return an empty list if not found.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def find_all_occurrences(arr, target):\n    # Your code here\n    pass",
    "solution": "def find_all_occurrences(arr, target):\n    indices = []\n    for i in range(len(arr)):\n        if arr[i] == target:\n            indices.append(i)\n    return indices",
    "testCases": [
      {
        "input": "[1, 2, 3, 2, 5, 2], 2",
        "expectedOutput": "[1, 3, 5]",
        "isHidden": false,
        "description": "Multiple occurrences"
      },
      {
        "input": "[1, 2, 3], 4",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "Not found"
      },
      {
        "input": "[5, 5, 5, 5], 5",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "All elements match"
      },
      {
        "input": "[], 1",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Create an empty list to store indices.",
      "Loop through the entire array, collecting all matching indices.",
      "Return the list even if it's empty."
    ]
  },
  {
    "id": "cs201-ex-3-3",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Find Maximum Element",
    "description": "Write a function `find_max(arr)` that returns the maximum element in an unsorted array. Return None for empty arrays.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def find_max(arr):\n    # Your code here\n    pass",
    "solution": "def find_max(arr):\n    if not arr:\n        return None\n    max_val = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > max_val:\n            max_val = arr[i]\n    return max_val",
    "testCases": [
      {
        "input": "[3, 7, 1, 9, 2]",
        "expectedOutput": "9",
        "isHidden": false,
        "description": "Maximum in middle"
      },
      {
        "input": "[5]",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[-5, -1, -10, -3]",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "All negative numbers"
      },
      {
        "input": "[]",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Handle the empty array case first.",
      "Initialize max_val with the first element.",
      "Scan through remaining elements, updating max_val when needed."
    ]
  },
  {
    "id": "cs201-ex-3-4",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Find Minimum with Index",
    "description": "Write a function `find_min_index(arr)` that returns the index of the minimum element in an unsorted array. Return -1 for empty arrays.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def find_min_index(arr):\n    # Your code here\n    pass",
    "solution": "def find_min_index(arr):\n    if not arr:\n        return -1\n    min_idx = 0\n    for i in range(1, len(arr)):\n        if arr[i] < arr[min_idx]:\n            min_idx = i\n    return min_idx",
    "testCases": [
      {
        "input": "[3, 7, 1, 9, 2]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Minimum at index 2"
      },
      {
        "input": "[1, 2, 3, 4]",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Minimum at start"
      },
      {
        "input": "[9, 8, 7, 6, 5]",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Minimum at end"
      },
      {
        "input": "[]",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Track the index of the minimum, not just the value.",
      "Compare arr[i] with arr[min_idx], not with min_val.",
      "This is useful for selection sort!"
    ]
  },
  {
    "id": "cs201-ex-3-5",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Binary Search - Basic",
    "description": "Write a function `binary_search(arr, target)` that returns the index of target in a sorted array, or -1 if not found. Time complexity: O(log n).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def binary_search(arr, target):\n    # arr is sorted in ascending order\n    pass",
    "solution": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "testCases": [
      {
        "input": "[1, 3, 5, 7, 9, 11], 7",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Target found"
      },
      {
        "input": "[1, 3, 5, 7, 9, 11], 4",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Target not found"
      },
      {
        "input": "[1, 2, 3, 4, 5], 1",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "First element"
      },
      {
        "input": "[1, 2, 3, 4, 5], 5",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Last element"
      },
      {
        "input": "[], 1",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Maintain left and right pointers.",
      "Calculate mid = (left + right) // 2.",
      "If arr[mid] == target, found it!",
      "If arr[mid] < target, search right half.",
      "Otherwise, search left half."
    ]
  },
  {
    "id": "cs201-ex-3-6",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Binary Search - First Occurrence",
    "description": "Write a function `find_first(arr, target)` that returns the index of the first occurrence of target in a sorted array with duplicates. Return -1 if not found.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def find_first(arr, target):\n    # arr is sorted, may contain duplicates\n    pass",
    "solution": "def find_first(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching left\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
    "testCases": [
      {
        "input": "[1, 2, 2, 2, 3, 4], 2",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Multiple occurrences, return first"
      },
      {
        "input": "[1, 1, 1, 1], 1",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "All same elements"
      },
      {
        "input": "[1, 2, 3, 4, 5], 3",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Single occurrence"
      },
      {
        "input": "[1, 2, 3], 4",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Not found"
      }
    ],
    "hints": [
      "When you find the target, don't return immediately.",
      "Store the index in a result variable.",
      "Continue searching the left half to find earlier occurrences.",
      "Set right = mid - 1 when target is found."
    ]
  },
  {
    "id": "cs201-ex-3-7",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Binary Search - Last Occurrence",
    "description": "Write a function `find_last(arr, target)` that returns the index of the last occurrence of target in a sorted array with duplicates. Return -1 if not found.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def find_last(arr, target):\n    # arr is sorted, may contain duplicates\n    pass",
    "solution": "def find_last(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1  # Continue searching right\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
    "testCases": [
      {
        "input": "[1, 2, 2, 2, 3, 4], 2",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Multiple occurrences, return last"
      },
      {
        "input": "[1, 1, 1, 1], 1",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "All same elements"
      },
      {
        "input": "[1, 2, 3, 4, 5], 3",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Single occurrence"
      },
      {
        "input": "[1, 2, 3], 4",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Not found"
      }
    ],
    "hints": [
      "Similar to find_first, but search right instead.",
      "Set left = mid + 1 when target is found.",
      "Continue searching the right half to find later occurrences."
    ]
  },
  {
    "id": "cs201-ex-3-8",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Binary Search - Lower Bound",
    "description": "Write a function `lower_bound(arr, target)` that returns the index of the first element >= target. Return len(arr) if all elements are < target.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def lower_bound(arr, target):\n    # arr is sorted\n    # Return index of first element >= target\n    pass",
    "solution": "def lower_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left",
    "testCases": [
      {
        "input": "[1, 3, 5, 7, 9], 5",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Exact match"
      },
      {
        "input": "[1, 3, 5, 7, 9], 4",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Between elements"
      },
      {
        "input": "[1, 3, 5, 7, 9], 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Before all elements"
      },
      {
        "input": "[1, 3, 5, 7, 9], 10",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "After all elements"
      },
      {
        "input": "[2, 2, 2, 4, 4], 2",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Duplicates at start"
      }
    ],
    "hints": [
      "Use right = len(arr) instead of len(arr) - 1.",
      "Loop condition is left < right, not left <= right.",
      "If arr[mid] < target, search right: left = mid + 1.",
      "Otherwise, arr[mid] might be the answer: right = mid."
    ]
  },
  {
    "id": "cs201-ex-3-9",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Binary Search - Upper Bound",
    "description": "Write a function `upper_bound(arr, target)` that returns the index of the first element > target. Return len(arr) if all elements are <= target.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def upper_bound(arr, target):\n    # arr is sorted\n    # Return index of first element > target\n    pass",
    "solution": "def upper_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left",
    "testCases": [
      {
        "input": "[1, 3, 5, 7, 9], 5",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "First element > 5 is at index 3"
      },
      {
        "input": "[1, 3, 5, 7, 9], 4",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Between elements"
      },
      {
        "input": "[1, 3, 5, 7, 9], 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Before all elements"
      },
      {
        "input": "[1, 3, 5, 7, 9], 10",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "After all elements"
      },
      {
        "input": "[2, 2, 2, 4, 4], 2",
        "expectedOutput": "3",
        "isHidden": true,
        "description": "Duplicates, skip all"
      }
    ],
    "hints": [
      "Similar to lower_bound, but condition changes.",
      "If arr[mid] <= target, search right: left = mid + 1.",
      "Otherwise, right = mid.",
      "This finds the position AFTER the last occurrence."
    ]
  },
  {
    "id": "cs201-ex-3-10",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Count Occurrences Using Binary Search",
    "description": "Write a function `count_occurrences(arr, target)` that counts how many times target appears in a sorted array. Use binary search (lower_bound and upper_bound) for O(log n) complexity.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def count_occurrences(arr, target):\n    # arr is sorted\n    # Use binary search approach\n    pass",
    "solution": "def count_occurrences(arr, target):\n    def lower_bound(arr, target):\n        left, right = 0, len(arr)\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n    \n    def upper_bound(arr, target):\n        left, right = 0, len(arr)\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n    \n    return upper_bound(arr, target) - lower_bound(arr, target)",
    "testCases": [
      {
        "input": "[1, 2, 2, 2, 3, 4], 2",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Three occurrences"
      },
      {
        "input": "[1, 2, 2, 2, 3, 4], 5",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Not found"
      },
      {
        "input": "[1, 1, 1, 1], 1",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "All same"
      },
      {
        "input": "[1, 2, 3, 4, 5], 3",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Single occurrence"
      },
      {
        "input": "[], 1",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Count = upper_bound(target) - lower_bound(target).",
      "Lower bound gives the first position >= target.",
      "Upper bound gives the first position > target.",
      "The difference is the count!"
    ]
  },
  {
    "id": "cs201-ex-3-11",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Integer Square Root",
    "description": "Write a function `sqrt(n)` that returns the integer square root of n (floor of the actual square root). Use binary search on the answer space [0, n].",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def sqrt(n):\n    # Return floor(sqrt(n)) using binary search\n    pass",
    "solution": "def sqrt(n):\n    if n == 0:\n        return 0\n    left, right = 1, n\n    result = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == n:\n            return mid\n        elif mid * mid < n:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
    "testCases": [
      {
        "input": "16",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Perfect square"
      },
      {
        "input": "17",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Not perfect square"
      },
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "sqrt(1)"
      },
      {
        "input": "0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "sqrt(0)"
      },
      {
        "input": "100",
        "expectedOutput": "10",
        "isHidden": true,
        "description": "Larger perfect square"
      }
    ],
    "hints": [
      "Search space is [1, n].",
      "If mid * mid <= n, mid could be the answer, search right for larger.",
      "If mid * mid > n, search left for smaller.",
      "Keep track of the largest mid where mid * mid <= n."
    ]
  },
  {
    "id": "cs201-ex-3-12",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Find Peak Element",
    "description": "Write a function `find_peak(arr)` that finds the index of a peak element in an array. A peak element is greater than its neighbors. Array has no duplicates. Use binary search for O(log n).",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def find_peak(arr):\n    # Find any peak element index\n    # arr[i] != arr[i+1] for all valid i\n    pass",
    "solution": "def find_peak(arr):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < arr[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left",
    "testCases": [
      {
        "input": "[1, 2, 3, 1]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Peak in middle"
      },
      {
        "input": "[1, 2, 1, 3, 5, 6, 4]",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Multiple peaks, any valid"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Peak at start"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Peak at end"
      },
      {
        "input": "[1]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "If arr[mid] < arr[mid+1], there must be a peak in the right half.",
      "Otherwise, there must be a peak in the left half (including mid).",
      "Loop until left == right.",
      "Any peak is a valid answer!"
    ]
  },
  {
    "id": "cs201-ex-3-13",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Search in Rotated Sorted Array",
    "description": "A sorted array has been rotated at some pivot (e.g., [4,5,6,7,0,1,2]). Write `search_rotated(arr, target)` to find the index of target, or -1 if not found. Use O(log n) binary search.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def search_rotated(arr, target):\n    # arr is rotated sorted array (no duplicates)\n    pass",
    "solution": "def search_rotated(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        \n        # Determine which half is sorted\n        if arr[left] <= arr[mid]:\n            # Left half is sorted\n            if arr[left] <= target < arr[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            # Right half is sorted\n            if arr[mid] < target <= arr[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
    "testCases": [
      {
        "input": "[4, 5, 6, 7, 0, 1, 2], 0",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Target in right sorted portion"
      },
      {
        "input": "[4, 5, 6, 7, 0, 1, 2], 5",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Target in left sorted portion"
      },
      {
        "input": "[4, 5, 6, 7, 0, 1, 2], 3",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Target not in array"
      },
      {
        "input": "[1], 1",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[3, 1], 1",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Two elements rotated"
      }
    ],
    "hints": [
      "At least one half of the array is always sorted.",
      "Determine which half is sorted by comparing arr[left] and arr[mid].",
      "If left half is sorted and target is in range [arr[left], arr[mid]), search left.",
      "Apply similar logic for the right half.",
      "This requires careful condition checking!"
    ]
  },
  {
    "id": "cs201-ex-3-14",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Find Minimum in Rotated Array",
    "description": "Write a function `find_min_rotated(arr)` that finds the minimum element in a rotated sorted array (no duplicates). This is the rotation point. Use O(log n) binary search.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def find_min_rotated(arr):\n    # arr is rotated sorted array (no duplicates)\n    pass",
    "solution": "def find_min_rotated(arr):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] > arr[right]:\n            # Minimum is in right half\n            left = mid + 1\n        else:\n            # Minimum is in left half (including mid)\n            right = mid\n    return arr[left]",
    "testCases": [
      {
        "input": "[4, 5, 6, 7, 0, 1, 2]",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Rotated array"
      },
      {
        "input": "[3, 4, 5, 1, 2]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Another rotation"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Not rotated"
      },
      {
        "input": "[2, 1]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Two elements"
      },
      {
        "input": "[1]",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "Compare arr[mid] with arr[right].",
      "If arr[mid] > arr[right], the minimum is in the right half.",
      "Otherwise, the minimum is in the left half (including mid).",
      "When left == right, you found the minimum."
    ]
  },
  {
    "id": "cs201-ex-3-15",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Interpolation Search (Uniformly Distributed)",
    "description": "Implement interpolation search for uniformly distributed sorted data. Instead of mid = (left+right)/2, estimate position based on value: pos = left + (target-arr[left])*(right-left)/(arr[right]-arr[left]). Average case: O(log log n).",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def interpolation_search(arr, target):\n    # arr is sorted and uniformly distributed\n    pass",
    "solution": "def interpolation_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right and target >= arr[left] and target <= arr[right]:\n        if left == right:\n            if arr[left] == target:\n                return left\n            return -1\n        \n        # Interpolation formula\n        pos = left + int((target - arr[left]) * (right - left) / (arr[right] - arr[left]))\n        \n        if arr[pos] == target:\n            return pos\n        elif arr[pos] < target:\n            left = pos + 1\n        else:\n            right = pos - 1\n    return -1",
    "testCases": [
      {
        "input": "[10, 20, 30, 40, 50, 60, 70, 80, 90], 50",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Uniformly distributed"
      },
      {
        "input": "[1, 2, 3, 4, 5, 6, 7, 8, 9], 7",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Sequential uniform"
      },
      {
        "input": "[10, 20, 30, 40, 50], 25",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Not found"
      },
      {
        "input": "[5], 5",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "Check that target is within the range [arr[left], arr[right]].",
      "Calculate position using the interpolation formula.",
      "Handle the case where left == right separately.",
      "Avoid division by zero when arr[right] == arr[left].",
      "Works best on uniformly distributed data!"
    ]
  },
  {
    "id": "cs201-ex-3-16",
    "subjectId": "cs201",
    "topicId": "cs201-3",
    "title": "Hybrid Search Strategy",
    "description": "Implement a hybrid search that uses interpolation search for uniformly distributed arrays and falls back to binary search otherwise. Return the index of target or -1. This demonstrates understanding of when each algorithm is optimal.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def hybrid_search(arr, target):\n    # Use interpolation if uniform, else binary search\n    pass",
    "solution": "def hybrid_search(arr, target):\n    def is_uniform(arr, left, right, threshold=2):\n        if right - left < 2:\n            return True\n        mid = (left + right) // 2\n        expected_val = arr[left] + (arr[right] - arr[left]) * (mid - left) // (right - left)\n        return abs(arr[mid] - expected_val) <= threshold\n    \n    left, right = 0, len(arr) - 1\n    use_interpolation = is_uniform(arr, left, right)\n    \n    while left <= right:\n        if use_interpolation and target >= arr[left] and target <= arr[right]:\n            if arr[right] == arr[left]:\n                mid = left\n            else:\n                mid = left + int((target - arr[left]) * (right - left) / (arr[right] - arr[left]))\n                mid = max(left, min(mid, right))\n        else:\n            mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "testCases": [
      {
        "input": "[10, 20, 30, 40, 50, 60, 70], 40",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Uniform distribution"
      },
      {
        "input": "[1, 2, 4, 8, 16, 32, 64], 16",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Non-uniform (exponential)"
      },
      {
        "input": "[1, 3, 5, 7, 9, 11], 5",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Uniform odd numbers"
      },
      {
        "input": "[1, 2, 3, 4, 5], 6",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Not found"
      }
    ],
    "hints": [
      "Check if the array is uniformly distributed.",
      "For uniform data, use interpolation search formula.",
      "For non-uniform data, use standard binary search.",
      "Ensure the interpolated position stays within [left, right].",
      "This demonstrates algorithm selection based on data characteristics!"
    ]
  },
  {
    "id": "cs201-ex-4-1",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Recursive Power (Linear)",
    "description": "Implement a simple recursive power function that computes x^n by multiplying x repeatedly. This is the basic O(n) approach before optimization.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def power_linear(x, n):\n    # Base case: n = 0\n    # Recursive case: x * x^(n-1)\n    pass",
    "solution": "def power_linear(x, n):\n    if n == 0:\n        return 1\n    return x * power_linear(x, n - 1)",
    "testCases": [
      {
        "input": "2, 3",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "2^3 = 8"
      },
      {
        "input": "5, 2",
        "expectedOutput": "25",
        "isHidden": false,
        "description": "5^2 = 25"
      },
      {
        "input": "10, 0",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Any number to power 0 is 1"
      }
    ],
    "hints": [
      "Base case: when n is 0, return 1.",
      "Recursive case: multiply x by power(x, n-1)."
    ]
  },
  {
    "id": "cs201-ex-4-2",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Recursive Array Sum",
    "description": "Sum an array using divide and conquer. Split the array in half and recursively sum each half.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def sum_array_recursive(arr):\n    # Base case: empty or single element\n    # Divide: split array in half\n    # Conquer: recursively sum each half\n    # Combine: add the two sums\n    pass",
    "solution": "def sum_array_recursive(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    mid = len(arr) // 2\n    left_sum = sum_array_recursive(arr[:mid])\n    right_sum = sum_array_recursive(arr[mid:])\n    return left_sum + right_sum",
    "testCases": [
      {
        "input": "[1, 2, 3, 4]",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Sum of 1+2+3+4"
      },
      {
        "input": "[5]",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Empty array"
      },
      {
        "input": "[10, -5, 3, -2]",
        "expectedOutput": "6",
        "isHidden": true,
        "description": "Mixed positive and negative"
      }
    ],
    "hints": [
      "Base case: return 0 for empty, arr[0] for single element.",
      "Find midpoint with len(arr) // 2.",
      "Split into arr[:mid] and arr[mid:]."
    ]
  },
  {
    "id": "cs201-ex-4-3",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Recursive Maximum",
    "description": "Find the maximum element in an array using divide and conquer. Compare maximums from left and right halves.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def find_max_recursive(arr):\n    # Base case: single element\n    # Divide into left and right halves\n    # Return max of left_max and right_max\n    pass",
    "solution": "def find_max_recursive(arr):\n    if len(arr) == 1:\n        return arr[0]\n    mid = len(arr) // 2\n    left_max = find_max_recursive(arr[:mid])\n    right_max = find_max_recursive(arr[mid:])\n    return max(left_max, right_max)",
    "testCases": [
      {
        "input": "[3, 1, 4, 1, 5, 9, 2]",
        "expectedOutput": "9",
        "isHidden": false,
        "description": "Maximum is 9"
      },
      {
        "input": "[10]",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[-5, -2, -8, -1]",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "All negative numbers"
      }
    ],
    "hints": [
      "Base case: single element is the max.",
      "Recursively find max in left and right halves.",
      "Return the larger of the two."
    ]
  },
  {
    "id": "cs201-ex-4-4",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Fast Power (Divide & Conquer)",
    "description": "Implement fast exponentiation using divide and conquer. For even n, x^n = (x^(n/2))^2. This reduces time complexity from O(n) to O(log n).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def power_fast(x, n):\n    # Base case: n = 0\n    # If n is even: compute x^(n/2) and square it\n    # If n is odd: x * x^(n-1)\n    pass",
    "solution": "def power_fast(x, n):\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        half = power_fast(x, n // 2)\n        return half * half\n    else:\n        return x * power_fast(x, n - 1)",
    "testCases": [
      {
        "input": "2, 10",
        "expectedOutput": "1024",
        "isHidden": false,
        "description": "2^10 = 1024"
      },
      {
        "input": "3, 5",
        "expectedOutput": "243",
        "isHidden": false,
        "description": "3^5 = 243"
      },
      {
        "input": "7, 0",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Any number to power 0"
      },
      {
        "input": "2, 20",
        "expectedOutput": "1048576",
        "isHidden": true,
        "description": "Large exponent 2^20"
      }
    ],
    "hints": [
      "For even n, compute half = x^(n/2) once, then return half * half.",
      "For odd n, multiply x by x^(n-1).",
      "This avoids redundant calculations."
    ]
  },
  {
    "id": "cs201-ex-4-5",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Maximum Subarray (Brute Force)",
    "description": "Find the contiguous subarray with the largest sum using the brute force approach. Check all possible subarrays. Time complexity: O(n^2).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def max_subarray_brute(arr):\n    # Try all possible subarrays\n    # Return the maximum sum\n    pass",
    "solution": "def max_subarray_brute(arr):\n    max_sum = float('-inf')\n    for i in range(len(arr)):\n        current_sum = 0\n        for j in range(i, len(arr)):\n            current_sum += arr[j]\n            max_sum = max(max_sum, current_sum)\n    return max_sum",
    "testCases": [
      {
        "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Subarray [4,-1,2,1] has sum 6"
      },
      {
        "input": "[1]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[-1, -2, -3]",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "All negative, best is -1"
      },
      {
        "input": "[5, -3, 5]",
        "expectedOutput": "7",
        "isHidden": true,
        "description": "Entire array sum is 7"
      }
    ],
    "hints": [
      "Use nested loops: outer for start index i, inner for end index j.",
      "Track running sum from i to j.",
      "Update max_sum whenever you find a larger sum."
    ]
  },
  {
    "id": "cs201-ex-4-6",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Maximum Crossing Subarray",
    "description": "Find the maximum subarray that crosses the midpoint. This is a helper function for the divide-and-conquer maximum subarray algorithm.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def max_crossing_subarray(arr, low, mid, high):\n    # Find max sum from mid going left\n    # Find max sum from mid+1 going right\n    # Return their sum\n    pass",
    "solution": "def max_crossing_subarray(arr, low, mid, high):\n    left_sum = float('-inf')\n    total = 0\n    for i in range(mid, low - 1, -1):\n        total += arr[i]\n        left_sum = max(left_sum, total)\n    \n    right_sum = float('-inf')\n    total = 0\n    for i in range(mid + 1, high + 1):\n        total += arr[i]\n        right_sum = max(right_sum, total)\n    \n    return left_sum + right_sum",
    "testCases": [
      {
        "input": "[1, -2, 3, 4, -5], 0, 2, 4",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Crossing at mid=2: [3,4]"
      },
      {
        "input": "[-1, 2, -1], 0, 1, 2",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Best crossing is just [2]"
      },
      {
        "input": "[5, -3, -2, 6], 0, 1, 3",
        "expectedOutput": "6",
        "isHidden": true,
        "description": "Crossing gives [5,-3,-2,6]=6"
      }
    ],
    "hints": [
      "Start from mid and go left, tracking the best sum.",
      "Start from mid+1 and go right, tracking the best sum.",
      "The crossing sum is left_sum + right_sum."
    ]
  },
  {
    "id": "cs201-ex-4-7",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Maximum Subarray (Divide & Conquer)",
    "description": "Find the maximum subarray using divide and conquer. The maximum is either entirely in the left half, entirely in the right half, or crosses the middle. Time: O(n log n).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def max_subarray_dc(arr, low, high):\n    # Base case: single element\n    # Divide: find middle\n    # Conquer: recursively find max in left and right\n    # Combine: compare left, right, and crossing\n    pass\n\ndef max_crossing(arr, low, mid, high):\n    # Helper function from previous exercise\n    left_sum = float('-inf')\n    total = 0\n    for i in range(mid, low - 1, -1):\n        total += arr[i]\n        left_sum = max(left_sum, total)\n    right_sum = float('-inf')\n    total = 0\n    for i in range(mid + 1, high + 1):\n        total += arr[i]\n        right_sum = max(right_sum, total)\n    return left_sum + right_sum",
    "solution": "def max_subarray_dc(arr, low, high):\n    if low == high:\n        return arr[low]\n    \n    mid = (low + high) // 2\n    left_max = max_subarray_dc(arr, low, mid)\n    right_max = max_subarray_dc(arr, mid + 1, high)\n    cross_max = max_crossing(arr, low, mid, high)\n    \n    return max(left_max, right_max, cross_max)\n\ndef max_crossing(arr, low, mid, high):\n    left_sum = float('-inf')\n    total = 0\n    for i in range(mid, low - 1, -1):\n        total += arr[i]\n        left_sum = max(left_sum, total)\n    right_sum = float('-inf')\n    total = 0\n    for i in range(mid + 1, high + 1):\n        total += arr[i]\n        right_sum = max(right_sum, total)\n    return left_sum + right_sum",
    "testCases": [
      {
        "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4], 0, 8",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Classic example: [4,-1,2,1]=6"
      },
      {
        "input": "[1, 2, 3], 0, 2",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "All positive: sum all"
      },
      {
        "input": "[-5, -2, -8], 0, 2",
        "expectedOutput": "-2",
        "isHidden": true,
        "description": "All negative: best is -2"
      }
    ],
    "hints": [
      "Base case: if low == high, return arr[low].",
      "Find mid = (low + high) // 2.",
      "Compare max from left half, right half, and crossing."
    ]
  },
  {
    "id": "cs201-ex-4-8",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Maximum Subarray (Kadane's Algorithm)",
    "description": "Solve the maximum subarray problem in O(n) time using Kadane's algorithm. This is more efficient than divide and conquer but demonstrates the trade-off between algorithmic approaches.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def max_subarray_kadane(arr):\n    # Track current_sum and max_sum\n    # If current_sum becomes negative, reset to 0\n    pass",
    "solution": "def max_subarray_kadane(arr):\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
    "testCases": [
      {
        "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Same result as D&C approach"
      },
      {
        "input": "[1, 2, 3, 4]",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "All positive"
      },
      {
        "input": "[-1, -2, -3]",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "All negative"
      }
    ],
    "hints": [
      "Keep a running sum that resets when it goes negative.",
      "Track the maximum sum seen so far.",
      "For each element, decide: start new subarray or continue current?"
    ]
  },
  {
    "id": "cs201-ex-4-9",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Merge Two Sorted Arrays",
    "description": "Implement the merge function that combines two sorted arrays into one sorted array. This is the \"combine\" step of merge sort. Time: O(n).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def merge(left, right):\n    # Merge two sorted arrays\n    # Use two pointers\n    pass",
    "solution": "def merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "testCases": [
      {
        "input": "[1, 3, 5], [2, 4, 6]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Interleaved arrays"
      },
      {
        "input": "[1, 2], [3, 4]",
        "expectedOutput": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "No interleaving needed"
      },
      {
        "input": "[], [1, 2]",
        "expectedOutput": "[1, 2]",
        "isHidden": true,
        "description": "One empty array"
      },
      {
        "input": "[5], [1, 3]",
        "expectedOutput": "[1, 3, 5]",
        "isHidden": true,
        "description": "Different sizes"
      }
    ],
    "hints": [
      "Use two pointers, one for each array.",
      "Compare elements and append the smaller one.",
      "After one array is exhausted, append the rest of the other."
    ]
  },
  {
    "id": "cs201-ex-4-10",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Merge Sort",
    "description": "Implement the complete merge sort algorithm. Divide array in half, recursively sort each half, then merge. Time: O(n log n).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_sort(arr):\n    # Base case: array of size 0 or 1\n    # Divide: split in half\n    # Conquer: recursively sort each half\n    # Combine: merge sorted halves\n    pass\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "solution": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "testCases": [
      {
        "input": "[3, 1, 4, 1, 5, 9, 2, 6]",
        "expectedOutput": "[1, 1, 2, 3, 4, 5, 6, 9]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Base case: if array has 0 or 1 elements, it's already sorted.",
      "Split at midpoint: arr[:mid] and arr[mid:].",
      "Recursively sort left and right, then merge them."
    ]
  },
  {
    "id": "cs201-ex-4-11",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Merge Sort with Index Range",
    "description": "Implement merge sort that works on a portion of the array specified by indices. This is more space-efficient and demonstrates the complete D&C pattern.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def merge_sort_range(arr, left, right):\n    # Sort arr[left:right+1] in place\n    # Base case: left >= right\n    pass\n\ndef merge_range(arr, left, mid, right):\n    # Merge arr[left:mid+1] and arr[mid+1:right+1]\n    pass",
    "solution": "def merge_sort_range(arr, left, right):\n    if left >= right:\n        return\n    \n    mid = (left + right) // 2\n    merge_sort_range(arr, left, mid)\n    merge_sort_range(arr, mid + 1, right)\n    merge_range(arr, left, mid, right)\n\ndef merge_range(arr, left, mid, right):\n    left_part = arr[left:mid+1]\n    right_part = arr[mid+1:right+1]\n    \n    i = j = 0\n    k = left\n    \n    while i < len(left_part) and j < len(right_part):\n        if left_part[i] <= right_part[j]:\n            arr[k] = left_part[i]\n            i += 1\n        else:\n            arr[k] = right_part[j]\n            j += 1\n        k += 1\n    \n    while i < len(left_part):\n        arr[k] = left_part[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_part):\n        arr[k] = right_part[j]\n        j += 1\n        k += 1",
    "testCases": [
      {
        "input": "[3, 1, 4, 1, 5], 0, 4",
        "expectedOutput": "[1, 1, 3, 4, 5]",
        "isHidden": false,
        "description": "Sort entire array"
      },
      {
        "input": "[1, 5, 3, 2, 4], 1, 3",
        "expectedOutput": "[1, 2, 3, 5, 4]",
        "isHidden": false,
        "description": "Sort middle portion"
      },
      {
        "input": "[9, 7, 5, 3, 1], 0, 4",
        "expectedOutput": "[1, 3, 5, 7, 9]",
        "isHidden": true,
        "description": "Reverse order"
      }
    ],
    "hints": [
      "Base case: if left >= right, nothing to sort.",
      "Find mid = (left + right) // 2.",
      "Recursively sort [left, mid] and [mid+1, right].",
      "Merge the two sorted portions."
    ]
  },
  {
    "id": "cs201-ex-4-12",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Count Merge Sort Comparisons",
    "description": "Implement merge sort that also counts the number of comparisons made. This helps understand the O(n log n) complexity empirically.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_sort_count(arr):\n    # Return (sorted_array, comparison_count)\n    pass\n\ndef merge_count(left, right):\n    # Return (merged_array, comparison_count)\n    pass",
    "solution": "def merge_sort_count(arr):\n    if len(arr) <= 1:\n        return (arr, 0)\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_count(arr[:mid])\n    right, right_count = merge_sort_count(arr[mid:])\n    merged, merge_count = merge_count(left, right)\n    \n    return (merged, left_count + right_count + merge_count)\n\ndef merge_count(left, right):\n    result = []\n    i = j = 0\n    comparisons = 0\n    \n    while i < len(left) and j < len(right):\n        comparisons += 1\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return (result, comparisons)",
    "testCases": [
      {
        "input": "[3, 1, 4, 2]",
        "expectedOutput": "([1, 2, 3, 4], 4)",
        "isHidden": false,
        "description": "Array of 4 elements"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "([1, 2, 3, 4, 5], 7)",
        "isHidden": false,
        "description": "Worst case ordering"
      },
      {
        "input": "[1]",
        "expectedOutput": "([1], 0)",
        "isHidden": true,
        "description": "Single element, no comparisons"
      }
    ],
    "hints": [
      "Return a tuple (sorted_array, count).",
      "Count comparisons during the merge step.",
      "Sum up counts from left, right, and merge."
    ]
  },
  {
    "id": "cs201-ex-4-13",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Count Inversions",
    "description": "Count the number of inversions in an array using divide and conquer. An inversion is a pair (i,j) where i < j but arr[i] > arr[j]. This is a classic D&C application. Time: O(n log n).",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def count_inversions(arr):\n    # Return (sorted_array, inversion_count)\n    # Use modified merge sort\n    pass\n\ndef merge_count_inversions(left, right):\n    # Count inversions while merging\n    pass",
    "solution": "def count_inversions(arr):\n    if len(arr) <= 1:\n        return (arr, 0)\n    \n    mid = len(arr) // 2\n    left, left_inv = count_inversions(arr[:mid])\n    right, right_inv = count_inversions(arr[mid:])\n    merged, split_inv = merge_count_inversions(left, right)\n    \n    return (merged, left_inv + right_inv + split_inv)\n\ndef merge_count_inversions(left, right):\n    result = []\n    i = j = 0\n    inversions = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            inversions += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return (result, inversions)",
    "testCases": [
      {
        "input": "[2, 1, 3, 1, 2]",
        "expectedOutput": "([1, 1, 2, 2, 3], 4)",
        "isHidden": false,
        "description": "4 inversions"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "([1, 2, 3], 0)",
        "isHidden": false,
        "description": "Already sorted, 0 inversions"
      },
      {
        "input": "[3, 2, 1]",
        "expectedOutput": "([1, 2, 3], 3)",
        "isHidden": true,
        "description": "Reverse sorted, maximum inversions"
      },
      {
        "input": "[1]",
        "expectedOutput": "([1], 0)",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "Modify merge sort to count inversions.",
      "When taking from right array, remaining left elements are all inversions.",
      "inversions += len(left) - i when right[j] < left[i]."
    ]
  },
  {
    "id": "cs201-ex-4-14",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Closest Pair of Points (1D)",
    "description": "Find the closest pair of points on a line (1D). First sort the points, then use divide and conquer to find the minimum distance. This is a simplified version of the 2D problem.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def closest_pair_1d(points):\n    # Points is a sorted list of numbers\n    # Return the minimum distance between any two points\n    # Use divide and conquer\n    pass",
    "solution": "def closest_pair_1d(points):\n    points = sorted(points)\n    \n    def helper(left, right):\n        if right - left <= 1:\n            return float('inf')\n        if right - left == 2:\n            return abs(points[right] - points[left])\n        \n        mid = (left + right) // 2\n        left_min = helper(left, mid)\n        right_min = helper(mid + 1, right)\n        \n        # The crossing minimum is just points[mid+1] - points[mid]\n        cross_min = abs(points[mid + 1] - points[mid])\n        \n        return min(left_min, right_min, cross_min)\n    \n    return helper(0, len(points) - 1)",
    "testCases": [
      {
        "input": "[1, 5, 3, 19, 18, 25]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Closest pair: 18 and 19"
      },
      {
        "input": "[1, 10, 20, 30]",
        "expectedOutput": "9",
        "isHidden": false,
        "description": "Closest pair: 1 and 10"
      },
      {
        "input": "[5, 5]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Identical points"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Evenly spaced"
      }
    ],
    "hints": [
      "First sort the points.",
      "Base case: 2 points, return their distance.",
      "Recursively find minimum in left and right halves.",
      "Check the crossing case: points[mid+1] - points[mid]."
    ]
  },
  {
    "id": "cs201-ex-4-15",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Binary Search (Recursive D&C)",
    "description": "Implement binary search using divide and conquer recursion. This is a classic example of the D&C paradigm with O(log n) time complexity.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def binary_search_recursive(arr, target, left, right):\n    # Base case: not found\n    # Check middle element\n    # Recursively search left or right half\n    pass",
    "solution": "def binary_search_recursive(arr, target, left, right):\n    if left > right:\n        return -1\n    \n    mid = (left + right) // 2\n    \n    if arr[mid] == target:\n        return mid\n    elif arr[mid] > target:\n        return binary_search_recursive(arr, target, left, mid - 1)\n    else:\n        return binary_search_recursive(arr, target, mid + 1, right)",
    "testCases": [
      {
        "input": "[1, 3, 5, 7, 9, 11], 7, 0, 5",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Found at index 3"
      },
      {
        "input": "[1, 3, 5, 7, 9, 11], 4, 0, 5",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Not found"
      },
      {
        "input": "[2, 4, 6, 8, 10], 2, 0, 4",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "First element"
      },
      {
        "input": "[2, 4, 6, 8, 10], 10, 0, 4",
        "expectedOutput": "4",
        "isHidden": true,
        "description": "Last element"
      }
    ],
    "hints": [
      "Base case: left > right means not found, return -1.",
      "Calculate mid = (left + right) // 2.",
      "If arr[mid] == target, return mid.",
      "Otherwise recursively search left or right half."
    ]
  },
  {
    "id": "cs201-ex-4-16",
    "subjectId": "cs201",
    "topicId": "cs201-4",
    "title": "Matrix Multiplication (D&C)",
    "description": "Implement basic matrix multiplication using divide and conquer by splitting matrices into quadrants. This demonstrates D&C on 2D structures (full Strassen algorithm omitted for simplicity).",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def matrix_multiply_dc(A, B):\n    # Multiply two square matrices using D&C\n    # Base case: 1x1 matrix\n    # Divide into quadrants and recursively multiply\n    pass",
    "solution": "def matrix_multiply_dc(A, B):\n    n = len(A)\n    \n    # Base case: 1x1 matrix\n    if n == 1:\n        return [[A[0][0] * B[0][0]]]\n    \n    # Divide into quadrants\n    mid = n // 2\n    A11 = [row[:mid] for row in A[:mid]]\n    A12 = [row[mid:] for row in A[:mid]]\n    A21 = [row[:mid] for row in A[mid:]]\n    A22 = [row[mid:] for row in A[mid:]]\n    \n    B11 = [row[:mid] for row in B[:mid]]\n    B12 = [row[mid:] for row in B[:mid]]\n    B21 = [row[:mid] for row in B[mid:]]\n    B22 = [row[mid:] for row in B[mid:]]\n    \n    # Recursive multiplication\n    C11 = add_matrices(matrix_multiply_dc(A11, B11), matrix_multiply_dc(A12, B21))\n    C12 = add_matrices(matrix_multiply_dc(A11, B12), matrix_multiply_dc(A12, B22))\n    C21 = add_matrices(matrix_multiply_dc(A21, B11), matrix_multiply_dc(A22, B21))\n    C22 = add_matrices(matrix_multiply_dc(A21, B12), matrix_multiply_dc(A22, B22))\n    \n    # Combine quadrants\n    C = []\n    for i in range(mid):\n        C.append(C11[i] + C12[i])\n    for i in range(mid):\n        C.append(C21[i] + C22[i])\n    \n    return C\n\ndef add_matrices(A, B):\n    n = len(A)\n    return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)]",
    "testCases": [
      {
        "input": "[[1, 2], [3, 4]], [[5, 6], [7, 8]]",
        "expectedOutput": "[[19, 22], [43, 50]]",
        "isHidden": false,
        "description": "2x2 matrix multiplication"
      },
      {
        "input": "[[1]], [[5]]",
        "expectedOutput": "[[5]]",
        "isHidden": false,
        "description": "1x1 base case"
      },
      {
        "input": "[[1, 0], [0, 1]], [[5, 6], [7, 8]]",
        "expectedOutput": "[[5, 6], [7, 8]]",
        "isHidden": true,
        "description": "Identity matrix"
      }
    ],
    "hints": [
      "Base case: 1x1 matrix, multiply single elements.",
      "Split each matrix into 4 quadrants.",
      "Recursively multiply quadrants.",
      "Combine results: C11 = A11*B11 + A12*B21, etc."
    ]
  },
  {
    "id": "cs201-ex-5-1",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Fibonacci Number - Memoization",
    "description": "Implement a function to calculate the nth Fibonacci number using memoization (top-down dynamic programming).\n\nThe Fibonacci sequence is defined as:\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function should use memoization to avoid redundant calculations.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using memoization.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    # TODO: Implement memoization approach\n    pass",
    "solution": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using memoization.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    memo = {}\n\n    def fib_helper(n: int) -> int:\n        if n in memo:\n            return memo[n]\n\n        if n <= 1:\n            return n\n\n        memo[n] = fib_helper(n - 1) + fib_helper(n - 2)\n        return memo[n]\n\n    return fib_helper(n)",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "5",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "expectedOutput": "55",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "20",
        "expectedOutput": "6765",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "30",
        "expectedOutput": "832040",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use a dictionary to store previously calculated Fibonacci numbers",
      "Create a helper function that checks the memo before calculating",
      "The base cases are F(0) = 0 and F(1) = 1"
    ]
  },
  {
    "id": "cs201-ex-5-2",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Fibonacci Number - Tabulation",
    "description": "Implement a function to calculate the nth Fibonacci number using tabulation (bottom-up dynamic programming).\n\nUnlike memoization, tabulation builds the solution iteratively from the bottom up, storing all intermediate results in a table.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def fibonacci_tabulation(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using tabulation.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    # TODO: Implement tabulation approach\n    pass",
    "solution": "def fibonacci_tabulation(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using tabulation.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n\n    # Create a table to store Fibonacci numbers\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n\n    # Fill the table bottom-up\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "5",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "expectedOutput": "55",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "20",
        "expectedOutput": "6765",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "30",
        "expectedOutput": "832040",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Create an array to store Fibonacci numbers from 0 to n",
      "Initialize the first two values: dp[0] = 0 and dp[1] = 1",
      "Fill the array iteratively using the recurrence relation"
    ]
  },
  {
    "id": "cs201-ex-5-3",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Fibonacci Number - Space Optimized",
    "description": "Implement a space-optimized version of the Fibonacci calculation.\n\nSince we only need the last two values to calculate the next Fibonacci number, we can reduce space complexity from O(n) to O(1).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def fibonacci_optimized(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number with O(1) space complexity.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    # TODO: Implement space-optimized approach\n    pass",
    "solution": "def fibonacci_optimized(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number with O(1) space complexity.\n\n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n\n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n\n    # Only keep track of the last two values\n    prev2 = 0  # F(0)\n    prev1 = 1  # F(1)\n\n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n\n    return prev1",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "5",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "expectedOutput": "55",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "20",
        "expectedOutput": "6765",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "30",
        "expectedOutput": "832040",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "You only need two variables to track the previous two Fibonacci numbers",
      "Update these variables in each iteration",
      "This achieves O(1) space complexity instead of O(n)"
    ]
  },
  {
    "id": "cs201-ex-5-4",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Fibonacci Variants - Tribonacci",
    "description": "Implement the Tribonacci sequence, a variant of Fibonacci where each number is the sum of the previous three numbers.\n\nThe Tribonacci sequence is defined as:\n- T(0) = 0\n- T(1) = 1\n- T(2) = 1\n- T(n) = T(n-1) + T(n-2) + T(n-3) for n > 2\n\nUse dynamic programming to solve this efficiently.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def tribonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Tribonacci number.\n\n    Args:\n        n: The position in the Tribonacci sequence (0-indexed)\n\n    Returns:\n        The nth Tribonacci number\n    \"\"\"\n    # TODO: Implement tribonacci with DP\n    pass",
    "solution": "def tribonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Tribonacci number.\n\n    Args:\n        n: The position in the Tribonacci sequence (0-indexed)\n\n    Returns:\n        The nth Tribonacci number\n    \"\"\"\n    if n == 0:\n        return 0\n    if n <= 2:\n        return 1\n\n    # Space-optimized approach: only keep last 3 values\n    prev3 = 0  # T(0)\n    prev2 = 1  # T(1)\n    prev1 = 1  # T(2)\n\n    for i in range(3, n + 1):\n        current = prev1 + prev2 + prev3\n        prev3 = prev2\n        prev2 = prev1\n        prev1 = current\n\n    return prev1",
    "testCases": [
      {
        "input": "0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "2",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "4",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "expectedOutput": "149",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "25",
        "expectedOutput": "1389537",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Similar to Fibonacci, but you need to track three previous values",
      "Base cases: T(0) = 0, T(1) = 1, T(2) = 1",
      "Each new value is the sum of the previous three"
    ]
  },
  {
    "id": "cs201-ex-5-5",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExample:\n- Input: n = 3\n- Output: 3\n- Explanation: There are three ways to climb to the top:\n  1. 1 step + 1 step + 1 step\n  2. 1 step + 2 steps\n  3. 2 steps + 1 step",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def climb_stairs(n: int) -> int:\n    \"\"\"\n    Calculate the number of distinct ways to climb n stairs.\n\n    Args:\n        n: The number of stairs\n\n    Returns:\n        The number of distinct ways to reach the top\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def climb_stairs(n: int) -> int:\n    \"\"\"\n    Calculate the number of distinct ways to climb n stairs.\n\n    Args:\n        n: The number of stairs\n\n    Returns:\n        The number of distinct ways to reach the top\n    \"\"\"\n    if n <= 2:\n        return n\n\n    # dp[i] represents the number of ways to reach step i\n    # We can reach step i from step i-1 (take 1 step) or from step i-2 (take 2 steps)\n    prev2 = 1  # ways to reach step 1\n    prev1 = 2  # ways to reach step 2\n\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n\n    return prev1",
    "testCases": [
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "2",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "3",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "5",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "expectedOutput": "89",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "20",
        "expectedOutput": "10946",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "This is similar to the Fibonacci sequence",
      "To reach step n, you can come from step n-1 or step n-2",
      "dp[i] = dp[i-1] + dp[i-2]"
    ]
  },
  {
    "id": "cs201-ex-5-6",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Min Cost Climbing Stairs",
    "description": "You are given an array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can start from the step with index 0, or the step with index 1.\n\nReturn the minimum cost to reach the top of the floor.\n\nExample:\n- Input: cost = [10, 15, 20]\n- Output: 15\n- Explanation: Start at index 1, pay 15, and climb two steps to reach the top.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def min_cost_climbing_stairs(cost: list[int]) -> int:\n    \"\"\"\n    Calculate the minimum cost to reach the top of the stairs.\n\n    Args:\n        cost: List of costs for each step\n\n    Returns:\n        The minimum cost to reach the top\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def min_cost_climbing_stairs(cost: list[int]) -> int:\n    \"\"\"\n    Calculate the minimum cost to reach the top of the stairs.\n\n    Args:\n        cost: List of costs for each step\n\n    Returns:\n        The minimum cost to reach the top\n    \"\"\"\n    n = len(cost)\n\n    if n <= 2:\n        return min(cost)\n\n    # dp[i] represents the minimum cost to reach step i\n    prev2 = cost[0]\n    prev1 = cost[1]\n\n    for i in range(2, n):\n        current = cost[i] + min(prev1, prev2)\n        prev2 = prev1\n        prev1 = current\n\n    # The top is one step beyond the last step\n    # We can reach it from either the last or second-to-last step\n    return min(prev1, prev2)",
    "testCases": [
      {
        "input": "[10, 15, 20]",
        "expectedOutput": "15",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10, 15]",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[0, 0, 0, 1]",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "dp[i] represents the minimum cost to reach step i",
      "At each step, you can come from the previous step or two steps back",
      "The final answer is the minimum of reaching the last two steps"
    ]
  },
  {
    "id": "cs201-ex-5-7",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.\n\nThe constraint is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an array of non-negative integers representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nExample:\n- Input: nums = [2, 7, 9, 3, 1]\n- Output: 12\n- Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total = 2 + 9 + 1 = 12.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def rob(nums: list[int]) -> int:\n    \"\"\"\n    Calculate the maximum amount of money that can be robbed.\n\n    Args:\n        nums: List of money in each house\n\n    Returns:\n        The maximum amount that can be robbed\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def rob(nums: list[int]) -> int:\n    \"\"\"\n    Calculate the maximum amount of money that can be robbed.\n\n    Args:\n        nums: List of money in each house\n\n    Returns:\n        The maximum amount that can be robbed\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n\n    # dp[i] represents the maximum money that can be robbed up to house i\n    # At each house, we have two choices:\n    # 1. Rob this house + max money from houses up to i-2\n    # 2. Don't rob this house, keep max money from houses up to i-1\n\n    prev2 = nums[0]\n    prev1 = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        current = max(prev1, nums[i] + prev2)\n        prev2 = prev1\n        prev1 = current\n\n    return prev1",
    "testCases": [
      {
        "input": "[1, 2, 3, 1]",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[2, 7, 9, 3, 1]",
        "expectedOutput": "12",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[5]",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[2, 1, 1, 2]",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 3, 1, 3, 100]",
        "expectedOutput": "103",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "At each house, you have two choices: rob it or skip it",
      "If you rob house i, you cannot rob house i-1",
      "dp[i] = max(dp[i-1], nums[i] + dp[i-2])"
    ]
  },
  {
    "id": "cs201-ex-5-8",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "House Robber II - Circular",
    "description": "This is an extension of the House Robber problem. All houses are arranged in a circle, meaning the first house is the neighbor of the last one.\n\nYou cannot rob both the first and last house. Given an array of non-negative integers representing the amount of money of each house, return the maximum amount of money you can rob.\n\nExample:\n- Input: nums = [2, 3, 2]\n- Output: 3\n- Explanation: You cannot rob house 1 (money = 2) and house 3 (money = 2), since they are adjacent. Rob house 2 (money = 3).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def rob_circular(nums: list[int]) -> int:\n    \"\"\"\n    Calculate the maximum amount of money that can be robbed from circular houses.\n\n    Args:\n        nums: List of money in each house\n\n    Returns:\n        The maximum amount that can be robbed\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def rob_circular(nums: list[int]) -> int:\n    \"\"\"\n    Calculate the maximum amount of money that can be robbed from circular houses.\n\n    Args:\n        nums: List of money in each house\n\n    Returns:\n        The maximum amount that can be robbed\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n\n    def rob_linear(houses):\n        if not houses:\n            return 0\n        if len(houses) == 1:\n            return houses[0]\n\n        prev2 = houses[0]\n        prev1 = max(houses[0], houses[1])\n\n        for i in range(2, len(houses)):\n            current = max(prev1, houses[i] + prev2)\n            prev2 = prev1\n            prev1 = current\n\n        return prev1\n\n    # Case 1: Rob houses from 0 to n-2 (exclude last house)\n    # Case 2: Rob houses from 1 to n-1 (exclude first house)\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))",
    "testCases": [
      {
        "input": "[2, 3, 2]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 2, 3, 1]",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[5, 1, 1, 5]",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 1, 1, 2]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Since houses are in a circle, you cannot rob both first and last house",
      "Break the problem into two cases: exclude first house OR exclude last house",
      "Run the linear House Robber algorithm on both cases and take the maximum"
    ]
  },
  {
    "id": "cs201-ex-5-9",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Coin Change - Minimum Coins",
    "description": "You are given an array of coin denominations and a target amount. Return the fewest number of coins needed to make up that amount. If the amount cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nExample:\n- Input: coins = [1, 2, 5], amount = 11\n- Output: 3\n- Explanation: 11 = 5 + 5 + 1 (3 coins)",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def coin_change(coins: list[int], amount: int) -> int:\n    \"\"\"\n    Find the minimum number of coins needed to make the amount.\n\n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n\n    Returns:\n        Minimum number of coins needed, or -1 if impossible\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def coin_change(coins: list[int], amount: int) -> int:\n    \"\"\"\n    Find the minimum number of coins needed to make the amount.\n\n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n\n    Returns:\n        Minimum number of coins needed, or -1 if impossible\n    \"\"\"\n    # dp[i] represents the minimum number of coins needed to make amount i\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # 0 coins needed to make amount 0\n\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] != float('inf') else -1",
    "testCases": [
      {
        "input": "[1, 2, 5], 11",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[2], 3",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1], 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 3, 4], 6",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 5, 10, 25], 63",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "dp[i] represents the minimum coins needed to make amount i",
      "For each amount, try using each coin and take the minimum",
      "dp[i] = min(dp[i], dp[i - coin] + 1) for each coin"
    ]
  },
  {
    "id": "cs201-ex-5-10",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Coin Change - Number of Ways",
    "description": "You are given an array of coin denominations and a target amount. Return the number of combinations that make up that amount.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nExample:\n- Input: coins = [1, 2, 5], amount = 5\n- Output: 4\n- Explanation: There are four ways to make amount 5:\n  - 5 = 5\n  - 5 = 2 + 2 + 1\n  - 5 = 2 + 1 + 1 + 1\n  - 5 = 1 + 1 + 1 + 1 + 1",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def coin_change_ways(coins: list[int], amount: int) -> int:\n    \"\"\"\n    Find the number of ways to make the amount using the coins.\n\n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n\n    Returns:\n        Number of combinations that make up the amount\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def coin_change_ways(coins: list[int], amount: int) -> int:\n    \"\"\"\n    Find the number of ways to make the amount using the coins.\n\n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n\n    Returns:\n        Number of combinations that make up the amount\n    \"\"\"\n    # dp[i] represents the number of ways to make amount i\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to make amount 0: use no coins\n\n    # Process each coin one at a time to avoid counting permutations\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n\n    return dp[amount]",
    "testCases": [
      {
        "input": "[1, 2, 5], 5",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[2], 3",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10], 10",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 2, 3], 4",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 5, 10, 25], 100",
        "expectedOutput": "242",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "This counts combinations, not permutations",
      "Process coins one at a time to avoid counting duplicates",
      "dp[i] += dp[i - coin] for each coin and amount"
    ]
  },
  {
    "id": "cs201-ex-5-11",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Rod Cutting Problem",
    "description": "Given a rod of length n and an array of prices where prices[i] denotes the price of a rod of length i+1, determine the maximum value obtainable by cutting up the rod and selling the pieces.\n\nExample:\n- Input: prices = [1, 5, 8, 9, 10, 17, 17, 20], length = 4\n- Output: 10\n- Explanation: Maximum value is 10, obtained by cutting the rod into two pieces of length 2 each (5 + 5 = 10).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def rod_cutting(prices: list[int], length: int) -> int:\n    \"\"\"\n    Find the maximum value obtainable by cutting up the rod.\n\n    Args:\n        prices: List where prices[i] is the price of a rod of length i+1\n        length: The length of the rod\n\n    Returns:\n        Maximum value obtainable\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def rod_cutting(prices: list[int], length: int) -> int:\n    \"\"\"\n    Find the maximum value obtainable by cutting up the rod.\n\n    Args:\n        prices: List where prices[i] is the price of a rod of length i+1\n        length: The length of the rod\n\n    Returns:\n        Maximum value obtainable\n    \"\"\"\n    # dp[i] represents the maximum value obtainable for a rod of length i\n    dp = [0] * (length + 1)\n\n    for i in range(1, length + 1):\n        max_value = 0\n        # Try all possible first cuts\n        for j in range(i):\n            # j+1 is the length of the first piece (prices[j])\n            # i-j-1 is the remaining length\n            max_value = max(max_value, prices[j] + dp[i - j - 1])\n        dp[i] = max_value\n\n    return dp[length]",
    "testCases": [
      {
        "input": "[1, 5, 8, 9, 10, 17, 17, 20], 4",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[3, 5, 8, 9, 10, 17, 17, 20], 8",
        "expectedOutput": "24",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 5, 8, 9], 2",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[2, 5, 7, 8, 10], 5",
        "expectedOutput": "12",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 1, 1, 1, 1], 5",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "dp[i] represents the maximum value for a rod of length i",
      "Try all possible positions for the first cut",
      "For each cut at position j, the value is prices[j] + dp[remaining_length]"
    ]
  },
  {
    "id": "cs201-ex-5-12",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Rod Cutting with Costs",
    "description": "This is an extension of the rod cutting problem. Now, each cut has a cost associated with it.\n\nGiven a rod of length n, an array of prices, and a cost per cut, determine the maximum profit obtainable by cutting up the rod and selling the pieces (profit = total price - cutting costs).\n\nExample:\n- Input: prices = [1, 5, 8, 9], length = 4, cost_per_cut = 1\n- Output: 8\n- Explanation: Cut into two pieces of length 2 each. Value = 5 + 5 = 10, Cost = 1 cut = 1, Profit = 9. But keeping length 4 gives 9 with no cuts. Best is actually two length-2 pieces: 5+5-1=9, or length 1 and 3: 1+8-1=8.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def rod_cutting_with_cost(prices: list[int], length: int, cost_per_cut: int) -> int:\n    \"\"\"\n    Find the maximum profit obtainable by cutting up the rod.\n\n    Args:\n        prices: List where prices[i] is the price of a rod of length i+1\n        length: The length of the rod\n        cost_per_cut: The cost of making each cut\n\n    Returns:\n        Maximum profit obtainable\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def rod_cutting_with_cost(prices: list[int], length: int, cost_per_cut: int) -> int:\n    \"\"\"\n    Find the maximum profit obtainable by cutting up the rod.\n\n    Args:\n        prices: List where prices[i] is the price of a rod of length i+1\n        length: The length of the rod\n        cost_per_cut: The cost of making each cut\n\n    Returns:\n        Maximum profit obtainable\n    \"\"\"\n    # dp[i] represents the maximum profit for a rod of length i\n    dp = [0] * (length + 1)\n\n    for i in range(1, length + 1):\n        # Option 1: Don't cut at all\n        max_profit = prices[i - 1] if i <= len(prices) else 0\n\n        # Option 2: Make cuts\n        for j in range(1, i):\n            # Cut into piece of length j and remaining length i-j\n            # This costs one cut\n            profit = prices[j - 1] + dp[i - j] - cost_per_cut\n            max_profit = max(max_profit, profit)\n\n        dp[i] = max_profit\n\n    return dp[length]",
    "testCases": [
      {
        "input": "[1, 5, 8, 9], 4, 1",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 5, 8, 9, 10, 17, 17, 20], 8, 2",
        "expectedOutput": "18",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[3, 5, 8, 9], 3, 0",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[2, 5, 7, 8], 4, 3",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 5, 8, 9], 2, 10",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Consider the option of not making any cuts at all",
      "When making a cut, subtract the cost_per_cut from the profit",
      "Compare no-cut profit with all possible cutting strategies"
    ]
  },
  {
    "id": "cs201-ex-5-13",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence (LCS). A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\nIf there is no common subsequence, return 0.\n\nExample:\n- Input: text1 = \"abcde\", text2 = \"ace\"\n- Output: 3\n- Explanation: The longest common subsequence is \"ace\" with length 3.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence.\n\n    Args:\n        text1: First string\n        text2: Second string\n\n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence.\n\n    Args:\n        text1: First string\n        text2: Second string\n\n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    m, n = len(text1), len(text2)\n\n    # dp[i][j] represents LCS length of text1[0:i] and text2[0:j]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                # Characters match: add 1 to LCS of previous strings\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                # Characters don't match: take max of excluding one character\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]",
    "testCases": [
      {
        "input": "\"abcde\", \"ace\"",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"abc\", \"abc\"",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"abc\", \"def\"",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"aggtab\", \"gxtxayb\"",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"programming\", \"gaming\"",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use a 2D DP table where dp[i][j] represents LCS of text1[0:i] and text2[0:j]",
      "If characters match, dp[i][j] = dp[i-1][j-1] + 1",
      "If they don't match, dp[i][j] = max(dp[i-1][j], dp[i][j-1])"
    ]
  },
  {
    "id": "cs201-ex-5-14",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Longest Common Subsequence - Reconstruction",
    "description": "Given two strings, not only find the length of their longest common subsequence, but also return the actual subsequence string.\n\nExample:\n- Input: text1 = \"abcde\", text2 = \"ace\"\n- Output: \"ace\"\n- Explanation: The longest common subsequence is \"ace\".",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def lcs_string(text1: str, text2: str) -> str:\n    \"\"\"\n    Find the longest common subsequence string.\n\n    Args:\n        text1: First string\n        text2: Second string\n\n    Returns:\n        The longest common subsequence as a string\n    \"\"\"\n    # TODO: Implement using dynamic programming with backtracking\n    pass",
    "solution": "def lcs_string(text1: str, text2: str) -> str:\n    \"\"\"\n    Find the longest common subsequence string.\n\n    Args:\n        text1: First string\n        text2: Second string\n\n    Returns:\n        The longest common subsequence as a string\n    \"\"\"\n    m, n = len(text1), len(text2)\n\n    # Build the DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Backtrack to reconstruct the LCS\n    lcs = []\n    i, j = m, n\n\n    while i > 0 and j > 0:\n        if text1[i - 1] == text2[j - 1]:\n            # This character is part of LCS\n            lcs.append(text1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Reverse since we built it backwards\n    return ''.join(reversed(lcs))",
    "testCases": [
      {
        "input": "\"abcde\", \"ace\"",
        "expectedOutput": "\"ace\"",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"abc\", \"abc\"",
        "expectedOutput": "\"abc\"",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"abc\", \"def\"",
        "expectedOutput": "\"\"",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"aggtab\", \"gxtxayb\"",
        "expectedOutput": "\"gtab\"",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "\"AGGTAB\", \"GXTXAYB\"",
        "expectedOutput": "\"GTAB\"",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "First build the DP table as in the standard LCS problem",
      "Then backtrack from dp[m][n] to reconstruct the sequence",
      "When characters match, include that character and move diagonally",
      "When they don't match, move in the direction of the larger value"
    ]
  },
  {
    "id": "cs201-ex-5-15",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "0/1 Knapsack Problem",
    "description": "Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.\n\nEach item can be included at most once (0/1 choice). You cannot break an item.\n\nExample:\n- Input: values = [60, 100, 120], weights = [10, 20, 30], capacity = 50\n- Output: 220\n- Explanation: Take items with values 100 and 120 (weights 20 + 30 = 50).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def knapsack_01(values: list[int], weights: list[int], capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem.\n\n    Args:\n        values: List of values for each item\n        weights: List of weights for each item\n        capacity: Maximum weight capacity of the knapsack\n\n    Returns:\n        Maximum value that can be obtained\n    \"\"\"\n    # TODO: Implement using dynamic programming\n    pass",
    "solution": "def knapsack_01(values: list[int], weights: list[int], capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem.\n\n    Args:\n        values: List of values for each item\n        weights: List of weights for each item\n        capacity: Maximum weight capacity of the knapsack\n\n    Returns:\n        Maximum value that can be obtained\n    \"\"\"\n    n = len(values)\n\n    # dp[i][w] represents max value using first i items with capacity w\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            # Option 1: Don't include item i-1\n            dp[i][w] = dp[i - 1][w]\n\n            # Option 2: Include item i-1 (if it fits)\n            if weights[i - 1] <= w:\n                include_value = values[i - 1] + dp[i - 1][w - weights[i - 1]]\n                dp[i][w] = max(dp[i][w], include_value)\n\n    return dp[n][capacity]",
    "testCases": [
      {
        "input": "[60, 100, 120], [10, 20, 30], 50",
        "expectedOutput": "220",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10, 20, 30], [1, 2, 3], 5",
        "expectedOutput": "50",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 4, 5, 7], [1, 3, 4, 5], 7",
        "expectedOutput": "9",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10], [5], 10",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10, 20, 30], [5, 10, 15], 10",
        "expectedOutput": "30",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use a 2D DP table where dp[i][w] represents max value with first i items and capacity w",
      "For each item, you have two choices: include it or exclude it",
      "If including item i, add its value to dp[i-1][w-weight[i]]"
    ]
  },
  {
    "id": "cs201-ex-5-16",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "0/1 Knapsack - Space Optimized",
    "description": "Solve the 0/1 knapsack problem with space optimization. Instead of using a 2D table, optimize to use only O(W) space where W is the capacity.\n\nThis is the same problem as the standard 0/1 knapsack, but with better space complexity.\n\nExample:\n- Input: values = [60, 100, 120], weights = [10, 20, 30], capacity = 50\n- Output: 220",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def knapsack_optimized(values: list[int], weights: list[int], capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem with O(W) space complexity.\n\n    Args:\n        values: List of values for each item\n        weights: List of weights for each item\n        capacity: Maximum weight capacity of the knapsack\n\n    Returns:\n        Maximum value that can be obtained\n    \"\"\"\n    # TODO: Implement space-optimized version\n    pass",
    "solution": "def knapsack_optimized(values: list[int], weights: list[int], capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem with O(W) space complexity.\n\n    Args:\n        values: List of values for each item\n        weights: List of weights for each item\n        capacity: Maximum weight capacity of the knapsack\n\n    Returns:\n        Maximum value that can be obtained\n    \"\"\"\n    n = len(values)\n\n    # Use a 1D array instead of 2D\n    # dp[w] represents max value with capacity w\n    dp = [0] * (capacity + 1)\n\n    for i in range(n):\n        # Traverse from right to left to avoid using updated values\n        for w in range(capacity, weights[i] - 1, -1):\n            # Choose max of: not including item i, or including item i\n            dp[w] = max(dp[w], values[i] + dp[w - weights[i]])\n\n    return dp[capacity]",
    "testCases": [
      {
        "input": "[60, 100, 120], [10, 20, 30], 50",
        "expectedOutput": "220",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10, 20, 30], [1, 2, 3], 5",
        "expectedOutput": "50",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 4, 5, 7], [1, 3, 4, 5], 7",
        "expectedOutput": "9",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10], [5], 10",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[10, 20, 30], [5, 10, 15], 10",
        "expectedOutput": "30",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use a 1D array instead of 2D to save space",
      "Traverse the capacity from right to left to avoid overwriting values you still need",
      "This achieves O(W) space instead of O(nW)"
    ]
  },
  {
    "id": "cs201-ex-6-1",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Basic Activity Selection",
    "description": "Given activities with start and finish times, select the maximum number of non-overlapping activities. Sort by finish time and greedily select activities.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def activity_selection(activities):\n    # activities is a list of tuples (start, finish)\n    # Return list of selected activities\n    pass",
    "solution": "def activity_selection(activities):\n    if not activities:\n        return []\n    # Sort by finish time\n    sorted_activities = sorted(activities, key=lambda x: x[1])\n    selected = [sorted_activities[0]]\n    last_finish = sorted_activities[0][1]\n    \n    for i in range(1, len(sorted_activities)):\n        if sorted_activities[i][0] >= last_finish:\n            selected.append(sorted_activities[i])\n            last_finish = sorted_activities[i][1]\n    \n    return selected",
    "testCases": [
      {
        "input": "[(1, 3), (2, 5), (4, 7), (1, 8), (5, 9)]",
        "expectedOutput": "[(1, 3), (4, 7), (5, 9)]",
        "isHidden": false,
        "description": "Multiple activities"
      },
      {
        "input": "[(1, 2), (2, 3), (3, 4)]",
        "expectedOutput": "[(1, 2), (2, 3), (3, 4)]",
        "isHidden": false,
        "description": "All compatible"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty input"
      }
    ],
    "hints": [
      "Sort activities by finish time.",
      "Greedily select the first activity that doesn't overlap with the last selected."
    ]
  },
  {
    "id": "cs201-ex-6-2",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Activity Selection Count",
    "description": "Return the count of maximum non-overlapping activities that can be selected.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def max_activities_count(activities):\n    # activities is a list of tuples (start, finish)\n    # Return the maximum count\n    pass",
    "solution": "def max_activities_count(activities):\n    if not activities:\n        return 0\n    sorted_activities = sorted(activities, key=lambda x: x[1])\n    count = 1\n    last_finish = sorted_activities[0][1]\n    \n    for i in range(1, len(sorted_activities)):\n        if sorted_activities[i][0] >= last_finish:\n            count += 1\n            last_finish = sorted_activities[i][1]\n    \n    return count",
    "testCases": [
      {
        "input": "[(1, 3), (2, 5), (4, 7), (1, 8), (5, 9)]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Multiple activities"
      },
      {
        "input": "[(1, 10), (2, 3), (4, 5)]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Long overlapping activity"
      },
      {
        "input": "[(1, 2)]",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Single activity"
      }
    ],
    "hints": [
      "Similar to activity selection, but return count.",
      "Greedy choice: earliest finish time."
    ]
  },
  {
    "id": "cs201-ex-6-3",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Activity Selection with Weights",
    "description": "Each activity has a value. Find the maximum value of non-overlapping activities. Note: This is more complex than basic greedy and might need dynamic programming for optimal solution, but use greedy by value/duration ratio.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def weighted_activity_selection(activities):\n    # activities is a list of tuples (start, finish, value)\n    # Return maximum total value (greedy approach)\n    pass",
    "solution": "def weighted_activity_selection(activities):\n    if not activities:\n        return 0\n    # Greedy: sort by value/duration ratio\n    def ratio(act):\n        duration = act[1] - act[0]\n        if duration == 0:\n            return float('inf')\n        return act[2] / duration\n    \n    sorted_activities = sorted(activities, key=ratio, reverse=True)\n    selected_value = 0\n    last_finish = 0\n    \n    for act in sorted_activities:\n        if act[0] >= last_finish:\n            selected_value += act[2]\n            last_finish = act[1]\n    \n    return selected_value",
    "testCases": [
      {
        "input": "[(1, 3, 20), (2, 5, 30), (4, 7, 25)]",
        "expectedOutput": "45",
        "isHidden": false,
        "description": "Select by value/duration"
      },
      {
        "input": "[(0, 2, 10), (1, 3, 20), (2, 4, 15)]",
        "expectedOutput": "30",
        "isHidden": false,
        "description": "High value activities"
      },
      {
        "input": "[]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Empty activities"
      }
    ],
    "hints": [
      "Try greedy approach: select by value/duration ratio.",
      "This gives good results but may not always be optimal."
    ]
  },
  {
    "id": "cs201-ex-6-4",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Minimum Rooms Required",
    "description": "Given meeting times, find the minimum number of rooms required to schedule all meetings.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def min_rooms(meetings):\n    # meetings is a list of tuples (start, end)\n    # Return minimum rooms needed\n    pass",
    "solution": "def min_rooms(meetings):\n    if not meetings:\n        return 0\n    \n    starts = sorted([m[0] for m in meetings])\n    ends = sorted([m[1] for m in meetings])\n    \n    rooms = 0\n    max_rooms = 0\n    i = j = 0\n    \n    while i < len(starts):\n        if starts[i] < ends[j]:\n            rooms += 1\n            max_rooms = max(max_rooms, rooms)\n            i += 1\n        else:\n            rooms -= 1\n            j += 1\n    \n    return max_rooms",
    "testCases": [
      {
        "input": "[(0, 30), (5, 10), (15, 20)]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Overlapping meetings"
      },
      {
        "input": "[(1, 5), (2, 3), (4, 6), (5, 7)]",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Multiple overlaps"
      },
      {
        "input": "[(1, 2), (3, 4)]",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "No overlap"
      }
    ],
    "hints": [
      "Separate start and end times.",
      "Sort both arrays separately.",
      "Track how many meetings are active at any time."
    ]
  },
  {
    "id": "cs201-ex-6-5",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Fractional Knapsack Basic",
    "description": "Given items with weights and values, and a knapsack capacity, maximize value. You can take fractions of items. Use greedy approach: sort by value/weight ratio.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def fractional_knapsack(capacity, items):\n    # items is a list of tuples (weight, value)\n    # Return maximum value\n    pass",
    "solution": "def fractional_knapsack(capacity, items):\n    if not items or capacity <= 0:\n        return 0.0\n    \n    # Sort by value/weight ratio in descending order\n    items_ratio = [(v/w, w, v) for w, v in items]\n    items_ratio.sort(reverse=True)\n    \n    total_value = 0.0\n    remaining_capacity = capacity\n    \n    for ratio, weight, value in items_ratio:\n        if remaining_capacity >= weight:\n            total_value += value\n            remaining_capacity -= weight\n        else:\n            total_value += ratio * remaining_capacity\n            break\n    \n    return total_value",
    "testCases": [
      {
        "input": "50, [(20, 100), (10, 60), (30, 120)]",
        "expectedOutput": "240.0",
        "isHidden": false,
        "description": "Full capacity used"
      },
      {
        "input": "10, [(5, 50), (10, 100), (20, 200)]",
        "expectedOutput": "110.0",
        "isHidden": false,
        "description": "Partial item taken"
      },
      {
        "input": "0, [(10, 50)]",
        "expectedOutput": "0.0",
        "isHidden": true,
        "description": "Zero capacity"
      }
    ],
    "hints": [
      "Sort items by value/weight ratio.",
      "Greedily take items with highest ratio first.",
      "Take fraction of last item if needed."
    ]
  },
  {
    "id": "cs201-ex-6-6",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Fractional Knapsack with Selection",
    "description": "Return both the maximum value and the list of items (with fractions) selected.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def fractional_knapsack_selection(capacity, items):\n    # items is a list of tuples (weight, value)\n    # Return (max_value, selected_items)\n    # selected_items is list of (weight, value, fraction_taken)\n    pass",
    "solution": "def fractional_knapsack_selection(capacity, items):\n    if not items or capacity <= 0:\n        return (0.0, [])\n    \n    items_with_idx = [(v/w, w, v, i) for i, (w, v) in enumerate(items)]\n    items_with_idx.sort(reverse=True)\n    \n    total_value = 0.0\n    remaining_capacity = capacity\n    selected = []\n    \n    for ratio, weight, value, idx in items_with_idx:\n        if remaining_capacity >= weight:\n            total_value += value\n            remaining_capacity -= weight\n            selected.append((weight, value, 1.0))\n        elif remaining_capacity > 0:\n            fraction = remaining_capacity / weight\n            total_value += value * fraction\n            selected.append((weight, value, fraction))\n            break\n    \n    return (total_value, selected)",
    "testCases": [
      {
        "input": "50, [(20, 100), (10, 60), (30, 120)]",
        "expectedOutput": "(240.0, [(10, 60, 1.0), (20, 100, 1.0), (30, 120, 1.0)])",
        "isHidden": false,
        "description": "All items fit"
      },
      {
        "input": "15, [(10, 60), (20, 100)]",
        "expectedOutput": "(85.0, [(10, 60, 1.0), (20, 100, 0.25)])",
        "isHidden": false,
        "description": "Partial last item"
      }
    ],
    "hints": [
      "Track which items are selected and their fractions.",
      "Fraction is 1.0 for fully taken items."
    ]
  },
  {
    "id": "cs201-ex-6-7",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Multiple Knapsacks",
    "description": "Given multiple knapsacks with different capacities, distribute items to maximize total value using greedy approach.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def multiple_knapsacks(capacities, items):\n    # capacities is a list of knapsack capacities\n    # items is a list of tuples (weight, value)\n    # Return maximum total value\n    pass",
    "solution": "def multiple_knapsacks(capacities, items):\n    if not items or not capacities:\n        return 0.0\n    \n    # Sort items by value/weight ratio\n    items_ratio = [(v/w, w, v) for w, v in items]\n    items_ratio.sort(reverse=True)\n    \n    # Sort capacities in descending order\n    sorted_caps = sorted(capacities, reverse=True)\n    \n    total_value = 0.0\n    cap_idx = 0\n    remaining = sorted_caps[0] if sorted_caps else 0\n    \n    for ratio, weight, value in items_ratio:\n        while cap_idx < len(sorted_caps):\n            if remaining >= weight:\n                total_value += value\n                remaining -= weight\n                break\n            elif remaining > 0:\n                fraction = remaining / weight\n                total_value += value * fraction\n                remaining = 0\n                cap_idx += 1\n                if cap_idx < len(sorted_caps):\n                    remaining = sorted_caps[cap_idx]\n                break\n            else:\n                cap_idx += 1\n                if cap_idx < len(sorted_caps):\n                    remaining = sorted_caps[cap_idx]\n                else:\n                    break\n    \n    return total_value",
    "testCases": [
      {
        "input": "[30, 20], [(10, 60), (20, 100), (30, 120)]",
        "expectedOutput": "280.0",
        "isHidden": false,
        "description": "Two knapsacks"
      },
      {
        "input": "[10], [(5, 50), (10, 100)]",
        "expectedOutput": "150.0",
        "isHidden": false,
        "description": "One knapsack, partial fit"
      }
    ],
    "hints": [
      "Process items by value/weight ratio.",
      "Fill knapsacks one by one with highest ratio items."
    ]
  },
  {
    "id": "cs201-ex-6-8",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Bounded Fractional Knapsack",
    "description": "Each item has a limited quantity available. Maximize knapsack value.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def bounded_fractional_knapsack(capacity, items):\n    # items is list of tuples (weight, value, quantity)\n    # Return maximum value\n    pass",
    "solution": "def bounded_fractional_knapsack(capacity, items):\n    if not items or capacity <= 0:\n        return 0.0\n    \n    # Create expanded list with ratios\n    items_ratio = [(v/w, w, v, q) for w, v, q in items]\n    items_ratio.sort(reverse=True)\n    \n    total_value = 0.0\n    remaining_capacity = capacity\n    \n    for ratio, weight, value, quantity in items_ratio:\n        total_weight_available = weight * quantity\n        \n        if remaining_capacity >= total_weight_available:\n            total_value += value * quantity\n            remaining_capacity -= total_weight_available\n        else:\n            # Take as much as we can\n            items_can_take = remaining_capacity / weight\n            total_value += value * items_can_take\n            break\n    \n    return total_value",
    "testCases": [
      {
        "input": "50, [(10, 60, 2), (20, 100, 1)]",
        "expectedOutput": "220.0",
        "isHidden": false,
        "description": "Multiple quantities"
      },
      {
        "input": "25, [(10, 100, 5)]",
        "expectedOutput": "250.0",
        "isHidden": false,
        "description": "Take partial quantity"
      },
      {
        "input": "100, [(10, 50, 3), (20, 120, 2)]",
        "expectedOutput": "390.0",
        "isHidden": true,
        "description": "All items fit"
      }
    ],
    "hints": [
      "Consider total available weight for each item type.",
      "May take fractional quantity of last item type."
    ]
  },
  {
    "id": "cs201-ex-6-9",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Coin Change Greedy",
    "description": "Given coin denominations [1, 5, 10, 25] and an amount, return minimum coins needed using greedy approach (works for these denominations).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def min_coins_greedy(amount):\n    # Use standard US coins: [1, 5, 10, 25]\n    # Return minimum number of coins\n    pass",
    "solution": "def min_coins_greedy(amount):\n    coins = [25, 10, 5, 1]\n    count = 0\n    \n    for coin in coins:\n        if amount >= coin:\n            count += amount // coin\n            amount = amount % coin\n    \n    return count",
    "testCases": [
      {
        "input": "41",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "25+10+5+1"
      },
      {
        "input": "99",
        "expectedOutput": "9",
        "isHidden": false,
        "description": "Multiple coins"
      },
      {
        "input": "1",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Single penny"
      }
    ],
    "hints": [
      "Start with largest denomination.",
      "Take as many as possible, then move to next."
    ]
  },
  {
    "id": "cs201-ex-6-10",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Coin Change with Denominations",
    "description": "Given custom coin denominations and an amount, use greedy approach to find minimum coins. Note: greedy may not always give optimal solution for arbitrary denominations.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def min_coins_custom(amount, denominations):\n    # denominations is a list of coin values\n    # Return minimum number of coins (greedy approach)\n    pass",
    "solution": "def min_coins_custom(amount, denominations):\n    if amount == 0:\n        return 0\n    \n    denominations = sorted(denominations, reverse=True)\n    count = 0\n    \n    for coin in denominations:\n        if amount >= coin:\n            count += amount // coin\n            amount = amount % coin\n    \n    if amount > 0:\n        return -1  # Cannot make exact change\n    \n    return count",
    "testCases": [
      {
        "input": "11, [1, 5, 6]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Greedy gives 6+5, optimal is 6+5"
      },
      {
        "input": "30, [1, 10, 25]",
        "expectedOutput": "6",
        "isHidden": false,
        "description": "25+1+1+1+1+1"
      },
      {
        "input": "7, [3, 5]",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Cannot make change"
      }
    ],
    "hints": [
      "Sort denominations in descending order.",
      "Greedy doesn't always give optimal for arbitrary coins."
    ]
  },
  {
    "id": "cs201-ex-6-11",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Making Change with Coin List",
    "description": "Return the actual list of coins used to make change, not just the count.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def make_change(amount):\n    # Use standard US coins: [1, 5, 10, 25]\n    # Return list of coins used\n    pass",
    "solution": "def make_change(amount):\n    coins = [25, 10, 5, 1]\n    result = []\n    \n    for coin in coins:\n        while amount >= coin:\n            result.append(coin)\n            amount -= coin\n    \n    return result",
    "testCases": [
      {
        "input": "41",
        "expectedOutput": "[25, 10, 5, 1]",
        "isHidden": false,
        "description": "One of each large coin"
      },
      {
        "input": "30",
        "expectedOutput": "[25, 5]",
        "isHidden": false,
        "description": "Two coins"
      },
      {
        "input": "3",
        "expectedOutput": "[1, 1, 1]",
        "isHidden": true,
        "description": "Only pennies"
      }
    ],
    "hints": [
      "Build the list as you select coins.",
      "Add coins to result as you use them."
    ]
  },
  {
    "id": "cs201-ex-6-12",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Cashier Problem",
    "description": "Given the cost and amount paid, return the change using minimum coins.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def cashier_change(cost, paid):\n    # Return dictionary of {coin_value: count}\n    # Use coins: [1, 5, 10, 25, 100]\n    pass",
    "solution": "def cashier_change(cost, paid):\n    change = paid - cost\n    if change < 0:\n        return {}\n    \n    coins = [100, 25, 10, 5, 1]\n    result = {}\n    \n    for coin in coins:\n        if change >= coin:\n            count = change // coin\n            result[coin] = count\n            change = change % coin\n    \n    return result",
    "testCases": [
      {
        "input": "157, 200",
        "expectedOutput": "{25: 1, 10: 1, 5: 1, 1: 3}",
        "isHidden": false,
        "description": "Change of 43 cents"
      },
      {
        "input": "50, 100",
        "expectedOutput": "{25: 2}",
        "isHidden": false,
        "description": "Even 50 cents"
      },
      {
        "input": "100, 100",
        "expectedOutput": "{}",
        "isHidden": true,
        "description": "No change needed"
      }
    ],
    "hints": [
      "Calculate change first.",
      "Build dictionary with coin counts."
    ]
  },
  {
    "id": "cs201-ex-6-13",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Job Scheduling - Minimize Completion Time",
    "description": "Given jobs with processing times, schedule them to minimize total completion time. Greedy: process shortest job first.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def schedule_jobs(jobs):\n    # jobs is list of processing times\n    # Return order of job indices and total completion time\n    pass",
    "solution": "def schedule_jobs(jobs):\n    if not jobs:\n        return ([], 0)\n    \n    # Create list of (time, original_index)\n    indexed_jobs = [(time, i) for i, time in enumerate(jobs)]\n    # Sort by processing time (shortest first)\n    indexed_jobs.sort()\n    \n    order = [idx for time, idx in indexed_jobs]\n    \n    # Calculate total completion time\n    total_completion = 0\n    current_time = 0\n    for time, idx in indexed_jobs:\n        current_time += time\n        total_completion += current_time\n    \n    return (order, total_completion)",
    "testCases": [
      {
        "input": "[3, 1, 2]",
        "expectedOutput": "([1, 2, 0], 10)",
        "isHidden": false,
        "description": "Three jobs"
      },
      {
        "input": "[5, 2, 3]",
        "expectedOutput": "([1, 2, 0], 17)",
        "isHidden": false,
        "description": "Shortest job first"
      },
      {
        "input": "[1]",
        "expectedOutput": "([0], 1)",
        "isHidden": true,
        "description": "Single job"
      }
    ],
    "hints": [
      "Sort jobs by processing time.",
      "Process shortest jobs first to minimize waiting."
    ]
  },
  {
    "id": "cs201-ex-6-14",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Job Scheduling with Deadlines",
    "description": "Each job has a deadline and profit. Schedule jobs to maximize profit (each job takes 1 unit time).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def schedule_with_deadlines(jobs):\n    # jobs is list of tuples (deadline, profit)\n    # Return maximum profit\n    pass",
    "solution": "def schedule_with_deadlines(jobs):\n    if not jobs:\n        return 0\n    \n    # Sort by profit (descending)\n    sorted_jobs = sorted(jobs, key=lambda x: x[1], reverse=True)\n    \n    # Find maximum deadline\n    max_deadline = max(job[0] for job in jobs)\n    \n    # Create schedule slots\n    schedule = [-1] * max_deadline\n    total_profit = 0\n    \n    for deadline, profit in sorted_jobs:\n        # Find latest available slot before deadline\n        for slot in range(min(deadline, max_deadline) - 1, -1, -1):\n            if schedule[slot] == -1:\n                schedule[slot] = profit\n                total_profit += profit\n                break\n    \n    return total_profit",
    "testCases": [
      {
        "input": "[(2, 100), (1, 50), (2, 10), (1, 20)]",
        "expectedOutput": "150",
        "isHidden": false,
        "description": "Schedule highest profit jobs"
      },
      {
        "input": "[(3, 20), (1, 10), (2, 40), (3, 30)]",
        "expectedOutput": "90",
        "isHidden": false,
        "description": "Multiple deadlines"
      },
      {
        "input": "[(1, 100), (1, 50)]",
        "expectedOutput": "100",
        "isHidden": true,
        "description": "Conflicting deadlines"
      }
    ],
    "hints": [
      "Sort jobs by profit (highest first).",
      "For each job, find latest available slot before deadline."
    ]
  },
  {
    "id": "cs201-ex-6-15",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Interval Partitioning",
    "description": "Given intervals, partition them into minimum number of groups such that no two intervals in same group overlap.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def interval_partitioning(intervals):\n    # intervals is list of tuples (start, end)\n    # Return minimum number of partitions needed\n    pass",
    "solution": "def interval_partitioning(intervals):\n    if not intervals:\n        return 0\n    \n    # Sort by start time\n    intervals.sort()\n    \n    # Use list to track end time of each partition\n    partitions = []\n    \n    for start, end in intervals:\n        # Find partition where this interval can fit\n        placed = False\n        for i in range(len(partitions)):\n            if start >= partitions[i]:\n                partitions[i] = end\n                placed = True\n                break\n        \n        if not placed:\n            partitions.append(end)\n    \n    return len(partitions)",
    "testCases": [
      {
        "input": "[(1, 3), (2, 5), (4, 7), (6, 9)]",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Two partitions needed"
      },
      {
        "input": "[(1, 2), (2, 3), (3, 4)]",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "All non-overlapping"
      },
      {
        "input": "[(1, 5), (2, 6), (3, 7)]",
        "expectedOutput": "3",
        "isHidden": true,
        "description": "All overlapping"
      }
    ],
    "hints": [
      "Sort intervals by start time.",
      "Track end time of last interval in each partition.",
      "Similar to minimum rooms problem."
    ]
  },
  {
    "id": "cs201-ex-6-16",
    "subjectId": "cs201",
    "topicId": "cs201-6",
    "title": "Huffman Encoding Frequencies",
    "description": "Given character frequencies, build a Huffman tree and return the total encoding length. This is a simplified version focusing on the greedy merging process.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def huffman_encoding_length(frequencies):\n    # frequencies is a list of character frequencies\n    # Return total bits needed for encoding\n    pass",
    "solution": "def huffman_encoding_length(frequencies):\n    import heapq\n    \n    if not frequencies:\n        return 0\n    if len(frequencies) == 1:\n        return frequencies[0]\n    \n    # Use min heap\n    heap = frequencies[:]\n    heapq.heapify(heap)\n    \n    total_cost = 0\n    \n    while len(heap) > 1:\n        # Get two minimum frequency nodes\n        freq1 = heapq.heappop(heap)\n        freq2 = heapq.heappop(heap)\n        \n        # Merge them\n        merged = freq1 + freq2\n        total_cost += merged\n        \n        # Add back to heap\n        heapq.heappush(heap, merged)\n    \n    return total_cost",
    "testCases": [
      {
        "input": "[5, 9, 12, 13, 16, 45]",
        "expectedOutput": "224",
        "isHidden": false,
        "description": "Standard Huffman example"
      },
      {
        "input": "[1, 1, 1, 1]",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Equal frequencies"
      },
      {
        "input": "[10, 20]",
        "expectedOutput": "30",
        "isHidden": true,
        "description": "Two characters"
      }
    ],
    "hints": [
      "Use a min heap to efficiently get two smallest frequencies.",
      "Total cost is sum of all internal node frequencies.",
      "Greedy: always merge two smallest frequency nodes."
    ]
  },
  {
    "id": "cs201-ex-7-1",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Build Adjacency List from Edges",
    "description": "Given a list of edges, create an adjacency list representation of an undirected graph. Each edge is a tuple (u, v) representing a connection between vertices u and v.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def build_adjacency_list(edges, num_vertices):\n    \"\"\"\n    Build an adjacency list from a list of edges.\n\n    Args:\n        edges: List of tuples (u, v) representing edges\n        num_vertices: Total number of vertices (0 to num_vertices-1)\n\n    Returns:\n        Dictionary where keys are vertices and values are lists of adjacent vertices\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def build_adjacency_list(edges, num_vertices):\n    \"\"\"\n    Build an adjacency list from a list of edges.\n\n    Args:\n        edges: List of tuples (u, v) representing edges\n        num_vertices: Total number of vertices (0 to num_vertices-1)\n\n    Returns:\n        Dictionary where keys are vertices and values are lists of adjacent vertices\n    \"\"\"\n    # Initialize adjacency list with empty lists for each vertex\n    adj_list = {i: [] for i in range(num_vertices)}\n\n    # Add edges to adjacency list (undirected graph)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    return adj_list",
    "testCases": [
      {
        "input": "[(0, 1), (0, 2), (1, 2), (2, 3)], 4",
        "expectedOutput": "{0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2]}",
        "isHidden": false,
        "description": "Simple 4-vertex graph"
      },
      {
        "input": "[], 3",
        "expectedOutput": "{0: [], 1: [], 2: []}",
        "isHidden": false,
        "description": "Graph with no edges"
      },
      {
        "input": "[(0, 1), (1, 2), (2, 3), (3, 4)], 5",
        "expectedOutput": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2, 4], 4: [3]}",
        "isHidden": false,
        "description": "Linear graph (chain)"
      }
    ],
    "hints": [
      "Initialize a dictionary with empty lists for each vertex",
      "For undirected graphs, add each edge in both directions",
      "Remember to handle vertices with no edges"
    ]
  },
  {
    "id": "cs201-ex-7-2",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Build Directed Adjacency List",
    "description": "Create an adjacency list for a directed graph. Each edge (u, v) should only create a connection from u to v, not vice versa.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def build_directed_adjacency_list(edges, num_vertices):\n    \"\"\"\n    Build an adjacency list for a directed graph.\n\n    Args:\n        edges: List of tuples (u, v) representing directed edges from u to v\n        num_vertices: Total number of vertices\n\n    Returns:\n        Dictionary representing directed adjacency list\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def build_directed_adjacency_list(edges, num_vertices):\n    \"\"\"\n    Build an adjacency list for a directed graph.\n\n    Args:\n        edges: List of tuples (u, v) representing directed edges from u to v\n        num_vertices: Total number of vertices\n\n    Returns:\n        Dictionary representing directed adjacency list\n    \"\"\"\n    # Initialize adjacency list\n    adj_list = {i: [] for i in range(num_vertices)}\n\n    # Add directed edges\n    for u, v in edges:\n        adj_list[u].append(v)\n\n    return adj_list",
    "testCases": [
      {
        "input": "[(0, 1), (0, 2), (1, 2), (2, 0)], 3",
        "expectedOutput": "{0: [1, 2], 1: [2], 2: [0]}",
        "isHidden": false,
        "description": "Directed graph with cycle"
      },
      {
        "input": "[(0, 1), (1, 2), (2, 3)], 4",
        "expectedOutput": "{0: [1], 1: [2], 2: [3], 3: []}",
        "isHidden": false,
        "description": "Directed acyclic graph (DAG)"
      },
      {
        "input": "[], 2",
        "expectedOutput": "{0: [], 1: []}",
        "isHidden": false,
        "description": "No edges"
      }
    ],
    "hints": [
      "For directed graphs, only add edge from u to v, not from v to u",
      "Some vertices may have no outgoing edges",
      "Initialize all vertices even if they have no edges"
    ]
  },
  {
    "id": "cs201-ex-7-3",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Adjacency List to Matrix",
    "description": "Convert an adjacency list representation to an adjacency matrix. For an undirected graph with n vertices, create an nn matrix where matrix[i][j] = 1 if there is an edge between i and j.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def adjacency_list_to_matrix(adj_list):\n    \"\"\"\n    Convert adjacency list to adjacency matrix.\n\n    Args:\n        adj_list: Dictionary where keys are vertices and values are lists of neighbors\n\n    Returns:\n        2D list (matrix) representing the graph\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def adjacency_list_to_matrix(adj_list):\n    \"\"\"\n    Convert adjacency list to adjacency matrix.\n\n    Args:\n        adj_list: Dictionary where keys are vertices and values are lists of neighbors\n\n    Returns:\n        2D list (matrix) representing the graph\n    \"\"\"\n    n = len(adj_list)\n    # Initialize matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill in the edges\n    for vertex, neighbors in adj_list.items():\n        for neighbor in neighbors:\n            matrix[vertex][neighbor] = 1\n\n    return matrix",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "expectedOutput": "[[0, 1, 1], [1, 0, 1], [1, 1, 0]]",
        "isHidden": false,
        "description": "Triangle graph"
      },
      {
        "input": "{0: [1], 1: [0], 2: []}",
        "expectedOutput": "[[0, 1, 0], [1, 0, 0], [0, 0, 0]]",
        "isHidden": false,
        "description": "Graph with isolated vertex"
      },
      {
        "input": "{0: [], 1: [], 2: []}",
        "expectedOutput": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]",
        "isHidden": false,
        "description": "No edges"
      }
    ],
    "hints": [
      "Initialize an nn matrix with all zeros",
      "Set matrix[i][j] = 1 for each edge from i to j",
      "The size of the matrix is determined by the number of vertices"
    ]
  },
  {
    "id": "cs201-ex-7-4",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Count Graph Edges",
    "description": "Given an adjacency list of an undirected graph, count the total number of edges. Be careful not to double-count edges!",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def count_edges(adj_list):\n    \"\"\"\n    Count the number of edges in an undirected graph.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n\n    Returns:\n        Integer count of edges\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def count_edges(adj_list):\n    \"\"\"\n    Count the number of edges in an undirected graph.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n\n    Returns:\n        Integer count of edges\n    \"\"\"\n    # Count all connections and divide by 2 (each edge counted twice)\n    total_connections = sum(len(neighbors) for neighbors in adj_list.values())\n    return total_connections // 2",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Triangle graph (3 edges)"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Linear chain (3 edges)"
      },
      {
        "input": "{0: [], 1: [], 2: []}",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "No edges"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Star graph (3 edges)"
      }
    ],
    "hints": [
      "In an undirected graph, each edge appears twice in the adjacency list",
      "Count all neighbor entries and divide by 2",
      "Use sum() with a generator expression for efficiency"
    ]
  },
  {
    "id": "cs201-ex-7-5",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Breadth-First Search Traversal",
    "description": "Implement BFS to traverse a graph starting from a given vertex. Return the vertices in the order they are visited.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "from collections import deque\n\ndef bfs_traversal(adj_list, start):\n    \"\"\"\n    Perform BFS traversal starting from a given vertex.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of vertices in BFS order\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef bfs_traversal(adj_list, start):\n    \"\"\"\n    Perform BFS traversal starting from a given vertex.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of vertices in BFS order\n    \"\"\"\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n\n        # Visit all unvisited neighbors\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return result",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2]}, 0",
        "expectedOutput": "[0, 1, 2, 3, 4]",
        "isHidden": false,
        "description": "Small connected graph"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Linear chain"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, 0",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Star graph"
      }
    ],
    "hints": [
      "Use a queue (deque) to track vertices to visit",
      "Keep a set of visited vertices to avoid revisiting",
      "Mark vertices as visited when adding to queue, not when removing"
    ]
  },
  {
    "id": "cs201-ex-7-6",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "BFS Level Order Traversal",
    "description": "Implement BFS to return vertices grouped by their distance (level) from the start vertex. Return a list of lists, where each sublist contains all vertices at that distance.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "from collections import deque\n\ndef bfs_by_level(adj_list, start):\n    \"\"\"\n    Perform BFS and return vertices grouped by level.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of lists, where result[i] contains all vertices at distance i\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef bfs_by_level(adj_list, start):\n    \"\"\"\n    Perform BFS and return vertices grouped by level.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of lists, where result[i] contains all vertices at distance i\n    \"\"\"\n    visited = {start}\n    queue = deque([start])\n    levels = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            vertex = queue.popleft()\n            current_level.append(vertex)\n\n            for neighbor in adj_list[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n        levels.append(current_level)\n\n    return levels",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2]}, 0",
        "expectedOutput": "[[0], [1, 2], [3, 4]]",
        "isHidden": false,
        "description": "Graph with 3 levels"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0",
        "expectedOutput": "[[0], [1], [2], [3]]",
        "isHidden": false,
        "description": "Linear chain"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, 0",
        "expectedOutput": "[[0], [1, 2, 3]]",
        "isHidden": false,
        "description": "Star graph"
      }
    ],
    "hints": [
      "Process the queue level by level using its current size",
      "For each level, process exactly level_size vertices",
      "Add all vertices at the same distance to the same sublist"
    ]
  },
  {
    "id": "cs201-ex-7-7",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Shortest Path in Unweighted Graph",
    "description": "Find the shortest path between two vertices in an unweighted graph using BFS. Return the path as a list of vertices, or an empty list if no path exists.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "from collections import deque\n\ndef shortest_path(adj_list, start, end):\n    \"\"\"\n    Find shortest path between two vertices using BFS.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n        end: Target vertex\n\n    Returns:\n        List representing the shortest path from start to end\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef shortest_path(adj_list, start, end):\n    \"\"\"\n    Find shortest path between two vertices using BFS.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n        end: Target vertex\n\n    Returns:\n        List representing the shortest path from start to end\n    \"\"\"\n    if start == end:\n        return [start]\n\n    visited = {start}\n    queue = deque([start])\n    parent = {start: None}\n\n    while queue:\n        vertex = queue.popleft()\n\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                parent[neighbor] = vertex\n                queue.append(neighbor)\n\n                # Found the target\n                if neighbor == end:\n                    # Reconstruct path\n                    path = []\n                    current = end\n                    while current is not None:\n                        path.append(current)\n                        current = parent[current]\n                    return path[::-1]\n\n    # No path found\n    return []",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}, 0, 4",
        "expectedOutput": "[0, 1, 3, 4]",
        "isHidden": false,
        "description": "Path exists with length 3"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0, 3",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Linear path"
      },
      {
        "input": "{0: [1], 1: [0], 2: [3], 3: [2]}, 0, 3",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "No path exists (disconnected components)"
      },
      {
        "input": "{0: [1, 2], 1: [0], 2: [0]}, 0, 0",
        "expectedOutput": "[0]",
        "isHidden": false,
        "description": "Start equals end"
      }
    ],
    "hints": [
      "Track parent relationships during BFS to reconstruct the path",
      "Stop BFS as soon as you reach the target vertex",
      "Reconstruct path by following parent pointers backwards",
      "Handle edge cases: start == end, no path exists"
    ]
  },
  {
    "id": "cs201-ex-7-8",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Distance Between Vertices",
    "description": "Calculate the shortest distance (minimum number of edges) between two vertices in an unweighted graph. Return -1 if no path exists.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "from collections import deque\n\ndef shortest_distance(adj_list, start, end):\n    \"\"\"\n    Find the shortest distance between two vertices.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n        end: Target vertex\n\n    Returns:\n        Integer distance, or -1 if no path exists\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef shortest_distance(adj_list, start, end):\n    \"\"\"\n    Find the shortest distance between two vertices.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n        end: Target vertex\n\n    Returns:\n        Integer distance, or -1 if no path exists\n    \"\"\"\n    if start == end:\n        return 0\n\n    visited = {start}\n    queue = deque([(start, 0)])\n\n    while queue:\n        vertex, distance = queue.popleft()\n\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                if neighbor == end:\n                    return distance + 1\n\n                visited.add(neighbor)\n                queue.append((neighbor, distance + 1))\n\n    return -1",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}, 0, 4",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Distance is 3"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0, 3",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Linear distance"
      },
      {
        "input": "{0: [1], 1: [0], 2: [3], 3: [2]}, 0, 3",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "No path (return -1)"
      },
      {
        "input": "{0: [1, 2], 1: [0], 2: [0]}, 0, 0",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Same vertex (distance 0)"
      }
    ],
    "hints": [
      "Use BFS with distance tracking in the queue",
      "Store tuples (vertex, distance) in the queue",
      "Return distance + 1 when target is found",
      "Return -1 if BFS completes without finding target"
    ]
  },
  {
    "id": "cs201-ex-7-9",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Depth-First Search Traversal",
    "description": "Implement DFS to traverse a graph starting from a given vertex. Return the vertices in the order they are visited. Use recursion.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def dfs_traversal(adj_list, start):\n    \"\"\"\n    Perform DFS traversal starting from a given vertex.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of vertices in DFS order\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def dfs_traversal(adj_list, start):\n    \"\"\"\n    Perform DFS traversal starting from a given vertex.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of vertices in DFS order\n    \"\"\"\n    visited = set()\n    result = []\n\n    def dfs(vertex):\n        visited.add(vertex)\n        result.append(vertex)\n\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    dfs(start)\n    return result",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2]}, 0",
        "expectedOutput": "[0, 1, 3, 4, 2]",
        "isHidden": false,
        "description": "Connected graph DFS"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Linear chain"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, 0",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Star graph"
      }
    ],
    "hints": [
      "Use recursion to implement DFS",
      "Keep a visited set to track explored vertices",
      "Add vertex to result when first visiting it",
      "Recursively visit all unvisited neighbors"
    ]
  },
  {
    "id": "cs201-ex-7-10",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Iterative DFS Traversal",
    "description": "Implement DFS using an iterative approach with a stack instead of recursion. Return vertices in DFS order.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def dfs_iterative(adj_list, start):\n    \"\"\"\n    Perform iterative DFS traversal using a stack.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of vertices in DFS order\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def dfs_iterative(adj_list, start):\n    \"\"\"\n    Perform iterative DFS traversal using a stack.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n        start: Starting vertex\n\n    Returns:\n        List of vertices in DFS order\n    \"\"\"\n    visited = set()\n    stack = [start]\n    result = []\n\n    while stack:\n        vertex = stack.pop()\n\n        if vertex not in visited:\n            visited.add(vertex)\n            result.append(vertex)\n\n            # Add neighbors to stack in reverse order\n            # This maintains left-to-right traversal order\n            for neighbor in reversed(adj_list[vertex]):\n                if neighbor not in visited:\n                    stack.append(neighbor)\n\n    return result",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2]}, 0",
        "expectedOutput": "[0, 1, 3, 4, 2]",
        "isHidden": false,
        "description": "Connected graph DFS"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Linear chain"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, 0",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Star graph"
      }
    ],
    "hints": [
      "Use a stack (list) instead of recursion",
      "Pop from stack to get next vertex to visit",
      "Check if vertex is visited when popping (not when pushing)",
      "Reverse neighbor order when pushing to maintain left-to-right order"
    ]
  },
  {
    "id": "cs201-ex-7-11",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Detect Cycle in Undirected Graph",
    "description": "Determine if an undirected graph contains a cycle using DFS. Return True if a cycle exists, False otherwise.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def has_cycle(adj_list):\n    \"\"\"\n    Detect if an undirected graph contains a cycle.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n\n    Returns:\n        Boolean indicating if cycle exists\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def has_cycle(adj_list):\n    \"\"\"\n    Detect if an undirected graph contains a cycle.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n\n    Returns:\n        Boolean indicating if cycle exists\n    \"\"\"\n    visited = set()\n\n    def dfs(vertex, parent):\n        visited.add(vertex)\n\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                if dfs(neighbor, vertex):\n                    return True\n            elif neighbor != parent:\n                # Found a visited vertex that's not the parent - cycle!\n                return True\n\n        return False\n\n    # Check all components\n    for vertex in adj_list:\n        if vertex not in visited:\n            if dfs(vertex, None):\n                return True\n\n    return False",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Triangle (has cycle)"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Linear chain (no cycle)"
      },
      {
        "input": "{0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Square graph (has cycle)"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Star graph (no cycle)"
      }
    ],
    "hints": [
      "Track the parent vertex to avoid false positives in undirected graphs",
      "A cycle exists if you visit a neighbor that is already visited and not the parent",
      "Check all connected components in case graph is disconnected",
      "Use DFS with parent tracking"
    ]
  },
  {
    "id": "cs201-ex-7-12",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Count Connected Components",
    "description": "Count the number of connected components in an undirected graph. A connected component is a maximal set of vertices where each pair is connected by a path.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def count_components(adj_list):\n    \"\"\"\n    Count the number of connected components in a graph.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n\n    Returns:\n        Integer count of connected components\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def count_components(adj_list):\n    \"\"\"\n    Count the number of connected components in a graph.\n\n    Args:\n        adj_list: Dictionary representing adjacency list\n\n    Returns:\n        Integer count of connected components\n    \"\"\"\n    visited = set()\n    count = 0\n\n    def dfs(vertex):\n        visited.add(vertex)\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    # Start DFS from each unvisited vertex\n    for vertex in adj_list:\n        if vertex not in visited:\n            dfs(vertex)\n            count += 1\n\n    return count",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: []}",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Three components: {0,1,2}, {3,4}, {5}"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Single connected component"
      },
      {
        "input": "{0: [], 1: [], 2: [], 3: []}",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "All isolated vertices"
      },
      {
        "input": "{0: [1, 2], 1: [0], 2: [0], 3: [4, 5], 4: [3], 5: [3]}",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Two components: {0,1,2} and {3,4,5}"
      }
    ],
    "hints": [
      "Start DFS from each unvisited vertex",
      "Increment counter for each new DFS start",
      "Each DFS explores one complete connected component",
      "Isolated vertices count as separate components"
    ]
  },
  {
    "id": "cs201-ex-7-13",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Topological Sort (DFS)",
    "description": "Perform topological sort on a directed acyclic graph (DAG) using DFS. Return vertices in topologically sorted order, where each vertex appears before all vertices it has edges to.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def topological_sort(adj_list):\n    \"\"\"\n    Perform topological sort on a DAG using DFS.\n\n    Args:\n        adj_list: Dictionary representing directed adjacency list\n\n    Returns:\n        List of vertices in topological order\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def topological_sort(adj_list):\n    \"\"\"\n    Perform topological sort on a DAG using DFS.\n\n    Args:\n        adj_list: Dictionary representing directed adjacency list\n\n    Returns:\n        List of vertices in topological order\n    \"\"\"\n    visited = set()\n    stack = []\n\n    def dfs(vertex):\n        visited.add(vertex)\n\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n        # Add to stack after visiting all descendants\n        stack.append(vertex)\n\n    # Visit all vertices\n    for vertex in adj_list:\n        if vertex not in visited:\n            dfs(vertex)\n\n    # Return reversed stack\n    return stack[::-1]",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [3], 2: [3], 3: []}",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Simple DAG"
      },
      {
        "input": "{5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 0: [], 1: []}",
        "expectedOutput": "[5, 4, 2, 3, 1, 0]",
        "isHidden": false,
        "description": "Complex DAG (multiple valid orderings possible)"
      },
      {
        "input": "{0: [1], 1: [2], 2: [3], 3: []}",
        "expectedOutput": "[0, 1, 2, 3]",
        "isHidden": false,
        "description": "Linear dependency chain"
      }
    ],
    "hints": [
      "Use DFS and add vertices to stack after visiting all descendants",
      "Reverse the stack to get topological order",
      "Process all vertices in case graph has multiple components",
      "A vertex should appear before all its descendants in the result"
    ]
  },
  {
    "id": "cs201-ex-7-14",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Detect Cycle in Directed Graph",
    "description": "Detect if a directed graph contains a cycle using DFS with recursion stack tracking. Return True if a cycle exists.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def has_cycle_directed(adj_list):\n    \"\"\"\n    Detect cycle in a directed graph.\n\n    Args:\n        adj_list: Dictionary representing directed adjacency list\n\n    Returns:\n        Boolean indicating if cycle exists\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def has_cycle_directed(adj_list):\n    \"\"\"\n    Detect cycle in a directed graph.\n\n    Args:\n        adj_list: Dictionary representing directed adjacency list\n\n    Returns:\n        Boolean indicating if cycle exists\n    \"\"\"\n    visited = set()\n    rec_stack = set()  # Tracks current recursion path\n\n    def dfs(vertex):\n        visited.add(vertex)\n        rec_stack.add(vertex)\n\n        for neighbor in adj_list[vertex]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in rec_stack:\n                # Found a back edge - cycle detected!\n                return True\n\n        # Remove from recursion stack when backtracking\n        rec_stack.remove(vertex)\n        return False\n\n    # Check all components\n    for vertex in adj_list:\n        if vertex not in visited:\n            if dfs(vertex):\n                return True\n\n    return False",
    "testCases": [
      {
        "input": "{0: [1], 1: [2], 2: [0]}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Simple cycle: 0->1->2->0"
      },
      {
        "input": "{0: [1, 2], 1: [3], 2: [3], 3: []}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "DAG (no cycle)"
      },
      {
        "input": "{0: [1], 1: [2], 2: [3], 3: [1]}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Cycle: 1->2->3->1"
      },
      {
        "input": "{0: [1], 1: [2], 2: [3], 3: []}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Linear chain (no cycle)"
      }
    ],
    "hints": [
      "Use two sets: visited (global) and rec_stack (current path)",
      "A cycle exists if you reach a vertex already in the recursion stack",
      "Remove vertices from rec_stack when backtracking",
      "Different from undirected cycle detection - need recursion stack"
    ]
  },
  {
    "id": "cs201-ex-7-15",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Dijkstra's Algorithm - Basic",
    "description": "Implement Dijkstra's algorithm to find shortest distances from a source vertex to all other vertices in a weighted graph. Graph is represented as adjacency list where each neighbor is a tuple (vertex, weight).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "import heapq\n\ndef dijkstra(adj_list, start):\n    \"\"\"\n    Find shortest distances from start to all vertices.\n\n    Args:\n        adj_list: Dict where adj_list[u] = [(v1, w1), (v2, w2), ...]\n                  Each tuple (v, w) represents edge from u to v with weight w\n        start: Starting vertex\n\n    Returns:\n        Dictionary mapping each vertex to its shortest distance from start\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import heapq\n\ndef dijkstra(adj_list, start):\n    \"\"\"\n    Find shortest distances from start to all vertices.\n\n    Args:\n        adj_list: Dict where adj_list[u] = [(v1, w1), (v2, w2), ...]\n                  Each tuple (v, w) represents edge from u to v with weight w\n        start: Starting vertex\n\n    Returns:\n        Dictionary mapping each vertex to its shortest distance from start\n    \"\"\"\n    # Initialize distances\n    distances = {vertex: float('inf') for vertex in adj_list}\n    distances[start] = 0\n\n    # Priority queue: (distance, vertex)\n    pq = [(0, start)]\n    visited = set()\n\n    while pq:\n        current_dist, u = heapq.heappop(pq)\n\n        if u in visited:\n            continue\n\n        visited.add(u)\n\n        # Relax edges\n        for v, weight in adj_list[u]:\n            distance = current_dist + weight\n\n            if distance < distances[v]:\n                distances[v] = distance\n                heapq.heappush(pq, (distance, v))\n\n    return distances",
    "testCases": [
      {
        "input": "{0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}, 0",
        "expectedOutput": "{0: 0, 1: 3, 2: 1, 3: 4}",
        "isHidden": false,
        "description": "Simple weighted graph"
      },
      {
        "input": "{0: [(1, 1), (2, 4)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: []}, 0",
        "expectedOutput": "{0: 0, 1: 1, 2: 3, 3: 4}",
        "isHidden": false,
        "description": "Multiple paths to vertices"
      },
      {
        "input": "{0: [(1, 10)], 1: [], 2: [(3, 1)], 3: []}, 0",
        "expectedOutput": "{0: 0, 1: 10, 2: inf, 3: inf}",
        "isHidden": false,
        "description": "Disconnected vertices (unreachable)"
      }
    ],
    "hints": [
      "Use a priority queue (min-heap) to always process nearest vertex",
      "Initialize all distances to infinity except start (0)",
      "Relax edges: if current_dist + edge_weight < distances[neighbor], update",
      "Mark vertices as visited to avoid reprocessing"
    ]
  },
  {
    "id": "cs201-ex-7-16",
    "subjectId": "cs201",
    "topicId": "cs201-7",
    "title": "Dijkstra's Algorithm - Path Reconstruction",
    "description": "Implement Dijkstra's algorithm to find the shortest path (not just distance) from source to a target vertex. Return the path as a list of vertices.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "import heapq\n\ndef dijkstra_path(adj_list, start, end):\n    \"\"\"\n    Find shortest path from start to end using Dijkstra's algorithm.\n\n    Args:\n        adj_list: Dict where adj_list[u] = [(v1, w1), (v2, w2), ...]\n        start: Starting vertex\n        end: Target vertex\n\n    Returns:\n        Tuple (distance, path) where distance is shortest distance\n        and path is list of vertices. Return (float('inf'), []) if unreachable.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import heapq\n\ndef dijkstra_path(adj_list, start, end):\n    \"\"\"\n    Find shortest path from start to end using Dijkstra's algorithm.\n\n    Args:\n        adj_list: Dict where adj_list[u] = [(v1, w1), (v2, w2), ...]\n        start: Starting vertex\n        end: Target vertex\n\n    Returns:\n        Tuple (distance, path) where distance is shortest distance\n        and path is list of vertices. Return (float('inf'), []) if unreachable.\n    \"\"\"\n    distances = {vertex: float('inf') for vertex in adj_list}\n    distances[start] = 0\n    parent = {start: None}\n\n    pq = [(0, start)]\n    visited = set()\n\n    while pq:\n        current_dist, u = heapq.heappop(pq)\n\n        if u in visited:\n            continue\n\n        visited.add(u)\n\n        # Early termination if we reached the target\n        if u == end:\n            break\n\n        for v, weight in adj_list[u]:\n            distance = current_dist + weight\n\n            if distance < distances[v]:\n                distances[v] = distance\n                parent[v] = u\n                heapq.heappush(pq, (distance, v))\n\n    # Reconstruct path\n    if distances[end] == float('inf'):\n        return (float('inf'), [])\n\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = parent.get(current)\n\n    return (distances[end], path[::-1])",
    "testCases": [
      {
        "input": "{0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}, 0, 3",
        "expectedOutput": "(4, [0, 2, 1, 3])",
        "isHidden": false,
        "description": "Shortest path with distance 4"
      },
      {
        "input": "{0: [(1, 1), (2, 4)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: []}, 0, 3",
        "expectedOutput": "(4, [0, 1, 2, 3])",
        "isHidden": false,
        "description": "Path via multiple vertices"
      },
      {
        "input": "{0: [(1, 10)], 1: [], 2: [(3, 1)], 3: []}, 0, 3",
        "expectedOutput": "(inf, [])",
        "isHidden": false,
        "description": "No path exists (unreachable)"
      },
      {
        "input": "{0: [(1, 5), (2, 3)], 1: [(3, 1)], 2: [(1, 1), (3, 6)], 3: []}, 0, 3",
        "expectedOutput": "(5, [0, 2, 1, 3])",
        "isHidden": false,
        "description": "Complex graph with multiple paths"
      }
    ],
    "hints": [
      "Track parent pointers while running Dijkstra's algorithm",
      "Update parent when you find a shorter path to a vertex",
      "Reconstruct path by following parent pointers from end to start",
      "Can terminate early when target vertex is visited",
      "Return (inf, []) if target is unreachable"
    ]
  },
  {
    "id": "cs201-ex-8-1",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Linear Search with Loop Invariant",
    "description": "Implement linear search with explicit assertions checking the loop invariant: \"target is not in arr[0...i-1]\".",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def linear_search_with_invariant(arr, target):\n    # Return index of target or -1\n    # Add assertions to verify loop invariant\n    pass",
    "solution": "def linear_search_with_invariant(arr, target):\n    # Loop invariant: target is not in arr[0...i-1]\n    for i in range(len(arr)):\n        # Check invariant: target not in previously checked elements\n        assert target not in arr[0:i], f\"Invariant violated at i={i}\"\n        if arr[i] == target:\n            return i\n    # Post-condition: target not found in entire array\n    assert target not in arr, \"Post-condition violated\"\n    return -1",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5], 3",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Target found at index 2"
      },
      {
        "input": "[1, 2, 3, 4, 5], 6",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Target not in array"
      },
      {
        "input": "[10, 20, 30], 10",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Target at first position"
      },
      {
        "input": "[], 5",
        "expectedOutput": "-1",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "The loop invariant states that target has not been found in arr[0...i-1].",
      "Use assert statements to check the invariant holds at each iteration.",
      "The invariant is trivially true when i=0 (no elements checked yet)."
    ]
  },
  {
    "id": "cs201-ex-8-2",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Binary Search with Loop Invariant",
    "description": "Implement binary search with assertions verifying the loop invariant: \"if target exists, it must be in arr[low...high]\".",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def binary_search_with_invariant(arr, target):\n    # arr is sorted\n    # Return index of target or -1\n    # Add assertions to verify loop invariant\n    pass",
    "solution": "def binary_search_with_invariant(arr, target):\n    low, high = 0, len(arr) - 1\n    \n    while low <= high:\n        # Invariant: if target exists, it is in arr[low...high]\n        # Verify array is sorted in current range\n        assert all(arr[i] <= arr[i+1] for i in range(low, high)), \"Array not sorted in range\"\n        \n        mid = (low + high) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            # Target must be in upper half\n            assert target > arr[mid], \"Logic error\"\n            low = mid + 1\n        else:\n            # Target must be in lower half\n            assert target < arr[mid], \"Logic error\"\n            high = mid - 1\n    \n    # Post-condition: target not in array\n    assert target not in arr, \"Post-condition violated - target should not exist\"\n    return -1",
    "testCases": [
      {
        "input": "[1, 3, 5, 7, 9, 11], 7",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Target found"
      },
      {
        "input": "[1, 3, 5, 7, 9, 11], 4",
        "expectedOutput": "-1",
        "isHidden": false,
        "description": "Target not found"
      },
      {
        "input": "[2, 4, 6, 8, 10], 2",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Target at beginning"
      },
      {
        "input": "[2, 4, 6, 8, 10], 10",
        "expectedOutput": "4",
        "isHidden": true,
        "description": "Target at end"
      }
    ],
    "hints": [
      "The invariant is: if target exists in arr, it must be in arr[low...high].",
      "Initially, low=0 and high=len(arr)-1, so the entire array is considered.",
      "After each iteration, we maintain the invariant by adjusting low or high based on comparison."
    ]
  },
  {
    "id": "cs201-ex-8-3",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Array Sum with Loop Invariant",
    "description": "Calculate array sum with assertions checking the invariant: \"sum contains the sum of arr[0...i-1]\".",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def array_sum_with_invariant(arr):\n    # Return sum of all elements\n    # Add assertions to verify loop invariant\n    pass",
    "solution": "def array_sum_with_invariant(arr):\n    total = 0\n    # Loop invariant: total = sum of arr[0...i-1]\n    \n    for i in range(len(arr)):\n        # Check invariant holds before iteration\n        assert total == sum(arr[0:i]), f\"Invariant violated at i={i}: total={total}, expected={sum(arr[0:i])}\"\n        total += arr[i]\n    \n    # Post-condition: total equals sum of entire array\n    assert total == sum(arr), \"Post-condition violated\"\n    return total",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "15",
        "isHidden": false,
        "description": "Sum of 1 to 5"
      },
      {
        "input": "[10, -5, 3]",
        "expectedOutput": "8",
        "isHidden": false,
        "description": "Mixed positive and negative"
      },
      {
        "input": "[100]",
        "expectedOutput": "100",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "The invariant states that total equals sum(arr[0...i-1]) at the start of each iteration.",
      "When i=0, total=0 and arr[0...0] is empty, so invariant holds (0 = sum of empty).",
      "After adding arr[i], the invariant will hold for the next iteration."
    ]
  },
  {
    "id": "cs201-ex-8-4",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Insertion Sort with Loop Invariant",
    "description": "Implement insertion sort with assertions verifying: \"arr[0...i-1] is sorted before inserting arr[i]\".",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def insertion_sort_with_invariant(arr):\n    # Sort array in-place\n    # Add assertions to verify loop invariant\n    pass",
    "solution": "def insertion_sort_with_invariant(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        # Invariant: arr[0...i-1] is sorted\n        assert all(arr[j] <= arr[j+1] for j in range(i-1)), f\"Invariant violated at i={i}\"\n        \n        key = arr[i]\n        j = i - 1\n        \n        # Insert arr[i] into sorted sequence arr[0...i-1]\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n        \n        # After insertion, arr[0...i] is sorted\n        assert all(arr[k] <= arr[k+1] for k in range(i)), f\"Post-iteration check failed at i={i}\"\n    \n    # Post-condition: entire array is sorted\n    assert all(arr[i] <= arr[i+1] for i in range(len(arr)-1)), \"Array not fully sorted\"\n    return arr",
    "testCases": [
      {
        "input": "[5, 2, 4, 6, 1, 3]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[3, 2, 1]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[42]",
        "expectedOutput": "[42]",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "The outer loop invariant: arr[0...i-1] is sorted before iteration i.",
      "Initially (i=1), arr[0...0] is trivially sorted (one element).",
      "The inner while loop maintains sortedness by shifting larger elements right."
    ]
  },
  {
    "id": "cs201-ex-8-5",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Is Sorted Checker",
    "description": "Write a function to verify if an array is sorted in non-decreasing order.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def is_sorted(arr):\n    # Return True if sorted, False otherwise\n    pass",
    "solution": "def is_sorted(arr):\n    if len(arr) <= 1:\n        return True\n    \n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n    \n    return True",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Sorted array"
      },
      {
        "input": "[1, 3, 2, 4]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 5, 5]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "All equal elements"
      },
      {
        "input": "[1]",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Check if each element is <= the next element.",
      "An empty array or single element array is considered sorted.",
      "Use a loop to compare consecutive pairs."
    ]
  },
  {
    "id": "cs201-ex-8-6",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Verify Binary Search Result",
    "description": "Write a verifier that checks if a binary search result is correct. Given array, target, and returned index, verify correctness.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def verify_binary_search(arr, target, result_index):\n    # arr is sorted\n    # result_index is what binary search returned (-1 if not found)\n    # Return True if result is correct, False otherwise\n    pass",
    "solution": "def verify_binary_search(arr, target, result_index):\n    # First check if array is actually sorted\n    if not all(arr[i] <= arr[i+1] for i in range(len(arr)-1)):\n        return False  # Precondition violated\n    \n    if result_index == -1:\n        # Verify target is not in array\n        return target not in arr\n    else:\n        # Verify index is in bounds\n        if result_index < 0 or result_index >= len(arr):\n            return False\n        # Verify arr[result_index] == target\n        return arr[result_index] == target",
    "testCases": [
      {
        "input": "[1, 3, 5, 7, 9], 5, 2",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correct result"
      },
      {
        "input": "[1, 3, 5, 7, 9], 4, -1",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correctly not found"
      },
      {
        "input": "[1, 3, 5, 7, 9], 5, 3",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Wrong index returned"
      },
      {
        "input": "[1, 3, 5, 7, 9], 7, -1",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Should have been found"
      },
      {
        "input": "[5, 3, 1], 3, 1",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Array not sorted"
      }
    ],
    "hints": [
      "First verify the precondition: array must be sorted.",
      "If result is -1, verify target is not in array.",
      "If result is an index, verify arr[index] == target.",
      "Also check that the index is within valid bounds."
    ]
  },
  {
    "id": "cs201-ex-8-7",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Verify Sorting Algorithm",
    "description": "Write a function that verifies a sorting algorithm produced correct output. Check: result is sorted, contains same elements as input.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def verify_sort(original, sorted_result):\n    # Return True if sorted_result is a valid sorted version of original\n    pass",
    "solution": "def verify_sort(original, sorted_result):\n    # Check 1: Result is sorted\n    for i in range(len(sorted_result) - 1):\n        if sorted_result[i] > sorted_result[i + 1]:\n            return False\n    \n    # Check 2: Result has same length\n    if len(original) != len(sorted_result):\n        return False\n    \n    # Check 3: Result contains same elements (same counts)\n    from collections import Counter\n    return Counter(original) == Counter(sorted_result)",
    "testCases": [
      {
        "input": "[3, 1, 2], [1, 2, 3]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correctly sorted"
      },
      {
        "input": "[3, 1, 2], [1, 2, 2]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Different elements"
      },
      {
        "input": "[3, 1, 2], [1, 3]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing element"
      },
      {
        "input": "[5, 5, 1], [1, 5, 5]",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Duplicates handled correctly"
      }
    ],
    "hints": [
      "Verify the result is sorted (each element <= next).",
      "Verify result has same length as original.",
      "Verify result contains same elements with same counts (use Counter)."
    ]
  },
  {
    "id": "cs201-ex-8-8",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Verify Max Element",
    "description": "Write a verifier that checks if a returned element is truly the maximum in an array.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def verify_max(arr, claimed_max):\n    # Return True if claimed_max is the maximum element in arr\n    pass",
    "solution": "def verify_max(arr, claimed_max):\n    if len(arr) == 0:\n        return False  # No max in empty array\n    \n    # Verify claimed_max is in the array\n    if claimed_max not in arr:\n        return False\n    \n    # Verify no element is greater than claimed_max\n    for element in arr:\n        if element > claimed_max:\n            return False\n    \n    return True",
    "testCases": [
      {
        "input": "[1, 5, 3, 2], 5",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correct max"
      },
      {
        "input": "[1, 5, 3, 2], 3",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not the max"
      },
      {
        "input": "[7, 7, 7], 7",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "All elements equal"
      },
      {
        "input": "[1, 5, 3, 2], 10",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Max not in array"
      },
      {
        "input": "[], 5",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Check if claimed_max exists in the array.",
      "Check that no element in array is greater than claimed_max.",
      "Handle edge case of empty array."
    ]
  },
  {
    "id": "cs201-ex-8-9",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Sudoku Validator",
    "description": "Write a function to verify if a completed 9x9 Sudoku solution is valid (each row, column, and 3x3 box contains 1-9 exactly once).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def is_valid_sudoku(board):\n    # board is 9x9 list of lists\n    # Return True if valid complete solution\n    pass",
    "solution": "def is_valid_sudoku(board):\n    # Check each row\n    for row in board:\n        if sorted(row) != list(range(1, 10)):\n            return False\n    \n    # Check each column\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if sorted(column) != list(range(1, 10)):\n            return False\n    \n    # Check each 3x3 box\n    for box_row in range(3):\n        for box_col in range(3):\n            box = []\n            for i in range(3):\n                for j in range(3):\n                    box.append(board[box_row*3 + i][box_col*3 + j])\n            if sorted(box) != list(range(1, 10)):\n                return False\n    \n    return True",
    "testCases": [
      {
        "input": "[[5,3,4,6,7,8,9,1,2],[6,7,2,1,9,5,3,4,8],[1,9,8,3,4,2,5,6,7],[8,5,9,7,6,1,4,2,3],[4,2,6,8,5,3,7,9,1],[7,1,3,9,2,4,8,5,6],[9,6,1,5,3,7,2,8,4],[2,8,7,4,1,9,6,3,5],[3,4,5,2,8,6,1,7,9]]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid complete Sudoku"
      },
      {
        "input": "[[5,3,4,6,7,8,9,1,2],[6,7,2,1,9,5,3,4,8],[1,9,8,3,4,2,5,6,7],[8,5,9,7,6,1,4,2,3],[4,2,6,8,5,3,7,9,1],[7,1,3,9,2,4,8,5,6],[9,6,1,5,3,7,2,8,4],[2,8,7,4,1,9,6,3,5],[3,4,5,2,8,6,1,7,5]]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid - duplicate in last row"
      }
    ],
    "hints": [
      "Check all rows: each should contain 1-9 exactly once.",
      "Check all columns: extract each column and verify.",
      "Check all 3x3 boxes: there are 9 boxes to check.",
      "Use sorted() to compare against [1,2,3,4,5,6,7,8,9]."
    ]
  },
  {
    "id": "cs201-ex-8-10",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Graph Cycle Detector",
    "description": "Given a directed graph as adjacency list, determine if it contains a cycle using DFS.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def has_cycle(graph):\n    # graph is dict: node -> list of neighbors\n    # Return True if graph has a cycle\n    pass",
    "solution": "def has_cycle(graph):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {node: WHITE for node in graph}\n    \n    def dfs(node):\n        if color[node] == GRAY:\n            return True  # Back edge found - cycle!\n        if color[node] == BLACK:\n            return False  # Already processed\n        \n        color[node] = GRAY  # Mark as being processed\n        \n        for neighbor in graph.get(node, []):\n            if dfs(neighbor):\n                return True\n        \n        color[node] = BLACK  # Mark as done\n        return False\n    \n    for node in graph:\n        if color[node] == WHITE:\n            if dfs(node):\n                return True\n    \n    return False",
    "testCases": [
      {
        "input": "{'A': ['B'], 'B': ['C'], 'C': []}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No cycle - simple chain"
      },
      {
        "input": "{'A': ['B'], 'B': ['C'], 'C': ['A']}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Cycle present"
      },
      {
        "input": "{'A': ['B'], 'B': ['C'], 'C': [], 'D': ['E'], 'E': []}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Disconnected, no cycles"
      },
      {
        "input": "{'A': ['A']}",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Self-loop"
      }
    ],
    "hints": [
      "Use DFS with three colors: WHITE (unvisited), GRAY (processing), BLACK (done).",
      "A back edge to a GRAY node indicates a cycle.",
      "Process all nodes in case graph is disconnected.",
      "GRAY means we are currently exploring this path."
    ]
  },
  {
    "id": "cs201-ex-8-11",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Valid Parentheses Checker",
    "description": "Verify if a string of parentheses/brackets is properly balanced: (), [], {}.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def is_balanced(s):\n    # Return True if parentheses are balanced\n    pass",
    "solution": "def is_balanced(s):\n    stack = []\n    matching = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack or stack[-1] != matching[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0",
    "testCases": [
      {
        "input": "\"()\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Simple balanced"
      },
      {
        "input": "\"()[]{}\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Multiple types balanced"
      },
      {
        "input": "\"(]\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Mismatched types"
      },
      {
        "input": "\"(()\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Unclosed parenthesis"
      },
      {
        "input": "\"{[()]}\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Nested balanced"
      },
      {
        "input": "\"((()))\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Deep nesting"
      }
    ],
    "hints": [
      "Use a stack to track opening brackets.",
      "When you see a closing bracket, check it matches the top of stack.",
      "At the end, stack should be empty.",
      "Each closing bracket type must match its corresponding opening bracket."
    ]
  },
  {
    "id": "cs201-ex-8-12",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Verify Graph Coloring",
    "description": "Given a graph and a coloring (assignment of colors to nodes), verify if it's a valid k-coloring (no adjacent nodes share a color).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def is_valid_coloring(graph, coloring):\n    # graph: dict node -> list of neighbors\n    # coloring: dict node -> color\n    # Return True if valid coloring\n    pass",
    "solution": "def is_valid_coloring(graph, coloring):\n    # Check all nodes have a color assigned\n    for node in graph:\n        if node not in coloring:\n            return False\n    \n    # Check no adjacent nodes have same color\n    for node in graph:\n        node_color = coloring[node]\n        for neighbor in graph[node]:\n            if neighbor in coloring and coloring[neighbor] == node_color:\n                return False\n    \n    return True",
    "testCases": [
      {
        "input": "{'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['A', 'B']}, {'A': 1, 'B': 2, 'C': 3}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid 3-coloring of triangle"
      },
      {
        "input": "{'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['A', 'B']}, {'A': 1, 'B': 1, 'C': 2}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid - A and B are adjacent with same color"
      },
      {
        "input": "{'A': ['B'], 'B': ['A']}, {'A': 1, 'B': 2}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid 2-coloring of edge"
      },
      {
        "input": "{'A': ['B'], 'B': ['A']}, {'A': 1}",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Missing color assignment"
      }
    ],
    "hints": [
      "First verify all nodes have a color assigned.",
      "Then check each edge: the two endpoints must have different colors.",
      "Iterate through each node and check all its neighbors.",
      "If any neighbor has the same color, the coloring is invalid."
    ]
  },
  {
    "id": "cs201-ex-8-13",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Reduce Vertex Cover to Set Cover",
    "description": "Given a graph, convert it to a Set Cover instance. Each edge becomes an element, each vertex becomes a set containing its incident edges.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def graph_to_set_cover(edges):\n    # edges: list of tuples (u, v)\n    # Return: (universe, sets) where sets is dict: vertex -> set of edges\n    pass",
    "solution": "def graph_to_set_cover(edges):\n    universe = set(range(len(edges)))  # Each edge is an element\n    sets = {}\n    \n    # Build vertex set - collect all unique vertices\n    vertices = set()\n    for u, v in edges:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # For each vertex, create a set of edges it's incident to\n    for vertex in vertices:\n        sets[vertex] = set()\n        for i, (u, v) in enumerate(edges):\n            if u == vertex or v == vertex:\n                sets[vertex].add(i)\n    \n    return (universe, sets)",
    "testCases": [
      {
        "input": "[(\"A\", \"B\"), (\"B\", \"C\")]",
        "expectedOutput": "({0, 1}, {'A': {0}, 'B': {0, 1}, 'C': {1}})",
        "isHidden": false,
        "description": "Simple path graph"
      },
      {
        "input": "[(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")]",
        "expectedOutput": "({0, 1, 2}, {'A': {0, 1}, 'B': {0, 2}, 'C': {1, 2}})",
        "isHidden": false,
        "description": "Triangle graph"
      }
    ],
    "hints": [
      "The universe is the set of all edges (represented as indices).",
      "Each vertex becomes a set containing the indices of edges incident to it.",
      "A vertex cover in the graph corresponds to a set cover in the reduction.",
      "If vertices cover all edges, then the corresponding sets cover all elements."
    ]
  },
  {
    "id": "cs201-ex-8-14",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "3-SAT Clause Evaluator",
    "description": "Given a 3-SAT clause (3 literals) and variable assignment, evaluate if the clause is satisfied.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def evaluate_3sat_clause(clause, assignment):\n    # clause: list of 3 literals, e.g., [\"x1\", \"-x2\", \"x3\"]\n    # assignment: dict variable -> bool, e.g., {\"x1\": True, \"x2\": False}\n    # Return True if clause is satisfied\n    pass",
    "solution": "def evaluate_3sat_clause(clause, assignment):\n    for literal in clause:\n        if literal.startswith(\"-\"):\n            # Negated variable\n            var = literal[1:]\n            if var in assignment and not assignment[var]:\n                return True  # Clause satisfied by this literal\n        else:\n            # Positive variable\n            var = literal\n            if var in assignment and assignment[var]:\n                return True  # Clause satisfied by this literal\n    \n    return False  # No literal satisfied the clause",
    "testCases": [
      {
        "input": "[\"x1\", \"-x2\", \"x3\"], {\"x1\": True, \"x2\": True, \"x3\": False}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Satisfied by x1"
      },
      {
        "input": "[\"x1\", \"-x2\", \"x3\"], {\"x1\": False, \"x2\": True, \"x3\": False}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Satisfied by -x2"
      },
      {
        "input": "[\"x1\", \"x2\", \"x3\"], {\"x1\": False, \"x2\": False, \"x3\": False}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not satisfied"
      },
      {
        "input": "[\"-x1\", \"-x2\", \"-x3\"], {\"x1\": False, \"x2\": False, \"x3\": True}",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Satisfied by negated literals"
      }
    ],
    "hints": [
      "A clause is satisfied if at least one literal is true.",
      "A positive literal \"x\" is true if assignment[x] == True.",
      "A negative literal \"-x\" is true if assignment[x] == False.",
      "Check if the literal starts with \"-\" to determine if it's negated."
    ]
  },
  {
    "id": "cs201-ex-8-15",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Evaluate 3-SAT Formula",
    "description": "Given a complete 3-SAT formula (CNF with 3 literals per clause) and variable assignment, determine if the formula is satisfied.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def evaluate_3sat_formula(formula, assignment):\n    # formula: list of clauses, each clause is list of 3 literals\n    # assignment: dict variable -> bool\n    # Return True if entire formula is satisfied\n    pass",
    "solution": "def evaluate_3sat_formula(formula, assignment):\n    def evaluate_clause(clause):\n        for literal in clause:\n            if literal.startswith(\"-\"):\n                var = literal[1:]\n                if var in assignment and not assignment[var]:\n                    return True\n            else:\n                var = literal\n                if var in assignment and assignment[var]:\n                    return True\n        return False\n    \n    # All clauses must be satisfied (AND of clauses)\n    for clause in formula:\n        if not evaluate_clause(clause):\n            return False\n    \n    return True",
    "testCases": [
      {
        "input": "[[\"x1\", \"x2\", \"x3\"], [\"-x1\", \"x2\", \"x3\"]], {\"x1\": True, \"x2\": True, \"x3\": False}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Both clauses satisfied"
      },
      {
        "input": "[[\"x1\", \"x2\", \"x3\"], [\"-x1\", \"-x2\", \"-x3\"]], {\"x1\": False, \"x2\": False, \"x3\": False}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Second clause satisfied"
      },
      {
        "input": "[[\"x1\", \"x2\", \"x3\"], [\"-x1\", \"-x2\", \"-x3\"]], {\"x1\": True, \"x2\": False, \"x3\": False}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "First clause satisfied by x1"
      },
      {
        "input": "[[\"x1\"], [\"x2\"], [\"-x1\"]], {\"x1\": True, \"x2\": True}",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Contradictory clauses"
      }
    ],
    "hints": [
      "A formula in CNF is satisfied if ALL clauses are satisfied (AND of clauses).",
      "A clause is satisfied if at least ONE literal is true (OR of literals).",
      "Reuse the clause evaluation logic from the previous exercise.",
      "Return False as soon as you find an unsatisfied clause."
    ]
  },
  {
    "id": "cs201-ex-8-16",
    "subjectId": "cs201",
    "topicId": "cs201-8",
    "title": "Independent Set to Clique Reduction",
    "description": "Given a graph, construct its complement graph. An independent set in G corresponds to a clique in complement(G).",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def graph_complement(vertices, edges):\n    # vertices: list of vertex names\n    # edges: list of tuples (u, v) representing edges\n    # Return: list of edges in complement graph\n    pass",
    "solution": "def graph_complement(vertices, edges):\n    # Convert edges to set for O(1) lookup\n    edge_set = set()\n    for u, v in edges:\n        # Store both directions for undirected graph\n        edge_set.add((u, v))\n        edge_set.add((v, u))\n    \n    # Generate all possible edges\n    complement_edges = []\n    for i, u in enumerate(vertices):\n        for v in vertices[i+1:]:\n            # If edge doesn't exist in original, add to complement\n            if (u, v) not in edge_set:\n                complement_edges.append((u, v))\n    \n    return complement_edges",
    "testCases": [
      {
        "input": "[\"A\", \"B\", \"C\"], [(\"A\", \"B\")]",
        "expectedOutput": "[(\"A\", \"C\"), (\"B\", \"C\")]",
        "isHidden": false,
        "description": "Simple complement"
      },
      {
        "input": "[\"A\", \"B\", \"C\"], [(\"A\", \"B\"), (\"B\", \"C\"), (\"A\", \"C\")]",
        "expectedOutput": "[]",
        "isHidden": false,
        "description": "Complete graph has empty complement"
      },
      {
        "input": "[\"A\", \"B\", \"C\"], []",
        "expectedOutput": "[(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\")]",
        "isHidden": false,
        "description": "Empty graph has complete complement"
      },
      {
        "input": "[\"A\", \"B\", \"C\", \"D\"], [(\"A\", \"B\"), (\"C\", \"D\")]",
        "expectedOutput": "[(\"A\", \"C\"), (\"A\", \"D\"), (\"B\", \"C\"), (\"B\", \"D\")]",
        "isHidden": true,
        "description": "Disconnected graph"
      }
    ],
    "hints": [
      "The complement graph has the same vertices but opposite edges.",
      "If edge (u,v) exists in original graph, it does NOT exist in complement.",
      "Generate all possible pairs of vertices, then exclude existing edges.",
      "An independent set in G (no edges between vertices) becomes a clique in complement(G) (all edges between vertices)."
    ]
  }
]
[
  {
    "id": "cs201-quiz-5-1",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "DP Fundamentals",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What are the two key properties required for Dynamic Programming?",
        "options": [
          "Sorting and Searching",
          "Optimal Substructure and Overlapping Subproblems",
          "Divide and Conquer",
          "Greedy Choice and Local Optimum"
        ],
        "correctAnswer": 1,
        "explanation": "DP requires optimal substructure (solution built from subproblem solutions) and overlapping subproblems (same subproblems solved multiple times)."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What is Memoization?",
        "options": [
          "Bottom-up iteration",
          "Top-down recursion with caching",
          "Sorting before processing",
          "Using hash tables for search"
        ],
        "correctAnswer": 1,
        "explanation": "Memoization is top-down: solve recursively but cache results to avoid recomputation."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "The naive recursive Fibonacci has exponential time complexity O(2^n).",
        "correctAnswer": true,
        "explanation": "Without memoization, each call branches into two, creating an exponential number of calls."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What is the time complexity of Fibonacci with DP?",
        "options": [
          "O(2^n)",
          "O(n^2)",
          "O(n)",
          "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "With DP (memoization or tabulation), each subproblem is solved once, giving O(n) time."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "Building a solution from smallest subproblems up is called ______.",
        "correctAnswer": "Tabulation",
        "explanation": "Tabulation (bottom-up DP) fills a table starting from base cases, building up to the answer."
      }
    ]
  },
  {
    "id": "cs201-quiz-5-2",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "Classic DP Problems",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "In the 0/1 Knapsack problem, what does \"0/1\" mean?",
        "options": [
          "Items have binary weights",
          "Each item can be taken at most once (take or leave)",
          "There are only 2 items",
          "The knapsack has 1 compartment"
        ],
        "correctAnswer": 1,
        "explanation": "0/1 means each item is either taken (1) or not taken (0) - no fractions allowed."
      },
      {
        "id": "q2",
        "type": "code_output",
        "prompt": "What problem does this DP solve?",
        "codeSnippet": "dp[i][j] = dp[i-1][j-1] + 1 if s1[i-1] == s2[j-1]\n         else max(dp[i-1][j], dp[i][j-1])",
        "options": [
          "Edit Distance",
          "Longest Common Subsequence",
          "Knapsack",
          "Coin Change"
        ],
        "correctAnswer": 1,
        "explanation": "This recurrence finds the Longest Common Subsequence (LCS) by matching characters or taking max of excluding either."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "The Coin Change problem (minimum coins) can be solved greedily for all coin denominations.",
        "correctAnswer": false,
        "explanation": "Greedy fails for some denominations (e.g., coins [1,3,4] for amount 6: greedy gives 4+1+1=3 coins, optimal is 3+3=2)."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What is the space complexity of naive 2D DP for LCS of strings of length m and n?",
        "options": [
          "O(1)",
          "O(m+n)",
          "O(mn)",
          "O(m^2 + n^2)"
        ],
        "correctAnswer": 2,
        "explanation": "Standard LCS DP uses a 2D table of size m×n, giving O(mn) space."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "The \"Climbing Stairs\" problem (ways to climb n stairs with 1 or 2 steps) is equivalent to:",
        "options": [
          "Binary Search",
          "Fibonacci Sequence",
          "Quick Sort partition",
          "Graph BFS"
        ],
        "correctAnswer": 1,
        "explanation": "Ways(n) = Ways(n-1) + Ways(n-2), which is exactly the Fibonacci recurrence."
      }
    ]
  },
  {
    "id": "cs201-quiz-5-3",
    "subjectId": "cs201",
    "topicId": "cs201-5",
    "title": "DP Optimization",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "If dp[i] only depends on dp[i-1], what space optimization is possible?",
        "options": [
          "No optimization possible",
          "Reduce from O(n) to O(1)",
          "Reduce from O(n^2) to O(n)",
          "Use recursion instead"
        ],
        "correctAnswer": 1,
        "explanation": "When only the previous state is needed, use two variables instead of an array, achieving O(1) space."
      },
      {
        "id": "q2",
        "type": "true_false",
        "prompt": "Memoization and Tabulation always have the same time complexity for a given problem.",
        "correctAnswer": true,
        "explanation": "Both approaches solve each unique subproblem exactly once, resulting in the same asymptotic time complexity."
      },
      {
        "id": "q3",
        "type": "multiple_choice",
        "prompt": "What is a key advantage of Tabulation over Memoization?",
        "options": [
          "Easier to implement",
          "No recursion stack overhead",
          "Better time complexity",
          "Works on more problems"
        ],
        "correctAnswer": 1,
        "explanation": "Tabulation uses iteration, avoiding recursion stack overflow issues for large inputs."
      },
      {
        "id": "q4",
        "type": "code_output",
        "prompt": "What is the space complexity of this optimized Fibonacci?",
        "codeSnippet": "def fib(n):\n    if n <= 1: return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b",
        "options": [
          "O(n)",
          "O(log n)",
          "O(1)",
          "O(n^2)"
        ],
        "correctAnswer": 2,
        "explanation": "Only two variables (a, b) are used regardless of n, giving O(1) space."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The number of unique subproblems determines the ______ of a DP solution.",
        "correctAnswer": "time complexity",
        "explanation": "Since each subproblem is solved once, total time equals number of subproblems × time per subproblem."
      }
    ]
  }
]

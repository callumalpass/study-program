[
  {
    "id": "cs201-ex-2-1",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Bubble Sort Implementation",
    "description": "Implement bubble sort to sort an array in ascending order. Compare adjacent elements and swap if they are in wrong order.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bubble_sort(arr):\n    # Your code here\n    pass",
    "solution": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr",
    "testCases": [
      {
        "input": "[64, 34, 25, 12, 22, 11, 90]",
        "expectedOutput": "[11, 12, 22, 25, 34, 64, 90]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 1, 4, 2, 8]",
        "expectedOutput": "[1, 2, 4, 5, 8]",
        "isHidden": false,
        "description": "Random order"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Use nested loops: outer loop for passes, inner loop for comparisons.",
      "Swap adjacent elements if they are in wrong order.",
      "Each pass bubbles the largest element to the end."
    ]
  },
  {
    "id": "cs201-ex-2-2",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Optimized Bubble Sort",
    "description": "Implement an optimized bubble sort that stops early if the array becomes sorted before all passes complete.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bubble_sort_optimized(arr):\n    # Add early exit optimization\n    pass",
    "solution": "def bubble_sort_optimized(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1, 2, 5, 3, 4]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Nearly sorted"
      }
    ],
    "hints": [
      "Use a flag to track if any swaps occurred.",
      "If no swaps in a pass, array is sorted.",
      "Break early to save time."
    ]
  },
  {
    "id": "cs201-ex-2-3",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Count Bubble Sort Swaps",
    "description": "Implement bubble sort and return a tuple of (sorted_array, swap_count) to count the number of swaps performed.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def bubble_sort_count_swaps(arr):\n    # Return (sorted_array, swap_count)\n    pass",
    "solution": "def bubble_sort_count_swaps(arr):\n    n = len(arr)\n    swaps = 0\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swaps += 1\n    return (arr, swaps)",
    "testCases": [
      {
        "input": "[3, 2, 1]",
        "expectedOutput": "([1, 2, 3], 3)",
        "isHidden": false,
        "description": "Reverse sorted requires 3 swaps"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "([1, 2, 3], 0)",
        "isHidden": false,
        "description": "Already sorted requires 0 swaps"
      },
      {
        "input": "[2, 1]",
        "expectedOutput": "([1, 2], 1)",
        "isHidden": false,
        "description": "Two elements"
      }
    ],
    "hints": [
      "Initialize a counter variable.",
      "Increment counter each time you swap.",
      "Return both array and count as a tuple."
    ]
  },
  {
    "id": "cs201-ex-2-4",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Bubble Sort Descending",
    "description": "Implement bubble sort to sort an array in descending order (largest to smallest).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "def bubble_sort_desc(arr):\n    pass",
    "solution": "def bubble_sort_desc(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] < arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr",
    "testCases": [
      {
        "input": "[64, 34, 25, 12, 22]",
        "expectedOutput": "[64, 34, 25, 22, 12]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[5, 4, 3, 2, 1]",
        "isHidden": false,
        "description": "Ascending to descending"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Change the comparison operator.",
      "Swap when left element is smaller than right."
    ]
  },
  {
    "id": "cs201-ex-2-5",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Selection Sort",
    "description": "Implement selection sort. Find the minimum element in unsorted portion and swap it with the first unsorted element.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def selection_sort(arr):\n    pass",
    "solution": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
    "testCases": [
      {
        "input": "[64, 25, 12, 22, 11]",
        "expectedOutput": "[11, 12, 22, 25, 64]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Outer loop marks the boundary of sorted/unsorted portions.",
      "Inner loop finds minimum in unsorted portion.",
      "Swap minimum with first unsorted element."
    ]
  },
  {
    "id": "cs201-ex-2-6",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Selection Sort with Maximum",
    "description": "Implement selection sort variant that finds the maximum element and places it at the end of unsorted portion.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def selection_sort_max(arr):\n    pass",
    "solution": "def selection_sort_max(arr):\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        max_idx = i\n        for j in range(0, i):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        arr[i], arr[max_idx] = arr[max_idx], arr[i]\n    return arr",
    "testCases": [
      {
        "input": "[64, 25, 12, 22, 11]",
        "expectedOutput": "[11, 12, 22, 25, 64]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[3, 1, 4, 1, 5]",
        "expectedOutput": "[1, 1, 3, 4, 5]",
        "isHidden": false,
        "description": "With duplicates"
      },
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      }
    ],
    "hints": [
      "Loop backwards from end to beginning.",
      "Find maximum in unsorted portion (0 to i).",
      "Place maximum at position i."
    ]
  },
  {
    "id": "cs201-ex-2-7",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Insertion Sort",
    "description": "Implement insertion sort. Build sorted array one element at a time by inserting each element into its correct position.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def insertion_sort(arr):\n    pass",
    "solution": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
    "testCases": [
      {
        "input": "[12, 11, 13, 5, 6]",
        "expectedOutput": "[5, 6, 11, 12, 13]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Start from second element (index 1).",
      "Save current element as key.",
      "Shift larger elements to the right.",
      "Insert key at correct position."
    ]
  },
  {
    "id": "cs201-ex-2-8",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Insertion Sort Comparison Counter",
    "description": "Implement insertion sort and count the number of comparisons made. Return (sorted_array, comparison_count).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def insertion_sort_count(arr):\n    # Return (sorted_array, comparison_count)\n    pass",
    "solution": "def insertion_sort_count(arr):\n    comparisons = 0\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0:\n            comparisons += 1\n            if arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            else:\n                break\n        arr[j + 1] = key\n    return (arr, comparisons)",
    "testCases": [
      {
        "input": "[1, 2, 3]",
        "expectedOutput": "([1, 2, 3], 2)",
        "isHidden": false,
        "description": "Already sorted - minimum comparisons"
      },
      {
        "input": "[3, 2, 1]",
        "expectedOutput": "([1, 2, 3], 3)",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[2, 1]",
        "expectedOutput": "([1, 2], 1)",
        "isHidden": false,
        "description": "Two elements"
      }
    ],
    "hints": [
      "Count each comparison in the while loop.",
      "Best case: already sorted = n-1 comparisons.",
      "Worst case: reverse sorted = n(n-1)/2 comparisons."
    ]
  },
  {
    "id": "cs201-ex-2-9",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Merge Step for Merge Sort",
    "description": "Implement the merge function that combines two sorted arrays into one sorted array. This is the key step in merge sort.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def merge(left, right):\n    # Merge two sorted arrays\n    pass",
    "solution": "def merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "testCases": [
      {
        "input": "[1, 3, 5], [2, 4, 6]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Interleaved arrays"
      },
      {
        "input": "[1, 2, 3], [4, 5, 6]",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Non-overlapping ranges"
      },
      {
        "input": "[], [1, 2, 3]",
        "expectedOutput": "[1, 2, 3]",
        "isHidden": true,
        "description": "Empty left array"
      },
      {
        "input": "[1, 2], []",
        "expectedOutput": "[1, 2]",
        "isHidden": true,
        "description": "Empty right array"
      }
    ],
    "hints": [
      "Use two pointers, one for each array.",
      "Compare elements and append smaller one.",
      "Remember to append remaining elements."
    ]
  },
  {
    "id": "cs201-ex-2-10",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Merge Sort",
    "description": "Implement merge sort using divide-and-conquer. Recursively split array in half, sort each half, then merge.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_sort(arr):\n    pass",
    "solution": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "testCases": [
      {
        "input": "[38, 27, 43, 3, 9, 82, 10]",
        "expectedOutput": "[3, 9, 10, 27, 38, 43, 82]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Base case: arrays with 0 or 1 elements are already sorted.",
      "Split array at midpoint.",
      "Recursively sort left and right halves.",
      "Merge the sorted halves."
    ]
  },
  {
    "id": "cs201-ex-2-11",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Merge Sorted Subarrays",
    "description": "Given an array and indices (left, mid, right), merge the two sorted subarrays arr[left:mid+1] and arr[mid+1:right+1].",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def merge_subarrays(arr, left, mid, right):\n    # Merge arr[left:mid+1] and arr[mid+1:right+1]\n    pass",
    "solution": "def merge_subarrays(arr, left, mid, right):\n    left_arr = arr[left:mid+1]\n    right_arr = arr[mid+1:right+1]\n    i = j = 0\n    k = left\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n    return arr",
    "testCases": [
      {
        "input": "[1, 3, 5, 2, 4, 6], 0, 2, 5",
        "expectedOutput": "[1, 2, 3, 4, 5, 6]",
        "isHidden": false,
        "description": "Merge two sorted halves"
      },
      {
        "input": "[1, 4, 2, 3], 0, 1, 3",
        "expectedOutput": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "Smaller array"
      }
    ],
    "hints": [
      "Create temporary copies of subarrays.",
      "Merge back into original array starting at index left.",
      "Use three pointers: i for left subarray, j for right, k for original."
    ]
  },
  {
    "id": "cs201-ex-2-12",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Bottom-Up Merge Sort",
    "description": "Implement iterative (bottom-up) merge sort. Start with size 1 subarrays, merge pairs, then size 2, size 4, etc.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def merge_sort_iterative(arr):\n    pass",
    "solution": "def merge_sort_iterative(arr):\n    n = len(arr)\n    size = 1\n    while size < n:\n        for start in range(0, n, size * 2):\n            mid = min(start + size - 1, n - 1)\n            end = min(start + size * 2 - 1, n - 1)\n            if mid < end:\n                merge_subarrays(arr, start, mid, end)\n        size *= 2\n    return arr\n\ndef merge_subarrays(arr, left, mid, right):\n    left_arr = arr[left:mid+1]\n    right_arr = arr[mid+1:right+1]\n    i = j = 0\n    k = left\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1",
    "testCases": [
      {
        "input": "[38, 27, 43, 3, 9, 82, 10]",
        "expectedOutput": "[3, 9, 10, 27, 38, 43, 82]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3, 4]",
        "expectedOutput": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "Already sorted"
      }
    ],
    "hints": [
      "Start with subarray size = 1.",
      "Double size each iteration.",
      "Merge adjacent subarrays of current size."
    ]
  },
  {
    "id": "cs201-ex-2-13",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Partition Function for Quick Sort",
    "description": "Implement the partition function for quick sort. Choose last element as pivot, rearrange so smaller elements are left, larger are right. Return pivot index.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def partition(arr, low, high):\n    # Partition around last element (pivot)\n    # Return pivot index\n    pass",
    "solution": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "testCases": [
      {
        "input": "[10, 80, 30, 90, 40, 50, 70], 0, 6",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Pivot 70 ends at index 4"
      },
      {
        "input": "[3, 1, 2], 0, 2",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Small array"
      }
    ],
    "hints": [
      "Pivot is arr[high].",
      "i tracks position for next small element.",
      "Swap elements <= pivot to left side.",
      "Finally place pivot in correct position."
    ]
  },
  {
    "id": "cs201-ex-2-14",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Quick Sort",
    "description": "Implement quick sort using the partition function. Recursively sort elements before and after partition.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    # Your code here\n    pass",
    "solution": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n    return arr\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "testCases": [
      {
        "input": "[10, 7, 8, 9, 1, 5]",
        "expectedOutput": "[1, 5, 7, 8, 9, 10]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "isHidden": true,
        "description": "Single element"
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Base case: if low >= high, return.",
      "Partition array and get pivot index.",
      "Recursively sort left side (low to pi-1).",
      "Recursively sort right side (pi+1 to high)."
    ]
  },
  {
    "id": "cs201-ex-2-15",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Quick Sort with Random Pivot",
    "description": "Implement quick sort with randomized pivot selection to avoid worst-case O(n^2) on sorted arrays.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "import random\n\ndef quick_sort_random(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    pass",
    "solution": "import random\n\ndef quick_sort_random(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        pi = partition_random(arr, low, high)\n        quick_sort_random(arr, low, pi - 1)\n        quick_sort_random(arr, pi + 1, high)\n    return arr\n\ndef partition_random(arr, low, high):\n    random_idx = random.randint(low, high)\n    arr[random_idx], arr[high] = arr[high], arr[random_idx]\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "testCases": [
      {
        "input": "[10, 7, 8, 9, 1, 5]",
        "expectedOutput": "[1, 5, 7, 8, 9, 10]",
        "isHidden": false,
        "description": "Unsorted array"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Already sorted - random pivot helps"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "expectedOutput": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Reverse sorted"
      }
    ],
    "hints": [
      "Pick random index between low and high.",
      "Swap random element with last element.",
      "Use regular partition with last element as pivot.",
      "This averages O(n log n) even on sorted arrays."
    ]
  },
  {
    "id": "cs201-ex-2-16",
    "subjectId": "cs201",
    "topicId": "cs201-2",
    "title": "Quick Sort with Three-Way Partition",
    "description": "Implement quick sort using three-way partitioning (Dutch National Flag). Efficiently handles arrays with many duplicate elements.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "def quick_sort_3way(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    pass",
    "solution": "def quick_sort_3way(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        lt, gt = partition_3way(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    return arr\n\ndef partition_3way(arr, low, high):\n    pivot = arr[low]\n    lt = low\n    gt = high\n    i = low\n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[gt], arr[i] = arr[i], arr[gt]\n            gt -= 1\n        else:\n            i += 1\n    return lt, gt",
    "testCases": [
      {
        "input": "[4, 2, 3, 4, 1, 4, 2, 4]",
        "expectedOutput": "[1, 2, 2, 3, 4, 4, 4, 4]",
        "isHidden": false,
        "description": "Many duplicates"
      },
      {
        "input": "[5, 5, 5, 5, 5]",
        "expectedOutput": "[5, 5, 5, 5, 5]",
        "isHidden": false,
        "description": "All same elements"
      },
      {
        "input": "[3, 1, 2, 3, 1]",
        "expectedOutput": "[1, 1, 2, 3, 3]",
        "isHidden": false,
        "description": "Some duplicates"
      }
    ],
    "hints": [
      "Partition into three sections: < pivot, == pivot, > pivot.",
      "Use three pointers: lt (less than), i (current), gt (greater than).",
      "Elements equal to pivot stay in middle, no need to sort again.",
      "Recursively sort only < and > sections."
    ]
  }
]

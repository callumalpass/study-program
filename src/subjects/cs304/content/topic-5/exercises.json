[
  {
    "id": "cs304-t5-ex01",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Simple Expression Code Generator",
    "difficulty": 1,
    "description": "Implement a basic code generator that converts arithmetic expressions into three-address code instructions. Given an expression tree, generate a sequence of instructions.",
    "starterCode": "class CodeGenerator:\n    def __init__(self):\n        self.temp_count = 0\n        self.instructions = []\n\n    def new_temp(self):\n        \"\"\"Generate a new temporary variable name.\"\"\"\n        temp = f\"t{self.temp_count}\"\n        self.temp_count += 1\n        return temp\n\n    def generate(self, expr):\n        \"\"\"\n        Generate code for an expression.\n        expr is a dict with 'op' and 'left'/'right' for binary ops,\n        or 'value' for constants.\n        Returns the temporary variable holding the result.\n        \"\"\"\n        # TODO: Implement code generation\n        pass\n\n# Example usage:\n# gen = CodeGenerator()\n# expr = {'op': '+', 'left': {'value': 5}, 'right': {'value': 3}}\n# result = gen.generate(expr)\n# print(gen.instructions)",
    "solution": "class CodeGenerator:\n    def __init__(self):\n        self.temp_count = 0\n        self.instructions = []\n\n    def new_temp(self):\n        \"\"\"Generate a new temporary variable name.\"\"\"\n        temp = f\"t{self.temp_count}\"\n        self.temp_count += 1\n        return temp\n\n    def generate(self, expr):\n        \"\"\"\n        Generate code for an expression.\n        expr is a dict with 'op' and 'left'/'right' for binary ops,\n        or 'value' for constants.\n        Returns the temporary variable holding the result.\n        \"\"\"\n        if 'value' in expr:\n            # Constant value\n            return str(expr['value'])\n\n        # Binary operation\n        left_result = self.generate(expr['left'])\n        right_result = self.generate(expr['right'])\n        temp = self.new_temp()\n\n        self.instructions.append(f\"{temp} = {left_result} {expr['op']} {right_result}\")\n        return temp",
    "testCases": [
      {
        "input": "gen = CodeGenerator()\nexpr = {'op': '+', 'left': {'value': 5}, 'right': {'value': 3}}\nresult = gen.generate(expr)\nprint(','.join(gen.instructions))",
        "expectedOutput": "t0 = 5 + 3",
        "isHidden": false,
        "description": "Simple addition"
      },
      {
        "input": "gen = CodeGenerator()\nexpr = {'op': '*', 'left': {'op': '+', 'left': {'value': 2}, 'right': {'value': 3}}, 'right': {'value': 4}}\nresult = gen.generate(expr)\nprint(','.join(gen.instructions))",
        "expectedOutput": "t0 = 2 + 3,t1 = t0 * 4",
        "isHidden": false,
        "description": "Nested expression (2 + 3) * 4"
      },
      {
        "input": "gen = CodeGenerator()\nexpr = {'op': '-', 'left': {'op': '*', 'left': {'value': 5}, 'right': {'value': 6}}, 'right': {'op': '+', 'left': {'value': 2}, 'right': {'value': 1}}}\nresult = gen.generate(expr)\nprint(','.join(gen.instructions))",
        "isHidden": true,
        "description": "Complex expression (5 * 6) - (2 + 1)"
      }
    ],
    "hints": [
      "Use recursion to handle nested expressions",
      "Generate code for left and right operands first",
      "Create a new temporary for each operation result",
      "For constants, return the value directly without creating a temporary"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex02",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Instruction Selection with Costs",
    "difficulty": 2,
    "description": "Implement an instruction selector that chooses between multiple instruction patterns based on cost. Select the cheapest instruction sequence to implement operations.",
    "starterCode": "class InstructionSelector:\n    def __init__(self):\n        self.instructions = []\n        # Cost table: operation -> (instruction_template, cost)\n        self.patterns = {\n            'add_imm': ('ADD {dest}, {src}, #{imm}', 1),  # Add immediate\n            'add_reg': ('ADD {dest}, {src1}, {src2}', 1),  # Add registers\n            'load_imm': ('MOV {dest}, #{imm}', 1),  # Load immediate\n            'load_add': ('LDR {dest}, [#{addr}]', 2),  # Load from memory then add\n        }\n\n    def select_add(self, dest, left, right):\n        \"\"\"\n        Select best instruction(s) for addition.\n        left and right can be registers or immediate values (dict with 'imm' key).\n        Returns total cost.\n        \"\"\"\n        # TODO: Implement instruction selection\n        pass",
    "solution": "class InstructionSelector:\n    def __init__(self):\n        self.instructions = []\n        # Cost table: operation -> (instruction_template, cost)\n        self.patterns = {\n            'add_imm': ('ADD {dest}, {src}, #{imm}', 1),  # Add immediate\n            'add_reg': ('ADD {dest}, {src1}, {src2}', 1),  # Add registers\n            'load_imm': ('MOV {dest}, #{imm}', 1),  # Load immediate\n            'load_add': ('LDR {dest}, [#{addr}]', 2),  # Load from memory then add\n        }\n\n    def select_add(self, dest, left, right):\n        \"\"\"\n        Select best instruction(s) for addition.\n        left and right can be registers or immediate values (dict with 'imm' key).\n        Returns total cost.\n        \"\"\"\n        total_cost = 0\n\n        # Both are registers\n        if isinstance(left, str) and isinstance(right, str):\n            template, cost = self.patterns['add_reg']\n            self.instructions.append(template.format(dest=dest, src1=left, src2=right))\n            total_cost = cost\n\n        # Right is immediate\n        elif isinstance(left, str) and isinstance(right, dict) and 'imm' in right:\n            template, cost = self.patterns['add_imm']\n            self.instructions.append(template.format(dest=dest, src=left, imm=right['imm']))\n            total_cost = cost\n\n        # Left is immediate\n        elif isinstance(left, dict) and 'imm' in left and isinstance(right, str):\n            template, cost = self.patterns['add_imm']\n            self.instructions.append(template.format(dest=dest, src=right, imm=left['imm']))\n            total_cost = cost\n\n        # Both are immediates - need to load one first\n        elif isinstance(left, dict) and isinstance(right, dict):\n            template, cost = self.patterns['load_imm']\n            temp = 'r_temp'\n            self.instructions.append(template.format(dest=temp, imm=left['imm']))\n            total_cost += cost\n\n            template, cost = self.patterns['add_imm']\n            self.instructions.append(template.format(dest=dest, src=temp, imm=right['imm']))\n            total_cost += cost\n\n        return total_cost",
    "testCases": [
      {
        "input": "sel = InstructionSelector()\ncost = sel.select_add('r0', 'r1', {'imm': 5})\nprint(cost)\nprint(sel.instructions[0])",
        "expectedOutput": "1\nADD r0, r1, #5",
        "isHidden": false,
        "description": "Register + immediate"
      },
      {
        "input": "sel = InstructionSelector()\ncost = sel.select_add('r0', 'r1', 'r2')\nprint(cost)\nprint(sel.instructions[0])",
        "expectedOutput": "1\nADD r0, r1, r2",
        "isHidden": false,
        "description": "Register + register"
      },
      {
        "input": "sel = InstructionSelector()\ncost = sel.select_add('r0', {'imm': 10}, {'imm': 20})\nprint(cost)\nprint(len(sel.instructions))",
        "isHidden": true,
        "description": "Two immediates (requires load first)"
      }
    ],
    "hints": [
      "Check the types of operands to determine which pattern to use",
      "Immediate values are represented as dicts with an \"imm\" key",
      "When both operands are immediates, you need to load one into a register first",
      "Return the sum of costs for all instructions generated"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex03",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Basic Register Allocator",
    "difficulty": 3,
    "description": "Implement a simple register allocator that assigns registers to variables using a linear scan approach. Handle register spilling when registers run out.",
    "starterCode": "class RegisterAllocator:\n    def __init__(self, num_registers=4):\n        self.num_registers = num_registers\n        self.allocation = {}  # variable -> register\n        self.free_registers = [f\"r{i}\" for i in range(num_registers)]\n        self.spilled = []  # variables that had to be spilled\n\n    def allocate(self, variable, live_ranges):\n        \"\"\"\n        Allocate a register for a variable.\n        live_ranges: dict mapping variable -> (start, end) positions\n        Returns the allocated register or 'SPILL' if no registers available.\n        \"\"\"\n        # TODO: Implement register allocation\n        pass\n\n    def free(self, variable):\n        \"\"\"Free the register used by a variable.\"\"\"\n        # TODO: Implement register freeing\n        pass",
    "solution": "class RegisterAllocator:\n    def __init__(self, num_registers=4):\n        self.num_registers = num_registers\n        self.allocation = {}  # variable -> register\n        self.free_registers = [f\"r{i}\" for i in range(num_registers)]\n        self.spilled = []  # variables that had to be spilled\n\n    def allocate(self, variable, live_ranges):\n        \"\"\"\n        Allocate a register for a variable.\n        live_ranges: dict mapping variable -> (start, end) positions\n        Returns the allocated register or 'SPILL' if no registers available.\n        \"\"\"\n        if variable in self.allocation:\n            return self.allocation[variable]\n\n        # Try to allocate a free register\n        if self.free_registers:\n            reg = self.free_registers.pop(0)\n            self.allocation[variable] = reg\n            return reg\n\n        # No free registers - need to spill\n        # Find a variable to spill (choose one with earliest end time that hasn't ended yet)\n        current_pos = live_ranges[variable][0]\n        spill_candidate = None\n        earliest_end = float('inf')\n\n        for var, reg in self.allocation.items():\n            var_start, var_end = live_ranges.get(var, (0, float('inf')))\n            if var_end < current_pos:\n                # This variable's live range has ended, we can reuse its register\n                spill_candidate = var\n                break\n            elif var_end < earliest_end:\n                earliest_end = var_end\n                spill_candidate = var\n\n        if spill_candidate:\n            # Spill the candidate and reuse its register\n            reg = self.allocation[spill_candidate]\n            del self.allocation[spill_candidate]\n            self.spilled.append(spill_candidate)\n            self.allocation[variable] = reg\n            return reg\n\n        # All registers in use with longer live ranges\n        self.spilled.append(variable)\n        return 'SPILL'\n\n    def free(self, variable):\n        \"\"\"Free the register used by a variable.\"\"\"\n        if variable in self.allocation:\n            reg = self.allocation[variable]\n            del self.allocation[variable]\n            self.free_registers.append(reg)",
    "testCases": [
      {
        "input": "alloc = RegisterAllocator(num_registers=2)\nlive_ranges = {'a': (0, 5), 'b': (1, 3), 'c': (4, 8)}\nr1 = alloc.allocate('a', live_ranges)\nr2 = alloc.allocate('b', live_ranges)\nprint(f\"{r1},{r2}\")",
        "expectedOutput": "r0,r1",
        "isHidden": false,
        "description": "Simple allocation with available registers"
      },
      {
        "input": "alloc = RegisterAllocator(num_registers=2)\nlive_ranges = {'a': (0, 5), 'b': (1, 3), 'c': (2, 8)}\nr1 = alloc.allocate('a', live_ranges)\nr2 = alloc.allocate('b', live_ranges)\nr3 = alloc.allocate('c', live_ranges)\nprint(f\"{r3}\" if r3 == 'SPILL' else r3)",
        "isHidden": false,
        "description": "Allocation requiring spilling"
      },
      {
        "input": "alloc = RegisterAllocator(num_registers=2)\nlive_ranges = {'a': (0, 2), 'b': (3, 5), 'c': (6, 8)}\nr1 = alloc.allocate('a', live_ranges)\nalloc.free('a')\nr2 = alloc.allocate('b', live_ranges)\nprint(f\"{r1},{r2}\")",
        "isHidden": true,
        "description": "Register reuse after freeing"
      }
    ],
    "hints": [
      "Keep track of which registers are free and which are allocated",
      "When all registers are in use, choose a variable to spill",
      "A good spilling heuristic is to spill the variable with the earliest end time",
      "Check if any allocated variables have already ended their live range"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex04",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Live Range Analysis",
    "difficulty": 2,
    "description": "Implement live range analysis for variables in a sequence of three-address code instructions. Determine where each variable is live (defined and used).",
    "starterCode": "def compute_live_ranges(instructions):\n    \"\"\"\n    Compute live ranges for variables in three-address code.\n    instructions: list of strings like \"t0 = a + b\"\n    Returns: dict mapping variable -> (first_use, last_use) line numbers\n    \"\"\"\n    # TODO: Implement live range analysis\n    pass\n\n# Example:\n# instructions = [\"t0 = a + b\", \"t1 = t0 * c\", \"d = t1 + t0\"]\n# Returns: {'a': (0, 0), 'b': (0, 0), 't0': (0, 2), 'c': (1, 1), 't1': (1, 2), 'd': (2, 2)}",
    "solution": "def compute_live_ranges(instructions):\n    \"\"\"\n    Compute live ranges for variables in three-address code.\n    instructions: list of strings like \"t0 = a + b\"\n    Returns: dict mapping variable -> (first_use, last_use) line numbers\n    \"\"\"\n    live_ranges = {}\n\n    for i, instr in enumerate(instructions):\n        # Parse instruction: \"dest = operand1 op operand2\" or \"dest = operand\"\n        parts = instr.split('=')\n        if len(parts) != 2:\n            continue\n\n        dest = parts[0].strip()\n        expr = parts[1].strip()\n\n        # Update destination variable\n        if dest not in live_ranges:\n            live_ranges[dest] = (i, i)\n        else:\n            live_ranges[dest] = (live_ranges[dest][0], i)\n\n        # Extract and update operand variables\n        # Simple tokenization: split by operators and spaces\n        tokens = expr.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n\n        for token in tokens:\n            token = token.strip()\n            # Check if it's a variable (not a number)\n            if token and not token.isdigit():\n                if token not in live_ranges:\n                    live_ranges[token] = (i, i)\n                else:\n                    live_ranges[token] = (live_ranges[token][0], i)\n\n    return live_ranges",
    "testCases": [
      {
        "input": "instructions = [\"t0 = a + b\", \"t1 = t0 * c\", \"d = t1 + t0\"]\nranges = compute_live_ranges(instructions)\nprint(f\"{ranges['t0'][0]},{ranges['t0'][1]}\")",
        "expectedOutput": "0,2",
        "isHidden": false,
        "description": "Variable t0 used from line 0 to 2"
      },
      {
        "input": "instructions = [\"x = 5 + 3\", \"y = x * 2\", \"z = y + x\"]\nranges = compute_live_ranges(instructions)\nprint(len(ranges))",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Count of variables"
      },
      {
        "input": "instructions = [\"a = b + c\", \"d = a + e\", \"f = d - a\"]\nranges = compute_live_ranges(instructions)\nprint(f\"{ranges['a'][0]},{ranges['a'][1]}\")",
        "isHidden": true,
        "description": "Variable a live range"
      }
    ],
    "hints": [
      "Track both definitions (left side of =) and uses (right side)",
      "For each variable, record the first and last line where it appears",
      "Parse instructions by splitting on operators to find all variables",
      "Numbers are not variables and should be ignored"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex05",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Graph Coloring Register Allocation",
    "difficulty": 4,
    "description": "Implement register allocation using graph coloring. Build an interference graph and color it with K colors representing K registers.",
    "starterCode": "class GraphColoringAllocator:\n    def __init__(self, num_registers):\n        self.num_registers = num_registers\n        self.graph = {}  # adjacency list: variable -> set of interfering variables\n        self.colors = {}  # variable -> register number\n        self.spilled = []\n\n    def add_interference(self, var1, var2):\n        \"\"\"Add an interference edge between two variables.\"\"\"\n        # TODO: Implement\n        pass\n\n    def color_graph(self):\n        \"\"\"\n        Color the interference graph using greedy coloring.\n        Returns dict mapping variable -> register number (0 to num_registers-1).\n        Variables that can't be colored are added to self.spilled.\n        \"\"\"\n        # TODO: Implement graph coloring\n        pass",
    "solution": "class GraphColoringAllocator:\n    def __init__(self, num_registers):\n        self.num_registers = num_registers\n        self.graph = {}  # adjacency list: variable -> set of interfering variables\n        self.colors = {}  # variable -> register number\n        self.spilled = []\n\n    def add_interference(self, var1, var2):\n        \"\"\"Add an interference edge between two variables.\"\"\"\n        if var1 not in self.graph:\n            self.graph[var1] = set()\n        if var2 not in self.graph:\n            self.graph[var2] = set()\n\n        self.graph[var1].add(var2)\n        self.graph[var2].add(var1)\n\n    def color_graph(self):\n        \"\"\"\n        Color the interference graph using greedy coloring.\n        Returns dict mapping variable -> register number (0 to num_registers-1).\n        Variables that can't be colored are added to self.spilled.\n        \"\"\"\n        # Sort variables by degree (most constrained first)\n        variables = sorted(self.graph.keys(),\n                         key=lambda v: len(self.graph[v]),\n                         reverse=True)\n\n        for var in variables:\n            # Find colors used by neighbors\n            used_colors = set()\n            for neighbor in self.graph[var]:\n                if neighbor in self.colors:\n                    used_colors.add(self.colors[neighbor])\n\n            # Try to find an available color\n            available = None\n            for color in range(self.num_registers):\n                if color not in used_colors:\n                    available = color\n                    break\n\n            if available is not None:\n                self.colors[var] = available\n            else:\n                # Can't color this variable - spill it\n                self.spilled.append(var)\n\n        return self.colors",
    "testCases": [
      {
        "input": "alloc = GraphColoringAllocator(num_registers=3)\nalloc.add_interference('a', 'b')\nalloc.add_interference('b', 'c')\nalloc.add_interference('a', 'c')\ncolors = alloc.color_graph()\nprint(len(set(colors.values())))",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Triangle graph needs 3 colors"
      },
      {
        "input": "alloc = GraphColoringAllocator(num_registers=2)\nalloc.add_interference('a', 'b')\nalloc.add_interference('c', 'd')\ncolors = alloc.color_graph()\nprint(len(colors))",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Two independent edges need 2 colors"
      },
      {
        "input": "alloc = GraphColoringAllocator(num_registers=2)\nalloc.add_interference('a', 'b')\nalloc.add_interference('b', 'c')\nalloc.add_interference('c', 'a')\ncolors = alloc.color_graph()\nprint(len(alloc.spilled))",
        "isHidden": true,
        "description": "Triangle with only 2 registers requires spilling"
      }
    ],
    "hints": [
      "Build an adjacency list representation of the interference graph",
      "Use a greedy coloring algorithm: assign the lowest available color to each node",
      "Sort variables by degree (number of interferences) to improve coloring",
      "If no color is available for a variable, it must be spilled"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex06",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Instruction Scheduling with Dependencies",
    "difficulty": 3,
    "description": "Implement instruction scheduling that reorders instructions to minimize pipeline stalls while respecting data dependencies.",
    "starterCode": "class InstructionScheduler:\n    def __init__(self):\n        self.dependencies = {}  # instruction_id -> list of dependency instruction_ids\n\n    def add_dependency(self, instr_id, depends_on):\n        \"\"\"Add a dependency: instr_id depends on depends_on.\"\"\"\n        if instr_id not in self.dependencies:\n            self.dependencies[instr_id] = []\n        self.dependencies[instr_id].append(depends_on)\n\n    def schedule(self, instructions):\n        \"\"\"\n        Schedule instructions respecting dependencies.\n        instructions: list of instruction IDs\n        Returns: list of instruction IDs in scheduled order\n        \"\"\"\n        # TODO: Implement topological sort for scheduling\n        pass",
    "solution": "class InstructionScheduler:\n    def __init__(self):\n        self.dependencies = {}  # instruction_id -> list of dependency instruction_ids\n\n    def add_dependency(self, instr_id, depends_on):\n        \"\"\"Add a dependency: instr_id depends on depends_on.\"\"\"\n        if instr_id not in self.dependencies:\n            self.dependencies[instr_id] = []\n        self.dependencies[instr_id].append(depends_on)\n\n    def schedule(self, instructions):\n        \"\"\"\n        Schedule instructions respecting dependencies.\n        instructions: list of instruction IDs\n        Returns: list of instruction IDs in scheduled order\n        \"\"\"\n        # Initialize all instructions with empty dependencies if not present\n        for instr in instructions:\n            if instr not in self.dependencies:\n                self.dependencies[instr] = []\n\n        # Topological sort using Kahn's algorithm\n        # Count incoming edges\n        in_degree = {instr: 0 for instr in instructions}\n        for instr in instructions:\n            for dep in self.dependencies[instr]:\n                if dep in in_degree:\n                    in_degree[instr] += 1\n\n        # Queue of instructions with no dependencies\n        ready = [instr for instr in instructions if in_degree[instr] == 0]\n        scheduled = []\n\n        while ready:\n            # Pick instruction with no dependencies\n            current = ready.pop(0)\n            scheduled.append(current)\n\n            # Update in-degrees for instructions that depend on current\n            for instr in instructions:\n                if current in self.dependencies[instr]:\n                    in_degree[instr] -= 1\n                    if in_degree[instr] == 0 and instr not in scheduled:\n                        ready.append(instr)\n\n        return scheduled",
    "testCases": [
      {
        "input": "scheduler = InstructionScheduler()\nscheduler.add_dependency('i2', 'i1')\nscheduler.add_dependency('i3', 'i1')\nscheduled = scheduler.schedule(['i1', 'i2', 'i3'])\nprint(scheduled[0])",
        "expectedOutput": "i1",
        "isHidden": false,
        "description": "i1 must come first"
      },
      {
        "input": "scheduler = InstructionScheduler()\nscheduler.add_dependency('i2', 'i1')\nscheduler.add_dependency('i3', 'i2')\nscheduled = scheduler.schedule(['i1', 'i2', 'i3'])\nprint(','.join(scheduled))",
        "expectedOutput": "i1,i2,i3",
        "isHidden": false,
        "description": "Linear dependency chain"
      },
      {
        "input": "scheduler = InstructionScheduler()\nscheduler.add_dependency('i3', 'i1')\nscheduler.add_dependency('i3', 'i2')\nscheduled = scheduler.schedule(['i1', 'i2', 'i3'])\nprint(scheduled[2])",
        "isHidden": true,
        "description": "i3 depends on both i1 and i2"
      }
    ],
    "hints": [
      "Use topological sorting to order instructions",
      "Kahn's algorithm works by repeatedly selecting nodes with no incoming edges",
      "Track the in-degree (number of dependencies) for each instruction",
      "Instructions with no dependencies can be scheduled first"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex07",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Stack Frame Layout Generator",
    "difficulty": 2,
    "description": "Generate stack frame layout for a function, including space for local variables, parameters, and saved registers.",
    "starterCode": "class StackFrameGenerator:\n    def __init__(self, word_size=4):\n        self.word_size = word_size  # bytes per word\n\n    def generate_layout(self, num_params, local_vars, saved_regs):\n        \"\"\"\n        Generate stack frame layout.\n        num_params: number of parameters\n        local_vars: list of (name, size_in_words) tuples\n        saved_regs: list of register names to save\n\n        Returns: dict with 'total_size' and 'offsets' (dict of name->offset from FP)\n        \"\"\"\n        # TODO: Implement stack frame layout\n        # Layout (growing downward):\n        # - Parameters (above frame pointer)\n        # - Saved registers\n        # - Local variables\n        pass",
    "solution": "class StackFrameGenerator:\n    def __init__(self, word_size=4):\n        self.word_size = word_size  # bytes per word\n\n    def generate_layout(self, num_params, local_vars, saved_regs):\n        \"\"\"\n        Generate stack frame layout.\n        num_params: number of parameters\n        local_vars: list of (name, size_in_words) tuples\n        saved_regs: list of register names to save\n\n        Returns: dict with 'total_size' and 'offsets' (dict of name->offset from FP)\n        \"\"\"\n        offsets = {}\n        current_offset = 0\n\n        # Parameters are at positive offsets (above FP)\n        for i in range(num_params):\n            param_name = f\"param{i}\"\n            offsets[param_name] = (i + 1) * self.word_size\n\n        # Saved registers at negative offsets (below FP)\n        for i, reg in enumerate(saved_regs):\n            current_offset -= self.word_size\n            offsets[reg] = current_offset\n\n        # Local variables below saved registers\n        for name, size_words in local_vars:\n            current_offset -= size_words * self.word_size\n            offsets[name] = current_offset\n\n        # Total frame size is absolute value of most negative offset\n        total_size = abs(current_offset)\n\n        return {\n            'total_size': total_size,\n            'offsets': offsets\n        }",
    "testCases": [
      {
        "input": "gen = StackFrameGenerator(word_size=4)\nlayout = gen.generate_layout(2, [('x', 1), ('y', 1)], ['r1', 'r2'])\nprint(layout['total_size'])",
        "expectedOutput": "16",
        "isHidden": false,
        "description": "2 saved regs + 2 locals = 16 bytes"
      },
      {
        "input": "gen = StackFrameGenerator(word_size=4)\nlayout = gen.generate_layout(1, [('arr', 4)], ['r1'])\nprint(layout['offsets']['arr'])",
        "expectedOutput": "-20",
        "isHidden": false,
        "description": "Array offset below saved register"
      },
      {
        "input": "gen = StackFrameGenerator(word_size=4)\nlayout = gen.generate_layout(3, [], [])\nprint(layout['offsets']['param1'])",
        "isHidden": true,
        "description": "Parameter offset above frame pointer"
      }
    ],
    "hints": [
      "Parameters are at positive offsets from the frame pointer",
      "Saved registers and local variables are at negative offsets",
      "Allocate space in order: saved registers first, then local variables",
      "Total frame size is the sum of all space needed below the frame pointer"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex08",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Calling Convention Implementation",
    "difficulty": 3,
    "description": "Implement code generation for function calls following a specific calling convention (caller-save vs callee-save registers).",
    "starterCode": "class CallingConvention:\n    def __init__(self):\n        self.caller_save = ['r0', 'r1', 'r2']  # Caller must save these\n        self.callee_save = ['r3', 'r4', 'r5']  # Callee must save these\n        self.instructions = []\n\n    def generate_call(self, function_name, args, live_regs):\n        \"\"\"\n        Generate code for a function call.\n        args: list of argument values\n        live_regs: set of registers that are live across the call\n        \"\"\"\n        # TODO: Generate caller-side code\n        # 1. Save caller-save registers that are live\n        # 2. Move arguments to parameter registers\n        # 3. Call function\n        # 4. Restore caller-save registers\n        pass\n\n    def generate_prologue(self, used_callee_save):\n        \"\"\"Generate function prologue saving callee-save registers.\"\"\"\n        # TODO: Save registers that the function will use\n        pass\n\n    def generate_epilogue(self, used_callee_save):\n        \"\"\"Generate function epilogue restoring callee-save registers.\"\"\"\n        # TODO: Restore saved registers\n        pass",
    "solution": "class CallingConvention:\n    def __init__(self):\n        self.caller_save = ['r0', 'r1', 'r2']  # Caller must save these\n        self.callee_save = ['r3', 'r4', 'r5']  # Callee must save these\n        self.instructions = []\n\n    def generate_call(self, function_name, args, live_regs):\n        \"\"\"\n        Generate code for a function call.\n        args: list of argument values\n        live_regs: set of registers that are live across the call\n        \"\"\"\n        # Save caller-save registers that are live\n        saved = []\n        for reg in self.caller_save:\n            if reg in live_regs:\n                self.instructions.append(f\"PUSH {reg}\")\n                saved.append(reg)\n\n        # Move arguments to parameter registers\n        for i, arg in enumerate(args[:len(self.caller_save)]):\n            self.instructions.append(f\"MOV r{i}, {arg}\")\n\n        # Call function\n        self.instructions.append(f\"CALL {function_name}\")\n\n        # Restore caller-save registers in reverse order\n        for reg in reversed(saved):\n            self.instructions.append(f\"POP {reg}\")\n\n    def generate_prologue(self, used_callee_save):\n        \"\"\"Generate function prologue saving callee-save registers.\"\"\"\n        for reg in used_callee_save:\n            if reg in self.callee_save:\n                self.instructions.append(f\"PUSH {reg}\")\n\n    def generate_epilogue(self, used_callee_save):\n        \"\"\"Generate function epilogue restoring callee-save registers.\"\"\"\n        for reg in reversed(used_callee_save):\n            if reg in self.callee_save:\n                self.instructions.append(f\"POP {reg}\")",
    "testCases": [
      {
        "input": "cc = CallingConvention()\ncc.generate_call('foo', ['5', '10'], {'r0', 'r1'})\nprint(cc.instructions[0])",
        "expectedOutput": "PUSH r0",
        "isHidden": false,
        "description": "Save live caller-save registers"
      },
      {
        "input": "cc = CallingConvention()\ncc.generate_prologue(['r3', 'r4'])\nprint(len(cc.instructions))",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Prologue saves 2 callee-save registers"
      },
      {
        "input": "cc = CallingConvention()\ncc.generate_call('bar', ['1', '2', '3'], {'r1'})\ncount = sum(1 for i in cc.instructions if 'MOV' in i)\nprint(count)",
        "isHidden": true,
        "description": "Count MOV instructions for arguments"
      }
    ],
    "hints": [
      "Caller-save registers must be saved by the caller before the call",
      "Only save registers that are actually live across the call",
      "Use PUSH/POP to save/restore registers on the stack",
      "Restore registers in reverse order of saving"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex09",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Peephole Optimizer",
    "difficulty": 2,
    "description": "Implement a peephole optimizer that applies local optimizations to a sequence of instructions (e.g., removing redundant loads/stores).",
    "starterCode": "class PeepholeOptimizer:\n    def optimize(self, instructions):\n        \"\"\"\n        Apply peephole optimizations to instruction sequence.\n        Optimizations:\n        1. Remove redundant MOV: MOV r1, r1 -> (removed)\n        2. Combine ADD+ADD: ADD r1, r1, #1; ADD r1, r1, #2 -> ADD r1, r1, #3\n        3. Remove dead store: MOV r1, #5; MOV r1, #10 -> MOV r1, #10\n\n        Returns: optimized instruction list\n        \"\"\"\n        # TODO: Implement peephole optimizations\n        pass",
    "solution": "class PeepholeOptimizer:\n    def optimize(self, instructions):\n        \"\"\"\n        Apply peephole optimizations to instruction sequence.\n        Optimizations:\n        1. Remove redundant MOV: MOV r1, r1 -> (removed)\n        2. Combine ADD+ADD: ADD r1, r1, #1; ADD r1, r1, #2 -> ADD r1, r1, #3\n        3. Remove dead store: MOV r1, #5; MOV r1, #10 -> MOV r1, #10\n\n        Returns: optimized instruction list\n        \"\"\"\n        optimized = []\n        i = 0\n\n        while i < len(instructions):\n            instr = instructions[i]\n\n            # Check for redundant MOV r, r\n            if instr.startswith('MOV'):\n                parts = instr.split(',')\n                if len(parts) == 2:\n                    dest = parts[0].replace('MOV', '').strip()\n                    src = parts[1].strip()\n                    if dest == src:\n                        i += 1\n                        continue  # Skip this instruction\n\n            # Check for consecutive ADD to same register with immediates\n            if i + 1 < len(instructions) and instr.startswith('ADD'):\n                next_instr = instructions[i + 1]\n                if next_instr.startswith('ADD'):\n                    # Parse: ADD r1, r1, #N\n                    parts1 = instr.split(',')\n                    parts2 = next_instr.split(',')\n\n                    if len(parts1) == 3 and len(parts2) == 3:\n                        dest1 = parts1[0].replace('ADD', '').strip()\n                        src1 = parts1[1].strip()\n                        imm1 = parts1[2].strip()\n\n                        dest2 = parts2[0].replace('ADD', '').strip()\n                        src2 = parts2[1].strip()\n                        imm2 = parts2[2].strip()\n\n                        if (dest1 == dest2 == src1 == src2 and\n                            imm1.startswith('#') and imm2.startswith('#')):\n                            val1 = int(imm1[1:])\n                            val2 = int(imm2[1:])\n                            combined = f\"ADD {dest1}, {src1}, #{val1 + val2}\"\n                            optimized.append(combined)\n                            i += 2\n                            continue\n\n            # Check for dead store (consecutive MOV to same register)\n            if i + 1 < len(instructions) and instr.startswith('MOV'):\n                next_instr = instructions[i + 1]\n                if next_instr.startswith('MOV'):\n                    parts1 = instr.split(',')\n                    parts2 = next_instr.split(',')\n\n                    if len(parts1) == 2 and len(parts2) == 2:\n                        dest1 = parts1[0].replace('MOV', '').strip()\n                        dest2 = parts2[0].replace('MOV', '').strip()\n\n                        if dest1 == dest2:\n                            # Skip first MOV, keep second\n                            i += 1\n                            continue\n\n            optimized.append(instr)\n            i += 1\n\n        return optimized",
    "testCases": [
      {
        "input": "opt = PeepholeOptimizer()\nresult = opt.optimize(['MOV r1, r1', 'ADD r2, r3, #5'])\nprint(len(result))",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Remove redundant MOV"
      },
      {
        "input": "opt = PeepholeOptimizer()\nresult = opt.optimize(['ADD r1, r1, #5', 'ADD r1, r1, #3'])\nprint(result[0])",
        "expectedOutput": "ADD r1, r1, #8",
        "isHidden": false,
        "description": "Combine consecutive ADDs"
      },
      {
        "input": "opt = PeepholeOptimizer()\nresult = opt.optimize(['MOV r1, #5', 'MOV r1, #10', 'ADD r1, r1, #1'])\nprint(len(result))",
        "isHidden": true,
        "description": "Remove dead store"
      }
    ],
    "hints": [
      "Process instructions in sequence, looking for patterns",
      "For redundant MOV, check if source and destination are the same",
      "For ADD combining, check that both instructions use the same register",
      "For dead stores, check if consecutive instructions write to the same register"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex10",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Spill Code Generator",
    "difficulty": 3,
    "description": "Generate spill code to save and restore variables to/from memory when registers are exhausted.",
    "starterCode": "class SpillCodeGenerator:\n    def __init__(self):\n        self.spill_offset = 0  # Current offset in spill area\n        self.spill_map = {}  # variable -> memory offset\n\n    def allocate_spill_slot(self, variable):\n        \"\"\"Allocate a spill slot for a variable. Returns memory offset.\"\"\"\n        # TODO: Implement spill slot allocation\n        pass\n\n    def generate_spill(self, variable, register):\n        \"\"\"Generate code to spill variable from register to memory.\"\"\"\n        # TODO: Generate STORE instruction\n        pass\n\n    def generate_reload(self, variable, register):\n        \"\"\"Generate code to reload variable from memory to register.\"\"\"\n        # TODO: Generate LOAD instruction\n        pass",
    "solution": "class SpillCodeGenerator:\n    def __init__(self):\n        self.spill_offset = 0  # Current offset in spill area\n        self.spill_map = {}  # variable -> memory offset\n\n    def allocate_spill_slot(self, variable):\n        \"\"\"Allocate a spill slot for a variable. Returns memory offset.\"\"\"\n        if variable not in self.spill_map:\n            self.spill_map[variable] = self.spill_offset\n            self.spill_offset += 4  # Assume 4-byte slots\n        return self.spill_map[variable]\n\n    def generate_spill(self, variable, register):\n        \"\"\"Generate code to spill variable from register to memory.\"\"\"\n        offset = self.allocate_spill_slot(variable)\n        return f\"STORE {register}, [SP + {offset}]\"\n\n    def generate_reload(self, variable, register):\n        \"\"\"Generate code to reload variable from memory to register.\"\"\"\n        if variable not in self.spill_map:\n            raise ValueError(f\"Variable {variable} has not been spilled\")\n        offset = self.spill_map[variable]\n        return f\"LOAD {register}, [SP + {offset}]\"",
    "testCases": [
      {
        "input": "gen = SpillCodeGenerator()\ncode = gen.generate_spill('x', 'r1')\nprint(code)",
        "expectedOutput": "STORE r1, [SP + 0]",
        "isHidden": false,
        "description": "First spill at offset 0"
      },
      {
        "input": "gen = SpillCodeGenerator()\ngen.generate_spill('x', 'r1')\ngen.generate_spill('y', 'r2')\ncode = gen.generate_reload('x', 'r3')\nprint(code)",
        "expectedOutput": "LOAD r3, [SP + 0]",
        "isHidden": false,
        "description": "Reload previously spilled variable"
      },
      {
        "input": "gen = SpillCodeGenerator()\ngen.generate_spill('a', 'r1')\ngen.generate_spill('b', 'r2')\noffset_b = gen.spill_map['b']\nprint(offset_b)",
        "isHidden": true,
        "description": "Second variable at offset 4"
      }
    ],
    "hints": [
      "Maintain a mapping from variables to their spill locations",
      "Allocate spill slots sequentially with a fixed size (e.g., 4 bytes)",
      "Use stack pointer (SP) relative addressing for spill locations",
      "Generate STORE instructions to save and LOAD instructions to reload"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex11",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Target-Specific Instruction Mapper",
    "difficulty": 3,
    "description": "Map generic IR operations to target-specific machine instructions, handling different addressing modes and instruction variants.",
    "starterCode": "class InstructionMapper:\n    def __init__(self):\n        # Target machine has these instruction formats:\n        # ADD reg, reg, reg\n        # ADD reg, reg, #imm\n        # LOAD reg, [reg + #offset]\n        # STORE reg, [reg + #offset]\n        pass\n\n    def map_binary_op(self, op, dest, left, right):\n        \"\"\"\n        Map a binary operation to target instructions.\n        Operands can be: {'reg': 'r0'}, {'imm': 5}, or {'mem': addr}\n        Returns list of instructions.\n        \"\"\"\n        # TODO: Implement mapping logic\n        pass",
    "solution": "class InstructionMapper:\n    def __init__(self):\n        # Target machine has these instruction formats:\n        # ADD reg, reg, reg\n        # ADD reg, reg, #imm\n        # LOAD reg, [reg + #offset]\n        # STORE reg, [reg + #offset]\n        pass\n\n    def map_binary_op(self, op, dest, left, right):\n        \"\"\"\n        Map a binary operation to target instructions.\n        Operands can be: {'reg': 'r0'}, {'imm': 5}, or {'mem': addr}\n        Returns list of instructions.\n        \"\"\"\n        instructions = []\n\n        # Handle different operand types\n        left_reg = None\n        right_reg = None\n\n        # Load left operand\n        if 'reg' in left:\n            left_reg = left['reg']\n        elif 'imm' in left:\n            left_reg = 'temp0'\n            instructions.append(f\"MOV {left_reg}, #{left['imm']}\")\n        elif 'mem' in left:\n            left_reg = 'temp0'\n            instructions.append(f\"LOAD {left_reg}, [{left['mem']}]\")\n\n        # Load right operand\n        if 'reg' in right:\n            right_reg = right['reg']\n        elif 'imm' in right:\n            # Can use immediate addressing mode\n            instructions.append(f\"{op.upper()} {dest}, {left_reg}, #{right['imm']}\")\n            return instructions\n        elif 'mem' in right:\n            right_reg = 'temp1'\n            instructions.append(f\"LOAD {right_reg}, [{right['mem']}]\")\n\n        # Generate the operation\n        instructions.append(f\"{op.upper()} {dest}, {left_reg}, {right_reg}\")\n\n        return instructions",
    "testCases": [
      {
        "input": "mapper = InstructionMapper()\ninstrs = mapper.map_binary_op('add', 'r0', {'reg': 'r1'}, {'imm': 5})\nprint(instrs[-1])",
        "expectedOutput": "ADD r0, r1, #5",
        "isHidden": false,
        "description": "Register + immediate"
      },
      {
        "input": "mapper = InstructionMapper()\ninstrs = mapper.map_binary_op('add', 'r0', {'imm': 10}, {'reg': 'r2'})\nprint(len(instrs))",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Immediate needs to be loaded first"
      },
      {
        "input": "mapper = InstructionMapper()\ninstrs = mapper.map_binary_op('add', 'r0', {'reg': 'r1'}, {'reg': 'r2'})\nprint(instrs[0])",
        "isHidden": true,
        "description": "Register + register"
      }
    ],
    "hints": [
      "Check the type of each operand (register, immediate, or memory)",
      "Immediates can often be used directly in arithmetic instructions",
      "Memory operands need to be loaded into temporary registers first",
      "Build the instruction sequence step by step"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex12",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Basic Block Code Generator",
    "difficulty": 4,
    "description": "Generate optimized code for a basic block by performing instruction selection and basic register allocation within the block.",
    "starterCode": "class BasicBlockCodeGen:\n    def __init__(self, num_registers=4):\n        self.num_registers = num_registers\n        self.instructions = []\n        self.register_map = {}  # temp var -> register\n        self.next_reg = 0\n\n    def get_register(self, temp):\n        \"\"\"Allocate or retrieve register for a temporary variable.\"\"\"\n        # TODO: Implement register allocation within block\n        pass\n\n    def generate_code(self, three_address_code):\n        \"\"\"\n        Generate machine code for a basic block.\n        three_address_code: list of (dest, op, left, right) tuples\n        \"\"\"\n        # TODO: Generate code with register allocation\n        pass",
    "solution": "class BasicBlockCodeGen:\n    def __init__(self, num_registers=4):\n        self.num_registers = num_registers\n        self.instructions = []\n        self.register_map = {}  # temp var -> register\n        self.next_reg = 0\n\n    def get_register(self, temp):\n        \"\"\"Allocate or retrieve register for a temporary variable.\"\"\"\n        if temp not in self.register_map:\n            if self.next_reg < self.num_registers:\n                self.register_map[temp] = f\"r{self.next_reg}\"\n                self.next_reg += 1\n            else:\n                # Simple strategy: reuse r0 when out of registers\n                self.register_map[temp] = \"r0\"\n        return self.register_map[temp]\n\n    def generate_code(self, three_address_code):\n        \"\"\"\n        Generate machine code for a basic block.\n        three_address_code: list of (dest, op, left, right) tuples\n        \"\"\"\n        for dest, op, left, right in three_address_code:\n            # Get or allocate registers for operands\n            if isinstance(left, str) and left.startswith('t'):\n                left_reg = self.get_register(left)\n            else:\n                left_reg = str(left)\n\n            if isinstance(right, str) and right.startswith('t'):\n                right_reg = self.get_register(right)\n            else:\n                right_reg = str(right)\n\n            # Allocate register for destination\n            dest_reg = self.get_register(dest)\n\n            # Generate instruction\n            if str(right_reg).isdigit():\n                # Immediate operand\n                self.instructions.append(f\"{op.upper()} {dest_reg}, {left_reg}, #{right_reg}\")\n            else:\n                # Register operand\n                self.instructions.append(f\"{op.upper()} {dest_reg}, {left_reg}, {right_reg}\")\n\n        return self.instructions",
    "testCases": [
      {
        "input": "gen = BasicBlockCodeGen(num_registers=4)\ncode = [('t0', 'add', 5, 3), ('t1', 'mul', 't0', 2)]\ninstrs = gen.generate_code(code)\nprint(len(instrs))",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Two instructions generated"
      },
      {
        "input": "gen = BasicBlockCodeGen(num_registers=4)\ncode = [('t0', 'add', 10, 20)]\ninstrs = gen.generate_code(code)\nprint(gen.register_map['t0'])",
        "expectedOutput": "r0",
        "isHidden": false,
        "description": "t0 allocated to r0"
      },
      {
        "input": "gen = BasicBlockCodeGen(num_registers=2)\ncode = [('t0', 'add', 1, 2), ('t1', 'add', 3, 4), ('t2', 'add', 't0', 't1')]\ninstrs = gen.generate_code(code)\nprint(len(instrs))",
        "isHidden": true,
        "description": "Multiple temporaries with limited registers"
      }
    ],
    "hints": [
      "Maintain a mapping from temporary variables to registers",
      "Allocate registers sequentially until you run out",
      "Check if operands are temporaries or immediate values",
      "Use different instruction formats for immediate vs register operands"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex13",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Branch Optimization",
    "difficulty": 2,
    "description": "Optimize conditional branches by inverting conditions and eliminating unnecessary jumps.",
    "starterCode": "class BranchOptimizer:\n    def optimize_branch_chain(self, instructions):\n        \"\"\"\n        Optimize branch instructions.\n        - Remove branches to next instruction\n        - Invert conditions to eliminate jumps\n\n        Instructions format: list of (label, instruction) tuples\n        \"\"\"\n        # TODO: Implement branch optimizations\n        pass",
    "solution": "class BranchOptimizer:\n    def optimize_branch_chain(self, instructions):\n        \"\"\"\n        Optimize branch instructions.\n        - Remove branches to next instruction\n        - Invert conditions to eliminate jumps\n\n        Instructions format: list of (label, instruction) tuples\n        \"\"\"\n        optimized = []\n\n        for i, (label, instr) in enumerate(instructions):\n            skip = False\n\n            # Check for branch to next instruction\n            if instr.startswith('JMP') or instr.startswith('BEQ') or instr.startswith('BNE'):\n                parts = instr.split()\n                if len(parts) == 2:\n                    target = parts[1]\n\n                    # Check if target is the next instruction\n                    if i + 1 < len(instructions):\n                        next_label = instructions[i + 1][0]\n                        if target == next_label:\n                            # Branch to next instruction - remove it\n                            skip = True\n\n            if not skip:\n                optimized.append((label, instr))\n\n        return optimized",
    "testCases": [
      {
        "input": "opt = BranchOptimizer()\ninstrs = [('L1', 'ADD r0, r1, #1'), ('L2', 'JMP L3'), ('L3', 'MOV r2, r0')]\nresult = opt.optimize_branch_chain(instrs)\nprint(len(result))",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Remove jump to next instruction"
      },
      {
        "input": "opt = BranchOptimizer()\ninstrs = [('L1', 'BEQ L2'), ('L2', 'ADD r0, r1, #1')]\nresult = opt.optimize_branch_chain(instrs)\nprint(len(result))",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Remove conditional branch to next"
      },
      {
        "input": "opt = BranchOptimizer()\ninstrs = [('L1', 'JMP L5'), ('L2', 'ADD r0, #1'), ('L5', 'MOV r1, r0')]\nresult = opt.optimize_branch_chain(instrs)\nprint(len(result))",
        "isHidden": true,
        "description": "Keep jump to non-adjacent label"
      }
    ],
    "hints": [
      "Check if a branch target is the immediately following instruction",
      "Compare the target label with the label of the next instruction",
      "Remove branches to the next instruction as they are redundant",
      "Preserve other branches that jump to non-adjacent locations"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex14",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Constant Pool Generator",
    "difficulty": 2,
    "description": "Generate a constant pool for large immediate values that cannot be encoded directly in instructions.",
    "starterCode": "class ConstantPoolGenerator:\n    def __init__(self, max_immediate=255):\n        self.max_immediate = max_immediate\n        self.pool = {}  # value -> label\n        self.pool_counter = 0\n\n    def add_constant(self, value):\n        \"\"\"Add a constant to the pool if it's too large. Returns label or None.\"\"\"\n        # TODO: Check if value needs to go in pool\n        # Return pool label if needed, None otherwise\n        pass\n\n    def generate_load(self, reg, value):\n        \"\"\"Generate instruction to load a value into a register.\"\"\"\n        # TODO: Use immediate or pool load based on value size\n        pass",
    "solution": "class ConstantPoolGenerator:\n    def __init__(self, max_immediate=255):\n        self.max_immediate = max_immediate\n        self.pool = {}  # value -> label\n        self.pool_counter = 0\n\n    def add_constant(self, value):\n        \"\"\"Add a constant to the pool if it's too large. Returns label or None.\"\"\"\n        if abs(value) <= self.max_immediate:\n            return None  # Can use immediate encoding\n\n        if value not in self.pool:\n            label = f\"CONST_{self.pool_counter}\"\n            self.pool[value] = label\n            self.pool_counter += 1\n\n        return self.pool[value]\n\n    def generate_load(self, reg, value):\n        \"\"\"Generate instruction to load a value into a register.\"\"\"\n        label = self.add_constant(value)\n\n        if label is None:\n            # Small value - use immediate\n            return f\"MOV {reg}, #{value}\"\n        else:\n            # Large value - load from pool\n            return f\"LDR {reg}, ={label}\"",
    "testCases": [
      {
        "input": "gen = ConstantPoolGenerator(max_immediate=255)\ninstr = gen.generate_load('r0', 100)\nprint(instr)",
        "expectedOutput": "MOV r0, #100",
        "isHidden": false,
        "description": "Small constant uses immediate"
      },
      {
        "input": "gen = ConstantPoolGenerator(max_immediate=255)\ninstr = gen.generate_load('r0', 1000)\nprint(instr)",
        "expectedOutput": "LDR r0, =CONST_0",
        "isHidden": false,
        "description": "Large constant uses pool"
      },
      {
        "input": "gen = ConstantPoolGenerator(max_immediate=255)\ngen.generate_load('r0', 1000)\ngen.generate_load('r1', 1000)\nprint(len(gen.pool))",
        "isHidden": true,
        "description": "Same constant reuses pool entry"
      }
    ],
    "hints": [
      "Compare constant values against the maximum immediate value",
      "Create a unique label for each distinct large constant",
      "Reuse pool entries for the same constant value",
      "Use MOV for small values and LDR for pool references"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex15",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Condition Code Optimizer",
    "difficulty": 3,
    "description": "Optimize the use of condition codes by eliminating redundant comparisons and reusing previously set flags.",
    "starterCode": "class ConditionCodeOptimizer:\n    def __init__(self):\n        self.last_flags_set = None  # Track what last set the flags\n\n    def optimize(self, instructions):\n        \"\"\"\n        Optimize condition code usage.\n        - Remove redundant CMP instructions\n        - Track operations that set flags\n\n        Instruction format: strings like \"ADD r0, r1, r2\", \"CMP r0, #0\", \"BEQ L1\"\n        \"\"\"\n        # TODO: Implement optimization\n        pass",
    "solution": "class ConditionCodeOptimizer:\n    def __init__(self):\n        self.last_flags_set = None  # Track what last set the flags\n\n    def optimize(self, instructions):\n        \"\"\"\n        Optimize condition code usage.\n        - Remove redundant CMP instructions\n        - Track operations that set flags\n\n        Instruction format: strings like \"ADD r0, r1, r2\", \"CMP r0, #0\", \"BEQ L1\"\n        \"\"\"\n        optimized = []\n\n        for instr in instructions:\n            parts = instr.split()\n            op = parts[0]\n\n            # Check for redundant CMP\n            if op == 'CMP':\n                # CMP sets flags based on comparison\n                operands = ' '.join(parts[1:])\n\n                # If the same comparison was just done, skip it\n                if self.last_flags_set == ('CMP', operands):\n                    continue  # Redundant comparison\n\n                self.last_flags_set = ('CMP', operands)\n                optimized.append(instr)\n\n            # Arithmetic operations that set flags\n            elif op in ['ADD', 'SUB', 'AND', 'OR']:\n                # These operations set flags as a side effect\n                # Extract destination register\n                dest = parts[1].rstrip(',')\n                self.last_flags_set = (op, dest)\n                optimized.append(instr)\n\n            # Branch instructions use flags but don't modify them\n            elif op in ['BEQ', 'BNE', 'BLT', 'BGT']:\n                optimized.append(instr)\n                # Don't clear last_flags_set - flags are still valid\n\n            # Other instructions may clobber flags\n            else:\n                self.last_flags_set = None\n                optimized.append(instr)\n\n        return optimized",
    "testCases": [
      {
        "input": "opt = ConditionCodeOptimizer()\ninstrs = ['CMP r0, #0', 'BEQ L1', 'CMP r0, #0', 'BNE L2']\nresult = opt.optimize(instrs)\nprint(len(result))",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Remove redundant second CMP"
      },
      {
        "input": "opt = ConditionCodeOptimizer()\ninstrs = ['SUB r0, r1, r2', 'CMP r0, #0', 'BEQ L1']\nresult = opt.optimize(instrs)\nprint(len(result))",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "SUB sets flags but CMP is different comparison"
      },
      {
        "input": "opt = ConditionCodeOptimizer()\ninstrs = ['CMP r0, #5', 'BEQ L1', 'ADD r1, r2, #1', 'CMP r0, #5']\nresult = opt.optimize(instrs)\nprint(len(result))",
        "isHidden": true,
        "description": "ADD clobbers flags, CMP needed again"
      }
    ],
    "hints": [
      "Track what operation last set the condition flags",
      "Arithmetic operations like ADD and SUB set flags as a side effect",
      "Branch instructions use flags but don't modify them",
      "Remove consecutive identical CMP instructions"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t5-ex16",
    "subjectId": "cs304",
    "topicId": "cs304-topic-5",
    "title": "Advanced Register Coalescing",
    "difficulty": 5,
    "description": "Implement register coalescing to reduce copy instructions by assigning the same register to variables connected by move operations.",
    "starterCode": "class RegisterCoalescer:\n    def __init__(self):\n        self.copies = []  # List of (dest, src) copy operations\n        self.interference = {}  # Interference graph\n        self.coalesced = {}  # Variable -> coalesced representative\n\n    def add_copy(self, dest, src):\n        \"\"\"Record a copy operation.\"\"\"\n        self.copies.append((dest, src))\n\n    def add_interference(self, var1, var2):\n        \"\"\"Record that two variables interfere.\"\"\"\n        if var1 not in self.interference:\n            self.interference[var1] = set()\n        if var2 not in self.interference:\n            self.interference[var2] = set()\n        self.interference[var1].add(var2)\n        self.interference[var2].add(var1)\n\n    def can_coalesce(self, dest, src):\n        \"\"\"Check if dest and src can be coalesced (don't interfere).\"\"\"\n        # TODO: Implement coalescing check\n        pass\n\n    def coalesce(self):\n        \"\"\"Perform register coalescing. Returns mapping of variables to coalesced names.\"\"\"\n        # TODO: Implement coalescing algorithm\n        pass",
    "solution": "class RegisterCoalescer:\n    def __init__(self):\n        self.copies = []  # List of (dest, src) copy operations\n        self.interference = {}  # Interference graph\n        self.coalesced = {}  # Variable -> coalesced representative\n\n    def add_copy(self, dest, src):\n        \"\"\"Record a copy operation.\"\"\"\n        self.copies.append((dest, src))\n\n    def add_interference(self, var1, var2):\n        \"\"\"Record that two variables interfere.\"\"\"\n        if var1 not in self.interference:\n            self.interference[var1] = set()\n        if var2 not in self.interference:\n            self.interference[var2] = set()\n        self.interference[var1].add(var2)\n        self.interference[var2].add(var1)\n\n    def find_representative(self, var):\n        \"\"\"Find the coalesced representative for a variable.\"\"\"\n        if var not in self.coalesced:\n            return var\n        # Path compression\n        if self.coalesced[var] != var:\n            self.coalesced[var] = self.find_representative(self.coalesced[var])\n        return self.coalesced[var]\n\n    def can_coalesce(self, dest, src):\n        \"\"\"Check if dest and src can be coalesced (don't interfere).\"\"\"\n        dest_rep = self.find_representative(dest)\n        src_rep = self.find_representative(src)\n\n        if dest_rep == src_rep:\n            return False  # Already coalesced\n\n        # Check if representatives interfere\n        dest_neighbors = self.interference.get(dest_rep, set())\n        src_neighbors = self.interference.get(src_rep, set())\n\n        # Can coalesce if they don't interfere with each other\n        if src_rep in dest_neighbors or dest_rep in src_neighbors:\n            return False\n\n        # Briggs' criterion: conservative coalescing\n        # Can coalesce if the combined node has fewer than K high-degree neighbors\n        # For simplicity, we'll just check direct interference\n        return True\n\n    def coalesce(self):\n        \"\"\"Perform register coalescing. Returns mapping of variables to coalesced names.\"\"\"\n        # Initialize coalesced mapping\n        all_vars = set()\n        for dest, src in self.copies:\n            all_vars.add(dest)\n            all_vars.add(src)\n        for var in all_vars:\n            self.coalesced[var] = var\n\n        # Try to coalesce each copy\n        for dest, src in self.copies:\n            if self.can_coalesce(dest, src):\n                dest_rep = self.find_representative(dest)\n                src_rep = self.find_representative(src)\n\n                # Union: make src point to dest\n                self.coalesced[src_rep] = dest_rep\n\n                # Merge interference edges\n                if src_rep in self.interference:\n                    if dest_rep not in self.interference:\n                        self.interference[dest_rep] = set()\n                    self.interference[dest_rep].update(self.interference[src_rep])\n\n        # Build final mapping\n        result = {}\n        for var in all_vars:\n            result[var] = self.find_representative(var)\n\n        return result",
    "testCases": [
      {
        "input": "coalescer = RegisterCoalescer()\ncoalescer.add_copy('a', 'b')\nresult = coalescer.coalesce()\nprint(result['a'] == result['b'])",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Non-interfering copy can be coalesced"
      },
      {
        "input": "coalescer = RegisterCoalescer()\ncoalescer.add_copy('a', 'b')\ncoalescer.add_interference('a', 'b')\nresult = coalescer.coalesce()\nprint(result['a'] == result['b'])",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Interfering variables cannot be coalesced"
      },
      {
        "input": "coalescer = RegisterCoalescer()\ncoalescer.add_copy('a', 'b')\ncoalescer.add_copy('b', 'c')\nresult = coalescer.coalesce()\nprint(result['a'] == result['c'])",
        "isHidden": true,
        "description": "Transitive coalescing"
      }
    ],
    "hints": [
      "Use union-find to track coalesced variables",
      "Check if variables interfere before coalescing",
      "When coalescing, merge the interference edges of both variables",
      "Use path compression in find_representative for efficiency"
    ],
    "language": "python"
  }
]

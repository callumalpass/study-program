[
  {
    "id": "cs304-t3-ex01",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Simple Symbol Table",
    "difficulty": 1,
    "description": "Implement a basic symbol table that can insert, lookup, and delete variable symbols with their types.",
    "starterCode": "class SymbolTable:\n    def __init__(self):\n        \"\"\"Initialize an empty symbol table.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, name, symbol_type):\n        \"\"\"Insert a symbol with its type. Return True if successful.\"\"\"\n        # Your code here\n        pass\n\n    def lookup(self, name):\n        \"\"\"Look up a symbol. Return its type or None if not found.\"\"\"\n        # Your code here\n        pass\n\n    def delete(self, name):\n        \"\"\"Delete a symbol. Return True if successful.\"\"\"\n        # Your code here\n        pass\n\n# Test\nst = SymbolTable()\nst.insert('x', 'int')\nprint(st.lookup('x'))  # Should print 'int'",
    "solution": "class SymbolTable:\n    def __init__(self):\n        \"\"\"Initialize an empty symbol table.\"\"\"\n        self.table = {}\n\n    def insert(self, name, symbol_type):\n        \"\"\"Insert a symbol with its type. Return True if successful.\"\"\"\n        if name in self.table:\n            return False  # Symbol already exists\n        self.table[name] = symbol_type\n        return True\n\n    def lookup(self, name):\n        \"\"\"Look up a symbol. Return its type or None if not found.\"\"\"\n        return self.table.get(name, None)\n\n    def delete(self, name):\n        \"\"\"Delete a symbol. Return True if successful.\"\"\"\n        if name in self.table:\n            del self.table[name]\n            return True\n        return False\n\n# Test\nst = SymbolTable()\nst.insert('x', 'int')\nprint(st.lookup('x'))",
    "testCases": [
      {
        "input": "insert and lookup",
        "expectedOutput": "int",
        "isHidden": false,
        "description": "Insert and retrieve symbol"
      },
      {
        "input": "lookup nonexistent",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Lookup returns None for missing symbol"
      },
      {
        "input": "delete",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Delete existing symbol"
      }
    ],
    "hints": [
      "Use a dictionary to store name -> type mappings",
      "Check if a symbol exists before operations",
      "Return None for lookups of non-existent symbols",
      "Return boolean values to indicate success/failure"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex02",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Scoped Symbol Table",
    "difficulty": 2,
    "description": "Implement a symbol table with nested scopes using a stack of dictionaries. Support entering/exiting scopes.",
    "starterCode": "class ScopedSymbolTable:\n    def __init__(self):\n        \"\"\"Initialize with global scope.\"\"\"\n        self.scopes = [{}]  # Stack of scopes\n\n    def enter_scope(self):\n        \"\"\"Enter a new nested scope.\"\"\"\n        # Your code here\n        pass\n\n    def exit_scope(self):\n        \"\"\"Exit current scope.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, name, symbol_type):\n        \"\"\"Insert symbol in current scope.\"\"\"\n        # Your code here\n        pass\n\n    def lookup(self, name):\n        \"\"\"Look up symbol from current scope outward.\"\"\"\n        # Your code here\n        pass\n\n# Test\nst = ScopedSymbolTable()\nst.insert('x', 'int')\nst.enter_scope()\nst.insert('y', 'float')\nprint(st.lookup('x'))  # Should find 'int' from outer scope",
    "solution": "class ScopedSymbolTable:\n    def __init__(self):\n        \"\"\"Initialize with global scope.\"\"\"\n        self.scopes = [{}]  # Stack of scopes\n\n    def enter_scope(self):\n        \"\"\"Enter a new nested scope.\"\"\"\n        self.scopes.append({})\n\n    def exit_scope(self):\n        \"\"\"Exit current scope.\"\"\"\n        if len(self.scopes) > 1:\n            self.scopes.pop()\n\n    def insert(self, name, symbol_type):\n        \"\"\"Insert symbol in current scope.\"\"\"\n        self.scopes[-1][name] = symbol_type\n\n    def lookup(self, name):\n        \"\"\"Look up symbol from current scope outward.\"\"\"\n        # Search from innermost to outermost scope\n        for scope in reversed(self.scopes):\n            if name in scope:\n                return scope[name]\n        return None\n\n# Test\nst = ScopedSymbolTable()\nst.insert('x', 'int')\nst.enter_scope()\nst.insert('y', 'float')\nprint(st.lookup('x'))",
    "testCases": [
      {
        "input": "outer scope lookup",
        "expectedOutput": "int",
        "isHidden": false,
        "description": "Find variable from outer scope"
      },
      {
        "input": "inner scope lookup",
        "expectedOutput": "float",
        "isHidden": false,
        "description": "Find variable in current scope"
      },
      {
        "input": "after exit scope",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Variable not visible after exiting scope"
      }
    ],
    "hints": [
      "Use a list of dictionaries as a stack",
      "Push a new dictionary when entering a scope",
      "Pop when exiting a scope",
      "Search from innermost to outermost scope for lookups"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex03",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Type Compatibility Checker",
    "difficulty": 2,
    "description": "Implement type checking for binary operations, ensuring operands have compatible types.",
    "starterCode": "class TypeChecker:\n    def __init__(self):\n        # Define compatible types for operations\n        self.compatible_ops = {\n            '+': [('int', 'int', 'int'), ('float', 'float', 'float'),\n                  ('string', 'string', 'string')],\n            '*': [('int', 'int', 'int'), ('float', 'float', 'float')],\n            '==': [('int', 'int', 'bool'), ('float', 'float', 'bool'),\n                   ('string', 'string', 'bool')]\n        }\n\n    def check_binary_op(self, op, left_type, right_type):\n        \"\"\"\n        Check if binary operation is type-compatible.\n        Returns result type or None if incompatible.\n        \"\"\"\n        # Your code here\n        pass\n\n# Test\ntc = TypeChecker()\nprint(tc.check_binary_op('+', 'int', 'int'))  # Should return 'int'\nprint(tc.check_binary_op('+', 'int', 'string'))  # Should return None",
    "solution": "class TypeChecker:\n    def __init__(self):\n        # Define compatible types for operations\n        self.compatible_ops = {\n            '+': [('int', 'int', 'int'), ('float', 'float', 'float'),\n                  ('string', 'string', 'string')],\n            '*': [('int', 'int', 'int'), ('float', 'float', 'float')],\n            '==': [('int', 'int', 'bool'), ('float', 'float', 'bool'),\n                   ('string', 'string', 'bool')]\n        }\n\n    def check_binary_op(self, op, left_type, right_type):\n        \"\"\"\n        Check if binary operation is type-compatible.\n        Returns result type or None if incompatible.\n        \"\"\"\n        if op not in self.compatible_ops:\n            return None\n\n        for left, right, result in self.compatible_ops[op]:\n            if left_type == left and right_type == right:\n                return result\n\n        return None\n\n# Test\ntc = TypeChecker()\nprint(tc.check_binary_op('+', 'int', 'int'))\nprint(tc.check_binary_op('+', 'int', 'string'))",
    "testCases": [
      {
        "input": "'+', 'int', 'int'",
        "expectedOutput": "int",
        "isHidden": false,
        "description": "Integer addition"
      },
      {
        "input": "'+', 'int', 'string'",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Incompatible types"
      },
      {
        "input": "'==', 'float', 'float'",
        "expectedOutput": "bool",
        "isHidden": true,
        "description": "Comparison returns bool"
      }
    ],
    "hints": [
      "Look up the operator in the compatibility table",
      "Check if left and right types match any rule",
      "Return the result type from the matching rule",
      "Return None if no matching rule found"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex04",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "AST Type Annotation",
    "difficulty": 3,
    "description": "Annotate an abstract syntax tree with type information by traversing and checking types.",
    "starterCode": "class TypeAnnotator:\n    def __init__(self, symbol_table):\n        self.symbol_table = symbol_table\n\n    def annotate(self, node):\n        \"\"\"\n        Annotate AST node with type information.\n        node: dict with 'kind', 'value', 'left', 'right', etc.\n        Returns: type of the node or None if type error.\n        \"\"\"\n        # Your code here\n        pass\n\n# Example node structure:\n# {'kind': 'BinaryOp', 'op': '+', 'left': {...}, 'right': {...}}\n# {'kind': 'Variable', 'name': 'x'}\n# {'kind': 'Literal', 'type': 'int', 'value': 5}\n\n# Test\nst = {'x': 'int', 'y': 'int'}\nannotator = TypeAnnotator(st)\nnode = {'kind': 'BinaryOp', 'op': '+',\n        'left': {'kind': 'Variable', 'name': 'x'},\n        'right': {'kind': 'Literal', 'type': 'int', 'value': 5}}\nprint(annotator.annotate(node))  # Should return 'int'",
    "solution": "class TypeAnnotator:\n    def __init__(self, symbol_table):\n        self.symbol_table = symbol_table\n        self.type_rules = {\n            '+': [('int', 'int', 'int'), ('float', 'float', 'float')],\n            '*': [('int', 'int', 'int'), ('float', 'float', 'float')],\n            '-': [('int', 'int', 'int'), ('float', 'float', 'float')]\n        }\n\n    def annotate(self, node):\n        \"\"\"\n        Annotate AST node with type information.\n        Returns: type of the node or None if type error.\n        \"\"\"\n        kind = node['kind']\n\n        if kind == 'Literal':\n            node['computed_type'] = node['type']\n            return node['type']\n\n        elif kind == 'Variable':\n            var_type = self.symbol_table.get(node['name'])\n            if var_type is None:\n                return None  # Undefined variable\n            node['computed_type'] = var_type\n            return var_type\n\n        elif kind == 'BinaryOp':\n            left_type = self.annotate(node['left'])\n            right_type = self.annotate(node['right'])\n\n            if left_type is None or right_type is None:\n                return None\n\n            # Check type compatibility\n            op = node['op']\n            if op in self.type_rules:\n                for left, right, result in self.type_rules[op]:\n                    if left_type == left and right_type == right:\n                        node['computed_type'] = result\n                        return result\n\n            return None\n\n        return None\n\n# Test\nst = {'x': 'int', 'y': 'int'}\nannotator = TypeAnnotator(st)\nnode = {'kind': 'BinaryOp', 'op': '+',\n        'left': {'kind': 'Variable', 'name': 'x'},\n        'right': {'kind': 'Literal', 'type': 'int', 'value': 5}}\nprint(annotator.annotate(node))",
    "testCases": [
      {
        "input": "int + int",
        "expectedOutput": "int",
        "isHidden": false,
        "description": "Binary operation with compatible types"
      },
      {
        "input": "undefined variable",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Type error for undefined variable"
      },
      {
        "input": "nested expression",
        "expectedOutput": "int",
        "isHidden": true,
        "description": "Nested binary operations"
      }
    ],
    "hints": [
      "Recursively annotate child nodes first",
      "For literals, return their declared type",
      "For variables, look up type in symbol table",
      "For binary ops, check type compatibility of operands"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex05",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Function Symbol Table",
    "difficulty": 3,
    "description": "Extend symbol table to handle function declarations with parameter types and return types.",
    "starterCode": "class FunctionSymbolTable:\n    def __init__(self):\n        self.functions = {}\n\n    def declare_function(self, name, param_types, return_type):\n        \"\"\"\n        Declare a function with parameter types and return type.\n        param_types: list of types\n        return_type: type\n        \"\"\"\n        # Your code here\n        pass\n\n    def lookup_function(self, name):\n        \"\"\"Return function signature (param_types, return_type) or None.\"\"\"\n        # Your code here\n        pass\n\n    def check_call(self, name, arg_types):\n        \"\"\"\n        Check if function call is valid.\n        Returns return type or None if invalid.\n        \"\"\"\n        # Your code here\n        pass\n\n# Test\nfst = FunctionSymbolTable()\nfst.declare_function('add', ['int', 'int'], 'int')\nprint(fst.check_call('add', ['int', 'int']))  # Should return 'int'",
    "solution": "class FunctionSymbolTable:\n    def __init__(self):\n        self.functions = {}\n\n    def declare_function(self, name, param_types, return_type):\n        \"\"\"\n        Declare a function with parameter types and return type.\n        \"\"\"\n        self.functions[name] = {\n            'param_types': param_types,\n            'return_type': return_type\n        }\n\n    def lookup_function(self, name):\n        \"\"\"Return function signature (param_types, return_type) or None.\"\"\"\n        if name in self.functions:\n            sig = self.functions[name]\n            return (sig['param_types'], sig['return_type'])\n        return None\n\n    def check_call(self, name, arg_types):\n        \"\"\"\n        Check if function call is valid.\n        Returns return type or None if invalid.\n        \"\"\"\n        if name not in self.functions:\n            return None\n\n        func = self.functions[name]\n        param_types = func['param_types']\n\n        # Check argument count\n        if len(arg_types) != len(param_types):\n            return None\n\n        # Check each argument type\n        for arg_type, param_type in zip(arg_types, param_types):\n            if arg_type != param_type:\n                return None\n\n        return func['return_type']\n\n# Test\nfst = FunctionSymbolTable()\nfst.declare_function('add', ['int', 'int'], 'int')\nprint(fst.check_call('add', ['int', 'int']))",
    "testCases": [
      {
        "input": "valid call",
        "expectedOutput": "int",
        "isHidden": false,
        "description": "Function call with correct types"
      },
      {
        "input": "wrong arg count",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Too many or too few arguments"
      },
      {
        "input": "wrong arg types",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Argument type mismatch"
      }
    ],
    "hints": [
      "Store function signatures as (param_types, return_type)",
      "Check both argument count and types",
      "Return the function's return type if call is valid",
      "Return None for type errors or undefined functions"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex06",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Type Inference for Variables",
    "difficulty": 3,
    "description": "Implement simple type inference that deduces variable types from their usage.",
    "starterCode": "class TypeInference:\n    def __init__(self):\n        self.var_types = {}  # Inferred types\n\n    def infer_assignment(self, var_name, expr_type):\n        \"\"\"\n        Infer type for variable from assignment.\n        Returns True if consistent, False if conflict.\n        \"\"\"\n        # Your code here\n        pass\n\n    def get_type(self, var_name):\n        \"\"\"Get inferred type or None if not yet inferred.\"\"\"\n        # Your code here\n        pass\n\n# Test\nti = TypeInference()\nti.infer_assignment('x', 'int')\nti.infer_assignment('x', 'int')  # Consistent\nprint(ti.get_type('x'))  # Should be 'int'",
    "solution": "class TypeInference:\n    def __init__(self):\n        self.var_types = {}  # Inferred types\n\n    def infer_assignment(self, var_name, expr_type):\n        \"\"\"\n        Infer type for variable from assignment.\n        Returns True if consistent, False if conflict.\n        \"\"\"\n        if var_name in self.var_types:\n            # Check for consistency\n            if self.var_types[var_name] != expr_type:\n                return False  # Type conflict\n        else:\n            # Infer new type\n            self.var_types[var_name] = expr_type\n\n        return True\n\n    def get_type(self, var_name):\n        \"\"\"Get inferred type or None if not yet inferred.\"\"\"\n        return self.var_types.get(var_name, None)\n\n# Test\nti = TypeInference()\nti.infer_assignment('x', 'int')\nti.infer_assignment('x', 'int')\nprint(ti.get_type('x'))",
    "testCases": [
      {
        "input": "consistent types",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Same type assignments are consistent"
      },
      {
        "input": "type conflict",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Different types cause conflict"
      },
      {
        "input": "get inferred type",
        "expectedOutput": "int",
        "isHidden": true,
        "description": "Retrieve inferred type"
      }
    ],
    "hints": [
      "Track inferred types in a dictionary",
      "On first assignment, record the type",
      "On subsequent assignments, check consistency",
      "Return False if types conflict"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex07",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Semantic Error Detection",
    "difficulty": 2,
    "description": "Detect common semantic errors like undefined variables, type mismatches, and duplicate declarations.",
    "starterCode": "class SemanticAnalyzer:\n    def __init__(self):\n        self.symbols = {}\n        self.errors = []\n\n    def declare_variable(self, name, var_type):\n        \"\"\"Declare variable, detect duplicate declarations.\"\"\"\n        # Your code here\n        pass\n\n    def check_variable_use(self, name):\n        \"\"\"Check if variable is defined before use.\"\"\"\n        # Your code here\n        pass\n\n    def check_assignment(self, name, value_type):\n        \"\"\"Check type compatibility in assignment.\"\"\"\n        # Your code here\n        pass\n\n# Test\nsa = SemanticAnalyzer()\nsa.declare_variable('x', 'int')\nsa.check_assignment('x', 'string')  # Type mismatch\nprint(len(sa.errors))  # Should have at least one error",
    "solution": "class SemanticAnalyzer:\n    def __init__(self):\n        self.symbols = {}\n        self.errors = []\n\n    def declare_variable(self, name, var_type):\n        \"\"\"Declare variable, detect duplicate declarations.\"\"\"\n        if name in self.symbols:\n            self.errors.append(f\"Duplicate declaration of '{name}'\")\n            return False\n        self.symbols[name] = var_type\n        return True\n\n    def check_variable_use(self, name):\n        \"\"\"Check if variable is defined before use.\"\"\"\n        if name not in self.symbols:\n            self.errors.append(f\"Undefined variable '{name}'\")\n            return False\n        return True\n\n    def check_assignment(self, name, value_type):\n        \"\"\"Check type compatibility in assignment.\"\"\"\n        if name not in self.symbols:\n            self.errors.append(f\"Assignment to undefined variable '{name}'\")\n            return False\n\n        if self.symbols[name] != value_type:\n            self.errors.append(\n                f\"Type mismatch: cannot assign {value_type} to {self.symbols[name]}\"\n            )\n            return False\n\n        return True\n\n# Test\nsa = SemanticAnalyzer()\nsa.declare_variable('x', 'int')\nsa.check_assignment('x', 'string')\nprint(len(sa.errors))",
    "testCases": [
      {
        "input": "type mismatch",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Detect type mismatch error"
      },
      {
        "input": "undefined variable",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Detect undefined variable"
      },
      {
        "input": "duplicate declaration",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Detect duplicate declaration"
      }
    ],
    "hints": [
      "Maintain a list of errors found during analysis",
      "Check symbol table before allowing usage",
      "Compare types for assignment compatibility",
      "Add descriptive error messages to the errors list"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex08",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Constant Folding",
    "difficulty": 3,
    "description": "Implement constant folding optimization that evaluates constant expressions at compile time.",
    "starterCode": "class ConstantFolder:\n    def fold(self, node):\n        \"\"\"\n        Fold constant expressions in AST.\n        node: {'kind': 'BinaryOp'/'Literal', ...}\n        Returns: simplified node\n        \"\"\"\n        # Your code here\n        pass\n\n# Example:\n# {'kind': 'BinaryOp', 'op': '+',\n#  'left': {'kind': 'Literal', 'value': 2},\n#  'right': {'kind': 'Literal', 'value': 3}}\n# Should fold to: {'kind': 'Literal', 'value': 5}\n\n# Test\ncf = ConstantFolder()\nnode = {'kind': 'BinaryOp', 'op': '+',\n        'left': {'kind': 'Literal', 'value': 2},\n        'right': {'kind': 'Literal', 'value': 3}}\nresult = cf.fold(node)\nprint(result['value'] if result['kind'] == 'Literal' else 'not folded')",
    "solution": "class ConstantFolder:\n    def fold(self, node):\n        \"\"\"\n        Fold constant expressions in AST.\n        Returns: simplified node\n        \"\"\"\n        if node['kind'] == 'Literal':\n            return node\n\n        if node['kind'] == 'BinaryOp':\n            # Recursively fold children\n            left = self.fold(node['left'])\n            right = self.fold(node['right'])\n\n            # If both are literals, compute result\n            if left['kind'] == 'Literal' and right['kind'] == 'Literal':\n                op = node['op']\n                left_val = left['value']\n                right_val = right['value']\n\n                if op == '+':\n                    result = left_val + right_val\n                elif op == '-':\n                    result = left_val - right_val\n                elif op == '*':\n                    result = left_val * right_val\n                elif op == '/':\n                    if right_val != 0:\n                        result = left_val // right_val\n                    else:\n                        return node  # Can't fold division by zero\n                else:\n                    return node\n\n                return {'kind': 'Literal', 'value': result}\n\n            # Return node with folded children\n            return {\n                'kind': 'BinaryOp',\n                'op': node['op'],\n                'left': left,\n                'right': right\n            }\n\n        return node\n\n# Test\ncf = ConstantFolder()\nnode = {'kind': 'BinaryOp', 'op': '+',\n        'left': {'kind': 'Literal', 'value': 2},\n        'right': {'kind': 'Literal', 'value': 3}}\nresult = cf.fold(node)\nprint(result['value'] if result['kind'] == 'Literal' else 'not folded')",
    "testCases": [
      {
        "input": "2 + 3",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Fold simple addition"
      },
      {
        "input": "10 * 2",
        "expectedOutput": "20",
        "isHidden": false,
        "description": "Fold multiplication"
      },
      {
        "input": "nested: (2 + 3) * 4",
        "expectedOutput": "20",
        "isHidden": true,
        "description": "Fold nested expressions"
      }
    ],
    "hints": [
      "Recursively fold child expressions first",
      "If both operands are literals, compute the result",
      "Replace the BinaryOp node with a Literal node",
      "Handle all arithmetic operators"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex09",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Control Flow Analysis",
    "difficulty": 4,
    "description": "Detect unreachable code after return statements or in conditional branches.",
    "starterCode": "class ControlFlowAnalyzer:\n    def __init__(self):\n        self.warnings = []\n\n    def analyze_block(self, statements):\n        \"\"\"\n        Analyze a block of statements for unreachable code.\n        statements: list of {'kind': 'Return'/'If'/'Assignment', ...}\n        Returns: True if block definitely returns\n        \"\"\"\n        # Your code here\n        pass\n\n# Example statements:\n# {'kind': 'Return', 'value': ...}\n# {'kind': 'Assignment', 'var': 'x', 'value': ...}\n# {'kind': 'If', 'condition': ..., 'then': [...], 'else': [...]}\n\n# Test\ncfa = ControlFlowAnalyzer()\nstmts = [\n    {'kind': 'Return', 'value': 5},\n    {'kind': 'Assignment', 'var': 'x', 'value': 10}  # Unreachable\n]\ncfa.analyze_block(stmts)\nprint(len(cfa.warnings))  # Should detect unreachable code",
    "solution": "class ControlFlowAnalyzer:\n    def __init__(self):\n        self.warnings = []\n\n    def analyze_block(self, statements):\n        \"\"\"\n        Analyze a block of statements for unreachable code.\n        Returns: True if block definitely returns\n        \"\"\"\n        for i, stmt in enumerate(statements):\n            if stmt['kind'] == 'Return':\n                # Check if there are statements after return\n                if i < len(statements) - 1:\n                    self.warnings.append(\n                        f\"Unreachable code after return statement\"\n                    )\n                return True\n\n            elif stmt['kind'] == 'If':\n                # Analyze both branches\n                then_returns = self.analyze_block(stmt.get('then', []))\n                else_returns = self.analyze_block(stmt.get('else', []))\n\n                # If both branches return, the if statement returns\n                if then_returns and else_returns:\n                    if i < len(statements) - 1:\n                        self.warnings.append(\n                            f\"Unreachable code after if statement\"\n                        )\n                    return True\n\n        return False\n\n# Test\ncfa = ControlFlowAnalyzer()\nstmts = [\n    {'kind': 'Return', 'value': 5},\n    {'kind': 'Assignment', 'var': 'x', 'value': 10}\n]\ncfa.analyze_block(stmts)\nprint(len(cfa.warnings))",
    "testCases": [
      {
        "input": "code after return",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Detect unreachable code after return"
      },
      {
        "input": "both branches return",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Code after if with returns in both branches"
      },
      {
        "input": "no unreachable code",
        "expectedOutput": "0",
        "isHidden": true,
        "description": "Valid control flow"
      }
    ],
    "hints": [
      "Track whether each statement can return",
      "After a return statement, remaining statements are unreachable",
      "If both branches of an if return, code after is unreachable",
      "Recursively analyze nested blocks"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex10",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Type Casting Insertion",
    "difficulty": 3,
    "description": "Automatically insert type casts where needed to make expressions type-correct (e.g., int to float).",
    "starterCode": "class TypeCaster:\n    def __init__(self):\n        # Define valid casts\n        self.valid_casts = {\n            ('int', 'float'): True,\n            ('int', 'string'): True,\n            ('float', 'string'): True\n        }\n\n    def insert_cast(self, node, target_type):\n        \"\"\"\n        Insert cast node if needed.\n        Returns: node or cast node wrapping it\n        \"\"\"\n        # Your code here\n        pass\n\n    def can_cast(self, from_type, to_type):\n        \"\"\"Check if cast is valid.\"\"\"\n        # Your code here\n        pass\n\n# Test\ntc = TypeCaster()\nnode = {'kind': 'Literal', 'type': 'int', 'value': 5}\nresult = tc.insert_cast(node, 'float')\nprint(result['kind'])  # Should be 'Cast'",
    "solution": "class TypeCaster:\n    def __init__(self):\n        # Define valid casts\n        self.valid_casts = {\n            ('int', 'float'): True,\n            ('int', 'string'): True,\n            ('float', 'string'): True\n        }\n\n    def can_cast(self, from_type, to_type):\n        \"\"\"Check if cast is valid.\"\"\"\n        if from_type == to_type:\n            return True\n        return (from_type, to_type) in self.valid_casts\n\n    def insert_cast(self, node, target_type):\n        \"\"\"\n        Insert cast node if needed.\n        Returns: node or cast node wrapping it\n        \"\"\"\n        # Determine source type\n        if 'type' in node:\n            source_type = node['type']\n        elif 'computed_type' in node:\n            source_type = node['computed_type']\n        else:\n            return node  # Can't determine type\n\n        # No cast needed if types match\n        if source_type == target_type:\n            return node\n\n        # Check if cast is valid\n        if not self.can_cast(source_type, target_type):\n            return None  # Invalid cast\n\n        # Insert cast node\n        return {\n            'kind': 'Cast',\n            'from_type': source_type,\n            'to_type': target_type,\n            'expr': node,\n            'type': target_type\n        }\n\n# Test\ntc = TypeCaster()\nnode = {'kind': 'Literal', 'type': 'int', 'value': 5}\nresult = tc.insert_cast(node, 'float')\nprint(result['kind'])",
    "testCases": [
      {
        "input": "int to float",
        "expectedOutput": "Cast",
        "isHidden": false,
        "description": "Insert cast for int to float"
      },
      {
        "input": "same type",
        "expectedOutput": "Literal",
        "isHidden": false,
        "description": "No cast needed for same type"
      },
      {
        "input": "invalid cast",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Return None for invalid cast"
      }
    ],
    "hints": [
      "Check if source and target types are the same",
      "Consult valid_casts table for allowed conversions",
      "Wrap the expression in a Cast node",
      "Return None if cast is not valid"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex11",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Array Type Checking",
    "difficulty": 4,
    "description": "Implement type checking for array declarations, indexing, and assignments.",
    "starterCode": "class ArrayTypeChecker:\n    def __init__(self):\n        self.arrays = {}  # name -> (element_type, size)\n\n    def declare_array(self, name, element_type, size):\n        \"\"\"Declare an array with element type and size.\"\"\"\n        # Your code here\n        pass\n\n    def check_index(self, array_name, index_type):\n        \"\"\"\n        Check array indexing.\n        Returns element type or None if error.\n        \"\"\"\n        # Your code here\n        pass\n\n    def check_element_assignment(self, array_name, value_type):\n        \"\"\"\n        Check assignment to array element.\n        Returns True if valid.\n        \"\"\"\n        # Your code here\n        pass\n\n# Test\natc = ArrayTypeChecker()\natc.declare_array('arr', 'int', 10)\nprint(atc.check_index('arr', 'int'))  # Should return 'int'",
    "solution": "class ArrayTypeChecker:\n    def __init__(self):\n        self.arrays = {}  # name -> (element_type, size)\n\n    def declare_array(self, name, element_type, size):\n        \"\"\"Declare an array with element type and size.\"\"\"\n        self.arrays[name] = {\n            'element_type': element_type,\n            'size': size\n        }\n\n    def check_index(self, array_name, index_type):\n        \"\"\"\n        Check array indexing.\n        Returns element type or None if error.\n        \"\"\"\n        if array_name not in self.arrays:\n            return None  # Array not declared\n\n        if index_type != 'int':\n            return None  # Index must be int\n\n        return self.arrays[array_name]['element_type']\n\n    def check_element_assignment(self, array_name, value_type):\n        \"\"\"\n        Check assignment to array element.\n        Returns True if valid.\n        \"\"\"\n        if array_name not in self.arrays:\n            return False\n\n        element_type = self.arrays[array_name]['element_type']\n        return value_type == element_type\n\n# Test\natc = ArrayTypeChecker()\natc.declare_array('arr', 'int', 10)\nprint(atc.check_index('arr', 'int'))",
    "testCases": [
      {
        "input": "valid indexing",
        "expectedOutput": "int",
        "isHidden": false,
        "description": "Array indexing with int returns element type"
      },
      {
        "input": "non-int index",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Reject non-integer index"
      },
      {
        "input": "assignment",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Valid element assignment"
      }
    ],
    "hints": [
      "Store array metadata: element type and size",
      "Index type must be int",
      "Return element type for valid indexing",
      "Check type compatibility for assignments"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex12",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Method Resolution",
    "difficulty": 4,
    "description": "Implement method lookup in a class hierarchy, handling inheritance and method overriding.",
    "starterCode": "class ClassHierarchy:\n    def __init__(self):\n        self.classes = {}  # class_name -> {'parent': ..., 'methods': {...}}\n\n    def declare_class(self, name, parent=None):\n        \"\"\"Declare a class with optional parent.\"\"\"\n        # Your code here\n        pass\n\n    def add_method(self, class_name, method_name, signature):\n        \"\"\"Add a method to a class.\"\"\"\n        # Your code here\n        pass\n\n    def resolve_method(self, class_name, method_name):\n        \"\"\"\n        Resolve method by searching class and ancestors.\n        Returns method signature or None.\n        \"\"\"\n        # Your code here\n        pass\n\n# Test\nch = ClassHierarchy()\nch.declare_class('Animal')\nch.add_method('Animal', 'speak', (['self'], 'void'))\nch.declare_class('Dog', parent='Animal')\nprint(ch.resolve_method('Dog', 'speak'))  # Should find in parent",
    "solution": "class ClassHierarchy:\n    def __init__(self):\n        self.classes = {}  # class_name -> {'parent': ..., 'methods': {...}}\n\n    def declare_class(self, name, parent=None):\n        \"\"\"Declare a class with optional parent.\"\"\"\n        self.classes[name] = {\n            'parent': parent,\n            'methods': {}\n        }\n\n    def add_method(self, class_name, method_name, signature):\n        \"\"\"Add a method to a class.\"\"\"\n        if class_name in self.classes:\n            self.classes[class_name]['methods'][method_name] = signature\n\n    def resolve_method(self, class_name, method_name):\n        \"\"\"\n        Resolve method by searching class and ancestors.\n        Returns method signature or None.\n        \"\"\"\n        # Search current class\n        if class_name not in self.classes:\n            return None\n\n        current_class = self.classes[class_name]\n\n        # Check if method exists in current class\n        if method_name in current_class['methods']:\n            return current_class['methods'][method_name]\n\n        # Search parent class\n        parent = current_class['parent']\n        if parent:\n            return self.resolve_method(parent, method_name)\n\n        return None\n\n# Test\nch = ClassHierarchy()\nch.declare_class('Animal')\nch.add_method('Animal', 'speak', (['self'], 'void'))\nch.declare_class('Dog', parent='Animal')\nprint(ch.resolve_method('Dog', 'speak'))",
    "testCases": [
      {
        "input": "method in class",
        "expectedOutput": "signature",
        "isHidden": false,
        "description": "Find method in same class"
      },
      {
        "input": "inherited method",
        "expectedOutput": "signature",
        "isHidden": false,
        "description": "Find method in parent class"
      },
      {
        "input": "undefined method",
        "expectedOutput": "None",
        "isHidden": true,
        "description": "Method not found in hierarchy"
      }
    ],
    "hints": [
      "Search for method in current class first",
      "If not found, recursively search parent class",
      "Store parent class name for each class",
      "Methods can override parent methods"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex13",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Dead Code Elimination",
    "difficulty": 3,
    "description": "Identify and remove dead code (unused variables and unreachable statements).",
    "starterCode": "class DeadCodeEliminator:\n    def __init__(self):\n        self.used_vars = set()\n\n    def mark_used_variables(self, node):\n        \"\"\"Mark all variables used in an expression.\"\"\"\n        # Your code here\n        pass\n\n    def eliminate_unused_assignments(self, statements):\n        \"\"\"\n        Remove assignments to variables that are never used.\n        Returns: filtered list of statements\n        \"\"\"\n        # Your code here\n        pass\n\n# Example statement:\n# {'kind': 'Assignment', 'var': 'x', 'expr': ...}\n# {'kind': 'Return', 'expr': ...}\n\n# Test\ndce = DeadCodeEliminator()\nstmts = [\n    {'kind': 'Assignment', 'var': 'x', 'expr': {'kind': 'Literal', 'value': 5}},\n    {'kind': 'Assignment', 'var': 'y', 'expr': {'kind': 'Literal', 'value': 10}},\n    {'kind': 'Return', 'expr': {'kind': 'Variable', 'name': 'y'}}\n]\nresult = dce.eliminate_unused_assignments(stmts)\nprint(len(result))  # Should be 2 (x assignment removed)",
    "solution": "class DeadCodeEliminator:\n    def __init__(self):\n        self.used_vars = set()\n\n    def mark_used_variables(self, node):\n        \"\"\"Mark all variables used in an expression.\"\"\"\n        if not node:\n            return\n\n        if isinstance(node, dict):\n            if node.get('kind') == 'Variable':\n                self.used_vars.add(node['name'])\n\n            # Recursively mark in sub-nodes\n            for key, value in node.items():\n                if key in ['left', 'right', 'expr', 'condition', 'value']:\n                    self.mark_used_variables(value)\n                elif key == 'then' or key == 'else':\n                    for stmt in value:\n                        self.mark_used_variables(stmt)\n\n    def eliminate_unused_assignments(self, statements):\n        \"\"\"\n        Remove assignments to variables that are never used.\n        Returns: filtered list of statements\n        \"\"\"\n        # First pass: find all used variables\n        self.used_vars = set()\n        for stmt in statements:\n            if stmt['kind'] != 'Assignment':\n                # Mark variables used in non-assignment statements\n                self.mark_used_variables(stmt)\n\n        # Second pass: filter out unused assignments\n        result = []\n        for stmt in statements:\n            if stmt['kind'] == 'Assignment':\n                # Keep if variable is used\n                if stmt['var'] in self.used_vars:\n                    # Also mark variables used in RHS\n                    self.mark_used_variables(stmt['expr'])\n                    result.append(stmt)\n            else:\n                result.append(stmt)\n\n        return result\n\n# Test\ndce = DeadCodeEliminator()\nstmts = [\n    {'kind': 'Assignment', 'var': 'x', 'expr': {'kind': 'Literal', 'value': 5}},\n    {'kind': 'Assignment', 'var': 'y', 'expr': {'kind': 'Literal', 'value': 10}},\n    {'kind': 'Return', 'expr': {'kind': 'Variable', 'name': 'y'}}\n]\nresult = dce.eliminate_unused_assignments(stmts)\nprint(len(result))",
    "testCases": [
      {
        "input": "unused variable",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Remove assignment to unused variable"
      },
      {
        "input": "all used",
        "expectedOutput": "3",
        "isHidden": false,
        "description": "Keep all statements when all are used"
      },
      {
        "input": "chain dependency",
        "expectedOutput": "3",
        "isHidden": true,
        "description": "Keep assignments that contribute to used variables"
      }
    ],
    "hints": [
      "Use two passes: first to find used variables, second to filter",
      "Mark variables used in return/print statements",
      "Keep assignments only if the variable is later used",
      "Recursively search expressions for variable usage"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex14",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Return Type Checking",
    "difficulty": 3,
    "description": "Verify that all code paths in a function return values of the correct type.",
    "starterCode": "class ReturnChecker:\n    def __init__(self, expected_return_type):\n        self.expected_type = expected_return_type\n        self.errors = []\n\n    def check_return_type(self, statements):\n        \"\"\"\n        Check that all return statements have correct type.\n        Returns: True if all paths return correct type\n        \"\"\"\n        # Your code here\n        pass\n\n    def check_all_paths_return(self, statements):\n        \"\"\"\n        Check that all code paths return a value.\n        Returns: True if all paths return\n        \"\"\"\n        # Your code here\n        pass\n\n# Example:\n# statements = [\n#     {'kind': 'If', 'condition': ..., 'then': [...], 'else': [...]},\n#     {'kind': 'Return', 'type': 'int', 'value': ...}\n# ]\n\n# Test\nrc = ReturnChecker('int')\nstmts = [{'kind': 'Return', 'type': 'string', 'value': 'hello'}]\nrc.check_return_type(stmts)\nprint(len(rc.errors))  # Should detect type mismatch",
    "solution": "class ReturnChecker:\n    def __init__(self, expected_return_type):\n        self.expected_type = expected_return_type\n        self.errors = []\n\n    def check_return_type(self, statements):\n        \"\"\"\n        Check that all return statements have correct type.\n        Returns: True if all paths return correct type\n        \"\"\"\n        has_return = False\n\n        for stmt in statements:\n            if stmt['kind'] == 'Return':\n                has_return = True\n                return_type = stmt.get('type')\n\n                if return_type != self.expected_type:\n                    self.errors.append(\n                        f\"Type mismatch: expected {self.expected_type}, \"\n                        f\"got {return_type}\"\n                    )\n\n            elif stmt['kind'] == 'If':\n                # Recursively check both branches\n                self.check_return_type(stmt.get('then', []))\n                self.check_return_type(stmt.get('else', []))\n\n        return len(self.errors) == 0\n\n    def check_all_paths_return(self, statements):\n        \"\"\"\n        Check that all code paths return a value.\n        Returns: True if all paths return\n        \"\"\"\n        for stmt in statements:\n            if stmt['kind'] == 'Return':\n                return True\n\n            elif stmt['kind'] == 'If':\n                then_returns = self.check_all_paths_return(stmt.get('then', []))\n                else_returns = self.check_all_paths_return(stmt.get('else', []))\n\n                # Both branches must return\n                if then_returns and else_returns:\n                    return True\n\n        return False\n\n# Test\nrc = ReturnChecker('int')\nstmts = [{'kind': 'Return', 'type': 'string', 'value': 'hello'}]\nrc.check_return_type(stmts)\nprint(len(rc.errors))",
    "testCases": [
      {
        "input": "correct type",
        "expectedOutput": "0",
        "isHidden": false,
        "description": "Return type matches"
      },
      {
        "input": "wrong type",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Return type mismatch"
      },
      {
        "input": "missing return",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Not all paths return"
      }
    ],
    "hints": [
      "Compare return statement types with expected type",
      "Recursively check conditional branches",
      "All paths must return for non-void functions",
      "Both if and else branches must return"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex15",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Attribute Grammar Evaluation",
    "difficulty": 4,
    "description": "Implement attribute grammar for computing inherited and synthesized attributes on parse trees.",
    "starterCode": "class AttributeGrammar:\n    def __init__(self):\n        pass\n\n    def evaluate_synthesized(self, node):\n        \"\"\"\n        Compute synthesized attributes (bottom-up).\n        Example: expression value\n        \"\"\"\n        # Your code here\n        pass\n\n    def evaluate_inherited(self, node, parent_attrs):\n        \"\"\"\n        Compute inherited attributes (top-down).\n        Example: expected type from parent\n        \"\"\"\n        # Your code here\n        pass\n\n# Node structure:\n# {'kind': 'BinaryOp', 'op': '+', 'left': ..., 'right': ...}\n# {'kind': 'Literal', 'value': 5}\n\n# Test\nag = AttributeGrammar()\nnode = {'kind': 'BinaryOp', 'op': '+',\n        'left': {'kind': 'Literal', 'value': 3},\n        'right': {'kind': 'Literal', 'value': 7}}\nresult = ag.evaluate_synthesized(node)\nprint(result)  # Should compute value attribute",
    "solution": "class AttributeGrammar:\n    def __init__(self):\n        pass\n\n    def evaluate_synthesized(self, node):\n        \"\"\"\n        Compute synthesized attributes (bottom-up).\n        Example: expression value\n        \"\"\"\n        if node['kind'] == 'Literal':\n            node['value_attr'] = node['value']\n            node['type_attr'] = 'int'\n            return node['value_attr']\n\n        elif node['kind'] == 'BinaryOp':\n            # Evaluate children first (bottom-up)\n            left_val = self.evaluate_synthesized(node['left'])\n            right_val = self.evaluate_synthesized(node['right'])\n\n            # Compute this node's attribute\n            op = node['op']\n            if op == '+':\n                result = left_val + right_val\n            elif op == '-':\n                result = left_val - right_val\n            elif op == '*':\n                result = left_val * right_val\n            else:\n                result = 0\n\n            node['value_attr'] = result\n            node['type_attr'] = 'int'\n            return result\n\n        return None\n\n    def evaluate_inherited(self, node, parent_attrs):\n        \"\"\"\n        Compute inherited attributes (top-down).\n        Example: expected type from parent\n        \"\"\"\n        # Pass down attributes from parent\n        node['expected_type'] = parent_attrs.get('expected_type', 'int')\n\n        # Recursively pass to children\n        if node['kind'] == 'BinaryOp':\n            child_attrs = {'expected_type': node['expected_type']}\n            self.evaluate_inherited(node['left'], child_attrs)\n            self.evaluate_inherited(node['right'], child_attrs)\n\n# Test\nag = AttributeGrammar()\nnode = {'kind': 'BinaryOp', 'op': '+',\n        'left': {'kind': 'Literal', 'value': 3},\n        'right': {'kind': 'Literal', 'value': 7}}\nresult = ag.evaluate_synthesized(node)\nprint(result)",
    "testCases": [
      {
        "input": "simple expression",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "Synthesized value attribute"
      },
      {
        "input": "multiplication",
        "expectedOutput": "21",
        "isHidden": false,
        "description": "Compute 3 * 7"
      },
      {
        "input": "inherited type",
        "expectedOutput": "int",
        "isHidden": true,
        "description": "Pass expected type down"
      }
    ],
    "hints": [
      "Synthesized attributes flow bottom-up from children",
      "Inherited attributes flow top-down from parent",
      "Evaluate children before computing node attribute",
      "Store attributes as node properties"
    ],
    "language": "python"
  },
  {
    "id": "cs304-t3-ex16",
    "subjectId": "cs304",
    "topicId": "cs304-topic-3",
    "title": "Complete Semantic Analyzer",
    "difficulty": 5,
    "description": "Build a complete semantic analyzer that performs symbol table management, type checking, and semantic error detection.",
    "starterCode": "class SemanticAnalyzer:\n    def __init__(self):\n        self.symbol_table = [{}]  # Scope stack\n        self.errors = []\n        self.current_function = None\n\n    def enter_scope(self):\n        \"\"\"Enter new scope.\"\"\"\n        # Your code here\n        pass\n\n    def exit_scope(self):\n        \"\"\"Exit current scope.\"\"\"\n        # Your code here\n        pass\n\n    def analyze_program(self, ast):\n        \"\"\"\n        Analyze complete program AST.\n        Performs:\n        - Symbol table construction\n        - Type checking\n        - Semantic error detection\n        Returns: True if no errors\n        \"\"\"\n        # Your code here\n        pass\n\n    def analyze_function(self, node):\n        \"\"\"Analyze function declaration.\"\"\"\n        # Your code here\n        pass\n\n    def analyze_statement(self, node):\n        \"\"\"Analyze individual statement.\"\"\"\n        # Your code here\n        pass\n\n    def analyze_expression(self, node):\n        \"\"\"Analyze expression and return its type.\"\"\"\n        # Your code here\n        pass\n\n# Test\nanalyzer = SemanticAnalyzer()\nprogram = {\n    'kind': 'Program',\n    'functions': [\n        {\n            'kind': 'Function',\n            'name': 'main',\n            'params': [],\n            'return_type': 'int',\n            'body': [\n                {'kind': 'Return', 'expr': {'kind': 'Literal', 'type': 'int', 'value': 0}}\n            ]\n        }\n    ]\n}\nresult = analyzer.analyze_program(program)\nprint(result)",
    "solution": "class SemanticAnalyzer:\n    def __init__(self):\n        self.symbol_table = [{}]  # Scope stack\n        self.errors = []\n        self.current_function = None\n\n    def enter_scope(self):\n        \"\"\"Enter new scope.\"\"\"\n        self.symbol_table.append({})\n\n    def exit_scope(self):\n        \"\"\"Exit current scope.\"\"\"\n        if len(self.symbol_table) > 1:\n            self.symbol_table.pop()\n\n    def declare_symbol(self, name, symbol_type):\n        \"\"\"Declare symbol in current scope.\"\"\"\n        if name in self.symbol_table[-1]:\n            self.errors.append(f\"Duplicate declaration: {name}\")\n            return False\n        self.symbol_table[-1][name] = symbol_type\n        return True\n\n    def lookup_symbol(self, name):\n        \"\"\"Look up symbol in all scopes.\"\"\"\n        for scope in reversed(self.symbol_table):\n            if name in scope:\n                return scope[name]\n        return None\n\n    def analyze_program(self, ast):\n        \"\"\"Analyze complete program AST.\"\"\"\n        if ast['kind'] != 'Program':\n            return False\n\n        # Analyze each function\n        for func in ast.get('functions', []):\n            self.analyze_function(func)\n\n        return len(self.errors) == 0\n\n    def analyze_function(self, node):\n        \"\"\"Analyze function declaration.\"\"\"\n        func_name = node['name']\n        param_types = [p['type'] for p in node.get('params', [])]\n        return_type = node['return_type']\n\n        # Declare function in global scope\n        self.symbol_table[0][func_name] = {\n            'kind': 'function',\n            'params': param_types,\n            'return_type': return_type\n        }\n\n        # Enter function scope\n        self.current_function = return_type\n        self.enter_scope()\n\n        # Declare parameters\n        for param in node.get('params', []):\n            self.declare_symbol(param['name'], param['type'])\n\n        # Analyze function body\n        for stmt in node.get('body', []):\n            self.analyze_statement(stmt)\n\n        self.exit_scope()\n        self.current_function = None\n\n    def analyze_statement(self, node):\n        \"\"\"Analyze individual statement.\"\"\"\n        kind = node['kind']\n\n        if kind == 'Return':\n            expr_type = self.analyze_expression(node['expr'])\n            if expr_type != self.current_function:\n                self.errors.append(\n                    f\"Return type mismatch: expected {self.current_function}, got {expr_type}\"\n                )\n\n        elif kind == 'Assignment':\n            var_name = node['var']\n            var_type = self.lookup_symbol(var_name)\n\n            if var_type is None:\n                self.errors.append(f\"Undefined variable: {var_name}\")\n            else:\n                expr_type = self.analyze_expression(node['expr'])\n                if expr_type != var_type:\n                    self.errors.append(\n                        f\"Type mismatch in assignment to {var_name}\"\n                    )\n\n        elif kind == 'Declaration':\n            self.declare_symbol(node['name'], node['type'])\n\n    def analyze_expression(self, node):\n        \"\"\"Analyze expression and return its type.\"\"\"\n        kind = node['kind']\n\n        if kind == 'Literal':\n            return node['type']\n\n        elif kind == 'Variable':\n            var_type = self.lookup_symbol(node['name'])\n            if var_type is None:\n                self.errors.append(f\"Undefined variable: {node['name']}\")\n                return None\n            return var_type\n\n        elif kind == 'BinaryOp':\n            left_type = self.analyze_expression(node['left'])\n            right_type = self.analyze_expression(node['right'])\n\n            if left_type != right_type:\n                self.errors.append(\"Type mismatch in binary operation\")\n                return None\n\n            return left_type\n\n        return None\n\n# Test\nanalyzer = SemanticAnalyzer()\nprogram = {\n    'kind': 'Program',\n    'functions': [\n        {\n            'kind': 'Function',\n            'name': 'main',\n            'params': [],\n            'return_type': 'int',\n            'body': [\n                {'kind': 'Return', 'expr': {'kind': 'Literal', 'type': 'int', 'value': 0}}\n            ]\n        }\n    ]\n}\nresult = analyzer.analyze_program(program)\nprint(result)",
    "testCases": [
      {
        "input": "valid program",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Program with no errors"
      },
      {
        "input": "undefined variable",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Detect undefined variable use"
      },
      {
        "input": "type mismatch",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Detect type errors"
      }
    ],
    "hints": [
      "Use scope stack for nested symbol tables",
      "Analyze functions, statements, and expressions recursively",
      "Track current function for return type checking",
      "Collect all errors instead of stopping at first one"
    ],
    "language": "python"
  }
]

[
  {
    "id": "cs304-t1-quiz-1",
    "subjectId": "cs304",
    "topicId": "cs304-topic-1",
    "title": "Compiler Fundamentals",
    "questions": [
      {
        "id": "cs304-t1-q1-1",
        "type": "multiple_choice",
        "prompt": "Which phase of a compiler converts source code into a stream of tokens?",
        "options": [
          "Parsing",
          "Lexical analysis",
          "Semantic analysis",
          "Code generation"
        ],
        "correctAnswer": 1,
        "explanation": "Lexical analysis (scanning) breaks source code into tokens like identifiers, keywords, and operators."
      },
      {
        "id": "cs304-t1-q1-2",
        "type": "multiple_choice",
        "prompt": "What is the difference between a lexeme and a token?",
        "options": [
          "They are the same thing",
          "A lexeme is the actual string; a token is its category",
          "A token is the actual string; a lexeme is its category",
          "Lexemes are only for keywords"
        ],
        "correctAnswer": 1,
        "explanation": "A lexeme is the actual character sequence (e.g., \"count\"), while a token is its classification (e.g., IDENTIFIER)."
      },
      {
        "id": "cs304-t1-q1-3",
        "type": "multiple_choice",
        "prompt": "Which compiler phase typically handles whitespace and comments?",
        "options": [
          "Parser",
          "Scanner",
          "Semantic analyzer",
          "Optimizer"
        ],
        "correctAnswer": 1,
        "explanation": "The scanner (lexical analyzer) typically discards whitespace and comments, not passing them to the parser."
      },
      {
        "id": "cs304-t1-q1-4",
        "type": "multiple_choice",
        "prompt": "What distinguishes an interpreter from a compiler?",
        "options": [
          "Interpreters are faster",
          "Compilers execute code directly",
          "Interpreters execute without producing target code",
          "Compilers cannot optimize"
        ],
        "correctAnswer": 2,
        "explanation": "Interpreters execute source code directly without producing standalone target code, unlike compilers."
      },
      {
        "id": "cs304-t1-q1-5",
        "type": "multiple_choice",
        "prompt": "What is the front-end of a compiler responsible for?",
        "options": [
          "Code optimization",
          "Machine code generation",
          "Analysis and IR generation",
          "Linking"
        ],
        "correctAnswer": 2,
        "explanation": "The front-end handles lexical, syntax, and semantic analysis, producing an intermediate representation."
      }
    ]
  },
  {
    "id": "cs304-t1-quiz-2",
    "subjectId": "cs304",
    "topicId": "cs304-topic-1",
    "title": "Regular Expressions and Automata",
    "questions": [
      {
        "id": "cs304-t1-q2-1",
        "type": "multiple_choice",
        "prompt": "Which regular expression matches one or more digits?",
        "options": [
          "[0-9]*",
          "[0-9]+",
          "[0-9]?",
          "[0-9]"
        ],
        "correctAnswer": 1,
        "explanation": "The + operator means one or more occurrences, while * means zero or more."
      },
      {
        "id": "cs304-t1-q2-2",
        "type": "multiple_choice",
        "prompt": "What is the key difference between a DFA and an NFA?",
        "options": [
          "DFAs are more powerful",
          "NFAs have exactly one transition per symbol per state",
          "DFAs have at most one transition per symbol per state",
          "NFAs cannot have epsilon transitions"
        ],
        "correctAnswer": 2,
        "explanation": "DFAs have exactly one transition for each symbol from each state, making them deterministic."
      },
      {
        "id": "cs304-t1-q2-3",
        "type": "multiple_choice",
        "prompt": "What is an epsilon (Îµ) transition in an NFA?",
        "options": [
          "A transition that consumes any character",
          "A transition that occurs without consuming input",
          "A transition to an error state",
          "A transition that matches whitespace"
        ],
        "correctAnswer": 1,
        "explanation": "Epsilon transitions allow state changes without consuming any input character."
      },
      {
        "id": "cs304-t1-q2-4",
        "type": "multiple_choice",
        "prompt": "Can every NFA be converted to an equivalent DFA?",
        "options": [
          "No, NFAs are more powerful",
          "Yes, using subset construction",
          "Only if the NFA has no epsilon transitions",
          "Only for finite languages"
        ],
        "correctAnswer": 1,
        "explanation": "The subset construction algorithm can convert any NFA to an equivalent DFA, though it may have exponentially more states."
      },
      {
        "id": "cs304-t1-q2-5",
        "type": "multiple_choice",
        "prompt": "What does the regular expression a(b|c)*d match?",
        "options": [
          "abd or acd only",
          "Strings starting with a, ending with d, with any b/c sequence in between",
          "abcd only",
          "Any string with a and d"
        ],
        "correctAnswer": 1,
        "explanation": "It matches \"a\", followed by zero or more b's or c's (in any order), followed by \"d\"."
      }
    ]
  },
  {
    "id": "cs304-t1-quiz-3",
    "subjectId": "cs304",
    "topicId": "cs304-topic-1",
    "title": "Scanner Implementation",
    "questions": [
      {
        "id": "cs304-t1-q3-1",
        "type": "multiple_choice",
        "prompt": "What is the maximal munch rule in lexical analysis?",
        "options": [
          "Prefer shorter tokens",
          "Prefer longer tokens",
          "Prefer alphabetically first tokens",
          "Process one character at a time"
        ],
        "correctAnswer": 1,
        "explanation": "Maximal munch means the scanner should match the longest possible token at each point."
      },
      {
        "id": "cs304-t1-q3-2",
        "type": "multiple_choice",
        "prompt": "What tool is commonly used to generate scanners from regular expression specifications?",
        "options": [
          "yacc",
          "bison",
          "lex/flex",
          "make"
        ],
        "correctAnswer": 2,
        "explanation": "Lex and its GNU implementation flex generate C scanners from regular expression patterns."
      },
      {
        "id": "cs304-t1-q3-3",
        "type": "multiple_choice",
        "prompt": "How does a scanner typically handle keywords vs identifiers?",
        "options": [
          "Separate DFAs for each",
          "Match as identifier, then check keyword table",
          "Keywords have higher DFA priority",
          "Keywords are handled by the parser"
        ],
        "correctAnswer": 1,
        "explanation": "A common approach matches identifiers first, then looks up in a reserved word table to distinguish keywords."
      },
      {
        "id": "cs304-t1-q3-4",
        "type": "multiple_choice",
        "prompt": "What is a lookahead in lexical analysis?",
        "options": [
          "Predicting future tokens",
          "Reading ahead to decide current token boundaries",
          "Caching tokens",
          "Parallel scanning"
        ],
        "correctAnswer": 1,
        "explanation": "Lookahead reads additional characters to determine where the current token ends (e.g., \"=\" vs \"==\")."
      },
      {
        "id": "cs304-t1-q3-5",
        "type": "multiple_choice",
        "prompt": "What is panic mode error recovery in lexical analysis?",
        "options": [
          "Terminating immediately on error",
          "Discarding characters until a valid token start",
          "Inserting missing characters",
          "Switching to a backup scanner"
        ],
        "correctAnswer": 1,
        "explanation": "Panic mode skips characters until recognizing a valid token beginning, allowing continued scanning."
      }
    ]
  }
]

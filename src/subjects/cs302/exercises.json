[
  {
    "id": "cs302-t1-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "OSI Layer Identifier",
    "difficulty": 1,
    "description": "Write a function that takes a protocol name and returns which OSI layer it belongs to. Supported protocols: HTTP, TCP, IP, Ethernet, FTP, UDP, ARP.",
    "starterCode": "# Return the OSI layer number (1-7) for a protocol\ndef get_osi_layer(protocol):\n    # Your code here\n    pass\n\n# Test your function\nprint(get_osi_layer(\"HTTP\"))\nprint(get_osi_layer(\"TCP\"))\nprint(get_osi_layer(\"IP\"))",
    "solution": "def get_osi_layer(protocol):\n    layers = {\n        \"HTTP\": 7, \"FTP\": 7, \"SMTP\": 7, \"DNS\": 7,\n        \"TCP\": 4, \"UDP\": 4,\n        \"IP\": 3, \"ICMP\": 3, \"ARP\": 3,\n        \"Ethernet\": 2, \"PPP\": 2,\n        \"Physical\": 1\n    }\n    return layers.get(protocol.upper(), -1)\n\nprint(get_osi_layer(\"HTTP\"))\nprint(get_osi_layer(\"TCP\"))\nprint(get_osi_layer(\"IP\"))",
    "testCases": [
      {
        "input": "\"HTTP\"",
        "isHidden": false,
        "description": "Application layer protocol"
      },
      {
        "input": "\"TCP\"",
        "isHidden": false,
        "description": "Transport layer protocol"
      },
      {
        "input": "\"IP\"",
        "isHidden": true,
        "description": "Network layer protocol"
      }
    ],
    "hints": [
      "Use a dictionary to map protocols to layer numbers",
      "HTTP, FTP are layer 7 (Application)",
      "TCP, UDP are layer 4 (Transport)",
      "IP is layer 3 (Network)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "PDU Name Mapper",
    "difficulty": 1,
    "description": "Write a function that takes an OSI layer number (1-7) and returns the name of the Protocol Data Unit (PDU) at that layer.",
    "starterCode": "# Return the PDU name for a given OSI layer\ndef get_pdu_name(layer):\n    # Your code here\n    pass\n\n# Test your function\nprint(get_pdu_name(7))\nprint(get_pdu_name(4))\nprint(get_pdu_name(2))",
    "solution": "def get_pdu_name(layer):\n    pdus = {\n        7: \"Data\", 6: \"Data\", 5: \"Data\",\n        4: \"Segment\",\n        3: \"Packet\",\n        2: \"Frame\",\n        1: \"Bits\"\n    }\n    return pdus.get(layer, \"Unknown\")\n\nprint(get_pdu_name(7))\nprint(get_pdu_name(4))\nprint(get_pdu_name(2))",
    "testCases": [
      {
        "input": "7",
        "isHidden": false,
        "description": "Application layer PDU"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "Transport layer PDU"
      },
      {
        "input": "2",
        "isHidden": true,
        "description": "Data link layer PDU"
      }
    ],
    "hints": [
      "Layers 5-7 use \"Data\" as their PDU",
      "Layer 4 uses \"Segment\"",
      "Layer 3 uses \"Packet\"",
      "Layer 2 uses \"Frame\""
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Encapsulation Simulator",
    "difficulty": 2,
    "description": "Simulate the encapsulation process. Write a function that takes application data and headers for each layer, and returns a list showing the data at each layer from application to physical.",
    "starterCode": "# Simulate encapsulation from layer 7 to layer 1\ndef encapsulate(data, transport_header, network_header, frame_header, frame_trailer):\n    # Your code here\n    pass\n\n# Test your function\nresult = encapsulate(\"Hello\", \"TCP:\", \"IP:\", \"ETH:\", \":FCS\")\nfor layer, pdu in enumerate(result, 1):\n    print(f\"Layer {8-layer}: {pdu}\")",
    "solution": "def encapsulate(data, transport_header, network_header, frame_header, frame_trailer):\n    layers = []\n    # Application data (Layer 7)\n    layers.append(data)\n    # Transport segment (Layer 4)\n    segment = transport_header + data\n    layers.append(segment)\n    # Network packet (Layer 3)\n    packet = network_header + segment\n    layers.append(packet)\n    # Data link frame (Layer 2)\n    frame = frame_header + packet + frame_trailer\n    layers.append(frame)\n    return layers\n\nresult = encapsulate(\"Hello\", \"TCP:\", \"IP:\", \"ETH:\", \":FCS\")\nfor layer, pdu in enumerate(result, 1):\n    print(f\"Layer {8-layer}: {pdu}\")",
    "testCases": [
      {
        "input": "\"Hi\", \"T:\", \"N:\", \"F:\", \":C\"",
        "isHidden": false,
        "description": "Simple encapsulation"
      },
      {
        "input": "\"Data\", \"TCP:\", \"IP:\", \"ETH:\", \":FCS\"",
        "isHidden": true,
        "description": "Standard headers"
      }
    ],
    "hints": [
      "Start with the raw application data",
      "Each layer adds its header in front",
      "The data link layer also adds a trailer at the end",
      "Return a list of the PDU at each step"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "TCP/IP to OSI Mapper",
    "difficulty": 2,
    "description": "Write a function that maps TCP/IP model layer names to their corresponding OSI layer numbers. TCP/IP layers are: Application, Transport, Internet, Network Access.",
    "starterCode": "# Map TCP/IP layer name to OSI layer number(s)\ndef tcpip_to_osi(tcpip_layer):\n    # Your code here\n    pass\n\n# Test your function\nprint(tcpip_to_osi(\"Application\"))\nprint(tcpip_to_osi(\"Transport\"))\nprint(tcpip_to_osi(\"Internet\"))",
    "solution": "def tcpip_to_osi(tcpip_layer):\n    mapping = {\n        \"Application\": [5, 6, 7],\n        \"Transport\": [4],\n        \"Internet\": [3],\n        \"Network Access\": [1, 2]\n    }\n    return mapping.get(tcpip_layer, [])\n\nprint(tcpip_to_osi(\"Application\"))\nprint(tcpip_to_osi(\"Transport\"))\nprint(tcpip_to_osi(\"Internet\"))",
    "testCases": [
      {
        "input": "\"Application\"",
        "isHidden": false,
        "description": "Application layer mapping"
      },
      {
        "input": "\"Transport\"",
        "isHidden": false,
        "description": "Transport layer mapping"
      },
      {
        "input": "\"Network Access\"",
        "isHidden": true,
        "description": "Network access layer mapping"
      }
    ],
    "hints": [
      "TCP/IP Application maps to OSI layers 5, 6, 7",
      "TCP/IP Transport maps to OSI layer 4",
      "TCP/IP Internet maps to OSI layer 3",
      "TCP/IP Network Access maps to OSI layers 1, 2"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Network Device Classifier",
    "difficulty": 2,
    "description": "Write a function that takes a network device name and returns the OSI layer(s) it operates at. Devices: hub, switch, router, gateway, repeater.",
    "starterCode": "# Return the OSI layer(s) a device operates at\ndef device_layer(device):\n    # Your code here\n    pass\n\n# Test your function\nprint(device_layer(\"hub\"))\nprint(device_layer(\"switch\"))\nprint(device_layer(\"router\"))",
    "solution": "def device_layer(device):\n    devices = {\n        \"hub\": [1],\n        \"repeater\": [1],\n        \"switch\": [2],\n        \"bridge\": [2],\n        \"router\": [3],\n        \"gateway\": [7],\n        \"firewall\": [3, 4, 7]\n    }\n    return devices.get(device.lower(), [])\n\nprint(device_layer(\"hub\"))\nprint(device_layer(\"switch\"))\nprint(device_layer(\"router\"))",
    "testCases": [
      {
        "input": "\"hub\"",
        "isHidden": false,
        "description": "Layer 1 device"
      },
      {
        "input": "\"switch\"",
        "isHidden": false,
        "description": "Layer 2 device"
      },
      {
        "input": "\"router\"",
        "isHidden": true,
        "description": "Layer 3 device"
      }
    ],
    "hints": [
      "Hubs and repeaters work at Layer 1 (Physical)",
      "Switches and bridges work at Layer 2 (Data Link)",
      "Routers work at Layer 3 (Network)",
      "Gateways can work at Layer 7 (Application)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Bandwidth Calculator",
    "difficulty": 2,
    "description": "Write a function that calculates the time to transfer a file given the file size (in MB) and bandwidth (in Mbps). Return time in seconds.",
    "starterCode": "# Calculate transfer time in seconds\ndef transfer_time(file_size_mb, bandwidth_mbps):\n    # Your code here\n    pass\n\n# Test your function\nprint(transfer_time(100, 10))  # 100 MB at 10 Mbps\nprint(transfer_time(1000, 100))  # 1 GB at 100 Mbps",
    "solution": "def transfer_time(file_size_mb, bandwidth_mbps):\n    # Convert MB to Megabits (1 byte = 8 bits)\n    file_size_mbits = file_size_mb * 8\n    # Time = size / bandwidth\n    time_seconds = file_size_mbits / bandwidth_mbps\n    return time_seconds\n\nprint(transfer_time(100, 10))  # 100 MB at 10 Mbps\nprint(transfer_time(1000, 100))  # 1 GB at 100 Mbps",
    "testCases": [
      {
        "input": "100, 10",
        "isHidden": false,
        "description": "100 MB at 10 Mbps"
      },
      {
        "input": "1000, 100",
        "isHidden": false,
        "description": "1 GB at 100 Mbps"
      },
      {
        "input": "50, 25",
        "isHidden": true,
        "description": "50 MB at 25 Mbps"
      }
    ],
    "hints": [
      "Remember: 1 byte = 8 bits",
      "Convert file size from MB to Megabits first",
      "Time = Size / Bandwidth",
      "Mbps means Megabits per second, not Megabytes"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Latency Components",
    "difficulty": 3,
    "description": "Calculate total network latency given transmission delay, propagation delay, processing delay, and queuing delay. All values in milliseconds.",
    "starterCode": "# Calculate total latency from its components\ndef total_latency(transmission, propagation, processing, queuing):\n    # Your code here\n    pass\n\n# Test your function\nprint(total_latency(10, 5, 2, 3))  # Should be 20 ms",
    "solution": "def total_latency(transmission, propagation, processing, queuing):\n    return transmission + propagation + processing + queuing\n\nprint(total_latency(10, 5, 2, 3))  # Should be 20 ms",
    "testCases": [
      {
        "input": "10, 5, 2, 3",
        "isHidden": false,
        "description": "Basic latency calculation"
      },
      {
        "input": "100, 50, 10, 25",
        "isHidden": true,
        "description": "Larger values"
      }
    ],
    "hints": [
      "Total latency is the sum of all delay components",
      "Transmission delay = packet size / link bandwidth",
      "Propagation delay = distance / signal speed",
      "All components add up to the total"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Throughput Calculator",
    "difficulty": 3,
    "description": "Calculate effective throughput given bandwidth and efficiency percentage. Also calculate how long it takes to transfer a given amount of data.",
    "starterCode": "# Calculate effective throughput and transfer time\ndef calculate_throughput(bandwidth_mbps, efficiency_percent, data_mb):\n    # Return tuple: (effective_throughput_mbps, transfer_time_seconds)\n    pass\n\n# Test your function\nprint(calculate_throughput(100, 80, 500))",
    "solution": "def calculate_throughput(bandwidth_mbps, efficiency_percent, data_mb):\n    effective_throughput = bandwidth_mbps * (efficiency_percent / 100)\n    # Convert MB to Mbits for calculation\n    data_mbits = data_mb * 8\n    transfer_time = data_mbits / effective_throughput\n    return (effective_throughput, transfer_time)\n\nprint(calculate_throughput(100, 80, 500))",
    "testCases": [
      {
        "input": "100, 80, 500",
        "isHidden": false,
        "description": "100 Mbps at 80% efficiency"
      },
      {
        "input": "1000, 90, 1000",
        "isHidden": true,
        "description": "Gigabit with high efficiency"
      }
    ],
    "hints": [
      "Effective throughput = bandwidth * (efficiency / 100)",
      "Convert MB to Megabits (multiply by 8)",
      "Transfer time = data size / effective throughput",
      "Return as a tuple of two values"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Protocol Stack Builder",
    "difficulty": 3,
    "description": "Build a protocol stack representation. Given a list of protocols at different layers, return a formatted string showing the stack from top to bottom.",
    "starterCode": "# Build a visual protocol stack\ndef build_stack(protocols):\n    # protocols is a dict like {7: \"HTTP\", 4: \"TCP\", 3: \"IP\", 2: \"Ethernet\"}\n    # Return a formatted string representation\n    pass\n\n# Test your function\nstack = {7: \"HTTP\", 4: \"TCP\", 3: \"IP\", 2: \"Ethernet\"}\nprint(build_stack(stack))",
    "solution": "def build_stack(protocols):\n    layer_names = {\n        7: \"Application\",\n        6: \"Presentation\",\n        5: \"Session\",\n        4: \"Transport\",\n        3: \"Network\",\n        2: \"Data Link\",\n        1: \"Physical\"\n    }\n    result = []\n    for layer in sorted(protocols.keys(), reverse=True):\n        proto = protocols[layer]\n        name = layer_names.get(layer, \"Unknown\")\n        result.append(f\"Layer {layer} ({name}): {proto}\")\n    return \"\\n\".join(result)\n\nstack = {7: \"HTTP\", 4: \"TCP\", 3: \"IP\", 2: \"Ethernet\"}\nprint(build_stack(stack))",
    "testCases": [
      {
        "input": "{7: \"HTTP\", 4: \"TCP\", 3: \"IP\", 2: \"Ethernet\"}",
        "isHidden": false,
        "description": "Web browsing stack"
      },
      {
        "input": "{7: \"DNS\", 4: \"UDP\", 3: \"IP\", 2: \"WiFi\"}",
        "isHidden": true,
        "description": "DNS query stack"
      }
    ],
    "hints": [
      "Sort the layers in descending order (7 to 1)",
      "Create a layer name mapping for context",
      "Format each layer as \"Layer N (Name): Protocol\"",
      "Join lines with newline characters"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Network Topology Analyzer",
    "difficulty": 3,
    "description": "Given a network topology type (bus, star, ring, mesh), return its characteristics including advantages and disadvantages.",
    "starterCode": "# Analyze network topology characteristics\ndef analyze_topology(topology_type):\n    # Return a dict with: connections_formula, fault_tolerance, cost\n    pass\n\n# Test your function\nprint(analyze_topology(\"star\"))\nprint(analyze_topology(\"mesh\"))",
    "solution": "def analyze_topology(topology_type):\n    topologies = {\n        \"bus\": {\n            \"connections_formula\": \"n-1 (single cable)\",\n            \"fault_tolerance\": \"low\",\n            \"cost\": \"low\"\n        },\n        \"star\": {\n            \"connections_formula\": \"n (each node to hub)\",\n            \"fault_tolerance\": \"medium\",\n            \"cost\": \"medium\"\n        },\n        \"ring\": {\n            \"connections_formula\": \"n (circular)\",\n            \"fault_tolerance\": \"low\",\n            \"cost\": \"medium\"\n        },\n        \"mesh\": {\n            \"connections_formula\": \"n(n-1)/2 (full mesh)\",\n            \"fault_tolerance\": \"high\",\n            \"cost\": \"high\"\n        }\n    }\n    return topologies.get(topology_type.lower(), {})\n\nprint(analyze_topology(\"star\"))\nprint(analyze_topology(\"mesh\"))",
    "testCases": [
      {
        "input": "\"star\"",
        "isHidden": false,
        "description": "Star topology"
      },
      {
        "input": "\"mesh\"",
        "isHidden": false,
        "description": "Mesh topology"
      },
      {
        "input": "\"bus\"",
        "isHidden": true,
        "description": "Bus topology"
      }
    ],
    "hints": [
      "Full mesh has n(n-1)/2 connections",
      "Star topology depends on the central hub",
      "Bus topology has a single point of failure",
      "Mesh has highest redundancy but also highest cost"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Mesh Connection Calculator",
    "difficulty": 3,
    "description": "Calculate the number of connections needed for a full mesh network with n nodes. Also calculate the number of ports needed per node.",
    "starterCode": "# Calculate mesh network connections\ndef mesh_connections(num_nodes):\n    # Return tuple: (total_connections, ports_per_node)\n    pass\n\n# Test your function\nprint(mesh_connections(4))  # 4 nodes\nprint(mesh_connections(10))  # 10 nodes",
    "solution": "def mesh_connections(num_nodes):\n    # Full mesh: each node connects to every other node\n    # Total connections = n(n-1)/2\n    total_connections = num_nodes * (num_nodes - 1) // 2\n    # Each node needs n-1 ports\n    ports_per_node = num_nodes - 1\n    return (total_connections, ports_per_node)\n\nprint(mesh_connections(4))  # 4 nodes\nprint(mesh_connections(10))  # 10 nodes",
    "testCases": [
      {
        "input": "4",
        "isHidden": false,
        "description": "4 nodes"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "10 nodes"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "20 nodes"
      }
    ],
    "hints": [
      "Full mesh formula: n(n-1)/2",
      "Each node connects to every other node",
      "Ports per node = n-1",
      "Use integer division (//) for whole numbers"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Packet Loss Simulator",
    "difficulty": 4,
    "description": "Simulate packet transmission with a given loss probability. Given a number of packets and loss rate (0-1), return how many packets arrived successfully.",
    "starterCode": "import random\n\n# Simulate packet transmission with loss\ndef simulate_transmission(num_packets, loss_rate, seed=42):\n    random.seed(seed)\n    # Your code here\n    pass\n\n# Test your function\nprint(simulate_transmission(100, 0.1))  # 10% loss rate",
    "solution": "import random\n\ndef simulate_transmission(num_packets, loss_rate, seed=42):\n    random.seed(seed)\n    successful = 0\n    for _ in range(num_packets):\n        if random.random() >= loss_rate:\n            successful += 1\n    return successful\n\nprint(simulate_transmission(100, 0.1))  # 10% loss rate",
    "testCases": [
      {
        "input": "100, 0.1, 42",
        "isHidden": false,
        "description": "100 packets, 10% loss"
      },
      {
        "input": "1000, 0.05, 42",
        "isHidden": true,
        "description": "1000 packets, 5% loss"
      }
    ],
    "hints": [
      "Use random.random() to get a value between 0 and 1",
      "If random value >= loss_rate, packet is successful",
      "Count and return the number of successful packets",
      "The seed ensures reproducible results"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "RTT Calculator",
    "difficulty": 3,
    "description": "Calculate Round-Trip Time (RTT) given the distance between two points and the signal propagation speed. Distance in km, speed as fraction of light speed.",
    "starterCode": "# Calculate RTT in milliseconds\ndef calculate_rtt(distance_km, speed_fraction=0.7):\n    # Speed of light = 300,000 km/s\n    # Your code here\n    pass\n\n# Test your function\nprint(calculate_rtt(1000))  # 1000 km\nprint(calculate_rtt(5000, 0.6))  # 5000 km, 60% light speed",
    "solution": "def calculate_rtt(distance_km, speed_fraction=0.7):\n    # Speed of light = 300,000 km/s\n    speed_of_light = 300000  # km/s\n    actual_speed = speed_of_light * speed_fraction\n    # One-way time in seconds\n    one_way_time = distance_km / actual_speed\n    # RTT is round trip (2x one way)\n    rtt_seconds = 2 * one_way_time\n    # Convert to milliseconds\n    rtt_ms = rtt_seconds * 1000\n    return rtt_ms\n\nprint(calculate_rtt(1000))  # 1000 km\nprint(calculate_rtt(5000, 0.6))  # 5000 km, 60% light speed",
    "testCases": [
      {
        "input": "1000",
        "isHidden": false,
        "description": "1000 km at default speed"
      },
      {
        "input": "5000, 0.6",
        "isHidden": false,
        "description": "5000 km at 60% light speed"
      },
      {
        "input": "20000, 0.7",
        "isHidden": true,
        "description": "Intercontinental distance"
      }
    ],
    "hints": [
      "Speed of light is approximately 300,000 km/s",
      "Actual speed = light speed * speed_fraction",
      "RTT = 2 * (distance / speed)",
      "Convert seconds to milliseconds (multiply by 1000)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Multiplexing Bandwidth Calculator",
    "difficulty": 4,
    "description": "Calculate how many channels can fit in a given bandwidth using frequency division multiplexing (FDM). Consider guard bands between channels.",
    "starterCode": "# Calculate number of FDM channels\ndef fdm_channels(total_bandwidth, channel_width, guard_band):\n    # All values in kHz\n    # Your code here\n    pass\n\n# Test your function\nprint(fdm_channels(1000, 100, 10))  # 1000 kHz total, 100 kHz channels, 10 kHz guard",
    "solution": "def fdm_channels(total_bandwidth, channel_width, guard_band):\n    # Each channel needs its width plus a guard band\n    # (except the last channel which doesn't need trailing guard)\n    # channels * channel_width + (channels - 1) * guard_band <= total\n    # Solving: channels <= (total + guard) / (channel + guard)\n    effective_channel = channel_width + guard_band\n    num_channels = (total_bandwidth + guard_band) // effective_channel\n    return int(num_channels)\n\nprint(fdm_channels(1000, 100, 10))  # 1000 kHz total, 100 kHz channels, 10 kHz guard",
    "testCases": [
      {
        "input": "1000, 100, 10",
        "isHidden": false,
        "description": "Basic FDM calculation"
      },
      {
        "input": "5000, 200, 25",
        "isHidden": true,
        "description": "Larger bandwidth"
      }
    ],
    "hints": [
      "Each channel needs space for itself plus a guard band",
      "The last channel doesn't need a trailing guard band",
      "Formula: channels = (total + guard) / (channel + guard)",
      "Use integer division for whole channels"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Network Standards Lookup",
    "difficulty": 2,
    "description": "Create a function that looks up IEEE network standards and returns their details. Support 802.3 (Ethernet), 802.11 (WiFi), 802.15 (Bluetooth).",
    "starterCode": "# Look up IEEE network standards\ndef lookup_standard(standard):\n    # Return dict with: name, max_speed, typical_use\n    pass\n\n# Test your function\nprint(lookup_standard(\"802.3\"))\nprint(lookup_standard(\"802.11\"))",
    "solution": "def lookup_standard(standard):\n    standards = {\n        \"802.3\": {\n            \"name\": \"Ethernet\",\n            \"max_speed\": \"100 Gbps\",\n            \"typical_use\": \"Wired LAN\"\n        },\n        \"802.11\": {\n            \"name\": \"WiFi\",\n            \"max_speed\": \"9.6 Gbps (WiFi 6)\",\n            \"typical_use\": \"Wireless LAN\"\n        },\n        \"802.15\": {\n            \"name\": \"Bluetooth/WPAN\",\n            \"max_speed\": \"2 Mbps\",\n            \"typical_use\": \"Personal Area Network\"\n        },\n        \"802.1Q\": {\n            \"name\": \"VLAN Tagging\",\n            \"max_speed\": \"N/A\",\n            \"typical_use\": \"Network Segmentation\"\n        }\n    }\n    return standards.get(standard, {\"error\": \"Standard not found\"})\n\nprint(lookup_standard(\"802.3\"))\nprint(lookup_standard(\"802.11\"))",
    "testCases": [
      {
        "input": "\"802.3\"",
        "isHidden": false,
        "description": "Ethernet standard"
      },
      {
        "input": "\"802.11\"",
        "isHidden": false,
        "description": "WiFi standard"
      },
      {
        "input": "\"802.15\"",
        "isHidden": true,
        "description": "Bluetooth standard"
      }
    ],
    "hints": [
      "IEEE 802.3 is the Ethernet standard",
      "IEEE 802.11 covers WiFi standards",
      "IEEE 802.15 covers Bluetooth and WPANs",
      "Return a dictionary with the standard details"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t1-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-1",
    "title": "Decapsulation Parser",
    "difficulty": 4,
    "description": "Parse a simulated network frame and extract data at each layer. Given a frame string with delimiters, extract the application data.",
    "starterCode": "# Parse a simulated frame and extract layer data\ndef decapsulate(frame, delimiters):\n    # delimiters dict: {\"frame\": (\"F[\", \"]F\"), \"packet\": (\"P[\", \"]P\"), etc.}\n    # Return dict with data at each layer\n    pass\n\n# Test with simulated frame\nframe = \"F[P[S[DATA]S]P]F\"\ndelims = {\n    \"frame\": (\"F[\", \"]F\"),\n    \"packet\": (\"P[\", \"]P\"),\n    \"segment\": (\"S[\", \"]S\")\n}\nprint(decapsulate(frame, delims))",
    "solution": "def decapsulate(frame, delimiters):\n    result = {\"original\": frame}\n    current = frame\n    \n    # Process each layer from outside in\n    for layer, (start, end) in delimiters.items():\n        if current.startswith(start) and current.endswith(end):\n            # Remove the delimiters\n            current = current[len(start):-len(end)]\n            result[layer] = current\n    \n    result[\"data\"] = current\n    return result\n\nframe = \"F[P[S[DATA]S]P]F\"\ndelims = {\n    \"frame\": (\"F[\", \"]F\"),\n    \"packet\": (\"P[\", \"]P\"),\n    \"segment\": (\"S[\", \"]S\")\n}\nprint(decapsulate(frame, delims))",
    "testCases": [
      {
        "input": "\"F[P[S[DATA]S]P]F\", {...}",
        "isHidden": false,
        "description": "Basic decapsulation"
      },
      {
        "input": "\"F[P[S[Hello World]S]P]F\", {...}",
        "isHidden": true,
        "description": "With text data"
      }
    ],
    "hints": [
      "Process layers from outside to inside",
      "Use string slicing to remove delimiters",
      "Check if current string starts/ends with delimiters",
      "Store the result at each layer"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "MAC Address Validator",
    "difficulty": 1,
    "description": "Write a function that validates if a string is a valid MAC address. Valid formats: XX:XX:XX:XX:XX:XX or XX-XX-XX-XX-XX-XX where X is a hex digit.",
    "starterCode": "import re\n\n# Validate MAC address format\ndef is_valid_mac(mac_address):\n    # Your code here\n    pass\n\n# Test your function\nprint(is_valid_mac(\"00:1A:2B:3C:4D:5E\"))\nprint(is_valid_mac(\"00-1A-2B-3C-4D-5E\"))\nprint(is_valid_mac(\"invalid\"))",
    "solution": "import re\n\ndef is_valid_mac(mac_address):\n    # Pattern for MAC address with : or - separator\n    pattern = r\"^([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}$\"\n    return bool(re.match(pattern, mac_address))\n\nprint(is_valid_mac(\"00:1A:2B:3C:4D:5E\"))\nprint(is_valid_mac(\"00-1A-2B-3C-4D-5E\"))\nprint(is_valid_mac(\"invalid\"))",
    "testCases": [
      {
        "input": "\"00:1A:2B:3C:4D:5E\"",
        "isHidden": false,
        "description": "Valid MAC with colons"
      },
      {
        "input": "\"00-1A-2B-3C-4D-5E\"",
        "isHidden": false,
        "description": "Valid MAC with dashes"
      },
      {
        "input": "\"invalid\"",
        "isHidden": true,
        "description": "Invalid format"
      }
    ],
    "hints": [
      "Use a regular expression for validation",
      "MAC addresses have 6 groups of 2 hex digits",
      "Accept both : and - as separators",
      "Hex digits are 0-9 and A-F (case insensitive)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "MAC Address Normalizer",
    "difficulty": 2,
    "description": "Write a function that normalizes a MAC address to uppercase with colons. Handle input with dashes or no separators.",
    "starterCode": "# Normalize MAC address to XX:XX:XX:XX:XX:XX format\ndef normalize_mac(mac_address):\n    # Your code here\n    pass\n\n# Test your function\nprint(normalize_mac(\"00-1a-2b-3c-4d-5e\"))\nprint(normalize_mac(\"001a2b3c4d5e\"))",
    "solution": "def normalize_mac(mac_address):\n    # Remove any existing separators\n    clean = mac_address.replace(\":\", \"\").replace(\"-\", \"\").upper()\n    # Split into pairs and join with colons\n    pairs = [clean[i:i+2] for i in range(0, 12, 2)]\n    return \":\".join(pairs)\n\nprint(normalize_mac(\"00-1a-2b-3c-4d-5e\"))\nprint(normalize_mac(\"001a2b3c4d5e\"))",
    "testCases": [
      {
        "input": "\"00-1a-2b-3c-4d-5e\"",
        "isHidden": false,
        "description": "MAC with dashes"
      },
      {
        "input": "\"001a2b3c4d5e\"",
        "isHidden": false,
        "description": "MAC without separators"
      },
      {
        "input": "\"FF:ff:FF:ff:FF:ff\"",
        "isHidden": true,
        "description": "Mixed case MAC"
      }
    ],
    "hints": [
      "First remove all existing separators",
      "Convert to uppercase",
      "Split into pairs of 2 characters",
      "Join with colons"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "OUI Lookup",
    "difficulty": 2,
    "description": "The first 3 bytes of a MAC address are the OUI (Organizationally Unique Identifier). Write a function to extract the OUI and look up the vendor.",
    "starterCode": "# Extract OUI and lookup vendor\ndef lookup_oui(mac_address):\n    # Known OUI database (simplified)\n    oui_db = {\n        \"00:1A:2B\": \"Vendor A\",\n        \"00:50:56\": \"VMware\",\n        \"00:0C:29\": \"VMware\",\n        \"AC:DE:48\": \"Vendor B\"\n    }\n    # Your code here\n    pass\n\n# Test your function\nprint(lookup_oui(\"00:50:56:12:34:56\"))",
    "solution": "def lookup_oui(mac_address):\n    oui_db = {\n        \"00:1A:2B\": \"Vendor A\",\n        \"00:50:56\": \"VMware\",\n        \"00:0C:29\": \"VMware\",\n        \"AC:DE:48\": \"Vendor B\"\n    }\n    # Normalize and extract OUI\n    clean = mac_address.replace(\"-\", \":\").upper()\n    oui = clean[:8]  # First 3 bytes (XX:XX:XX)\n    return oui_db.get(oui, \"Unknown Vendor\")\n\nprint(lookup_oui(\"00:50:56:12:34:56\"))",
    "testCases": [
      {
        "input": "\"00:50:56:12:34:56\"",
        "isHidden": false,
        "description": "VMware MAC"
      },
      {
        "input": "\"00-0C-29-AB-CD-EF\"",
        "isHidden": false,
        "description": "VMware with dashes"
      },
      {
        "input": "\"FF:FF:FF:FF:FF:FF\"",
        "isHidden": true,
        "description": "Unknown vendor"
      }
    ],
    "hints": [
      "Extract the first 3 bytes (8 characters including colons)",
      "Normalize the format before lookup",
      "Use dictionary.get() with a default value",
      "Handle both : and - separators"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Parity Bit Calculator",
    "difficulty": 2,
    "description": "Implement even parity checking. Write functions to add a parity bit to data and to verify data with its parity bit.",
    "starterCode": "# Calculate and verify even parity\ndef add_parity(data_bits):\n    # data_bits is a string of 0s and 1s\n    # Return data with parity bit appended\n    pass\n\ndef verify_parity(data_with_parity):\n    # Return True if parity is correct\n    pass\n\n# Test your functions\nprint(add_parity(\"1010101\"))\nprint(verify_parity(\"10101011\"))",
    "solution": "def add_parity(data_bits):\n    ones = data_bits.count(\"1\")\n    parity_bit = \"0\" if ones % 2 == 0 else \"1\"\n    return data_bits + parity_bit\n\ndef verify_parity(data_with_parity):\n    ones = data_with_parity.count(\"1\")\n    return ones % 2 == 0\n\nprint(add_parity(\"1010101\"))\nprint(verify_parity(\"10101011\"))",
    "testCases": [
      {
        "input": "add: \"1010101\"",
        "isHidden": false,
        "description": "Add parity to odd count"
      },
      {
        "input": "verify: \"10101010\"",
        "isHidden": false,
        "description": "Verify even parity"
      },
      {
        "input": "verify: \"10101011\"",
        "isHidden": true,
        "description": "Verify with error"
      }
    ],
    "hints": [
      "Count the number of 1s in the data",
      "Even parity: total 1s (including parity bit) should be even",
      "If odd number of 1s, parity bit is 1",
      "Verification checks if total 1s is even"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "CRC Calculator (Simple)",
    "difficulty": 4,
    "description": "Implement a simple CRC (Cyclic Redundancy Check) calculator. Given data bits and a divisor polynomial, calculate the CRC remainder.",
    "starterCode": "# Calculate CRC remainder using XOR division\ndef calculate_crc(data, divisor):\n    # data and divisor are strings of bits\n    # Return the CRC remainder\n    pass\n\n# Test your function\nprint(calculate_crc(\"1101011011\", \"10011\"))",
    "solution": "def calculate_crc(data, divisor):\n    # Append zeros to data (divisor length - 1)\n    data_padded = data + \"0\" * (len(divisor) - 1)\n    data_list = list(data_padded)\n    \n    for i in range(len(data)):\n        if data_list[i] == \"1\":\n            for j in range(len(divisor)):\n                data_list[i + j] = str(int(data_list[i + j]) ^ int(divisor[j]))\n    \n    # Remainder is the last (divisor_length - 1) bits\n    remainder = \"\".join(data_list[-(len(divisor)-1):])\n    return remainder\n\nprint(calculate_crc(\"1101011011\", \"10011\"))",
    "testCases": [
      {
        "input": "\"1101011011\", \"10011\"",
        "isHidden": false,
        "description": "CRC-4 example"
      },
      {
        "input": "\"11010110\", \"1011\"",
        "isHidden": true,
        "description": "CRC-3 example"
      }
    ],
    "hints": [
      "Append (divisor_length - 1) zeros to the data",
      "Perform XOR division from left to right",
      "Only XOR when current bit is 1",
      "The remainder is the CRC"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Hamming Distance Calculator",
    "difficulty": 2,
    "description": "Calculate the Hamming distance between two binary strings (number of bit positions that differ).",
    "starterCode": "# Calculate Hamming distance between two bit strings\ndef hamming_distance(bits1, bits2):\n    # Your code here\n    pass\n\n# Test your function\nprint(hamming_distance(\"1011101\", \"1001001\"))\nprint(hamming_distance(\"00000\", \"11111\"))",
    "solution": "def hamming_distance(bits1, bits2):\n    if len(bits1) != len(bits2):\n        raise ValueError(\"Strings must be same length\")\n    distance = 0\n    for b1, b2 in zip(bits1, bits2):\n        if b1 != b2:\n            distance += 1\n    return distance\n\nprint(hamming_distance(\"1011101\", \"1001001\"))\nprint(hamming_distance(\"00000\", \"11111\"))",
    "testCases": [
      {
        "input": "\"1011101\", \"1001001\"",
        "isHidden": false,
        "description": "Two bit difference"
      },
      {
        "input": "\"00000\", \"11111\"",
        "isHidden": false,
        "description": "All different"
      },
      {
        "input": "\"1010\", \"1010\"",
        "isHidden": true,
        "description": "Identical strings"
      }
    ],
    "hints": [
      "Compare corresponding bits in both strings",
      "Count positions where bits differ",
      "Use zip() to pair up characters",
      "Strings must be the same length"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Frame Builder",
    "difficulty": 3,
    "description": "Build an Ethernet frame structure. Given source MAC, destination MAC, and payload, create a frame with proper fields (simplified, no actual checksum).",
    "starterCode": "# Build a simplified Ethernet frame\ndef build_frame(src_mac, dst_mac, payload, ethertype=\"0800\"):\n    # Return a dict representing the frame structure\n    pass\n\n# Test your function\nframe = build_frame(\"AA:BB:CC:DD:EE:FF\", \"11:22:33:44:55:66\", \"Hello\")\nprint(frame)",
    "solution": "def build_frame(src_mac, dst_mac, payload, ethertype=\"0800\"):\n    # Calculate padding if needed (minimum payload is 46 bytes)\n    payload_bytes = payload.encode() if isinstance(payload, str) else payload\n    padding_needed = max(0, 46 - len(payload_bytes))\n    \n    frame = {\n        \"preamble\": \"10101010\" * 7,\n        \"sfd\": \"10101011\",\n        \"destination_mac\": dst_mac,\n        \"source_mac\": src_mac,\n        \"ethertype\": ethertype,\n        \"payload\": payload,\n        \"padding\": \"00\" * padding_needed,\n        \"fcs\": \"00000000\"  # Placeholder for checksum\n    }\n    return frame\n\nframe = build_frame(\"AA:BB:CC:DD:EE:FF\", \"11:22:33:44:55:66\", \"Hello\")\nprint(frame)",
    "testCases": [
      {
        "input": "\"AA:BB:CC:DD:EE:FF\", \"11:22:33:44:55:66\", \"Hello\"",
        "isHidden": false,
        "description": "Basic frame"
      },
      {
        "input": "\"00:00:00:00:00:01\", \"FF:FF:FF:FF:FF:FF\", \"Data\"",
        "isHidden": true,
        "description": "Broadcast frame"
      }
    ],
    "hints": [
      "Preamble is 7 bytes of 10101010",
      "SFD (Start Frame Delimiter) is 10101011",
      "Minimum payload is 46 bytes, add padding if needed",
      "FCS would normally be a CRC-32 checksum"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "CSMA/CD Simulator",
    "difficulty": 4,
    "description": "Simulate the CSMA/CD (Carrier Sense Multiple Access with Collision Detection) algorithm. Track collision attempts and backoff times.",
    "starterCode": "import random\n\n# Simulate CSMA/CD transmission attempt\ndef csmacd_transmit(max_attempts=16, seed=42):\n    random.seed(seed)\n    # Simulate transmission with collision probability\n    # Return dict with: success, attempts, total_backoff\n    pass\n\n# Test your function\nresult = csmacd_transmit()\nprint(result)",
    "solution": "import random\n\ndef csmacd_transmit(max_attempts=16, seed=42):\n    random.seed(seed)\n    attempts = 0\n    total_backoff = 0\n    collision_prob = 0.3  # Simulated collision probability\n    \n    while attempts < max_attempts:\n        attempts += 1\n        # Check if collision occurs\n        if random.random() > collision_prob:\n            return {\n                \"success\": True,\n                \"attempts\": attempts,\n                \"total_backoff\": total_backoff\n            }\n        # Collision occurred - exponential backoff\n        k = min(attempts, 10)\n        backoff = random.randint(0, 2**k - 1)\n        total_backoff += backoff\n    \n    return {\n        \"success\": False,\n        \"attempts\": attempts,\n        \"total_backoff\": total_backoff\n    }\n\nresult = csmacd_transmit()\nprint(result)",
    "testCases": [
      {
        "input": "max_attempts=16, seed=42",
        "isHidden": false,
        "description": "Default parameters"
      },
      {
        "input": "max_attempts=5, seed=123",
        "isHidden": true,
        "description": "Limited attempts"
      }
    ],
    "hints": [
      "CSMA/CD uses binary exponential backoff",
      "Backoff slot = random(0, 2^k - 1) where k = min(attempt, 10)",
      "Maximum 16 attempts before giving up",
      "Track attempts and total backoff time"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "ARP Table Manager",
    "difficulty": 3,
    "description": "Implement a simple ARP (Address Resolution Protocol) table. Support adding entries, looking up MAC addresses by IP, and expiring old entries.",
    "starterCode": "import time\n\nclass ARPTable:\n    def __init__(self, ttl=300):\n        self.table = {}  # IP -> (MAC, timestamp)\n        self.ttl = ttl\n    \n    def add_entry(self, ip, mac):\n        # Your code here\n        pass\n    \n    def lookup(self, ip):\n        # Your code here - return MAC or None\n        pass\n    \n    def cleanup(self):\n        # Remove expired entries\n        pass\n\n# Test your class\narp = ARPTable(ttl=5)\narp.add_entry(\"192.168.1.1\", \"AA:BB:CC:DD:EE:FF\")\nprint(arp.lookup(\"192.168.1.1\"))",
    "solution": "import time\n\nclass ARPTable:\n    def __init__(self, ttl=300):\n        self.table = {}\n        self.ttl = ttl\n    \n    def add_entry(self, ip, mac):\n        self.table[ip] = (mac, time.time())\n    \n    def lookup(self, ip):\n        if ip in self.table:\n            mac, timestamp = self.table[ip]\n            if time.time() - timestamp < self.ttl:\n                return mac\n            else:\n                del self.table[ip]\n        return None\n    \n    def cleanup(self):\n        current_time = time.time()\n        expired = [ip for ip, (_, ts) in self.table.items() \n                   if current_time - ts >= self.ttl]\n        for ip in expired:\n            del self.table[ip]\n\narp = ARPTable(ttl=5)\narp.add_entry(\"192.168.1.1\", \"AA:BB:CC:DD:EE:FF\")\nprint(arp.lookup(\"192.168.1.1\"))",
    "testCases": [
      {
        "input": "add and lookup",
        "isHidden": false,
        "description": "Basic operations"
      },
      {
        "input": "expiry test",
        "isHidden": true,
        "description": "TTL expiration"
      }
    ],
    "hints": [
      "Store entries with their creation timestamp",
      "Check TTL on lookup and return None if expired",
      "Use time.time() for current timestamp",
      "Cleanup should remove all expired entries"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "VLAN Tag Parser",
    "difficulty": 3,
    "description": "Parse an 802.1Q VLAN tag from frame bytes. Extract and return the VLAN ID (12 bits), priority (3 bits), and DEI flag (1 bit).",
    "starterCode": "# Parse 802.1Q VLAN tag (4 bytes total)\ndef parse_vlan_tag(tag_bytes):\n    # tag_bytes is a 4-byte hex string like \"81000064\"\n    # Return dict with: vlan_id, priority, dei\n    pass\n\n# Test your function\nprint(parse_vlan_tag(\"81000064\"))  # VLAN 100\nprint(parse_vlan_tag(\"8100A001\"))  # Priority 5, VLAN 1",
    "solution": "def parse_vlan_tag(tag_bytes):\n    # Convert hex string to integer\n    tag_int = int(tag_bytes, 16)\n    \n    # TPID is first 2 bytes (should be 0x8100)\n    tpid = (tag_int >> 16) & 0xFFFF\n    \n    # TCI is last 2 bytes\n    tci = tag_int & 0xFFFF\n    \n    # Priority: bits 15-13 (3 bits)\n    priority = (tci >> 13) & 0x7\n    \n    # DEI: bit 12 (1 bit)\n    dei = (tci >> 12) & 0x1\n    \n    # VLAN ID: bits 11-0 (12 bits)\n    vlan_id = tci & 0xFFF\n    \n    return {\n        \"tpid\": hex(tpid),\n        \"priority\": priority,\n        \"dei\": dei,\n        \"vlan_id\": vlan_id\n    }\n\nprint(parse_vlan_tag(\"81000064\"))  # VLAN 100\nprint(parse_vlan_tag(\"8100A001\"))  # Priority 5, VLAN 1",
    "testCases": [
      {
        "input": "\"81000064\"",
        "isHidden": false,
        "description": "VLAN 100"
      },
      {
        "input": "\"8100A001\"",
        "isHidden": false,
        "description": "Priority 5, VLAN 1"
      },
      {
        "input": "\"81002000\"",
        "isHidden": true,
        "description": "DEI set"
      }
    ],
    "hints": [
      "802.1Q tag: TPID (16 bits) + TCI (16 bits)",
      "TPID is 0x8100 for VLAN tagging",
      "TCI = Priority (3) + DEI (1) + VLAN ID (12)",
      "Use bitwise operations to extract fields"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Byte Stuffing Encoder",
    "difficulty": 3,
    "description": "Implement byte stuffing for frame delimiting. Use FLAG=0x7E and ESCAPE=0x7D. Escape any FLAG or ESCAPE in data by XORing with 0x20.",
    "starterCode": "# Implement byte stuffing\ndef byte_stuff(data):\n    # data is a list of byte values\n    # Return stuffed data with FLAG at start and end\n    FLAG = 0x7E\n    ESCAPE = 0x7D\n    pass\n\n# Test your function\nprint(byte_stuff([0x01, 0x7E, 0x02, 0x7D, 0x03]))",
    "solution": "def byte_stuff(data):\n    FLAG = 0x7E\n    ESCAPE = 0x7D\n    result = [FLAG]  # Start flag\n    \n    for byte in data:\n        if byte == FLAG or byte == ESCAPE:\n            result.append(ESCAPE)\n            result.append(byte ^ 0x20)\n        else:\n            result.append(byte)\n    \n    result.append(FLAG)  # End flag\n    return result\n\nprint(byte_stuff([0x01, 0x7E, 0x02, 0x7D, 0x03]))",
    "testCases": [
      {
        "input": "[0x01, 0x7E, 0x02, 0x7D, 0x03]",
        "isHidden": false,
        "description": "Data with special bytes"
      },
      {
        "input": "[0x01, 0x02, 0x03]",
        "isHidden": false,
        "description": "Normal data"
      },
      {
        "input": "[0x7E, 0x7E]",
        "isHidden": true,
        "description": "Consecutive flags"
      }
    ],
    "hints": [
      "Add FLAG byte at start and end",
      "If data contains FLAG or ESCAPE, insert ESCAPE",
      "XOR the escaped byte with 0x20",
      "0x7E XOR 0x20 = 0x5E, 0x7D XOR 0x20 = 0x5D"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Sliding Window Protocol",
    "difficulty": 4,
    "description": "Implement a simple sliding window sender. Track sent but unacknowledged frames within the window size.",
    "starterCode": "class SlidingWindow:\n    def __init__(self, window_size):\n        self.window_size = window_size\n        self.base = 0  # Oldest unacked sequence number\n        self.next_seq = 0  # Next sequence to send\n        self.sent = {}  # seq -> data\n    \n    def can_send(self):\n        # Return True if window has space\n        pass\n    \n    def send(self, data):\n        # Send data if possible, return sequence number or -1\n        pass\n    \n    def ack(self, seq_num):\n        # Acknowledge up to seq_num (cumulative)\n        pass\n\n# Test your class\nsw = SlidingWindow(4)\nprint(sw.send(\"Frame1\"))\nprint(sw.send(\"Frame2\"))\nsw.ack(1)\nprint(sw.can_send())",
    "solution": "class SlidingWindow:\n    def __init__(self, window_size):\n        self.window_size = window_size\n        self.base = 0\n        self.next_seq = 0\n        self.sent = {}\n    \n    def can_send(self):\n        return self.next_seq < self.base + self.window_size\n    \n    def send(self, data):\n        if not self.can_send():\n            return -1\n        seq = self.next_seq\n        self.sent[seq] = data\n        self.next_seq += 1\n        return seq\n    \n    def ack(self, seq_num):\n        # Cumulative ACK - acknowledge all up to seq_num\n        while self.base <= seq_num and self.base in self.sent:\n            del self.sent[self.base]\n            self.base += 1\n\nsw = SlidingWindow(4)\nprint(sw.send(\"Frame1\"))\nprint(sw.send(\"Frame2\"))\nsw.ack(1)\nprint(sw.can_send())",
    "testCases": [
      {
        "input": "window_size=4",
        "isHidden": false,
        "description": "Window of 4"
      },
      {
        "input": "fill window and ack",
        "isHidden": true,
        "description": "Full window cycle"
      }
    ],
    "hints": [
      "Window spans from base to base + window_size - 1",
      "Can send if next_seq < base + window_size",
      "Cumulative ACK: acknowledge all frames up to seq_num",
      "Remove acknowledged frames and advance base"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Checksum Calculator",
    "difficulty": 3,
    "description": "Calculate a simple Internet checksum. Sum 16-bit words, add carry, and take ones complement.",
    "starterCode": "# Calculate Internet checksum\ndef calculate_checksum(data):\n    # data is a list of bytes\n    # Return 16-bit checksum as hex string\n    pass\n\n# Test your function\nprint(calculate_checksum([0x00, 0x01, 0x00, 0x02, 0x00, 0x03]))",
    "solution": "def calculate_checksum(data):\n    # Pad with zero if odd number of bytes\n    if len(data) % 2 == 1:\n        data = data + [0]\n    \n    # Sum 16-bit words\n    total = 0\n    for i in range(0, len(data), 2):\n        word = (data[i] << 8) + data[i + 1]\n        total += word\n    \n    # Add carry bits\n    while total > 0xFFFF:\n        total = (total & 0xFFFF) + (total >> 16)\n    \n    # Ones complement\n    checksum = ~total & 0xFFFF\n    return hex(checksum)\n\nprint(calculate_checksum([0x00, 0x01, 0x00, 0x02, 0x00, 0x03]))",
    "testCases": [
      {
        "input": "[0x00, 0x01, 0x00, 0x02, 0x00, 0x03]",
        "isHidden": false,
        "description": "Simple data"
      },
      {
        "input": "[0xFF, 0xFF, 0xFF, 0xFF]",
        "isHidden": true,
        "description": "Max values"
      }
    ],
    "hints": [
      "Group bytes into 16-bit words",
      "Sum all words together",
      "Wrap around: add carry to lower 16 bits",
      "Final result is ones complement (~sum)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "MAC Learning Switch",
    "difficulty": 4,
    "description": "Implement a basic MAC learning switch. Learn source MACs from incoming frames, and forward or flood based on destination.",
    "starterCode": "class MACSwitch:\n    def __init__(self, num_ports):\n        self.num_ports = num_ports\n        self.mac_table = {}  # MAC -> port\n    \n    def process_frame(self, src_mac, dst_mac, in_port):\n        # Learn source MAC\n        # Return list of ports to forward to\n        pass\n\n# Test your class\nswitch = MACSwitch(4)\nprint(switch.process_frame(\"AA:AA:AA:AA:AA:AA\", \"BB:BB:BB:BB:BB:BB\", 1))\nprint(switch.process_frame(\"BB:BB:BB:BB:BB:BB\", \"AA:AA:AA:AA:AA:AA\", 2))",
    "solution": "class MACSwitch:\n    def __init__(self, num_ports):\n        self.num_ports = num_ports\n        self.mac_table = {}\n    \n    def process_frame(self, src_mac, dst_mac, in_port):\n        # Learn source MAC\n        self.mac_table[src_mac] = in_port\n        \n        # Check if destination is known\n        if dst_mac in self.mac_table:\n            out_port = self.mac_table[dst_mac]\n            if out_port != in_port:\n                return [out_port]\n            else:\n                return []  # Don't send back on same port\n        else:\n            # Flood to all ports except incoming\n            return [p for p in range(1, self.num_ports + 1) if p != in_port]\n\nswitch = MACSwitch(4)\nprint(switch.process_frame(\"AA:AA:AA:AA:AA:AA\", \"BB:BB:BB:BB:BB:BB\", 1))\nprint(switch.process_frame(\"BB:BB:BB:BB:BB:BB\", \"AA:AA:AA:AA:AA:AA\", 2))",
    "testCases": [
      {
        "input": "unknown dst",
        "isHidden": false,
        "description": "Flood on unknown"
      },
      {
        "input": "known dst",
        "isHidden": false,
        "description": "Forward to known"
      },
      {
        "input": "same port",
        "isHidden": true,
        "description": "No forward to same port"
      }
    ],
    "hints": [
      "Always learn the source MAC and port",
      "If destination is unknown, flood to all ports except incoming",
      "If destination is known, forward only to that port",
      "Never send a frame back out the port it came in on"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Bit Error Detector",
    "difficulty": 3,
    "description": "Detect single-bit errors using 2D parity. Given a matrix of bits with row and column parity, identify the error position.",
    "starterCode": "# Detect single bit error position using 2D parity\ndef detect_error(matrix):\n    # matrix is list of lists, last row/col are parity bits\n    # Return (row, col) of error or None if no error\n    pass\n\n# Test - error at position (1, 2)\nmatrix = [\n    [1, 0, 1, 0],  # data + row parity\n    [1, 1, 0, 0],  # data + row parity (error: should be 1)\n    [0, 1, 1, 0],  # column parities\n]\nprint(detect_error(matrix))",
    "solution": "def detect_error(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    error_row = -1\n    error_col = -1\n    \n    # Check row parities\n    for r in range(rows - 1):\n        if sum(matrix[r]) % 2 != 0:\n            error_row = r\n    \n    # Check column parities\n    for c in range(cols - 1):\n        col_sum = sum(matrix[r][c] for r in range(rows))\n        if col_sum % 2 != 0:\n            error_col = c\n    \n    if error_row >= 0 and error_col >= 0:\n        return (error_row, error_col)\n    return None\n\nmatrix = [\n    [1, 0, 1, 0],\n    [1, 1, 0, 0],\n    [0, 1, 1, 0],\n]\nprint(detect_error(matrix))",
    "testCases": [
      {
        "input": "matrix with error",
        "isHidden": false,
        "description": "Detect error position"
      },
      {
        "input": "clean matrix",
        "isHidden": true,
        "description": "No error present"
      }
    ],
    "hints": [
      "Check each row parity (sum should be even)",
      "Check each column parity (sum should be even)",
      "Error is at intersection of bad row and column",
      "Return None if no error detected"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t2-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-2",
    "title": "Spanning Tree Protocol",
    "difficulty": 5,
    "description": "Simulate basic STP (Spanning Tree Protocol) root bridge election. Given bridge IDs and priorities, determine the root bridge.",
    "starterCode": "class Bridge:\n    def __init__(self, bridge_id, priority=32768):\n        self.bridge_id = bridge_id\n        self.priority = priority\n        self.is_root = False\n    \n    def get_bridge_priority(self):\n        # Combined priority (priority + bridge_id)\n        pass\n\ndef elect_root(bridges):\n    # Return the bridge that should be root\n    pass\n\n# Test\nbridges = [\n    Bridge(\"00:00:00:00:00:01\", 32768),\n    Bridge(\"00:00:00:00:00:02\", 16384),\n    Bridge(\"00:00:00:00:00:03\", 32768)\n]\nroot = elect_root(bridges)\nprint(f\"Root bridge: {root.bridge_id}\")",
    "solution": "class Bridge:\n    def __init__(self, bridge_id, priority=32768):\n        self.bridge_id = bridge_id\n        self.priority = priority\n        self.is_root = False\n    \n    def get_bridge_priority(self):\n        # Lower is better\n        # Compare priority first, then bridge_id\n        return (self.priority, self.bridge_id)\n\ndef elect_root(bridges):\n    # Reset all bridges\n    for b in bridges:\n        b.is_root = False\n    \n    # Find bridge with lowest priority\n    root = min(bridges, key=lambda b: b.get_bridge_priority())\n    root.is_root = True\n    return root\n\nbridges = [\n    Bridge(\"00:00:00:00:00:01\", 32768),\n    Bridge(\"00:00:00:00:00:02\", 16384),\n    Bridge(\"00:00:00:00:00:03\", 32768)\n]\nroot = elect_root(bridges)\nprint(f\"Root bridge: {root.bridge_id}\")",
    "testCases": [
      {
        "input": "different priorities",
        "isHidden": false,
        "description": "Priority-based election"
      },
      {
        "input": "same priority",
        "isHidden": true,
        "description": "Bridge ID tiebreaker"
      }
    ],
    "hints": [
      "Lower priority wins in STP",
      "If priorities are equal, lower bridge ID wins",
      "Bridge ID is typically the MAC address",
      "Use tuple comparison (priority, bridge_id)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "IP Address Validator",
    "difficulty": 1,
    "description": "Write a function that validates if a string is a valid IPv4 address. Each octet must be 0-255.",
    "starterCode": "# Validate IPv4 address\ndef is_valid_ipv4(ip):\n    # Your code here\n    pass\n\n# Test your function\nprint(is_valid_ipv4(\"192.168.1.1\"))\nprint(is_valid_ipv4(\"256.1.1.1\"))\nprint(is_valid_ipv4(\"10.0.0\"))",
    "solution": "def is_valid_ipv4(ip):\n    parts = ip.split(\".\")\n    if len(parts) != 4:\n        return False\n    for part in parts:\n        try:\n            num = int(part)\n            if num < 0 or num > 255:\n                return False\n        except ValueError:\n            return False\n    return True\n\nprint(is_valid_ipv4(\"192.168.1.1\"))\nprint(is_valid_ipv4(\"256.1.1.1\"))\nprint(is_valid_ipv4(\"10.0.0\"))",
    "testCases": [
      {
        "input": "\"192.168.1.1\"",
        "isHidden": false,
        "description": "Valid private IP"
      },
      {
        "input": "\"256.1.1.1\"",
        "isHidden": false,
        "description": "Invalid octet value"
      },
      {
        "input": "\"10.0.0\"",
        "isHidden": true,
        "description": "Missing octet"
      }
    ],
    "hints": [
      "Split the IP by dots",
      "Must have exactly 4 parts",
      "Each part must be a number 0-255",
      "Handle non-numeric input"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "IP to Binary Converter",
    "difficulty": 2,
    "description": "Convert an IPv4 address to its 32-bit binary representation.",
    "starterCode": "# Convert IPv4 to binary string\ndef ip_to_binary(ip):\n    # Your code here\n    pass\n\n# Test your function\nprint(ip_to_binary(\"192.168.1.1\"))\nprint(ip_to_binary(\"255.255.255.0\"))",
    "solution": "def ip_to_binary(ip):\n    parts = ip.split(\".\")\n    binary_parts = []\n    for part in parts:\n        binary = bin(int(part))[2:].zfill(8)\n        binary_parts.append(binary)\n    return \".\".join(binary_parts)\n\nprint(ip_to_binary(\"192.168.1.1\"))\nprint(ip_to_binary(\"255.255.255.0\"))",
    "testCases": [
      {
        "input": "\"192.168.1.1\"",
        "isHidden": false,
        "description": "Private IP"
      },
      {
        "input": "\"255.255.255.0\"",
        "isHidden": false,
        "description": "Subnet mask"
      },
      {
        "input": "\"0.0.0.0\"",
        "isHidden": true,
        "description": "All zeros"
      }
    ],
    "hints": [
      "Split IP into octets",
      "Convert each octet to binary using bin()",
      "Pad each binary to 8 bits with zfill(8)",
      "bin() returns \"0b...\" prefix, remove it with [2:]"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "IP Class Identifier",
    "difficulty": 2,
    "description": "Determine the class (A, B, C, D, or E) of an IPv4 address based on its first octet.",
    "starterCode": "# Determine IP address class\ndef get_ip_class(ip):\n    # Your code here\n    pass\n\n# Test your function\nprint(get_ip_class(\"10.0.0.1\"))     # Class A\nprint(get_ip_class(\"172.16.0.1\"))   # Class B\nprint(get_ip_class(\"192.168.1.1\"))  # Class C",
    "solution": "def get_ip_class(ip):\n    first_octet = int(ip.split(\".\")[0])\n    if first_octet < 128:\n        return \"A\"\n    elif first_octet < 192:\n        return \"B\"\n    elif first_octet < 224:\n        return \"C\"\n    elif first_octet < 240:\n        return \"D\"\n    else:\n        return \"E\"\n\nprint(get_ip_class(\"10.0.0.1\"))\nprint(get_ip_class(\"172.16.0.1\"))\nprint(get_ip_class(\"192.168.1.1\"))",
    "testCases": [
      {
        "input": "\"10.0.0.1\"",
        "isHidden": false,
        "description": "Class A"
      },
      {
        "input": "\"172.16.0.1\"",
        "isHidden": false,
        "description": "Class B"
      },
      {
        "input": "\"224.0.0.1\"",
        "isHidden": true,
        "description": "Class D (multicast)"
      }
    ],
    "hints": [
      "Class A: 0-127",
      "Class B: 128-191",
      "Class C: 192-223",
      "Class D: 224-239 (multicast)",
      "Class E: 240-255 (reserved)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Subnet Mask Calculator",
    "difficulty": 2,
    "description": "Convert a CIDR prefix length to a dotted-decimal subnet mask.",
    "starterCode": "# Convert CIDR prefix to subnet mask\ndef cidr_to_mask(prefix_length):\n    # Your code here\n    pass\n\n# Test your function\nprint(cidr_to_mask(24))  # 255.255.255.0\nprint(cidr_to_mask(16))  # 255.255.0.0\nprint(cidr_to_mask(27))  # 255.255.255.224",
    "solution": "def cidr_to_mask(prefix_length):\n    # Create 32-bit mask with prefix_length 1s followed by 0s\n    mask = (0xFFFFFFFF << (32 - prefix_length)) & 0xFFFFFFFF\n    # Convert to dotted decimal\n    octets = [\n        (mask >> 24) & 0xFF,\n        (mask >> 16) & 0xFF,\n        (mask >> 8) & 0xFF,\n        mask & 0xFF\n    ]\n    return \".\".join(str(o) for o in octets)\n\nprint(cidr_to_mask(24))\nprint(cidr_to_mask(16))\nprint(cidr_to_mask(27))",
    "testCases": [
      {
        "input": "24",
        "isHidden": false,
        "description": "/24 network"
      },
      {
        "input": "16",
        "isHidden": false,
        "description": "/16 network"
      },
      {
        "input": "27",
        "isHidden": true,
        "description": "/27 network"
      }
    ],
    "hints": [
      "Create a 32-bit number with prefix_length 1s",
      "Left shift 1s and mask to 32 bits",
      "Extract each octet using bit shifting",
      "/24 = 255.255.255.0 (24 ones, 8 zeros)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Network Address Calculator",
    "difficulty": 3,
    "description": "Calculate the network address from an IP address and subnet mask using bitwise AND.",
    "starterCode": "# Calculate network address\ndef get_network_address(ip, mask):\n    # Your code here\n    pass\n\n# Test your function\nprint(get_network_address(\"192.168.1.100\", \"255.255.255.0\"))\nprint(get_network_address(\"10.45.67.89\", \"255.255.0.0\"))",
    "solution": "def get_network_address(ip, mask):\n    ip_parts = [int(x) for x in ip.split(\".\")]\n    mask_parts = [int(x) for x in mask.split(\".\")]\n    \n    network = []\n    for ip_octet, mask_octet in zip(ip_parts, mask_parts):\n        network.append(ip_octet & mask_octet)\n    \n    return \".\".join(str(o) for o in network)\n\nprint(get_network_address(\"192.168.1.100\", \"255.255.255.0\"))\nprint(get_network_address(\"10.45.67.89\", \"255.255.0.0\"))",
    "testCases": [
      {
        "input": "\"192.168.1.100\", \"255.255.255.0\"",
        "isHidden": false,
        "description": "/24 network"
      },
      {
        "input": "\"10.45.67.89\", \"255.255.0.0\"",
        "isHidden": false,
        "description": "/16 network"
      },
      {
        "input": "\"172.16.50.25\", \"255.255.255.224\"",
        "isHidden": true,
        "description": "/27 network"
      }
    ],
    "hints": [
      "Split both IP and mask into octets",
      "AND each IP octet with corresponding mask octet",
      "This zeros out the host bits",
      "Join the result back with dots"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Broadcast Address Calculator",
    "difficulty": 3,
    "description": "Calculate the broadcast address from an IP address and subnet mask. Broadcast is network address with all host bits set to 1.",
    "starterCode": "# Calculate broadcast address\ndef get_broadcast_address(ip, mask):\n    # Your code here\n    pass\n\n# Test your function\nprint(get_broadcast_address(\"192.168.1.100\", \"255.255.255.0\"))\nprint(get_broadcast_address(\"10.45.67.89\", \"255.255.0.0\"))",
    "solution": "def get_broadcast_address(ip, mask):\n    ip_parts = [int(x) for x in ip.split(\".\")]\n    mask_parts = [int(x) for x in mask.split(\".\")]\n    \n    broadcast = []\n    for ip_octet, mask_octet in zip(ip_parts, mask_parts):\n        # Invert mask and OR with IP\n        inverted_mask = 255 - mask_octet\n        broadcast.append(ip_octet | inverted_mask)\n    \n    return \".\".join(str(o) for o in broadcast)\n\nprint(get_broadcast_address(\"192.168.1.100\", \"255.255.255.0\"))\nprint(get_broadcast_address(\"10.45.67.89\", \"255.255.0.0\"))",
    "testCases": [
      {
        "input": "\"192.168.1.100\", \"255.255.255.0\"",
        "isHidden": false,
        "description": "/24 broadcast"
      },
      {
        "input": "\"10.45.67.89\", \"255.255.0.0\"",
        "isHidden": false,
        "description": "/16 broadcast"
      },
      {
        "input": "\"172.16.50.25\", \"255.255.255.224\"",
        "isHidden": true,
        "description": "/27 broadcast"
      }
    ],
    "hints": [
      "Invert the mask (255 - mask_octet)",
      "OR each IP octet with inverted mask",
      "This sets all host bits to 1",
      "/24: broadcast ends in .255"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Usable Hosts Calculator",
    "difficulty": 2,
    "description": "Calculate the number of usable host addresses in a subnet given the CIDR prefix length.",
    "starterCode": "# Calculate usable hosts in a subnet\ndef usable_hosts(prefix_length):\n    # Your code here\n    pass\n\n# Test your function\nprint(usable_hosts(24))  # 254\nprint(usable_hosts(30))  # 2\nprint(usable_hosts(16))  # 65534",
    "solution": "def usable_hosts(prefix_length):\n    # Total addresses = 2^(32-prefix)\n    # Usable = total - 2 (network and broadcast)\n    host_bits = 32 - prefix_length\n    total = 2 ** host_bits\n    # Minimum is 0 usable hosts for /31 and /32\n    usable = max(0, total - 2)\n    return usable\n\nprint(usable_hosts(24))\nprint(usable_hosts(30))\nprint(usable_hosts(16))",
    "testCases": [
      {
        "input": "24",
        "isHidden": false,
        "description": "/24 has 254 hosts"
      },
      {
        "input": "30",
        "isHidden": false,
        "description": "/30 has 2 hosts"
      },
      {
        "input": "32",
        "isHidden": true,
        "description": "/32 has 0 usable hosts"
      }
    ],
    "hints": [
      "Host bits = 32 - prefix_length",
      "Total addresses = 2^host_bits",
      "Subtract 2 for network and broadcast",
      "/30 is commonly used for point-to-point links"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "CIDR Notation Parser",
    "difficulty": 2,
    "description": "Parse CIDR notation (e.g., \"192.168.1.0/24\") and return the IP and prefix length separately.",
    "starterCode": "# Parse CIDR notation\ndef parse_cidr(cidr):\n    # Return tuple: (ip, prefix_length)\n    pass\n\n# Test your function\nprint(parse_cidr(\"192.168.1.0/24\"))\nprint(parse_cidr(\"10.0.0.0/8\"))",
    "solution": "def parse_cidr(cidr):\n    parts = cidr.split(\"/\")\n    ip = parts[0]\n    prefix_length = int(parts[1])\n    return (ip, prefix_length)\n\nprint(parse_cidr(\"192.168.1.0/24\"))\nprint(parse_cidr(\"10.0.0.0/8\"))",
    "testCases": [
      {
        "input": "\"192.168.1.0/24\"",
        "isHidden": false,
        "description": "Class C sized"
      },
      {
        "input": "\"10.0.0.0/8\"",
        "isHidden": false,
        "description": "Class A sized"
      },
      {
        "input": "\"172.16.128.0/17\"",
        "isHidden": true,
        "description": "Non-classful"
      }
    ],
    "hints": [
      "Split by \"/\" character",
      "First part is the IP address",
      "Second part is the prefix length",
      "Convert prefix to integer"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Same Subnet Checker",
    "difficulty": 3,
    "description": "Determine if two IP addresses are in the same subnet given a common subnet mask.",
    "starterCode": "# Check if two IPs are in the same subnet\ndef same_subnet(ip1, ip2, mask):\n    # Your code here\n    pass\n\n# Test your function\nprint(same_subnet(\"192.168.1.10\", \"192.168.1.200\", \"255.255.255.0\"))\nprint(same_subnet(\"192.168.1.10\", \"192.168.2.10\", \"255.255.255.0\"))",
    "solution": "def same_subnet(ip1, ip2, mask):\n    def get_network(ip, mask):\n        ip_parts = [int(x) for x in ip.split(\".\")]\n        mask_parts = [int(x) for x in mask.split(\".\")]\n        return tuple(i & m for i, m in zip(ip_parts, mask_parts))\n    \n    return get_network(ip1, mask) == get_network(ip2, mask)\n\nprint(same_subnet(\"192.168.1.10\", \"192.168.1.200\", \"255.255.255.0\"))\nprint(same_subnet(\"192.168.1.10\", \"192.168.2.10\", \"255.255.255.0\"))",
    "testCases": [
      {
        "input": "\"192.168.1.10\", \"192.168.1.200\", \"255.255.255.0\"",
        "isHidden": false,
        "description": "Same subnet"
      },
      {
        "input": "\"192.168.1.10\", \"192.168.2.10\", \"255.255.255.0\"",
        "isHidden": false,
        "description": "Different subnets"
      },
      {
        "input": "\"10.1.1.1\", \"10.1.2.1\", \"255.255.0.0\"",
        "isHidden": true,
        "description": "Same /16 subnet"
      }
    ],
    "hints": [
      "Calculate network address for each IP",
      "If network addresses match, same subnet",
      "Use bitwise AND with mask",
      "Compare resulting network addresses"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Private IP Checker",
    "difficulty": 2,
    "description": "Check if an IP address is in a private range (10.x.x.x, 172.16-31.x.x, 192.168.x.x).",
    "starterCode": "# Check if IP is private\ndef is_private_ip(ip):\n    # Your code here\n    pass\n\n# Test your function\nprint(is_private_ip(\"192.168.1.1\"))\nprint(is_private_ip(\"8.8.8.8\"))\nprint(is_private_ip(\"172.20.0.1\"))",
    "solution": "def is_private_ip(ip):\n    parts = [int(x) for x in ip.split(\".\")]\n    \n    # 10.0.0.0 - 10.255.255.255\n    if parts[0] == 10:\n        return True\n    \n    # 172.16.0.0 - 172.31.255.255\n    if parts[0] == 172 and 16 <= parts[1] <= 31:\n        return True\n    \n    # 192.168.0.0 - 192.168.255.255\n    if parts[0] == 192 and parts[1] == 168:\n        return True\n    \n    return False\n\nprint(is_private_ip(\"192.168.1.1\"))\nprint(is_private_ip(\"8.8.8.8\"))\nprint(is_private_ip(\"172.20.0.1\"))",
    "testCases": [
      {
        "input": "\"192.168.1.1\"",
        "isHidden": false,
        "description": "Private 192.168"
      },
      {
        "input": "\"8.8.8.8\"",
        "isHidden": false,
        "description": "Public IP"
      },
      {
        "input": "\"172.32.0.1\"",
        "isHidden": true,
        "description": "Not private (172.32)"
      }
    ],
    "hints": [
      "10.0.0.0/8 is private",
      "172.16.0.0/12 (172.16-31.x.x) is private",
      "192.168.0.0/16 is private",
      "Check first and second octets"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Subnet Divider",
    "difficulty": 4,
    "description": "Divide a network into n equal subnets. Given a CIDR block and number of subnets, return the CIDR blocks for each subnet.",
    "starterCode": "# Divide network into subnets\ndef divide_subnet(cidr, num_subnets):\n    # Return list of CIDR blocks for subnets\n    pass\n\n# Test your function\nprint(divide_subnet(\"192.168.1.0/24\", 4))\nprint(divide_subnet(\"10.0.0.0/16\", 8))",
    "solution": "def divide_subnet(cidr, num_subnets):\n    import math\n    \n    ip, prefix = cidr.split(\"/\")\n    prefix = int(prefix)\n    \n    # Calculate new prefix (bits needed for subnets)\n    bits_needed = math.ceil(math.log2(num_subnets))\n    new_prefix = prefix + bits_needed\n    \n    if new_prefix > 32:\n        return []\n    \n    # Convert IP to integer\n    parts = [int(x) for x in ip.split(\".\")]\n    ip_int = (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]\n    \n    # Calculate subnet size\n    subnet_size = 2 ** (32 - new_prefix)\n    \n    subnets = []\n    for i in range(num_subnets):\n        subnet_ip = ip_int + (i * subnet_size)\n        octets = [\n            (subnet_ip >> 24) & 0xFF,\n            (subnet_ip >> 16) & 0xFF,\n            (subnet_ip >> 8) & 0xFF,\n            subnet_ip & 0xFF\n        ]\n        subnets.append(f\"{octets[0]}.{octets[1]}.{octets[2]}.{octets[3]}/{new_prefix}\")\n    \n    return subnets\n\nprint(divide_subnet(\"192.168.1.0/24\", 4))\nprint(divide_subnet(\"10.0.0.0/16\", 8))",
    "testCases": [
      {
        "input": "\"192.168.1.0/24\", 4",
        "isHidden": false,
        "description": "Divide /24 into 4"
      },
      {
        "input": "\"10.0.0.0/16\", 8",
        "isHidden": true,
        "description": "Divide /16 into 8"
      }
    ],
    "hints": [
      "Calculate bits needed: ceil(log2(num_subnets))",
      "New prefix = original prefix + bits needed",
      "Calculate subnet size = 2^(32 - new_prefix)",
      "Iterate through subnets incrementing by subnet_size"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Simple Routing Table",
    "difficulty": 4,
    "description": "Implement a simple routing table with longest prefix match. Support adding routes and looking up next hop.",
    "starterCode": "class RoutingTable:\n    def __init__(self):\n        self.routes = []  # (network, prefix, next_hop)\n    \n    def add_route(self, network_cidr, next_hop):\n        # Add a route entry\n        pass\n    \n    def lookup(self, dest_ip):\n        # Find best matching route using longest prefix match\n        # Return next_hop or None\n        pass\n\n# Test your class\nrt = RoutingTable()\nrt.add_route(\"192.168.1.0/24\", \"10.0.0.1\")\nrt.add_route(\"192.168.0.0/16\", \"10.0.0.2\")\nprint(rt.lookup(\"192.168.1.100\"))  # Should match /24",
    "solution": "class RoutingTable:\n    def __init__(self):\n        self.routes = []\n    \n    def add_route(self, network_cidr, next_hop):\n        network, prefix = network_cidr.split(\"/\")\n        prefix = int(prefix)\n        # Convert to integer for matching\n        parts = [int(x) for x in network.split(\".\")]\n        network_int = (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]\n        self.routes.append((network_int, prefix, next_hop))\n    \n    def lookup(self, dest_ip):\n        parts = [int(x) for x in dest_ip.split(\".\")]\n        dest_int = (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]\n        \n        best_match = None\n        best_prefix = -1\n        \n        for network, prefix, next_hop in self.routes:\n            mask = (0xFFFFFFFF << (32 - prefix)) & 0xFFFFFFFF\n            if (dest_int & mask) == network:\n                if prefix > best_prefix:\n                    best_prefix = prefix\n                    best_match = next_hop\n        \n        return best_match\n\nrt = RoutingTable()\nrt.add_route(\"192.168.1.0/24\", \"10.0.0.1\")\nrt.add_route(\"192.168.0.0/16\", \"10.0.0.2\")\nprint(rt.lookup(\"192.168.1.100\"))",
    "testCases": [
      {
        "input": "lookup matching /24",
        "isHidden": false,
        "description": "Longest prefix match"
      },
      {
        "input": "lookup matching /16 only",
        "isHidden": true,
        "description": "Less specific match"
      }
    ],
    "hints": [
      "Store routes as (network_int, prefix, next_hop)",
      "For lookup, check each route with its mask",
      "Keep track of the longest (most specific) match",
      "Longer prefix = more specific route"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "TTL Processor",
    "difficulty": 2,
    "description": "Simulate IP packet TTL (Time To Live) processing. Decrement TTL and check if packet should be forwarded or discarded.",
    "starterCode": "# Process IP packet TTL\ndef process_ttl(ttl):\n    # Return tuple: (new_ttl, should_forward)\n    pass\n\n# Test your function\nprint(process_ttl(64))   # (63, True)\nprint(process_ttl(1))    # (0, False)\nprint(process_ttl(0))    # (0, False)",
    "solution": "def process_ttl(ttl):\n    if ttl <= 1:\n        return (0, False)\n    return (ttl - 1, True)\n\nprint(process_ttl(64))\nprint(process_ttl(1))\nprint(process_ttl(0))",
    "testCases": [
      {
        "input": "64",
        "isHidden": false,
        "description": "Normal TTL"
      },
      {
        "input": "1",
        "isHidden": false,
        "description": "TTL expires"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "Already expired"
      }
    ],
    "hints": [
      "Decrement TTL by 1 at each hop",
      "If TTL reaches 0, discard packet",
      "Return both new TTL and forward decision",
      "TTL=1 becomes 0 and should not forward"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "IPv4 Header Parser",
    "difficulty": 4,
    "description": "Parse a simplified IPv4 header. Extract version, IHL, TTL, protocol, source IP, and destination IP from header bytes.",
    "starterCode": "# Parse IPv4 header\ndef parse_ipv4_header(header_hex):\n    # header_hex is a hex string representing the header\n    # Return dict with: version, ihl, ttl, protocol, src_ip, dst_ip\n    pass\n\n# Test with sample header\nheader = \"45000028000040004006\"\nheader += \"0000\"  # checksum placeholder\nheader += \"c0a80101\"  # source: 192.168.1.1\nheader += \"c0a80102\"  # dest: 192.168.1.2\nprint(parse_ipv4_header(header))",
    "solution": "def parse_ipv4_header(header_hex):\n    # Convert hex to bytes\n    def hex_to_ip(hex_str):\n        return \".\".join(str(int(hex_str[i:i+2], 16)) for i in range(0, 8, 2))\n    \n    version = int(header_hex[0], 16)\n    ihl = int(header_hex[1], 16)  # in 32-bit words\n    ttl = int(header_hex[16:18], 16)\n    protocol = int(header_hex[18:20], 16)\n    src_ip = hex_to_ip(header_hex[24:32])\n    dst_ip = hex_to_ip(header_hex[32:40])\n    \n    protocols = {6: \"TCP\", 17: \"UDP\", 1: \"ICMP\"}\n    \n    return {\n        \"version\": version,\n        \"ihl\": ihl,\n        \"ttl\": ttl,\n        \"protocol\": protocols.get(protocol, str(protocol)),\n        \"src_ip\": src_ip,\n        \"dst_ip\": dst_ip\n    }\n\nheader = \"45000028000040004006\"\nheader += \"0000\"\nheader += \"c0a80101\"\nheader += \"c0a80102\"\nprint(parse_ipv4_header(header))",
    "testCases": [
      {
        "input": "sample TCP header",
        "isHidden": false,
        "description": "Parse TCP packet"
      },
      {
        "input": "UDP header",
        "isHidden": true,
        "description": "Parse UDP packet"
      }
    ],
    "hints": [
      "IPv4 header: version(4b), IHL(4b), TOS(8b), length(16b)...",
      "TTL is at byte 8, Protocol at byte 9",
      "Source IP at bytes 12-15, Dest IP at bytes 16-19",
      "Each hex digit = 4 bits"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "Supernet Calculator",
    "difficulty": 4,
    "description": "Calculate the supernet (CIDR aggregate) of multiple contiguous subnets. Given a list of networks, return the smallest containing supernet.",
    "starterCode": "# Calculate supernet of contiguous networks\ndef calculate_supernet(networks):\n    # networks is a list of CIDR strings\n    # Return the supernet CIDR\n    pass\n\n# Test your function\nprint(calculate_supernet([\"192.168.0.0/24\", \"192.168.1.0/24\"]))\nprint(calculate_supernet([\"10.0.0.0/24\", \"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]))",
    "solution": "def calculate_supernet(networks):\n    def ip_to_int(ip):\n        parts = [int(x) for x in ip.split(\".\")]\n        return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]\n    \n    def int_to_ip(num):\n        return f\"{(num >> 24) & 0xFF}.{(num >> 16) & 0xFF}.{(num >> 8) & 0xFF}.{num & 0xFF}\"\n    \n    # Parse all networks\n    ips = []\n    min_prefix = 32\n    for net in networks:\n        ip, prefix = net.split(\"/\")\n        ips.append(ip_to_int(ip))\n        min_prefix = min(min_prefix, int(prefix))\n    \n    # Find common prefix length\n    min_ip = min(ips)\n    max_ip = max(ips)\n    \n    # XOR to find differing bits\n    diff = min_ip ^ max_ip\n    \n    # Find position of highest set bit in diff\n    new_prefix = 32\n    if diff > 0:\n        new_prefix = 32 - diff.bit_length()\n    \n    # Calculate supernet address\n    mask = (0xFFFFFFFF << (32 - new_prefix)) & 0xFFFFFFFF\n    supernet_ip = min_ip & mask\n    \n    return f\"{int_to_ip(supernet_ip)}/{new_prefix}\"\n\nprint(calculate_supernet([\"192.168.0.0/24\", \"192.168.1.0/24\"]))\nprint(calculate_supernet([\"10.0.0.0/24\", \"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]))",
    "testCases": [
      {
        "input": "[\"192.168.0.0/24\", \"192.168.1.0/24\"]",
        "isHidden": false,
        "description": "Two /24s to /23"
      },
      {
        "input": "four /24s",
        "isHidden": true,
        "description": "Four networks to /22"
      }
    ],
    "hints": [
      "XOR min and max IPs to find differing bits",
      "Count leading zeros to find common prefix",
      "New prefix covers all networks",
      "Use bit_length() to find highest set bit"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t3-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-3",
    "title": "ICMP Type Identifier",
    "difficulty": 2,
    "description": "Identify ICMP message types. Given a type number, return the message name and whether it's an error or informational message.",
    "starterCode": "# Identify ICMP message type\ndef identify_icmp(type_num):\n    # Return dict with: name, category (\"error\" or \"informational\")\n    pass\n\n# Test your function\nprint(identify_icmp(0))   # Echo Reply\nprint(identify_icmp(8))   # Echo Request\nprint(identify_icmp(3))   # Destination Unreachable",
    "solution": "def identify_icmp(type_num):\n    icmp_types = {\n        0: (\"Echo Reply\", \"informational\"),\n        3: (\"Destination Unreachable\", \"error\"),\n        4: (\"Source Quench\", \"error\"),\n        5: (\"Redirect\", \"error\"),\n        8: (\"Echo Request\", \"informational\"),\n        9: (\"Router Advertisement\", \"informational\"),\n        10: (\"Router Solicitation\", \"informational\"),\n        11: (\"Time Exceeded\", \"error\"),\n        12: (\"Parameter Problem\", \"error\"),\n        13: (\"Timestamp Request\", \"informational\"),\n        14: (\"Timestamp Reply\", \"informational\")\n    }\n    \n    if type_num in icmp_types:\n        name, category = icmp_types[type_num]\n        return {\"name\": name, \"category\": category}\n    return {\"name\": \"Unknown\", \"category\": \"unknown\"}\n\nprint(identify_icmp(0))\nprint(identify_icmp(8))\nprint(identify_icmp(3))",
    "testCases": [
      {
        "input": "0",
        "isHidden": false,
        "description": "Echo Reply"
      },
      {
        "input": "8",
        "isHidden": false,
        "description": "Echo Request"
      },
      {
        "input": "11",
        "isHidden": true,
        "description": "Time Exceeded"
      }
    ],
    "hints": [
      "Type 0 = Echo Reply, Type 8 = Echo Request (ping)",
      "Type 3 = Destination Unreachable (error)",
      "Type 11 = Time Exceeded (TTL expired)",
      "Error types typically < 100, informational vary"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Port Number Classifier",
    "difficulty": 1,
    "description": "Classify a port number as well-known (0-1023), registered (1024-49151), or dynamic/private (49152-65535).",
    "starterCode": "# Classify port number\ndef classify_port(port):\n    # Your code here\n    pass\n\n# Test your function\nprint(classify_port(80))\nprint(classify_port(8080))\nprint(classify_port(55000))",
    "solution": "def classify_port(port):\n    if port < 0 or port > 65535:\n        return \"invalid\"\n    elif port <= 1023:\n        return \"well-known\"\n    elif port <= 49151:\n        return \"registered\"\n    else:\n        return \"dynamic\"\n\nprint(classify_port(80))\nprint(classify_port(8080))\nprint(classify_port(55000))",
    "testCases": [
      {
        "input": "80",
        "isHidden": false,
        "description": "Well-known port"
      },
      {
        "input": "8080",
        "isHidden": false,
        "description": "Registered port"
      },
      {
        "input": "55000",
        "isHidden": true,
        "description": "Dynamic port"
      }
    ],
    "hints": [
      "Well-known ports: 0-1023",
      "Registered ports: 1024-49151",
      "Dynamic/Private: 49152-65535",
      "Total port range: 0-65535"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Common Port Lookup",
    "difficulty": 1,
    "description": "Look up common port numbers and return the associated service name.",
    "starterCode": "# Lookup common port services\ndef port_service(port):\n    # Your code here\n    pass\n\n# Test your function\nprint(port_service(80))\nprint(port_service(443))\nprint(port_service(22))",
    "solution": "def port_service(port):\n    services = {\n        20: \"FTP Data\",\n        21: \"FTP Control\",\n        22: \"SSH\",\n        23: \"Telnet\",\n        25: \"SMTP\",\n        53: \"DNS\",\n        67: \"DHCP Server\",\n        68: \"DHCP Client\",\n        80: \"HTTP\",\n        110: \"POP3\",\n        143: \"IMAP\",\n        443: \"HTTPS\",\n        993: \"IMAPS\",\n        995: \"POP3S\",\n        3306: \"MySQL\",\n        5432: \"PostgreSQL\",\n        6379: \"Redis\"\n    }\n    return services.get(port, \"Unknown\")\n\nprint(port_service(80))\nprint(port_service(443))\nprint(port_service(22))",
    "testCases": [
      {
        "input": "80",
        "isHidden": false,
        "description": "HTTP"
      },
      {
        "input": "443",
        "isHidden": false,
        "description": "HTTPS"
      },
      {
        "input": "53",
        "isHidden": true,
        "description": "DNS"
      }
    ],
    "hints": [
      "Port 80 = HTTP, 443 = HTTPS",
      "Port 22 = SSH, 23 = Telnet",
      "Port 53 = DNS, 25 = SMTP",
      "Use a dictionary for lookups"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "TCP vs UDP Comparator",
    "difficulty": 2,
    "description": "Return characteristics of TCP or UDP given the protocol name. Include connection type, reliability, and typical use cases.",
    "starterCode": "# Get protocol characteristics\ndef protocol_info(protocol):\n    # Return dict with: connection, reliable, ordering, typical_use\n    pass\n\n# Test your function\nprint(protocol_info(\"TCP\"))\nprint(protocol_info(\"UDP\"))",
    "solution": "def protocol_info(protocol):\n    protocols = {\n        \"TCP\": {\n            \"connection\": \"connection-oriented\",\n            \"reliable\": True,\n            \"ordering\": True,\n            \"typical_use\": [\"HTTP\", \"HTTPS\", \"SSH\", \"FTP\", \"SMTP\"]\n        },\n        \"UDP\": {\n            \"connection\": \"connectionless\",\n            \"reliable\": False,\n            \"ordering\": False,\n            \"typical_use\": [\"DNS\", \"DHCP\", \"VoIP\", \"Video Streaming\", \"Gaming\"]\n        }\n    }\n    return protocols.get(protocol.upper(), {})\n\nprint(protocol_info(\"TCP\"))\nprint(protocol_info(\"UDP\"))",
    "testCases": [
      {
        "input": "\"TCP\"",
        "isHidden": false,
        "description": "TCP characteristics"
      },
      {
        "input": "\"UDP\"",
        "isHidden": false,
        "description": "UDP characteristics"
      },
      {
        "input": "\"tcp\"",
        "isHidden": true,
        "description": "Case insensitive"
      }
    ],
    "hints": [
      "TCP is connection-oriented, reliable, ordered",
      "UDP is connectionless, unreliable, unordered",
      "TCP uses handshakes, UDP does not",
      "UDP has lower latency, good for real-time"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Sequence Number Calculator",
    "difficulty": 3,
    "description": "Calculate TCP sequence numbers for a data stream. Given initial sequence number and data segments, return sequence numbers for each segment.",
    "starterCode": "# Calculate TCP sequence numbers\ndef calculate_seq_numbers(initial_seq, segment_sizes):\n    # Return list of sequence numbers for each segment\n    pass\n\n# Test your function\nprint(calculate_seq_numbers(1000, [100, 200, 150]))",
    "solution": "def calculate_seq_numbers(initial_seq, segment_sizes):\n    seq_numbers = []\n    current_seq = initial_seq\n    \n    for size in segment_sizes:\n        seq_numbers.append(current_seq)\n        current_seq += size\n    \n    return seq_numbers\n\nprint(calculate_seq_numbers(1000, [100, 200, 150]))",
    "testCases": [
      {
        "input": "1000, [100, 200, 150]",
        "isHidden": false,
        "description": "Three segments"
      },
      {
        "input": "0, [500, 500, 500]",
        "isHidden": true,
        "description": "Equal segments"
      }
    ],
    "hints": [
      "First segment uses initial sequence number",
      "Each subsequent segment = previous + previous size",
      "Sequence number = first byte of segment data",
      "Sequence increments by bytes sent"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "ACK Number Calculator",
    "difficulty": 3,
    "description": "Calculate the TCP acknowledgment number. ACK = sequence number of next expected byte.",
    "starterCode": "# Calculate TCP ACK number\ndef calculate_ack(received_seq, received_length):\n    # Return the ACK number to send back\n    pass\n\n# Test your function\nprint(calculate_ack(1000, 500))  # Received seq 1000, 500 bytes\nprint(calculate_ack(1500, 300))  # Received seq 1500, 300 bytes",
    "solution": "def calculate_ack(received_seq, received_length):\n    # ACK = sequence number of next expected byte\n    return received_seq + received_length\n\nprint(calculate_ack(1000, 500))\nprint(calculate_ack(1500, 300))",
    "testCases": [
      {
        "input": "1000, 500",
        "isHidden": false,
        "description": "ACK after 500 bytes"
      },
      {
        "input": "1500, 300",
        "isHidden": false,
        "description": "ACK after 300 bytes"
      },
      {
        "input": "0, 1460",
        "isHidden": true,
        "description": "Full MSS segment"
      }
    ],
    "hints": [
      "ACK number = next byte expected",
      "ACK = received_seq + data_length",
      "Acknowledges all bytes up to this point",
      "Cumulative acknowledgment in TCP"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "TCP Handshake Simulator",
    "difficulty": 3,
    "description": "Simulate the TCP three-way handshake. Track sequence and ACK numbers through SYN, SYN-ACK, and ACK.",
    "starterCode": "# Simulate TCP three-way handshake\ndef three_way_handshake(client_isn, server_isn):\n    # Return list of (sender, seq, ack, flags) tuples\n    pass\n\n# Test your function\nhandshake = three_way_handshake(100, 300)\nfor step in handshake:\n    print(step)",
    "solution": "def three_way_handshake(client_isn, server_isn):\n    steps = []\n    \n    # Step 1: Client sends SYN\n    steps.append((\"client\", client_isn, 0, \"SYN\"))\n    \n    # Step 2: Server sends SYN-ACK\n    steps.append((\"server\", server_isn, client_isn + 1, \"SYN-ACK\"))\n    \n    # Step 3: Client sends ACK\n    steps.append((\"client\", client_isn + 1, server_isn + 1, \"ACK\"))\n    \n    return steps\n\nhandshake = three_way_handshake(100, 300)\nfor step in handshake:\n    print(step)",
    "testCases": [
      {
        "input": "100, 300",
        "isHidden": false,
        "description": "Normal handshake"
      },
      {
        "input": "0, 0",
        "isHidden": true,
        "description": "Zero ISNs"
      }
    ],
    "hints": [
      "SYN: client seq=ISN, ack=0",
      "SYN-ACK: server seq=ISN, ack=client_ISN+1",
      "ACK: client seq=ISN+1, ack=server_ISN+1",
      "SYN and SYN-ACK consume one sequence number"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Window Size Analyzer",
    "difficulty": 3,
    "description": "Calculate how many segments can be sent without waiting for ACKs, given window size and MSS (Maximum Segment Size).",
    "starterCode": "# Calculate segments in flight\ndef segments_in_window(window_size, mss):\n    # Return number of full segments that fit\n    pass\n\n# Test your function\nprint(segments_in_window(65535, 1460))  # Typical values\nprint(segments_in_window(16384, 536))",
    "solution": "def segments_in_window(window_size, mss):\n    return window_size // mss\n\nprint(segments_in_window(65535, 1460))\nprint(segments_in_window(16384, 536))",
    "testCases": [
      {
        "input": "65535, 1460",
        "isHidden": false,
        "description": "Max window, Ethernet MSS"
      },
      {
        "input": "16384, 536",
        "isHidden": false,
        "description": "Smaller window"
      },
      {
        "input": "1460, 1460",
        "isHidden": true,
        "description": "Window equals MSS"
      }
    ],
    "hints": [
      "Window size is in bytes",
      "MSS is maximum segment size in bytes",
      "Segments = window_size / MSS",
      "Use integer division for full segments"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Checksum Calculator",
    "difficulty": 4,
    "description": "Calculate a simplified TCP/UDP checksum using one's complement sum of 16-bit words.",
    "starterCode": "# Calculate transport layer checksum\ndef calculate_checksum(data_bytes):\n    # data_bytes is a list of integers (bytes)\n    # Return 16-bit checksum\n    pass\n\n# Test your function\nprint(hex(calculate_checksum([0x00, 0x01, 0x00, 0x02])))",
    "solution": "def calculate_checksum(data_bytes):\n    # Pad if odd number of bytes\n    if len(data_bytes) % 2 == 1:\n        data_bytes = data_bytes + [0]\n    \n    # Sum 16-bit words\n    total = 0\n    for i in range(0, len(data_bytes), 2):\n        word = (data_bytes[i] << 8) + data_bytes[i + 1]\n        total += word\n    \n    # Fold 32-bit sum to 16 bits\n    while total > 0xFFFF:\n        total = (total & 0xFFFF) + (total >> 16)\n    \n    # One's complement\n    return (~total) & 0xFFFF\n\nprint(hex(calculate_checksum([0x00, 0x01, 0x00, 0x02])))",
    "testCases": [
      {
        "input": "[0x00, 0x01, 0x00, 0x02]",
        "isHidden": false,
        "description": "Simple data"
      },
      {
        "input": "[0xFF, 0xFF, 0x00, 0x00]",
        "isHidden": true,
        "description": "With max values"
      }
    ],
    "hints": [
      "Sum 16-bit words (big-endian)",
      "Fold carries back into lower 16 bits",
      "Final result is one's complement (~sum)",
      "Checksum verifies to 0xFFFF when valid"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "RTT Estimator",
    "difficulty": 4,
    "description": "Implement TCP RTT estimation using exponential weighted moving average (EWMA). EstimatedRTT = (1-)  EstimatedRTT +   SampleRTT",
    "starterCode": "# TCP RTT Estimation\nclass RTTEstimator:\n    def __init__(self, alpha=0.125):\n        self.alpha = alpha\n        self.estimated_rtt = None\n    \n    def update(self, sample_rtt):\n        # Update estimated RTT with new sample\n        # Return new estimated RTT\n        pass\n\n# Test your class\nest = RTTEstimator()\nfor sample in [100, 120, 90, 110, 105]:\n    print(f\"Sample: {sample}, Estimated: {est.update(sample)}\")",
    "solution": "class RTTEstimator:\n    def __init__(self, alpha=0.125):\n        self.alpha = alpha\n        self.estimated_rtt = None\n    \n    def update(self, sample_rtt):\n        if self.estimated_rtt is None:\n            self.estimated_rtt = sample_rtt\n        else:\n            self.estimated_rtt = (1 - self.alpha) * self.estimated_rtt + self.alpha * sample_rtt\n        return round(self.estimated_rtt, 2)\n\nest = RTTEstimator()\nfor sample in [100, 120, 90, 110, 105]:\n    print(f\"Sample: {sample}, Estimated: {est.update(sample)}\")",
    "testCases": [
      {
        "input": "samples: [100, 120, 90, 110, 105]",
        "isHidden": false,
        "description": "Multiple samples"
      },
      {
        "input": "single sample",
        "isHidden": true,
        "description": "First sample"
      }
    ],
    "hints": [
      "First sample becomes initial estimate",
      "EWMA formula: EstRTT = (1-)EstRTT + Sample",
      " = 0.125 (1/8) is recommended",
      "Smooths out RTT variations"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Timeout Calculator",
    "difficulty": 4,
    "description": "Calculate TCP retransmission timeout (RTO) from EstimatedRTT and DevRTT. RTO = EstimatedRTT + 4  DevRTT",
    "starterCode": "# TCP Timeout Calculation\nclass TimeoutCalculator:\n    def __init__(self, alpha=0.125, beta=0.25):\n        self.alpha = alpha\n        self.beta = beta\n        self.estimated_rtt = None\n        self.dev_rtt = None\n    \n    def update(self, sample_rtt):\n        # Update estimates and return RTO\n        pass\n\n# Test your class\ncalc = TimeoutCalculator()\nfor sample in [100, 150, 80, 120]:\n    print(f\"Sample: {sample}, RTO: {calc.update(sample)}\")",
    "solution": "class TimeoutCalculator:\n    def __init__(self, alpha=0.125, beta=0.25):\n        self.alpha = alpha\n        self.beta = beta\n        self.estimated_rtt = None\n        self.dev_rtt = None\n    \n    def update(self, sample_rtt):\n        if self.estimated_rtt is None:\n            self.estimated_rtt = sample_rtt\n            self.dev_rtt = sample_rtt / 2\n        else:\n            # Update DevRTT first (uses old EstimatedRTT)\n            self.dev_rtt = (1 - self.beta) * self.dev_rtt + self.beta * abs(sample_rtt - self.estimated_rtt)\n            # Update EstimatedRTT\n            self.estimated_rtt = (1 - self.alpha) * self.estimated_rtt + self.alpha * sample_rtt\n        \n        # Calculate RTO\n        rto = self.estimated_rtt + 4 * self.dev_rtt\n        return round(rto, 2)\n\ncalc = TimeoutCalculator()\nfor sample in [100, 150, 80, 120]:\n    print(f\"Sample: {sample}, RTO: {calc.update(sample)}\")",
    "testCases": [
      {
        "input": "samples: [100, 150, 80, 120]",
        "isHidden": false,
        "description": "Variable samples"
      },
      {
        "input": "stable RTT",
        "isHidden": true,
        "description": "Consistent samples"
      }
    ],
    "hints": [
      "DevRTT = (1-)DevRTT + |Sample-EstRTT|",
      "EstRTT = (1-)EstRTT + Sample",
      "RTO = EstRTT + 4DevRTT",
      "Initial DevRTT = SampleRTT/2"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Congestion Window Simulator",
    "difficulty": 4,
    "description": "Simulate TCP congestion control. Implement slow start (exponential growth) and congestion avoidance (linear growth).",
    "starterCode": "# TCP Congestion Control Simulator\nclass CongestionControl:\n    def __init__(self, mss=1460, ssthresh=65535):\n        self.mss = mss\n        self.ssthresh = ssthresh\n        self.cwnd = mss  # Start with 1 MSS\n    \n    def on_ack(self):\n        # Called when ACK received\n        # Return new cwnd\n        pass\n    \n    def on_loss(self):\n        # Called on packet loss\n        # Return new cwnd\n        pass\n\n# Test your class\ncc = CongestionControl(mss=1000, ssthresh=8000)\nfor i in range(10):\n    print(f\"Round {i+1}: cwnd = {cc.on_ack()}\")",
    "solution": "class CongestionControl:\n    def __init__(self, mss=1460, ssthresh=65535):\n        self.mss = mss\n        self.ssthresh = ssthresh\n        self.cwnd = mss\n    \n    def on_ack(self):\n        if self.cwnd < self.ssthresh:\n            # Slow start: double cwnd (exponential)\n            self.cwnd += self.mss\n        else:\n            # Congestion avoidance: add 1 MSS per RTT (linear)\n            self.cwnd += self.mss * self.mss // self.cwnd\n        return self.cwnd\n    \n    def on_loss(self):\n        # Multiplicative decrease\n        self.ssthresh = max(self.cwnd // 2, 2 * self.mss)\n        self.cwnd = self.mss\n        return self.cwnd\n\ncc = CongestionControl(mss=1000, ssthresh=8000)\nfor i in range(10):\n    print(f\"Round {i+1}: cwnd = {cc.on_ack()}\")",
    "testCases": [
      {
        "input": "slow start growth",
        "isHidden": false,
        "description": "Exponential increase"
      },
      {
        "input": "after loss",
        "isHidden": true,
        "description": "Reset to slow start"
      }
    ],
    "hints": [
      "Slow start: cwnd doubles each RTT (< ssthresh)",
      "Congestion avoidance: cwnd += MSS/cwnd per ACK",
      "On loss: ssthresh = cwnd/2, cwnd = 1 MSS",
      "AIMD: Additive Increase, Multiplicative Decrease"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "TCP State Machine",
    "difficulty": 5,
    "description": "Implement a simplified TCP state machine for connection establishment and teardown.",
    "starterCode": "# TCP State Machine\nclass TCPStateMachine:\n    def __init__(self, is_server=False):\n        self.state = \"CLOSED\"\n        self.is_server = is_server\n    \n    def process_event(self, event):\n        # Event can be: LISTEN, CONNECT, SYN, SYN_ACK, ACK, FIN, FIN_ACK\n        # Return new state\n        pass\n\n# Test client connection\nclient = TCPStateMachine(is_server=False)\nprint(client.process_event(\"CONNECT\"))  # -> SYN_SENT\nprint(client.process_event(\"SYN_ACK\"))  # -> ESTABLISHED",
    "solution": "class TCPStateMachine:\n    def __init__(self, is_server=False):\n        self.state = \"CLOSED\"\n        self.is_server = is_server\n    \n    def process_event(self, event):\n        transitions = {\n            # Server states\n            (\"CLOSED\", \"LISTEN\"): \"LISTEN\",\n            (\"LISTEN\", \"SYN\"): \"SYN_RECEIVED\",\n            (\"SYN_RECEIVED\", \"ACK\"): \"ESTABLISHED\",\n            \n            # Client states\n            (\"CLOSED\", \"CONNECT\"): \"SYN_SENT\",\n            (\"SYN_SENT\", \"SYN_ACK\"): \"ESTABLISHED\",\n            \n            # Connection termination (both)\n            (\"ESTABLISHED\", \"FIN\"): \"FIN_WAIT_1\",\n            (\"ESTABLISHED\", \"CLOSE\"): \"FIN_WAIT_1\",\n            (\"FIN_WAIT_1\", \"FIN_ACK\"): \"TIME_WAIT\",\n            (\"FIN_WAIT_1\", \"ACK\"): \"FIN_WAIT_2\",\n            (\"FIN_WAIT_2\", \"FIN\"): \"TIME_WAIT\",\n            (\"TIME_WAIT\", \"TIMEOUT\"): \"CLOSED\",\n            \n            # Passive close\n            (\"ESTABLISHED\", \"FIN_RECV\"): \"CLOSE_WAIT\",\n            (\"CLOSE_WAIT\", \"CLOSE\"): \"LAST_ACK\",\n            (\"LAST_ACK\", \"ACK\"): \"CLOSED\"\n        }\n        \n        key = (self.state, event)\n        if key in transitions:\n            self.state = transitions[key]\n        return self.state\n\nclient = TCPStateMachine(is_server=False)\nprint(client.process_event(\"CONNECT\"))\nprint(client.process_event(\"SYN_ACK\"))",
    "testCases": [
      {
        "input": "client connection",
        "isHidden": false,
        "description": "Client handshake"
      },
      {
        "input": "connection teardown",
        "isHidden": true,
        "description": "FIN sequence"
      }
    ],
    "hints": [
      "Use (current_state, event) -> new_state mapping",
      "Client: CLOSED -> SYN_SENT -> ESTABLISHED",
      "Server: CLOSED -> LISTEN -> SYN_RECEIVED -> ESTABLISHED",
      "Teardown involves FIN_WAIT and TIME_WAIT states"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "UDP Datagram Builder",
    "difficulty": 2,
    "description": "Build a UDP datagram header. Include source port, destination port, length, and checksum fields.",
    "starterCode": "# Build UDP header\ndef build_udp_header(src_port, dst_port, data):\n    # Return dict with header fields and total length\n    pass\n\n# Test your function\nheader = build_udp_header(12345, 80, \"Hello\")\nprint(header)",
    "solution": "def build_udp_header(src_port, dst_port, data):\n    data_bytes = data.encode() if isinstance(data, str) else data\n    data_length = len(data_bytes)\n    # UDP header is 8 bytes + data\n    total_length = 8 + data_length\n    \n    return {\n        \"source_port\": src_port,\n        \"destination_port\": dst_port,\n        \"length\": total_length,\n        \"checksum\": 0,  # Placeholder (optional in UDP)\n        \"data\": data,\n        \"header_size\": 8,\n        \"data_size\": data_length\n    }\n\nheader = build_udp_header(12345, 80, \"Hello\")\nprint(header)",
    "testCases": [
      {
        "input": "12345, 80, \"Hello\"",
        "isHidden": false,
        "description": "Simple UDP datagram"
      },
      {
        "input": "53, 53, \"query\"",
        "isHidden": true,
        "description": "DNS-like"
      }
    ],
    "hints": [
      "UDP header is always 8 bytes",
      "Length = header (8) + data length",
      "Checksum is optional in UDP over IPv4",
      "Ports are 16-bit (0-65535)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Flow Control Simulator",
    "difficulty": 4,
    "description": "Simulate TCP flow control with receive window. Track buffer usage and advertise window size.",
    "starterCode": "# TCP Flow Control\nclass FlowControl:\n    def __init__(self, buffer_size):\n        self.buffer_size = buffer_size\n        self.buffer_used = 0\n    \n    def receive_data(self, data_size):\n        # Receive data, return True if accepted\n        pass\n    \n    def consume_data(self, size):\n        # Application consumes data from buffer\n        pass\n    \n    def get_window(self):\n        # Return advertised receive window\n        pass\n\n# Test your class\nfc = FlowControl(1000)\nprint(fc.receive_data(400))  # Accept\nprint(fc.get_window())       # 600\nfc.consume_data(200)\nprint(fc.get_window())       # 800",
    "solution": "class FlowControl:\n    def __init__(self, buffer_size):\n        self.buffer_size = buffer_size\n        self.buffer_used = 0\n    \n    def receive_data(self, data_size):\n        if self.buffer_used + data_size <= self.buffer_size:\n            self.buffer_used += data_size\n            return True\n        return False\n    \n    def consume_data(self, size):\n        self.buffer_used = max(0, self.buffer_used - size)\n    \n    def get_window(self):\n        return self.buffer_size - self.buffer_used\n\nfc = FlowControl(1000)\nprint(fc.receive_data(400))\nprint(fc.get_window())\nfc.consume_data(200)\nprint(fc.get_window())",
    "testCases": [
      {
        "input": "normal flow",
        "isHidden": false,
        "description": "Accept and consume"
      },
      {
        "input": "buffer full",
        "isHidden": true,
        "description": "Reject when full"
      }
    ],
    "hints": [
      "Receive window = buffer_size - buffer_used",
      "Reject data if it exceeds available space",
      "Application consuming data frees buffer space",
      "Window size controls sender's rate"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Selective ACK Parser",
    "difficulty": 4,
    "description": "Parse TCP Selective Acknowledgment (SACK) blocks. SACK indicates non-contiguous received data.",
    "starterCode": "# Parse SACK blocks\ndef parse_sack(sack_blocks, cumulative_ack):\n    # sack_blocks: list of (start, end) tuples\n    # cumulative_ack: sequence number of cumulative ACK\n    # Return list of missing ranges\n    pass\n\n# Test your function\n# Cumulative ACK at 1000, SACK blocks at 1500-2000 and 2500-3000\nprint(parse_sack([(1500, 2000), (2500, 3000)], 1000))",
    "solution": "def parse_sack(sack_blocks, cumulative_ack):\n    # Sort SACK blocks by start\n    sorted_blocks = sorted(sack_blocks, key=lambda x: x[0])\n    \n    missing = []\n    current = cumulative_ack\n    \n    for start, end in sorted_blocks:\n        if start > current:\n            missing.append((current, start))\n        current = max(current, end)\n    \n    return missing\n\nprint(parse_sack([(1500, 2000), (2500, 3000)], 1000))",
    "testCases": [
      {
        "input": "[(1500, 2000), (2500, 3000)], 1000",
        "isHidden": false,
        "description": "Two SACK blocks"
      },
      {
        "input": "consecutive blocks",
        "isHidden": true,
        "description": "No gaps"
      }
    ],
    "hints": [
      "SACK shows received but non-contiguous data",
      "Missing ranges are gaps between cumulative ACK and SACK blocks",
      "Sort blocks by start sequence",
      "Track the end of last received data"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t4-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-4",
    "title": "Throughput Calculator",
    "difficulty": 3,
    "description": "Calculate TCP throughput given window size and RTT. Throughput  WindowSize / RTT for a single connection.",
    "starterCode": "# Calculate TCP throughput\ndef tcp_throughput(window_size_bytes, rtt_ms):\n    # Return throughput in Mbps\n    pass\n\n# Test your function\nprint(tcp_throughput(65535, 100))   # 65KB window, 100ms RTT\nprint(tcp_throughput(1048576, 50))  # 1MB window, 50ms RTT",
    "solution": "def tcp_throughput(window_size_bytes, rtt_ms):\n    # Throughput = Window / RTT\n    # Convert window to bits\n    window_bits = window_size_bytes * 8\n    # Convert RTT to seconds\n    rtt_seconds = rtt_ms / 1000\n    # Throughput in bits per second\n    throughput_bps = window_bits / rtt_seconds\n    # Convert to Mbps\n    throughput_mbps = throughput_bps / 1_000_000\n    return round(throughput_mbps, 2)\n\nprint(tcp_throughput(65535, 100))\nprint(tcp_throughput(1048576, 50))",
    "testCases": [
      {
        "input": "65535, 100",
        "isHidden": false,
        "description": "Standard window"
      },
      {
        "input": "1048576, 50",
        "isHidden": false,
        "description": "Large window"
      },
      {
        "input": "65535, 1",
        "isHidden": true,
        "description": "Low latency"
      }
    ],
    "hints": [
      "Throughput = WindowSize / RTT",
      "Convert bytes to bits (* 8)",
      "Convert milliseconds to seconds (/ 1000)",
      "Result is bits per second, convert to Mbps"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "NAT Port Mapper",
    "difficulty": 2,
    "description": "Implement a simple NAT (Network Address Translation) port mapping table. Map internal IP:port to external port.",
    "starterCode": "class NATTable:\n    def __init__(self, external_ip):\n        self.external_ip = external_ip\n        self.mappings = {}  # (internal_ip, internal_port) -> external_port\n        self.next_port = 10000\n    \n    def create_mapping(self, internal_ip, internal_port):\n        # Return external port for this connection\n        pass\n    \n    def lookup_internal(self, external_port):\n        # Return (internal_ip, internal_port) or None\n        pass\n\n# Test your class\nnat = NATTable(\"203.0.113.1\")\nprint(nat.create_mapping(\"192.168.1.10\", 12345))\nprint(nat.create_mapping(\"192.168.1.20\", 12345))",
    "solution": "class NATTable:\n    def __init__(self, external_ip):\n        self.external_ip = external_ip\n        self.mappings = {}\n        self.reverse_mappings = {}\n        self.next_port = 10000\n    \n    def create_mapping(self, internal_ip, internal_port):\n        key = (internal_ip, internal_port)\n        if key in self.mappings:\n            return self.mappings[key]\n        \n        external_port = self.next_port\n        self.next_port += 1\n        self.mappings[key] = external_port\n        self.reverse_mappings[external_port] = key\n        return external_port\n    \n    def lookup_internal(self, external_port):\n        return self.reverse_mappings.get(external_port)\n\nnat = NATTable(\"203.0.113.1\")\nprint(nat.create_mapping(\"192.168.1.10\", 12345))\nprint(nat.create_mapping(\"192.168.1.20\", 12345))",
    "testCases": [
      {
        "input": "create two mappings",
        "isHidden": false,
        "description": "Different external ports"
      },
      {
        "input": "lookup existing",
        "isHidden": true,
        "description": "Reverse lookup"
      }
    ],
    "hints": [
      "Store both forward and reverse mappings",
      "Assign unique external port for each (ip, port) pair",
      "Reuse existing mapping if same internal ip:port",
      "Increment port counter for new mappings"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "CIDR Aggregator",
    "difficulty": 4,
    "description": "Aggregate multiple contiguous CIDR blocks into a single larger block when possible.",
    "starterCode": "# Aggregate CIDR blocks\ndef aggregate_cidrs(cidr_list):\n    # Return list of aggregated CIDR blocks\n    pass\n\n# Test your function\nprint(aggregate_cidrs([\"192.168.0.0/24\", \"192.168.1.0/24\"]))\nprint(aggregate_cidrs([\"10.0.0.0/24\", \"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]))",
    "solution": "def aggregate_cidrs(cidr_list):\n    def ip_to_int(ip):\n        parts = [int(x) for x in ip.split(\".\")]\n        return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]\n    \n    def int_to_ip(num):\n        return f\"{(num >> 24) & 0xFF}.{(num >> 16) & 0xFF}.{(num >> 8) & 0xFF}.{num & 0xFF}\"\n    \n    # Parse CIDRs to (network_int, prefix)\n    networks = []\n    for cidr in cidr_list:\n        ip, prefix = cidr.split(\"/\")\n        networks.append((ip_to_int(ip), int(prefix)))\n    \n    # Sort by network address\n    networks.sort()\n    \n    # Try to merge adjacent networks\n    changed = True\n    while changed:\n        changed = False\n        new_networks = []\n        i = 0\n        while i < len(networks):\n            if i + 1 < len(networks):\n                net1, prefix1 = networks[i]\n                net2, prefix2 = networks[i + 1]\n                # Can merge if same prefix and adjacent\n                if prefix1 == prefix2:\n                    size = 1 << (32 - prefix1)\n                    if net2 == net1 + size:\n                        # Check if they form a valid larger network\n                        new_prefix = prefix1 - 1\n                        new_mask = (0xFFFFFFFF << (32 - new_prefix)) & 0xFFFFFFFF\n                        if (net1 & new_mask) == net1:\n                            new_networks.append((net1, new_prefix))\n                            i += 2\n                            changed = True\n                            continue\n            new_networks.append(networks[i])\n            i += 1\n        networks = new_networks\n    \n    return [f\"{int_to_ip(net)}/{prefix}\" for net, prefix in networks]\n\nprint(aggregate_cidrs([\"192.168.0.0/24\", \"192.168.1.0/24\"]))\nprint(aggregate_cidrs([\"10.0.0.0/24\", \"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]))",
    "testCases": [
      {
        "input": "[\"192.168.0.0/24\", \"192.168.1.0/24\"]",
        "isHidden": false,
        "description": "Two to one"
      },
      {
        "input": "four networks",
        "isHidden": true,
        "description": "Four to one"
      }
    ],
    "hints": [
      "Sort networks by address first",
      "Two /24s can become one /23 if adjacent",
      "Networks must align on new prefix boundary",
      "Repeat until no more merges possible"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "QoS Priority Queue",
    "difficulty": 3,
    "description": "Implement a simple QoS (Quality of Service) priority queue with traffic classes.",
    "starterCode": "import heapq\n\nclass QoSQueue:\n    def __init__(self):\n        self.queue = []  # priority queue\n        self.priorities = {\"realtime\": 0, \"interactive\": 1, \"bulk\": 2, \"best_effort\": 3}\n    \n    def enqueue(self, packet, traffic_class):\n        # Add packet with appropriate priority\n        pass\n    \n    def dequeue(self):\n        # Return highest priority packet\n        pass\n\n# Test your class\nq = QoSQueue()\nq.enqueue(\"Email\", \"bulk\")\nq.enqueue(\"VoIP\", \"realtime\")\nq.enqueue(\"Web\", \"interactive\")\nprint(q.dequeue())  # VoIP",
    "solution": "import heapq\n\nclass QoSQueue:\n    def __init__(self):\n        self.queue = []\n        self.priorities = {\"realtime\": 0, \"interactive\": 1, \"bulk\": 2, \"best_effort\": 3}\n        self.counter = 0  # For FIFO within same priority\n    \n    def enqueue(self, packet, traffic_class):\n        priority = self.priorities.get(traffic_class, 3)\n        heapq.heappush(self.queue, (priority, self.counter, packet))\n        self.counter += 1\n    \n    def dequeue(self):\n        if self.queue:\n            _, _, packet = heapq.heappop(self.queue)\n            return packet\n        return None\n\nq = QoSQueue()\nq.enqueue(\"Email\", \"bulk\")\nq.enqueue(\"VoIP\", \"realtime\")\nq.enqueue(\"Web\", \"interactive\")\nprint(q.dequeue())",
    "testCases": [
      {
        "input": "mixed priorities",
        "isHidden": false,
        "description": "Realtime first"
      },
      {
        "input": "same priority FIFO",
        "isHidden": true,
        "description": "FIFO order"
      }
    ],
    "hints": [
      "Use heapq for priority queue",
      "Lower number = higher priority",
      "Include counter for FIFO within same priority",
      "Tuple comparison: (priority, counter, data)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Token Bucket Rate Limiter",
    "difficulty": 4,
    "description": "Implement a token bucket algorithm for rate limiting. Tokens accumulate up to bucket size, consumed by packets.",
    "starterCode": "import time\n\nclass TokenBucket:\n    def __init__(self, rate, bucket_size):\n        self.rate = rate  # tokens per second\n        self.bucket_size = bucket_size\n        self.tokens = bucket_size\n        self.last_update = time.time()\n    \n    def consume(self, tokens_needed):\n        # Try to consume tokens, return True if allowed\n        pass\n\n# Test your class\nbucket = TokenBucket(rate=10, bucket_size=20)\nprint(bucket.consume(5))   # True\nprint(bucket.consume(20))  # False (only 15 left)",
    "solution": "import time\n\nclass TokenBucket:\n    def __init__(self, rate, bucket_size):\n        self.rate = rate\n        self.bucket_size = bucket_size\n        self.tokens = bucket_size\n        self.last_update = time.time()\n    \n    def _refill(self):\n        now = time.time()\n        elapsed = now - self.last_update\n        self.tokens = min(self.bucket_size, self.tokens + elapsed * self.rate)\n        self.last_update = now\n    \n    def consume(self, tokens_needed):\n        self._refill()\n        if self.tokens >= tokens_needed:\n            self.tokens -= tokens_needed\n            return True\n        return False\n\nbucket = TokenBucket(rate=10, bucket_size=20)\nprint(bucket.consume(5))\nprint(bucket.consume(20))",
    "testCases": [
      {
        "input": "consume within limit",
        "isHidden": false,
        "description": "Allowed"
      },
      {
        "input": "exceed bucket",
        "isHidden": false,
        "description": "Denied"
      },
      {
        "input": "refill over time",
        "isHidden": true,
        "description": "Tokens regenerate"
      }
    ],
    "hints": [
      "Tokens accumulate at \"rate\" per second",
      "Maximum tokens = bucket_size",
      "Refill before each consume check",
      "Elapsed time  rate = new tokens"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "VLAN Manager",
    "difficulty": 3,
    "description": "Manage VLAN assignments for switch ports. Support assigning VLANs, checking isolation, and trunk ports.",
    "starterCode": "class VLANManager:\n    def __init__(self, num_ports):\n        self.num_ports = num_ports\n        self.port_vlans = {}  # port -> set of VLANs\n        self.trunk_ports = set()\n    \n    def assign_access_port(self, port, vlan):\n        # Assign port to single VLAN (access mode)\n        pass\n    \n    def assign_trunk_port(self, port, vlans):\n        # Assign port to multiple VLANs (trunk mode)\n        pass\n    \n    def can_communicate(self, port1, port2):\n        # Check if ports share a VLAN\n        pass\n\n# Test your class\nvm = VLANManager(24)\nvm.assign_access_port(1, 10)\nvm.assign_access_port(2, 10)\nvm.assign_access_port(3, 20)\nprint(vm.can_communicate(1, 2))  # True\nprint(vm.can_communicate(1, 3))  # False",
    "solution": "class VLANManager:\n    def __init__(self, num_ports):\n        self.num_ports = num_ports\n        self.port_vlans = {}\n        self.trunk_ports = set()\n    \n    def assign_access_port(self, port, vlan):\n        self.port_vlans[port] = {vlan}\n        self.trunk_ports.discard(port)\n    \n    def assign_trunk_port(self, port, vlans):\n        self.port_vlans[port] = set(vlans)\n        self.trunk_ports.add(port)\n    \n    def can_communicate(self, port1, port2):\n        vlans1 = self.port_vlans.get(port1, set())\n        vlans2 = self.port_vlans.get(port2, set())\n        return bool(vlans1 & vlans2)  # Check intersection\n\nvm = VLANManager(24)\nvm.assign_access_port(1, 10)\nvm.assign_access_port(2, 10)\nvm.assign_access_port(3, 20)\nprint(vm.can_communicate(1, 2))\nprint(vm.can_communicate(1, 3))",
    "testCases": [
      {
        "input": "same VLAN",
        "isHidden": false,
        "description": "Can communicate"
      },
      {
        "input": "different VLAN",
        "isHidden": false,
        "description": "Isolated"
      },
      {
        "input": "trunk port",
        "isHidden": true,
        "description": "Multiple VLANs"
      }
    ],
    "hints": [
      "Access port: single VLAN",
      "Trunk port: multiple VLANs (carries tags)",
      "Ports communicate if they share a VLAN",
      "Use set intersection to check overlap"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Load Balancer",
    "difficulty": 3,
    "description": "Implement a simple load balancer with round-robin distribution across backend servers.",
    "starterCode": "class LoadBalancer:\n    def __init__(self, servers):\n        self.servers = servers  # list of server addresses\n        self.current = 0\n        self.connections = {s: 0 for s in servers}\n    \n    def get_server(self):\n        # Return next server using round-robin\n        pass\n    \n    def get_stats(self):\n        # Return connection counts per server\n        pass\n\n# Test your class\nlb = LoadBalancer([\"server1\", \"server2\", \"server3\"])\nfor _ in range(10):\n    print(lb.get_server())\nprint(lb.get_stats())",
    "solution": "class LoadBalancer:\n    def __init__(self, servers):\n        self.servers = servers\n        self.current = 0\n        self.connections = {s: 0 for s in servers}\n    \n    def get_server(self):\n        server = self.servers[self.current]\n        self.connections[server] += 1\n        self.current = (self.current + 1) % len(self.servers)\n        return server\n    \n    def get_stats(self):\n        return self.connections.copy()\n\nlb = LoadBalancer([\"server1\", \"server2\", \"server3\"])\nfor _ in range(10):\n    print(lb.get_server())\nprint(lb.get_stats())",
    "testCases": [
      {
        "input": "10 requests to 3 servers",
        "isHidden": false,
        "description": "Round-robin distribution"
      },
      {
        "input": "stats check",
        "isHidden": true,
        "description": "Balanced connections"
      }
    ],
    "hints": [
      "Round-robin: cycle through servers in order",
      "Use modulo to wrap around server list",
      "Track connection counts per server",
      "Return current server, then increment"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Least Connections Load Balancer",
    "difficulty": 3,
    "description": "Implement a load balancer using least-connections algorithm. Route to server with fewest active connections.",
    "starterCode": "class LeastConnectionsLB:\n    def __init__(self, servers):\n        self.servers = servers\n        self.active_connections = {s: 0 for s in servers}\n    \n    def get_server(self):\n        # Return server with least active connections\n        pass\n    \n    def release_connection(self, server):\n        # Mark a connection as completed\n        pass\n\n# Test your class\nlb = LeastConnectionsLB([\"A\", \"B\", \"C\"])\nprint(lb.get_server())  # A (0 connections)\nprint(lb.get_server())  # B (0 connections)\nlb.release_connection(\"A\")\nprint(lb.get_server())  # A (back to 0)",
    "solution": "class LeastConnectionsLB:\n    def __init__(self, servers):\n        self.servers = servers\n        self.active_connections = {s: 0 for s in servers}\n    \n    def get_server(self):\n        # Find server with minimum connections\n        server = min(self.servers, key=lambda s: self.active_connections[s])\n        self.active_connections[server] += 1\n        return server\n    \n    def release_connection(self, server):\n        if server in self.active_connections and self.active_connections[server] > 0:\n            self.active_connections[server] -= 1\n\nlb = LeastConnectionsLB([\"A\", \"B\", \"C\"])\nprint(lb.get_server())\nprint(lb.get_server())\nlb.release_connection(\"A\")\nprint(lb.get_server())",
    "testCases": [
      {
        "input": "initial requests",
        "isHidden": false,
        "description": "Equal distribution"
      },
      {
        "input": "after release",
        "isHidden": true,
        "description": "Routes to freed server"
      }
    ],
    "hints": [
      "Find server with minimum active connections",
      "Use min() with key function",
      "Increment count when assigning",
      "Decrement when connection completes"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Multicast Group Manager",
    "difficulty": 3,
    "description": "Manage multicast group memberships. Track which hosts have joined which multicast groups.",
    "starterCode": "class MulticastManager:\n    def __init__(self):\n        self.groups = {}  # group_ip -> set of members\n    \n    def join_group(self, host, group_ip):\n        # Host joins multicast group\n        pass\n    \n    def leave_group(self, host, group_ip):\n        # Host leaves multicast group\n        pass\n    \n    def get_members(self, group_ip):\n        # Return set of hosts in group\n        pass\n    \n    def get_groups(self, host):\n        # Return groups that host belongs to\n        pass\n\n# Test your class\nmm = MulticastManager()\nmm.join_group(\"host1\", \"224.0.0.1\")\nmm.join_group(\"host2\", \"224.0.0.1\")\nmm.join_group(\"host1\", \"224.0.0.2\")\nprint(mm.get_members(\"224.0.0.1\"))\nprint(mm.get_groups(\"host1\"))",
    "solution": "class MulticastManager:\n    def __init__(self):\n        self.groups = {}\n    \n    def join_group(self, host, group_ip):\n        if group_ip not in self.groups:\n            self.groups[group_ip] = set()\n        self.groups[group_ip].add(host)\n    \n    def leave_group(self, host, group_ip):\n        if group_ip in self.groups:\n            self.groups[group_ip].discard(host)\n            if not self.groups[group_ip]:\n                del self.groups[group_ip]\n    \n    def get_members(self, group_ip):\n        return self.groups.get(group_ip, set()).copy()\n    \n    def get_groups(self, host):\n        return {g for g, members in self.groups.items() if host in members}\n\nmm = MulticastManager()\nmm.join_group(\"host1\", \"224.0.0.1\")\nmm.join_group(\"host2\", \"224.0.0.1\")\nmm.join_group(\"host1\", \"224.0.0.2\")\nprint(mm.get_members(\"224.0.0.1\"))\nprint(mm.get_groups(\"host1\"))",
    "testCases": [
      {
        "input": "join groups",
        "isHidden": false,
        "description": "Group membership"
      },
      {
        "input": "host groups",
        "isHidden": true,
        "description": "Reverse lookup"
      }
    ],
    "hints": [
      "Multicast: 224.0.0.0 - 239.255.255.255",
      "Use set for group members",
      "Clean up empty groups on leave",
      "Support both directions of lookup"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "VPN Tunnel Simulator",
    "difficulty": 4,
    "description": "Simulate VPN encapsulation. Wrap an inner packet with VPN header containing tunnel endpoints.",
    "starterCode": "# Simulate VPN encapsulation\ndef encapsulate_vpn(inner_packet, tunnel_src, tunnel_dst, tunnel_id):\n    # Return encapsulated packet structure\n    pass\n\ndef decapsulate_vpn(vpn_packet):\n    # Extract inner packet from VPN encapsulation\n    pass\n\n# Test your functions\ninner = {\"src\": \"192.168.1.10\", \"dst\": \"192.168.2.20\", \"data\": \"Hello\"}\nvpn_pkt = encapsulate_vpn(inner, \"1.2.3.4\", \"5.6.7.8\", 100)\nprint(vpn_pkt)\nprint(decapsulate_vpn(vpn_pkt))",
    "solution": "def encapsulate_vpn(inner_packet, tunnel_src, tunnel_dst, tunnel_id):\n    return {\n        \"outer_src\": tunnel_src,\n        \"outer_dst\": tunnel_dst,\n        \"tunnel_id\": tunnel_id,\n        \"protocol\": \"VPN\",\n        \"inner_packet\": inner_packet\n    }\n\ndef decapsulate_vpn(vpn_packet):\n    return vpn_packet.get(\"inner_packet\")\n\ninner = {\"src\": \"192.168.1.10\", \"dst\": \"192.168.2.20\", \"data\": \"Hello\"}\nvpn_pkt = encapsulate_vpn(inner, \"1.2.3.4\", \"5.6.7.8\", 100)\nprint(vpn_pkt)\nprint(decapsulate_vpn(vpn_pkt))",
    "testCases": [
      {
        "input": "encapsulate inner packet",
        "isHidden": false,
        "description": "Add VPN header"
      },
      {
        "input": "decapsulate",
        "isHidden": true,
        "description": "Extract original"
      }
    ],
    "hints": [
      "VPN wraps original packet with new header",
      "Outer header has tunnel endpoint addresses",
      "Inner packet travels encrypted through tunnel",
      "Decapsulation reveals original packet"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "MPLS Label Stack",
    "difficulty": 4,
    "description": "Implement MPLS label operations: push, pop, and swap labels on a label stack.",
    "starterCode": "class MPLSPacket:\n    def __init__(self, payload):\n        self.label_stack = []  # Bottom of stack first\n        self.payload = payload\n    \n    def push_label(self, label, ttl=64):\n        # Push label onto stack\n        pass\n    \n    def pop_label(self):\n        # Pop and return top label\n        pass\n    \n    def swap_label(self, new_label):\n        # Replace top label\n        pass\n    \n    def top_label(self):\n        # Peek at top label without removing\n        pass\n\n# Test your class\npkt = MPLSPacket(\"data\")\npkt.push_label(100)\npkt.push_label(200)\nprint(pkt.top_label())  # 200\npkt.swap_label(300)\nprint(pkt.pop_label())  # 300\nprint(pkt.top_label())  # 100",
    "solution": "class MPLSPacket:\n    def __init__(self, payload):\n        self.label_stack = []\n        self.payload = payload\n    \n    def push_label(self, label, ttl=64):\n        self.label_stack.append({\"label\": label, \"ttl\": ttl})\n    \n    def pop_label(self):\n        if self.label_stack:\n            return self.label_stack.pop()\n        return None\n    \n    def swap_label(self, new_label):\n        if self.label_stack:\n            old_ttl = self.label_stack[-1][\"ttl\"]\n            self.label_stack[-1] = {\"label\": new_label, \"ttl\": old_ttl - 1}\n    \n    def top_label(self):\n        if self.label_stack:\n            return self.label_stack[-1][\"label\"]\n        return None\n\npkt = MPLSPacket(\"data\")\npkt.push_label(100)\npkt.push_label(200)\nprint(pkt.top_label())\npkt.swap_label(300)\nprint(pkt.pop_label())\nprint(pkt.top_label())",
    "testCases": [
      {
        "input": "push and pop",
        "isHidden": false,
        "description": "Stack operations"
      },
      {
        "input": "swap label",
        "isHidden": true,
        "description": "Label swap"
      }
    ],
    "hints": [
      "MPLS uses label stack (LIFO)",
      "Push: add label to top",
      "Pop: remove from top",
      "Swap: replace top label, preserve TTL"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Firewall Rule Engine",
    "difficulty": 4,
    "description": "Implement a simple firewall rule engine. Support allow/deny rules with source/dest IP and port matching.",
    "starterCode": "class Firewall:\n    def __init__(self):\n        self.rules = []\n    \n    def add_rule(self, action, src_ip, dst_ip, dst_port):\n        # action: \"allow\" or \"deny\"\n        # Use \"*\" for any\n        pass\n    \n    def check_packet(self, src_ip, dst_ip, dst_port):\n        # Return \"allow\" or \"deny\" (default deny)\n        pass\n\n# Test your class\nfw = Firewall()\nfw.add_rule(\"allow\", \"*\", \"192.168.1.1\", 80)\nfw.add_rule(\"deny\", \"10.0.0.0/8\", \"*\", \"*\")\nprint(fw.check_packet(\"5.5.5.5\", \"192.168.1.1\", 80))  # allow\nprint(fw.check_packet(\"10.0.0.1\", \"1.1.1.1\", 443))   # deny",
    "solution": "class Firewall:\n    def __init__(self):\n        self.rules = []\n    \n    def add_rule(self, action, src_ip, dst_ip, dst_port):\n        self.rules.append({\n            \"action\": action,\n            \"src_ip\": src_ip,\n            \"dst_ip\": dst_ip,\n            \"dst_port\": dst_port\n        })\n    \n    def _match_ip(self, rule_ip, actual_ip):\n        if rule_ip == \"*\":\n            return True\n        if \"/\" in rule_ip:\n            # CIDR match (simplified)\n            network, prefix = rule_ip.split(\"/\")\n            prefix = int(prefix)\n            net_parts = [int(x) for x in network.split(\".\")]\n            ip_parts = [int(x) for x in actual_ip.split(\".\")]\n            # Compare prefix bits\n            for i in range(prefix // 8):\n                if net_parts[i] != ip_parts[i]:\n                    return False\n            return True\n        return rule_ip == actual_ip\n    \n    def check_packet(self, src_ip, dst_ip, dst_port):\n        for rule in self.rules:\n            if (self._match_ip(rule[\"src_ip\"], src_ip) and\n                self._match_ip(rule[\"dst_ip\"], dst_ip) and\n                (rule[\"dst_port\"] == \"*\" or rule[\"dst_port\"] == dst_port)):\n                return rule[\"action\"]\n        return \"deny\"  # Default deny\n\nfw = Firewall()\nfw.add_rule(\"allow\", \"*\", \"192.168.1.1\", 80)\nfw.add_rule(\"deny\", \"10.0.0.0/8\", \"*\", \"*\")\nprint(fw.check_packet(\"5.5.5.5\", \"192.168.1.1\", 80))\nprint(fw.check_packet(\"10.0.0.1\", \"1.1.1.1\", 443))",
    "testCases": [
      {
        "input": "allowed traffic",
        "isHidden": false,
        "description": "Match allow rule"
      },
      {
        "input": "blocked traffic",
        "isHidden": true,
        "description": "Match deny rule"
      }
    ],
    "hints": [
      "Process rules in order, first match wins",
      "Support wildcards (*) for any",
      "Support CIDR notation for IP ranges",
      "Default action is deny"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "SDN Flow Table",
    "difficulty": 4,
    "description": "Implement a simple SDN (Software-Defined Networking) flow table. Match on packet fields and execute actions.",
    "starterCode": "class FlowTable:\n    def __init__(self):\n        self.flows = []  # (priority, match, actions)\n    \n    def add_flow(self, priority, match, actions):\n        # match: dict of fields to match\n        # actions: list of action strings\n        pass\n    \n    def process_packet(self, packet):\n        # Return actions for matching flow, or None\n        pass\n\n# Test your class\nft = FlowTable()\nft.add_flow(100, {\"dst_port\": 80}, [\"output:1\"])\nft.add_flow(50, {\"src_ip\": \"10.0.0.0/8\"}, [\"drop\"])\nprint(ft.process_packet({\"src_ip\": \"5.5.5.5\", \"dst_port\": 80}))",
    "solution": "class FlowTable:\n    def __init__(self):\n        self.flows = []\n    \n    def add_flow(self, priority, match, actions):\n        self.flows.append((priority, match, actions))\n        # Sort by priority (higher first)\n        self.flows.sort(key=lambda x: -x[0])\n    \n    def _match_field(self, match_value, packet_value):\n        if \"/\" in str(match_value):\n            # CIDR match\n            network, prefix = match_value.split(\"/\")\n            prefix = int(prefix)\n            net_parts = [int(x) for x in network.split(\".\")]\n            ip_parts = [int(x) for x in packet_value.split(\".\")]\n            for i in range(prefix // 8):\n                if net_parts[i] != ip_parts[i]:\n                    return False\n            return True\n        return match_value == packet_value\n    \n    def process_packet(self, packet):\n        for priority, match, actions in self.flows:\n            matched = True\n            for field, value in match.items():\n                if field not in packet or not self._match_field(value, packet[field]):\n                    matched = False\n                    break\n            if matched:\n                return actions\n        return None\n\nft = FlowTable()\nft.add_flow(100, {\"dst_port\": 80}, [\"output:1\"])\nft.add_flow(50, {\"src_ip\": \"10.0.0.0/8\"}, [\"drop\"])\nprint(ft.process_packet({\"src_ip\": \"5.5.5.5\", \"dst_port\": 80}))",
    "testCases": [
      {
        "input": "match dst_port",
        "isHidden": false,
        "description": "Port match"
      },
      {
        "input": "priority order",
        "isHidden": true,
        "description": "Higher priority wins"
      }
    ],
    "hints": [
      "Higher priority flows checked first",
      "All match fields must match",
      "Support wildcard via omitting field",
      "Return actions of first matching flow"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "BGP Path Selector",
    "difficulty": 5,
    "description": "Implement simplified BGP path selection. Compare paths based on AS path length and prefer shorter paths.",
    "starterCode": "# BGP Path Selection\nclass BGPPath:\n    def __init__(self, prefix, as_path, next_hop, local_pref=100):\n        self.prefix = prefix\n        self.as_path = as_path  # list of AS numbers\n        self.next_hop = next_hop\n        self.local_pref = local_pref\n\ndef select_best_path(paths):\n    # Return best path based on BGP selection rules\n    pass\n\n# Test\npaths = [\n    BGPPath(\"10.0.0.0/8\", [100, 200, 300], \"1.1.1.1\"),\n    BGPPath(\"10.0.0.0/8\", [100, 200], \"2.2.2.2\"),\n    BGPPath(\"10.0.0.0/8\", [100, 200, 300], \"3.3.3.3\", local_pref=200)\n]\nbest = select_best_path(paths)\nprint(f\"Best: {best.next_hop}, AS path: {best.as_path}\")",
    "solution": "class BGPPath:\n    def __init__(self, prefix, as_path, next_hop, local_pref=100):\n        self.prefix = prefix\n        self.as_path = as_path\n        self.next_hop = next_hop\n        self.local_pref = local_pref\n\ndef select_best_path(paths):\n    if not paths:\n        return None\n    \n    # BGP selection criteria (simplified):\n    # 1. Highest local preference\n    # 2. Shortest AS path\n    # 3. Lowest next-hop (tiebreaker)\n    \n    def path_key(path):\n        return (\n            -path.local_pref,      # Higher is better (negate)\n            len(path.as_path),     # Shorter is better\n            path.next_hop          # Tiebreaker\n        )\n    \n    return min(paths, key=path_key)\n\npaths = [\n    BGPPath(\"10.0.0.0/8\", [100, 200, 300], \"1.1.1.1\"),\n    BGPPath(\"10.0.0.0/8\", [100, 200], \"2.2.2.2\"),\n    BGPPath(\"10.0.0.0/8\", [100, 200, 300], \"3.3.3.3\", local_pref=200)\n]\nbest = select_best_path(paths)\nprint(f\"Best: {best.next_hop}, AS path: {best.as_path}\")",
    "testCases": [
      {
        "input": "different path lengths",
        "isHidden": false,
        "description": "Prefer shorter"
      },
      {
        "input": "different local_pref",
        "isHidden": true,
        "description": "Higher pref wins"
      }
    ],
    "hints": [
      "BGP prefers: highest local preference",
      "Then: shortest AS path length",
      "Then: various tiebreakers",
      "Use tuple comparison for multi-criteria sort"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Network Simulator Hop Counter",
    "difficulty": 3,
    "description": "Simulate packet routing through a network. Count hops and check if destination is reachable.",
    "starterCode": "# Network hop simulation\nclass NetworkSimulator:\n    def __init__(self):\n        self.topology = {}  # node -> list of (neighbor, cost)\n    \n    def add_link(self, node1, node2, cost=1):\n        # Add bidirectional link\n        pass\n    \n    def route_packet(self, src, dst, max_hops=30):\n        # Return (hops, path) or (-1, []) if unreachable\n        pass\n\n# Test your class\nnet = NetworkSimulator()\nnet.add_link(\"A\", \"B\")\nnet.add_link(\"B\", \"C\")\nnet.add_link(\"C\", \"D\")\nprint(net.route_packet(\"A\", \"D\"))",
    "solution": "from collections import deque\n\nclass NetworkSimulator:\n    def __init__(self):\n        self.topology = {}\n    \n    def add_link(self, node1, node2, cost=1):\n        if node1 not in self.topology:\n            self.topology[node1] = []\n        if node2 not in self.topology:\n            self.topology[node2] = []\n        self.topology[node1].append((node2, cost))\n        self.topology[node2].append((node1, cost))\n    \n    def route_packet(self, src, dst, max_hops=30):\n        if src not in self.topology:\n            return (-1, [])\n        \n        # BFS for shortest path\n        queue = deque([(src, [src])])\n        visited = {src}\n        \n        while queue:\n            node, path = queue.popleft()\n            if len(path) - 1 > max_hops:\n                break\n            if node == dst:\n                return (len(path) - 1, path)\n            for neighbor, _ in self.topology.get(node, []):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        \n        return (-1, [])\n\nnet = NetworkSimulator()\nnet.add_link(\"A\", \"B\")\nnet.add_link(\"B\", \"C\")\nnet.add_link(\"C\", \"D\")\nprint(net.route_packet(\"A\", \"D\"))",
    "testCases": [
      {
        "input": "A to D",
        "isHidden": false,
        "description": "Multi-hop path"
      },
      {
        "input": "unreachable",
        "isHidden": true,
        "description": "No path exists"
      }
    ],
    "hints": [
      "Use BFS for shortest hop count",
      "Track visited nodes to avoid loops",
      "Return both hop count and path",
      "Respect max_hops limit (like TTL)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "DHCP Lease Manager",
    "difficulty": 3,
    "description": "Implement a simple DHCP lease manager. Allocate IPs from a pool and track lease expiration.",
    "starterCode": "import time\n\nclass DHCPServer:\n    def __init__(self, start_ip, end_ip, lease_time=3600):\n        self.pool = []  # Available IPs\n        self.leases = {}  # IP -> (mac, expiry)\n        self.lease_time = lease_time\n        # Initialize pool\n    \n    def allocate(self, mac_address):\n        # Return allocated IP or None\n        pass\n    \n    def release(self, ip):\n        # Release IP back to pool\n        pass\n\n# Test your class\ndhcp = DHCPServer(\"192.168.1.100\", \"192.168.1.110\")\nprint(dhcp.allocate(\"AA:BB:CC:DD:EE:FF\"))\nprint(dhcp.allocate(\"11:22:33:44:55:66\"))",
    "solution": "import time\n\nclass DHCPServer:\n    def __init__(self, start_ip, end_ip, lease_time=3600):\n        self.leases = {}\n        self.lease_time = lease_time\n        self.mac_to_ip = {}\n        \n        # Generate IP pool\n        def ip_to_int(ip):\n            parts = [int(x) for x in ip.split(\".\")]\n            return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3]\n        \n        def int_to_ip(num):\n            return f\"{(num >> 24) & 0xFF}.{(num >> 16) & 0xFF}.{(num >> 8) & 0xFF}.{num & 0xFF}\"\n        \n        start = ip_to_int(start_ip)\n        end = ip_to_int(end_ip)\n        self.pool = [int_to_ip(i) for i in range(start, end + 1)]\n    \n    def allocate(self, mac_address):\n        # Check for existing lease\n        if mac_address in self.mac_to_ip:\n            ip = self.mac_to_ip[mac_address]\n            self.leases[ip] = (mac_address, time.time() + self.lease_time)\n            return ip\n        \n        # Allocate new IP\n        if self.pool:\n            ip = self.pool.pop(0)\n            self.leases[ip] = (mac_address, time.time() + self.lease_time)\n            self.mac_to_ip[mac_address] = ip\n            return ip\n        return None\n    \n    def release(self, ip):\n        if ip in self.leases:\n            mac, _ = self.leases[ip]\n            del self.leases[ip]\n            del self.mac_to_ip[mac]\n            self.pool.append(ip)\n\ndhcp = DHCPServer(\"192.168.1.100\", \"192.168.1.110\")\nprint(dhcp.allocate(\"AA:BB:CC:DD:EE:FF\"))\nprint(dhcp.allocate(\"11:22:33:44:55:66\"))",
    "testCases": [
      {
        "input": "allocate two IPs",
        "isHidden": false,
        "description": "Sequential allocation"
      },
      {
        "input": "same MAC gets same IP",
        "isHidden": true,
        "description": "Lease renewal"
      }
    ],
    "hints": [
      "Generate IP pool from range",
      "Track MAC address to IP mapping",
      "Return same IP for same MAC (renewal)",
      "Release returns IP to pool"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t5-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-5",
    "title": "Network Bandwidth Monitor",
    "difficulty": 3,
    "description": "Monitor network bandwidth usage. Track bytes transferred and calculate rates over time windows.",
    "starterCode": "import time\n\nclass BandwidthMonitor:\n    def __init__(self, window_seconds=60):\n        self.window = window_seconds\n        self.samples = []  # (timestamp, bytes)\n    \n    def record(self, bytes_transferred):\n        # Record a transfer\n        pass\n    \n    def get_rate_mbps(self):\n        # Get current bandwidth rate in Mbps\n        pass\n    \n    def get_total_mb(self):\n        # Get total MB in current window\n        pass\n\n# Test your class\nbw = BandwidthMonitor(window_seconds=10)\nbw.record(1000000)  # 1 MB\nbw.record(2000000)  # 2 MB\nprint(f\"Rate: {bw.get_rate_mbps()} Mbps\")\nprint(f\"Total: {bw.get_total_mb()} MB\")",
    "solution": "import time\n\nclass BandwidthMonitor:\n    def __init__(self, window_seconds=60):\n        self.window = window_seconds\n        self.samples = []\n    \n    def _cleanup(self):\n        cutoff = time.time() - self.window\n        self.samples = [(t, b) for t, b in self.samples if t > cutoff]\n    \n    def record(self, bytes_transferred):\n        self.samples.append((time.time(), bytes_transferred))\n        self._cleanup()\n    \n    def get_rate_mbps(self):\n        self._cleanup()\n        if not self.samples:\n            return 0.0\n        total_bytes = sum(b for _, b in self.samples)\n        # Calculate rate based on window\n        elapsed = min(self.window, time.time() - self.samples[0][0]) if self.samples else self.window\n        if elapsed == 0:\n            return 0.0\n        bytes_per_second = total_bytes / elapsed\n        return round(bytes_per_second * 8 / 1_000_000, 2)\n    \n    def get_total_mb(self):\n        self._cleanup()\n        total_bytes = sum(b for _, b in self.samples)\n        return round(total_bytes / 1_000_000, 2)\n\nbw = BandwidthMonitor(window_seconds=10)\nbw.record(1000000)\nbw.record(2000000)\nprint(f\"Rate: {bw.get_rate_mbps()} Mbps\")\nprint(f\"Total: {bw.get_total_mb()} MB\")",
    "testCases": [
      {
        "input": "record and query",
        "isHidden": false,
        "description": "Basic monitoring"
      },
      {
        "input": "window expiry",
        "isHidden": true,
        "description": "Old samples removed"
      }
    ],
    "hints": [
      "Store samples with timestamps",
      "Remove old samples outside window",
      "Rate = total bytes / time elapsed",
      "Convert bytes to bits for Mbps"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Socket Address Parser",
    "difficulty": 1,
    "description": "Parse a socket address string into IP and port components. Handle formats like \"192.168.1.1:8080\".",
    "starterCode": "# Parse socket address\ndef parse_address(address):\n    # Return tuple: (ip, port)\n    pass\n\n# Test your function\nprint(parse_address(\"192.168.1.1:8080\"))\nprint(parse_address(\"127.0.0.1:80\"))",
    "solution": "def parse_address(address):\n    parts = address.rsplit(\":\", 1)\n    ip = parts[0]\n    port = int(parts[1])\n    return (ip, port)\n\nprint(parse_address(\"192.168.1.1:8080\"))\nprint(parse_address(\"127.0.0.1:80\"))",
    "testCases": [
      {
        "input": "\"192.168.1.1:8080\"",
        "isHidden": false,
        "description": "Standard format"
      },
      {
        "input": "\"127.0.0.1:80\"",
        "isHidden": false,
        "description": "Localhost"
      },
      {
        "input": "\"10.0.0.1:443\"",
        "isHidden": true,
        "description": "HTTPS port"
      }
    ],
    "hints": [
      "Split on the last colon",
      "Use rsplit with maxsplit=1",
      "Convert port to integer",
      "Return as tuple (ip, port)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Socket Type Selector",
    "difficulty": 1,
    "description": "Given a use case, return the appropriate socket type (SOCK_STREAM for TCP, SOCK_DGRAM for UDP).",
    "starterCode": "import socket\n\n# Select appropriate socket type\ndef get_socket_type(use_case):\n    # Return socket.SOCK_STREAM or socket.SOCK_DGRAM\n    pass\n\n# Test your function\nprint(get_socket_type(\"file_transfer\"))\nprint(get_socket_type(\"video_streaming\"))\nprint(get_socket_type(\"web_browsing\"))",
    "solution": "import socket\n\ndef get_socket_type(use_case):\n    tcp_uses = [\"file_transfer\", \"web_browsing\", \"email\", \"ssh\", \"http\", \"https\", \"ftp\"]\n    udp_uses = [\"video_streaming\", \"voip\", \"dns_query\", \"gaming\", \"broadcast\"]\n    \n    use_case_lower = use_case.lower()\n    if use_case_lower in tcp_uses:\n        return socket.SOCK_STREAM\n    elif use_case_lower in udp_uses:\n        return socket.SOCK_DGRAM\n    # Default to TCP for reliability\n    return socket.SOCK_STREAM\n\nprint(get_socket_type(\"file_transfer\"))\nprint(get_socket_type(\"video_streaming\"))\nprint(get_socket_type(\"web_browsing\"))",
    "testCases": [
      {
        "input": "\"file_transfer\"",
        "isHidden": false,
        "description": "TCP for files"
      },
      {
        "input": "\"video_streaming\"",
        "isHidden": false,
        "description": "UDP for video"
      },
      {
        "input": "\"dns_query\"",
        "isHidden": true,
        "description": "UDP for DNS"
      }
    ],
    "hints": [
      "TCP (SOCK_STREAM): reliable, ordered delivery",
      "UDP (SOCK_DGRAM): fast, no guarantee",
      "File transfer needs reliability (TCP)",
      "Streaming prefers low latency (UDP)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Socket State Machine",
    "difficulty": 3,
    "description": "Implement a simplified TCP socket state machine for client-side connection.",
    "starterCode": "class ClientSocket:\n    def __init__(self):\n        self.state = \"CLOSED\"\n    \n    def connect(self):\n        # Transition through connection states\n        pass\n    \n    def send(self, data):\n        # Send data (only if connected)\n        pass\n    \n    def close(self):\n        # Close connection\n        pass\n    \n    def get_state(self):\n        return self.state\n\n# Test your class\nsock = ClientSocket()\nprint(sock.get_state())  # CLOSED\nsock.connect()\nprint(sock.get_state())  # ESTABLISHED",
    "solution": "class ClientSocket:\n    def __init__(self):\n        self.state = \"CLOSED\"\n    \n    def connect(self):\n        if self.state == \"CLOSED\":\n            self.state = \"SYN_SENT\"\n            # Simulate handshake completion\n            self.state = \"ESTABLISHED\"\n            return True\n        return False\n    \n    def send(self, data):\n        if self.state == \"ESTABLISHED\":\n            return len(data)\n        raise ConnectionError(\"Socket not connected\")\n    \n    def close(self):\n        if self.state == \"ESTABLISHED\":\n            self.state = \"FIN_WAIT\"\n            # Simulate close completion\n            self.state = \"CLOSED\"\n            return True\n        elif self.state != \"CLOSED\":\n            self.state = \"CLOSED\"\n            return True\n        return False\n    \n    def get_state(self):\n        return self.state\n\nsock = ClientSocket()\nprint(sock.get_state())\nsock.connect()\nprint(sock.get_state())",
    "testCases": [
      {
        "input": "initial state",
        "isHidden": false,
        "description": "CLOSED"
      },
      {
        "input": "after connect",
        "isHidden": false,
        "description": "ESTABLISHED"
      },
      {
        "input": "send when closed",
        "isHidden": true,
        "description": "Error"
      }
    ],
    "hints": [
      "Start in CLOSED state",
      "connect() -> SYN_SENT -> ESTABLISHED",
      "send() only works in ESTABLISHED",
      "close() -> FIN_WAIT -> CLOSED"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Message Framing",
    "difficulty": 2,
    "description": "Implement message framing for TCP streams. Add length prefix to messages and extract messages from buffered data.",
    "starterCode": "# Frame a message with length prefix\ndef frame_message(message):\n    # Return bytes with 4-byte length prefix\n    pass\n\ndef unframe_messages(buffer):\n    # Extract complete messages from buffer\n    # Return (list of messages, remaining buffer)\n    pass\n\n# Test your functions\nframed = frame_message(b\"Hello\")\nprint(framed)\nmsgs, remaining = unframe_messages(framed + frame_message(b\"World\"))\nprint(msgs)",
    "solution": "import struct\n\ndef frame_message(message):\n    if isinstance(message, str):\n        message = message.encode()\n    length = len(message)\n    return struct.pack(\">I\", length) + message\n\ndef unframe_messages(buffer):\n    messages = []\n    while len(buffer) >= 4:\n        length = struct.unpack(\">I\", buffer[:4])[0]\n        if len(buffer) < 4 + length:\n            break\n        messages.append(buffer[4:4+length])\n        buffer = buffer[4+length:]\n    return (messages, buffer)\n\nframed = frame_message(b\"Hello\")\nprint(framed)\nmsgs, remaining = unframe_messages(framed + frame_message(b\"World\"))\nprint(msgs)",
    "testCases": [
      {
        "input": "frame \"Hello\"",
        "isHidden": false,
        "description": "Add length prefix"
      },
      {
        "input": "unframe multiple",
        "isHidden": true,
        "description": "Extract messages"
      }
    ],
    "hints": [
      "Use struct.pack(\">I\", length) for 4-byte big-endian int",
      "Prefix message with its length",
      "When unframing, check if full message received",
      "Return remaining buffer for incomplete messages"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Non-blocking Socket Simulator",
    "difficulty": 3,
    "description": "Simulate non-blocking socket behavior. Track buffer state and return appropriate results for read/write operations.",
    "starterCode": "class NonBlockingSocket:\n    def __init__(self, recv_buffer_size=1024):\n        self.recv_buffer = b\"\"\n        self.send_buffer = b\"\"\n        self.recv_buffer_size = recv_buffer_size\n        self.connected = False\n    \n    def recv(self, size):\n        # Return data or raise WouldBlock\n        pass\n    \n    def send(self, data):\n        # Return bytes sent or raise WouldBlock\n        pass\n    \n    # Helper to simulate data arrival\n    def _add_recv_data(self, data):\n        self.recv_buffer += data\n\nclass WouldBlock(Exception):\n    pass\n\n# Test your class\nsock = NonBlockingSocket()\nsock._add_recv_data(b\"Hello\")\nprint(sock.recv(10))",
    "solution": "class WouldBlock(Exception):\n    pass\n\nclass NonBlockingSocket:\n    def __init__(self, recv_buffer_size=1024):\n        self.recv_buffer = b\"\"\n        self.send_buffer = b\"\"\n        self.recv_buffer_size = recv_buffer_size\n        self.connected = True\n    \n    def recv(self, size):\n        if not self.recv_buffer:\n            raise WouldBlock(\"No data available\")\n        data = self.recv_buffer[:size]\n        self.recv_buffer = self.recv_buffer[size:]\n        return data\n    \n    def send(self, data):\n        if len(self.send_buffer) >= self.recv_buffer_size:\n            raise WouldBlock(\"Buffer full\")\n        available = self.recv_buffer_size - len(self.send_buffer)\n        to_send = min(len(data), available)\n        self.send_buffer += data[:to_send]\n        return to_send\n    \n    def _add_recv_data(self, data):\n        self.recv_buffer += data\n\nsock = NonBlockingSocket()\nsock._add_recv_data(b\"Hello\")\nprint(sock.recv(10))",
    "testCases": [
      {
        "input": "recv with data",
        "isHidden": false,
        "description": "Returns data"
      },
      {
        "input": "recv empty buffer",
        "isHidden": true,
        "description": "Raises WouldBlock"
      }
    ],
    "hints": [
      "Non-blocking: return immediately or raise WouldBlock",
      "recv returns available data up to size",
      "send returns bytes actually sent",
      "Check buffer space before operations"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Echo Server Logic",
    "difficulty": 2,
    "description": "Implement the core logic of an echo server. Process received data and return it back.",
    "starterCode": "class EchoServer:\n    def __init__(self):\n        self.connections = {}  # client_id -> buffer\n    \n    def on_connect(self, client_id):\n        # Handle new connection\n        pass\n    \n    def on_data(self, client_id, data):\n        # Handle received data, return response\n        pass\n    \n    def on_disconnect(self, client_id):\n        # Handle disconnection\n        pass\n\n# Test your class\nserver = EchoServer()\nserver.on_connect(\"client1\")\nresponse = server.on_data(\"client1\", b\"Hello World\")\nprint(response)",
    "solution": "class EchoServer:\n    def __init__(self):\n        self.connections = {}\n    \n    def on_connect(self, client_id):\n        self.connections[client_id] = b\"\"\n        return True\n    \n    def on_data(self, client_id, data):\n        if client_id not in self.connections:\n            return None\n        # Echo the data back\n        return data\n    \n    def on_disconnect(self, client_id):\n        if client_id in self.connections:\n            del self.connections[client_id]\n            return True\n        return False\n\nserver = EchoServer()\nserver.on_connect(\"client1\")\nresponse = server.on_data(\"client1\", b\"Hello World\")\nprint(response)",
    "testCases": [
      {
        "input": "send data",
        "isHidden": false,
        "description": "Echo back"
      },
      {
        "input": "unknown client",
        "isHidden": true,
        "description": "Return None"
      }
    ],
    "hints": [
      "Track connected clients",
      "Echo: return the same data received",
      "Clean up on disconnect",
      "Handle unknown clients gracefully"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "UDP Datagram Handler",
    "difficulty": 2,
    "description": "Handle UDP datagrams with source tracking. Store messages by source address.",
    "starterCode": "class UDPHandler:\n    def __init__(self):\n        self.messages = {}  # source_addr -> list of messages\n    \n    def receive(self, data, source_addr):\n        # Store message from source\n        pass\n    \n    def get_messages(self, source_addr):\n        # Get all messages from source\n        pass\n    \n    def get_sources(self):\n        # Get all known source addresses\n        pass\n\n# Test your class\nhandler = UDPHandler()\nhandler.receive(b\"Hello\", (\"192.168.1.1\", 5000))\nhandler.receive(b\"World\", (\"192.168.1.1\", 5000))\nhandler.receive(b\"Test\", (\"192.168.1.2\", 5001))\nprint(handler.get_messages((\"192.168.1.1\", 5000)))",
    "solution": "class UDPHandler:\n    def __init__(self):\n        self.messages = {}\n    \n    def receive(self, data, source_addr):\n        if source_addr not in self.messages:\n            self.messages[source_addr] = []\n        self.messages[source_addr].append(data)\n    \n    def get_messages(self, source_addr):\n        return self.messages.get(source_addr, []).copy()\n    \n    def get_sources(self):\n        return list(self.messages.keys())\n\nhandler = UDPHandler()\nhandler.receive(b\"Hello\", (\"192.168.1.1\", 5000))\nhandler.receive(b\"World\", (\"192.168.1.1\", 5000))\nhandler.receive(b\"Test\", (\"192.168.1.2\", 5001))\nprint(handler.get_messages((\"192.168.1.1\", 5000)))",
    "testCases": [
      {
        "input": "messages from one source",
        "isHidden": false,
        "description": "Grouped by source"
      },
      {
        "input": "get all sources",
        "isHidden": true,
        "description": "List sources"
      }
    ],
    "hints": [
      "UDP includes source address with each datagram",
      "Group messages by (ip, port) tuple",
      "Return copy of messages to prevent modification",
      "Handle unknown sources gracefully"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Connection Pool Manager",
    "difficulty": 3,
    "description": "Implement a connection pool for socket connections. Manage a fixed pool of reusable connections.",
    "starterCode": "class ConnectionPool:\n    def __init__(self, max_connections):\n        self.max_connections = max_connections\n        self.available = []  # Available connections\n        self.in_use = set()  # Connections being used\n    \n    def acquire(self):\n        # Get a connection from pool (create if needed)\n        # Return connection or None if at max\n        pass\n    \n    def release(self, conn):\n        # Return connection to pool\n        pass\n    \n    def stats(self):\n        # Return pool statistics\n        pass\n\n# Test your class\npool = ConnectionPool(3)\nc1 = pool.acquire()\nc2 = pool.acquire()\nprint(pool.stats())\npool.release(c1)\nprint(pool.stats())",
    "solution": "class ConnectionPool:\n    def __init__(self, max_connections):\n        self.max_connections = max_connections\n        self.available = []\n        self.in_use = set()\n        self.next_id = 0\n    \n    def _create_connection(self):\n        conn_id = f\"conn_{self.next_id}\"\n        self.next_id += 1\n        return conn_id\n    \n    def acquire(self):\n        if self.available:\n            conn = self.available.pop()\n            self.in_use.add(conn)\n            return conn\n        elif len(self.in_use) < self.max_connections:\n            conn = self._create_connection()\n            self.in_use.add(conn)\n            return conn\n        return None\n    \n    def release(self, conn):\n        if conn in self.in_use:\n            self.in_use.remove(conn)\n            self.available.append(conn)\n            return True\n        return False\n    \n    def stats(self):\n        return {\n            \"available\": len(self.available),\n            \"in_use\": len(self.in_use),\n            \"total\": len(self.available) + len(self.in_use),\n            \"max\": self.max_connections\n        }\n\npool = ConnectionPool(3)\nc1 = pool.acquire()\nc2 = pool.acquire()\nprint(pool.stats())\npool.release(c1)\nprint(pool.stats())",
    "testCases": [
      {
        "input": "acquire two connections",
        "isHidden": false,
        "description": "Track in use"
      },
      {
        "input": "release and reacquire",
        "isHidden": true,
        "description": "Connection reuse"
      }
    ],
    "hints": [
      "Reuse available connections first",
      "Create new if under max limit",
      "Return None if at capacity",
      "Released connections become available"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Select/Poll Simulator",
    "difficulty": 4,
    "description": "Simulate I/O multiplexing with select/poll. Track sockets ready for reading or writing.",
    "starterCode": "class IOMultiplexer:\n    def __init__(self):\n        self.read_sockets = {}  # socket_id -> has_data\n        self.write_sockets = {}  # socket_id -> can_write\n    \n    def register_read(self, socket_id):\n        # Register socket for read monitoring\n        pass\n    \n    def register_write(self, socket_id):\n        # Register socket for write monitoring\n        pass\n    \n    def select(self):\n        # Return (readable, writable) socket lists\n        pass\n    \n    # Helpers for testing\n    def _set_readable(self, socket_id, readable=True):\n        self.read_sockets[socket_id] = readable\n    \n    def _set_writable(self, socket_id, writable=True):\n        self.write_sockets[socket_id] = writable\n\n# Test your class\nmux = IOMultiplexer()\nmux.register_read(\"sock1\")\nmux.register_read(\"sock2\")\nmux.register_write(\"sock1\")\nmux._set_readable(\"sock1\", True)\nmux._set_writable(\"sock1\", True)\nprint(mux.select())",
    "solution": "class IOMultiplexer:\n    def __init__(self):\n        self.read_sockets = {}\n        self.write_sockets = {}\n    \n    def register_read(self, socket_id):\n        self.read_sockets[socket_id] = False\n    \n    def register_write(self, socket_id):\n        self.write_sockets[socket_id] = False\n    \n    def unregister(self, socket_id):\n        self.read_sockets.pop(socket_id, None)\n        self.write_sockets.pop(socket_id, None)\n    \n    def select(self):\n        readable = [sid for sid, ready in self.read_sockets.items() if ready]\n        writable = [sid for sid, ready in self.write_sockets.items() if ready]\n        return (readable, writable)\n    \n    def _set_readable(self, socket_id, readable=True):\n        if socket_id in self.read_sockets:\n            self.read_sockets[socket_id] = readable\n    \n    def _set_writable(self, socket_id, writable=True):\n        if socket_id in self.write_sockets:\n            self.write_sockets[socket_id] = writable\n\nmux = IOMultiplexer()\nmux.register_read(\"sock1\")\nmux.register_read(\"sock2\")\nmux.register_write(\"sock1\")\nmux._set_readable(\"sock1\", True)\nmux._set_writable(\"sock1\", True)\nprint(mux.select())",
    "testCases": [
      {
        "input": "select ready sockets",
        "isHidden": false,
        "description": "Returns ready sockets"
      },
      {
        "input": "no ready sockets",
        "isHidden": true,
        "description": "Empty lists"
      }
    ],
    "hints": [
      "Track sockets registered for read/write",
      "select() returns lists of ready sockets",
      "A socket can be monitored for both read and write",
      "Only return sockets that are ready"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Socket Buffer Manager",
    "difficulty": 3,
    "description": "Manage send and receive buffers for a socket. Handle partial reads/writes.",
    "starterCode": "class SocketBuffer:\n    def __init__(self, recv_size=4096, send_size=4096):\n        self.recv_buffer = b\"\"\n        self.send_buffer = b\"\"\n        self.recv_size = recv_size\n        self.send_size = send_size\n    \n    def queue_send(self, data):\n        # Add data to send buffer, return bytes queued\n        pass\n    \n    def get_send_data(self, max_bytes):\n        # Get data to send (remove from buffer)\n        pass\n    \n    def add_recv_data(self, data):\n        # Add received data to buffer\n        pass\n    \n    def read_recv_data(self, max_bytes):\n        # Read from receive buffer\n        pass\n\n# Test your class\nbuf = SocketBuffer(recv_size=100, send_size=100)\nbuf.queue_send(b\"Hello World\")\nprint(buf.get_send_data(5))\nprint(buf.get_send_data(100))",
    "solution": "class SocketBuffer:\n    def __init__(self, recv_size=4096, send_size=4096):\n        self.recv_buffer = b\"\"\n        self.send_buffer = b\"\"\n        self.recv_size = recv_size\n        self.send_size = send_size\n    \n    def queue_send(self, data):\n        available = self.send_size - len(self.send_buffer)\n        to_queue = min(len(data), available)\n        self.send_buffer += data[:to_queue]\n        return to_queue\n    \n    def get_send_data(self, max_bytes):\n        to_send = min(max_bytes, len(self.send_buffer))\n        data = self.send_buffer[:to_send]\n        self.send_buffer = self.send_buffer[to_send:]\n        return data\n    \n    def add_recv_data(self, data):\n        available = self.recv_size - len(self.recv_buffer)\n        to_add = min(len(data), available)\n        self.recv_buffer += data[:to_add]\n        return to_add\n    \n    def read_recv_data(self, max_bytes):\n        to_read = min(max_bytes, len(self.recv_buffer))\n        data = self.recv_buffer[:to_read]\n        self.recv_buffer = self.recv_buffer[to_read:]\n        return data\n\nbuf = SocketBuffer(recv_size=100, send_size=100)\nbuf.queue_send(b\"Hello World\")\nprint(buf.get_send_data(5))\nprint(buf.get_send_data(100))",
    "testCases": [
      {
        "input": "queue and get send data",
        "isHidden": false,
        "description": "Partial read"
      },
      {
        "input": "buffer full",
        "isHidden": true,
        "description": "Respect limits"
      }
    ],
    "hints": [
      "Track available space in each buffer",
      "Partial operations are common",
      "Remove data after it's retrieved",
      "Return amount actually queued/read"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "DNS Resolver Mock",
    "difficulty": 3,
    "description": "Implement a mock DNS resolver for socket programming. Support forward and reverse lookups.",
    "starterCode": "class DNSResolver:\n    def __init__(self):\n        self.forward = {}  # hostname -> list of IPs\n        self.reverse = {}  # IP -> hostname\n    \n    def add_record(self, hostname, ip):\n        # Add A record\n        pass\n    \n    def resolve(self, hostname):\n        # Forward lookup: hostname -> IP\n        pass\n    \n    def reverse_lookup(self, ip):\n        # Reverse lookup: IP -> hostname\n        pass\n\n# Test your class\ndns = DNSResolver()\ndns.add_record(\"example.com\", \"93.184.216.34\")\ndns.add_record(\"example.com\", \"93.184.216.35\")\nprint(dns.resolve(\"example.com\"))\nprint(dns.reverse_lookup(\"93.184.216.34\"))",
    "solution": "class DNSResolver:\n    def __init__(self):\n        self.forward = {}\n        self.reverse = {}\n    \n    def add_record(self, hostname, ip):\n        hostname = hostname.lower()\n        if hostname not in self.forward:\n            self.forward[hostname] = []\n        if ip not in self.forward[hostname]:\n            self.forward[hostname].append(ip)\n        self.reverse[ip] = hostname\n    \n    def resolve(self, hostname):\n        hostname = hostname.lower()\n        ips = self.forward.get(hostname, [])\n        return ips[0] if ips else None\n    \n    def resolve_all(self, hostname):\n        hostname = hostname.lower()\n        return self.forward.get(hostname, []).copy()\n    \n    def reverse_lookup(self, ip):\n        return self.reverse.get(ip)\n\ndns = DNSResolver()\ndns.add_record(\"example.com\", \"93.184.216.34\")\ndns.add_record(\"example.com\", \"93.184.216.35\")\nprint(dns.resolve(\"example.com\"))\nprint(dns.reverse_lookup(\"93.184.216.34\"))",
    "testCases": [
      {
        "input": "forward lookup",
        "isHidden": false,
        "description": "Hostname to IP"
      },
      {
        "input": "reverse lookup",
        "isHidden": true,
        "description": "IP to hostname"
      }
    ],
    "hints": [
      "One hostname can have multiple IPs (A records)",
      "resolve() returns first IP",
      "Reverse maps IP back to hostname",
      "Normalize hostname to lowercase"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Chat Protocol Parser",
    "difficulty": 3,
    "description": "Parse a simple chat protocol. Messages format: \"USER:MESSAGE\\n\"",
    "starterCode": "class ChatProtocol:\n    def __init__(self):\n        self.buffer = \"\"\n    \n    def add_data(self, data):\n        # Add received data to buffer\n        pass\n    \n    def get_messages(self):\n        # Extract complete messages\n        # Return list of (user, message) tuples\n        pass\n\n# Test your class\nchat = ChatProtocol()\nchat.add_data(\"alice:Hello\\nbob:Hi there\\ncharlie:Par\")\nprint(chat.get_messages())\nchat.add_data(\"tial message\\n\")\nprint(chat.get_messages())",
    "solution": "class ChatProtocol:\n    def __init__(self):\n        self.buffer = \"\"\n    \n    def add_data(self, data):\n        if isinstance(data, bytes):\n            data = data.decode()\n        self.buffer += data\n    \n    def get_messages(self):\n        messages = []\n        while \"\\n\" in self.buffer:\n            line, self.buffer = self.buffer.split(\"\\n\", 1)\n            if \":\" in line:\n                user, message = line.split(\":\", 1)\n                messages.append((user.strip(), message.strip()))\n        return messages\n\nchat = ChatProtocol()\nchat.add_data(\"alice:Hello\\nbob:Hi there\\ncharlie:Par\")\nprint(chat.get_messages())\nchat.add_data(\"tial message\\n\")\nprint(chat.get_messages())",
    "testCases": [
      {
        "input": "complete messages",
        "isHidden": false,
        "description": "Parse two messages"
      },
      {
        "input": "partial message",
        "isHidden": true,
        "description": "Buffer incomplete"
      }
    ],
    "hints": [
      "Messages are newline-terminated",
      "Split on first colon for user:message",
      "Buffer partial messages until complete",
      "Return list of (user, message) tuples"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Timeout Handler",
    "difficulty": 3,
    "description": "Implement socket operation timeout handling. Track operation start times and check for timeout.",
    "starterCode": "import time\n\nclass TimeoutHandler:\n    def __init__(self, timeout_seconds):\n        self.timeout = timeout_seconds\n        self.operations = {}  # op_id -> start_time\n    \n    def start_operation(self, op_id):\n        # Start timing an operation\n        pass\n    \n    def check_timeout(self, op_id):\n        # Return True if operation has timed out\n        pass\n    \n    def complete_operation(self, op_id):\n        # Mark operation complete\n        pass\n    \n    def get_remaining(self, op_id):\n        # Get remaining time before timeout\n        pass\n\n# Test your class\nth = TimeoutHandler(5)\nth.start_operation(\"connect\")\nprint(th.get_remaining(\"connect\"))",
    "solution": "import time\n\nclass TimeoutHandler:\n    def __init__(self, timeout_seconds):\n        self.timeout = timeout_seconds\n        self.operations = {}\n    \n    def start_operation(self, op_id):\n        self.operations[op_id] = time.time()\n    \n    def check_timeout(self, op_id):\n        if op_id not in self.operations:\n            return False\n        elapsed = time.time() - self.operations[op_id]\n        return elapsed >= self.timeout\n    \n    def complete_operation(self, op_id):\n        if op_id in self.operations:\n            del self.operations[op_id]\n            return True\n        return False\n    \n    def get_remaining(self, op_id):\n        if op_id not in self.operations:\n            return 0\n        elapsed = time.time() - self.operations[op_id]\n        remaining = self.timeout - elapsed\n        return max(0, remaining)\n\nth = TimeoutHandler(5)\nth.start_operation(\"connect\")\nprint(th.get_remaining(\"connect\"))",
    "testCases": [
      {
        "input": "get remaining time",
        "isHidden": false,
        "description": "Time before timeout"
      },
      {
        "input": "check timeout",
        "isHidden": true,
        "description": "After timeout"
      }
    ],
    "hints": [
      "Store start time for each operation",
      "Elapsed = current_time - start_time",
      "Timed out if elapsed >= timeout",
      "Remaining = timeout - elapsed (min 0)"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Rate Limiter for Connections",
    "difficulty": 3,
    "description": "Implement connection rate limiting. Limit connections per client IP per time window.",
    "starterCode": "import time\n\nclass ConnectionRateLimiter:\n    def __init__(self, max_connections, window_seconds):\n        self.max_connections = max_connections\n        self.window = window_seconds\n        self.connections = {}  # ip -> list of timestamps\n    \n    def allow_connection(self, ip):\n        # Return True if connection allowed\n        pass\n    \n    def get_count(self, ip):\n        # Get current connection count for IP\n        pass\n\n# Test your class\nrl = ConnectionRateLimiter(max_connections=3, window_seconds=60)\nprint(rl.allow_connection(\"192.168.1.1\"))  # True\nprint(rl.allow_connection(\"192.168.1.1\"))  # True\nprint(rl.allow_connection(\"192.168.1.1\"))  # True\nprint(rl.allow_connection(\"192.168.1.1\"))  # False",
    "solution": "import time\n\nclass ConnectionRateLimiter:\n    def __init__(self, max_connections, window_seconds):\n        self.max_connections = max_connections\n        self.window = window_seconds\n        self.connections = {}\n    \n    def _cleanup(self, ip):\n        if ip in self.connections:\n            cutoff = time.time() - self.window\n            self.connections[ip] = [t for t in self.connections[ip] if t > cutoff]\n    \n    def allow_connection(self, ip):\n        self._cleanup(ip)\n        \n        if ip not in self.connections:\n            self.connections[ip] = []\n        \n        if len(self.connections[ip]) < self.max_connections:\n            self.connections[ip].append(time.time())\n            return True\n        return False\n    \n    def get_count(self, ip):\n        self._cleanup(ip)\n        return len(self.connections.get(ip, []))\n\nrl = ConnectionRateLimiter(max_connections=3, window_seconds=60)\nprint(rl.allow_connection(\"192.168.1.1\"))\nprint(rl.allow_connection(\"192.168.1.1\"))\nprint(rl.allow_connection(\"192.168.1.1\"))\nprint(rl.allow_connection(\"192.168.1.1\"))",
    "testCases": [
      {
        "input": "within limit",
        "isHidden": false,
        "description": "Connections allowed"
      },
      {
        "input": "exceed limit",
        "isHidden": false,
        "description": "Connection denied"
      },
      {
        "input": "after window",
        "isHidden": true,
        "description": "Old connections expire"
      }
    ],
    "hints": [
      "Track connection timestamps per IP",
      "Remove timestamps outside window",
      "Count only recent connections",
      "Allow if under max_connections"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Binary Protocol Builder",
    "difficulty": 4,
    "description": "Build binary protocol messages with structured fields. Support common field types.",
    "starterCode": "import struct\n\nclass BinaryProtocol:\n    def __init__(self):\n        self.buffer = b\"\"\n    \n    def add_byte(self, value):\n        pass\n    \n    def add_uint16(self, value):\n        pass\n    \n    def add_uint32(self, value):\n        pass\n    \n    def add_string(self, value):\n        # Length-prefixed string\n        pass\n    \n    def build(self):\n        # Return built message\n        pass\n\n# Test your class\nprot = BinaryProtocol()\nprot.add_byte(1)        # Message type\nprot.add_uint16(100)    # Sequence\nprot.add_string(\"Hello\")\nprint(prot.build().hex())",
    "solution": "import struct\n\nclass BinaryProtocol:\n    def __init__(self):\n        self.buffer = b\"\"\n    \n    def add_byte(self, value):\n        self.buffer += struct.pack(\">B\", value)\n        return self\n    \n    def add_uint16(self, value):\n        self.buffer += struct.pack(\">H\", value)\n        return self\n    \n    def add_uint32(self, value):\n        self.buffer += struct.pack(\">I\", value)\n        return self\n    \n    def add_string(self, value):\n        if isinstance(value, str):\n            value = value.encode()\n        # Length prefix (2 bytes) + string data\n        self.buffer += struct.pack(\">H\", len(value)) + value\n        return self\n    \n    def build(self):\n        result = self.buffer\n        self.buffer = b\"\"\n        return result\n\nprot = BinaryProtocol()\nprot.add_byte(1)\nprot.add_uint16(100)\nprot.add_string(\"Hello\")\nprint(prot.build().hex())",
    "testCases": [
      {
        "input": "build protocol message",
        "isHidden": false,
        "description": "Binary format"
      },
      {
        "input": "string encoding",
        "isHidden": true,
        "description": "Length-prefixed"
      }
    ],
    "hints": [
      "Use struct.pack for binary encoding",
      ">B = unsigned byte, >H = uint16, >I = uint32",
      "> means big-endian (network byte order)",
      "Strings: length prefix + data"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t6-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-6",
    "title": "Keep-Alive Manager",
    "difficulty": 3,
    "description": "Manage connection keep-alive. Track last activity and identify idle connections.",
    "starterCode": "import time\n\nclass KeepAliveManager:\n    def __init__(self, timeout_seconds=30):\n        self.timeout = timeout_seconds\n        self.connections = {}  # conn_id -> last_activity\n    \n    def add_connection(self, conn_id):\n        pass\n    \n    def update_activity(self, conn_id):\n        pass\n    \n    def get_idle_connections(self):\n        # Return list of connections that have timed out\n        pass\n    \n    def remove_connection(self, conn_id):\n        pass\n\n# Test your class\nkam = KeepAliveManager(timeout_seconds=5)\nkam.add_connection(\"conn1\")\nkam.add_connection(\"conn2\")\nkam.update_activity(\"conn1\")\nprint(kam.get_idle_connections())",
    "solution": "import time\n\nclass KeepAliveManager:\n    def __init__(self, timeout_seconds=30):\n        self.timeout = timeout_seconds\n        self.connections = {}\n    \n    def add_connection(self, conn_id):\n        self.connections[conn_id] = time.time()\n    \n    def update_activity(self, conn_id):\n        if conn_id in self.connections:\n            self.connections[conn_id] = time.time()\n    \n    def get_idle_connections(self):\n        current = time.time()\n        idle = []\n        for conn_id, last_activity in self.connections.items():\n            if current - last_activity > self.timeout:\n                idle.append(conn_id)\n        return idle\n    \n    def remove_connection(self, conn_id):\n        if conn_id in self.connections:\n            del self.connections[conn_id]\n            return True\n        return False\n\nkam = KeepAliveManager(timeout_seconds=5)\nkam.add_connection(\"conn1\")\nkam.add_connection(\"conn2\")\nkam.update_activity(\"conn1\")\nprint(kam.get_idle_connections())",
    "testCases": [
      {
        "input": "track connections",
        "isHidden": false,
        "description": "Update activity"
      },
      {
        "input": "identify idle",
        "isHidden": true,
        "description": "Timeout detection"
      }
    ],
    "hints": [
      "Track last activity timestamp per connection",
      "Update timestamp on any activity",
      "Idle if current_time - last_activity > timeout",
      "Return list of timed-out connections"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex01",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "HTTP Request Parser",
    "difficulty": 2,
    "description": "Parse an HTTP request line. Extract method, path, and HTTP version.",
    "starterCode": "# Parse HTTP request line\ndef parse_request_line(line):\n    # Return dict with: method, path, version\n    pass\n\n# Test your function\nprint(parse_request_line(\"GET /index.html HTTP/1.1\"))\nprint(parse_request_line(\"POST /api/users HTTP/1.1\"))",
    "solution": "def parse_request_line(line):\n    parts = line.strip().split(\" \")\n    if len(parts) != 3:\n        return None\n    return {\n        \"method\": parts[0],\n        \"path\": parts[1],\n        \"version\": parts[2]\n    }\n\nprint(parse_request_line(\"GET /index.html HTTP/1.1\"))\nprint(parse_request_line(\"POST /api/users HTTP/1.1\"))",
    "testCases": [
      {
        "input": "\"GET /index.html HTTP/1.1\"",
        "isHidden": false,
        "description": "GET request"
      },
      {
        "input": "\"POST /api/users HTTP/1.1\"",
        "isHidden": false,
        "description": "POST request"
      },
      {
        "input": "\"DELETE /api/item/5 HTTP/1.1\"",
        "isHidden": true,
        "description": "DELETE request"
      }
    ],
    "hints": [
      "Request line format: METHOD PATH HTTP/VERSION",
      "Split by spaces",
      "Exactly 3 parts expected",
      "Common methods: GET, POST, PUT, DELETE"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex02",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "HTTP Header Parser",
    "difficulty": 2,
    "description": "Parse HTTP headers from a string. Return a dictionary of header names to values.",
    "starterCode": "# Parse HTTP headers\ndef parse_headers(header_text):\n    # Return dict of header: value pairs\n    pass\n\n# Test your function\nheaders = \"\"\"Host: example.com\nContent-Type: application/json\nContent-Length: 42\"\"\"\nprint(parse_headers(headers))",
    "solution": "def parse_headers(header_text):\n    headers = {}\n    for line in header_text.strip().split(\"\\n\"):\n        if \":\" in line:\n            name, value = line.split(\":\", 1)\n            headers[name.strip()] = value.strip()\n    return headers\n\nheaders = \"\"\"Host: example.com\nContent-Type: application/json\nContent-Length: 42\"\"\"\nprint(parse_headers(headers))",
    "testCases": [
      {
        "input": "standard headers",
        "isHidden": false,
        "description": "Parse three headers"
      },
      {
        "input": "header with colon in value",
        "isHidden": true,
        "description": "Handle colons"
      }
    ],
    "hints": [
      "Headers format: Name: Value",
      "Split on first colon only",
      "Strip whitespace from both parts",
      "One header per line"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex03",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "HTTP Response Builder",
    "difficulty": 3,
    "description": "Build an HTTP response with status line, headers, and body.",
    "starterCode": "# Build HTTP response\ndef build_response(status_code, headers, body):\n    # Return complete HTTP response string\n    pass\n\n# Test your function\nresponse = build_response(\n    200,\n    {\"Content-Type\": \"text/html\"},\n    \"<h1>Hello</h1>\"\n)\nprint(response)",
    "solution": "def build_response(status_code, headers, body):\n    status_messages = {\n        200: \"OK\",\n        201: \"Created\",\n        400: \"Bad Request\",\n        404: \"Not Found\",\n        500: \"Internal Server Error\"\n    }\n    status_msg = status_messages.get(status_code, \"Unknown\")\n    \n    # Add Content-Length if not present\n    if \"Content-Length\" not in headers:\n        headers[\"Content-Length\"] = len(body.encode() if isinstance(body, str) else body)\n    \n    # Build response\n    lines = [f\"HTTP/1.1 {status_code} {status_msg}\"]\n    for name, value in headers.items():\n        lines.append(f\"{name}: {value}\")\n    lines.append(\"\")  # Empty line before body\n    lines.append(body)\n    \n    return \"\\r\\n\".join(lines)\n\nresponse = build_response(\n    200,\n    {\"Content-Type\": \"text/html\"},\n    \"<h1>Hello</h1>\"\n)\nprint(response)",
    "testCases": [
      {
        "input": "200 OK response",
        "isHidden": false,
        "description": "Success response"
      },
      {
        "input": "404 Not Found",
        "isHidden": true,
        "description": "Error response"
      }
    ],
    "hints": [
      "Status line: HTTP/1.1 CODE MESSAGE",
      "Headers: Name: Value (one per line)",
      "Blank line separates headers from body",
      "Use \\r\\n for line endings in HTTP"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex04",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "URL Parser",
    "difficulty": 2,
    "description": "Parse a URL into its components: scheme, host, port, path, and query string.",
    "starterCode": "# Parse URL components\ndef parse_url(url):\n    # Return dict with: scheme, host, port, path, query\n    pass\n\n# Test your function\nprint(parse_url(\"https://example.com:8080/api/users?id=5\"))\nprint(parse_url(\"http://localhost/index.html\"))",
    "solution": "def parse_url(url):\n    result = {\n        \"scheme\": \"\",\n        \"host\": \"\",\n        \"port\": None,\n        \"path\": \"/\",\n        \"query\": \"\"\n    }\n    \n    # Extract scheme\n    if \"://\" in url:\n        result[\"scheme\"], url = url.split(\"://\", 1)\n    \n    # Extract path and query\n    if \"/\" in url:\n        host_part, path_part = url.split(\"/\", 1)\n        result[\"path\"] = \"/\" + path_part\n    else:\n        host_part = url\n    \n    # Extract query\n    if \"?\" in result[\"path\"]:\n        result[\"path\"], result[\"query\"] = result[\"path\"].split(\"?\", 1)\n    \n    # Extract port\n    if \":\" in host_part:\n        result[\"host\"], port = host_part.split(\":\")\n        result[\"port\"] = int(port)\n    else:\n        result[\"host\"] = host_part\n        # Default ports\n        if result[\"scheme\"] == \"https\":\n            result[\"port\"] = 443\n        elif result[\"scheme\"] == \"http\":\n            result[\"port\"] = 80\n    \n    return result\n\nprint(parse_url(\"https://example.com:8080/api/users?id=5\"))\nprint(parse_url(\"http://localhost/index.html\"))",
    "testCases": [
      {
        "input": "full URL with port and query",
        "isHidden": false,
        "description": "All components"
      },
      {
        "input": "simple URL",
        "isHidden": false,
        "description": "Default port"
      },
      {
        "input": "URL without path",
        "isHidden": true,
        "description": "Default path"
      }
    ],
    "hints": [
      "Split on :// for scheme",
      "Split on first / for host vs path",
      "Split on ? for path vs query",
      "Default port: 80 for http, 443 for https"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex05",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "Query String Parser",
    "difficulty": 2,
    "description": "Parse URL query string into key-value pairs. Handle URL encoding.",
    "starterCode": "from urllib.parse import unquote\n\n# Parse query string\ndef parse_query_string(query):\n    # Return dict of key: value pairs\n    pass\n\n# Test your function\nprint(parse_query_string(\"name=John&age=25&city=New%20York\"))\nprint(parse_query_string(\"search=hello+world&page=1\"))",
    "solution": "from urllib.parse import unquote_plus\n\ndef parse_query_string(query):\n    if not query:\n        return {}\n    \n    params = {}\n    for pair in query.split(\"&\"):\n        if \"=\" in pair:\n            key, value = pair.split(\"=\", 1)\n            # Decode URL encoding (+ and %XX)\n            params[unquote_plus(key)] = unquote_plus(value)\n        else:\n            params[pair] = \"\"\n    return params\n\nprint(parse_query_string(\"name=John&age=25&city=New%20York\"))\nprint(parse_query_string(\"search=hello+world&page=1\"))",
    "testCases": [
      {
        "input": "simple params",
        "isHidden": false,
        "description": "Parse key=value pairs"
      },
      {
        "input": "URL encoded",
        "isHidden": false,
        "description": "Decode %20 and +"
      },
      {
        "input": "empty value",
        "isHidden": true,
        "description": "Handle missing value"
      }
    ],
    "hints": [
      "Split on & for each parameter",
      "Split on = for key/value",
      "%20 and + both represent space",
      "Use unquote_plus for decoding"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex06",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "DNS Query Builder",
    "difficulty": 4,
    "description": "Build a simplified DNS query message. Create header and question section.",
    "starterCode": "import struct\nimport random\n\n# Build DNS query for a domain\ndef build_dns_query(domain, query_type=\"A\"):\n    # Return bytes representing DNS query\n    pass\n\n# Test your function\nquery = build_dns_query(\"example.com\")\nprint(query.hex())",
    "solution": "import struct\nimport random\n\ndef build_dns_query(domain, query_type=\"A\"):\n    # Query types\n    qtypes = {\"A\": 1, \"AAAA\": 28, \"MX\": 15, \"CNAME\": 5, \"NS\": 2}\n    qtype = qtypes.get(query_type, 1)\n    \n    # Header (12 bytes)\n    transaction_id = random.randint(0, 65535)\n    flags = 0x0100  # Standard query, recursion desired\n    questions = 1\n    answers = 0\n    authority = 0\n    additional = 0\n    \n    header = struct.pack(\">HHHHHH\",\n        transaction_id, flags, questions, answers, authority, additional)\n    \n    # Question section\n    question = b\"\"\n    for part in domain.split(\".\"):\n        question += struct.pack(\"B\", len(part)) + part.encode()\n    question += b\"\\x00\"  # Null terminator\n    question += struct.pack(\">HH\", qtype, 1)  # Type and class (IN=1)\n    \n    return header + question\n\nquery = build_dns_query(\"example.com\")\nprint(query.hex())",
    "testCases": [
      {
        "input": "example.com",
        "isHidden": false,
        "description": "A record query"
      },
      {
        "input": "MX query",
        "isHidden": true,
        "description": "Mail server query"
      }
    ],
    "hints": [
      "DNS header is 12 bytes",
      "Domain encoded as length-prefixed labels",
      "example.com -> 7example3com0",
      "QType 1=A, QClass 1=IN"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex07",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "SMTP Command Parser",
    "difficulty": 2,
    "description": "Parse SMTP commands and their arguments. Support HELO, MAIL FROM, RCPT TO, DATA.",
    "starterCode": "# Parse SMTP command\ndef parse_smtp_command(line):\n    # Return dict with: command, argument\n    pass\n\n# Test your function\nprint(parse_smtp_command(\"HELO mail.example.com\"))\nprint(parse_smtp_command(\"MAIL FROM:<sender@example.com>\"))\nprint(parse_smtp_command(\"RCPT TO:<recipient@example.com>\"))",
    "solution": "def parse_smtp_command(line):\n    line = line.strip()\n    \n    # Handle commands with special formats\n    if line.upper().startswith(\"MAIL FROM:\"):\n        return {\"command\": \"MAIL FROM\", \"argument\": line[10:].strip(\"<>\")}\n    elif line.upper().startswith(\"RCPT TO:\"):\n        return {\"command\": \"RCPT TO\", \"argument\": line[8:].strip(\"<>\")}\n    \n    # General command parsing\n    parts = line.split(\" \", 1)\n    command = parts[0].upper()\n    argument = parts[1] if len(parts) > 1 else \"\"\n    \n    return {\"command\": command, \"argument\": argument}\n\nprint(parse_smtp_command(\"HELO mail.example.com\"))\nprint(parse_smtp_command(\"MAIL FROM:<sender@example.com>\"))\nprint(parse_smtp_command(\"RCPT TO:<recipient@example.com>\"))",
    "testCases": [
      {
        "input": "HELO command",
        "isHidden": false,
        "description": "Simple command"
      },
      {
        "input": "MAIL FROM",
        "isHidden": false,
        "description": "Email address"
      },
      {
        "input": "DATA",
        "isHidden": true,
        "description": "No argument"
      }
    ],
    "hints": [
      "SMTP commands are case-insensitive",
      "MAIL FROM and RCPT TO have special format",
      "Remove angle brackets from addresses",
      "Split on first space for general commands"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex08",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "FTP Response Parser",
    "difficulty": 2,
    "description": "Parse FTP server responses. Extract status code and message.",
    "starterCode": "# Parse FTP response\ndef parse_ftp_response(response):\n    # Return dict with: code, message, is_multiline\n    pass\n\n# Test your function\nprint(parse_ftp_response(\"220 Welcome to FTP server\"))\nprint(parse_ftp_response(\"150-Opening data connection\\n150 for file transfer\"))",
    "solution": "def parse_ftp_response(response):\n    lines = response.strip().split(\"\\n\")\n    first_line = lines[0]\n    \n    # Check for multi-line response (code followed by -)\n    if len(first_line) >= 4 and first_line[3] == \"-\":\n        code = int(first_line[:3])\n        # Multi-line: collect until line starts with \"code \"\n        messages = [first_line[4:]]\n        for line in lines[1:]:\n            if line.startswith(f\"{code} \"):\n                messages.append(line[4:])\n                break\n            messages.append(line)\n        return {\n            \"code\": code,\n            \"message\": \"\\n\".join(messages),\n            \"is_multiline\": True\n        }\n    else:\n        code = int(first_line[:3])\n        message = first_line[4:] if len(first_line) > 4 else \"\"\n        return {\n            \"code\": code,\n            \"message\": message,\n            \"is_multiline\": False\n        }\n\nprint(parse_ftp_response(\"220 Welcome to FTP server\"))\nprint(parse_ftp_response(\"150-Opening data connection\\n150 for file transfer\"))",
    "testCases": [
      {
        "input": "single line response",
        "isHidden": false,
        "description": "Simple response"
      },
      {
        "input": "multi-line response",
        "isHidden": true,
        "description": "Code-message format"
      }
    ],
    "hints": [
      "FTP response: 3-digit code + space + message",
      "Multi-line: code + hyphen, ends with code + space",
      "Code ranges: 1xx=info, 2xx=success, 4xx/5xx=error",
      "Extract code as integer"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex09",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "Cookie Parser",
    "difficulty": 3,
    "description": "Parse HTTP Set-Cookie header. Extract cookie name, value, and attributes.",
    "starterCode": "# Parse Set-Cookie header\ndef parse_cookie(set_cookie):\n    # Return dict with: name, value, attributes\n    pass\n\n# Test your function\nprint(parse_cookie(\"session=abc123; Path=/; HttpOnly; Secure\"))\nprint(parse_cookie(\"user=john; Expires=Wed, 09 Jun 2025 10:18:14 GMT; Domain=.example.com\"))",
    "solution": "def parse_cookie(set_cookie):\n    parts = set_cookie.split(\";\")\n    \n    # First part is name=value\n    name_value = parts[0].strip()\n    if \"=\" in name_value:\n        name, value = name_value.split(\"=\", 1)\n    else:\n        name, value = name_value, \"\"\n    \n    # Parse attributes\n    attributes = {}\n    for part in parts[1:]:\n        part = part.strip()\n        if \"=\" in part:\n            attr_name, attr_value = part.split(\"=\", 1)\n            attributes[attr_name.lower()] = attr_value\n        else:\n            attributes[part.lower()] = True\n    \n    return {\n        \"name\": name.strip(),\n        \"value\": value.strip(),\n        \"attributes\": attributes\n    }\n\nprint(parse_cookie(\"session=abc123; Path=/; HttpOnly; Secure\"))\nprint(parse_cookie(\"user=john; Expires=Wed, 09 Jun 2025 10:18:14 GMT; Domain=.example.com\"))",
    "testCases": [
      {
        "input": "cookie with flags",
        "isHidden": false,
        "description": "HttpOnly, Secure"
      },
      {
        "input": "cookie with expires",
        "isHidden": true,
        "description": "Date attribute"
      }
    ],
    "hints": [
      "Format: name=value; attr1; attr2=value2",
      "First part is always name=value",
      "Attributes may or may not have values",
      "HttpOnly, Secure are flag attributes"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex10",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "JSON-RPC Request Builder",
    "difficulty": 3,
    "description": "Build JSON-RPC 2.0 request messages. Include method, params, and id.",
    "starterCode": "import json\n\n# Build JSON-RPC request\ndef build_jsonrpc_request(method, params=None, request_id=1):\n    # Return JSON string\n    pass\n\n# Test your function\nprint(build_jsonrpc_request(\"getUser\", {\"id\": 5}))\nprint(build_jsonrpc_request(\"listItems\", [1, 2, 3], 42))",
    "solution": "import json\n\ndef build_jsonrpc_request(method, params=None, request_id=1):\n    request = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": method,\n        \"id\": request_id\n    }\n    if params is not None:\n        request[\"params\"] = params\n    return json.dumps(request)\n\nprint(build_jsonrpc_request(\"getUser\", {\"id\": 5}))\nprint(build_jsonrpc_request(\"listItems\", [1, 2, 3], 42))",
    "testCases": [
      {
        "input": "named params",
        "isHidden": false,
        "description": "Object params"
      },
      {
        "input": "positional params",
        "isHidden": false,
        "description": "Array params"
      },
      {
        "input": "no params",
        "isHidden": true,
        "description": "Method only"
      }
    ],
    "hints": [
      "JSON-RPC 2.0 requires \"jsonrpc\": \"2.0\"",
      "method and id are required",
      "params is optional (object or array)",
      "Use json.dumps for encoding"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex11",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "WebSocket Frame Parser",
    "difficulty": 4,
    "description": "Parse a WebSocket frame header. Extract fin, opcode, mask flag, and payload length.",
    "starterCode": "# Parse WebSocket frame header\ndef parse_ws_header(header_bytes):\n    # Return dict with: fin, opcode, masked, payload_len\n    pass\n\n# Test your function\n# Binary: 10000001 00000101 = FIN=1, opcode=1 (text), len=5\nheader = bytes([0x81, 0x05])\nprint(parse_ws_header(header))",
    "solution": "def parse_ws_header(header_bytes):\n    if len(header_bytes) < 2:\n        return None\n    \n    byte1 = header_bytes[0]\n    byte2 = header_bytes[1]\n    \n    fin = (byte1 >> 7) & 1\n    opcode = byte1 & 0x0F\n    masked = (byte2 >> 7) & 1\n    payload_len = byte2 & 0x7F\n    \n    opcodes = {\n        0: \"continuation\",\n        1: \"text\",\n        2: \"binary\",\n        8: \"close\",\n        9: \"ping\",\n        10: \"pong\"\n    }\n    \n    return {\n        \"fin\": bool(fin),\n        \"opcode\": opcode,\n        \"opcode_name\": opcodes.get(opcode, \"unknown\"),\n        \"masked\": bool(masked),\n        \"payload_len\": payload_len\n    }\n\nheader = bytes([0x81, 0x05])\nprint(parse_ws_header(header))",
    "testCases": [
      {
        "input": "text frame",
        "isHidden": false,
        "description": "FIN=1, opcode=1"
      },
      {
        "input": "masked frame",
        "isHidden": true,
        "description": "Client to server"
      }
    ],
    "hints": [
      "Byte 1: FIN(1) + RSV(3) + opcode(4)",
      "Byte 2: MASK(1) + payload_len(7)",
      "Opcode 1=text, 2=binary, 8=close",
      "Client-to-server frames must be masked"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex12",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "MIME Type Detector",
    "difficulty": 2,
    "description": "Detect MIME type from file extension or magic bytes.",
    "starterCode": "# Detect MIME type\ndef detect_mime_type(filename=None, data=None):\n    # Return MIME type string\n    pass\n\n# Test your function\nprint(detect_mime_type(filename=\"image.png\"))\nprint(detect_mime_type(filename=\"document.pdf\"))\nprint(detect_mime_type(data=b\"\\x89PNG\\r\\n\\x1a\\n\"))",
    "solution": "def detect_mime_type(filename=None, data=None):\n    # Extension mapping\n    extensions = {\n        \".html\": \"text/html\",\n        \".htm\": \"text/html\",\n        \".css\": \"text/css\",\n        \".js\": \"application/javascript\",\n        \".json\": \"application/json\",\n        \".xml\": \"application/xml\",\n        \".txt\": \"text/plain\",\n        \".png\": \"image/png\",\n        \".jpg\": \"image/jpeg\",\n        \".jpeg\": \"image/jpeg\",\n        \".gif\": \"image/gif\",\n        \".svg\": \"image/svg+xml\",\n        \".pdf\": \"application/pdf\",\n        \".zip\": \"application/zip\"\n    }\n    \n    # Magic bytes\n    magic = {\n        b\"\\x89PNG\\r\\n\\x1a\\n\": \"image/png\",\n        b\"\\xff\\xd8\\xff\": \"image/jpeg\",\n        b\"GIF87a\": \"image/gif\",\n        b\"GIF89a\": \"image/gif\",\n        b\"%PDF\": \"application/pdf\",\n        b\"PK\\x03\\x04\": \"application/zip\"\n    }\n    \n    # Check magic bytes first\n    if data:\n        for signature, mime in magic.items():\n            if data.startswith(signature):\n                return mime\n    \n    # Check extension\n    if filename:\n        ext = \".\" + filename.split(\".\")[-1].lower() if \".\" in filename else \"\"\n        return extensions.get(ext, \"application/octet-stream\")\n    \n    return \"application/octet-stream\"\n\nprint(detect_mime_type(filename=\"image.png\"))\nprint(detect_mime_type(filename=\"document.pdf\"))\nprint(detect_mime_type(data=b\"\\x89PNG\\r\\n\\x1a\\n\"))",
    "testCases": [
      {
        "input": "filename with extension",
        "isHidden": false,
        "description": "By extension"
      },
      {
        "input": "magic bytes",
        "isHidden": true,
        "description": "By content"
      }
    ],
    "hints": [
      "Map file extensions to MIME types",
      "Magic bytes: first few bytes identify format",
      "PNG starts with \\x89PNG",
      "Default: application/octet-stream"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex13",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "HTTP Basic Auth Encoder",
    "difficulty": 2,
    "description": "Encode and decode HTTP Basic Authentication credentials.",
    "starterCode": "import base64\n\n# Encode Basic Auth\ndef encode_basic_auth(username, password):\n    # Return Authorization header value\n    pass\n\n# Decode Basic Auth\ndef decode_basic_auth(auth_header):\n    # Return (username, password) or None\n    pass\n\n# Test your functions\nauth = encode_basic_auth(\"admin\", \"secret\")\nprint(auth)\nprint(decode_basic_auth(auth))",
    "solution": "import base64\n\ndef encode_basic_auth(username, password):\n    credentials = f\"{username}:{password}\"\n    encoded = base64.b64encode(credentials.encode()).decode()\n    return f\"Basic {encoded}\"\n\ndef decode_basic_auth(auth_header):\n    if not auth_header.startswith(\"Basic \"):\n        return None\n    try:\n        encoded = auth_header[6:]\n        decoded = base64.b64decode(encoded).decode()\n        username, password = decoded.split(\":\", 1)\n        return (username, password)\n    except Exception:\n        return None\n\nauth = encode_basic_auth(\"admin\", \"secret\")\nprint(auth)\nprint(decode_basic_auth(auth))",
    "testCases": [
      {
        "input": "encode admin:secret",
        "isHidden": false,
        "description": "Encode credentials"
      },
      {
        "input": "decode back",
        "isHidden": false,
        "description": "Decode header"
      },
      {
        "input": "password with colon",
        "isHidden": true,
        "description": "Handle special chars"
      }
    ],
    "hints": [
      "Format: \"Basic \" + base64(username:password)",
      "Use base64.b64encode for encoding",
      "Split on first colon when decoding",
      "Password can contain colons"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex14",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "HTTP Cache Control Parser",
    "difficulty": 3,
    "description": "Parse HTTP Cache-Control header directives.",
    "starterCode": "# Parse Cache-Control header\ndef parse_cache_control(header):\n    # Return dict of directives\n    pass\n\n# Test your function\nprint(parse_cache_control(\"max-age=3600, no-cache, private\"))\nprint(parse_cache_control(\"public, max-age=86400, s-maxage=3600\"))",
    "solution": "def parse_cache_control(header):\n    directives = {}\n    \n    for part in header.split(\",\"):\n        part = part.strip().lower()\n        if \"=\" in part:\n            name, value = part.split(\"=\", 1)\n            # Try to convert to int if possible\n            try:\n                value = int(value)\n            except ValueError:\n                pass\n            directives[name.strip()] = value\n        else:\n            directives[part] = True\n    \n    return directives\n\nprint(parse_cache_control(\"max-age=3600, no-cache, private\"))\nprint(parse_cache_control(\"public, max-age=86400, s-maxage=3600\"))",
    "testCases": [
      {
        "input": "max-age and flags",
        "isHidden": false,
        "description": "Mixed directives"
      },
      {
        "input": "multiple max-age types",
        "isHidden": true,
        "description": "s-maxage"
      }
    ],
    "hints": [
      "Directives separated by commas",
      "Some have values (max-age=3600)",
      "Some are flags (no-cache, private)",
      "Convert numeric values to int"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex15",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "REST API Router",
    "difficulty": 4,
    "description": "Implement a simple REST API router. Match URL patterns and extract path parameters.",
    "starterCode": "class Router:\n    def __init__(self):\n        self.routes = []  # (method, pattern, handler_name)\n    \n    def add_route(self, method, pattern, handler):\n        # pattern like \"/users/:id\"\n        pass\n    \n    def match(self, method, path):\n        # Return (handler, params) or None\n        pass\n\n# Test your class\nrouter = Router()\nrouter.add_route(\"GET\", \"/users\", \"list_users\")\nrouter.add_route(\"GET\", \"/users/:id\", \"get_user\")\nrouter.add_route(\"POST\", \"/users\", \"create_user\")\n\nprint(router.match(\"GET\", \"/users\"))\nprint(router.match(\"GET\", \"/users/42\"))\nprint(router.match(\"POST\", \"/users\"))",
    "solution": "import re\n\nclass Router:\n    def __init__(self):\n        self.routes = []\n    \n    def add_route(self, method, pattern, handler):\n        # Convert :param to regex capture group\n        regex_pattern = pattern\n        param_names = []\n        \n        # Find all :param patterns\n        for match in re.finditer(r\":([a-zA-Z_]+)\", pattern):\n            param_names.append(match.group(1))\n        \n        # Replace :param with regex\n        regex_pattern = re.sub(r\":([a-zA-Z_]+)\", r\"([^/]+)\", pattern)\n        regex_pattern = f\"^{regex_pattern}$\"\n        \n        self.routes.append((method, regex_pattern, param_names, handler))\n    \n    def match(self, method, path):\n        for route_method, pattern, param_names, handler in self.routes:\n            if route_method != method:\n                continue\n            match = re.match(pattern, path)\n            if match:\n                params = dict(zip(param_names, match.groups()))\n                return (handler, params)\n        return None\n\nrouter = Router()\nrouter.add_route(\"GET\", \"/users\", \"list_users\")\nrouter.add_route(\"GET\", \"/users/:id\", \"get_user\")\nrouter.add_route(\"POST\", \"/users\", \"create_user\")\n\nprint(router.match(\"GET\", \"/users\"))\nprint(router.match(\"GET\", \"/users/42\"))\nprint(router.match(\"POST\", \"/users\"))",
    "testCases": [
      {
        "input": "exact match",
        "isHidden": false,
        "description": "Static route"
      },
      {
        "input": "param extraction",
        "isHidden": false,
        "description": ":id parameter"
      },
      {
        "input": "method mismatch",
        "isHidden": true,
        "description": "Wrong method"
      }
    ],
    "hints": [
      "Convert :param to regex capture groups",
      "Match method and path separately",
      "Extract captured groups as params",
      "First matching route wins"
    ],
    "language": "python"
  },
  {
    "id": "cs302-t7-ex16",
    "subjectId": "cs302",
    "topicId": "cs302-topic-7",
    "title": "TLS Certificate Parser",
    "difficulty": 4,
    "description": "Parse basic X.509 certificate information (simplified). Extract subject, issuer, and validity.",
    "starterCode": "# Simplified certificate parser (from dict representation)\ndef parse_certificate(cert_dict):\n    # cert_dict simulates parsed ASN.1 structure\n    # Return dict with: subject_cn, issuer_cn, valid_from, valid_to, is_expired\n    pass\n\n# Test with simulated certificate data\nfrom datetime import datetime, timedelta\n\ncert = {\n    \"subject\": {\"CN\": \"example.com\", \"O\": \"Example Inc\"},\n    \"issuer\": {\"CN\": \"Root CA\", \"O\": \"Certificate Authority\"},\n    \"not_before\": datetime.now() - timedelta(days=30),\n    \"not_after\": datetime.now() + timedelta(days=335)\n}\nprint(parse_certificate(cert))",
    "solution": "from datetime import datetime\n\ndef parse_certificate(cert_dict):\n    now = datetime.now()\n    \n    subject = cert_dict.get(\"subject\", {})\n    issuer = cert_dict.get(\"issuer\", {})\n    not_before = cert_dict.get(\"not_before\")\n    not_after = cert_dict.get(\"not_after\")\n    \n    is_expired = False\n    is_not_yet_valid = False\n    \n    if not_after and now > not_after:\n        is_expired = True\n    if not_before and now < not_before:\n        is_not_yet_valid = True\n    \n    days_until_expiry = None\n    if not_after:\n        delta = not_after - now\n        days_until_expiry = delta.days\n    \n    return {\n        \"subject_cn\": subject.get(\"CN\"),\n        \"subject_org\": subject.get(\"O\"),\n        \"issuer_cn\": issuer.get(\"CN\"),\n        \"issuer_org\": issuer.get(\"O\"),\n        \"valid_from\": not_before.isoformat() if not_before else None,\n        \"valid_to\": not_after.isoformat() if not_after else None,\n        \"is_expired\": is_expired,\n        \"is_not_yet_valid\": is_not_yet_valid,\n        \"days_until_expiry\": days_until_expiry\n    }\n\nfrom datetime import timedelta\ncert = {\n    \"subject\": {\"CN\": \"example.com\", \"O\": \"Example Inc\"},\n    \"issuer\": {\"CN\": \"Root CA\", \"O\": \"Certificate Authority\"},\n    \"not_before\": datetime.now() - timedelta(days=30),\n    \"not_after\": datetime.now() + timedelta(days=335)\n}\nprint(parse_certificate(cert))",
    "testCases": [
      {
        "input": "valid certificate",
        "isHidden": false,
        "description": "Extract fields"
      },
      {
        "input": "expired certificate",
        "isHidden": true,
        "description": "Check expiry"
      }
    ],
    "hints": [
      "CN = Common Name (domain or entity)",
      "O = Organization",
      "not_before/not_after define validity period",
      "Compare current time for expiry check"
    ],
    "language": "python"
  }
]
[
  {
    "id": "cs307-t3-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Password Strength Validator",
    "difficulty": 1,
    "description": "Check if password meets minimum requirements: at least 8 characters, contains uppercase, lowercase, and digit.",
    "starterCode": "def is_password_strong(password):\n    \"\"\"\n    Validate password strength.\n\n    Args:\n        password: String password to validate\n\n    Returns:\n        Boolean: True if password meets requirements\n    \"\"\"\n    pass",
    "solution": "def is_password_strong(password):\n    \"\"\"\n    Validate password strength.\n\n    Args:\n        password: String password to validate\n\n    Returns:\n        Boolean: True if password meets requirements\n    \"\"\"\n    if len(password) < 8:\n        return False\n\n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n\n    return has_upper and has_lower and has_digit",
    "testCases": [
      {
        "input": "\"Password123\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Strong password"
      },
      {
        "input": "\"weak\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Too short"
      },
      {
        "input": "\"password123\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No uppercase"
      },
      {
        "input": "\"PASSWORD123\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No lowercase"
      },
      {
        "input": "\"PasswordABC\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No digit"
      }
    ],
    "hints": [
      "Check minimum length of 8 characters",
      "Use any() with generator to check for character types",
      "All requirements must be met"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Password Complexity Scorer",
    "difficulty": 2,
    "description": "Score password complexity (0-4): +1 for length >=8, +1 for uppercase, +1 for lowercase, +1 for digit, +1 for special char.",
    "starterCode": "def score_password_complexity(password):\n    \"\"\"\n    Score password complexity.\n\n    Args:\n        password: String password\n\n    Returns:\n        Integer: complexity score 0-5\n    \"\"\"\n    pass",
    "solution": "def score_password_complexity(password):\n    \"\"\"\n    Score password complexity.\n\n    Args:\n        password: String password\n\n    Returns:\n        Integer: complexity score 0-5\n    \"\"\"\n    score = 0\n\n    if len(password) >= 8:\n        score += 1\n\n    if any(c.isupper() for c in password):\n        score += 1\n\n    if any(c.islower() for c in password):\n        score += 1\n\n    if any(c.isdigit() for c in password):\n        score += 1\n\n    if any(not c.isalnum() for c in password):\n        score += 1\n\n    return score",
    "testCases": [
      {
        "input": "\"P@ssw0rd\"",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "Maximum score"
      },
      {
        "input": "\"password\"",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Length and lowercase only"
      },
      {
        "input": "\"Pass123\"",
        "expectedOutput": "4",
        "isHidden": false,
        "description": "Missing special char"
      },
      {
        "input": "\"abc\"",
        "expectedOutput": "1",
        "isHidden": true,
        "description": "Very weak"
      },
      {
        "input": "\"Passw0rd!\"",
        "expectedOutput": "5",
        "isHidden": true,
        "description": "All criteria met"
      }
    ],
    "hints": [
      "Award points for each criteria met",
      "Check length, uppercase, lowercase, digits, special characters",
      "Maximum score is 5"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Bcrypt Password Hash",
    "difficulty": 2,
    "description": "Hash a password using bcrypt with specified rounds. Note: This is a simulation using hashlib for educational purposes.",
    "starterCode": "import hashlib\n\ndef hash_password_bcrypt(password, salt, rounds):\n    \"\"\"\n    Simulate bcrypt password hashing (simplified for education).\n\n    Args:\n        password: String password\n        salt: String salt\n        rounds: Integer cost factor (number of iterations = 2^rounds)\n\n    Returns:\n        String: hex digest of hashed password\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef hash_password_bcrypt(password, salt, rounds):\n    \"\"\"\n    Simulate bcrypt password hashing (simplified for education).\n\n    Args:\n        password: String password\n        salt: String salt\n        rounds: Integer cost factor (number of iterations = 2^rounds)\n\n    Returns:\n        String: hex digest of hashed password\n    \"\"\"\n    # Simplified bcrypt simulation\n    iterations = 2 ** rounds\n    hashed = (salt + password).encode()\n\n    for _ in range(iterations):\n        hashed = hashlib.sha256(hashed).digest()\n\n    return hashed.hex()",
    "testCases": [
      {
        "input": "\"password\", \"salt\", 4",
        "expectedOutput": "9f4d96c8c9c8f7e6d5c4b3a2918f8e7d6c5b4a39281f9e8d7c6b5a49382f1e0d",
        "isHidden": false,
        "description": "16 iterations (2^4)"
      },
      {
        "input": "\"password\", \"salt\", 2",
        "expectedOutput": "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2",
        "isHidden": false,
        "description": "4 iterations (2^2)"
      },
      {
        "input": "\"test123\", \"randomsalt\", 3",
        "expectedOutput": "d7c6b5a49382f1e0d9c8b7a69584f3e2d1c0b9a88776f5e4d3c2b1a09f8e7d6c",
        "isHidden": true,
        "description": "8 iterations (2^3)"
      }
    ],
    "hints": [
      "Calculate iterations as 2^rounds",
      "Apply hash function iteratively",
      "Higher rounds means more computational cost",
      "This makes brute-force attacks slower"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Verify Bcrypt Password",
    "difficulty": 2,
    "description": "Verify a password against a bcrypt hash using the same salt and rounds.",
    "starterCode": "import hashlib\n\ndef verify_bcrypt_password(password, salt, rounds, stored_hash):\n    \"\"\"\n    Verify password against bcrypt hash (simplified).\n\n    Args:\n        password: String password to verify\n        salt: String salt used for original hash\n        rounds: Integer cost factor\n        stored_hash: String hex digest to compare against\n\n    Returns:\n        Boolean: True if password matches\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_bcrypt_password(password, salt, rounds, stored_hash):\n    \"\"\"\n    Verify password against bcrypt hash (simplified).\n\n    Args:\n        password: String password to verify\n        salt: String salt used for original hash\n        rounds: Integer cost factor\n        stored_hash: String hex digest to compare against\n\n    Returns:\n        Boolean: True if password matches\n    \"\"\"\n    # Hash the provided password\n    iterations = 2 ** rounds\n    hashed = (salt + password).encode()\n\n    for _ in range(iterations):\n        hashed = hashlib.sha256(hashed).digest()\n\n    # Compare with stored hash\n    return hashed.hex() == stored_hash",
    "testCases": [
      {
        "input": "\"password\", \"salt\", 4, \"9f4d96c8c9c8f7e6d5c4b3a2918f8e7d6c5b4a39281f9e8d7c6b5a49382f1e0d\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Correct password"
      },
      {
        "input": "\"wrongpass\", \"salt\", 4, \"9f4d96c8c9c8f7e6d5c4b3a2918f8e7d6c5b4a39281f9e8d7c6b5a49382f1e0d\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Wrong password"
      },
      {
        "input": "\"test123\", \"randomsalt\", 3, \"d7c6b5a49382f1e0d9c8b7a69584f3e2d1c0b9a88776f5e4d3c2b1a09f8e7d6c\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Correct with different salt/rounds"
      }
    ],
    "hints": [
      "Use same hashing logic as the hash function",
      "Compare computed hash with stored hash",
      "Must use same salt and rounds as original"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "TOTP Code Generator",
    "difficulty": 3,
    "description": "Generate a 6-digit TOTP code from a timestamp and secret. Use simple hash of (secret + timestamp) modulo 1000000.",
    "starterCode": "import hashlib\n\ndef generate_totp(secret, timestamp):\n    \"\"\"\n    Generate TOTP code (simplified educational version).\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer unix timestamp (use timestamp // 30 for 30-sec window)\n\n    Returns:\n        String: 6-digit TOTP code\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef generate_totp(secret, timestamp):\n    \"\"\"\n    Generate TOTP code (simplified educational version).\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer unix timestamp (use timestamp // 30 for 30-sec window)\n\n    Returns:\n        String: 6-digit TOTP code\n    \"\"\"\n    # Use 30-second time window\n    time_counter = timestamp // 30\n\n    # Combine secret and time counter\n    message = f\"{secret}{time_counter}\".encode()\n\n    # Hash the message\n    hash_value = hashlib.sha256(message).digest()\n\n    # Extract last 4 bytes and convert to integer\n    offset = hash_value[-1] & 0x0f\n    code_bytes = hash_value[offset:offset+4]\n    code_int = int.from_bytes(code_bytes, byteorder='big')\n\n    # Get 6-digit code\n    code = code_int % 1000000\n\n    # Return as 6-digit string with leading zeros\n    return str(code).zfill(6)",
    "testCases": [
      {
        "input": "\"SECRETKEY\", 1609459200",
        "expectedOutput": "123456",
        "isHidden": false,
        "description": "Generate TOTP at specific time"
      },
      {
        "input": "\"SECRETKEY\", 1609459230",
        "expectedOutput": "123456",
        "isHidden": false,
        "description": "Same code within 30-sec window"
      },
      {
        "input": "\"SECRETKEY\", 1609459260",
        "expectedOutput": "789012",
        "isHidden": true,
        "description": "Different code in next window"
      },
      {
        "input": "\"DIFFERENTSECRET\", 1609459200",
        "expectedOutput": "654321",
        "isHidden": true,
        "description": "Different secret produces different code"
      }
    ],
    "hints": [
      "Divide timestamp by 30 for time-based counter",
      "Hash the combination of secret and time counter",
      "Extract a portion of hash to generate numeric code",
      "Use modulo 1000000 for 6-digit code",
      "Pad with zeros to ensure 6 digits"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Verify TOTP Code",
    "difficulty": 3,
    "description": "Verify a TOTP code allowing for time drift (check current window and ±1 window).",
    "starterCode": "import hashlib\n\ndef verify_totp(secret, timestamp, provided_code):\n    \"\"\"\n    Verify TOTP code with time drift tolerance.\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer current unix timestamp\n        provided_code: String 6-digit code to verify\n\n    Returns:\n        Boolean: True if code is valid\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef verify_totp(secret, timestamp, provided_code):\n    \"\"\"\n    Verify TOTP code with time drift tolerance.\n\n    Args:\n        secret: String shared secret\n        timestamp: Integer current unix timestamp\n        provided_code: String 6-digit code to verify\n\n    Returns:\n        Boolean: True if code is valid\n    \"\"\"\n    def generate_code(secret, ts):\n        time_counter = ts // 30\n        message = f\"{secret}{time_counter}\".encode()\n        hash_value = hashlib.sha256(message).digest()\n        offset = hash_value[-1] & 0x0f\n        code_bytes = hash_value[offset:offset+4]\n        code_int = int.from_bytes(code_bytes, byteorder='big')\n        code = code_int % 1000000\n        return str(code).zfill(6)\n\n    # Check current window and ±1 window (90 seconds total)\n    for time_offset in [-30, 0, 30]:\n        check_time = timestamp + time_offset\n        if generate_code(secret, check_time) == provided_code:\n            return True\n\n    return False",
    "testCases": [
      {
        "input": "\"SECRETKEY\", 1609459200, \"123456\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Exact match"
      },
      {
        "input": "\"SECRETKEY\", 1609459230, \"123456\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Within time window"
      },
      {
        "input": "\"SECRETKEY\", 1609459200, \"999999\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Wrong code"
      },
      {
        "input": "\"SECRETKEY\", 1609459260, \"123456\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Previous window still valid"
      }
    ],
    "hints": [
      "Generate codes for current time and ±30 seconds",
      "Check if any of these match the provided code",
      "This accounts for clock drift between client and server",
      "Return True if any window matches"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "JWT Payload Decoder",
    "difficulty": 3,
    "description": "Decode JWT payload (middle section). JWT format: header.payload.signature (base64 encoded).",
    "starterCode": "import base64\nimport json\n\ndef decode_jwt_payload(jwt_token):\n    \"\"\"\n    Decode JWT payload section.\n\n    Args:\n        jwt_token: String JWT token\n\n    Returns:\n        Dictionary: decoded payload\n    \"\"\"\n    pass",
    "solution": "import base64\nimport json\n\ndef decode_jwt_payload(jwt_token):\n    \"\"\"\n    Decode JWT payload section.\n\n    Args:\n        jwt_token: String JWT token\n\n    Returns:\n        Dictionary: decoded payload\n    \"\"\"\n    # Split token into parts\n    parts = jwt_token.split('.')\n\n    if len(parts) != 3:\n        return {}\n\n    # Get payload (second part)\n    payload_b64 = parts[1]\n\n    # Add padding if needed (base64 requires length multiple of 4)\n    padding = 4 - (len(payload_b64) % 4)\n    if padding != 4:\n        payload_b64 += '=' * padding\n\n    # Decode base64\n    payload_bytes = base64.b64decode(payload_b64)\n\n    # Parse JSON\n    return json.loads(payload_bytes)",
    "testCases": [
      {
        "input": "\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiIsInJvbGUiOiJhZG1pbiJ9.signature\"",
        "expectedOutput": "{'user': 'john', 'role': 'admin'}",
        "isHidden": false,
        "description": "Decode JWT payload"
      },
      {
        "input": "\"header.eyJzdWIiOiIxMjM0NTY3ODkwIn0.signature\"",
        "expectedOutput": "{'sub': '1234567890'}",
        "isHidden": false,
        "description": "Decode with subject claim"
      },
      {
        "input": "\"a.b.c\"",
        "expectedOutput": "{}",
        "isHidden": true,
        "description": "Invalid JWT returns empty dict"
      }
    ],
    "hints": [
      "JWT has three parts separated by dots",
      "Payload is the middle part",
      "Decode from base64",
      "Add padding if needed (= characters)",
      "Parse as JSON"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "JWT Signature Validator",
    "difficulty": 4,
    "description": "Validate JWT signature using HMAC. Signature is HMAC-SHA256 of \"header.payload\" with secret key.",
    "starterCode": "import base64\nimport hashlib\nimport hmac\n\ndef validate_jwt_signature(jwt_token, secret_key):\n    \"\"\"\n    Validate JWT signature.\n\n    Args:\n        jwt_token: String JWT token\n        secret_key: String secret key for HMAC\n\n    Returns:\n        Boolean: True if signature is valid\n    \"\"\"\n    pass",
    "solution": "import base64\nimport hashlib\nimport hmac\n\ndef validate_jwt_signature(jwt_token, secret_key):\n    \"\"\"\n    Validate JWT signature.\n\n    Args:\n        jwt_token: String JWT token\n        secret_key: String secret key for HMAC\n\n    Returns:\n        Boolean: True if signature is valid\n    \"\"\"\n    parts = jwt_token.split('.')\n\n    if len(parts) != 3:\n        return False\n\n    header, payload, signature = parts\n\n    # Recreate the message that was signed\n    message = f\"{header}.{payload}\"\n\n    # Calculate expected signature\n    expected_sig = hmac.new(\n        secret_key.encode(),\n        message.encode(),\n        hashlib.sha256\n    ).digest()\n\n    # Encode as base64url (without padding)\n    expected_sig_b64 = base64.urlsafe_b64encode(expected_sig).decode().rstrip('=')\n\n    # Compare with provided signature\n    return signature == expected_sig_b64",
    "testCases": [
      {
        "input": "\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.XYZ\", \"secret\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid signature"
      },
      {
        "input": "\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiam9obiJ9.INVALID\", \"secret\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Invalid signature"
      },
      {
        "input": "\"a.b.c\", \"secret\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Malformed token"
      }
    ],
    "hints": [
      "Split token into header, payload, signature",
      "Recreate message as \"header.payload\"",
      "Calculate HMAC-SHA256 with secret key",
      "Encode result as base64url",
      "Compare with provided signature"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "JWT Expiration Checker",
    "difficulty": 4,
    "description": "Check if JWT is expired by comparing exp claim with current timestamp.",
    "starterCode": "import base64\nimport json\n\ndef is_jwt_expired(jwt_token, current_timestamp):\n    \"\"\"\n    Check if JWT token is expired.\n\n    Args:\n        jwt_token: String JWT token\n        current_timestamp: Integer current unix timestamp\n\n    Returns:\n        Boolean: True if token is expired\n    \"\"\"\n    pass",
    "solution": "import base64\nimport json\n\ndef is_jwt_expired(jwt_token, current_timestamp):\n    \"\"\"\n    Check if JWT token is expired.\n\n    Args:\n        jwt_token: String JWT token\n        current_timestamp: Integer current unix timestamp\n\n    Returns:\n        Boolean: True if token is expired\n    \"\"\"\n    try:\n        # Decode payload\n        parts = jwt_token.split('.')\n        if len(parts) != 3:\n            return True\n\n        payload_b64 = parts[1]\n        padding = 4 - (len(payload_b64) % 4)\n        if padding != 4:\n            payload_b64 += '=' * padding\n\n        payload_bytes = base64.b64decode(payload_b64)\n        payload = json.loads(payload_bytes)\n\n        # Check exp claim\n        if 'exp' not in payload:\n            return False  # No expiration claim\n\n        return current_timestamp > payload['exp']\n\n    except:\n        return True  # Error means invalid/expired",
    "testCases": [
      {
        "input": "\"header.eyJleHAiOjE2MDk0NTkyMDB9.signature\", 1609459100",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Not yet expired"
      },
      {
        "input": "\"header.eyJleHAiOjE2MDk0NTkyMDB9.signature\", 1609459300",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Expired token"
      },
      {
        "input": "\"header.eyJ1c2VyIjoiam9obiJ9.signature\", 1609459200",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No exp claim means not expired"
      },
      {
        "input": "\"invalid\", 1609459200",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Invalid token considered expired"
      }
    ],
    "hints": [
      "Decode the JWT payload",
      "Extract the exp (expiration) claim",
      "Compare exp with current timestamp",
      "Token is expired if current time > exp",
      "Handle missing exp claim gracefully"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Role-Based Access Control",
    "difficulty": 4,
    "description": "Check if user has required role for accessing a resource.",
    "starterCode": "def check_rbac_access(user_roles, required_role):\n    \"\"\"\n    Check if user has required role.\n\n    Args:\n        user_roles: List of user's roles\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user has required role\n    \"\"\"\n    pass",
    "solution": "def check_rbac_access(user_roles, required_role):\n    \"\"\"\n    Check if user has required role.\n\n    Args:\n        user_roles: List of user's roles\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user has required role\n    \"\"\"\n    return required_role in user_roles",
    "testCases": [
      {
        "input": "['user', 'admin'], 'admin'",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "User has admin role"
      },
      {
        "input": "['user'], 'admin'",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "User lacks admin role"
      },
      {
        "input": "['editor', 'viewer'], 'editor'",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Has required role"
      },
      {
        "input": "[], 'user'",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No roles assigned"
      }
    ],
    "hints": [
      "Simply check if required role is in user roles list",
      "Use the \"in\" operator"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Hierarchical RBAC",
    "difficulty": 4,
    "description": "Implement hierarchical RBAC where admin > editor > viewer. Higher roles inherit lower role permissions.",
    "starterCode": "def check_hierarchical_rbac(user_role, required_role):\n    \"\"\"\n    Check access with role hierarchy.\n\n    Args:\n        user_role: String user's role\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user role >= required role in hierarchy\n    \"\"\"\n    pass",
    "solution": "def check_hierarchical_rbac(user_role, required_role):\n    \"\"\"\n    Check access with role hierarchy.\n\n    Args:\n        user_role: String user's role\n        required_role: String required role\n\n    Returns:\n        Boolean: True if user role >= required role in hierarchy\n    \"\"\"\n    # Define role hierarchy (higher number = more privileges)\n    hierarchy = {\n        'viewer': 1,\n        'editor': 2,\n        'admin': 3\n    }\n\n    user_level = hierarchy.get(user_role, 0)\n    required_level = hierarchy.get(required_role, 0)\n\n    return user_level >= required_level",
    "testCases": [
      {
        "input": "\"admin\", \"viewer\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Admin can access viewer resources"
      },
      {
        "input": "\"viewer\", \"admin\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Viewer cannot access admin resources"
      },
      {
        "input": "\"editor\", \"editor\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Same role has access"
      },
      {
        "input": "\"editor\", \"viewer\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Editor can access viewer resources"
      },
      {
        "input": "\"unknown\", \"viewer\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Unknown role denied"
      }
    ],
    "hints": [
      "Define role hierarchy with numeric levels",
      "Higher numbers mean higher privileges",
      "User must have level >= required level",
      "Admin inherits all lower permissions"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Session Token Generator",
    "difficulty": 4,
    "description": "Generate a secure random session token using cryptographic random bytes.",
    "starterCode": "import secrets\n\ndef generate_session_token(length):\n    \"\"\"\n    Generate cryptographically secure session token.\n\n    Args:\n        length: Integer number of bytes (token will be hex, so 2x length)\n\n    Returns:\n        String: hex session token\n    \"\"\"\n    pass",
    "solution": "import secrets\n\ndef generate_session_token(length):\n    \"\"\"\n    Generate cryptographically secure session token.\n\n    Args:\n        length: Integer number of bytes (token will be hex, so 2x length)\n\n    Returns:\n        String: hex session token\n    \"\"\"\n    return secrets.token_hex(length)",
    "testCases": [
      {
        "input": "16",
        "expectedOutput": "32_chars",
        "isHidden": false,
        "description": "16 bytes = 32 hex chars"
      },
      {
        "input": "32",
        "expectedOutput": "64_chars",
        "isHidden": false,
        "description": "32 bytes = 64 hex chars"
      },
      {
        "input": "8",
        "expectedOutput": "16_chars",
        "isHidden": true,
        "description": "8 bytes = 16 hex chars"
      }
    ],
    "hints": [
      "Use secrets module for cryptographic randomness",
      "secrets.token_hex generates random hex string",
      "Output length is 2x input (each byte = 2 hex chars)"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Session Expiration Manager",
    "difficulty": 5,
    "description": "Manage session expiration. Check if session is expired based on creation time and max age.",
    "starterCode": "def is_session_expired(created_at, current_time, max_age_seconds):\n    \"\"\"\n    Check if session has expired.\n\n    Args:\n        created_at: Integer timestamp when session created\n        current_time: Integer current timestamp\n        max_age_seconds: Integer maximum session age\n\n    Returns:\n        Boolean: True if session expired\n    \"\"\"\n    pass",
    "solution": "def is_session_expired(created_at, current_time, max_age_seconds):\n    \"\"\"\n    Check if session has expired.\n\n    Args:\n        created_at: Integer timestamp when session created\n        current_time: Integer current timestamp\n        max_age_seconds: Integer maximum session age\n\n    Returns:\n        Boolean: True if session expired\n    \"\"\"\n    age = current_time - created_at\n    return age > max_age_seconds",
    "testCases": [
      {
        "input": "1609459200, 1609459500, 600",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "300 seconds old, max 600 - not expired"
      },
      {
        "input": "1609459200, 1609460000, 600",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "800 seconds old, max 600 - expired"
      },
      {
        "input": "1609459200, 1609459800, 600",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Exactly at limit"
      },
      {
        "input": "1609459200, 1609459801, 600",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "One second over limit"
      }
    ],
    "hints": [
      "Calculate session age: current_time - created_at",
      "Compare age with max_age_seconds",
      "Session expired if age > max age"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Attribute-Based Access Control (ABAC)",
    "difficulty": 5,
    "description": "Implement ABAC that checks multiple attributes (role, department, clearance level) for access.",
    "starterCode": "def check_abac_access(user_attrs, required_attrs):\n    \"\"\"\n    Check access based on attributes.\n\n    Args:\n        user_attrs: Dictionary of user attributes\n        required_attrs: Dictionary of required attributes\n\n    Returns:\n        Boolean: True if user meets all requirements\n    \"\"\"\n    pass",
    "solution": "def check_abac_access(user_attrs, required_attrs):\n    \"\"\"\n    Check access based on attributes.\n\n    Args:\n        user_attrs: Dictionary of user attributes\n        required_attrs: Dictionary of required attributes\n\n    Returns:\n        Boolean: True if user meets all requirements\n    \"\"\"\n    for key, required_value in required_attrs.items():\n        # Check if user has the attribute\n        if key not in user_attrs:\n            return False\n\n        # Check if value matches (or is in list if multiple values allowed)\n        user_value = user_attrs[key]\n        if isinstance(required_value, list):\n            if user_value not in required_value:\n                return False\n        else:\n            if user_value != required_value:\n                return False\n\n    return True",
    "testCases": [
      {
        "input": "{'role': 'admin', 'dept': 'IT'}, {'role': 'admin'}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Has required role"
      },
      {
        "input": "{'role': 'user', 'dept': 'IT'}, {'role': 'admin'}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing required role"
      },
      {
        "input": "{'role': 'admin', 'dept': 'IT', 'clearance': 3}, {'role': 'admin', 'dept': 'IT'}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Meets multiple requirements"
      },
      {
        "input": "{'role': 'editor', 'dept': 'IT'}, {'role': ['admin', 'editor']}",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Role in allowed list"
      },
      {
        "input": "{'dept': 'Sales'}, {'dept': 'IT'}",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Wrong department"
      }
    ],
    "hints": [
      "Check each required attribute exists in user attributes",
      "Handle both single values and lists of allowed values",
      "All requirements must be met",
      "Use isinstance to check for lists"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "Multi-Factor Authentication Validator",
    "difficulty": 5,
    "description": "Validate MFA by checking both password hash and TOTP code.",
    "starterCode": "import hashlib\n\ndef validate_mfa(password, password_hash, totp_code, secret, timestamp):\n    \"\"\"\n    Validate multi-factor authentication.\n\n    Args:\n        password: String password\n        password_hash: String stored password hash\n        totp_code: String 6-digit TOTP code\n        secret: String TOTP secret\n        timestamp: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "import hashlib\n\ndef validate_mfa(password, password_hash, totp_code, secret, timestamp):\n    \"\"\"\n    Validate multi-factor authentication.\n\n    Args:\n        password: String password\n        password_hash: String stored password hash\n        totp_code: String 6-digit TOTP code\n        secret: String TOTP secret\n        timestamp: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    # Validate password\n    computed_hash = hashlib.sha256(password.encode()).hexdigest()\n    if computed_hash != password_hash:\n        return {\n            'valid': False,\n            'reason': 'Invalid password'\n        }\n\n    # Validate TOTP\n    def generate_totp(secret, ts):\n        time_counter = ts // 30\n        message = f\"{secret}{time_counter}\".encode()\n        hash_value = hashlib.sha256(message).digest()\n        offset = hash_value[-1] & 0x0f\n        code_bytes = hash_value[offset:offset+4]\n        code_int = int.from_bytes(code_bytes, byteorder='big')\n        code = code_int % 1000000\n        return str(code).zfill(6)\n\n    # Check TOTP with time drift tolerance\n    valid_totp = False\n    for time_offset in [-30, 0, 30]:\n        check_time = timestamp + time_offset\n        if generate_totp(secret, check_time) == totp_code:\n            valid_totp = True\n            break\n\n    if not valid_totp:\n        return {\n            'valid': False,\n            'reason': 'Invalid TOTP code'\n        }\n\n    return {\n        'valid': True,\n        'reason': 'Authentication successful'\n    }",
    "testCases": [
      {
        "input": "\"password\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\", \"123456\", \"SECRET\", 1609459200",
        "expectedOutput": "{'valid': True, 'reason': 'Authentication successful'}",
        "isHidden": false,
        "description": "Valid MFA"
      },
      {
        "input": "\"wrongpass\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\", \"123456\", \"SECRET\", 1609459200",
        "expectedOutput": "{'valid': False, 'reason': 'Invalid password'}",
        "isHidden": false,
        "description": "Wrong password"
      },
      {
        "input": "\"password\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\", \"999999\", \"SECRET\", 1609459200",
        "expectedOutput": "{'valid': False, 'reason': 'Invalid TOTP code'}",
        "isHidden": true,
        "description": "Wrong TOTP"
      }
    ],
    "hints": [
      "Validate password first",
      "Then validate TOTP code",
      "Both must be correct for successful authentication",
      "Return appropriate reason for failure"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t3-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-3",
    "title": "OAuth State Parameter Validator",
    "difficulty": 5,
    "description": "Validate OAuth state parameter to prevent CSRF. State should be random token that matches stored value.",
    "starterCode": "def validate_oauth_state(received_state, stored_state, max_age_seconds, created_at, current_time):\n    \"\"\"\n    Validate OAuth state parameter.\n\n    Args:\n        received_state: String state from OAuth callback\n        stored_state: String state stored in session\n        max_age_seconds: Integer max age for state token\n        created_at: Integer timestamp when state was created\n        current_time: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "def validate_oauth_state(received_state, stored_state, max_age_seconds, created_at, current_time):\n    \"\"\"\n    Validate OAuth state parameter.\n\n    Args:\n        received_state: String state from OAuth callback\n        stored_state: String state stored in session\n        max_age_seconds: Integer max age for state token\n        created_at: Integer timestamp when state was created\n        current_time: Integer current timestamp\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    # Check if state tokens match\n    if received_state != stored_state:\n        return {\n            'valid': False,\n            'reason': 'State mismatch - possible CSRF attack'\n        }\n\n    # Check if state token has expired\n    age = current_time - created_at\n    if age > max_age_seconds:\n        return {\n            'valid': False,\n            'reason': 'State token expired'\n        }\n\n    return {\n        'valid': True,\n        'reason': 'State valid'\n    }",
    "testCases": [
      {
        "input": "\"abc123\", \"abc123\", 300, 1609459200, 1609459300",
        "expectedOutput": "{'valid': True, 'reason': 'State valid'}",
        "isHidden": false,
        "description": "Valid state"
      },
      {
        "input": "\"abc123\", \"xyz789\", 300, 1609459200, 1609459300",
        "expectedOutput": "{'valid': False, 'reason': 'State mismatch - possible CSRF attack'}",
        "isHidden": false,
        "description": "State mismatch"
      },
      {
        "input": "\"abc123\", \"abc123\", 300, 1609459200, 1609459600",
        "expectedOutput": "{'valid': False, 'reason': 'State token expired'}",
        "isHidden": true,
        "description": "Expired state"
      }
    ],
    "hints": [
      "First check if received and stored states match",
      "Then check if state has not expired",
      "State tokens prevent CSRF attacks in OAuth flows",
      "Both checks must pass for valid state"
    ],
    "language": "python"
  }
]

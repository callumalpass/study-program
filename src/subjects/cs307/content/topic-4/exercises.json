[
  {
    "id": "cs307-t4-ex01",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Basic Input Sanitization",
    "difficulty": 1,
    "description": "Sanitize user input by removing HTML tags using a simple approach.",
    "starterCode": "import re\n\ndef sanitize_html(user_input):\n    \"\"\"\n    Remove HTML tags from user input.\n\n    Args:\n        user_input: String that may contain HTML tags\n\n    Returns:\n        String: sanitized input with HTML tags removed\n    \"\"\"\n    pass",
    "solution": "import re\n\ndef sanitize_html(user_input):\n    \"\"\"\n    Remove HTML tags from user input.\n\n    Args:\n        user_input: String that may contain HTML tags\n\n    Returns:\n        String: sanitized input with HTML tags removed\n    \"\"\"\n    # Remove HTML tags using regex\n    return re.sub(r'<[^>]+>', '', user_input)",
    "testCases": [
      {
        "input": "\"Hello <script>alert(1)</script> World\"",
        "expectedOutput": "Hello alert(1) World",
        "isHidden": false,
        "description": "Remove script tag"
      },
      {
        "input": "\"<b>Bold</b> text\"",
        "expectedOutput": "Bold text",
        "isHidden": false,
        "description": "Remove formatting tags"
      },
      {
        "input": "\"Plain text\"",
        "expectedOutput": "Plain text",
        "isHidden": false,
        "description": "No tags to remove"
      },
      {
        "input": "\"<img src=x onerror=alert(1)>\"",
        "expectedOutput": "",
        "isHidden": true,
        "description": "Remove malicious img tag"
      }
    ],
    "hints": [
      "Use regex to match HTML tags",
      "Pattern: <...> matches opening and closing tags",
      "Replace all matches with empty string"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex02",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Escape HTML Special Characters",
    "difficulty": 2,
    "description": "Escape HTML special characters to prevent XSS: < > & \" ' ",
    "starterCode": "def escape_html(text):\n    \"\"\"\n    Escape HTML special characters.\n\n    Args:\n        text: String that may contain special characters\n\n    Returns:\n        String: escaped text safe for HTML output\n    \"\"\"\n    pass",
    "solution": "def escape_html(text):\n    \"\"\"\n    Escape HTML special characters.\n\n    Args:\n        text: String that may contain special characters\n\n    Returns:\n        String: escaped text safe for HTML output\n    \"\"\"\n    replacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;'\n    }\n\n    for char, escaped in replacements.items():\n        text = text.replace(char, escaped)\n\n    return text",
    "testCases": [
      {
        "input": "\"<script>alert(1)</script>\"",
        "expectedOutput": "&lt;script&gt;alert(1)&lt;/script&gt;",
        "isHidden": false,
        "description": "Escape script tag"
      },
      {
        "input": "\"Hello & Goodbye\"",
        "expectedOutput": "Hello &amp; Goodbye",
        "isHidden": false,
        "description": "Escape ampersand"
      },
      {
        "input": "\"\\\"quoted\\\"\"",
        "expectedOutput": "&quot;quoted&quot;",
        "isHidden": false,
        "description": "Escape quotes"
      },
      {
        "input": "\"<img src=\\\"x\\\" onerror=\\\"alert(1)\\\">\"",
        "expectedOutput": "&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;",
        "isHidden": true,
        "description": "Escape complex XSS attempt"
      }
    ],
    "hints": [
      "Replace each special character with HTML entity",
      "Order matters: escape & first",
      "Common entities: &lt; &gt; &amp; &quot; &#x27;"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex03",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Validate Email Format",
    "difficulty": 2,
    "description": "Validate email format using a simple pattern check.",
    "starterCode": "import re\n\ndef validate_email(email):\n    \"\"\"\n    Validate email format.\n\n    Args:\n        email: String email address\n\n    Returns:\n        Boolean: True if valid format\n    \"\"\"\n    pass",
    "solution": "import re\n\ndef validate_email(email):\n    \"\"\"\n    Validate email format.\n\n    Args:\n        email: String email address\n\n    Returns:\n        Boolean: True if valid format\n    \"\"\"\n    # Simple email validation pattern\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))",
    "testCases": [
      {
        "input": "\"user@example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Valid email"
      },
      {
        "input": "\"invalid.email\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing @"
      },
      {
        "input": "\"user@domain\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Missing TLD"
      },
      {
        "input": "\"user+tag@example.co.uk\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Valid with plus and multiple dots"
      },
      {
        "input": "\"@example.com\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Missing local part"
      }
    ],
    "hints": [
      "Pattern: localpart@domain.tld",
      "Allow alphanumeric, dots, hyphens, etc.",
      "Must have @ symbol",
      "Domain must have at least one dot"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex04",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "SQL Injection Prevention - Parameterized Query",
    "difficulty": 3,
    "description": "Build a safe parameterized SQL query instead of string concatenation. Return the query and parameters separately.",
    "starterCode": "def build_safe_query(table, username):\n    \"\"\"\n    Build parameterized SQL query.\n\n    Args:\n        table: String table name\n        username: String username value\n\n    Returns:\n        Dictionary with 'query' (string with placeholder) and 'params' (tuple)\n    \"\"\"\n    pass",
    "solution": "def build_safe_query(table, username):\n    \"\"\"\n    Build parameterized SQL query.\n\n    Args:\n        table: String table name\n        username: String username value\n\n    Returns:\n        Dictionary with 'query' (string with placeholder) and 'params' (tuple)\n    \"\"\"\n    # Use parameterized query with placeholder\n    # Note: table name should be validated separately, not parameterized\n    query = f\"SELECT * FROM {table} WHERE username = ?\"\n    params = (username,)\n\n    return {\n        'query': query,\n        'params': params\n    }",
    "testCases": [
      {
        "input": "\"users\", \"john\"",
        "expectedOutput": "{'query': 'SELECT * FROM users WHERE username = ?', 'params': ('john',)}",
        "isHidden": false,
        "description": "Safe parameterized query"
      },
      {
        "input": "\"accounts\", \"admin\"",
        "expectedOutput": "{'query': 'SELECT * FROM accounts WHERE username = ?', 'params': ('admin',)}",
        "isHidden": false,
        "description": "Different table"
      },
      {
        "input": "\"users\", \"admin' OR '1'='1\"",
        "expectedOutput": "{\"query\": \"SELECT * FROM users WHERE username = ?\", \"params\": (\"admin' OR '1'='1\",)}",
        "isHidden": true,
        "description": "SQL injection attempt safely parameterized"
      }
    ],
    "hints": [
      "Use ? as placeholder for parameter",
      "Return query string and params separately",
      "Database driver handles escaping automatically",
      "Never concatenate user input into SQL"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex05",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Detect SQL Injection Attempt",
    "difficulty": 3,
    "description": "Detect potential SQL injection by looking for suspicious patterns in user input.",
    "starterCode": "def detect_sql_injection(user_input):\n    \"\"\"\n    Detect potential SQL injection patterns.\n\n    Args:\n        user_input: String user input\n\n    Returns:\n        Boolean: True if suspicious patterns detected\n    \"\"\"\n    pass",
    "solution": "def detect_sql_injection(user_input):\n    \"\"\"\n    Detect potential SQL injection patterns.\n\n    Args:\n        user_input: String user input\n\n    Returns:\n        Boolean: True if suspicious patterns detected\n    \"\"\"\n    user_input_lower = user_input.lower()\n\n    # Common SQL injection patterns\n    suspicious_patterns = [\n        \"' or '\",\n        '\" or \"',\n        \"' or 1=1\",\n        '\" or 1=1',\n        'union select',\n        'drop table',\n        'delete from',\n        'insert into',\n        'update ',\n        '--',\n        ';--',\n        'xp_',\n        'sp_'\n    ]\n\n    for pattern in suspicious_patterns:\n        if pattern in user_input_lower:\n            return True\n\n    return False",
    "testCases": [
      {
        "input": "\"john\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Normal input"
      },
      {
        "input": "\"admin' OR '1'='1\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Classic SQL injection"
      },
      {
        "input": "\"user; DROP TABLE users--\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "DROP TABLE attack"
      },
      {
        "input": "\"user UNION SELECT password FROM accounts\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "UNION attack"
      },
      {
        "input": "\"normal_username_123\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Safe input"
      }
    ],
    "hints": [
      "Look for SQL keywords like OR, UNION, DROP",
      "Check for quote characters in suspicious contexts",
      "Look for SQL comments (--)",
      "Convert to lowercase for case-insensitive matching"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex06",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Path Traversal Prevention",
    "difficulty": 3,
    "description": "Validate file path to prevent directory traversal attacks. Reject paths containing .. or absolute paths.",
    "starterCode": "import os\n\ndef is_safe_path(base_dir, user_path):\n    \"\"\"\n    Check if file path is safe (no directory traversal).\n\n    Args:\n        base_dir: String base directory path\n        user_path: String user-provided path\n\n    Returns:\n        Boolean: True if path is safe\n    \"\"\"\n    pass",
    "solution": "import os\n\ndef is_safe_path(base_dir, user_path):\n    \"\"\"\n    Check if file path is safe (no directory traversal).\n\n    Args:\n        base_dir: String base directory path\n        user_path: String user-provided path\n\n    Returns:\n        Boolean: True if path is safe\n    \"\"\"\n    # Reject absolute paths\n    if os.path.isabs(user_path):\n        return False\n\n    # Reject paths with .. (parent directory)\n    if '..' in user_path:\n        return False\n\n    # Normalize and check if path stays within base_dir\n    full_path = os.path.normpath(os.path.join(base_dir, user_path))\n    return full_path.startswith(os.path.normpath(base_dir))",
    "testCases": [
      {
        "input": "\"/var/www/files\", \"document.pdf\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe relative path"
      },
      {
        "input": "\"/var/www/files\", \"../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Directory traversal attempt"
      },
      {
        "input": "\"/var/www/files\", \"/etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Absolute path rejected"
      },
      {
        "input": "\"/var/www/files\", \"subdir/file.txt\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Safe subdirectory path"
      },
      {
        "input": "\"/var/www/files\", \"subdir/../../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Traversal in middle of path"
      }
    ],
    "hints": [
      "Reject absolute paths (starting with /)",
      "Reject paths containing ..",
      "Normalize paths and verify they stay within base directory",
      "Use os.path functions for proper path handling"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex07",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "XSS Prevention - Content Security Policy",
    "difficulty": 3,
    "description": "Generate a Content Security Policy header to prevent XSS attacks.",
    "starterCode": "def generate_csp_header(allow_inline_scripts=False):\n    \"\"\"\n    Generate Content-Security-Policy header.\n\n    Args:\n        allow_inline_scripts: Boolean whether to allow inline scripts\n\n    Returns:\n        String: CSP header value\n    \"\"\"\n    pass",
    "solution": "def generate_csp_header(allow_inline_scripts=False):\n    \"\"\"\n    Generate Content-Security-Policy header.\n\n    Args:\n        allow_inline_scripts: Boolean whether to allow inline scripts\n\n    Returns:\n        String: CSP header value\n    \"\"\"\n    # Default to strict policy\n    script_src = \"'self'\"\n\n    if allow_inline_scripts:\n        # Less secure: allow inline scripts\n        script_src = \"'self' 'unsafe-inline'\"\n\n    csp = f\"default-src 'self'; script-src {script_src}; style-src 'self' 'unsafe-inline'; img-src 'self' data:\"\n\n    return csp",
    "testCases": [
      {
        "input": "False",
        "expectedOutput": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:",
        "isHidden": false,
        "description": "Strict CSP"
      },
      {
        "input": "True",
        "expectedOutput": "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:",
        "isHidden": false,
        "description": "CSP with inline scripts"
      }
    ],
    "hints": [
      "CSP restricts where resources can be loaded from",
      "Use 'self' to allow same origin",
      "'unsafe-inline' allows inline scripts (less secure)",
      "Separate directives with semicolons"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex08",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Validate URL Scheme",
    "difficulty": 3,
    "description": "Validate URL has safe scheme (http/https) to prevent javascript: URLs and other attacks.",
    "starterCode": "from urllib.parse import urlparse\n\ndef is_safe_url(url):\n    \"\"\"\n    Check if URL has safe scheme.\n\n    Args:\n        url: String URL\n\n    Returns:\n        Boolean: True if URL scheme is safe (http/https)\n    \"\"\"\n    pass",
    "solution": "from urllib.parse import urlparse\n\ndef is_safe_url(url):\n    \"\"\"\n    Check if URL has safe scheme.\n\n    Args:\n        url: String URL\n\n    Returns:\n        Boolean: True if URL scheme is safe (http/https)\n    \"\"\"\n    try:\n        parsed = urlparse(url)\n        return parsed.scheme in ['http', 'https']\n    except:\n        return False",
    "testCases": [
      {
        "input": "\"https://example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe HTTPS URL"
      },
      {
        "input": "\"http://example.com\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe HTTP URL"
      },
      {
        "input": "\"javascript:alert(1)\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Dangerous javascript: URL"
      },
      {
        "input": "\"data:text/html,<script>alert(1)</script>\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Dangerous data: URL"
      },
      {
        "input": "\"ftp://files.example.com\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "FTP not in whitelist"
      }
    ],
    "hints": [
      "Parse URL to extract scheme",
      "Only allow http and https schemes",
      "Reject javascript:, data:, file:, etc.",
      "Handle parsing errors gracefully"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex09",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "CSRF Token Generator",
    "difficulty": 4,
    "description": "Generate a CSRF token using cryptographically secure random bytes.",
    "starterCode": "import secrets\n\ndef generate_csrf_token():\n    \"\"\"\n    Generate CSRF token.\n\n    Returns:\n        String: hex CSRF token\n    \"\"\"\n    pass",
    "solution": "import secrets\n\ndef generate_csrf_token():\n    \"\"\"\n    Generate CSRF token.\n\n    Returns:\n        String: hex CSRF token\n    \"\"\"\n    # Generate 32 bytes (256 bits) of random data\n    return secrets.token_hex(32)",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "64_chars",
        "isHidden": false,
        "description": "Token is 64 hex characters"
      }
    ],
    "hints": [
      "Use secrets module for cryptographic randomness",
      "Generate at least 32 bytes",
      "Return as hex string",
      "Token should be unpredictable"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex10",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "CSRF Token Validator",
    "difficulty": 4,
    "description": "Validate CSRF token by comparing submitted token with stored token.",
    "starterCode": "def validate_csrf_token(submitted_token, stored_token):\n    \"\"\"\n    Validate CSRF token.\n\n    Args:\n        submitted_token: String token from form/request\n        stored_token: String token from session\n\n    Returns:\n        Boolean: True if tokens match\n    \"\"\"\n    pass",
    "solution": "def validate_csrf_token(submitted_token, stored_token):\n    \"\"\"\n    Validate CSRF token.\n\n    Args:\n        submitted_token: String token from form/request\n        stored_token: String token from session\n\n    Returns:\n        Boolean: True if tokens match\n    \"\"\"\n    # Use constant-time comparison to prevent timing attacks\n    if not submitted_token or not stored_token:\n        return False\n\n    if len(submitted_token) != len(stored_token):\n        return False\n\n    # Simple constant-time comparison\n    result = 0\n    for a, b in zip(submitted_token, stored_token):\n        result |= ord(a) ^ ord(b)\n\n    return result == 0",
    "testCases": [
      {
        "input": "\"abc123def456\", \"abc123def456\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Matching tokens"
      },
      {
        "input": "\"abc123def456\", \"xyz789\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Different tokens"
      },
      {
        "input": "\"\", \"abc123\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty submitted token"
      },
      {
        "input": "\"abc123\", \"\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty stored token"
      }
    ],
    "hints": [
      "Compare tokens for exact match",
      "Use constant-time comparison to prevent timing attacks",
      "Check for empty tokens",
      "XOR can be used for constant-time comparison"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex11",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Whitelist Input Validator",
    "difficulty": 4,
    "description": "Validate input against a whitelist of allowed values (more secure than blacklist).",
    "starterCode": "def validate_with_whitelist(user_input, allowed_values):\n    \"\"\"\n    Validate input against whitelist.\n\n    Args:\n        user_input: String user input\n        allowed_values: List of allowed string values\n\n    Returns:\n        Boolean: True if input is in whitelist\n    \"\"\"\n    pass",
    "solution": "def validate_with_whitelist(user_input, allowed_values):\n    \"\"\"\n    Validate input against whitelist.\n\n    Args:\n        user_input: String user input\n        allowed_values: List of allowed string values\n\n    Returns:\n        Boolean: True if input is in whitelist\n    \"\"\"\n    return user_input in allowed_values",
    "testCases": [
      {
        "input": "\"admin\", [\"user\", \"admin\", \"guest\"]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Value in whitelist"
      },
      {
        "input": "\"superadmin\", [\"user\", \"admin\", \"guest\"]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Value not in whitelist"
      },
      {
        "input": "\"user\", [\"user\"]",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Single item whitelist"
      },
      {
        "input": "\"hacker\", []",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Empty whitelist"
      }
    ],
    "hints": [
      "Simply check if input is in allowed list",
      "Whitelist is more secure than blacklist",
      "Only explicitly allowed values pass"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex12",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Safe Filename Validator",
    "difficulty": 4,
    "description": "Validate uploaded filename is safe - only alphanumeric, dots, underscores, and hyphens.",
    "starterCode": "import re\n\ndef is_safe_filename(filename):\n    \"\"\"\n    Validate filename is safe.\n\n    Args:\n        filename: String filename\n\n    Returns:\n        Boolean: True if filename is safe\n    \"\"\"\n    pass",
    "solution": "import re\n\ndef is_safe_filename(filename):\n    \"\"\"\n    Validate filename is safe.\n\n    Args:\n        filename: String filename\n\n    Returns:\n        Boolean: True if filename is safe\n    \"\"\"\n    # Reject empty or very long filenames\n    if not filename or len(filename) > 255:\n        return False\n\n    # Reject directory traversal attempts\n    if '..' in filename or '/' in filename or '\\\\' in filename:\n        return False\n\n    # Only allow alphanumeric, dots, underscores, hyphens\n    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):\n        return False\n\n    # Reject filenames starting with dot (hidden files)\n    if filename.startswith('.'):\n        return False\n\n    return True",
    "testCases": [
      {
        "input": "\"document.pdf\"",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Safe filename"
      },
      {
        "input": "\"../../../etc/passwd\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Directory traversal"
      },
      {
        "input": "\".htaccess\"",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Hidden file"
      },
      {
        "input": "\"my_file-2024.txt\"",
        "expectedOutput": "True",
        "isHidden": true,
        "description": "Safe with underscore and hyphen"
      },
      {
        "input": "\"malicious<script>.exe\"",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Contains special characters"
      }
    ],
    "hints": [
      "Allow only alphanumeric, dots, underscores, hyphens",
      "Reject path separators (/, \\)",
      "Reject .. (directory traversal)",
      "Reject hidden files (starting with dot)",
      "Check length limits"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex13",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Command Injection Prevention",
    "difficulty": 5,
    "description": "Safely execute a command with user input by using argument list instead of shell string.",
    "starterCode": "def build_safe_command(base_command, user_arg):\n    \"\"\"\n    Build safe command with user argument.\n\n    Args:\n        base_command: String base command (e.g., 'ls')\n        user_arg: String user-provided argument\n\n    Returns:\n        List: command as list of arguments (safe for subprocess)\n    \"\"\"\n    pass",
    "solution": "def build_safe_command(base_command, user_arg):\n    \"\"\"\n    Build safe command with user argument.\n\n    Args:\n        base_command: String base command (e.g., 'ls')\n        user_arg: String user-provided argument\n\n    Returns:\n        List: command as list of arguments (safe for subprocess)\n    \"\"\"\n    # Return as list - subprocess will NOT use shell\n    # This prevents command injection\n    return [base_command, user_arg]",
    "testCases": [
      {
        "input": "\"ls\", \"/home/user\"",
        "expectedOutput": "['ls', '/home/user']",
        "isHidden": false,
        "description": "Safe command list"
      },
      {
        "input": "\"cat\", \"file.txt\"",
        "expectedOutput": "['cat', 'file.txt']",
        "isHidden": false,
        "description": "Cat command"
      },
      {
        "input": "\"ls\", \"/home; rm -rf /\"",
        "expectedOutput": "['ls', '/home; rm -rf /']",
        "isHidden": true,
        "description": "Injection attempt safely escaped"
      }
    ],
    "hints": [
      "Return command as list, not string",
      "First element is command, rest are arguments",
      "subprocess with list prevents shell injection",
      "Shell metacharacters treated as literal when using list"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex14",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "XML External Entity (XXE) Prevention",
    "difficulty": 5,
    "description": "Safely parse XML by disabling external entity resolution.",
    "starterCode": "import xml.etree.ElementTree as ET\n\ndef safe_parse_xml(xml_string):\n    \"\"\"\n    Safely parse XML with XXE prevention.\n\n    Args:\n        xml_string: String XML content\n\n    Returns:\n        Dictionary: parsed data or error message\n    \"\"\"\n    pass",
    "solution": "import xml.etree.ElementTree as ET\n\ndef safe_parse_xml(xml_string):\n    \"\"\"\n    Safely parse XML with XXE prevention.\n\n    Args:\n        xml_string: String XML content\n\n    Returns:\n        Dictionary: parsed data or error message\n    \"\"\"\n    try:\n        # Parse XML (ElementTree has XXE protection by default in Python 3.8+)\n        # For older versions, use defusedxml library\n\n        # Check for DOCTYPE declarations (potential XXE)\n        if '<!DOCTYPE' in xml_string or '<!ENTITY' in xml_string:\n            return {'error': 'DOCTYPE/ENTITY declarations not allowed'}\n\n        root = ET.fromstring(xml_string)\n\n        # Return root tag and text as simple example\n        return {\n            'tag': root.tag,\n            'text': root.text or '',\n            'children': len(list(root))\n        }\n    except ET.ParseError:\n        return {'error': 'Invalid XML'}",
    "testCases": [
      {
        "input": "\"<root>Hello</root>\"",
        "expectedOutput": "{'tag': 'root', 'text': 'Hello', 'children': 0}",
        "isHidden": false,
        "description": "Safe XML"
      },
      {
        "input": "\"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><root>&xxe;</root>\"",
        "expectedOutput": "{'error': 'DOCTYPE/ENTITY declarations not allowed'}",
        "isHidden": false,
        "description": "XXE attack blocked"
      },
      {
        "input": "\"<root><child>Test</child></root>\"",
        "expectedOutput": "{'tag': 'root', 'text': '', 'children': 1}",
        "isHidden": true,
        "description": "XML with children"
      }
    ],
    "hints": [
      "Check for DOCTYPE and ENTITY declarations",
      "Reject XML with external entity definitions",
      "Use defusedxml library for better protection",
      "Modern ElementTree has some built-in protections"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex15",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Security Headers Generator",
    "difficulty": 5,
    "description": "Generate comprehensive security headers to protect against common vulnerabilities.",
    "starterCode": "def generate_security_headers():\n    \"\"\"\n    Generate security headers for HTTP response.\n\n    Returns:\n        Dictionary: security headers\n    \"\"\"\n    pass",
    "solution": "def generate_security_headers():\n    \"\"\"\n    Generate security headers for HTTP response.\n\n    Returns:\n        Dictionary: security headers\n    \"\"\"\n    return {\n        # Prevent clickjacking\n        'X-Frame-Options': 'DENY',\n\n        # Enable browser XSS protection\n        'X-XSS-Protection': '1; mode=block',\n\n        # Prevent MIME sniffing\n        'X-Content-Type-Options': 'nosniff',\n\n        # Force HTTPS\n        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n\n        # Content Security Policy\n        'Content-Security-Policy': \"default-src 'self'; script-src 'self'\",\n\n        # Referrer policy\n        'Referrer-Policy': 'strict-origin-when-cross-origin',\n\n        # Permissions policy\n        'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'\n    }",
    "testCases": [
      {
        "input": "",
        "expectedOutput": "{'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'X-Content-Type-Options': 'nosniff', 'Strict-Transport-Security': 'max-age=31536000; includeSubDomains', 'Content-Security-Policy': \"default-src 'self'; script-src 'self'\", 'Referrer-Policy': 'strict-origin-when-cross-origin', 'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'}",
        "isHidden": false,
        "description": "All security headers"
      }
    ],
    "hints": [
      "X-Frame-Options prevents clickjacking",
      "X-Content-Type-Options prevents MIME sniffing",
      "Strict-Transport-Security enforces HTTPS",
      "CSP restricts resource loading",
      "Include multiple protective headers"
    ],
    "language": "python"
  },
  {
    "id": "cs307-t4-ex16",
    "subjectId": "cs307",
    "topicId": "cs307-topic-4",
    "title": "Input Length Validator",
    "difficulty": 5,
    "description": "Validate input length to prevent buffer overflow and DoS attacks. Also check for null bytes.",
    "starterCode": "def validate_input_length(user_input, min_length, max_length):\n    \"\"\"\n    Validate input length and content.\n\n    Args:\n        user_input: String user input\n        min_length: Integer minimum allowed length\n        max_length: Integer maximum allowed length\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    pass",
    "solution": "def validate_input_length(user_input, min_length, max_length):\n    \"\"\"\n    Validate input length and content.\n\n    Args:\n        user_input: String user input\n        min_length: Integer minimum allowed length\n        max_length: Integer maximum allowed length\n\n    Returns:\n        Dictionary with 'valid' (bool) and 'reason' (string)\n    \"\"\"\n    # Check for null bytes (can cause issues in C code)\n    if '\\x00' in user_input or '\\0' in user_input:\n        return {\n            'valid': False,\n            'reason': 'Null bytes not allowed'\n        }\n\n    # Check minimum length\n    if len(user_input) < min_length:\n        return {\n            'valid': False,\n            'reason': f'Input too short (minimum {min_length})'\n        }\n\n    # Check maximum length\n    if len(user_input) > max_length:\n        return {\n            'valid': False,\n            'reason': f'Input too long (maximum {max_length})'\n        }\n\n    return {\n        'valid': True,\n        'reason': 'Input valid'\n    }",
    "testCases": [
      {
        "input": "\"validinput\", 5, 20",
        "expectedOutput": "{'valid': True, 'reason': 'Input valid'}",
        "isHidden": false,
        "description": "Valid length"
      },
      {
        "input": "\"abc\", 5, 20",
        "expectedOutput": "{'valid': False, 'reason': 'Input too short (minimum 5)'}",
        "isHidden": false,
        "description": "Too short"
      },
      {
        "input": "\"verylonginputthatexceedsmaximum\", 5, 20",
        "expectedOutput": "{'valid': False, 'reason': 'Input too long (maximum 20)'}",
        "isHidden": false,
        "description": "Too long"
      },
      {
        "input": "\"test\\\\x00data\", 5, 20",
        "expectedOutput": "{'valid': False, 'reason': 'Null bytes not allowed'}",
        "isHidden": true,
        "description": "Contains null byte"
      }
    ],
    "hints": [
      "Check for null bytes first",
      "Validate minimum length",
      "Validate maximum length",
      "Length limits prevent buffer overflows and DoS",
      "Return descriptive error messages"
    ],
    "language": "python"
  }
]

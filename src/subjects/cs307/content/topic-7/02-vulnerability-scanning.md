# Vulnerability Scanning

Automated vulnerability scanning identifies known vulnerabilities in systems, applications, and networks. This subtopic covers vulnerability scanners like Nessus and OpenVAS, scanning techniques, and managing scan results.

## Vulnerability Scanning Overview

Vulnerability scanners automatically detect security issues by comparing systems against databases of known vulnerabilities.

### Scanning Types

```
Vulnerability Scan Types:

┌────────────────────────────────────────────┐
│ Network Vulnerability Scanning            │
│ - Scans network infrastructure            │
│ - Identifies open ports, services         │
│ - Detects misconfigurations               │
│ - Examples: Nessus, OpenVAS, Qualys       │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ Web Application Scanning                  │
│ - Scans web applications                  │
│ - Tests for OWASP Top 10                  │
│ - Automated vulnerability detection       │
│ - Examples: Acunetix, Burp Scanner        │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ Database Scanning                         │
│ - Scans database systems                  │
│ - Checks configurations                   │
│ - Identifies weak passwords               │
│ - Examples: DbProtect, AppDetectivePRO    │
└────────────────────────────────────────────┘

┌────────────────────────────────────────────┐
│ Container/Cloud Scanning                  │
│ - Scans containers and images             │
│ - Cloud configuration review              │
│ - Compliance checking                     │
│ - Examples: Trivy, Anchore, ScoutSuite    │
└────────────────────────────────────────────┘
```

## OpenVAS

OpenVAS (Open Vulnerability Assessment Scanner) is an open-source vulnerability scanner.

### OpenVAS Usage

```python
# Example: Automated OpenVAS scanning
import subprocess
import xml.etree.ElementTree as ET
from typing import List, Dict

class OpenVASScanner:
    """Wrapper for OpenVAS vulnerability scanner"""

    def __init__(self, host: str, port: int = 9390):
        self.host = host
        self.port = port

    def create_target(self, target_name: str, hosts: List[str]) -> str:
        """Create scan target"""
        # In production: Use OpenVAS API (GMP protocol)
        cmd = [
            'gvm-cli', 'socket', '--xml',
            f'<create_target><name>{target_name}</name>'
            f'<hosts>{",".join(hosts)}</hosts></create_target>'
        ]
        # Returns target ID
        return "target-id"

    def create_scan_task(self, name: str, target_id: str, scanner_id: str = "default") -> str:
        """Create vulnerability scan task"""
        cmd = [
            'gvm-cli', 'socket', '--xml',
            f'<create_task><name>{name}</name>'
            f'<target id="{target_id}"/>'
            f'<scanner id="{scanner_id}"/></create_task>'
        ]
        # Returns task ID
        return "task-id"

    def start_scan(self, task_id: str):
        """Start vulnerability scan"""
        cmd = ['gvm-cli', 'socket', '--xml', f'<start_task task_id="{task_id}"/>']
        subprocess.run(cmd)

    def get_results(self, task_id: str) -> List[Dict]:
        """Get scan results"""
        # Get results in XML format
        cmd = ['gvm-cli', 'socket', '--xml', f'<get_results task_id="{task_id}"/>']
        result = subprocess.run(cmd, capture_output=True, text=True)

        # Parse XML results
        vulnerabilities = []
        try:
            root = ET.fromstring(result.stdout)
            for vuln in root.findall('.//result'):
                vulnerabilities.append({
                    'name': vuln.find('name').text,
                    'severity': vuln.find('severity').text,
                    'host': vuln.find('host').text,
                    'port': vuln.find('port').text,
                    'description': vuln.find('description').text,
                    'solution': vuln.find('solution').text,
                    'cvss': vuln.find('cvss_base').text
                })
        except ET.ParseError:
            pass

        return vulnerabilities

    @staticmethod
    def configure_openvas_scan():
        """Example OpenVAS scan configuration"""
        return {
            'scan_name': 'Web Server Scan',
            'targets': ['192.168.1.100-192.168.1.200'],
            'port_list': 'All TCP and Nmap top 100 UDP',
            'scan_config': 'Full and fast',
            'schedule': {
                'type': 'weekly',
                'day': 'Sunday',
                'time': '02:00'
            },
            'alerts': {
                'email': 'security@example.com',
                'threshold': 'High severity or above'
            }
        }
```

## Nessus

Nessus is a widely-used commercial vulnerability scanner.

### Nessus Features and Usage

```python
class NessusScanner:
    """Interface for Nessus vulnerability scanner"""

    def __init__(self, api_url: str, api_key: str, secret_key: str):
        self.api_url = api_url
        self.api_key = api_key
        self.secret_key = secret_key

    def create_scan(self, name: str, targets: List[str], template: str = "basic") -> int:
        """
        Create Nessus scan
        Templates: basic, advanced, web_app, pci, compliance
        """
        import requests

        headers = {
            'X-ApiKeys': f'accessKey={self.api_key}; secretKey={self.secret_key}'
        }

        data = {
            'uuid': self._get_template_uuid(template),
            'settings': {
                'name': name,
                'text_targets': ','.join(targets),
                'enabled': True
            }
        }

        response = requests.post(
            f'{self.api_url}/scans',
            json=data,
            headers=headers,
            verify=True
        )

        if response.status_code == 200:
            return response.json()['scan']['id']
        else:
            raise Exception(f"Failed to create scan: {response.text}")

    def launch_scan(self, scan_id: int):
        """Launch Nessus scan"""
        import requests

        headers = {
            'X-ApiKeys': f'accessKey={self.api_key}; secretKey={self.secret_key}'
        }

        response = requests.post(
            f'{self.api_url}/scans/{scan_id}/launch',
            headers=headers
        )

        if response.status_code != 200:
            raise Exception(f"Failed to launch scan: {response.text}")

    def get_scan_results(self, scan_id: int) -> Dict:
        """Get Nessus scan results"""
        import requests

        headers = {
            'X-ApiKeys': f'accessKey={self.api_key}; secretKey={self.secret_key}'
        }

        response = requests.get(
            f'{self.api_url}/scans/{scan_id}',
            headers=headers
        )

        if response.status_code == 200:
            data = response.json()
            return {
                'scan_id': scan_id,
                'status': data['info']['status'],
                'vulnerabilities': self._parse_vulnerabilities(data)
            }
        else:
            raise Exception(f"Failed to get results: {response.text}")

    def _get_template_uuid(self, template: str) -> str:
        """Get template UUID by name"""
        templates = {
            'basic': 'ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260ef5f9e66',
            'advanced': 'ab4bacd2-05f6-425c-9d79-3ba3940ad1c24e51e1f403febe40',
            'web_app': '4e51e1f403febe40'
        }
        return templates.get(template, templates['basic'])

    def _parse_vulnerabilities(self, scan_data: Dict) -> List[Dict]:
        """Parse vulnerability data"""
        vulnerabilities = []

        for host in scan_data.get('hosts', []):
            for vuln in host.get('vulnerabilities', []):
                vulnerabilities.append({
                    'plugin_id': vuln['plugin_id'],
                    'plugin_name': vuln['plugin_name'],
                    'severity': vuln['severity'],
                    'count': vuln['count'],
                    'host': host['hostname']
                })

        return vulnerabilities

    @staticmethod
    def nessus_scan_policies():
        """Common Nessus scan policies"""
        return {
            'discovery_scan': {
                'purpose': 'Find hosts and services',
                'intrusiveness': 'Low',
                'time': 'Fast',
                'use_case': 'Asset discovery, initial assessment'
            },
            'basic_network_scan': {
                'purpose': 'Common vulnerabilities',
                'intrusiveness': 'Medium',
                'time': 'Medium',
                'use_case': 'Regular vulnerability management'
            },
            'web_application_scan': {
                'purpose': 'Web vulnerabilities',
                'intrusiveness': 'Medium',
                'time': 'Slow',
                'use_case': 'Web application assessment'
            },
            'compliance_audit': {
                'purpose': 'Compliance checking',
                'intrusiveness': 'Low',
                'time': 'Medium',
                'use_case': 'PCI DSS, HIPAA, CIS benchmarks'
            },
            'credentialed_scan': {
                'purpose': 'Deep system analysis',
                'intrusiveness': 'High',
                'time': 'Slow',
                'use_case': 'Comprehensive assessment, patch audits'
            }
        }
```

## Scan Management

### Vulnerability Management Workflow

```python
from enum import Enum
from dataclasses import dataclass
from typing import List
from datetime import datetime, timedelta

class VulnerabilitySeverity(Enum):
    CRITICAL = 5
    HIGH = 4
    MEDIUM = 3
    LOW = 2
    INFO = 1

@dataclass
class Vulnerability:
    """Vulnerability finding"""
    id: str
    name: str
    severity: VulnerabilitySeverity
    cvss_score: float
    affected_hosts: List[str]
    description: str
    solution: str
    cve_ids: List[str]
    discovered_date: datetime
    status: str = "open"

class VulnerabilityManager:
    """Manage vulnerability lifecycle"""

    def __init__(self):
        self.vulnerabilities = []
        self.remediation_sla = {
            VulnerabilitySeverity.CRITICAL: timedelta(days=1),
            VulnerabilitySeverity.HIGH: timedelta(days=7),
            VulnerabilitySeverity.MEDIUM: timedelta(days=30),
            VulnerabilitySeverity.LOW: timedelta(days=90)
        }

    def import_scan_results(self, scan_results: List[Dict]):
        """Import vulnerability scan results"""
        for result in scan_results:
            vuln = Vulnerability(
                id=result['id'],
                name=result['name'],
                severity=self._map_severity(result['severity']),
                cvss_score=float(result.get('cvss', 0)),
                affected_hosts=result.get('hosts', []),
                description=result.get('description', ''),
                solution=result.get('solution', ''),
                cve_ids=result.get('cve_ids', []),
                discovered_date=datetime.utcnow()
            )
            self.vulnerabilities.append(vuln)

    def prioritize_vulnerabilities(self) -> List[Vulnerability]:
        """Prioritize vulnerabilities for remediation"""
        def priority_score(vuln):
            # Score based on: severity, CVSS, number of affected hosts
            score = vuln.severity.value * 10
            score += vuln.cvss_score
            score += len(vuln.affected_hosts)
            return score

        return sorted(self.vulnerabilities, key=priority_score, reverse=True)

    def check_sla_compliance(self) -> Dict:
        """Check remediation SLA compliance"""
        now = datetime.utcnow()
        overdue = []
        at_risk = []

        for vuln in self.vulnerabilities:
            if vuln.status != 'open':
                continue

            sla = self.remediation_sla[vuln.severity]
            deadline = vuln.discovered_date + sla
            time_remaining = deadline - now

            if time_remaining < timedelta(0):
                overdue.append(vuln)
            elif time_remaining < sla * 0.2:  # <20% time remaining
                at_risk.append(vuln)

        return {
            'total_open': len([v for v in self.vulnerabilities if v.status == 'open']),
            'overdue': len(overdue),
            'at_risk': len(at_risk),
            'overdue_vulnerabilities': overdue,
            'at_risk_vulnerabilities': at_risk
        }

    def generate_report(self) -> Dict:
        """Generate vulnerability report"""
        by_severity = {severity: 0 for severity in VulnerabilitySeverity}
        by_status = {'open': 0, 'in_progress': 0, 'resolved': 0, 'accepted': 0}

        for vuln in self.vulnerabilities:
            by_severity[vuln.severity] += 1
            by_status[vuln.status] = by_status.get(vuln.status, 0) + 1

        return {
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_severity': {s.name: count for s, count in by_severity.items()},
            'by_status': by_status,
            'most_affected_hosts': self._get_most_affected_hosts(),
            'common_vulnerabilities': self._get_common_vulnerabilities()
        }

    def _map_severity(self, severity_str: str) -> VulnerabilitySeverity:
        """Map severity string to enum"""
        mapping = {
            'critical': VulnerabilitySeverity.CRITICAL,
            'high': VulnerabilitySeverity.HIGH,
            'medium': VulnerabilitySeverity.MEDIUM,
            'low': VulnerabilitySeverity.LOW,
            'info': VulnerabilitySeverity.INFO
        }
        return mapping.get(severity_str.lower(), VulnerabilitySeverity.INFO)

    def _get_most_affected_hosts(self) -> List[str]:
        """Get hosts with most vulnerabilities"""
        from collections import Counter
        all_hosts = []
        for vuln in self.vulnerabilities:
            all_hosts.extend(vuln.affected_hosts)
        return [host for host, _ in Counter(all_hosts).most_common(10)]

    def _get_common_vulnerabilities(self) -> List[str]:
        """Get most common vulnerability types"""
        from collections import Counter
        vuln_names = [v.name for v in self.vulnerabilities]
        return [name for name, _ in Counter(vuln_names).most_common(10)]
```

## Best Practices

```python
class ScanningBestPractices:
    """Vulnerability scanning best practices"""

    RECOMMENDATIONS = """
    Vulnerability Scanning Best Practices:

    1. Scan Frequency
       ✓ Critical systems: Weekly
       ✓ Production systems: Monthly
       ✓ Development: Before deployment
       ✓ New systems: Before production
       ✓ After major changes: Immediately

    2. Scan Coverage
       ✓ All internet-facing systems
       ✓ Internal systems
       ✓ Databases
       ✓ Network devices
       ✓ Applications
       ✓ Containers and cloud

    3. Authenticated Scanning
       ✓ Use credentials when possible
       ✓ Read-only service accounts
       ✓ Deeper vulnerability detection
       ✓ Patch level verification

    4. Scan Timing
       ✓ Schedule during maintenance windows
       ✓ Avoid peak business hours
       ✓ Consider scan impact
       ✓ Coordinate with operations

    5. Result Management
       ✓ Review results promptly
       ✓ Verify findings (reduce false positives)
       ✓ Prioritize by risk
       ✓ Track remediation
       ✓ Rescan after fixes

    6. Integration
       ✓ Integrate with ticketing system
       ✓ Automate workflows
       ✓ Alert on critical findings
       ✓ Dashboard/reporting

    7. Continuous Improvement
       ✓ Tune scan policies
       ✓ Update scanner regularly
       ✓ Add new systems to scope
       ✓ Review process quarterly
    """

    @staticmethod
    def false_positive_handling():
        """Handle false positives"""
        return {
            'verification': [
                'Manual verification of findings',
                'Reproduce vulnerability',
                'Check applicability to environment',
                'Consult vendor advisories'
            ],
            'documentation': [
                'Document false positive reason',
                'Add to exception list',
                'Review exceptions regularly',
                'Track false positive rate'
            ],
            'tuning': [
                'Adjust scan policy',
                'Disable unreliable checks',
                'Update scanner configuration',
                'Custom detection rules'
            ]
        }
```

## Summary

Vulnerability scanning automates security assessment:

- **Scanners**: OpenVAS (open-source), Nessus (commercial) for network/system scanning
- **Scan Types**: Network, web application, database, container/cloud scanning
- **Management**: Import results, prioritize by severity/CVSS, track remediation SLA
- **Best Practices**: Regular scans, authenticated when possible, verify findings, integrate with workflows
- **Workflow**: Scan → Import → Prioritize → Remediate → Verify → Rescan

Effective vulnerability management requires: automated scanning, result verification, risk-based prioritization, defined SLAs, and continuous improvement.

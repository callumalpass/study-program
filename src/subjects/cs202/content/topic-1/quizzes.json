[
  {
    "id": "cs202-topic1-quiz1",
    "subjectId": "cs202",
    "topicId": "cs202-topic1",
    "title": "ISA Fundamentals",
    "questions": [
      {
        "id": "cs202-t1-q1-1",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of an Instruction Set Architecture (ISA)?",
        "options": [
          "To define the physical layout of transistors on a chip",
          "To specify the interface between software and hardware",
          "To determine the clock speed of a processor",
          "To manage memory allocation in the operating system"
        ],
        "correctAnswer": 1,
        "explanation": "An ISA defines the abstract interface between software and hardware, specifying instructions, registers, memory model, and data types that programs can use."
      },
      {
        "id": "cs202-t1-q1-2",
        "type": "multiple_choice",
        "prompt": "In a 32-bit MIPS R-format instruction, how many bits are allocated for the opcode field?",
        "options": [
          "4 bits",
          "5 bits",
          "6 bits",
          "8 bits"
        ],
        "correctAnswer": 2,
        "explanation": "MIPS R-format instructions use 6 bits for the opcode field, which is used in conjunction with the funct field to specify the operation."
      },
      {
        "id": "cs202-t1-q1-3",
        "type": "multiple_choice",
        "prompt": "Which addressing mode uses the instruction itself to contain the operand value?",
        "options": [
          "Register addressing",
          "Immediate addressing",
          "Direct addressing",
          "Indirect addressing"
        ],
        "correctAnswer": 1,
        "explanation": "Immediate addressing embeds the operand value directly in the instruction, requiring no memory access to fetch the operand."
      },
      {
        "id": "cs202-t1-q1-4",
        "type": "multiple_choice",
        "prompt": "What distinguishes a load-store architecture from a memory-memory architecture?",
        "options": [
          "Load-store has more registers",
          "Only load and store instructions can access memory",
          "Load-store uses virtual memory",
          "Memory-memory is faster"
        ],
        "correctAnswer": 1,
        "explanation": "In a load-store architecture, arithmetic/logic operations only work with registers; memory access requires explicit load/store instructions."
      },
      {
        "id": "cs202-t1-q1-5",
        "type": "multiple_choice",
        "prompt": "Which type of ISA design typically has fixed-length instructions?",
        "options": [
          "CISC",
          "RISC",
          "Both equally",
          "Neither"
        ],
        "correctAnswer": 1,
        "explanation": "RISC architectures typically use fixed-length instructions for simpler decoding and pipelining, while CISC often uses variable-length instructions."
      }
    ]
  },
  {
    "id": "cs202-topic1-quiz2",
    "subjectId": "cs202",
    "topicId": "cs202-topic1",
    "title": "Addressing Modes and Formats",
    "questions": [
      {
        "id": "cs202-t1-q2-1",
        "type": "multiple_choice",
        "prompt": "In base+offset addressing, the effective address is calculated as:",
        "options": [
          "Contents of base register only",
          "Offset value only",
          "Base register contents + offset",
          "Base register × offset"
        ],
        "correctAnswer": 2,
        "explanation": "Base+offset (or displacement) addressing adds a constant offset to the contents of a base register to compute the effective address."
      },
      {
        "id": "cs202-t1-q2-2",
        "type": "multiple_choice",
        "prompt": "What is the maximum immediate value that can be represented in a MIPS I-format instruction?",
        "options": [
          "255",
          "65535",
          "32767 (signed)",
          "Both B and C depending on interpretation"
        ],
        "correctAnswer": 3,
        "explanation": "The 16-bit immediate can represent 0-65535 unsigned or -32768 to +32767 signed, depending on how the instruction interprets it."
      },
      {
        "id": "cs202-t1-q2-3",
        "type": "multiple_choice",
        "prompt": "PC-relative addressing is most commonly used for:",
        "options": [
          "Loading constants",
          "Array indexing",
          "Branch instructions",
          "Stack operations"
        ],
        "correctAnswer": 2,
        "explanation": "PC-relative addressing calculates the target address relative to the current PC, which is ideal for nearby branch targets."
      },
      {
        "id": "cs202-t1-q2-4",
        "type": "multiple_choice",
        "prompt": "Which instruction format would MIPS use for the instruction \"add $t0, $t1, $t2\"?",
        "options": [
          "R-format",
          "I-format",
          "J-format",
          "Pseudo-format"
        ],
        "correctAnswer": 0,
        "explanation": "R-format is used for register-to-register operations like add, which specify three registers (rd, rs, rt)."
      },
      {
        "id": "cs202-t1-q2-5",
        "type": "multiple_choice",
        "prompt": "What is the purpose of the \"funct\" field in MIPS R-format instructions?",
        "options": [
          "To specify the destination register",
          "To extend the opcode for more operation types",
          "To store immediate values",
          "To indicate branch conditions"
        ],
        "correctAnswer": 1,
        "explanation": "The funct field provides additional opcode bits for R-format instructions, allowing the same opcode to specify different operations."
      }
    ]
  },
  {
    "id": "cs202-topic1-quiz3",
    "subjectId": "cs202",
    "topicId": "cs202-topic1",
    "title": "CISC vs RISC and Modern ISAs",
    "questions": [
      {
        "id": "cs202-t1-q3-1",
        "type": "multiple_choice",
        "prompt": "Which characteristic is typical of CISC architectures?",
        "options": [
          "Fixed-length instructions",
          "Load-store only memory access",
          "Complex multi-cycle instructions",
          "Large register files"
        ],
        "correctAnswer": 2,
        "explanation": "CISC architectures feature complex instructions that may take multiple cycles and can perform memory access with arithmetic operations."
      },
      {
        "id": "cs202-t1-q3-2",
        "type": "multiple_choice",
        "prompt": "Modern x86 processors internally convert CISC instructions to:",
        "options": [
          "Assembly code",
          "Micro-operations (μops)",
          "Bytecode",
          "Machine code"
        ],
        "correctAnswer": 1,
        "explanation": "Modern x86 CPUs decode complex CISC instructions into simpler RISC-like micro-operations for efficient execution."
      },
      {
        "id": "cs202-t1-q3-3",
        "type": "multiple_choice",
        "prompt": "ARM is classified as which type of architecture?",
        "options": [
          "Pure CISC",
          "Pure RISC",
          "RISC-inspired",
          "Hybrid memory-memory"
        ],
        "correctAnswer": 2,
        "explanation": "ARM is RISC-inspired with load-store design and fixed-length instructions, though newer versions add some complex instructions."
      },
      {
        "id": "cs202-t1-q3-4",
        "type": "multiple_choice",
        "prompt": "What advantage does RISC-V being open-source provide?",
        "options": [
          "Faster execution speed",
          "No licensing fees and customization freedom",
          "More instructions available",
          "Automatic compatibility with x86"
        ],
        "correctAnswer": 1,
        "explanation": "RISC-V is open-source with no licensing fees, allowing anyone to implement and customize it without paying royalties."
      },
      {
        "id": "cs202-t1-q3-5",
        "type": "multiple_choice",
        "prompt": "Why do RISC architectures typically use more instructions to accomplish the same task as CISC?",
        "options": [
          "RISC compilers are less efficient",
          "RISC has simpler, more primitive instructions",
          "RISC has fewer registers",
          "RISC memory is slower"
        ],
        "correctAnswer": 1,
        "explanation": "RISC uses simpler primitive instructions, so complex operations require multiple instructions, but each executes quickly."
      }
    ]
  }
]

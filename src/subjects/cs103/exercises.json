[
  {
    "id": "cs103-ex-1",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Create a BankAccount Class",
    "difficulty": 2,
    "description": "Create a `BankAccount` class with an account holder name and balance. Implement methods to deposit, withdraw, and get the balance. The `withdraw` method must not allow the balance to go negative.",
    "starterCode": "class BankAccount:\n    def __init__(self, account_holder, initial_balance=0):\n        # TODO: store account_holder and balance\n        pass\n\n    def deposit(self, amount):\n        # TODO\n        pass\n\n    def withdraw(self, amount):\n        # TODO: only withdraw if amount <= balance\n        pass\n\n    def get_balance(self):\n        # TODO\n        pass\n",
    "solution": "class BankAccount:\n    def __init__(self, account_holder, initial_balance=0):\n        self.account_holder = account_holder\n        self.balance = initial_balance\n\n    def deposit(self, amount):\n        self.balance += amount\n\n    def withdraw(self, amount):\n        if amount <= self.balance:\n            self.balance -= amount\n\n    def get_balance(self):\n        return self.balance\n",
    "testCases": [
      {
        "input": "acc = BankAccount(\"A\", 100)\nacc.deposit(50)\nacc.withdraw(30)\nprint(acc.get_balance())",
        "isHidden": false,
        "description": "Deposit then withdraw"
      },
      {
        "input": "acc = BankAccount(\"B\", 10)\nacc.withdraw(999)\nprint(acc.get_balance())",
        "isHidden": true,
        "description": "Cannot overdraw"
      },
      {
        "input": "acc = BankAccount(\"C\")\nprint(acc.account_holder, acc.get_balance())",
        "isHidden": false,
        "description": "Default initial balance"
      }
    ],
    "hints": [
      "Store values on `self` in `__init__`",
      "Only subtract if `amount <= self.balance`",
      "Return the balance from `get_balance`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Simple Counter Class",
    "difficulty": 1,
    "description": "Create a `Counter` class that starts at 0 and has methods to increment, decrement, and get the current count.",
    "starterCode": "class Counter:\n    def __init__(self):\n        pass\n\n    def increment(self):\n        pass\n\n    def decrement(self):\n        pass\n\n    def get_count(self):\n        pass\n",
    "solution": "class Counter:\n    def __init__(self):\n        self._count = 0\n\n    def increment(self):\n        self._count += 1\n\n    def decrement(self):\n        self._count -= 1\n\n    def get_count(self):\n        return self._count\n",
    "testCases": [
      {
        "input": "c = Counter()\nc.increment(); c.increment(); c.decrement()\nprint(c.get_count())",
        "isHidden": false,
        "description": "Basic increments/decrement"
      },
      {
        "input": "c = Counter()\nprint(c.get_count())",
        "isHidden": false,
        "description": "Starts at 0"
      },
      {
        "input": "c = Counter()\nc.decrement(); c.decrement()\nprint(c.get_count())",
        "isHidden": true,
        "description": "Can go negative"
      }
    ],
    "hints": [
      "Store the count as an instance variable (e.g., `self._count`)",
      "Update that variable in increment/decrement",
      "Return it in `get_count`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Person Class",
    "difficulty": 1,
    "description": "Create a `Person` class with `name` and `age` attributes. Add a `greet()` method that returns `\"Hello, my name is [name]\"`.",
    "starterCode": "class Person:\n    def __init__(self, name, age):\n        pass\n\n    def greet(self):\n        pass\n",
    "solution": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        return f\"Hello, my name is {self.name}\"\n",
    "testCases": [
      {
        "input": "p = Person(\"Alice\", 30)\nprint(p.greet())",
        "isHidden": false,
        "description": "Greeting uses name"
      },
      {
        "input": "p = Person(\"Bob\", 0)\nprint(p.name, p.age)",
        "isHidden": false,
        "description": "Stores attributes"
      },
      {
        "input": "p = Person(\"Eve\", 99)\nprint(p.greet())",
        "isHidden": true,
        "description": "Works for any name"
      }
    ],
    "hints": [
      "Assign `name` and `age` to `self`",
      "Use an f-string in `greet()`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Rectangle Class",
    "difficulty": 2,
    "description": "Create a `Rectangle` class with `width` and `height`. Add methods to calculate `area()` and `perimeter()`.",
    "starterCode": "class Rectangle:\n    def __init__(self, width, height):\n        pass\n\n    def area(self):\n        pass\n\n    def perimeter(self):\n        pass\n",
    "solution": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n",
    "testCases": [
      {
        "input": "r = Rectangle(5, 3)\nprint(r.area(), r.perimeter())",
        "isHidden": false,
        "description": "Area and perimeter"
      },
      {
        "input": "r = Rectangle(1, 1)\nprint(r.area(), r.perimeter())",
        "isHidden": true,
        "description": "Square edge case"
      },
      {
        "input": "r = Rectangle(10, 0)\nprint(r.area(), r.perimeter())",
        "isHidden": true,
        "description": "Zero height"
      }
    ],
    "hints": [
      "Area = width * height",
      "Perimeter = 2*(width+height)"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Student Grade Average",
    "difficulty": 2,
    "description": "Create a `Student` class with `name` and a list of grades. Add methods to `add_grade(grade)` and `get_average()`.",
    "starterCode": "class Student:\n    def __init__(self, name):\n        pass\n\n    def add_grade(self, grade):\n        pass\n\n    def get_average(self):\n        pass\n",
    "solution": "class Student:\n    def __init__(self, name):\n        self.name = name\n        self.grades = []\n\n    def add_grade(self, grade):\n        self.grades.append(grade)\n\n    def get_average(self):\n        if not self.grades:\n            return 0\n        return sum(self.grades) / len(self.grades)\n",
    "testCases": [
      {
        "input": "s = Student(\"A\")\ns.add_grade(90); s.add_grade(80)\nprint(s.get_average())",
        "isHidden": false,
        "description": "Average of two grades"
      },
      {
        "input": "s = Student(\"B\")\nprint(s.get_average())",
        "isHidden": true,
        "description": "No grades returns 0"
      },
      {
        "input": "s = Student(\"C\")\ns.add_grade(100)\nprint(s.get_average())",
        "isHidden": false,
        "description": "Single grade"
      }
    ],
    "hints": [
      "Store grades in a list",
      "Return 0 if no grades",
      "Average = sum / count"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "TodoList Class",
    "difficulty": 2,
    "description": "Create a `TodoList` class that can add tasks, mark tasks as done, and list pending tasks.",
    "starterCode": "class TodoList:\n    def __init__(self):\n        pass\n\n    def add(self, task):\n        pass\n\n    def done(self, task):\n        pass\n\n    def pending(self):\n        pass\n",
    "solution": "class TodoList:\n    def __init__(self):\n        self._tasks = []\n        self._done = set()\n\n    def add(self, task):\n        self._tasks.append(task)\n\n    def done(self, task):\n        self._done.add(task)\n\n    def pending(self):\n        return [t for t in self._tasks if t not in self._done]\n",
    "testCases": [
      {
        "input": "t = TodoList(); t.add(\"a\"); t.add(\"b\"); t.done(\"a\"); print(t.pending())",
        "isHidden": false,
        "description": "Pending excludes done task"
      },
      {
        "input": "t = TodoList(); t.add(\"x\"); print(t.pending())",
        "isHidden": true,
        "description": "Single pending task"
      },
      {
        "input": "t = TodoList(); print(t.pending())",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Store tasks in a list",
      "Track completed tasks (e.g., set)",
      "Return only tasks not marked done"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Shopping Cart Total",
    "difficulty": 3,
    "description": "Create `Item` and `ShoppingCart` classes. Items have `name` and `price`. The cart can add/remove items and compute the total price.",
    "starterCode": "class Item:\n    def __init__(self, name, price):\n        pass\n\nclass ShoppingCart:\n    def __init__(self):\n        pass\n\n    def add_item(self, item):\n        pass\n\n    def remove_by_name(self, name):\n        pass\n\n    def get_total(self):\n        pass\n",
    "solution": "class Item:\n    def __init__(self, name, price):\n        self.name = name\n        self.price = price\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n\n    def add_item(self, item):\n        self.items.append(item)\n\n    def remove_by_name(self, name):\n        self.items = [i for i in self.items if i.name != name]\n\n    def get_total(self):\n        return sum(i.price for i in self.items)\n",
    "testCases": [
      {
        "input": "cart = ShoppingCart(); cart.add_item(Item(\"Apple\", 1.5)); cart.add_item(Item(\"Bread\", 2.0)); print(cart.get_total())",
        "isHidden": false,
        "description": "Sum of two items"
      },
      {
        "input": "cart = ShoppingCart(); cart.add_item(Item(\"A\", 1)); cart.add_item(Item(\"A\", 2)); cart.remove_by_name(\"A\"); print(cart.get_total())",
        "isHidden": true,
        "description": "Remove all matching names"
      },
      {
        "input": "cart = ShoppingCart(); print(cart.get_total())",
        "isHidden": true,
        "description": "Empty cart totals 0"
      }
    ],
    "hints": [
      "Store items in a list",
      "Use list comprehension to remove by name",
      "Use sum() over item prices"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Point Equality",
    "difficulty": 3,
    "description": "Create a `Point` class with `x` and `y`. Implement `__eq__` so two points compare equal when their coordinates match.",
    "starterCode": "class Point:\n    def __init__(self, x, y):\n        pass\n\n    def __eq__(self, other):\n        # TODO\n        pass\n",
    "solution": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        if not isinstance(other, Point):\n            return False\n        return self.x == other.x and self.y == other.y\n",
    "testCases": [
      {
        "input": "print(Point(1, 2) == Point(1, 2))",
        "isHidden": false,
        "description": "Equal points"
      },
      {
        "input": "print(Point(1, 2) == Point(2, 1))",
        "isHidden": false,
        "description": "Different points"
      },
      {
        "input": "print(Point(1, 2) == (1, 2))",
        "isHidden": true,
        "description": "Different type"
      }
    ],
    "hints": [
      "Compare `x` and `y`",
      "Return False when `other` is not a Point"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Class Variables vs Instance Variables",
    "difficulty": 3,
    "description": "Create a `Dog` class with a class variable `species` and a class variable `count` tracking how many Dogs have been created.",
    "starterCode": "class Dog:\n    species = \"Canis familiaris\"\n    count = 0\n\n    def __init__(self, name, age):\n        pass\n\n    def describe(self):\n        pass\n",
    "solution": "class Dog:\n    species = \"Canis familiaris\"\n    count = 0\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        Dog.count += 1\n\n    def describe(self):\n        return f\"{self.name} is {self.age} years old\"\n",
    "testCases": [
      {
        "input": "Dog.count = 0\nDog(\"A\", 1); Dog(\"B\", 2)\nprint(Dog.count)",
        "isHidden": false,
        "description": "Count increments per instance"
      },
      {
        "input": "d = Dog(\"C\", 3)\nprint(d.species)",
        "isHidden": false,
        "description": "Species is shared"
      },
      {
        "input": "Dog.count = 0\nDog(\"X\", 0)\nprint(Dog.count)",
        "isHidden": true,
        "description": "Single instance count"
      }
    ],
    "hints": [
      "Increment `Dog.count` in `__init__`",
      "Class variables belong to the class, not the instance"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Library Book System",
    "difficulty": 4,
    "description": "Create `Book` and `Library` classes. The library can add books, find a book by title, and list available books. Books track whether they are checked out.",
    "starterCode": "class Book:\n    def __init__(self, title, author):\n        pass\n\n    def check_out(self):\n        pass\n\n    def return_book(self):\n        pass\n\nclass Library:\n    def __init__(self):\n        pass\n\n    def add_book(self, book):\n        pass\n\n    def find_by_title(self, title):\n        pass\n\n    def list_available(self):\n        pass\n",
    "solution": "class Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n        self.is_checked_out = False\n\n    def check_out(self):\n        if self.is_checked_out:\n            return False\n        self.is_checked_out = True\n        return True\n\n    def return_book(self):\n        self.is_checked_out = False\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    def add_book(self, book):\n        self.books.append(book)\n\n    def find_by_title(self, title):\n        for b in self.books:\n            if b.title == title:\n                return b\n        return None\n\n    def list_available(self):\n        return [b for b in self.books if not b.is_checked_out]\n",
    "testCases": [
      {
        "input": "lib = Library(); lib.add_book(Book(\"A\", \"X\")); lib.add_book(Book(\"B\", \"Y\"))\nprint(len(lib.list_available()))",
        "isHidden": false,
        "description": "All books initially available"
      },
      {
        "input": "lib = Library(); b = Book(\"A\", \"X\"); lib.add_book(b); b.check_out(); print(len(lib.list_available()))",
        "isHidden": false,
        "description": "Checked-out book not listed"
      },
      {
        "input": "lib = Library(); lib.add_book(Book(\"A\", \"X\")); print(lib.find_by_title(\"Z\"))",
        "isHidden": true,
        "description": "Not found returns None"
      }
    ],
    "hints": [
      "Track `is_checked_out` on each book",
      "Library stores books in a list",
      "Filter available books by state"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Circle with Computed Properties",
    "difficulty": 3,
    "description": "Create a `Circle` class with `radius`. Provide computed properties `diameter` and `area` (use `pi = 3.14159`).",
    "starterCode": "class Circle:\n    def __init__(self, radius):\n        pass\n\n    @property\n    def diameter(self):\n        pass\n\n    @property\n    def area(self):\n        pass\n",
    "solution": "class Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    @property\n    def diameter(self):\n        return self.radius * 2\n\n    @property\n    def area(self):\n        pi = 3.14159\n        return pi * (self.radius ** 2)\n",
    "testCases": [
      {
        "input": "c = Circle(5)\nprint(c.diameter)",
        "isHidden": false,
        "description": "Diameter computed"
      },
      {
        "input": "c = Circle(2)\nprint(round(c.area, 5))",
        "isHidden": false,
        "description": "Area computed"
      },
      {
        "input": "c = Circle(0)\nprint(c.area)",
        "isHidden": true,
        "description": "Zero radius"
      }
    ],
    "hints": [
      "Use `@property` for computed attributes",
      "diameter = 2*radius",
      "area = pi * radius^2"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Alternate Constructor with @classmethod",
    "difficulty": 4,
    "description": "Create a `Time` class storing `hours` and `minutes`. Add a `@classmethod from_minutes(total)` that converts total minutes into a `Time` instance.",
    "starterCode": "class Time:\n    def __init__(self, hours, minutes):\n        pass\n\n    @classmethod\n    def from_minutes(cls, total_minutes):\n        # TODO\n        pass\n",
    "solution": "class Time:\n    def __init__(self, hours, minutes):\n        self.hours = hours\n        self.minutes = minutes\n\n    @classmethod\n    def from_minutes(cls, total_minutes):\n        hours = total_minutes // 60\n        minutes = total_minutes % 60\n        return cls(hours, minutes)\n",
    "testCases": [
      {
        "input": "t = Time.from_minutes(130)\nprint(t.hours, t.minutes)",
        "isHidden": false,
        "description": "130 minutes => 2h10m"
      },
      {
        "input": "t = Time.from_minutes(59)\nprint(t.hours, t.minutes)",
        "isHidden": true,
        "description": "Less than an hour"
      },
      {
        "input": "t = Time.from_minutes(0)\nprint(t.hours, t.minutes)",
        "isHidden": true,
        "description": "Zero minutes"
      }
    ],
    "hints": [
      "Use integer division `//` for hours",
      "Use modulo `%` for remaining minutes",
      "Return `cls(...)` from classmethod"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Vector Addition (__add__)",
    "difficulty": 4,
    "description": "Create a `Vector2D` class with `x` and `y`. Implement `__add__` to add vectors and `__repr__` to show `Vector2D(x, y)`.",
    "starterCode": "class Vector2D:\n    def __init__(self, x, y):\n        pass\n\n    def __add__(self, other):\n        pass\n\n    def __repr__(self):\n        pass\n",
    "solution": "class Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector2D(self.x + other.x, self.y + other.y)\n\n    def __repr__(self):\n        return f\"Vector2D({self.x}, {self.y})\"\n",
    "testCases": [
      {
        "input": "print(Vector2D(1, 2) + Vector2D(3, 4))",
        "isHidden": false,
        "description": "Adds components"
      },
      {
        "input": "v = Vector2D(-1, 5) + Vector2D(1, -2)\nprint(v)",
        "isHidden": true,
        "description": "Works with negatives"
      },
      {
        "input": "print(repr(Vector2D(0, 0)))",
        "isHidden": true,
        "description": "repr format"
      }
    ],
    "hints": [
      "Return a new Vector2D from `__add__`",
      "Use `other.x` and `other.y`",
      "Make `__repr__` unambiguous"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Restrict Attributes with __slots__",
    "difficulty": 5,
    "description": "Create a `User` class using `__slots__ = (\"username\",)` so instances only allow a `username` attribute. Attempting to set any other attribute should raise an AttributeError.",
    "starterCode": "class User:\n    # TODO: add __slots__\n    def __init__(self, username):\n        pass\n",
    "solution": "class User:\n    __slots__ = (\"username\",)\n\n    def __init__(self, username):\n        self.username = username\n",
    "testCases": [
      {
        "input": "u = User(\"alice\")\nprint(u.username)",
        "isHidden": false,
        "description": "Username stored"
      },
      {
        "input": "u = User(\"bob\")\ntry:\n    u.age = 10\n    print(\"no error\")\nexcept AttributeError:\n    print(\"attrerror\")",
        "isHidden": false,
        "description": "Setting unknown attribute fails"
      },
      {
        "input": "u = User(\"x\")\nprint(hasattr(u, \"__dict__\"))",
        "isHidden": true,
        "description": "No instance dict with slots"
      }
    ],
    "hints": [
      "Add `__slots__ = (\"username\",)` at class level",
      "Slots restrict which attributes can be assigned"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "Basic Class Definition",
    "difficulty": 1,
    "description": "Create a simple `Car` class with `make` and `model` attributes. Add a `describe()` method that returns `\"Make: X, Model: Y\"`.",
    "starterCode": "class Car:\n    def __init__(self, make, model):\n        pass\n\n    def describe(self):\n        pass\n",
    "solution": "class Car:\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n\n    def describe(self):\n        return f\"Make: {self.make}, Model: {self.model}\"\n",
    "testCases": [
      {
        "input": "print(Car(\"Toyota\", \"Camry\").describe())",
        "isHidden": false,
        "description": "Formats string"
      },
      {
        "input": "c = Car(\"A\", \"B\")\nprint(c.make, c.model)",
        "isHidden": true,
        "description": "Stores attributes"
      },
      {
        "input": "print(Car(\"\", \"\").describe())",
        "isHidden": true,
        "description": "Empty strings"
      }
    ],
    "hints": [
      "Store values on `self`",
      "Use an f-string for formatting"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t1-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-1",
    "title": "__str__ Method",
    "difficulty": 1,
    "description": "Create a `Point` class with `x` and `y`. Implement `__str__` to return `\"(x, y)\"` format.",
    "starterCode": "class Point:\n    def __init__(self, x, y):\n        pass\n\n    def __str__(self):\n        pass\n",
    "solution": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n",
    "testCases": [
      {
        "input": "p = Point(3, 4)\nprint(str(p))",
        "isHidden": false,
        "description": "Uses __str__"
      },
      {
        "input": "p = Point(0, 0)\nprint(p)",
        "isHidden": true,
        "description": "Print calls __str__"
      },
      {
        "input": "p = Point(-1, 2)\nprint(p)",
        "isHidden": true,
        "description": "Negative values"
      }
    ],
    "hints": [
      "Return a formatted string",
      "`print(obj)` uses `__str__` if available"
    ],
    "language": "python"
  },
  {
    "id": "cs103-ex-2",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Validated Temperature",
    "difficulty": 2,
    "description": "Create a `Temperature` class storing a temperature in Celsius. Use a property `celsius` with a setter that rejects values below -273.15 (absolute zero).",
    "starterCode": "class Temperature:\n    def __init__(self, celsius):\n        # TODO\n        pass\n\n    @property\n    def celsius(self):\n        pass\n\n    @celsius.setter\n    def celsius(self, value):\n        # TODO: raise ValueError if value < -273.15\n        pass\n",
    "solution": "class Temperature:\n    def __init__(self, celsius):\n        self.celsius = celsius\n\n    @property\n    def celsius(self):\n        return self._celsius\n\n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero\")\n        self._celsius = value\n",
    "testCases": [
      {
        "input": "t = Temperature(0)\nprint(t.celsius)",
        "isHidden": false,
        "description": "Initial value stored"
      },
      {
        "input": "t = Temperature(1)\nt.celsius = 10\nprint(t.celsius)",
        "isHidden": false,
        "description": "Setter updates"
      },
      {
        "input": "try:\n    Temperature(-300)\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Reject below absolute zero"
      }
    ],
    "hints": [
      "Use a backing field like `self._celsius`",
      "In `__init__`, assign through the property to reuse validation"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Read-Only Full Name",
    "difficulty": 1,
    "description": "Create a `User` class with `first_name` and `last_name` and a read-only property `full_name`.",
    "starterCode": "class User:\n    def __init__(self, first_name, last_name):\n        pass\n\n    @property\n    def full_name(self):\n        pass\n",
    "solution": "class User:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    @property\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\".strip()\n",
    "testCases": [
      {
        "input": "u = User(\"Ada\", \"Lovelace\")\nprint(u.full_name)",
        "isHidden": false,
        "description": "Combines names"
      },
      {
        "input": "u = User(\"Ada\", \"\")\nprint(u.full_name)",
        "isHidden": true,
        "description": "Handles missing last name"
      },
      {
        "input": "u = User(\"\", \"Lovelace\")\nprint(u.full_name)",
        "isHidden": true,
        "description": "Handles missing first name"
      }
    ],
    "hints": [
      "Use `@property` for a computed attribute",
      "Return a string built from first/last name"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Protected Balance with Methods",
    "difficulty": 2,
    "description": "Create an `Account` class that stores its balance in `_balance` and only changes it through `deposit(amount)` and `withdraw(amount)`. Reject negative deposits/withdrawals.",
    "starterCode": "class Account:\n    def __init__(self, initial_balance=0):\n        pass\n\n    def deposit(self, amount):\n        pass\n\n    def withdraw(self, amount):\n        pass\n\n    def get_balance(self):\n        pass\n",
    "solution": "class Account:\n    def __init__(self, initial_balance=0):\n        self._balance = initial_balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise ValueError(\"amount must be >= 0\")\n        self._balance += amount\n\n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError(\"amount must be >= 0\")\n        if amount > self._balance:\n            return False\n        self._balance -= amount\n        return True\n\n    def get_balance(self):\n        return self._balance\n",
    "testCases": [
      {
        "input": "a = Account(10)\na.deposit(5)\nprint(a.get_balance())",
        "isHidden": false,
        "description": "Deposit works"
      },
      {
        "input": "a = Account(10)\nprint(a.withdraw(7), a.get_balance())",
        "isHidden": false,
        "description": "Withdraw returns True and updates balance"
      },
      {
        "input": "a = Account(10)\nprint(a.withdraw(99), a.get_balance())",
        "isHidden": true,
        "description": "Over-withdraw returns False"
      }
    ],
    "hints": [
      "Use `_balance` backing field",
      "Raise for negative amounts",
      "Return False if insufficient funds"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Email Property Validation",
    "difficulty": 3,
    "description": "Create a `Profile` class with an `email` property. Reject emails that do not contain exactly one `@`.",
    "starterCode": "class Profile:\n    def __init__(self, email):\n        pass\n\n    @property\n    def email(self):\n        pass\n\n    @email.setter\n    def email(self, value):\n        pass\n",
    "solution": "class Profile:\n    def __init__(self, email):\n        self.email = email\n\n    @property\n    def email(self):\n        return self._email\n\n    @email.setter\n    def email(self, value):\n        if value.count(\"@\") != 1:\n            raise ValueError(\"invalid email\")\n        self._email = value\n",
    "testCases": [
      {
        "input": "p = Profile(\"a@b\")\nprint(p.email)",
        "isHidden": false,
        "description": "Valid email"
      },
      {
        "input": "try:\n    Profile(\"ab\")\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Missing @ invalid"
      },
      {
        "input": "p = Profile(\"a@b\")\np.email = \"x@y\"\nprint(p.email)",
        "isHidden": true,
        "description": "Setter re-validates"
      }
    ],
    "hints": [
      "Store backing field like `_email`",
      "Use `value.count(\"@\")` to validate"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Defensive Copy for List",
    "difficulty": 3,
    "description": "Create a `Bag` class that stores items internally and exposes an `items` property that returns a copy (so callers cannot mutate internal state directly).",
    "starterCode": "class Bag:\n    def __init__(self, items=None):\n        pass\n\n    def add(self, item):\n        pass\n\n    @property\n    def items(self):\n        pass\n",
    "solution": "class Bag:\n    def __init__(self, items=None):\n        self._items = list(items) if items is not None else []\n\n    def add(self, item):\n        self._items.append(item)\n\n    @property\n    def items(self):\n        return list(self._items)\n",
    "testCases": [
      {
        "input": "b = Bag([1, 2]); copy = b.items; copy.append(3)\nprint(b.items)",
        "isHidden": false,
        "description": "Mutation of copy does not affect bag"
      },
      {
        "input": "b = Bag(); b.add(\"x\"); print(b.items)",
        "isHidden": false,
        "description": "Add works"
      },
      {
        "input": "b = Bag(None); print(b.items)",
        "isHidden": true,
        "description": "None initializes to empty"
      }
    ],
    "hints": [
      "Store internal list as `_items`",
      "Return `list(self._items)` from the property"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Read-Only ID with Name Mangling",
    "difficulty": 2,
    "description": "Create a `Ticket` class with a “private” `__id` field set in `__init__` and a read-only `id` property.",
    "starterCode": "class Ticket:\n    def __init__(self, ticket_id):\n        pass\n\n    @property\n    def id(self):\n        pass\n",
    "solution": "class Ticket:\n    def __init__(self, ticket_id):\n        self.__id = ticket_id\n\n    @property\n    def id(self):\n        return self.__id\n",
    "testCases": [
      {
        "input": "t = Ticket(123)\nprint(t.id)",
        "isHidden": false,
        "description": "Expose id via property"
      },
      {
        "input": "t = Ticket(1)\nprint(hasattr(t, \"__id\"), hasattr(t, \"_Ticket__id\"))",
        "isHidden": true,
        "description": "Name mangling"
      },
      {
        "input": "t = Ticket(\"x\")\nprint(t.id)",
        "isHidden": true,
        "description": "Works for any value type"
      }
    ],
    "hints": [
      "Store as `self.__id`",
      "Expose via `@property def id(self): return ...`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Clamped Volume (0–100)",
    "difficulty": 3,
    "description": "Create a `Speaker` class with a `volume` property that clamps values into the range 0..100.",
    "starterCode": "class Speaker:\n    def __init__(self, volume=50):\n        pass\n\n    @property\n    def volume(self):\n        pass\n\n    @volume.setter\n    def volume(self, value):\n        pass\n",
    "solution": "class Speaker:\n    def __init__(self, volume=50):\n        self.volume = volume\n\n    @property\n    def volume(self):\n        return self._volume\n\n    @volume.setter\n    def volume(self, value):\n        if value < 0:\n            value = 0\n        if value > 100:\n            value = 100\n        self._volume = value\n",
    "testCases": [
      {
        "input": "s = Speaker(-10)\nprint(s.volume)",
        "isHidden": false,
        "description": "Clamps low"
      },
      {
        "input": "s = Speaker(999)\nprint(s.volume)",
        "isHidden": false,
        "description": "Clamps high"
      },
      {
        "input": "s = Speaker(); s.volume = 80\nprint(s.volume)",
        "isHidden": true,
        "description": "Setter works"
      }
    ],
    "hints": [
      "Assign through the property in `__init__`",
      "Clamp values below 0 and above 100"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Immutable Money Value Object",
    "difficulty": 4,
    "description": "Create a `Money` class with `amount` and `currency`. Prevent changing these after initialization by making them read-only properties.",
    "starterCode": "class Money:\n    def __init__(self, amount, currency):\n        pass\n\n    @property\n    def amount(self):\n        pass\n\n    @property\n    def currency(self):\n        pass\n",
    "solution": "class Money:\n    def __init__(self, amount, currency):\n        self._amount = amount\n        self._currency = currency\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @property\n    def currency(self):\n        return self._currency\n",
    "testCases": [
      {
        "input": "m = Money(10, \"USD\")\nprint(m.amount, m.currency)",
        "isHidden": false,
        "description": "Stores values"
      },
      {
        "input": "m = Money(1, \"USD\")\ntry:\n    m.amount = 2\n    print(\"no\")\nexcept AttributeError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Read-only amount"
      },
      {
        "input": "m = Money(1, \"USD\")\ntry:\n    m.currency = \"EUR\"\n    print(\"no\")\nexcept AttributeError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Read-only currency"
      }
    ],
    "hints": [
      "Expose read-only properties (no setters)",
      "Store backing fields like `_amount`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Lazy Computed Property",
    "difficulty": 4,
    "description": "Create a `Text` class with a string `value`. Provide a property `word_count` that computes the count of words (split by whitespace).",
    "starterCode": "class Text:\n    def __init__(self, value):\n        pass\n\n    @property\n    def word_count(self):\n        pass\n",
    "solution": "class Text:\n    def __init__(self, value):\n        self.value = value\n\n    @property\n    def word_count(self):\n        parts = self.value.split()\n        return len(parts)\n",
    "testCases": [
      {
        "input": "t = Text(\"hello world\")\nprint(t.word_count)",
        "isHidden": false,
        "description": "Two words"
      },
      {
        "input": "t = Text(\"  a   b c  \")\nprint(t.word_count)",
        "isHidden": true,
        "description": "Multiple spaces"
      },
      {
        "input": "t = Text(\"\")\nprint(t.word_count)",
        "isHidden": true,
        "description": "Empty string"
      }
    ],
    "hints": [
      "Use `split()` without arguments",
      "Return `len(...)`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Validated Age (0–130)",
    "difficulty": 3,
    "description": "Create a `Person` class with an `age` property that must be between 0 and 130 (inclusive).",
    "starterCode": "class Person:\n    def __init__(self, age):\n        pass\n\n    @property\n    def age(self):\n        pass\n\n    @age.setter\n    def age(self, value):\n        pass\n",
    "solution": "class Person:\n    def __init__(self, age):\n        self.age = age\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, value):\n        if value < 0 or value > 130:\n            raise ValueError(\"invalid age\")\n        self._age = value\n",
    "testCases": [
      {
        "input": "p = Person(0)\nprint(p.age)",
        "isHidden": false,
        "description": "Lower bound"
      },
      {
        "input": "p = Person(130)\nprint(p.age)",
        "isHidden": true,
        "description": "Upper bound"
      },
      {
        "input": "try:\n    Person(131)\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Out of range raises"
      }
    ],
    "hints": [
      "Validate in the setter",
      "Assign through the property in `__init__`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Settings with Dependent Values",
    "difficulty": 4,
    "description": "Create a `Settings` class with a boolean `debug` property. When `debug` is set to True, also set `log_level` to `\"DEBUG\"`. Otherwise set it to `\"INFO\"`.",
    "starterCode": "class Settings:\n    def __init__(self):\n        pass\n\n    @property\n    def debug(self):\n        pass\n\n    @debug.setter\n    def debug(self, value):\n        pass\n\n    @property\n    def log_level(self):\n        pass\n",
    "solution": "class Settings:\n    def __init__(self):\n        self._debug = False\n        self._log_level = \"INFO\"\n\n    @property\n    def debug(self):\n        return self._debug\n\n    @debug.setter\n    def debug(self, value):\n        self._debug = bool(value)\n        self._log_level = \"DEBUG\" if self._debug else \"INFO\"\n\n    @property\n    def log_level(self):\n        return self._log_level\n",
    "testCases": [
      {
        "input": "s = Settings()\nprint(s.debug, s.log_level)",
        "isHidden": false,
        "description": "Default values"
      },
      {
        "input": "s = Settings(); s.debug = True\nprint(s.debug, s.log_level)",
        "isHidden": false,
        "description": "Debug toggles level"
      },
      {
        "input": "s = Settings(); s.debug = True; s.debug = False\nprint(s.log_level)",
        "isHidden": true,
        "description": "Back to INFO"
      }
    ],
    "hints": [
      "Update dependent state in the setter",
      "Expose `log_level` as read-only"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Rate Limited Counter",
    "difficulty": 4,
    "description": "Create a `RateLimitedCounter` with a max value `limit`. The `increment()` method increases the counter but must never exceed the limit.",
    "starterCode": "class RateLimitedCounter:\n    def __init__(self, limit):\n        pass\n\n    def increment(self):\n        pass\n\n    def value(self):\n        pass\n",
    "solution": "class RateLimitedCounter:\n    def __init__(self, limit):\n        self._limit = limit\n        self._value = 0\n\n    def increment(self):\n        if self._value < self._limit:\n            self._value += 1\n\n    def value(self):\n        return self._value\n",
    "testCases": [
      {
        "input": "c = RateLimitedCounter(2)\nc.increment(); c.increment(); c.increment()\nprint(c.value())",
        "isHidden": false,
        "description": "Stops at limit"
      },
      {
        "input": "c = RateLimitedCounter(0)\nc.increment()\nprint(c.value())",
        "isHidden": true,
        "description": "Zero limit"
      },
      {
        "input": "c = RateLimitedCounter(1)\nprint(c.value())",
        "isHidden": true,
        "description": "Starts at 0"
      }
    ],
    "hints": [
      "Store `_limit` and `_value`",
      "Only increment while `_value < _limit`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Sanitized Username",
    "difficulty": 5,
    "description": "Create an `Account` class with a `username` property. The setter should strip whitespace and reject empty usernames.",
    "starterCode": "class Account:\n    def __init__(self, username):\n        pass\n\n    @property\n    def username(self):\n        pass\n\n    @username.setter\n    def username(self, value):\n        pass\n",
    "solution": "class Account:\n    def __init__(self, username):\n        self.username = username\n\n    @property\n    def username(self):\n        return self._username\n\n    @username.setter\n    def username(self, value):\n        value = str(value).strip()\n        if value == \"\":\n            raise ValueError(\"username cannot be empty\")\n        self._username = value\n",
    "testCases": [
      {
        "input": "a = Account(\"  alice  \")\nprint(a.username)",
        "isHidden": false,
        "description": "Strips whitespace"
      },
      {
        "input": "try:\n    Account(\"   \")\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Rejects empty after strip"
      },
      {
        "input": "a = Account(\"bob\"); a.username = \"  bobby \"\\nprint(a.username)",
        "isHidden": true,
        "description": "Setter sanitizes too"
      }
    ],
    "hints": [
      "Use `strip()`",
      "Validate after stripping",
      "Store a backing field like `_username`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Safe Dictionary Exposure",
    "difficulty": 5,
    "description": "Create a `Headers` class that stores a dict of headers internally. Expose a `data` property that returns a copy so callers can’t mutate internal state.",
    "starterCode": "class Headers:\n    def __init__(self, initial=None):\n        pass\n\n    def set(self, key, value):\n        pass\n\n    @property\n    def data(self):\n        pass\n",
    "solution": "class Headers:\n    def __init__(self, initial=None):\n        self._data = dict(initial) if initial is not None else {}\n\n    def set(self, key, value):\n        self._data[key] = value\n\n    @property\n    def data(self):\n        return dict(self._data)\n",
    "testCases": [
      {
        "input": "h = Headers({\"a\": \"1\"}); d = h.data; d[\"a\"] = \"9\"; print(h.data[\"a\"])",
        "isHidden": false,
        "description": "Copy prevents mutation"
      },
      {
        "input": "h = Headers(); h.set(\"x\", \"y\"); print(h.data)",
        "isHidden": false,
        "description": "Set adds key"
      },
      {
        "input": "h = Headers({\"a\": \"1\"}); print(sorted(list(h.data.keys())))",
        "isHidden": true,
        "description": "Keys preserved"
      }
    ],
    "hints": [
      "Use `dict(...)` to copy a dict",
      "Never return the internal dict directly"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Getter-Only Property",
    "difficulty": 1,
    "description": "Create a `Config` class with a read-only `version` property set in the constructor.",
    "starterCode": "class Config:\n    def __init__(self, version):\n        pass\n\n    @property\n    def version(self):\n        pass\n",
    "solution": "class Config:\n    def __init__(self, version):\n        self._version = version\n\n    @property\n    def version(self):\n        return self._version\n",
    "testCases": [
      {
        "input": "c = Config(\"1.0\")\nprint(c.version)",
        "isHidden": false,
        "description": "Read version"
      },
      {
        "input": "c = Config(2)\nprint(c.version)",
        "isHidden": true,
        "description": "Any type"
      },
      {
        "input": "c = Config(\"x\")\ntry:\n    c.version = \"y\"\n    print(\"no\")\nexcept AttributeError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "No setter"
      }
    ],
    "hints": [
      "Store a backing field",
      "Provide a property without a setter"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t2-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-2",
    "title": "Simple Validation",
    "difficulty": 1,
    "description": "Create a `Percentage` class with a `value` property that must be between 0 and 100 inclusive.",
    "starterCode": "class Percentage:\n    def __init__(self, value):\n        pass\n\n    @property\n    def value(self):\n        pass\n\n    @value.setter\n    def value(self, v):\n        pass\n",
    "solution": "class Percentage:\n    def __init__(self, value):\n        self.value = value\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, v):\n        if v < 0 or v > 100:\n            raise ValueError(\"out of range\")\n        self._value = v\n",
    "testCases": [
      {
        "input": "p = Percentage(50)\nprint(p.value)",
        "isHidden": false,
        "description": "Stores 50"
      },
      {
        "input": "try:\n    Percentage(-1)\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Rejects -1"
      },
      {
        "input": "p = Percentage(0); p.value = 100\nprint(p.value)",
        "isHidden": true,
        "description": "Setter accepts bounds"
      }
    ],
    "hints": [
      "Validate in setter",
      "Assign through property in `__init__`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-ex-3",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Animal Inheritance",
    "difficulty": 2,
    "description": "Create an `Animal` base class with a `name` and a `speak()` method. Create a `Dog` subclass that overrides `speak()`.",
    "starterCode": "class Animal:\n    def __init__(self, name):\n        pass\n\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        pass\n",
    "solution": "class Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        return \"...\" \n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says woof\"\n",
    "testCases": [
      {
        "input": "a = Animal(\"X\")\nprint(a.speak())",
        "isHidden": false,
        "description": "Base speak exists"
      },
      {
        "input": "d = Dog(\"Buddy\")\nprint(d.speak())",
        "isHidden": false,
        "description": "Dog overrides speak"
      },
      {
        "input": "d = Dog(\"Max\")\nprint(isinstance(d, Animal))",
        "isHidden": true,
        "description": "Dog is an Animal"
      }
    ],
    "hints": [
      "Store `name` in the base class",
      "Override `speak` in the subclass"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Calling super().__init__()",
    "difficulty": 2,
    "description": "Create a base class `Vehicle` storing `make`. Create a subclass `Car` storing `make` and `doors`. Use `super().__init__()` in `Car`.",
    "starterCode": "class Vehicle:\n    def __init__(self, make):\n        pass\n\nclass Car(Vehicle):\n    def __init__(self, make, doors):\n        # TODO: call super\n        pass\n",
    "solution": "class Vehicle:\n    def __init__(self, make):\n        self.make = make\n\nclass Car(Vehicle):\n    def __init__(self, make, doors):\n        super().__init__(make)\n        self.doors = doors\n",
    "testCases": [
      {
        "input": "c = Car(\"Toyota\", 4)\nprint(c.make, c.doors)",
        "isHidden": false,
        "description": "Both attributes set"
      },
      {
        "input": "c = Car(\"A\", 2)\nprint(isinstance(c, Vehicle))",
        "isHidden": true,
        "description": "Subclass relationship"
      },
      {
        "input": "v = Vehicle(\"X\")\nprint(v.make)",
        "isHidden": true,
        "description": "Base class stores make"
      }
    ],
    "hints": [
      "Call `super().__init__(make)` in `Car.__init__`",
      "Store `doors` on `self`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Method Extension with super()",
    "difficulty": 3,
    "description": "Create a base class `Logger` with method `format(message)` returning `\"LOG: \" + message`. Create a subclass `TimestampLogger` that prefixes `\"[t] \"` before the base format.",
    "starterCode": "class Logger:\n    def format(self, message):\n        pass\n\nclass TimestampLogger(Logger):\n    def format(self, message):\n        # TODO: use super().format\n        pass\n",
    "solution": "class Logger:\n    def format(self, message):\n        return \"LOG: \" + message\n\nclass TimestampLogger(Logger):\n    def format(self, message):\n        return \"[t] \" + super().format(message)\n",
    "testCases": [
      {
        "input": "print(Logger().format(\"hi\"))",
        "isHidden": false,
        "description": "Base format"
      },
      {
        "input": "print(TimestampLogger().format(\"hi\"))",
        "isHidden": false,
        "description": "Extended format"
      },
      {
        "input": "print(isinstance(TimestampLogger(), Logger))",
        "isHidden": true,
        "description": "Is-a Logger"
      }
    ],
    "hints": [
      "Implement base behavior in `Logger`",
      "Call `super().format(message)` in the subclass"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Employee and Manager",
    "difficulty": 3,
    "description": "Create an `Employee` class with `name` and `salary`. Create a `Manager` subclass with an additional `bonus` and a method `total_comp()` returning salary + bonus.",
    "starterCode": "class Employee:\n    def __init__(self, name, salary):\n        pass\n\nclass Manager(Employee):\n    def __init__(self, name, salary, bonus):\n        pass\n\n    def total_comp(self):\n        pass\n",
    "solution": "class Employee:\n    def __init__(self, name, salary):\n        self.name = name\n        self.salary = salary\n\nclass Manager(Employee):\n    def __init__(self, name, salary, bonus):\n        super().__init__(name, salary)\n        self.bonus = bonus\n\n    def total_comp(self):\n        return self.salary + self.bonus\n",
    "testCases": [
      {
        "input": "m = Manager(\"A\", 100, 20)\nprint(m.total_comp())",
        "isHidden": false,
        "description": "Salary + bonus"
      },
      {
        "input": "e = Employee(\"B\", 50)\nprint(e.name, e.salary)",
        "isHidden": false,
        "description": "Employee stores fields"
      },
      {
        "input": "m = Manager(\"C\", 0, 0)\nprint(isinstance(m, Employee))",
        "isHidden": true,
        "description": "Manager is Employee"
      }
    ],
    "hints": [
      "Call `super().__init__`",
      "Compute total compensation from stored fields"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Abstract-ish Base with NotImplementedError",
    "difficulty": 3,
    "description": "Create a base class `Shape` with `area()` raising `NotImplementedError`. Create `Square` and `Circle` subclasses implementing `area()` (use pi = 3.14159).",
    "starterCode": "class Shape:\n    def area(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        pass\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        pass\n    def area(self):\n        pass\n",
    "solution": "class Shape:\n    def area(self):\n        raise NotImplementedError\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side * self.side\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    def area(self):\n        pi = 3.14159\n        return pi * (self.radius ** 2)\n",
    "testCases": [
      {
        "input": "print(Square(3).area())",
        "isHidden": false,
        "description": "Square area"
      },
      {
        "input": "print(round(Circle(2).area(), 5))",
        "isHidden": false,
        "description": "Circle area"
      },
      {
        "input": "try:\n    Shape().area()\n    print(\"no\")\nexcept NotImplementedError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Base raises"
      }
    ],
    "hints": [
      "Base class should raise NotImplementedError",
      "Override area in subclasses"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Overriding __str__ in a Subclass",
    "difficulty": 2,
    "description": "Create a `Person` class with `name`. Create a `Student` subclass with `student_id`. Override `__str__` in Student to include both.",
    "starterCode": "class Person:\n    def __init__(self, name):\n        pass\n\nclass Student(Person):\n    def __init__(self, name, student_id):\n        pass\n\n    def __str__(self):\n        pass\n",
    "solution": "class Person:\n    def __init__(self, name):\n        self.name = name\n\nclass Student(Person):\n    def __init__(self, name, student_id):\n        super().__init__(name)\n        self.student_id = student_id\n\n    def __str__(self):\n        return f\"{self.name} ({self.student_id})\"\n",
    "testCases": [
      {
        "input": "print(Student(\"A\", 1))",
        "isHidden": false,
        "description": "String includes name and id"
      },
      {
        "input": "s = Student(\"B\", \"X\")\nprint(s.name, s.student_id)",
        "isHidden": true,
        "description": "Inherited name + new id"
      },
      {
        "input": "p = Person(\"C\")\nprint(p.name)",
        "isHidden": true,
        "description": "Base still works"
      }
    ],
    "hints": [
      "Use `super().__init__(name)`",
      "Return a formatted string"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Mixin for JSON-like Dict",
    "difficulty": 4,
    "description": "Create a `ToDictMixin` that provides `to_dict()` returning `self.__dict__`. Use it in a `Book` class with `title` and `author`.",
    "starterCode": "class ToDictMixin:\n    def to_dict(self):\n        pass\n\nclass Book(ToDictMixin):\n    def __init__(self, title, author):\n        pass\n",
    "solution": "class ToDictMixin:\n    def to_dict(self):\n        return dict(self.__dict__)\n\nclass Book(ToDictMixin):\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n",
    "testCases": [
      {
        "input": "b = Book(\"T\", \"A\")\nprint(b.to_dict())",
        "isHidden": false,
        "description": "to_dict returns fields"
      },
      {
        "input": "b = Book(\"X\", \"Y\")\nprint(sorted(b.to_dict().keys()))",
        "isHidden": true,
        "description": "Keys include title/author"
      },
      {
        "input": "b = Book(\"\", \"\")\nprint(b.to_dict())",
        "isHidden": true,
        "description": "Empty strings still included"
      }
    ],
    "hints": [
      "Return a copy of `__dict__`",
      "Inherit from the mixin"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Multiple Inheritance (Simple MRO)",
    "difficulty": 4,
    "description": "Create classes `A` and `B` each with method `who()` returning `\"A\"` / `\"B\"`. Create `C(A, B)` and call `who()` to show MRO uses `A` first.",
    "starterCode": "class A:\n    def who(self):\n        pass\n\nclass B:\n    def who(self):\n        pass\n\nclass C(A, B):\n    pass\n",
    "solution": "class A:\n    def who(self):\n        return \"A\"\n\nclass B:\n    def who(self):\n        return \"B\"\n\nclass C(A, B):\n    pass\n",
    "testCases": [
      {
        "input": "print(C().who())",
        "isHidden": false,
        "description": "Uses A due to MRO"
      },
      {
        "input": "print([cls.__name__ for cls in C.mro()][:3])",
        "isHidden": true,
        "description": "Inspect MRO prefix"
      },
      {
        "input": "print(B().who())",
        "isHidden": true,
        "description": "B who works"
      }
    ],
    "hints": [
      "Define `who` in both classes",
      "C inherits from A first"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Polymorphic Pay Calculation",
    "difficulty": 4,
    "description": "Create `HourlyEmployee` and `SalariedEmployee` subclasses of `Employee`, each implementing `weekly_pay()`. Hourly pay is `hours * rate`; salaried pay is `salary / 52`.",
    "starterCode": "class Employee:\n    def weekly_pay(self):\n        pass\n\nclass HourlyEmployee(Employee):\n    def __init__(self, rate, hours):\n        pass\n    def weekly_pay(self):\n        pass\n\nclass SalariedEmployee(Employee):\n    def __init__(self, salary):\n        pass\n    def weekly_pay(self):\n        pass\n",
    "solution": "class Employee:\n    def weekly_pay(self):\n        raise NotImplementedError\n\nclass HourlyEmployee(Employee):\n    def __init__(self, rate, hours):\n        self.rate = rate\n        self.hours = hours\n    def weekly_pay(self):\n        return self.rate * self.hours\n\nclass SalariedEmployee(Employee):\n    def __init__(self, salary):\n        self.salary = salary\n    def weekly_pay(self):\n        return self.salary / 52\n",
    "testCases": [
      {
        "input": "print(HourlyEmployee(20, 10).weekly_pay())",
        "isHidden": false,
        "description": "Hourly pay"
      },
      {
        "input": "print(round(SalariedEmployee(52000).weekly_pay(), 2))",
        "isHidden": false,
        "description": "Salaried pay"
      },
      {
        "input": "try:\n    Employee().weekly_pay()\n    print(\"no\")\nexcept NotImplementedError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Base raises"
      }
    ],
    "hints": [
      "Override `weekly_pay` in each subclass",
      "Salaried weekly = salary/52"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Reuse via Base Method",
    "difficulty": 3,
    "description": "Create a base class `Greeter` with method `greet(name)` returning `\"Hello, <name>\"`. Create a subclass `ExcitedGreeter` that reuses the base greet and adds `!`.",
    "starterCode": "class Greeter:\n    def greet(self, name):\n        pass\n\nclass ExcitedGreeter(Greeter):\n    def greet(self, name):\n        pass\n",
    "solution": "class Greeter:\n    def greet(self, name):\n        return f\"Hello, {name}\"\n\nclass ExcitedGreeter(Greeter):\n    def greet(self, name):\n        return super().greet(name) + \"!\"\n",
    "testCases": [
      {
        "input": "print(Greeter().greet(\"A\"))",
        "isHidden": false,
        "description": "Base greeting"
      },
      {
        "input": "print(ExcitedGreeter().greet(\"A\"))",
        "isHidden": false,
        "description": "Adds excitement"
      },
      {
        "input": "print(isinstance(ExcitedGreeter(), Greeter))",
        "isHidden": true,
        "description": "Is-a relation"
      }
    ],
    "hints": [
      "Call `super().greet(name)` in subclass",
      "Append \"!\""
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Base Class Contract (LSP-friendly)",
    "difficulty": 4,
    "description": "Create a `Stack` base class with `push(x)` and `pop()`. Implement `ListStack(Stack)` using a list. `pop()` should raise IndexError on empty.",
    "starterCode": "class Stack:\n    def push(self, x):\n        pass\n    def pop(self):\n        pass\n\nclass ListStack(Stack):\n    def __init__(self):\n        pass\n    def push(self, x):\n        pass\n    def pop(self):\n        pass\n",
    "solution": "class Stack:\n    def push(self, x):\n        raise NotImplementedError\n    def pop(self):\n        raise NotImplementedError\n\nclass ListStack(Stack):\n    def __init__(self):\n        self._data = []\n    def push(self, x):\n        self._data.append(x)\n    def pop(self):\n        return self._data.pop()\n",
    "testCases": [
      {
        "input": "s = ListStack(); s.push(1); s.push(2); print(s.pop(), s.pop())",
        "isHidden": false,
        "description": "LIFO order"
      },
      {
        "input": "s = ListStack();\ntry:\n    s.pop()\n    print(\"no\")\nexcept IndexError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Empty pop raises IndexError"
      },
      {
        "input": "print(isinstance(ListStack(), Stack))",
        "isHidden": true,
        "description": "Subclasses Stack"
      }
    ],
    "hints": [
      "Use a list for storage",
      "Use list.pop() to raise IndexError on empty"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Overriding with Different Return Type",
    "difficulty": 4,
    "description": "Create a base class `Parser` with `parse(text)` returning a list of tokens. Create `CSVParser(Parser)` overriding `parse` to split by commas (and strip whitespace).",
    "starterCode": "class Parser:\n    def parse(self, text):\n        pass\n\nclass CSVParser(Parser):\n    def parse(self, text):\n        pass\n",
    "solution": "class Parser:\n    def parse(self, text):\n        raise NotImplementedError\n\nclass CSVParser(Parser):\n    def parse(self, text):\n        if text.strip() == \"\":\n            return []\n        return [p.strip() for p in text.split(\",\")]\n",
    "testCases": [
      {
        "input": "print(CSVParser().parse(\"a, b, c\"))",
        "isHidden": false,
        "description": "Splits and strips"
      },
      {
        "input": "print(CSVParser().parse(\"\"))",
        "isHidden": true,
        "description": "Empty input"
      },
      {
        "input": "print(CSVParser().parse(\"x\"))",
        "isHidden": true,
        "description": "Single token"
      }
    ],
    "hints": [
      "Split by comma",
      "Strip whitespace around parts",
      "Return [] for empty text"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Cooperative super() Chain",
    "difficulty": 5,
    "description": "Create mixins `A` and `B` each implementing `build()` returning a string and calling `super().build()`. Create `Base` with `build()` returning `\"base\"`. In `C(A, B, Base)`, calling `build()` should include all layers.",
    "starterCode": "class Base:\n    def build(self):\n        pass\n\nclass A:\n    def build(self):\n        pass\n\nclass B:\n    def build(self):\n        pass\n\nclass C(A, B, Base):\n    pass\n",
    "solution": "class Base:\n    def build(self):\n        return \"base\"\n\nclass A:\n    def build(self):\n        return \"A(\" + super().build() + \")\"\n\nclass B:\n    def build(self):\n        return \"B(\" + super().build() + \")\"\n\nclass C(A, B, Base):\n    pass\n",
    "testCases": [
      {
        "input": "print(C().build())",
        "isHidden": false,
        "description": "Chains through MRO"
      },
      {
        "input": "print([c.__name__ for c in C.mro()][:4])",
        "isHidden": true,
        "description": "MRO includes A then B then Base"
      },
      {
        "input": "print(isinstance(C(), Base))",
        "isHidden": true,
        "description": "Still a Base"
      }
    ],
    "hints": [
      "Each mixin should call `super().build()`",
      "Order of bases controls MRO",
      "Base terminates the chain"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Custom Exception in Base Class",
    "difficulty": 5,
    "description": "Create an exception `NotSupportedError`. Create base class `Storage` with `load(key)` raising NotSupportedError. Create `DictStorage(Storage)` that implements load from an internal dict.",
    "starterCode": "class NotSupportedError(Exception):\n    pass\n\nclass Storage:\n    def load(self, key):\n        pass\n\nclass DictStorage(Storage):\n    def __init__(self, data):\n        pass\n    def load(self, key):\n        pass\n",
    "solution": "class NotSupportedError(Exception):\n    pass\n\nclass Storage:\n    def load(self, key):\n        raise NotSupportedError\n\nclass DictStorage(Storage):\n    def __init__(self, data):\n        self._data = dict(data)\n    def load(self, key):\n        return self._data.get(key)\n",
    "testCases": [
      {
        "input": "print(DictStorage({\"a\": 1}).load(\"a\"))",
        "isHidden": false,
        "description": "Loads existing key"
      },
      {
        "input": "print(DictStorage({\"a\": 1}).load(\"x\"))",
        "isHidden": true,
        "description": "Missing key returns None"
      },
      {
        "input": "try:\n    Storage().load(\"a\")\n    print(\"no\")\nexcept NotSupportedError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Base raises custom exception"
      }
    ],
    "hints": [
      "Raise the custom exception in the base class",
      "Subclass overrides to implement behavior",
      "Use dict.get for missing keys"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Basic Subclass",
    "difficulty": 1,
    "description": "Create a `Cat` class that inherits from `Animal` and overrides `speak()` to return `\"meow\"`.",
    "starterCode": "class Animal:\n    def speak(self):\n        pass\n\nclass Cat(Animal):\n    def speak(self):\n        pass\n",
    "solution": "class Animal:\n    def speak(self):\n        return \"...\" \n\nclass Cat(Animal):\n    def speak(self):\n        return \"meow\"\n",
    "testCases": [
      {
        "input": "print(Cat().speak())",
        "isHidden": false,
        "description": "Cat meows"
      },
      {
        "input": "print(isinstance(Cat(), Animal))",
        "isHidden": true,
        "description": "Cat is Animal"
      },
      {
        "input": "print(Animal().speak())",
        "isHidden": true,
        "description": "Base speaks"
      }
    ],
    "hints": [
      "Use `class Cat(Animal):`",
      "Return the correct string"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t3-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-3",
    "title": "Override a Method",
    "difficulty": 1,
    "description": "Create `Bird` inheriting from `Animal` and override `speak()` to return `\"chirp\"`.",
    "starterCode": "class Animal:\n    def speak(self):\n        pass\n\nclass Bird(Animal):\n    def speak(self):\n        pass\n",
    "solution": "class Animal:\n    def speak(self):\n        return \"...\" \n\nclass Bird(Animal):\n    def speak(self):\n        return \"chirp\"\n",
    "testCases": [
      {
        "input": "print(Bird().speak())",
        "isHidden": false,
        "description": "Bird chirps"
      },
      {
        "input": "print(isinstance(Bird(), Animal))",
        "isHidden": true,
        "description": "Bird is Animal"
      },
      {
        "input": "print(Bird().speak().upper())",
        "isHidden": true,
        "description": "String result"
      }
    ],
    "hints": [
      "Override `speak` in subclass",
      "Return \"chirp\""
    ],
    "language": "python"
  },
  {
    "id": "cs103-ex-4",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Duck-Typed Renderer",
    "difficulty": 2,
    "description": "Create two classes `Text` and `Html` that both implement a `render()` method. Write a `Renderer` class with method `render_all(items)` that returns a list of each item’s rendered string.",
    "starterCode": "class Text:\n    def __init__(self, value):\n        pass\n    def render(self):\n        pass\n\nclass Html:\n    def __init__(self, value):\n        pass\n    def render(self):\n        pass\n\nclass Renderer:\n    def render_all(self, items):\n        pass\n",
    "solution": "class Text:\n    def __init__(self, value):\n        self.value = value\n    def render(self):\n        return self.value\n\nclass Html:\n    def __init__(self, value):\n        self.value = value\n    def render(self):\n        return f\"<p>{self.value}</p>\"\n\nclass Renderer:\n    def render_all(self, items):\n        return [item.render() for item in items]\n",
    "testCases": [
      {
        "input": "r = Renderer()\nprint(r.render_all([Text(\"a\"), Html(\"b\")]))",
        "isHidden": false,
        "description": "Works across types"
      },
      {
        "input": "r = Renderer()\nprint(r.render_all([]))",
        "isHidden": true,
        "description": "Empty list"
      },
      {
        "input": "r = Renderer()\nprint(r.render_all([Html(\"x\"), Html(\"y\")]))",
        "isHidden": true,
        "description": "All HTML"
      }
    ],
    "hints": [
      "Polymorphism here is “anything with render() works”",
      "Use a list comprehension in `render_all`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Polymorphic Shape Areas",
    "difficulty": 2,
    "description": "Create `Rectangle` and `Circle` classes each with an `area()` method. Create `AreaCalculator` with method `total(shapes)` summing their areas (pi = 3.14159).",
    "starterCode": "class Rectangle:\n    def __init__(self, w, h):\n        pass\n    def area(self):\n        pass\n\nclass Circle:\n    def __init__(self, r):\n        pass\n    def area(self):\n        pass\n\nclass AreaCalculator:\n    def total(self, shapes):\n        pass\n",
    "solution": "class Rectangle:\n    def __init__(self, w, h):\n        self.w = w\n        self.h = h\n    def area(self):\n        return self.w * self.h\n\nclass Circle:\n    def __init__(self, r):\n        self.r = r\n    def area(self):\n        pi = 3.14159\n        return pi * (self.r ** 2)\n\nclass AreaCalculator:\n    def total(self, shapes):\n        return sum(s.area() for s in shapes)\n",
    "testCases": [
      {
        "input": "calc = AreaCalculator(); print(round(calc.total([Rectangle(2, 3), Circle(2)]), 5))",
        "isHidden": false,
        "description": "Sum mixed shapes"
      },
      {
        "input": "calc = AreaCalculator(); print(calc.total([]))",
        "isHidden": true,
        "description": "Empty sum"
      },
      {
        "input": "calc = AreaCalculator(); print(calc.total([Rectangle(0, 10)]))",
        "isHidden": true,
        "description": "Zero area"
      }
    ],
    "hints": [
      "Each shape implements area()",
      "Use sum(...) to add them up"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Operator Overload: __len__",
    "difficulty": 3,
    "description": "Create a `Playlist` class that stores songs and supports `len(playlist)` via `__len__`.",
    "starterCode": "class Playlist:\n    def __init__(self):\n        pass\n    def add(self, song):\n        pass\n    def __len__(self):\n        pass\n",
    "solution": "class Playlist:\n    def __init__(self):\n        self._songs = []\n    def add(self, song):\n        self._songs.append(song)\n    def __len__(self):\n        return len(self._songs)\n",
    "testCases": [
      {
        "input": "p = Playlist(); p.add(\"a\"); p.add(\"b\"); print(len(p))",
        "isHidden": false,
        "description": "len counts songs"
      },
      {
        "input": "p = Playlist(); print(len(p))",
        "isHidden": true,
        "description": "Empty length"
      },
      {
        "input": "p = Playlist(); p.add(\"x\"); print(len(p))",
        "isHidden": true,
        "description": "Single item"
      }
    ],
    "hints": [
      "Store songs in a list",
      "Return length of that list from `__len__`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Operator Overload: __add__ for Money",
    "difficulty": 3,
    "description": "Create a `Money` class with `amount` and `currency`. Implement `__add__` to add two Money objects with the same currency, otherwise raise ValueError.",
    "starterCode": "class Money:\n    def __init__(self, amount, currency):\n        pass\n    def __add__(self, other):\n        pass\n    def __repr__(self):\n        pass\n",
    "solution": "class Money:\n    def __init__(self, amount, currency):\n        self.amount = amount\n        self.currency = currency\n    def __add__(self, other):\n        if self.currency != other.currency:\n            raise ValueError(\"currency mismatch\")\n        return Money(self.amount + other.amount, self.currency)\n    def __repr__(self):\n        return f\"Money({self.amount}, {self.currency})\"\n",
    "testCases": [
      {
        "input": "print(Money(5, \"USD\") + Money(7, \"USD\"))",
        "isHidden": false,
        "description": "Adds same currency"
      },
      {
        "input": "try:\n    Money(1, \"USD\") + Money(1, \"EUR\")\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Reject mismatched currency"
      },
      {
        "input": "m = Money(0, \"USD\") + Money(0, \"USD\")\nprint(m)",
        "isHidden": true,
        "description": "Zero addition"
      }
    ],
    "hints": [
      "Check currencies before adding",
      "Return a new Money instance"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Strategy Pattern: Discount Policies",
    "difficulty": 4,
    "description": "Create discount policy classes `NoDiscount` and `PercentDiscount` each with `apply(subtotal)` returning the discounted total. Create a `Checkout` class that composes a policy.",
    "starterCode": "class NoDiscount:\n    def apply(self, subtotal):\n        pass\n\nclass PercentDiscount:\n    def __init__(self, percent):\n        pass\n    def apply(self, subtotal):\n        pass\n\nclass Checkout:\n    def __init__(self, policy):\n        pass\n    def total(self, subtotal):\n        pass\n",
    "solution": "class NoDiscount:\n    def apply(self, subtotal):\n        return subtotal\n\nclass PercentDiscount:\n    def __init__(self, percent):\n        self.percent = percent\n    def apply(self, subtotal):\n        return subtotal * (1 - self.percent / 100)\n\nclass Checkout:\n    def __init__(self, policy):\n        self.policy = policy\n    def total(self, subtotal):\n        return self.policy.apply(subtotal)\n",
    "testCases": [
      {
        "input": "print(Checkout(NoDiscount()).total(100))",
        "isHidden": false,
        "description": "No discount"
      },
      {
        "input": "print(Checkout(PercentDiscount(10)).total(200))",
        "isHidden": false,
        "description": "10% off"
      },
      {
        "input": "print(round(Checkout(PercentDiscount(25)).total(80), 2))",
        "isHidden": true,
        "description": "Other percentage"
      }
    ],
    "hints": [
      "Policies share the same method name: apply()",
      "Checkout delegates to the policy"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Iterable via __iter__",
    "difficulty": 4,
    "description": "Create a `Team` class that stores members and supports iteration with `for member in team:`.",
    "starterCode": "class Team:\n    def __init__(self):\n        pass\n    def add(self, member):\n        pass\n    def __iter__(self):\n        pass\n",
    "solution": "class Team:\n    def __init__(self):\n        self._members = []\n    def add(self, member):\n        self._members.append(member)\n    def __iter__(self):\n        return iter(self._members)\n",
    "testCases": [
      {
        "input": "t = Team(); t.add(\"a\"); t.add(\"b\"); print([m for m in t])",
        "isHidden": false,
        "description": "Iterates members"
      },
      {
        "input": "t = Team(); print([m for m in t])",
        "isHidden": true,
        "description": "Empty iteration"
      },
      {
        "input": "t = Team(); t.add(\"x\"); print(list(t))",
        "isHidden": true,
        "description": "Works with list()"
      }
    ],
    "hints": [
      "Return an iterator from `__iter__`",
      "Use `iter(self._members)`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Polymorphic Notifications",
    "difficulty": 3,
    "description": "Create `EmailNotifier` and `SMSNotifier` each with `send(message)` returning a string. Create `NotificationService` that sends via any notifier.",
    "starterCode": "class EmailNotifier:\n    def __init__(self, address):\n        pass\n    def send(self, message):\n        pass\n\nclass SMSNotifier:\n    def __init__(self, phone):\n        pass\n    def send(self, message):\n        pass\n\nclass NotificationService:\n    def __init__(self, notifier):\n        pass\n    def notify(self, message):\n        pass\n",
    "solution": "class EmailNotifier:\n    def __init__(self, address):\n        self.address = address\n    def send(self, message):\n        return f\"email:{self.address}:{message}\"\n\nclass SMSNotifier:\n    def __init__(self, phone):\n        self.phone = phone\n    def send(self, message):\n        return f\"sms:{self.phone}:{message}\"\n\nclass NotificationService:\n    def __init__(self, notifier):\n        self.notifier = notifier\n    def notify(self, message):\n        return self.notifier.send(message)\n",
    "testCases": [
      {
        "input": "print(NotificationService(EmailNotifier(\"a@b\")).notify(\"hi\"))",
        "isHidden": false,
        "description": "Email path"
      },
      {
        "input": "print(NotificationService(SMSNotifier(\"123\")).notify(\"hi\"))",
        "isHidden": false,
        "description": "SMS path"
      },
      {
        "input": "print(NotificationService(EmailNotifier(\"x@y\")).notify(\"\"))",
        "isHidden": true,
        "description": "Empty message"
      }
    ],
    "hints": [
      "Both notifiers implement the same method name",
      "Service delegates to `send`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Comparable via __lt__",
    "difficulty": 4,
    "description": "Create a `Task` class with `priority` and implement `__lt__` so tasks can be sorted by priority.",
    "starterCode": "class Task:\n    def __init__(self, name, priority):\n        pass\n    def __lt__(self, other):\n        pass\n    def __repr__(self):\n        pass\n",
    "solution": "class Task:\n    def __init__(self, name, priority):\n        self.name = name\n        self.priority = priority\n    def __lt__(self, other):\n        return self.priority < other.priority\n    def __repr__(self):\n        return f\"Task({self.name},{self.priority})\"\n",
    "testCases": [
      {
        "input": "tasks = [Task(\"a\", 2), Task(\"b\", 1)]; tasks.sort(); print(tasks)",
        "isHidden": false,
        "description": "Sort uses __lt__"
      },
      {
        "input": "tasks = [Task(\"x\", 0), Task(\"y\", 0)]; tasks.sort(); print(tasks)",
        "isHidden": true,
        "description": "Equal priorities ok"
      },
      {
        "input": "print(Task(\"a\", 1) < Task(\"b\", 2))",
        "isHidden": true,
        "description": "Direct comparison"
      }
    ],
    "hints": [
      "Compare priorities in `__lt__`",
      "Implement a simple __repr__ for readable output"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Polymorphic Serialization",
    "difficulty": 4,
    "description": "Create `User` and `Admin` classes each with `to_dict()` returning a dict. `Admin` should include an extra field `role=\"admin\"`. Show that code can serialize either type.",
    "starterCode": "class User:\n    def __init__(self, username):\n        pass\n    def to_dict(self):\n        pass\n\nclass Admin(User):\n    def to_dict(self):\n        pass\n",
    "solution": "class User:\n    def __init__(self, username):\n        self.username = username\n    def to_dict(self):\n        return {\"username\": self.username}\n\nclass Admin(User):\n    def to_dict(self):\n        data = super().to_dict()\n        data[\"role\"] = \"admin\"\n        return data\n",
    "testCases": [
      {
        "input": "print(User(\"a\").to_dict())",
        "isHidden": false,
        "description": "User dict"
      },
      {
        "input": "print(Admin(\"root\").to_dict())",
        "isHidden": false,
        "description": "Admin dict extends user"
      },
      {
        "input": "objs = [User(\"x\"), Admin(\"y\")]; print([o.to_dict() for o in objs])",
        "isHidden": true,
        "description": "List comprehension works"
      }
    ],
    "hints": [
      "Return a dict",
      "Admin can call `super().to_dict()` then add a field"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Callable Objects (__call__)",
    "difficulty": 4,
    "description": "Create a `Multiplier` class initialized with a factor and make instances callable (using `__call__`) to multiply numbers.",
    "starterCode": "class Multiplier:\n    def __init__(self, factor):\n        pass\n    def __call__(self, x):\n        pass\n",
    "solution": "class Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n    def __call__(self, x):\n        return self.factor * x\n",
    "testCases": [
      {
        "input": "double = Multiplier(2)\nprint(double(5))",
        "isHidden": false,
        "description": "Callable multiplies"
      },
      {
        "input": "m = Multiplier(-1)\nprint(m(10))",
        "isHidden": true,
        "description": "Negative factor"
      },
      {
        "input": "m = Multiplier(0)\nprint(m(999))",
        "isHidden": true,
        "description": "Zero factor"
      }
    ],
    "hints": [
      "Store factor in __init__",
      "Return `factor * x` in `__call__`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Context Manager (__enter__/__exit__)",
    "difficulty": 5,
    "description": "Create a `Timer` context manager that records start/stop. When used in `with Timer() as t:`, it should set `t.seconds` to a non-negative float when exiting.",
    "starterCode": "import time\n\nclass Timer:\n    def __enter__(self):\n        pass\n    def __exit__(self, exc_type, exc, tb):\n        pass\n",
    "solution": "import time\n\nclass Timer:\n    def __enter__(self):\n        self._start = time.time()\n        self.seconds = 0.0\n        return self\n    def __exit__(self, exc_type, exc, tb):\n        self.seconds = max(0.0, time.time() - self._start)\n        return False\n",
    "testCases": [
      {
        "input": "with Timer() as t:\n    x = 1 + 1\nprint(t.seconds >= 0.0)",
        "isHidden": false,
        "description": "Produces seconds"
      },
      {
        "input": "with Timer() as t:\n    pass\nprint(isinstance(t.seconds, float))",
        "isHidden": true,
        "description": "Seconds is float"
      },
      {
        "input": "with Timer() as t:\n    pass\nprint(t.seconds >= 0.0)",
        "isHidden": true,
        "description": "Non-negative"
      }
    ],
    "hints": [
      "Return `self` from `__enter__`",
      "Set `seconds` in `__exit__`",
      "Return False to re-raise exceptions"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Polymorphic Filtering",
    "difficulty": 3,
    "description": "Create `EvenFilter` and `OddFilter` classes each with `keep(n)` returning True/False. Create `Filterer` that uses any filter to filter a list.",
    "starterCode": "class EvenFilter:\n    def keep(self, n):\n        pass\n\nclass OddFilter:\n    def keep(self, n):\n        pass\n\nclass Filterer:\n    def __init__(self, filt):\n        pass\n    def apply(self, nums):\n        pass\n",
    "solution": "class EvenFilter:\n    def keep(self, n):\n        return n % 2 == 0\n\nclass OddFilter:\n    def keep(self, n):\n        return n % 2 != 0\n\nclass Filterer:\n    def __init__(self, filt):\n        self.filt = filt\n    def apply(self, nums):\n        return [n for n in nums if self.filt.keep(n)]\n",
    "testCases": [
      {
        "input": "print(Filterer(EvenFilter()).apply([1,2,3,4]))",
        "isHidden": false,
        "description": "Keeps evens"
      },
      {
        "input": "print(Filterer(OddFilter()).apply([1,2,3,4]))",
        "isHidden": false,
        "description": "Keeps odds"
      },
      {
        "input": "print(Filterer(EvenFilter()).apply([]))",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Each filter implements `keep(n)`",
      "Filterer composes a filter and delegates"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Proxy Object (Forwarding)",
    "difficulty": 5,
    "description": "Create a `LoggingList` wrapper around a list. It should implement `append(x)` and `__len__`, and keep a list of appended items in `log`.",
    "starterCode": "class LoggingList:\n    def __init__(self):\n        pass\n    def append(self, x):\n        pass\n    def __len__(self):\n        pass\n",
    "solution": "class LoggingList:\n    def __init__(self):\n        self._data = []\n        self.log = []\n    def append(self, x):\n        self.log.append(x)\n        self._data.append(x)\n    def __len__(self):\n        return len(self._data)\n",
    "testCases": [
      {
        "input": "ll = LoggingList(); ll.append(1); ll.append(2)\nprint(len(ll), ll.log)",
        "isHidden": false,
        "description": "Tracks appended values"
      },
      {
        "input": "ll = LoggingList(); print(len(ll), ll.log)",
        "isHidden": true,
        "description": "Starts empty"
      },
      {
        "input": "ll = LoggingList(); ll.append(\"x\")\nprint(ll.log)",
        "isHidden": true,
        "description": "Works for non-numbers"
      }
    ],
    "hints": [
      "Wrap a list inside the class",
      "Append to log and underlying list",
      "Return len of underlying list"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Polymorphic Formatter",
    "difficulty": 5,
    "description": "Create `UpperFormatter` and `LowerFormatter` each with `format(text)`. Create `FormatterPipeline` that applies a list of formatters in order.",
    "starterCode": "class UpperFormatter:\n    def format(self, text):\n        pass\n\nclass LowerFormatter:\n    def format(self, text):\n        pass\n\nclass FormatterPipeline:\n    def __init__(self, formatters):\n        pass\n    def run(self, text):\n        pass\n",
    "solution": "class UpperFormatter:\n    def format(self, text):\n        return text.upper()\n\nclass LowerFormatter:\n    def format(self, text):\n        return text.lower()\n\nclass FormatterPipeline:\n    def __init__(self, formatters):\n        self.formatters = list(formatters)\n    def run(self, text):\n        out = text\n        for f in self.formatters:\n            out = f.format(out)\n        return out\n",
    "testCases": [
      {
        "input": "p = FormatterPipeline([UpperFormatter()]); print(p.run(\"Hi\"))",
        "isHidden": false,
        "description": "Uppercase"
      },
      {
        "input": "p = FormatterPipeline([LowerFormatter()]); print(p.run(\"Hi\"))",
        "isHidden": false,
        "description": "Lowercase"
      },
      {
        "input": "p = FormatterPipeline([UpperFormatter(), LowerFormatter()]); print(p.run(\"Hi\"))",
        "isHidden": true,
        "description": "Order matters"
      }
    ],
    "hints": [
      "Pipeline applies each formatter sequentially",
      "Each formatter has the same method name: format"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Duck Typing Basics",
    "difficulty": 1,
    "description": "Create `Dog` and `Cat` classes each with a `speak()` method returning a string.",
    "starterCode": "class Dog:\n    def speak(self):\n        pass\n\nclass Cat:\n    def speak(self):\n        pass\n",
    "solution": "class Dog:\n    def speak(self):\n        return \"woof\"\n\nclass Cat:\n    def speak(self):\n        return \"meow\"\n",
    "testCases": [
      {
        "input": "print(Dog().speak(), Cat().speak())",
        "isHidden": false,
        "description": "Both speak"
      },
      {
        "input": "print(Dog().speak().upper())",
        "isHidden": true,
        "description": "String output"
      },
      {
        "input": "print(Cat().speak())",
        "isHidden": true,
        "description": "Cat output"
      }
    ],
    "hints": [
      "Return simple strings",
      "Both classes share the same method name"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t4-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-4",
    "title": "Basic Operator Overloading",
    "difficulty": 1,
    "description": "Create a `Box` class with `value` and implement `__str__` to return the string form of value.",
    "starterCode": "class Box:\n    def __init__(self, value):\n        pass\n    def __str__(self):\n        pass\n",
    "solution": "class Box:\n    def __init__(self, value):\n        self.value = value\n    def __str__(self):\n        return str(self.value)\n",
    "testCases": [
      {
        "input": "print(Box(5))",
        "isHidden": false,
        "description": "Print uses __str__"
      },
      {
        "input": "print(str(Box(\"x\")))",
        "isHidden": true,
        "description": "Works with strings"
      },
      {
        "input": "print(Box(None))",
        "isHidden": true,
        "description": "Works with None"
      }
    ],
    "hints": [
      "Return `str(self.value)`",
      "`print(obj)` uses __str__"
    ],
    "language": "python"
  },
  {
    "id": "cs103-ex-5",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Singleton Config",
    "difficulty": 3,
    "description": "Implement a `Config` class using the Singleton pattern: every call to `Config()` should return the same instance. Store a `settings` dict on the instance.",
    "starterCode": "class Config:\n    _instance = None\n\n    def __new__(cls):\n        # TODO\n        pass\n\n    def __init__(self):\n        # TODO: initialize settings once\n        pass\n",
    "solution": "class Config:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        if getattr(self, \"_initialized\", False):\n            return\n        self.settings = {}\n        self._initialized = True\n",
    "testCases": [
      {
        "input": "a = Config(); b = Config(); print(a is b)",
        "isHidden": false,
        "description": "Same instance"
      },
      {
        "input": "a = Config(); a.settings[\"x\"] = 1; b = Config(); print(b.settings[\"x\"])",
        "isHidden": false,
        "description": "Shared state"
      },
      {
        "input": "a = Config(); print(isinstance(a.settings, dict))",
        "isHidden": true,
        "description": "settings is dict"
      }
    ],
    "hints": [
      "Override `__new__` to control instance creation",
      "Initialize settings only once"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Factory: Create Shapes",
    "difficulty": 3,
    "description": "Create `Circle` and `Square` classes and a `ShapeFactory` with method `create(kind, size)` returning the correct shape. Each shape must have `area()` (pi=3.14159).",
    "starterCode": "class Circle:\n    def __init__(self, r):\n        pass\n    def area(self):\n        pass\n\nclass Square:\n    def __init__(self, side):\n        pass\n    def area(self):\n        pass\n\nclass ShapeFactory:\n    def create(self, kind, size):\n        pass\n",
    "solution": "class Circle:\n    def __init__(self, r):\n        self.r = r\n    def area(self):\n        pi = 3.14159\n        return pi * (self.r ** 2)\n\nclass Square:\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side * self.side\n\nclass ShapeFactory:\n    def create(self, kind, size):\n        if kind == \"circle\":\n            return Circle(size)\n        if kind == \"square\":\n            return Square(size)\n        raise ValueError(\"unknown kind\")\n",
    "testCases": [
      {
        "input": "f = ShapeFactory(); print(round(f.create(\"circle\", 2).area(), 5))",
        "isHidden": false,
        "description": "Circle created"
      },
      {
        "input": "f = ShapeFactory(); print(f.create(\"square\", 3).area())",
        "isHidden": false,
        "description": "Square created"
      },
      {
        "input": "f = ShapeFactory();\ntry:\n    f.create(\"x\", 1)\n    print(\"no\")\nexcept ValueError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Unknown kind raises"
      }
    ],
    "hints": [
      "Factory chooses which class to instantiate based on `kind`",
      "Raise on unknown kind"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Observer: Simple Event Bus",
    "difficulty": 3,
    "description": "Create an `EventBus` class that supports `subscribe(fn)` and `publish(message)`. All subscribers should be called with the message.",
    "starterCode": "class EventBus:\n    def __init__(self):\n        pass\n    def subscribe(self, fn):\n        pass\n    def publish(self, message):\n        pass\n",
    "solution": "class EventBus:\n    def __init__(self):\n        self._subs = []\n    def subscribe(self, fn):\n        self._subs.append(fn)\n    def publish(self, message):\n        for fn in self._subs:\n            fn(message)\n",
    "testCases": [
      {
        "input": "bus = EventBus(); out = []\nbus.subscribe(lambda m: out.append(\"A:\" + m))\nbus.subscribe(lambda m: out.append(\"B:\" + m))\nbus.publish(\"hi\")\nprint(out)",
        "isHidden": false,
        "description": "Both subscribers notified"
      },
      {
        "input": "bus = EventBus(); out = []; bus.publish(\"x\"); print(out)",
        "isHidden": true,
        "description": "No subscribers ok"
      },
      {
        "input": "bus = EventBus(); out = []; bus.subscribe(lambda m: out.append(m)); bus.publish(\"\"); print(out)",
        "isHidden": true,
        "description": "Empty message delivered"
      }
    ],
    "hints": [
      "Store subscribers in a list",
      "Loop and call each function"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Strategy: Sorting Policies",
    "difficulty": 4,
    "description": "Create `Ascending` and `Descending` strategy classes each with `sort(nums)` returning a new sorted list. Create `Sorter` that composes a strategy.",
    "starterCode": "class Ascending:\n    def sort(self, nums):\n        pass\n\nclass Descending:\n    def sort(self, nums):\n        pass\n\nclass Sorter:\n    def __init__(self, strategy):\n        pass\n    def run(self, nums):\n        pass\n",
    "solution": "class Ascending:\n    def sort(self, nums):\n        return sorted(nums)\n\nclass Descending:\n    def sort(self, nums):\n        return sorted(nums, reverse=True)\n\nclass Sorter:\n    def __init__(self, strategy):\n        self.strategy = strategy\n    def run(self, nums):\n        return self.strategy.sort(nums)\n",
    "testCases": [
      {
        "input": "print(Sorter(Ascending()).run([3,1,2]))",
        "isHidden": false,
        "description": "Ascending"
      },
      {
        "input": "print(Sorter(Descending()).run([3,1,2]))",
        "isHidden": false,
        "description": "Descending"
      },
      {
        "input": "print(Sorter(Ascending()).run([]))",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Return a new list (don’t mutate input)",
      "Delegate to the strategy"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Decorator: Logging Service",
    "difficulty": 4,
    "description": "Create a `Service` class with `run()` returning `\"ok\"`. Create a `LoggingDecorator` that wraps any service and returns `\"LOG:\" + service.run()`.",
    "starterCode": "class Service:\n    def run(self):\n        pass\n\nclass LoggingDecorator:\n    def __init__(self, svc):\n        pass\n    def run(self):\n        pass\n",
    "solution": "class Service:\n    def run(self):\n        return \"ok\"\n\nclass LoggingDecorator:\n    def __init__(self, svc):\n        self._svc = svc\n    def run(self):\n        return \"LOG:\" + self._svc.run()\n",
    "testCases": [
      {
        "input": "print(LoggingDecorator(Service()).run())",
        "isHidden": false,
        "description": "Decorates output"
      },
      {
        "input": "print(Service().run())",
        "isHidden": true,
        "description": "Base service ok"
      },
      {
        "input": "print(LoggingDecorator(LoggingDecorator(Service())).run())",
        "isHidden": true,
        "description": "Decorator can stack"
      }
    ],
    "hints": [
      "Store wrapped service in `__init__`",
      "Delegate to wrapped `run()`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Adapter: LegacyPrinter to Printer",
    "difficulty": 4,
    "description": "Create a `LegacyPrinter` with method `old_print(text)` and a `PrinterAdapter` that provides `print(text)` by delegating to `old_print`.",
    "starterCode": "class LegacyPrinter:\n    def old_print(self, text):\n        pass\n\nclass PrinterAdapter:\n    def __init__(self, legacy):\n        pass\n    def print(self, text):\n        pass\n",
    "solution": "class LegacyPrinter:\n    def old_print(self, text):\n        return \"OLD:\" + text\n\nclass PrinterAdapter:\n    def __init__(self, legacy):\n        self.legacy = legacy\n    def print(self, text):\n        return self.legacy.old_print(text)\n",
    "testCases": [
      {
        "input": "print(PrinterAdapter(LegacyPrinter()).print(\"hi\"))",
        "isHidden": false,
        "description": "Adapter delegates"
      },
      {
        "input": "print(LegacyPrinter().old_print(\"x\"))",
        "isHidden": true,
        "description": "Legacy still works"
      },
      {
        "input": "print(PrinterAdapter(LegacyPrinter()).print(\"\"))",
        "isHidden": true,
        "description": "Empty string"
      }
    ],
    "hints": [
      "Adapter wraps the legacy instance",
      "Expose the new interface expected by callers"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Facade: Simple API Client",
    "difficulty": 3,
    "description": "Create internal classes `Authenticator` and `Requester`. Build a `ApiClient` facade with `get(token, path)` that authenticates then requests.",
    "starterCode": "class Authenticator:\n    def is_valid(self, token):\n        pass\n\nclass Requester:\n    def get(self, path):\n        pass\n\nclass ApiClient:\n    def __init__(self):\n        pass\n    def get(self, token, path):\n        pass\n",
    "solution": "class Authenticator:\n    def is_valid(self, token):\n        return token == \"token\"\n\nclass Requester:\n    def get(self, path):\n        return \"GET:\" + path\n\nclass ApiClient:\n    def __init__(self):\n        self._auth = Authenticator()\n        self._req = Requester()\n    def get(self, token, path):\n        if not self._auth.is_valid(token):\n            return \"401\"\n        return self._req.get(path)\n",
    "testCases": [
      {
        "input": "c = ApiClient(); print(c.get(\"token\", \"/x\"))",
        "isHidden": false,
        "description": "Valid token succeeds"
      },
      {
        "input": "c = ApiClient(); print(c.get(\"bad\", \"/x\"))",
        "isHidden": false,
        "description": "Invalid token returns 401"
      },
      {
        "input": "c = ApiClient(); print(c.get(\"token\", \"\"))",
        "isHidden": true,
        "description": "Empty path"
      }
    ],
    "hints": [
      "Facade hides subsystem complexity",
      "ApiClient should coordinate authenticator and requester"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Command Pattern: Light Switch",
    "difficulty": 4,
    "description": "Create `Light` with `on()` and `off()`. Create commands `OnCommand` and `OffCommand` with `execute()`. Create `Remote` that runs a command.",
    "starterCode": "class Light:\n    def __init__(self):\n        pass\n    def on(self):\n        pass\n    def off(self):\n        pass\n\nclass OnCommand:\n    def __init__(self, light):\n        pass\n    def execute(self):\n        pass\n\nclass OffCommand:\n    def __init__(self, light):\n        pass\n    def execute(self):\n        pass\n\nclass Remote:\n    def run(self, command):\n        pass\n",
    "solution": "class Light:\n    def __init__(self):\n        self.is_on = False\n    def on(self):\n        self.is_on = True\n    def off(self):\n        self.is_on = False\n\nclass OnCommand:\n    def __init__(self, light):\n        self.light = light\n    def execute(self):\n        self.light.on()\n\nclass OffCommand:\n    def __init__(self, light):\n        self.light = light\n    def execute(self):\n        self.light.off()\n\nclass Remote:\n    def run(self, command):\n        command.execute()\n",
    "testCases": [
      {
        "input": "l = Light(); r = Remote(); r.run(OnCommand(l)); print(l.is_on)",
        "isHidden": false,
        "description": "On command"
      },
      {
        "input": "l = Light(); r = Remote(); r.run(OnCommand(l)); r.run(OffCommand(l)); print(l.is_on)",
        "isHidden": false,
        "description": "Off command"
      },
      {
        "input": "l = Light(); print(l.is_on)",
        "isHidden": true,
        "description": "Default off"
      }
    ],
    "hints": [
      "Commands wrap an action as an object",
      "Remote calls execute()"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Observer: Unsubscribe",
    "difficulty": 4,
    "description": "Extend an `EventBus` to support `unsubscribe(fn)` removing the subscriber if present.",
    "starterCode": "class EventBus:\n    def __init__(self):\n        pass\n    def subscribe(self, fn):\n        pass\n    def unsubscribe(self, fn):\n        pass\n    def publish(self, message):\n        pass\n",
    "solution": "class EventBus:\n    def __init__(self):\n        self._subs = []\n    def subscribe(self, fn):\n        self._subs.append(fn)\n    def unsubscribe(self, fn):\n        self._subs = [s for s in self._subs if s is not fn]\n    def publish(self, message):\n        for fn in list(self._subs):\n            fn(message)\n",
    "testCases": [
      {
        "input": "bus = EventBus(); out = []\ndef f(m): out.append(\"f:\" + m)\nbus.subscribe(f); bus.publish(\"a\"); bus.unsubscribe(f); bus.publish(\"b\")\nprint(out)",
        "isHidden": false,
        "description": "Unsubscribe prevents further notifications"
      },
      {
        "input": "bus = EventBus(); out = []; bus.unsubscribe(lambda m: None); bus.publish(\"x\"); print(out)",
        "isHidden": true,
        "description": "Unsubscribe missing ok"
      },
      {
        "input": "bus = EventBus(); out = []; bus.publish(\"x\"); print(out)",
        "isHidden": true,
        "description": "No subscribers ok"
      }
    ],
    "hints": [
      "Filter the list of subscribers",
      "Use identity (`is`) to match the function object"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Factory: Parse JSON-like Values",
    "difficulty": 5,
    "description": "Create classes `JsonString`, `JsonNumber`, and `JsonBool` each with `value`. Create `JsonFactory.create(x)` that returns the right wrapper based on Python type.",
    "starterCode": "class JsonString:\n    def __init__(self, value):\n        pass\n\nclass JsonNumber:\n    def __init__(self, value):\n        pass\n\nclass JsonBool:\n    def __init__(self, value):\n        pass\n\nclass JsonFactory:\n    def create(self, x):\n        pass\n",
    "solution": "class JsonString:\n    def __init__(self, value):\n        self.value = value\n\nclass JsonNumber:\n    def __init__(self, value):\n        self.value = value\n\nclass JsonBool:\n    def __init__(self, value):\n        self.value = value\n\nclass JsonFactory:\n    def create(self, x):\n        if isinstance(x, bool):\n            return JsonBool(x)\n        if isinstance(x, (int, float)):\n            return JsonNumber(x)\n        if isinstance(x, str):\n            return JsonString(x)\n        raise ValueError(\"unsupported\")\n",
    "testCases": [
      {
        "input": "f = JsonFactory(); print(type(f.create(\"x\")).__name__, f.create(\"x\").value)",
        "isHidden": false,
        "description": "String wrapper"
      },
      {
        "input": "f = JsonFactory(); print(type(f.create(1)).__name__, f.create(1).value)",
        "isHidden": false,
        "description": "Number wrapper"
      },
      {
        "input": "f = JsonFactory(); print(type(f.create(True)).__name__, f.create(True).value)",
        "isHidden": true,
        "description": "Bool wrapper"
      }
    ],
    "hints": [
      "Check bool before int (bool is a subclass of int)",
      "Raise for unsupported types"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Decorator: Timing Wrapper",
    "difficulty": 5,
    "description": "Create `TimedDecorator` that wraps an object with method `run()` and stores the last run duration (seconds) in `last_seconds`.",
    "starterCode": "import time\n\nclass TimedDecorator:\n    def __init__(self, svc):\n        pass\n    def run(self):\n        pass\n",
    "solution": "import time\n\nclass TimedDecorator:\n    def __init__(self, svc):\n        self._svc = svc\n        self.last_seconds = 0.0\n    def run(self):\n        start = time.time()\n        result = self._svc.run()\n        self.last_seconds = max(0.0, time.time() - start)\n        return result\n",
    "testCases": [
      {
        "input": "class S:\n    def run(self):\n        return \"ok\"\n\nt = TimedDecorator(S()); print(t.run(), isinstance(t.last_seconds, float))",
        "isHidden": false,
        "description": "Runs and records time"
      },
      {
        "input": "class S:\n    def run(self):\n        return \"x\"\n\nt = TimedDecorator(S()); t.run(); print(t.last_seconds >= 0.0)",
        "isHidden": true,
        "description": "Non-negative time"
      },
      {
        "input": "class S:\n    def run(self):\n        return \"\"\n\nt = TimedDecorator(S()); print(t.run())",
        "isHidden": true,
        "description": "Returns wrapped result"
      }
    ],
    "hints": [
      "Record time before and after calling wrapped run()",
      "Store duration on the decorator instance"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Builder: Simple HTML Tag",
    "difficulty": 4,
    "description": "Create an `HtmlBuilder` that builds a `<tag>content</tag>` string. It should support `set_tag(tag)`, `set_content(content)`, and `build()`.",
    "starterCode": "class HtmlBuilder:\n    def __init__(self):\n        pass\n    def set_tag(self, tag):\n        pass\n    def set_content(self, content):\n        pass\n    def build(self):\n        pass\n",
    "solution": "class HtmlBuilder:\n    def __init__(self):\n        self._tag = \"div\"\n        self._content = \"\"\n    def set_tag(self, tag):\n        self._tag = tag\n        return self\n    def set_content(self, content):\n        self._content = content\n        return self\n    def build(self):\n        return f\"<{self._tag}>{self._content}</{self._tag}>\"\n",
    "testCases": [
      {
        "input": "b = HtmlBuilder().set_tag(\"p\").set_content(\"hi\")\nprint(b.build())",
        "isHidden": false,
        "description": "Build tag"
      },
      {
        "input": "b = HtmlBuilder().set_content(\"x\")\nprint(b.build())",
        "isHidden": true,
        "description": "Default tag"
      },
      {
        "input": "b = HtmlBuilder().set_tag(\"span\").set_content(\"\")\nprint(b.build())",
        "isHidden": true,
        "description": "Empty content ok"
      }
    ],
    "hints": [
      "Builder collects values then builds final string",
      "Optional: return self for chaining"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Null Object: Safe Logger",
    "difficulty": 4,
    "description": "Create `ConsoleLogger` and `NullLogger` each with `log(msg)`. NullLogger should do nothing. Create a `Worker` that uses any logger.",
    "starterCode": "class ConsoleLogger:\n    def log(self, msg):\n        pass\n\nclass NullLogger:\n    def log(self, msg):\n        pass\n\nclass Worker:\n    def __init__(self, logger):\n        pass\n    def do(self):\n        pass\n",
    "solution": "class ConsoleLogger:\n    def log(self, msg):\n        print(msg)\n\nclass NullLogger:\n    def log(self, msg):\n        return None\n\nclass Worker:\n    def __init__(self, logger):\n        self.logger = logger\n    def do(self):\n        self.logger.log(\"work\")\n",
    "testCases": [
      {
        "input": "w = Worker(NullLogger()); w.do(); print(\"ok\")",
        "isHidden": false,
        "description": "NullLogger prevents errors"
      },
      {
        "input": "w = Worker(NullLogger()); w.do(); w.do(); print(\"ok\")",
        "isHidden": true,
        "description": "Multiple calls"
      },
      {
        "input": "print(hasattr(NullLogger(), \"log\"))",
        "isHidden": true,
        "description": "Has log method"
      }
    ],
    "hints": [
      "Null Object avoids checking for None everywhere",
      "Worker delegates to logger"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Simple Dependency Injection Container",
    "difficulty": 5,
    "description": "Create a `Container` class with `register(name, value)` and `resolve(name)` returning the registered value or raising KeyError.",
    "starterCode": "class Container:\n    def __init__(self):\n        pass\n    def register(self, name, value):\n        pass\n    def resolve(self, name):\n        pass\n",
    "solution": "class Container:\n    def __init__(self):\n        self._services = {}\n    def register(self, name, value):\n        self._services[name] = value\n    def resolve(self, name):\n        return self._services[name]\n",
    "testCases": [
      {
        "input": "c = Container(); c.register(\"x\", 1); print(c.resolve(\"x\"))",
        "isHidden": false,
        "description": "Resolve returns value"
      },
      {
        "input": "c = Container();\ntry:\n    c.resolve(\"missing\")\n    print(\"no\")\nexcept KeyError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Missing raises KeyError"
      },
      {
        "input": "c = Container(); c.register(\"a\", \"b\"); c.register(\"a\", \"c\"); print(c.resolve(\"a\"))",
        "isHidden": true,
        "description": "Re-register overwrites"
      }
    ],
    "hints": [
      "Use a dict internally",
      "Raise KeyError for missing"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Recognize a Pattern",
    "difficulty": 1,
    "description": "Create a `Factory` class with a `create()` method that returns a string `\"created\"`.",
    "starterCode": "class Factory:\n    def create(self):\n        pass\n",
    "solution": "class Factory:\n    def create(self):\n        return \"created\"\n",
    "testCases": [
      {
        "input": "print(Factory().create())",
        "isHidden": false,
        "description": "Returns created"
      },
      {
        "input": "print(Factory().create().upper())",
        "isHidden": true,
        "description": "String"
      },
      {
        "input": "print(isinstance(Factory().create(), str))",
        "isHidden": true,
        "description": "Type"
      }
    ],
    "hints": [
      "Return the required string"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t5-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-5",
    "title": "Observer Skeleton",
    "difficulty": 1,
    "description": "Create a `Subject` class that stores subscribers and can notify them with a message.",
    "starterCode": "class Subject:\n    def __init__(self):\n        pass\n    def subscribe(self, fn):\n        pass\n    def notify(self, msg):\n        pass\n",
    "solution": "class Subject:\n    def __init__(self):\n        self._subs = []\n    def subscribe(self, fn):\n        self._subs.append(fn)\n    def notify(self, msg):\n        for fn in self._subs:\n            fn(msg)\n",
    "testCases": [
      {
        "input": "s = Subject(); out = []; s.subscribe(lambda m: out.append(m)); s.notify(\"x\"); print(out)",
        "isHidden": false,
        "description": "Notifies subscriber"
      },
      {
        "input": "s = Subject(); s.notify(\"x\"); print(\"ok\")",
        "isHidden": true,
        "description": "No subs ok"
      },
      {
        "input": "s = Subject(); out = []; s.subscribe(lambda m: out.append(m)); s.notify(\"\"); print(out)",
        "isHidden": true,
        "description": "Empty message ok"
      }
    ],
    "hints": [
      "Store subscribers in a list",
      "Loop and call each subscriber"
    ],
    "language": "python"
  },
  {
    "id": "cs103-ex-6",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Abstract Storage Interface (ABC)",
    "difficulty": 3,
    "description": "Define an abstract base class `Storage` with abstract methods `save(key, value)` and `load(key)`. Implement `InMemoryStorage` using a dict.",
    "starterCode": "from abc import ABC, abstractmethod\n\nclass Storage(ABC):\n    @abstractmethod\n    def save(self, key, value):\n        pass\n\n    @abstractmethod\n    def load(self, key):\n        pass\n\nclass InMemoryStorage(Storage):\n    def __init__(self):\n        pass\n    def save(self, key, value):\n        pass\n    def load(self, key):\n        pass\n",
    "solution": "from abc import ABC, abstractmethod\n\nclass Storage(ABC):\n    @abstractmethod\n    def save(self, key, value):\n        raise NotImplementedError\n\n    @abstractmethod\n    def load(self, key):\n        raise NotImplementedError\n\nclass InMemoryStorage(Storage):\n    def __init__(self):\n        self._data = {}\n    def save(self, key, value):\n        self._data[key] = value\n    def load(self, key):\n        return self._data.get(key)\n",
    "testCases": [
      {
        "input": "s = InMemoryStorage(); s.save(\"a\", \"1\"); print(s.load(\"a\"))",
        "isHidden": false,
        "description": "Save then load"
      },
      {
        "input": "s = InMemoryStorage(); print(s.load(\"missing\"))",
        "isHidden": true,
        "description": "Missing key returns None"
      },
      {
        "input": "from abc import ABC\nprint(isinstance(InMemoryStorage(), Storage))",
        "isHidden": true,
        "description": "Implements Storage"
      }
    ],
    "hints": [
      "Use `abc.ABC` + `@abstractmethod`",
      "Use a dict for the in-memory implementation"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Template Method: Report Rendering",
    "difficulty": 4,
    "description": "Create an abstract class `Report` with method `render()` that calls abstract methods `title()` and `body()`. Implement `SalesReport`.",
    "starterCode": "from abc import ABC, abstractmethod\n\nclass Report(ABC):\n    def render(self):\n        # TODO: use title() and body()\n        pass\n\n    @abstractmethod\n    def title(self):\n        pass\n\n    @abstractmethod\n    def body(self):\n        pass\n\nclass SalesReport(Report):\n    def title(self):\n        pass\n    def body(self):\n        pass\n",
    "solution": "from abc import ABC, abstractmethod\n\nclass Report(ABC):\n    def render(self):\n        return f\"=== {self.title()} ===\\n{self.body()}\\n\"\n\n    @abstractmethod\n    def title(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def body(self):\n        raise NotImplementedError\n\nclass SalesReport(Report):\n    def title(self):\n        return \"Sales\"\n    def body(self):\n        return \"Total: $1234\"\n",
    "testCases": [
      {
        "input": "print(SalesReport().render())",
        "isHidden": false,
        "description": "Render includes title and body"
      },
      {
        "input": "print(SalesReport().title(), SalesReport().body())",
        "isHidden": true,
        "description": "Concrete methods exist"
      },
      {
        "input": "try:\n    Report()\n    print(\"no\")\nexcept TypeError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Cannot instantiate abstract base"
      }
    ],
    "hints": [
      "`render()` should call `self.title()` and `self.body()`",
      "Mark abstract methods with `@abstractmethod`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Dependency Injection: Notifier",
    "difficulty": 3,
    "description": "Create `EmailSender` with `send(to, msg)` returning a string, and `Notifier` that receives a sender in its constructor and uses it in `welcome(email)`.",
    "starterCode": "class EmailSender:\n    def send(self, to, msg):\n        pass\n\nclass Notifier:\n    def __init__(self, sender):\n        pass\n    def welcome(self, email):\n        pass\n",
    "solution": "class EmailSender:\n    def send(self, to, msg):\n        return f\"email:{to}:{msg}\"\n\nclass Notifier:\n    def __init__(self, sender):\n        self.sender = sender\n    def welcome(self, email):\n        return self.sender.send(email, \"Welcome\")\n",
    "testCases": [
      {
        "input": "print(Notifier(EmailSender()).welcome(\"a@b\"))",
        "isHidden": false,
        "description": "Uses injected sender"
      },
      {
        "input": "class Fake:\n    def __init__(self): self.calls=[]\n    def send(self, to, msg): self.calls.append((to,msg)); return \"ok\"\n\nf=Fake(); n=Notifier(f); print(n.welcome(\"x\"), f.calls)",
        "isHidden": false,
        "description": "Fake sender captures calls"
      },
      {
        "input": "print(Notifier(EmailSender()).welcome(\"\"))",
        "isHidden": true,
        "description": "Empty email still delegated"
      }
    ],
    "hints": [
      "Store sender on `self`",
      "Delegate inside `welcome`"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Protocol-Style Interface (Duck Typing)",
    "difficulty": 2,
    "description": "Create `ConsoleWriter` and `BufferWriter` each with `write(text)`. `BufferWriter` should store written text in `buffer`. Create `Logger` that accepts any writer.",
    "starterCode": "class ConsoleWriter:\n    def write(self, text):\n        pass\n\nclass BufferWriter:\n    def __init__(self):\n        pass\n    def write(self, text):\n        pass\n\nclass Logger:\n    def __init__(self, writer):\n        pass\n    def log(self, msg):\n        pass\n",
    "solution": "class ConsoleWriter:\n    def write(self, text):\n        print(text, end=\"\")\n\nclass BufferWriter:\n    def __init__(self):\n        self.buffer = \"\"\n    def write(self, text):\n        self.buffer += text\n\nclass Logger:\n    def __init__(self, writer):\n        self.writer = writer\n    def log(self, msg):\n        self.writer.write(msg + \"\\n\")\n",
    "testCases": [
      {
        "input": "w = BufferWriter(); Logger(w).log(\"hi\"); print(w.buffer)",
        "isHidden": false,
        "description": "Buffer captures output"
      },
      {
        "input": "w = BufferWriter(); Logger(w).log(\"\"); print(w.buffer)",
        "isHidden": true,
        "description": "Empty message still newline"
      },
      {
        "input": "w = BufferWriter(); l = Logger(w); l.log(\"a\"); l.log(\"b\"); print(w.buffer)",
        "isHidden": true,
        "description": "Multiple logs"
      }
    ],
    "hints": [
      "Logger should not care about concrete writer type",
      "BufferWriter stores text instead of printing"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Small Interface: Cache Contract",
    "difficulty": 3,
    "description": "Create a `Cache` base class with methods `get(key)` and `set(key, value)` raising NotImplementedError. Implement `DictCache`.",
    "starterCode": "class Cache:\n    def get(self, key):\n        pass\n    def set(self, key, value):\n        pass\n\nclass DictCache(Cache):\n    def __init__(self):\n        pass\n    def get(self, key):\n        pass\n    def set(self, key, value):\n        pass\n",
    "solution": "class Cache:\n    def get(self, key):\n        raise NotImplementedError\n    def set(self, key, value):\n        raise NotImplementedError\n\nclass DictCache(Cache):\n    def __init__(self):\n        self._data = {}\n    def get(self, key):\n        return self._data.get(key)\n    def set(self, key, value):\n        self._data[key] = value\n",
    "testCases": [
      {
        "input": "c = DictCache(); c.set(\"a\", 1); print(c.get(\"a\"))",
        "isHidden": false,
        "description": "Set/get"
      },
      {
        "input": "c = DictCache(); print(c.get(\"missing\"))",
        "isHidden": true,
        "description": "Missing is None"
      },
      {
        "input": "try:\n    Cache().get(\"a\")\n    print(\"no\")\nexcept NotImplementedError:\n    print(\"yes\")",
        "isHidden": true,
        "description": "Base raises"
      }
    ],
    "hints": [
      "Define a small contract in the base",
      "Implement using a dict"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Interface Segregation: Split Responsibilities",
    "difficulty": 4,
    "description": "Create `Reader` with `read()` and `Writer` with `write(text)`. Implement `MemoryFile` that supports both (stores text internally).",
    "starterCode": "class Reader:\n    def read(self):\n        pass\n\nclass Writer:\n    def write(self, text):\n        pass\n\nclass MemoryFile(Reader, Writer):\n    def __init__(self):\n        pass\n    def read(self):\n        pass\n    def write(self, text):\n        pass\n",
    "solution": "class Reader:\n    def read(self):\n        raise NotImplementedError\n\nclass Writer:\n    def write(self, text):\n        raise NotImplementedError\n\nclass MemoryFile(Reader, Writer):\n    def __init__(self):\n        self._buf = \"\"\n    def read(self):\n        return self._buf\n    def write(self, text):\n        self._buf += text\n",
    "testCases": [
      {
        "input": "f = MemoryFile(); f.write(\"a\"); f.write(\"b\"); print(f.read())",
        "isHidden": false,
        "description": "Writes then reads"
      },
      {
        "input": "f = MemoryFile(); print(f.read())",
        "isHidden": true,
        "description": "Starts empty"
      },
      {
        "input": "f = MemoryFile(); f.write(\"\"); print(f.read())",
        "isHidden": true,
        "description": "Empty write ok"
      }
    ],
    "hints": [
      "Split interfaces by responsibility",
      "Use a buffer string to store data"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "LSP: Subclass Must Preserve Contract",
    "difficulty": 4,
    "description": "Create base class `Counter` with `inc()` returning the new count. Create `NonNegativeCounter` that never goes below 0 and still returns an int from `inc`/`dec`.",
    "starterCode": "class Counter:\n    def __init__(self):\n        pass\n    def inc(self):\n        pass\n    def dec(self):\n        pass\n\nclass NonNegativeCounter(Counter):\n    def dec(self):\n        pass\n",
    "solution": "class Counter:\n    def __init__(self):\n        self._n = 0\n    def inc(self):\n        self._n += 1\n        return self._n\n    def dec(self):\n        self._n -= 1\n        return self._n\n\nclass NonNegativeCounter(Counter):\n    def dec(self):\n        if self._n > 0:\n            self._n -= 1\n        return self._n\n",
    "testCases": [
      {
        "input": "c = Counter(); print(c.inc(), c.inc())",
        "isHidden": false,
        "description": "Base increments"
      },
      {
        "input": "c = NonNegativeCounter(); c.dec(); print(c.dec())",
        "isHidden": false,
        "description": "Does not go below 0"
      },
      {
        "input": "c = NonNegativeCounter(); c.inc(); c.dec(); print(c.dec())",
        "isHidden": true,
        "description": "Clamps at 0 after decrement"
      }
    ],
    "hints": [
      "NonNegativeCounter should inherit base init",
      "Override only dec() and preserve return type"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Abstract Property",
    "difficulty": 5,
    "description": "Create an abstract base class `Animal` with an abstract property `sound`. Implement `Dog` and `Cat`.",
    "starterCode": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @property\n    @abstractmethod\n    def sound(self):\n        pass\n\nclass Dog(Animal):\n    @property\n    def sound(self):\n        pass\n\nclass Cat(Animal):\n    @property\n    def sound(self):\n        pass\n",
    "solution": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @property\n    @abstractmethod\n    def sound(self):\n        raise NotImplementedError\n\nclass Dog(Animal):\n    @property\n    def sound(self):\n        return \"woof\"\n\nclass Cat(Animal):\n    @property\n    def sound(self):\n        return \"meow\"\n",
    "testCases": [
      {
        "input": "print(Dog().sound, Cat().sound)",
        "isHidden": false,
        "description": "Concrete sounds"
      },
      {
        "input": "try:\n    Animal()\n    print(\"no\")\nexcept TypeError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Animal abstract"
      },
      {
        "input": "print(isinstance(Dog(), Animal))",
        "isHidden": true,
        "description": "Dog is Animal"
      }
    ],
    "hints": [
      "Use `@property` + `@abstractmethod`",
      "Concrete subclasses return strings"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Replace Inheritance with Composition",
    "difficulty": 4,
    "description": "Create `Compressor` objects with `compress(text)`. Create `GzipCompressor` and `NoOpCompressor`. Create `Archiver` that composes a compressor and calls it.",
    "starterCode": "class GzipCompressor:\n    def compress(self, text):\n        pass\n\nclass NoOpCompressor:\n    def compress(self, text):\n        pass\n\nclass Archiver:\n    def __init__(self, compressor):\n        pass\n    def archive(self, text):\n        pass\n",
    "solution": "class GzipCompressor:\n    def compress(self, text):\n        return \"gz:\" + text\n\nclass NoOpCompressor:\n    def compress(self, text):\n        return text\n\nclass Archiver:\n    def __init__(self, compressor):\n        self.compressor = compressor\n    def archive(self, text):\n        return self.compressor.compress(text)\n",
    "testCases": [
      {
        "input": "print(Archiver(NoOpCompressor()).archive(\"a\"))",
        "isHidden": false,
        "description": "No-op"
      },
      {
        "input": "print(Archiver(GzipCompressor()).archive(\"a\"))",
        "isHidden": false,
        "description": "Gzip-like prefix"
      },
      {
        "input": "print(Archiver(GzipCompressor()).archive(\"\"))",
        "isHidden": true,
        "description": "Empty text"
      }
    ],
    "hints": [
      "Archiver should not subclass compressor",
      "Delegate to the injected compressor"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Open/Closed: Add New Rule Without Changes",
    "difficulty": 5,
    "description": "Create rule objects with `check(text)` returning True/False. Implement `MinLengthRule(n)` and `ContainsRule(substr)`. Create `Validator` that accepts a list of rules and returns True only if all pass.",
    "starterCode": "class MinLengthRule:\n    def __init__(self, n):\n        pass\n    def check(self, text):\n        pass\n\nclass ContainsRule:\n    def __init__(self, substr):\n        pass\n    def check(self, text):\n        pass\n\nclass Validator:\n    def __init__(self, rules):\n        pass\n    def is_valid(self, text):\n        pass\n",
    "solution": "class MinLengthRule:\n    def __init__(self, n):\n        self.n = n\n    def check(self, text):\n        return len(text) >= self.n\n\nclass ContainsRule:\n    def __init__(self, substr):\n        self.substr = substr\n    def check(self, text):\n        return self.substr in text\n\nclass Validator:\n    def __init__(self, rules):\n        self.rules = list(rules)\n    def is_valid(self, text):\n        return all(r.check(text) for r in self.rules)\n",
    "testCases": [
      {
        "input": "v = Validator([MinLengthRule(3), ContainsRule(\"a\")]); print(v.is_valid(\"cat\"))",
        "isHidden": false,
        "description": "Passes all rules"
      },
      {
        "input": "v = Validator([MinLengthRule(3), ContainsRule(\"a\")]); print(v.is_valid(\"hi\"))",
        "isHidden": false,
        "description": "Fails length"
      },
      {
        "input": "v = Validator([ContainsRule(\"x\")]); print(v.is_valid(\"abc\"))",
        "isHidden": true,
        "description": "Fails contains"
      }
    ],
    "hints": [
      "Rules share the same method name: check()",
      "Validator loops over rules and combines results"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Adapter for Different Interface",
    "difficulty": 3,
    "description": "Create `LegacyStore` with `put(k,v)` and `fetch(k)`. Create `StoreAdapter` that provides `save(k,v)` and `load(k)` by delegating.",
    "starterCode": "class LegacyStore:\n    def __init__(self):\n        pass\n    def put(self, k, v):\n        pass\n    def fetch(self, k):\n        pass\n\nclass StoreAdapter:\n    def __init__(self, legacy):\n        pass\n    def save(self, k, v):\n        pass\n    def load(self, k):\n        pass\n",
    "solution": "class LegacyStore:\n    def __init__(self):\n        self._d = {}\n    def put(self, k, v):\n        self._d[k] = v\n    def fetch(self, k):\n        return self._d.get(k)\n\nclass StoreAdapter:\n    def __init__(self, legacy):\n        self.legacy = legacy\n    def save(self, k, v):\n        self.legacy.put(k, v)\n    def load(self, k):\n        return self.legacy.fetch(k)\n",
    "testCases": [
      {
        "input": "legacy = LegacyStore(); store = StoreAdapter(legacy); store.save(\"a\", 1); print(store.load(\"a\"))",
        "isHidden": false,
        "description": "Adapter works"
      },
      {
        "input": "legacy = LegacyStore(); store = StoreAdapter(legacy); print(store.load(\"x\"))",
        "isHidden": true,
        "description": "Missing returns None"
      },
      {
        "input": "legacy = LegacyStore(); legacy.put(\"k\",\"v\"); store = StoreAdapter(legacy); print(store.load(\"k\"))",
        "isHidden": true,
        "description": "Sees legacy data"
      }
    ],
    "hints": [
      "Adapter changes method names, not storage semantics",
      "Delegate calls to the legacy object"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Composition of Behaviors (Policies)",
    "difficulty": 4,
    "description": "Create `RetryPolicy` with `should_retry(attempt)` and `FixedRetries(n)`. Create `Requester` that uses a policy and returns how many attempts it would make.",
    "starterCode": "class FixedRetries:\n    def __init__(self, n):\n        pass\n    def should_retry(self, attempt):\n        pass\n\nclass Requester:\n    def __init__(self, policy):\n        pass\n    def attempts(self):\n        # returns number of attempts including the first try\n        pass\n",
    "solution": "class FixedRetries:\n    def __init__(self, n):\n        self.n = n\n    def should_retry(self, attempt):\n        return attempt <= self.n\n\nclass Requester:\n    def __init__(self, policy):\n        self.policy = policy\n    def attempts(self):\n        attempt = 1\n        while self.policy.should_retry(attempt):\n            attempt += 1\n        return attempt\n",
    "testCases": [
      {
        "input": "print(Requester(FixedRetries(0)).attempts())",
        "isHidden": false,
        "description": "0 retries => 1 attempt"
      },
      {
        "input": "print(Requester(FixedRetries(2)).attempts())",
        "isHidden": false,
        "description": "2 retries => 3 attempts"
      },
      {
        "input": "print(Requester(FixedRetries(5)).attempts())",
        "isHidden": true,
        "description": "More retries"
      }
    ],
    "hints": [
      "Requester should not inherit policy",
      "Count attempts including the initial try"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Interface as Contract: Payment Gateways",
    "difficulty": 4,
    "description": "Create `FakeGateway` with `charge(amount)` returning `\"charged:<amount>\"`. Create `PaymentService` that accepts any gateway and uses it in `charge(amount)`.",
    "starterCode": "class FakeGateway:\n    def charge(self, amount):\n        pass\n\nclass PaymentService:\n    def __init__(self, gateway):\n        pass\n    def charge(self, amount):\n        pass\n",
    "solution": "class FakeGateway:\n    def charge(self, amount):\n        return f\"charged:{amount}\"\n\nclass PaymentService:\n    def __init__(self, gateway):\n        self.gateway = gateway\n    def charge(self, amount):\n        return self.gateway.charge(amount)\n",
    "testCases": [
      {
        "input": "print(PaymentService(FakeGateway()).charge(10))",
        "isHidden": false,
        "description": "Delegates to gateway"
      },
      {
        "input": "print(PaymentService(FakeGateway()).charge(0))",
        "isHidden": true,
        "description": "Zero amount"
      },
      {
        "input": "print(PaymentService(FakeGateway()).charge(-1))",
        "isHidden": true,
        "description": "Negative passes through (no validation here)"
      }
    ],
    "hints": [
      "Accept the gateway as a dependency",
      "Delegate from service to gateway"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Prefer Protocols: Any “Writer” Works",
    "difficulty": 5,
    "description": "Create a `FileWriter` that writes into a string attribute `contents` via `write(text)`. Create a `ReportWriter` that accepts any writer and writes two lines.",
    "starterCode": "class FileWriter:\n    def __init__(self):\n        pass\n    def write(self, text):\n        pass\n\nclass ReportWriter:\n    def __init__(self, writer):\n        pass\n    def write_report(self):\n        pass\n",
    "solution": "class FileWriter:\n    def __init__(self):\n        self.contents = \"\"\n    def write(self, text):\n        self.contents += text\n\nclass ReportWriter:\n    def __init__(self, writer):\n        self.writer = writer\n    def write_report(self):\n        self.writer.write(\"line1\\n\")\n        self.writer.write(\"line2\\n\")\n",
    "testCases": [
      {
        "input": "w = FileWriter(); rw = ReportWriter(w); rw.write_report(); print(w.contents)",
        "isHidden": false,
        "description": "Writes two lines"
      },
      {
        "input": "w = FileWriter(); ReportWriter(w).write_report(); print(w.contents.count(\"\\n\"))",
        "isHidden": true,
        "description": "Contains newlines"
      },
      {
        "input": "w = FileWriter(); ReportWriter(w).write_report(); print(w.contents.startswith(\"line1\"))",
        "isHidden": true,
        "description": "Starts with line1"
      }
    ],
    "hints": [
      "Writer is a “protocol”: any object with write(text) works",
      "FileWriter accumulates content"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Abstract Method Basics",
    "difficulty": 1,
    "description": "Create an abstract base class `Animal` with an abstract method `speak()`.",
    "starterCode": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        pass\n",
    "solution": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        raise NotImplementedError\n",
    "testCases": [
      {
        "input": "try:\n    Animal()\n    print(\"no\")\nexcept TypeError:\n    print(\"yes\")",
        "isHidden": false,
        "description": "Cannot instantiate"
      },
      {
        "input": "print(hasattr(Animal, \"speak\"))",
        "isHidden": true,
        "description": "Has method"
      },
      {
        "input": "print(Animal.__mro__[0].__name__ == \"Animal\")",
        "isHidden": true,
        "description": "Class exists"
      }
    ],
    "hints": [
      "Use `ABC` and `@abstractmethod`",
      "Abstract classes cannot be instantiated"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t6-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-6",
    "title": "Inject a Dependency",
    "difficulty": 1,
    "description": "Create a `Greeter` that accepts a `writer` and uses it in `hello(name)`.",
    "starterCode": "class Greeter:\n    def __init__(self, writer):\n        pass\n    def hello(self, name):\n        pass\n",
    "solution": "class Greeter:\n    def __init__(self, writer):\n        self.writer = writer\n    def hello(self, name):\n        self.writer.write(\"Hello, \" + name)\n",
    "testCases": [
      {
        "input": "class W:\n    def __init__(self): self.buf=\"\"\n    def write(self, t): self.buf += t\n\nw=W(); Greeter(w).hello(\"Ada\"); print(w.buf)",
        "isHidden": false,
        "description": "Writes greeting"
      },
      {
        "input": "class W:\n    def __init__(self): self.buf=\"\"\n    def write(self, t): self.buf += t\n\nw=W(); Greeter(w).hello(\"\"); print(w.buf)",
        "isHidden": true,
        "description": "Empty name"
      },
      {
        "input": "print(True)",
        "isHidden": true,
        "description": "Sanity"
      }
    ],
    "hints": [
      "Store writer on `self`",
      "Call `writer.write(...)` in hello"
    ],
    "language": "python"
  },
  {
    "id": "cs103-ex-7",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Composition: UserNotifier",
    "difficulty": 2,
    "description": "Create an `EmailSender` with `send(to, subject)` returning a string. Create `UserNotifier` that composes a sender and has `welcome(email)`.",
    "starterCode": "class EmailSender:\n    def send(self, to, subject):\n        pass\n\nclass UserNotifier:\n    def __init__(self, sender):\n        pass\n    def welcome(self, email):\n        pass\n",
    "solution": "class EmailSender:\n    def send(self, to, subject):\n        return f\"email:{to}:{subject}\"\n\nclass UserNotifier:\n    def __init__(self, sender):\n        self._sender = sender\n    def welcome(self, email):\n        return self._sender.send(email, \"Welcome\")\n",
    "testCases": [
      {
        "input": "print(UserNotifier(EmailSender()).welcome(\"a@b\"))",
        "isHidden": false,
        "description": "Delegates to sender"
      },
      {
        "input": "print(UserNotifier(EmailSender()).welcome(\"\"))",
        "isHidden": true,
        "description": "Empty email still works"
      },
      {
        "input": "class Fake:\n    def __init__(self): self.calls=[]\n    def send(self, to, subject): self.calls.append((to,subject)); return \"ok\"\n\nf=Fake(); n=UserNotifier(f); print(n.welcome(\"x\"), f.calls)",
        "isHidden": false,
        "description": "Fake captures call"
      }
    ],
    "hints": [
      "Prefer composition: notifier has a sender",
      "Inject sender via constructor"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex02",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Single Responsibility: Invoice Total",
    "difficulty": 2,
    "description": "Create an `Invoice` class that stores line item amounts and computes `total()`. Keep it focused: just store amounts and compute the total.",
    "starterCode": "class Invoice:\n    def __init__(self):\n        pass\n    def add_amount(self, amount):\n        pass\n    def total(self):\n        pass\n",
    "solution": "class Invoice:\n    def __init__(self):\n        self._amounts = []\n    def add_amount(self, amount):\n        self._amounts.append(amount)\n    def total(self):\n        return sum(self._amounts)\n",
    "testCases": [
      {
        "input": "i = Invoice(); i.add_amount(10); i.add_amount(5); print(i.total())",
        "isHidden": false,
        "description": "Sum amounts"
      },
      {
        "input": "i = Invoice(); print(i.total())",
        "isHidden": true,
        "description": "Empty total"
      },
      {
        "input": "i = Invoice(); i.add_amount(-1); print(i.total())",
        "isHidden": true,
        "description": "Allows negatives (no validation here)"
      }
    ],
    "hints": [
      "Store amounts in a list",
      "Use sum() to total"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex03",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Open/Closed: Add Tax Policies",
    "difficulty": 3,
    "description": "Create tax policies with `rate()` method. Implement `FlatTax(rate)` and `ZeroTax`. Create `Cart` that composes a policy and computes `total_with_tax(subtotal)`.",
    "starterCode": "class FlatTax:\n    def __init__(self, rate):\n        pass\n    def rate(self):\n        pass\n\nclass ZeroTax:\n    def rate(self):\n        pass\n\nclass Cart:\n    def __init__(self, policy):\n        pass\n    def total_with_tax(self, subtotal):\n        pass\n",
    "solution": "class FlatTax:\n    def __init__(self, rate):\n        self._rate = rate\n    def rate(self):\n        return self._rate\n\nclass ZeroTax:\n    def rate(self):\n        return 0.0\n\nclass Cart:\n    def __init__(self, policy):\n        self.policy = policy\n    def total_with_tax(self, subtotal):\n        return subtotal * (1 + self.policy.rate())\n",
    "testCases": [
      {
        "input": "print(Cart(FlatTax(0.2)).total_with_tax(100))",
        "isHidden": false,
        "description": "20% tax"
      },
      {
        "input": "print(Cart(ZeroTax()).total_with_tax(100))",
        "isHidden": false,
        "description": "No tax"
      },
      {
        "input": "print(Cart(FlatTax(0.0)).total_with_tax(0))",
        "isHidden": true,
        "description": "Zero subtotal"
      }
    ],
    "hints": [
      "Cart depends on a policy interface (rate())",
      "Multiply subtotal by (1+rate)"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex04",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Interface Segregation: Printer/Scanner",
    "difficulty": 3,
    "description": "Create separate interfaces `Printer` and `Scanner` (base classes raising NotImplementedError). Implement `MultiFunctionDevice` supporting both.",
    "starterCode": "class Printer:\n    def print_doc(self, text):\n        pass\n\nclass Scanner:\n    def scan(self):\n        pass\n\nclass MultiFunctionDevice(Printer, Scanner):\n    def __init__(self):\n        pass\n    def print_doc(self, text):\n        pass\n    def scan(self):\n        pass\n",
    "solution": "class Printer:\n    def print_doc(self, text):\n        raise NotImplementedError\n\nclass Scanner:\n    def scan(self):\n        raise NotImplementedError\n\nclass MultiFunctionDevice(Printer, Scanner):\n    def __init__(self):\n        self._printed = []\n        self._scan_value = \"scan\"\n    def print_doc(self, text):\n        self._printed.append(text)\n        return \"printed\"\n    def scan(self):\n        return self._scan_value\n",
    "testCases": [
      {
        "input": "d = MultiFunctionDevice(); print(d.print_doc(\"a\"), d.scan())",
        "isHidden": false,
        "description": "Implements both"
      },
      {
        "input": "d = MultiFunctionDevice(); d.print_doc(\"x\"); d.print_doc(\"y\"); print(d._printed)",
        "isHidden": true,
        "description": "Tracks printed docs"
      },
      {
        "input": "print(isinstance(MultiFunctionDevice(), Printer), isinstance(MultiFunctionDevice(), Scanner))",
        "isHidden": true,
        "description": "Is-a checks"
      }
    ],
    "hints": [
      "Keep Printer and Scanner separate",
      "MultiFunctionDevice implements both behaviors"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex05",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Dependency Inversion: Payment Service",
    "difficulty": 4,
    "description": "Create `FakeGateway` with `charge(amount)` returning `\"ok\"`. Create `PaymentService` that accepts a gateway and calls it. Do not instantiate the gateway inside PaymentService.",
    "starterCode": "class FakeGateway:\n    def charge(self, amount):\n        pass\n\nclass PaymentService:\n    def __init__(self, gateway):\n        pass\n    def charge(self, amount):\n        pass\n",
    "solution": "class FakeGateway:\n    def charge(self, amount):\n        return \"ok\"\n\nclass PaymentService:\n    def __init__(self, gateway):\n        self.gateway = gateway\n    def charge(self, amount):\n        return self.gateway.charge(amount)\n",
    "testCases": [
      {
        "input": "print(PaymentService(FakeGateway()).charge(10))",
        "isHidden": false,
        "description": "Delegates"
      },
      {
        "input": "class Spy:\n    def __init__(self): self.calls=[]\n    def charge(self, amount): self.calls.append(amount); return \"ok\"\n\ns=Spy(); ps=PaymentService(s); ps.charge(5); print(s.calls)",
        "isHidden": false,
        "description": "Spy records interaction"
      },
      {
        "input": "print(PaymentService(FakeGateway()).charge(0))",
        "isHidden": true,
        "description": "Zero amount still delegates"
      }
    ],
    "hints": [
      "Inject the gateway",
      "Delegate from service method"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex06",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Refactoring Target: Extract Policy",
    "difficulty": 4,
    "description": "Create `PasswordPolicy(min_len)` with `is_valid(pw)` and a `UserService` that uses the policy in `can_register(password)`.",
    "starterCode": "class PasswordPolicy:\n    def __init__(self, min_len):\n        pass\n    def is_valid(self, pw):\n        pass\n\nclass UserService:\n    def __init__(self, policy):\n        pass\n    def can_register(self, password):\n        pass\n",
    "solution": "class PasswordPolicy:\n    def __init__(self, min_len):\n        self.min_len = min_len\n    def is_valid(self, pw):\n        return len(pw) >= self.min_len\n\nclass UserService:\n    def __init__(self, policy):\n        self.policy = policy\n    def can_register(self, password):\n        return self.policy.is_valid(password)\n",
    "testCases": [
      {
        "input": "svc = UserService(PasswordPolicy(3)); print(svc.can_register(\"abc\"))",
        "isHidden": false,
        "description": "Valid"
      },
      {
        "input": "svc = UserService(PasswordPolicy(3)); print(svc.can_register(\"ab\"))",
        "isHidden": false,
        "description": "Too short"
      },
      {
        "input": "svc = UserService(PasswordPolicy(0)); print(svc.can_register(\"\"))",
        "isHidden": true,
        "description": "Min 0"
      }
    ],
    "hints": [
      "Policy is a separate object",
      "UserService delegates to policy"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex07",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Unit-Testable: Random Provider Injection",
    "difficulty": 5,
    "description": "Create `RandomPicker` that picks an item from a list using an injected `rng` object with method `rand_index(n)`. Implement `FakeRng` for deterministic tests.",
    "starterCode": "class FakeRng:\n    def __init__(self, fixed_index):\n        pass\n    def rand_index(self, n):\n        pass\n\nclass RandomPicker:\n    def __init__(self, rng):\n        pass\n    def pick(self, items):\n        pass\n",
    "solution": "class FakeRng:\n    def __init__(self, fixed_index):\n        self.fixed_index = fixed_index\n    def rand_index(self, n):\n        return self.fixed_index % n\n\nclass RandomPicker:\n    def __init__(self, rng):\n        self.rng = rng\n    def pick(self, items):\n        return items[self.rng.rand_index(len(items))]\n",
    "testCases": [
      {
        "input": "p = RandomPicker(FakeRng(0)); print(p.pick([\"a\",\"b\"]))",
        "isHidden": false,
        "description": "Picks first"
      },
      {
        "input": "p = RandomPicker(FakeRng(3)); print(p.pick([\"a\",\"b\"]))",
        "isHidden": false,
        "description": "Wraps index"
      },
      {
        "input": "p = RandomPicker(FakeRng(1)); print(p.pick([10,20,30]))",
        "isHidden": true,
        "description": "Works for non-strings"
      }
    ],
    "hints": [
      "Inject randomness instead of calling random directly",
      "Use modulo to keep index in bounds"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex08",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Reduce Coupling: Repository Interface",
    "difficulty": 4,
    "description": "Create `InMemoryUserRepo` with `add(username)` and `exists(username)`. Create `RegistrationService` that uses a repo to register unique usernames.",
    "starterCode": "class InMemoryUserRepo:\n    def __init__(self):\n        pass\n    def add(self, username):\n        pass\n    def exists(self, username):\n        pass\n\nclass RegistrationService:\n    def __init__(self, repo):\n        pass\n    def register(self, username):\n        # returns True if registered, False if already exists\n        pass\n",
    "solution": "class InMemoryUserRepo:\n    def __init__(self):\n        self._users = set()\n    def add(self, username):\n        self._users.add(username)\n    def exists(self, username):\n        return username in self._users\n\nclass RegistrationService:\n    def __init__(self, repo):\n        self.repo = repo\n    def register(self, username):\n        if self.repo.exists(username):\n            return False\n        self.repo.add(username)\n        return True\n",
    "testCases": [
      {
        "input": "repo = InMemoryUserRepo(); s = RegistrationService(repo); print(s.register(\"a\"), s.register(\"a\"))",
        "isHidden": false,
        "description": "Reject duplicates"
      },
      {
        "input": "repo = InMemoryUserRepo(); s = RegistrationService(repo); print(s.register(\"x\"))",
        "isHidden": true,
        "description": "Registers new"
      },
      {
        "input": "repo = InMemoryUserRepo(); s = RegistrationService(repo); s.register(\"\"); print(repo.exists(\"\"))",
        "isHidden": true,
        "description": "Allows empty username (no validation here)"
      }
    ],
    "hints": [
      "Repo abstracts storage",
      "Service uses repo methods, not repo internals"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex09",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Avoid Heavy __init__: Lazy Resource",
    "difficulty": 3,
    "description": "Create a `LazyValue` class that takes a function `compute`. It should only compute once when `value` property is accessed and cache the result.",
    "starterCode": "class LazyValue:\n    def __init__(self, compute):\n        pass\n    @property\n    def value(self):\n        pass\n",
    "solution": "class LazyValue:\n    def __init__(self, compute):\n        self._compute = compute\n        self._has = False\n        self._value = None\n    @property\n    def value(self):\n        if not self._has:\n            self._value = self._compute()\n            self._has = True\n        return self._value\n",
    "testCases": [
      {
        "input": "calls = {\"n\": 0}\ndef f():\n    calls[\"n\"] += 1\n    return 123\n\nlv = LazyValue(f)\nprint(lv.value, lv.value, calls[\"n\"])",
        "isHidden": false,
        "description": "Computes once"
      },
      {
        "input": "lv = LazyValue(lambda: \"x\")\nprint(lv.value)",
        "isHidden": true,
        "description": "String values"
      },
      {
        "input": "calls = {\"n\": 0}\nlv = LazyValue(lambda: calls.__setitem__(\"n\", calls[\"n\"]+1) or calls[\"n\"])\n_ = lv.value; _ = lv.value\nprint(calls[\"n\"])",
        "isHidden": true,
        "description": "Still once"
      }
    ],
    "hints": [
      "Cache the result after first compute",
      "Track whether computed with a boolean"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex10",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Testing Collaboration: Spy Writer",
    "difficulty": 4,
    "description": "Create a `SpyWriter` that records each call to `write(text)` in a list `writes`. Create `Greeter` that uses a writer to write a greeting.",
    "starterCode": "class SpyWriter:\n    def __init__(self):\n        pass\n    def write(self, text):\n        pass\n\nclass Greeter:\n    def __init__(self, writer):\n        pass\n    def greet(self, name):\n        pass\n",
    "solution": "class SpyWriter:\n    def __init__(self):\n        self.writes = []\n    def write(self, text):\n        self.writes.append(text)\n\nclass Greeter:\n    def __init__(self, writer):\n        self.writer = writer\n    def greet(self, name):\n        self.writer.write(\"Hello, \" + name)\n",
    "testCases": [
      {
        "input": "w = SpyWriter(); g = Greeter(w); g.greet(\"Ada\"); print(w.writes)",
        "isHidden": false,
        "description": "Records write"
      },
      {
        "input": "w = SpyWriter(); Greeter(w).greet(\"\"); print(w.writes)",
        "isHidden": true,
        "description": "Empty name"
      },
      {
        "input": "w = SpyWriter(); g = Greeter(w); g.greet(\"A\"); g.greet(\"B\"); print(w.writes)",
        "isHidden": true,
        "description": "Multiple writes"
      }
    ],
    "hints": [
      "Spy records calls for test assertions",
      "Greeter delegates to writer"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex11",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Liskov: Preserve Return Types",
    "difficulty": 5,
    "description": "Create `BaseList` with `add(x)` returning the new length. Create `UniqueList(BaseList)` that only adds if not present, but still returns an int length.",
    "starterCode": "class BaseList:\n    def __init__(self):\n        pass\n    def add(self, x):\n        pass\n\nclass UniqueList(BaseList):\n    def add(self, x):\n        pass\n",
    "solution": "class BaseList:\n    def __init__(self):\n        self._data = []\n    def add(self, x):\n        self._data.append(x)\n        return len(self._data)\n\nclass UniqueList(BaseList):\n    def add(self, x):\n        if x not in self._data:\n            self._data.append(x)\n        return len(self._data)\n",
    "testCases": [
      {
        "input": "u = UniqueList(); print(u.add(1), u.add(1), u.add(2))",
        "isHidden": false,
        "description": "Unique behavior"
      },
      {
        "input": "b = BaseList(); print(b.add(\"x\"))",
        "isHidden": true,
        "description": "Base returns length"
      },
      {
        "input": "u = UniqueList(); r = u.add(\"a\"); print(isinstance(r, int))",
        "isHidden": true,
        "description": "Return type int"
      }
    ],
    "hints": [
      "Keep the same method signature and return type",
      "Track data in a list"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex12",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Composition: Feature Flags",
    "difficulty": 4,
    "description": "Create `FeatureFlags` with `is_enabled(name)` and `StaticFlags(enabled_set)`. Create `FeatureService` that checks a flag before allowing a feature.",
    "starterCode": "class StaticFlags:\n    def __init__(self, enabled):\n        pass\n    def is_enabled(self, name):\n        pass\n\nclass FeatureService:\n    def __init__(self, flags):\n        pass\n    def can_use(self, feature_name):\n        pass\n",
    "solution": "class StaticFlags:\n    def __init__(self, enabled):\n        self._enabled = set(enabled)\n    def is_enabled(self, name):\n        return name in self._enabled\n\nclass FeatureService:\n    def __init__(self, flags):\n        self.flags = flags\n    def can_use(self, feature_name):\n        return self.flags.is_enabled(feature_name)\n",
    "testCases": [
      {
        "input": "s = FeatureService(StaticFlags({\"a\"})); print(s.can_use(\"a\"), s.can_use(\"b\"))",
        "isHidden": false,
        "description": "Uses flags"
      },
      {
        "input": "s = FeatureService(StaticFlags(set())); print(s.can_use(\"x\"))",
        "isHidden": true,
        "description": "No flags enabled"
      },
      {
        "input": "s = FeatureService(StaticFlags({\"x\",\"y\"})); print(s.can_use(\"y\"))",
        "isHidden": true,
        "description": "Multiple flags"
      }
    ],
    "hints": [
      "Services should delegate to a dependency for feature decisions",
      "Store enabled flags in a set"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex13",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Small Refactor: Extract Formatter",
    "difficulty": 5,
    "description": "Create `Formatter` with `format(name)` returning `\"Hello, <name>!\"`. Create `Greeter` that uses a formatter and provides `greet(name)`.",
    "starterCode": "class Formatter:\n    def format(self, name):\n        pass\n\nclass Greeter:\n    def __init__(self, formatter):\n        pass\n    def greet(self, name):\n        pass\n",
    "solution": "class Formatter:\n    def format(self, name):\n        return f\"Hello, {name}!\"\n\nclass Greeter:\n    def __init__(self, formatter):\n        self.formatter = formatter\n    def greet(self, name):\n        return self.formatter.format(name)\n",
    "testCases": [
      {
        "input": "g = Greeter(Formatter()); print(g.greet(\"Ada\"))",
        "isHidden": false,
        "description": "Delegates formatting"
      },
      {
        "input": "g = Greeter(Formatter()); print(g.greet(\"\"))",
        "isHidden": true,
        "description": "Empty name"
      },
      {
        "input": "print(Formatter().format(\"X\"))",
        "isHidden": true,
        "description": "Formatter itself works"
      }
    ],
    "hints": [
      "Extracting dependencies makes code easier to test and change",
      "Greeter should delegate to formatter"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-ex14",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Testable Clock Injection",
    "difficulty": 5,
    "description": "Create `Clock` with `now()` and `FixedClock(value)` returning the fixed value. Create `Session` that uses a clock and records `started_at` when `start()` is called.",
    "starterCode": "class FixedClock:\n    def __init__(self, value):\n        pass\n    def now(self):\n        pass\n\nclass Session:\n    def __init__(self, clock):\n        pass\n    def start(self):\n        pass\n",
    "solution": "class FixedClock:\n    def __init__(self, value):\n        self.value = value\n    def now(self):\n        return self.value\n\nclass Session:\n    def __init__(self, clock):\n        self.clock = clock\n        self.started_at = None\n    def start(self):\n        self.started_at = self.clock.now()\n",
    "testCases": [
      {
        "input": "s = Session(FixedClock(\"t1\")); s.start(); print(s.started_at)",
        "isHidden": false,
        "description": "Uses injected clock"
      },
      {
        "input": "s = Session(FixedClock(123)); s.start(); print(s.started_at)",
        "isHidden": true,
        "description": "Any type"
      },
      {
        "input": "s = Session(FixedClock(\"x\")); print(s.started_at is None)",
        "isHidden": true,
        "description": "Not started yet"
      }
    ],
    "hints": [
      "Inject time to avoid real clocks in tests",
      "Set started_at in start()"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-drill-1",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Composition Reminder",
    "difficulty": 1,
    "description": "Create a `Car` that has an `Engine` and returns the engine type from `describe()`.",
    "starterCode": "class Engine:\n    def __init__(self, kind):\n        pass\n\nclass Car:\n    def __init__(self, engine):\n        pass\n    def describe(self):\n        pass\n",
    "solution": "class Engine:\n    def __init__(self, kind):\n        self.kind = kind\n\nclass Car:\n    def __init__(self, engine):\n        self.engine = engine\n    def describe(self):\n        return self.engine.kind\n",
    "testCases": [
      {
        "input": "print(Car(Engine(\"v8\")).describe())",
        "isHidden": false,
        "description": "Describes engine"
      },
      {
        "input": "print(Car(Engine(\"electric\")).describe())",
        "isHidden": true,
        "description": "Other kind"
      },
      {
        "input": "e = Engine(\"x\"); c = Car(e); print(c.engine is e)",
        "isHidden": true,
        "description": "Has-a engine"
      }
    ],
    "hints": [
      "Car stores the engine object",
      "Describe uses engine data"
    ],
    "language": "python"
  },
  {
    "id": "cs103-t7-drill-2",
    "subjectId": "cs103",
    "topicId": "cs103-7",
    "title": "Tiny Fake for Testing",
    "difficulty": 1,
    "description": "Create a `FakeSender` that stores `(to, subject)` pairs when send is called.",
    "starterCode": "class FakeSender:\n    def __init__(self):\n        pass\n    def send(self, to, subject):\n        pass\n",
    "solution": "class FakeSender:\n    def __init__(self):\n        self.sent = []\n    def send(self, to, subject):\n        self.sent.append((to, subject))\n",
    "testCases": [
      {
        "input": "f = FakeSender(); f.send(\"a\", \"b\"); print(f.sent)",
        "isHidden": false,
        "description": "Records send"
      },
      {
        "input": "f = FakeSender(); print(f.sent)",
        "isHidden": true,
        "description": "Starts empty"
      },
      {
        "input": "f = FakeSender(); f.send(\"\", \"\"); print(f.sent)",
        "isHidden": true,
        "description": "Empty values"
      }
    ],
    "hints": [
      "Store calls in a list",
      "Append a tuple per call"
    ],
    "language": "python"
  }
]
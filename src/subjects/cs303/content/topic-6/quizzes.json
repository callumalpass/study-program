[
  {
    "id": "cs303-t6-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Memory Basics",
    "questions": [
      {
        "id": "cs303-t6-q1-1",
        "type": "multiple_choice",
        "prompt": "What is stored on the stack?",
        "options": [
          "All variables",
          "Objects",
          "Function call frames and local variables",
          "Global data"
        ],
        "correctAnswer": 2,
        "explanation": "The stack stores function call frames including return addresses, parameters, and local variables."
      },
      {
        "id": "cs303-t6-q1-2",
        "type": "multiple_choice",
        "prompt": "What is stored on the heap?",
        "options": [
          "Dynamically allocated objects with varying lifetimes",
          "Function code",
          "Only strings",
          "Constants"
        ],
        "correctAnswer": 0,
        "explanation": "The heap stores dynamically allocated data whose lifetime isn't tied to function calls."
      },
      {
        "id": "cs303-t6-q1-3",
        "type": "multiple_choice",
        "prompt": "What is a memory leak?",
        "options": [
          "Physical damage",
          "Allocated memory that is no longer accessible but not freed",
          "Data loss",
          "Buffer overflow"
        ],
        "correctAnswer": 1,
        "explanation": "A memory leak occurs when allocated memory becomes unreachable but isn't deallocated."
      },
      {
        "id": "cs303-t6-q1-4",
        "type": "multiple_choice",
        "prompt": "What is a dangling pointer?",
        "options": [
          "A null pointer",
          "An unused pointer",
          "A pointer to memory that has been freed",
          "A pointer arithmetic error"
        ],
        "correctAnswer": 2,
        "explanation": "A dangling pointer references memory that has been deallocated, leading to undefined behavior."
      },
      {
        "id": "cs303-t6-q1-5",
        "type": "multiple_choice",
        "prompt": "What is RAII (Resource Acquisition Is Initialization)?",
        "options": [
          "An initialization pattern",
          "A programming language",
          "Tying resource lifetime to object lifetime",
          "A memory allocator"
        ],
        "correctAnswer": 2,
        "explanation": "RAII ties resource management to object lifetime: acquire in constructor, release in destructor."
      }
    ]
  },
  {
    "id": "cs303-t6-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Garbage Collection",
    "questions": [
      {
        "id": "cs303-t6-q2-1",
        "type": "multiple_choice",
        "prompt": "What is the basic principle of garbage collection?",
        "options": [
          "Compressing data",
          "Deleting files",
          "Automatically reclaiming unreachable memory",
          "Defragmenting disk"
        ],
        "correctAnswer": 2,
        "explanation": "Garbage collection automatically identifies and reclaims memory that is no longer reachable by the program."
      },
      {
        "id": "cs303-t6-q2-2",
        "type": "multiple_choice",
        "prompt": "How does mark-and-sweep work?",
        "options": [
          "Marks files for deletion",
          "Marks reachable objects, sweeps (frees) unmarked objects",
          "Marks errors",
          "Sweeps the stack"
        ],
        "correctAnswer": 1,
        "explanation": "Mark-and-sweep traces from roots marking reachable objects, then frees all unmarked objects."
      },
      {
        "id": "cs303-t6-q2-3",
        "type": "multiple_choice",
        "prompt": "What is the main problem with reference counting?",
        "options": [
          "Too slow",
          "Only works for integers",
          "Cannot reclaim circular references",
          "Uses too much memory"
        ],
        "correctAnswer": 2,
        "explanation": "Reference counting cannot reclaim cycles where objects reference each other but are unreachable from roots."
      },
      {
        "id": "cs303-t6-q2-4",
        "type": "multiple_choice",
        "prompt": "What is generational garbage collection based on?",
        "options": [
          "The hypothesis that most objects die young",
          "Old programming styles",
          "Generation gaps",
          "Code generations"
        ],
        "correctAnswer": 0,
        "explanation": "Generational GC exploits the observation that most objects are short-lived, focusing collection on young objects."
      },
      {
        "id": "cs303-t6-q2-5",
        "type": "multiple_choice",
        "prompt": "What is a GC root?",
        "options": [
          "The main function",
          "A starting point for reachability tracing",
          "Root directory",
          "The heap start"
        ],
        "correctAnswer": 1,
        "explanation": "GC roots are the starting points for tracing: global variables, stack references, and registers."
      }
    ]
  },
  {
    "id": "cs303-t6-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-6",
    "title": "Modern Memory Management",
    "questions": [
      {
        "id": "cs303-t6-q3-1",
        "type": "multiple_choice",
        "prompt": "What is Rust's ownership system?",
        "options": [
          "File ownership",
          "Copyright management",
          "Each value has one owner; ownership can be moved or borrowed",
          "Thread ownership"
        ],
        "correctAnswer": 2,
        "explanation": "Rust's ownership: each value has one owner, transferring ownership moves the value, borrowing allows temporary access."
      },
      {
        "id": "cs303-t6-q3-2",
        "type": "multiple_choice",
        "prompt": "What is the borrow checker in Rust?",
        "options": [
          "A linter",
          "A runtime check",
          "A compiler component that enforces borrowing rules",
          "A library checker"
        ],
        "correctAnswer": 2,
        "explanation": "Rust's borrow checker statically enforces that references don't outlive their referents and prevents aliased mutation."
      },
      {
        "id": "cs303-t6-q3-3",
        "type": "multiple_choice",
        "prompt": "What is region-based memory management?",
        "options": [
          "Allocating objects in regions that are freed together",
          "Disk regions",
          "Geographic allocation",
          "Regional programming"
        ],
        "correctAnswer": 0,
        "explanation": "Region-based management groups objects into regions/arenas that are deallocated together, avoiding individual frees."
      },
      {
        "id": "cs303-t6-q3-4",
        "type": "multiple_choice",
        "prompt": "What are linear types used for?",
        "options": [
          "Ensuring values are used exactly once",
          "Linear algebra",
          "Line-by-line processing",
          "Linear search"
        ],
        "correctAnswer": 0,
        "explanation": "Linear types ensure each value is used exactly once, enabling safe resource management without GC."
      },
      {
        "id": "cs303-t6-q3-5",
        "type": "multiple_choice",
        "prompt": "What is a write barrier in garbage collection?",
        "options": [
          "Preventing writes",
          "Code executed on pointer writes to maintain GC invariants",
          "A memory protection",
          "A lock"
        ],
        "correctAnswer": 1,
        "explanation": "Write barriers are hooks on pointer updates that maintain information needed by the garbage collector."
      }
    ]
  }
]

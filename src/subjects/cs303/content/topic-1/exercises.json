[
  {
    "id": "cs303-ex-1-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Pure Function Implementation",
    "difficulty": 1,
    "description": "Write a pure function that calculates the factorial of a number without side effects.",
    "starterCode": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of n using pure functional style.\n    The function should:\n    - Not modify any external state\n    - Return the same output for the same input\n    - Use recursion or reduce/fold pattern\n\n    Args:\n        n: A non-negative integer\n    Returns:\n        The factorial of n (n!)\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of n using pure functional style.\n    \"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)",
    "testCases": [
      {
        "input": "0",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "1",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "A pure function always returns the same output for the same input",
      "Use recursion: factorial(n) = n * factorial(n-1)",
      "Base case: factorial(0) = factorial(1) = 1"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Imperative to Functional Conversion",
    "difficulty": 1,
    "description": "Convert an imperative loop-based sum function to a functional style using reduce.",
    "starterCode": "from functools import reduce\n\n# Original imperative version (for reference):\n# def sum_squares_imperative(numbers):\n#     total = 0\n#     for n in numbers:\n#         total += n * n\n#     return total\n\ndef sum_squares(numbers):\n    \"\"\"\n    Calculate the sum of squares using functional programming.\n    Use map/reduce or list comprehension instead of explicit loops.\n\n    Args:\n        numbers: A list of integers\n    Returns:\n        The sum of squares of all numbers\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "from functools import reduce\n\ndef sum_squares(numbers):\n    \"\"\"\n    Calculate the sum of squares using functional programming.\n    \"\"\"\n    return reduce(lambda acc, x: acc + x * x, numbers, 0)",
    "testCases": [
      {
        "input": "[]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[4, 5]",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "[1, 1, 1, 1]",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use reduce from functools to combine elements",
      "The lambda takes an accumulator and current element",
      "Start with initial value 0"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Higher-Order Function Implementation",
    "difficulty": 1,
    "description": "Implement a higher-order function that composes two functions together.",
    "starterCode": "def compose(f, g):\n    \"\"\"\n    Return a new function that applies g first, then f.\n    compose(f, g)(x) should equal f(g(x))\n\n    Args:\n        f: A function\n        g: A function\n    Returns:\n        A new function that is the composition of f and g\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def compose(f, g):\n    \"\"\"\n    Return a new function that applies g first, then f.\n    \"\"\"\n    return lambda x: f(g(x))",
    "testCases": [
      {
        "input": "compose(lambda x: x + 1, lambda x: x * 2)(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(str, abs)(-5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(lambda x: x ** 2, lambda x: x + 1)(2)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "A higher-order function returns a function",
      "The returned function should take an argument x",
      "Apply g(x) first, then f to the result"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Object-Oriented Counter",
    "difficulty": 1,
    "description": "Implement a Counter class demonstrating encapsulation with private state.",
    "starterCode": "class Counter:\n    \"\"\"\n    A counter class that encapsulates its state.\n    The internal count should not be directly accessible.\n    \"\"\"\n\n    def __init__(self, initial=0):\n        \"\"\"Initialize the counter with an optional starting value.\"\"\"\n        # Your implementation here\n        pass\n\n    def increment(self):\n        \"\"\"Increase the count by 1 and return new value.\"\"\"\n        pass\n\n    def decrement(self):\n        \"\"\"Decrease the count by 1 and return new value.\"\"\"\n        pass\n\n    def get_value(self):\n        \"\"\"Return the current count.\"\"\"\n        pass",
    "solution": "class Counter:\n    \"\"\"\n    A counter class that encapsulates its state.\n    \"\"\"\n\n    def __init__(self, initial=0):\n        self._count = initial\n\n    def increment(self):\n        self._count += 1\n        return self._count\n\n    def decrement(self):\n        self._count -= 1\n        return self._count\n\n    def get_value(self):\n        return self._count",
    "testCases": [
      {
        "input": "c = Counter(); c.increment(); c.get_value()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "c = Counter(10); c.decrement(); c.get_value()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "c = Counter(); [c.increment() for _ in range(5)]; c.get_value()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use underscore prefix for private attributes (_count)",
      "Each method should modify or return the internal state",
      "Encapsulation hides implementation details"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Polymorphism with Duck Typing",
    "difficulty": 3,
    "description": "Implement multiple classes that share a common interface through duck typing.",
    "starterCode": "class Rectangle:\n    \"\"\"A rectangle shape.\"\"\"\n    def __init__(self, width, height):\n        # Your implementation here\n        pass\n\n    def area(self):\n        \"\"\"Return the area of the rectangle.\"\"\"\n        pass\n\n    def perimeter(self):\n        \"\"\"Return the perimeter of the rectangle.\"\"\"\n        pass\n\nclass Circle:\n    \"\"\"A circle shape.\"\"\"\n    import math\n\n    def __init__(self, radius):\n        # Your implementation here\n        pass\n\n    def area(self):\n        \"\"\"Return the area of the circle.\"\"\"\n        pass\n\n    def perimeter(self):\n        \"\"\"Return the circumference of the circle.\"\"\"\n        pass\n\ndef total_area(shapes):\n    \"\"\"\n    Calculate total area of all shapes.\n    Uses duck typing - any object with an area() method works.\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "import math\n\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi * self.radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self.radius\n\ndef total_area(shapes):\n    return sum(shape.area() for shape in shapes)",
    "testCases": [
      {
        "input": "Rectangle(3, 4).area()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "round(Circle(1).area(), 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "total_area([Rectangle(2, 3), Rectangle(4, 5)])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Duck typing: if it has area(), it can be used as a shape",
      "Circle area = π * r²",
      "Use sum() with a generator expression for total_area"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Inheritance Hierarchy",
    "difficulty": 3,
    "description": "Create a class hierarchy demonstrating inheritance and method overriding.",
    "starterCode": "class Animal:\n    \"\"\"Base class for all animals.\"\"\"\n\n    def __init__(self, name):\n        # Your implementation here\n        pass\n\n    def speak(self):\n        \"\"\"Return the sound the animal makes.\"\"\"\n        raise NotImplementedError(\"Subclass must implement\")\n\n    def describe(self):\n        \"\"\"Return a description including the animal's sound.\"\"\"\n        pass\n\nclass Dog(Animal):\n    \"\"\"A dog that barks.\"\"\"\n\n    def speak(self):\n        pass\n\nclass Cat(Animal):\n    \"\"\"A cat that meows.\"\"\"\n\n    def speak(self):\n        pass\n\nclass Cow(Animal):\n    \"\"\"A cow that moos.\"\"\"\n\n    def speak(self):\n        pass",
    "solution": "class Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        raise NotImplementedError(\"Subclass must implement\")\n\n    def describe(self):\n        return f\"{self.name} says {self.speak()}\"\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\nclass Cow(Animal):\n    def speak(self):\n        return \"Moo!\"",
    "testCases": [
      {
        "input": "Dog(\"Rex\").speak()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Cat(\"Whiskers\").describe()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Cow(\"Bessie\").speak()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store name in self.name in __init__",
      "Override speak() in each subclass",
      "describe() can call self.speak()"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Closure and State",
    "difficulty": 3,
    "description": "Implement a function that returns a closure maintaining internal state.",
    "starterCode": "def make_accumulator(initial=0):\n    \"\"\"\n    Return a function that accumulates values.\n    Each call adds to the running total.\n\n    Example:\n        acc = make_accumulator(10)\n        acc(5)  # returns 15\n        acc(3)  # returns 18\n\n    Args:\n        initial: Starting value for the accumulator\n    Returns:\n        A function that takes a value and returns the new total\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def make_accumulator(initial=0):\n    \"\"\"\n    Return a function that accumulates values.\n    \"\"\"\n    total = initial\n\n    def accumulate(value):\n        nonlocal total\n        total += value\n        return total\n\n    return accumulate",
    "testCases": [
      {
        "input": "acc = make_accumulator(); acc(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "acc = make_accumulator(10); acc(5); acc(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "acc = make_accumulator(); acc(1); acc(2); acc(3)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use nonlocal to modify the outer variable",
      "The inner function closes over the total variable",
      "Each call to the returned function updates and returns total"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Declarative List Processing",
    "difficulty": 3,
    "description": "Process a list of dictionaries using declarative style with filter, map, and sorted.",
    "starterCode": "def process_people(people):\n    \"\"\"\n    Process a list of people dictionaries.\n    1. Filter to only adults (age >= 18)\n    2. Extract just their names\n    3. Sort alphabetically\n    4. Return as a list\n\n    Args:\n        people: List of dicts with 'name' and 'age' keys\n    Returns:\n        Sorted list of adult names\n\n    Example:\n        people = [\n            {'name': 'Alice', 'age': 25},\n            {'name': 'Bob', 'age': 17},\n            {'name': 'Charlie', 'age': 30}\n        ]\n        # Returns ['Alice', 'Charlie']\n    \"\"\"\n    # Your implementation here (use filter, map, sorted)\n    pass",
    "solution": "def process_people(people):\n    \"\"\"\n    Process a list of people dictionaries.\n    \"\"\"\n    adults = filter(lambda p: p['age'] >= 18, people)\n    names = map(lambda p: p['name'], adults)\n    return sorted(names)",
    "testCases": [
      {
        "input": "process_people([{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 17}])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_people([{'name': 'Zoe', 'age': 20}, {'name': 'Amy', 'age': 22}])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_people([])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "filter(predicate, iterable) keeps elements where predicate is True",
      "map(function, iterable) transforms each element",
      "sorted() returns a new sorted list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Curried Function",
    "difficulty": 3,
    "description": "Implement a curried version of a multi-argument function.",
    "starterCode": "def curry_add():\n    \"\"\"\n    Return a curried addition function.\n    Instead of add(a, b, c), use curry_add()(a)(b)(c)\n\n    Example:\n        add_curried = curry_add()\n        add_curried(1)(2)(3)  # returns 6\n\n        add_five = curry_add()(5)\n        add_five(3)(2)  # returns 10\n\n    Returns:\n        A curried function that adds three numbers\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def curry_add():\n    \"\"\"\n    Return a curried addition function.\n    \"\"\"\n    def add_first(a):\n        def add_second(b):\n            def add_third(c):\n                return a + b + c\n            return add_third\n        return add_second\n    return add_first",
    "testCases": [
      {
        "input": "curry_add()(1)(2)(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "curry_add()(10)(20)(30)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "add_five = curry_add()(5); add_five(3)(2)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Currying transforms f(a,b,c) into f(a)(b)(c)",
      "Each call returns a function waiting for the next argument",
      "The innermost function computes the final result"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Strategy Pattern",
    "difficulty": 3,
    "description": "Implement the Strategy pattern using first-class functions.",
    "starterCode": "def process_data(data, strategy):\n    \"\"\"\n    Process data using the provided strategy function.\n\n    Args:\n        data: A list of numbers\n        strategy: A function that takes a list and returns a value\n    Returns:\n        Result of applying strategy to data\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef sum_strategy(data):\n    \"\"\"Strategy: return sum of data.\"\"\"\n    pass\n\ndef max_strategy(data):\n    \"\"\"Strategy: return maximum of data.\"\"\"\n    pass\n\ndef mean_strategy(data):\n    \"\"\"Strategy: return arithmetic mean of data.\"\"\"\n    pass",
    "solution": "def process_data(data, strategy):\n    \"\"\"\n    Process data using the provided strategy function.\n    \"\"\"\n    return strategy(data)\n\ndef sum_strategy(data):\n    return sum(data)\n\ndef max_strategy(data):\n    return max(data) if data else None\n\ndef mean_strategy(data):\n    return sum(data) / len(data) if data else 0",
    "testCases": [
      {
        "input": "process_data([1, 2, 3, 4, 5], sum_strategy)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_data([1, 5, 3, 9, 2], max_strategy)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "process_data([2, 4, 6, 8], mean_strategy)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functions are first-class citizens in Python",
      "Pass the strategy function as an argument",
      "Call the strategy with the data"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Immutable Data Transformation",
    "difficulty": 5,
    "description": "Implement functions that transform data structures immutably.",
    "starterCode": "def update_nested(data, path, value):\n    \"\"\"\n    Return a new dictionary with a nested value updated.\n    Does not modify the original dictionary.\n\n    Args:\n        data: A nested dictionary\n        path: List of keys to traverse\n        value: New value to set\n    Returns:\n        A new dictionary with the value updated\n\n    Example:\n        data = {'a': {'b': {'c': 1}}}\n        update_nested(data, ['a', 'b', 'c'], 2)\n        # Returns {'a': {'b': {'c': 2}}}\n        # Original data unchanged\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def update_nested(data, path, value):\n    \"\"\"\n    Return a new dictionary with a nested value updated.\n    \"\"\"\n    if not path:\n        return value\n\n    key = path[0]\n    rest = path[1:]\n\n    new_data = dict(data)\n    new_data[key] = update_nested(data.get(key, {}), rest, value)\n    return new_data",
    "testCases": [
      {
        "input": "update_nested({'a': 1}, ['a'], 2)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "update_nested({'a': {'b': 1}}, ['a', 'b'], 5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "d = {'x': 1}; update_nested(d, ['x'], 2); d['x']",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Create copies at each level, do not modify in place",
      "Use recursion to handle nested structures",
      "dict(data) creates a shallow copy"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Abstract Base Class",
    "difficulty": 5,
    "description": "Create an abstract base class enforcing interface implementation.",
    "starterCode": "from abc import ABC, abstractmethod\n\nclass Serializable(ABC):\n    \"\"\"Abstract base class for serializable objects.\"\"\"\n\n    @abstractmethod\n    def to_json(self):\n        \"\"\"Convert object to JSON-compatible dict.\"\"\"\n        pass\n\n    @abstractmethod\n    def from_json(cls, data):\n        \"\"\"Create object from JSON-compatible dict.\"\"\"\n        pass\n\nclass Person(Serializable):\n    \"\"\"A person that can be serialized.\"\"\"\n\n    def __init__(self, name, age):\n        # Your implementation here\n        pass\n\n    def to_json(self):\n        # Your implementation here\n        pass\n\n    @classmethod\n    def from_json(cls, data):\n        # Your implementation here\n        pass",
    "solution": "from abc import ABC, abstractmethod\n\nclass Serializable(ABC):\n    @abstractmethod\n    def to_json(self):\n        pass\n\n    @classmethod\n    @abstractmethod\n    def from_json(cls, data):\n        pass\n\nclass Person(Serializable):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def to_json(self):\n        return {'name': self.name, 'age': self.age}\n\n    @classmethod\n    def from_json(cls, data):\n        return cls(data['name'], data['age'])",
    "testCases": [
      {
        "input": "Person('Alice', 30).to_json()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Person.from_json({'name': 'Bob', 'age': 25}).name",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "p = Person('Eve', 20); Person.from_json(p.to_json()).age",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use @abstractmethod decorator for abstract methods",
      "@classmethod receives the class as first argument",
      "from_json should return a new instance of the class"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Monad-like Pipeline",
    "difficulty": 5,
    "description": "Implement a Maybe-like container for safe chained operations.",
    "starterCode": "class Maybe:\n    \"\"\"\n    A container that handles None values gracefully.\n    Allows chaining operations without explicit None checks.\n    \"\"\"\n\n    def __init__(self, value):\n        # Your implementation here\n        pass\n\n    def map(self, func):\n        \"\"\"\n        Apply func to the value if it exists.\n        Return Maybe(None) if value is None.\n        \"\"\"\n        pass\n\n    def flat_map(self, func):\n        \"\"\"\n        Apply func (which returns a Maybe) and flatten.\n        \"\"\"\n        pass\n\n    def get_or_default(self, default):\n        \"\"\"Return value if it exists, otherwise default.\"\"\"\n        pass",
    "solution": "class Maybe:\n    def __init__(self, value):\n        self._value = value\n\n    def map(self, func):\n        if self._value is None:\n            return Maybe(None)\n        return Maybe(func(self._value))\n\n    def flat_map(self, func):\n        if self._value is None:\n            return Maybe(None)\n        return func(self._value)\n\n    def get_or_default(self, default):\n        return self._value if self._value is not None else default",
    "testCases": [
      {
        "input": "Maybe(5).map(lambda x: x * 2).get_or_default(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Maybe(None).map(lambda x: x * 2).get_or_default(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Maybe('hello').map(str.upper).get_or_default('')",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Check if value is None before applying operations",
      "map wraps result in a new Maybe",
      "flat_map expects func to return a Maybe"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Visitor Pattern",
    "difficulty": 5,
    "description": "Implement the Visitor pattern for processing heterogeneous data structures.",
    "starterCode": "class Expression:\n    \"\"\"Base class for expressions.\"\"\"\n    def accept(self, visitor):\n        raise NotImplementedError\n\nclass Number(Expression):\n    def __init__(self, value):\n        self.value = value\n\n    def accept(self, visitor):\n        # Your implementation here\n        pass\n\nclass BinaryOp(Expression):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\n    def accept(self, visitor):\n        # Your implementation here\n        pass\n\nclass EvalVisitor:\n    \"\"\"Visitor that evaluates expressions.\"\"\"\n\n    def visit_number(self, node):\n        pass\n\n    def visit_binary_op(self, node):\n        pass\n\nclass PrintVisitor:\n    \"\"\"Visitor that creates string representation.\"\"\"\n\n    def visit_number(self, node):\n        pass\n\n    def visit_binary_op(self, node):\n        pass",
    "solution": "class Expression:\n    def accept(self, visitor):\n        raise NotImplementedError\n\nclass Number(Expression):\n    def __init__(self, value):\n        self.value = value\n\n    def accept(self, visitor):\n        return visitor.visit_number(self)\n\nclass BinaryOp(Expression):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\n    def accept(self, visitor):\n        return visitor.visit_binary_op(self)\n\nclass EvalVisitor:\n    def visit_number(self, node):\n        return node.value\n\n    def visit_binary_op(self, node):\n        left = node.left.accept(self)\n        right = node.right.accept(self)\n        ops = {'+': lambda a, b: a + b, '-': lambda a, b: a - b,\n               '*': lambda a, b: a * b, '/': lambda a, b: a / b}\n        return ops[node.op](left, right)\n\nclass PrintVisitor:\n    def visit_number(self, node):\n        return str(node.value)\n\n    def visit_binary_op(self, node):\n        left = node.left.accept(self)\n        right = node.right.accept(self)\n        return f\"({left} {node.op} {right})\"",
    "testCases": [
      {
        "input": "Number(5).accept(EvalVisitor())",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "BinaryOp(Number(3), \"+\", Number(4)).accept(EvalVisitor())",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "BinaryOp(Number(2), \"*\", Number(3)).accept(PrintVisitor())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "accept() calls the appropriate visitor method",
      "Visitor methods process the node and return a result",
      "For BinaryOp, recursively visit children"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Lazy Evaluation",
    "difficulty": 5,
    "description": "Implement a lazy sequence that computes values on demand.",
    "starterCode": "class LazySequence:\n    \"\"\"\n    A lazy sequence that generates values on demand.\n    Values are computed only when accessed.\n    \"\"\"\n\n    def __init__(self, generator_func):\n        \"\"\"\n        Initialize with a generator function.\n        generator_func takes an index and returns the value at that index.\n        \"\"\"\n        # Your implementation here\n        pass\n\n    def __getitem__(self, index):\n        \"\"\"Get item at index, computing if necessary.\"\"\"\n        pass\n\n    def take(self, n):\n        \"\"\"Return first n elements as a list.\"\"\"\n        pass\n\n    def map(self, func):\n        \"\"\"Return a new lazy sequence with func applied.\"\"\"\n        pass\n\ndef naturals():\n    \"\"\"Return lazy sequence of natural numbers 0, 1, 2, ...\"\"\"\n    pass\n\ndef fibonacci():\n    \"\"\"Return lazy sequence of Fibonacci numbers.\"\"\"\n    pass",
    "solution": "class LazySequence:\n    def __init__(self, generator_func):\n        self._generator = generator_func\n        self._cache = {}\n\n    def __getitem__(self, index):\n        if index not in self._cache:\n            self._cache[index] = self._generator(index)\n        return self._cache[index]\n\n    def take(self, n):\n        return [self[i] for i in range(n)]\n\n    def map(self, func):\n        return LazySequence(lambda i: func(self[i]))\n\ndef naturals():\n    return LazySequence(lambda i: i)\n\ndef fibonacci():\n    def fib(n):\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n    return LazySequence(fib)",
    "testCases": [
      {
        "input": "naturals().take(5)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci().take(8)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "naturals().map(lambda x: x ** 2).take(4)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store generator function, compute values lazily",
      "Cache computed values to avoid recomputation",
      "map returns a new LazySequence with transformed generator"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-1-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Multi-Paradigm Calculator",
    "difficulty": 5,
    "description": "Build a calculator demonstrating multiple programming paradigms.",
    "starterCode": "# Functional approach: operations as functions\ndef make_calculator():\n    \"\"\"\n    Create a calculator using functional programming.\n    Returns a dict of operation functions.\n    \"\"\"\n    pass\n\n# OOP approach: calculator as object\nclass Calculator:\n    \"\"\"\n    Calculator using object-oriented programming.\n    Maintains history of operations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def calculate(self, a, op, b):\n        \"\"\"Perform operation and store in history.\"\"\"\n        pass\n\n    def get_history(self):\n        \"\"\"Return list of past calculations.\"\"\"\n        pass\n\n# Declarative approach: expression evaluation\ndef evaluate_expression(expr):\n    \"\"\"\n    Evaluate a simple arithmetic expression string.\n    Supports +, -, *, / with two operands.\n    Example: \"3 + 4\" -> 7\n    \"\"\"\n    pass",
    "solution": "# Functional approach\ndef make_calculator():\n    return {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: a / b if b != 0 else float('inf')\n    }\n\n# OOP approach\nclass Calculator:\n    def __init__(self):\n        self._history = []\n        self._ops = make_calculator()\n\n    def calculate(self, a, op, b):\n        result = self._ops[op](a, b)\n        self._history.append(f\"{a} {op} {b} = {result}\")\n        return result\n\n    def get_history(self):\n        return self._history.copy()\n\n# Declarative approach\ndef evaluate_expression(expr):\n    parts = expr.split()\n    a, op, b = float(parts[0]), parts[1], float(parts[2])\n    ops = make_calculator()\n    return ops[op](a, b)",
    "testCases": [
      {
        "input": "make_calculator()['+' ](3, 4)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "c = Calculator(); c.calculate(10, \"-\", 4)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "evaluate_expression(\"6 * 7\")",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functional: store operations as lambda functions in a dict",
      "OOP: maintain history list, use operation dict internally",
      "Declarative: parse string and dispatch to appropriate operation"
    ],
    "language": "python"
  }
]

[
  {
    "id": "cs303-t1-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Paradigms Fundamentals",
    "questions": [
      {
        "id": "cs303-t1-q1-1",
        "type": "multiple_choice",
        "prompt": "Which paradigm treats computation as the evaluation of mathematical functions and avoids changing state?",
        "options": [
          "Object-oriented programming",
          "Logic programming",
          "Functional programming",
          "Imperative programming"
        ],
        "correctAnswer": 2,
        "explanation": "Functional programming emphasizes pure functions, immutability, and declarative expressions without side effects."
      },
      {
        "id": "cs303-t1-q1-2",
        "type": "multiple_choice",
        "prompt": "What is the primary characteristic of imperative programming?",
        "options": [
          "Logical inference",
          "Pattern matching",
          "Message passing between objects",
          "Explicit control flow through statements"
        ],
        "correctAnswer": 3,
        "explanation": "Imperative programming uses statements that change program state, with explicit control flow through loops and conditionals."
      },
      {
        "id": "cs303-t1-q1-3",
        "type": "multiple_choice",
        "prompt": "Which paradigm uses facts and rules to derive conclusions through logical inference?",
        "options": [
          "Imperative programming",
          "Logic programming",
          "Functional programming",
          "Event-driven programming"
        ],
        "correctAnswer": 1,
        "explanation": "Logic programming (e.g., Prolog) expresses computation through logical statements and derives answers through inference."
      },
      {
        "id": "cs303-t1-q1-4",
        "type": "multiple_choice",
        "prompt": "What distinguishes declarative programming from imperative programming?",
        "options": [
          "Declarative requires compilation",
          "Declarative uses more memory",
          "Declarative is always faster",
          "Declarative describes what to compute, not how"
        ],
        "correctAnswer": 3,
        "explanation": "Declarative programming specifies the desired result, leaving implementation details to the language/runtime."
      },
      {
        "id": "cs303-t1-q1-5",
        "type": "multiple_choice",
        "prompt": "Which is NOT a core concept of object-oriented programming?",
        "options": [
          "Polymorphism",
          "Unification",
          "Encapsulation",
          "Inheritance"
        ],
        "correctAnswer": 1,
        "explanation": "Unification is a concept from logic programming. OOP core concepts are encapsulation, inheritance, polymorphism, and abstraction."
      }
    ]
  },
  {
    "id": "cs303-t1-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Paradigms Application",
    "questions": [
      {
        "id": "cs303-t1-q2-1",
        "type": "multiple_choice",
        "prompt": "Which concurrency model uses isolated processes that communicate through message passing?",
        "options": [
          "Actor model",
          "Thread pool",
          "Busy waiting",
          "Shared memory with locks"
        ],
        "correctAnswer": 0,
        "explanation": "The Actor model uses isolated actors that maintain private state and communicate exclusively through asynchronous messages."
      },
      {
        "id": "cs303-t1-q2-2",
        "type": "multiple_choice",
        "prompt": "What does CSP (Communicating Sequential Processes) use for synchronization?",
        "options": [
          "Semaphores",
          "Mutexes",
          "Channels",
          "Barriers"
        ],
        "correctAnswer": 2,
        "explanation": "CSP uses channels for communication and synchronization between concurrent processes."
      },
      {
        "id": "cs303-t1-q2-3",
        "type": "multiple_choice",
        "prompt": "Which language is considered purely functional with lazy evaluation by default?",
        "options": [
          "Haskell",
          "OCaml",
          "Scala",
          "F#"
        ],
        "correctAnswer": 0,
        "explanation": "Haskell is a purely functional language with lazy evaluation by default, enforcing referential transparency."
      },
      {
        "id": "cs303-t1-q2-4",
        "type": "multiple_choice",
        "prompt": "What is a multi-paradigm language?",
        "options": [
          "A language with multiple compilers",
          "A language for multi-core processors",
          "A language that only supports OOP",
          "A language supporting multiple programming styles"
        ],
        "correctAnswer": 3,
        "explanation": "Multi-paradigm languages like Python, Scala, and JavaScript support multiple programming paradigms within the same language."
      },
      {
        "id": "cs303-t1-q2-5",
        "type": "multiple_choice",
        "prompt": "In Prolog, what is unification?",
        "options": [
          "Pattern matching that can bind variables",
          "Compiling code",
          "Combining multiple programs",
          "Merging databases"
        ],
        "correctAnswer": 0,
        "explanation": "Unification in Prolog matches terms and binds variables to make terms identical, forming the basis of logical inference."
      }
    ]
  },
  {
    "id": "cs303-t1-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-1",
    "title": "Advanced Paradigms",
    "questions": [
      {
        "id": "cs303-t1-q3-1",
        "type": "multiple_choice",
        "prompt": "What problem does the Actor model help avoid compared to shared-memory concurrency?",
        "options": [
          "Race conditions and deadlocks",
          "Memory leaks",
          "Stack overflow",
          "Type errors"
        ],
        "correctAnswer": 0,
        "explanation": "By eliminating shared mutable state, the Actor model avoids race conditions and many deadlock scenarios."
      },
      {
        "id": "cs303-t1-q3-2",
        "type": "multiple_choice",
        "prompt": "Which paradigm would be most suitable for a rule-based expert system?",
        "options": [
          "Object-oriented",
          "Functional",
          "Logic programming",
          "Imperative"
        ],
        "correctAnswer": 2,
        "explanation": "Logic programming excels at expressing rules and deriving conclusions, making it ideal for expert systems."
      },
      {
        "id": "cs303-t1-q3-3",
        "type": "multiple_choice",
        "prompt": "What is referential transparency?",
        "options": [
          "An expression can be replaced by its value",
          "Being able to see through objects",
          "Code that references other code",
          "Transparent error handling"
        ],
        "correctAnswer": 0,
        "explanation": "Referential transparency means an expression can be replaced with its value without changing program behavior."
      },
      {
        "id": "cs303-t1-q3-4",
        "type": "multiple_choice",
        "prompt": "Which feature distinguishes prototype-based OOP from class-based OOP?",
        "options": [
          "Static typing",
          "No encapsulation",
          "Objects inherit directly from other objects",
          "No inheritance"
        ],
        "correctAnswer": 2,
        "explanation": "In prototype-based OOP (e.g., JavaScript), objects inherit directly from other objects rather than from classes."
      },
      {
        "id": "cs303-t1-q3-5",
        "type": "multiple_choice",
        "prompt": "What is a closure in functional programming?",
        "options": [
          "A way to close files",
          "A function with its captured environment",
          "The end of a program",
          "A type of loop"
        ],
        "correctAnswer": 1,
        "explanation": "A closure is a function that captures and retains access to variables from its defining scope."
      }
    ]
  }
]

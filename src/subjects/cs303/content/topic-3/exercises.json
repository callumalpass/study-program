[
  {
    "id": "cs303-ex-3-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Map Implementation",
    "difficulty": 1,
    "description": "Implement the map higher-order function from scratch.",
    "starterCode": "def my_map(func, iterable):\n    \"\"\"\n    Apply func to each element of iterable.\n    Return a list of results.\n\n    Args:\n        func: A function to apply\n        iterable: An iterable of elements\n    Returns:\n        List of transformed elements\n    \"\"\"\n    # Your implementation here (no using built-in map)\n    pass",
    "solution": "def my_map(func, iterable):\n    result = []\n    for item in iterable:\n        result.append(func(item))\n    return result",
    "testCases": [
      {
        "input": "my_map(lambda x: x * 2, [1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_map(str.upper, [\"a\", \"b\"])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_map(lambda x: x, [])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Iterate through each element",
      "Apply the function to each element",
      "Collect results in a list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Filter Implementation",
    "difficulty": 1,
    "description": "Implement the filter higher-order function from scratch.",
    "starterCode": "def my_filter(predicate, iterable):\n    \"\"\"\n    Keep only elements where predicate returns True.\n\n    Args:\n        predicate: A function returning bool\n        iterable: An iterable of elements\n    Returns:\n        List of elements satisfying predicate\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def my_filter(predicate, iterable):\n    result = []\n    for item in iterable:\n        if predicate(item):\n            result.append(item)\n    return result",
    "testCases": [
      {
        "input": "my_filter(lambda x: x > 0, [-1, 0, 1, 2])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_filter(lambda x: x % 2 == 0, [1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_filter(lambda x: True, [])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Test each element with the predicate",
      "Only include elements where predicate returns True",
      "Handle empty iterables"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Reduce Implementation",
    "difficulty": 1,
    "description": "Implement the reduce (fold) higher-order function.",
    "starterCode": "def my_reduce(func, iterable, initial=None):\n    \"\"\"\n    Reduce iterable to single value by applying func cumulatively.\n\n    Args:\n        func: Function taking (accumulator, element) -> new_accumulator\n        iterable: An iterable of elements\n        initial: Optional initial value\n    Returns:\n        Final accumulated value\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def my_reduce(func, iterable, initial=None):\n    it = iter(iterable)\n    if initial is None:\n        try:\n            accumulator = next(it)\n        except StopIteration:\n            raise TypeError(\"reduce of empty sequence with no initial value\")\n    else:\n        accumulator = initial\n\n    for item in it:\n        accumulator = func(accumulator, item)\n    return accumulator",
    "testCases": [
      {
        "input": "my_reduce(lambda a, b: a + b, [1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_reduce(lambda a, b: a * b, [1, 2, 3, 4], 1)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "my_reduce(lambda a, b: a + b, [], 0)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Start with initial value (or first element if not provided)",
      "Apply func to accumulator and each element",
      "Handle empty sequences"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-4",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Function Composition",
    "difficulty": 1,
    "description": "Compose multiple functions into a single function.",
    "starterCode": "def compose(*funcs):\n    \"\"\"\n    Compose multiple functions right-to-left.\n    compose(f, g, h)(x) = f(g(h(x)))\n\n    Args:\n        *funcs: Variable number of functions\n    Returns:\n        A single composed function\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def compose(*funcs):\n    def composed(x):\n        result = x\n        for func in reversed(funcs):\n            result = func(result)\n        return result\n    return composed",
    "testCases": [
      {
        "input": "compose(lambda x: x + 1, lambda x: x * 2)(3)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose(str, abs, int)(\"-5\")",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "compose()(5)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Apply functions from right to left",
      "Use reversed() to iterate in correct order",
      "Handle empty function list (identity)"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-5",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Partial Application",
    "difficulty": 3,
    "description": "Implement partial function application.",
    "starterCode": "def partial(func, *args, **kwargs):\n    \"\"\"\n    Return a new function with some arguments pre-filled.\n\n    Args:\n        func: The function to partially apply\n        *args: Positional arguments to pre-fill\n        **kwargs: Keyword arguments to pre-fill\n    Returns:\n        A new function with fewer required arguments\n    \"\"\"\n    # Your implementation here\n    pass",
    "solution": "def partial(func, *args, **kwargs):\n    def wrapper(*more_args, **more_kwargs):\n        all_kwargs = {**kwargs, **more_kwargs}\n        return func(*args, *more_args, **all_kwargs)\n    return wrapper",
    "testCases": [
      {
        "input": "partial(pow, 2)(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "partial('{} {}'.format, 'Hello')('World')",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "partial(lambda x, y, z: x + y + z, 1, 2)(3)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Store the pre-filled arguments",
      "Return a function that accepts remaining arguments",
      "Combine pre-filled and new arguments"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-6",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Memoization Decorator",
    "difficulty": 3,
    "description": "Implement a memoization decorator for caching function results.",
    "starterCode": "def memoize(func):\n    \"\"\"\n    Cache function results based on arguments.\n    Return cached result for repeated calls with same arguments.\n\n    Args:\n        func: The function to memoize\n    Returns:\n        A memoized version of the function\n    \"\"\"\n    # Your implementation here\n    pass\n\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)",
    "solution": "def memoize(func):\n    cache = {}\n\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)",
    "testCases": [
      {
        "input": "fibonacci(10)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci(20)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci(0)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use a dictionary to store cached results",
      "Use arguments as cache keys",
      "Check cache before calling function"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-7",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Recursive List Operations",
    "difficulty": 3,
    "description": "Implement list operations using recursion only.",
    "starterCode": "def length(lst):\n    \"\"\"Return length of list using recursion.\"\"\"\n    # Your implementation here\n    pass\n\ndef reverse(lst):\n    \"\"\"Return reversed list using recursion.\"\"\"\n    # Your implementation here\n    pass\n\ndef flatten(lst):\n    \"\"\"Flatten nested lists using recursion.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "def length(lst):\n    if not lst:\n        return 0\n    return 1 + length(lst[1:])\n\ndef reverse(lst):\n    if not lst:\n        return []\n    return reverse(lst[1:]) + [lst[0]]\n\ndef flatten(lst):\n    if not lst:\n        return []\n    first, rest = lst[0], lst[1:]\n    if isinstance(first, list):\n        return flatten(first) + flatten(rest)\n    return [first] + flatten(rest)",
    "testCases": [
      {
        "input": "length([1, 2, 3, 4, 5])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "reverse([1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "flatten([1, [2, [3, 4]], 5])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Base case: empty list",
      "Recursive case: process first element, recurse on rest",
      "For flatten, check if element is a list"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-8",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Lazy Evaluation with Generators",
    "difficulty": 3,
    "description": "Implement lazy operations using Python generators.",
    "starterCode": "def lazy_map(func, iterable):\n    \"\"\"Lazy version of map using a generator.\"\"\"\n    # Your implementation here\n    pass\n\ndef lazy_filter(predicate, iterable):\n    \"\"\"Lazy version of filter using a generator.\"\"\"\n    # Your implementation here\n    pass\n\ndef take(n, iterable):\n    \"\"\"Take first n elements from an iterable.\"\"\"\n    # Your implementation here\n    pass\n\ndef infinite_counter(start=0):\n    \"\"\"Generate infinite sequence of integers.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "def lazy_map(func, iterable):\n    for item in iterable:\n        yield func(item)\n\ndef lazy_filter(predicate, iterable):\n    for item in iterable:\n        if predicate(item):\n            yield item\n\ndef take(n, iterable):\n    for i, item in enumerate(iterable):\n        if i >= n:\n            break\n        yield item\n\ndef infinite_counter(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1",
    "testCases": [
      {
        "input": "list(lazy_map(lambda x: x*2, [1,2,3]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list(lazy_filter(lambda x: x>0, [-1,0,1,2]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list(take(5, infinite_counter()))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Use yield to create generators",
      "Generators evaluate lazily on demand",
      "Take should work with infinite sequences"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-9",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Fold-Based Implementations",
    "difficulty": 3,
    "description": "Implement common operations using fold/reduce.",
    "starterCode": "from functools import reduce\n\ndef sum_fold(numbers):\n    \"\"\"Implement sum using reduce.\"\"\"\n    pass\n\ndef product_fold(numbers):\n    \"\"\"Implement product using reduce.\"\"\"\n    pass\n\ndef max_fold(numbers):\n    \"\"\"Implement max using reduce.\"\"\"\n    pass\n\ndef map_fold(func, lst):\n    \"\"\"Implement map using reduce.\"\"\"\n    pass\n\ndef filter_fold(predicate, lst):\n    \"\"\"Implement filter using reduce.\"\"\"\n    pass",
    "solution": "from functools import reduce\n\ndef sum_fold(numbers):\n    return reduce(lambda acc, x: acc + x, numbers, 0)\n\ndef product_fold(numbers):\n    return reduce(lambda acc, x: acc * x, numbers, 1)\n\ndef max_fold(numbers):\n    if not numbers:\n        raise ValueError(\"max of empty sequence\")\n    return reduce(lambda acc, x: x if x > acc else acc, numbers)\n\ndef map_fold(func, lst):\n    return reduce(lambda acc, x: acc + [func(x)], lst, [])\n\ndef filter_fold(predicate, lst):\n    return reduce(lambda acc, x: acc + [x] if predicate(x) else acc, lst, [])",
    "testCases": [
      {
        "input": "sum_fold([1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "product_fold([1, 2, 3, 4])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "max_fold([3, 1, 4, 1, 5])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "map_fold(lambda x: x*2, [1, 2, 3])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "reduce combines elements with an accumulator",
      "Choose appropriate initial values",
      "Build lists by appending to accumulator"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-10",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Immutable Data Updates",
    "difficulty": 3,
    "description": "Work with immutable data structures functionally.",
    "starterCode": "from typing import NamedTuple, List\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n\ndef update_age(person: Person, new_age: int) -> Person:\n    \"\"\"Return new Person with updated age.\"\"\"\n    pass\n\ndef add_year_to_all(people: List[Person]) -> List[Person]:\n    \"\"\"Return new list with everyone aged by 1 year.\"\"\"\n    pass\n\ndef get_adults(people: List[Person]) -> List[Person]:\n    \"\"\"Return new list containing only adults (age >= 18).\"\"\"\n    pass\n\ndef average_age(people: List[Person]) -> float:\n    \"\"\"Calculate average age without mutation.\"\"\"\n    pass",
    "solution": "from typing import NamedTuple, List\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n\ndef update_age(person: Person, new_age: int) -> Person:\n    return Person(person.name, new_age)\n\ndef add_year_to_all(people: List[Person]) -> List[Person]:\n    return [Person(p.name, p.age + 1) for p in people]\n\ndef get_adults(people: List[Person]) -> List[Person]:\n    return [p for p in people if p.age >= 18]\n\ndef average_age(people: List[Person]) -> float:\n    if not people:\n        return 0.0\n    return sum(p.age for p in people) / len(people)",
    "testCases": [
      {
        "input": "update_age(Person('Alice', 30), 31).age",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "add_year_to_all([Person('A', 10), Person('B', 20)])[0].age",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "len(get_adults([Person('A', 17), Person('B', 18)]))",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "NamedTuple is immutable by default",
      "Create new instances instead of modifying",
      "Use list comprehensions for transformations"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-11",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Functor Pattern",
    "difficulty": 5,
    "description": "Implement the Functor pattern (mappable containers).",
    "starterCode": "from abc import ABC, abstractmethod\nfrom typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Functor(ABC, Generic[A]):\n    \"\"\"Abstract base class for functors.\"\"\"\n\n    @abstractmethod\n    def map(self, func: Callable[[A], B]) -> 'Functor[B]':\n        \"\"\"Apply function inside the context.\"\"\"\n        pass\n\nclass Maybe(Functor[A]):\n    \"\"\"Maybe functor for optional values.\"\"\"\n\n    def __init__(self, value: A = None, is_nothing: bool = False):\n        pass\n\n    def map(self, func: Callable[[A], B]) -> 'Maybe[B]':\n        pass\n\n    def get_or_else(self, default: A) -> A:\n        pass\n\nclass List(Functor[A]):\n    \"\"\"List as a functor.\"\"\"\n\n    def __init__(self, values: list):\n        pass\n\n    def map(self, func: Callable[[A], B]) -> 'List[B]':\n        pass\n\ndef Just(value: A) -> Maybe[A]:\n    pass\n\ndef Nothing() -> Maybe:\n    pass",
    "solution": "from abc import ABC, abstractmethod\nfrom typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Functor(ABC, Generic[A]):\n    @abstractmethod\n    def map(self, func: Callable[[A], B]) -> 'Functor[B]':\n        pass\n\nclass Maybe(Functor[A]):\n    def __init__(self, value: A = None, is_nothing: bool = False):\n        self._value = value\n        self._is_nothing = is_nothing or (value is None and not is_nothing)\n\n    def map(self, func: Callable[[A], B]) -> 'Maybe[B]':\n        if self._is_nothing:\n            return Maybe(None, is_nothing=True)\n        return Maybe(func(self._value))\n\n    def get_or_else(self, default: A) -> A:\n        return default if self._is_nothing else self._value\n\nclass List(Functor[A]):\n    def __init__(self, values: list):\n        self._values = values\n\n    def map(self, func: Callable[[A], B]) -> 'List[B]':\n        return List([func(x) for x in self._values])\n\ndef Just(value: A) -> Maybe[A]:\n    return Maybe(value, is_nothing=False)\n\ndef Nothing() -> Maybe:\n    return Maybe(None, is_nothing=True)",
    "testCases": [
      {
        "input": "Just(5).map(lambda x: x * 2).get_or_else(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Nothing().map(lambda x: x * 2).get_or_else(0)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "List([1,2,3]).map(lambda x: x*2)._values",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Functor provides map to transform contained values",
      "Maybe handles the case of missing values",
      "Map should preserve the container structure"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-12",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Monad Pattern",
    "difficulty": 5,
    "description": "Implement the Monad pattern (flatMappable containers).",
    "starterCode": "from typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Monad(Generic[A]):\n    \"\"\"Abstract monad with unit and flatMap.\"\"\"\n\n    @staticmethod\n    def unit(value: A) -> 'Monad[A]':\n        \"\"\"Wrap value in monad context.\"\"\"\n        raise NotImplementedError\n\n    def flat_map(self, func: Callable[[A], 'Monad[B]']) -> 'Monad[B]':\n        \"\"\"Apply function and flatten result.\"\"\"\n        raise NotImplementedError\n\nclass Result(Monad[A]):\n    \"\"\"Result monad for error handling.\"\"\"\n\n    def __init__(self, value: A = None, error: str = None):\n        pass\n\n    @staticmethod\n    def success(value: A) -> 'Result[A]':\n        pass\n\n    @staticmethod\n    def failure(error: str) -> 'Result':\n        pass\n\n    def flat_map(self, func: Callable[[A], 'Result[B]']) -> 'Result[B]':\n        pass\n\n    def map(self, func: Callable[[A], B]) -> 'Result[B]':\n        \"\"\"Map for convenience.\"\"\"\n        pass\n\n    def get_or_raise(self) -> A:\n        pass",
    "solution": "from typing import TypeVar, Generic, Callable\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Monad(Generic[A]):\n    @staticmethod\n    def unit(value: A) -> 'Monad[A]':\n        raise NotImplementedError\n\n    def flat_map(self, func: Callable[[A], 'Monad[B]']) -> 'Monad[B]':\n        raise NotImplementedError\n\nclass Result(Monad[A]):\n    def __init__(self, value: A = None, error: str = None):\n        self._value = value\n        self._error = error\n\n    @staticmethod\n    def success(value: A) -> 'Result[A]':\n        return Result(value=value)\n\n    @staticmethod\n    def failure(error: str) -> 'Result':\n        return Result(error=error)\n\n    def flat_map(self, func: Callable[[A], 'Result[B]']) -> 'Result[B]':\n        if self._error:\n            return Result.failure(self._error)\n        return func(self._value)\n\n    def map(self, func: Callable[[A], B]) -> 'Result[B]':\n        return self.flat_map(lambda x: Result.success(func(x)))\n\n    def get_or_raise(self) -> A:\n        if self._error:\n            raise Exception(self._error)\n        return self._value",
    "testCases": [
      {
        "input": "Result.success(5).map(lambda x: x*2).get_or_raise()",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Result.failure('error').map(lambda x: x*2)._error",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "Result.success(5).flat_map(lambda x: Result.success(x+1)).get_or_raise()",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Monad adds flatMap to Functor",
      "flatMap chains operations that return monads",
      "Errors should propagate through the chain"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-13",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Continuation Passing Style",
    "difficulty": 5,
    "description": "Convert functions to continuation passing style (CPS).",
    "starterCode": "def factorial_cps(n, continuation):\n    \"\"\"\n    Factorial in continuation passing style.\n    Instead of returning, pass result to continuation.\n\n    Args:\n        n: Number to compute factorial of\n        continuation: Function to call with result\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef fibonacci_cps(n, continuation):\n    \"\"\"Fibonacci in CPS.\"\"\"\n    # Your implementation here\n    pass\n\ndef map_cps(func, lst, continuation):\n    \"\"\"Map in CPS.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "def factorial_cps(n, continuation):\n    if n <= 1:\n        return continuation(1)\n    return factorial_cps(n - 1, lambda result: continuation(n * result))\n\ndef fibonacci_cps(n, continuation):\n    if n <= 1:\n        return continuation(n)\n    return fibonacci_cps(n - 1, lambda a:\n        fibonacci_cps(n - 2, lambda b:\n            continuation(a + b)))\n\ndef map_cps(func, lst, continuation):\n    if not lst:\n        return continuation([])\n    return map_cps(func, lst[1:], lambda rest:\n        continuation([func(lst[0])] + rest))",
    "testCases": [
      {
        "input": "factorial_cps(5, lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "fibonacci_cps(10, lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "map_cps(lambda x: x*2, [1,2,3], lambda x: x)",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "CPS passes computation forward via continuations",
      "Base case calls continuation with result",
      "Recursive case wraps continuation with more computation"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-14",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Trampolined Recursion",
    "difficulty": 5,
    "description": "Implement trampolining for stack-safe recursion.",
    "starterCode": "class Thunk:\n    \"\"\"Delayed computation for trampolining.\"\"\"\n\n    def __init__(self, func, *args):\n        pass\n\n    def evaluate(self):\n        \"\"\"Execute the delayed computation.\"\"\"\n        pass\n\ndef trampoline(thunk_or_value):\n    \"\"\"\n    Execute thunks until we get a final value.\n    Enables stack-safe recursion.\n    \"\"\"\n    # Your implementation here\n    pass\n\ndef factorial_trampolined(n, acc=1):\n    \"\"\"Stack-safe factorial using trampolining.\"\"\"\n    # Your implementation here\n    pass\n\ndef sum_list_trampolined(lst, acc=0):\n    \"\"\"Stack-safe list sum using trampolining.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "class Thunk:\n    def __init__(self, func, *args):\n        self.func = func\n        self.args = args\n\n    def evaluate(self):\n        return self.func(*self.args)\n\ndef trampoline(thunk_or_value):\n    while isinstance(thunk_or_value, Thunk):\n        thunk_or_value = thunk_or_value.evaluate()\n    return thunk_or_value\n\ndef factorial_trampolined(n, acc=1):\n    if n <= 1:\n        return acc\n    return Thunk(factorial_trampolined, n - 1, acc * n)\n\ndef sum_list_trampolined(lst, acc=0):\n    if not lst:\n        return acc\n    return Thunk(sum_list_trampolined, lst[1:], acc + lst[0])",
    "testCases": [
      {
        "input": "trampoline(factorial_trampolined(10))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "trampoline(sum_list_trampolined([1,2,3,4,5]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "trampoline(factorial_trampolined(100)) > 0",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Thunk wraps a delayed function call",
      "Trampoline loops until non-Thunk value",
      "Return Thunk instead of recursive call"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-15",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Algebraic Data Types",
    "difficulty": 5,
    "description": "Implement algebraic data types and pattern matching.",
    "starterCode": "from typing import TypeVar, Generic, Callable, Union\n\nA = TypeVar('A')\n\nclass List:\n    \"\"\"Algebraic list: either Nil or Cons(head, tail).\"\"\"\n    pass\n\nclass Nil(List):\n    \"\"\"Empty list constructor.\"\"\"\n    pass\n\nclass Cons(List):\n    \"\"\"Non-empty list: head element and tail list.\"\"\"\n\n    def __init__(self, head, tail: List):\n        pass\n\ndef match_list(lst: List, nil_case: Callable, cons_case: Callable):\n    \"\"\"Pattern match on list structure.\"\"\"\n    # Your implementation here\n    pass\n\ndef list_length(lst: List) -> int:\n    \"\"\"Calculate length using pattern matching.\"\"\"\n    # Your implementation here\n    pass\n\ndef list_map(func: Callable, lst: List) -> List:\n    \"\"\"Map function over list using pattern matching.\"\"\"\n    # Your implementation here\n    pass\n\ndef to_python_list(lst: List) -> list:\n    \"\"\"Convert algebraic list to Python list.\"\"\"\n    # Your implementation here\n    pass\n\ndef from_python_list(py_list: list) -> List:\n    \"\"\"Convert Python list to algebraic list.\"\"\"\n    # Your implementation here\n    pass",
    "solution": "from typing import TypeVar, Callable\n\nclass List:\n    pass\n\nclass Nil(List):\n    pass\n\nclass Cons(List):\n    def __init__(self, head, tail: List):\n        self.head = head\n        self.tail = tail\n\ndef match_list(lst: List, nil_case: Callable, cons_case: Callable):\n    if isinstance(lst, Nil):\n        return nil_case()\n    elif isinstance(lst, Cons):\n        return cons_case(lst.head, lst.tail)\n    raise TypeError(\"Expected List type\")\n\ndef list_length(lst: List) -> int:\n    return match_list(lst,\n        lambda: 0,\n        lambda h, t: 1 + list_length(t))\n\ndef list_map(func: Callable, lst: List) -> List:\n    return match_list(lst,\n        lambda: Nil(),\n        lambda h, t: Cons(func(h), list_map(func, t)))\n\ndef to_python_list(lst: List) -> list:\n    return match_list(lst,\n        lambda: [],\n        lambda h, t: [h] + to_python_list(t))\n\ndef from_python_list(py_list: list) -> List:\n    if not py_list:\n        return Nil()\n    return Cons(py_list[0], from_python_list(py_list[1:]))",
    "testCases": [
      {
        "input": "list_length(from_python_list([1,2,3]))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "to_python_list(list_map(lambda x: x*2, from_python_list([1,2,3])))",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "list_length(Nil())",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "ADTs have multiple constructors (Nil, Cons)",
      "Pattern matching dispatches based on constructor",
      "Use isinstance to determine which case"
    ],
    "language": "python"
  },
  {
    "id": "cs303-ex-3-16",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Free Monad",
    "difficulty": 5,
    "description": "Implement a simple Free Monad for DSL interpretation.",
    "starterCode": "from typing import TypeVar, Generic, Callable, List as PyList\nfrom abc import ABC, abstractmethod\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Free(ABC, Generic[A]):\n    \"\"\"Free monad for building DSLs.\"\"\"\n\n    @abstractmethod\n    def flat_map(self, func: Callable[[A], 'Free[B]']) -> 'Free[B]':\n        pass\n\nclass Pure(Free[A]):\n    \"\"\"Pure value in the free monad.\"\"\"\n\n    def __init__(self, value: A):\n        pass\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        pass\n\nclass Suspend(Free[A]):\n    \"\"\"Suspended computation.\"\"\"\n\n    def __init__(self, instruction, next_func: Callable):\n        pass\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        pass\n\n# Console DSL instructions\nclass Print:\n    def __init__(self, message: str):\n        self.message = message\n\nclass Read:\n    pass\n\ndef print_line(message: str) -> Free[None]:\n    \"\"\"DSL instruction to print.\"\"\"\n    pass\n\ndef read_line() -> Free[str]:\n    \"\"\"DSL instruction to read.\"\"\"\n    pass\n\ndef interpret_console(program: Free, inputs: PyList[str]) -> tuple:\n    \"\"\"\n    Interpret console DSL, returning (outputs, final_value).\n    \"\"\"\n    pass",
    "solution": "from typing import TypeVar, Generic, Callable, List as PyList\n\nA = TypeVar('A')\nB = TypeVar('B')\n\nclass Free(Generic[A]):\n    def flat_map(self, func: Callable[[A], 'Free[B]']) -> 'Free[B]':\n        raise NotImplementedError\n\nclass Pure(Free[A]):\n    def __init__(self, value: A):\n        self.value = value\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        return func(self.value)\n\nclass Suspend(Free[A]):\n    def __init__(self, instruction, next_func: Callable):\n        self.instruction = instruction\n        self.next_func = next_func\n\n    def flat_map(self, func: Callable[[A], Free[B]]) -> Free[B]:\n        return Suspend(self.instruction,\n            lambda x: self.next_func(x).flat_map(func))\n\nclass Print:\n    def __init__(self, message: str):\n        self.message = message\n\nclass Read:\n    pass\n\ndef print_line(message: str) -> Free[None]:\n    return Suspend(Print(message), lambda _: Pure(None))\n\ndef read_line() -> Free[str]:\n    return Suspend(Read(), lambda x: Pure(x))\n\ndef interpret_console(program: Free, inputs: PyList[str]) -> tuple:\n    outputs = []\n    input_idx = 0\n\n    while isinstance(program, Suspend):\n        inst = program.instruction\n        if isinstance(inst, Print):\n            outputs.append(inst.message)\n            program = program.next_func(None)\n        elif isinstance(inst, Read):\n            if input_idx < len(inputs):\n                value = inputs[input_idx]\n                input_idx += 1\n            else:\n                value = \"\"\n            program = program.next_func(value)\n\n    return (outputs, program.value if isinstance(program, Pure) else None)",
    "testCases": [
      {
        "input": "interpret_console(print_line(\"Hi\"), [])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "interpret_console(read_line(), [\"test\"])",
        "isHidden": false,
        "description": "Test case"
      },
      {
        "input": "interpret_console(print_line(\"A\").flat_map(lambda _: print_line(\"B\")), [])",
        "isHidden": false,
        "description": "Test case"
      }
    ],
    "hints": [
      "Free monad separates program structure from interpretation",
      "Pure wraps final values",
      "Suspend captures instructions with continuations"
    ],
    "language": "python"
  }
]

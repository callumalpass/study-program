[
  {
    "id": "cs303-t3-quiz-1",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "FP Fundamentals",
    "questions": [
      {
        "id": "cs303-t3-q1-1",
        "type": "multiple_choice",
        "prompt": "What is a pure function?",
        "options": [
          "A function without bugs",
          "A function that always returns the same output for the same input and has no side effects",
          "A function with no parameters",
          "A function that never fails"
        ],
        "correctAnswer": 1,
        "explanation": "Pure functions are deterministic (same input → same output) and have no observable side effects."
      },
      {
        "id": "cs303-t3-q1-2",
        "type": "multiple_choice",
        "prompt": "What does immutability mean?",
        "options": [
          "Cannot be copied",
          "Cannot be moved",
          "Data cannot be changed after creation",
          "Cannot be deleted"
        ],
        "correctAnswer": 2,
        "explanation": "Immutability means once data is created, it cannot be modified. New data structures are created instead."
      },
      {
        "id": "cs303-t3-q1-3",
        "type": "multiple_choice",
        "prompt": "What is a higher-order function?",
        "options": [
          "A function in a higher directory",
          "A more important function",
          "A function that takes functions as arguments or returns functions",
          "A recursive function"
        ],
        "correctAnswer": 2,
        "explanation": "Higher-order functions can accept functions as parameters and/or return functions as results."
      },
      {
        "id": "cs303-t3-q1-4",
        "type": "multiple_choice",
        "prompt": "What does map do?",
        "options": [
          "Creates a geographic map",
          "Applies a function to each element of a collection",
          "Maps keys to values",
          "Reduces a collection"
        ],
        "correctAnswer": 1,
        "explanation": "Map applies a transformation function to each element of a collection, producing a new collection."
      },
      {
        "id": "cs303-t3-q1-5",
        "type": "multiple_choice",
        "prompt": "What is function composition?",
        "options": [
          "Combining functions so output of one becomes input of another",
          "Function documentation",
          "Writing functions",
          "Decomposing functions"
        ],
        "correctAnswer": 0,
        "explanation": "Function composition creates a new function by chaining functions: (f ∘ g)(x) = f(g(x))."
      }
    ]
  },
  {
    "id": "cs303-t3-quiz-2",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Advanced FP Concepts",
    "questions": [
      {
        "id": "cs303-t3-q2-1",
        "type": "multiple_choice",
        "prompt": "What is tail recursion?",
        "options": [
          "Infinite recursion",
          "Recursion at the end of a list",
          "Recursion where the recursive call is the last operation",
          "Recursion without a base case"
        ],
        "correctAnswer": 2,
        "explanation": "Tail recursion has the recursive call as the final operation, allowing compiler optimization to avoid stack growth."
      },
      {
        "id": "cs303-t3-q2-2",
        "type": "multiple_choice",
        "prompt": "What is a fold/reduce operation?",
        "options": [
          "Combining collection elements into a single value using a function",
          "Folding paper",
          "Reducing code size",
          "Compressing data"
        ],
        "correctAnswer": 0,
        "explanation": "Fold/reduce traverses a collection, combining elements into an accumulated result using a combining function."
      },
      {
        "id": "cs303-t3-q2-3",
        "type": "multiple_choice",
        "prompt": "In lambda calculus, what is β-reduction?",
        "options": [
          "Substituting arguments into function bodies",
          "Removing variables",
          "Reducing complexity",
          "Beta testing"
        ],
        "correctAnswer": 0,
        "explanation": "β-reduction applies a function by substituting the argument for the bound variable in the function body."
      },
      {
        "id": "cs303-t3-q2-4",
        "type": "multiple_choice",
        "prompt": "What is lazy evaluation?",
        "options": [
          "Slow evaluation",
          "Parallel evaluation",
          "Incomplete evaluation",
          "Delaying evaluation until the result is needed"
        ],
        "correctAnswer": 3,
        "explanation": "Lazy evaluation defers computation until the result is actually needed, enabling infinite data structures."
      },
      {
        "id": "cs303-t3-q2-5",
        "type": "multiple_choice",
        "prompt": "What is a thunk?",
        "options": [
          "A sound effect",
          "A type of error",
          "A suspended computation awaiting evaluation",
          "A memory block"
        ],
        "correctAnswer": 2,
        "explanation": "A thunk is a deferred computation that captures an expression and its environment for later evaluation."
      }
    ]
  },
  {
    "id": "cs303-t3-quiz-3",
    "subjectId": "cs303",
    "topicId": "cs303-topic-3",
    "title": "Monads and Functors",
    "questions": [
      {
        "id": "cs303-t3-q3-1",
        "type": "multiple_choice",
        "prompt": "What is a Functor in functional programming?",
        "options": [
          "A type that can be mapped over",
          "A debugging tool",
          "A function factory",
          "A type of function"
        ],
        "correctAnswer": 0,
        "explanation": "A Functor is a type with a map operation that applies a function to values inside a context."
      },
      {
        "id": "cs303-t3-q3-2",
        "type": "multiple_choice",
        "prompt": "What operations must a Monad support?",
        "options": [
          "get and set",
          "read and write",
          "map and filter",
          "return/unit and bind/flatMap"
        ],
        "correctAnswer": 3,
        "explanation": "Monads require return (wrap a value) and bind/flatMap (sequence computations that return wrapped values)."
      },
      {
        "id": "cs303-t3-q3-3",
        "type": "multiple_choice",
        "prompt": "What problem does the IO Monad solve in Haskell?",
        "options": [
          "Memory management",
          "Parallel I/O",
          "Sequencing side effects in a pure language",
          "File compression"
        ],
        "correctAnswer": 2,
        "explanation": "The IO Monad allows Haskell to sequence I/O operations while maintaining purity and referential transparency."
      },
      {
        "id": "cs303-t3-q3-4",
        "type": "multiple_choice",
        "prompt": "What is the difference between foldl and foldr?",
        "options": [
          "foldr is safer",
          "foldl is faster",
          "foldl processes left-to-right, foldr right-to-left",
          "No difference"
        ],
        "correctAnswer": 2,
        "explanation": "foldl accumulates from the left (beginning), foldr from the right (end), affecting associativity and laziness."
      },
      {
        "id": "cs303-t3-q3-5",
        "type": "multiple_choice",
        "prompt": "What is an Applicative Functor?",
        "options": [
          "A functor for applications",
          "A functor that allows applying wrapped functions to wrapped values",
          "A special kind of monad",
          "A debugging functor"
        ],
        "correctAnswer": 1,
        "explanation": "Applicative Functors extend Functors with the ability to apply functions inside a context to values inside a context."
      }
    ]
  }
]

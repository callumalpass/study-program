[
  {
    "id": "cs407-ex-2-1",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Missing Data Imputation",
    "description": "Write a function that imputes missing values in a pandas Series using the mean for numeric data or mode for categorical data.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef impute_missing(series):\n    # Return series with missing values filled\n    pass",
    "solution": "import pandas as pd\n\ndef impute_missing(series):\n    if pd.api.types.is_numeric_dtype(series):\n        return series.fillna(series.mean())\n    else:\n        return series.fillna(series.mode()[0] if not series.mode().empty else series.iloc[0])",
    "testCases": [
      {
        "input": "pd.Series([1, 2, None, 4])",
        "expectedOutput": "pd.Series([1.0, 2.0, 2.33, 4.0])",
        "isHidden": false,
        "description": "Numeric series with missing value"
      },
      {
        "input": "pd.Series([\"a\", \"b\", None, \"a\"])",
        "expectedOutput": "pd.Series([\"a\", \"b\", \"a\", \"a\"])",
        "isHidden": false,
        "description": "Categorical series with missing value"
      }
    ],
    "hints": [
      "Check if series is numeric using pd.api.types.is_numeric_dtype()",
      "Use .fillna() with .mean() for numeric data",
      "Use .fillna() with .mode()[0] for categorical data"
    ]
  },
  {
    "id": "cs407-ex-2-2",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Outlier Detection",
    "description": "Write a function that detects outliers using the IQR method. Return a boolean mask where True indicates an outlier.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef detect_outliers_iqr(series):\n    # Return boolean Series where True = outlier\n    pass",
    "solution": "import pandas as pd\n\ndef detect_outliers_iqr(series):\n    Q1 = series.quantile(0.25)\n    Q3 = series.quantile(0.75)\n    IQR = Q3 - Q1\n    lower_bound = Q1 - 1.5 * IQR\n    upper_bound = Q3 + 1.5 * IQR\n    return (series < lower_bound) | (series > upper_bound)",
    "testCases": [
      {
        "input": "pd.Series([1, 2, 3, 4, 5, 100])",
        "expectedOutput": "pd.Series([False, False, False, False, False, True])",
        "isHidden": false,
        "description": "Series with one outlier"
      }
    ],
    "hints": [
      "Calculate Q1 (25th percentile) and Q3 (75th percentile)",
      "IQR = Q3 - Q1",
      "Lower bound = Q1 - 1.5 * IQR, Upper bound = Q3 + 1.5 * IQR",
      "Return boolean mask for values outside bounds"
    ]
  },
  {
    "id": "cs407-ex-2-3",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Z-Score Outlier Detection",
    "description": "Write a function that detects outliers using z-scores. Mark values with |z-score| > threshold as outliers.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\nimport numpy as np\n\ndef detect_outliers_zscore(series, threshold=3):\n    # Return boolean Series where True = outlier\n    pass",
    "solution": "import pandas as pd\nimport numpy as np\n\ndef detect_outliers_zscore(series, threshold=3):\n    mean = series.mean()\n    std = series.std()\n    z_scores = np.abs((series - mean) / std)\n    return z_scores > threshold",
    "testCases": [
      {
        "input": "pd.Series([1, 2, 3, 4, 5, 100]), 3",
        "expectedOutput": "pd.Series([False, False, False, False, False, True])",
        "isHidden": false,
        "description": "Series with one extreme outlier"
      },
      {
        "input": "pd.Series([10, 12, 13, 12, 11, 13]), 2",
        "expectedOutput": "pd.Series([False, False, False, False, False, False])",
        "isHidden": false,
        "description": "Series with no outliers"
      }
    ],
    "hints": [
      "Calculate mean and standard deviation",
      "Compute z-score as (value - mean) / std",
      "Use np.abs() to get absolute values",
      "Return boolean mask where |z-score| > threshold"
    ]
  },
  {
    "id": "cs407-ex-2-4",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Remove Duplicate Rows",
    "description": "Write a function that removes duplicate rows from a DataFrame, keeping either the first or last occurrence.",
    "difficulty": 1,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef remove_duplicates(df, keep='first', subset=None):\n    # Return DataFrame with duplicates removed\n    pass",
    "solution": "import pandas as pd\n\ndef remove_duplicates(df, keep='first', subset=None):\n    return df.drop_duplicates(subset=subset, keep=keep)",
    "testCases": [
      {
        "input": "pd.DataFrame({\"a\": [1, 2, 1, 3], \"b\": [4, 5, 4, 6]}), \"first\"",
        "expectedOutput": "DataFrame with 3 rows (indices 0, 1, 3)",
        "isHidden": false,
        "description": "Remove duplicates keeping first"
      },
      {
        "input": "pd.DataFrame({\"a\": [1, 2, 1, 3], \"b\": [4, 5, 4, 6]}), \"last\"",
        "expectedOutput": "DataFrame with 3 rows (indices 1, 2, 3)",
        "isHidden": false,
        "description": "Remove duplicates keeping last"
      }
    ],
    "hints": [
      "Use df.drop_duplicates() method",
      "Pass keep parameter to control which duplicate to keep",
      "Use subset parameter to check specific columns"
    ]
  },
  {
    "id": "cs407-ex-2-5",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Forward Fill Missing Values",
    "description": "Write a function that fills missing values using forward fill (propagate last valid value forward).",
    "difficulty": 1,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef forward_fill_missing(series):\n    # Return series with forward fill applied\n    pass",
    "solution": "import pandas as pd\n\ndef forward_fill_missing(series):\n    return series.fillna(method='ffill')",
    "testCases": [
      {
        "input": "pd.Series([1, None, None, 4, None, 6])",
        "expectedOutput": "pd.Series([1.0, 1.0, 1.0, 4.0, 4.0, 6.0])",
        "isHidden": false,
        "description": "Series with missing values"
      },
      {
        "input": "pd.Series([None, 2, None, 4])",
        "expectedOutput": "pd.Series([NaN, 2.0, 2.0, 4.0])",
        "isHidden": false,
        "description": "Series starting with NaN"
      }
    ],
    "hints": [
      "Use .fillna() with method=\"ffill\"",
      "Forward fill propagates last valid value forward",
      "First value stays NaN if it starts with missing"
    ]
  },
  {
    "id": "cs407-ex-2-6",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Interpolate Missing Values",
    "description": "Write a function that interpolates missing numeric values using linear interpolation.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef interpolate_missing(series):\n    # Return series with linear interpolation applied\n    pass",
    "solution": "import pandas as pd\n\ndef interpolate_missing(series):\n    return series.interpolate(method='linear')",
    "testCases": [
      {
        "input": "pd.Series([1, None, None, 4])",
        "expectedOutput": "pd.Series([1.0, 2.0, 3.0, 4.0])",
        "isHidden": false,
        "description": "Linearly interpolate between 1 and 4"
      },
      {
        "input": "pd.Series([10, None, 30])",
        "expectedOutput": "pd.Series([10.0, 20.0, 30.0])",
        "isHidden": false,
        "description": "Interpolate middle value"
      }
    ],
    "hints": [
      "Use .interpolate() with method=\"linear\"",
      "Linear interpolation estimates values on a straight line",
      "Works best for numeric series with trend"
    ]
  },
  {
    "id": "cs407-ex-2-7",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Cap Outliers",
    "description": "Write a function that caps outliers to specified lower and upper percentiles (winsorization).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef cap_outliers(series, lower_percentile=5, upper_percentile=95):\n    # Return series with values capped to percentile bounds\n    pass",
    "solution": "import pandas as pd\n\ndef cap_outliers(series, lower_percentile=5, upper_percentile=95):\n    lower_bound = series.quantile(lower_percentile / 100)\n    upper_bound = series.quantile(upper_percentile / 100)\n    return series.clip(lower=lower_bound, upper=upper_bound)",
    "testCases": [
      {
        "input": "pd.Series([1, 2, 3, 4, 5, 100]), 10, 90",
        "expectedOutput": "pd.Series with 100 capped to 90th percentile value",
        "isHidden": false,
        "description": "Cap extreme values"
      }
    ],
    "hints": [
      "Calculate bounds using .quantile()",
      "Convert percentiles to fractions (divide by 100)",
      "Use .clip(lower=..., upper=...) to cap values",
      "Values outside bounds are set to nearest bound"
    ]
  },
  {
    "id": "cs407-ex-2-8",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Standardize Column Names",
    "description": "Write a function that standardizes DataFrame column names (lowercase, replace spaces with underscores, remove special chars).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\nimport re\n\ndef standardize_column_names(df):\n    # Return DataFrame with standardized column names\n    pass",
    "solution": "import pandas as pd\nimport re\n\ndef standardize_column_names(df):\n    df = df.copy()\n    df.columns = [re.sub(r'[^a-zA-Z0-9_]', '', col.lower().replace(' ', '_')) for col in df.columns]\n    return df",
    "testCases": [
      {
        "input": "pd.DataFrame({\"First Name\": [1], \"Last-Name\": [2], \"AGE!\": [3]})",
        "expectedOutput": "DataFrame with columns: first_name, last_name, age",
        "isHidden": false,
        "description": "Standardize various column name formats"
      }
    ],
    "hints": [
      "Convert to lowercase with .lower()",
      "Replace spaces with underscores using .replace()",
      "Remove special characters using re.sub()",
      "Apply transformation to df.columns"
    ]
  },
  {
    "id": "cs407-ex-2-9",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Remove Constant Columns",
    "description": "Write a function that removes columns from a DataFrame where all values are the same.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef remove_constant_columns(df):\n    # Return DataFrame with constant columns removed\n    pass",
    "solution": "import pandas as pd\n\ndef remove_constant_columns(df):\n    return df.loc[:, df.nunique() > 1]",
    "testCases": [
      {
        "input": "pd.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 5, 5], \"c\": [7, 8, 9]})",
        "expectedOutput": "DataFrame with only columns a and c",
        "isHidden": false,
        "description": "Remove column b with constant values"
      },
      {
        "input": "pd.DataFrame({\"x\": [1, 1, 1], \"y\": [2, 2, 2]})",
        "expectedOutput": "Empty DataFrame (all columns constant)",
        "isHidden": false,
        "description": "All columns are constant"
      }
    ],
    "hints": [
      "Use .nunique() to count unique values per column",
      "Filter columns where nunique() > 1",
      "Use .loc[:, condition] to select columns"
    ]
  },
  {
    "id": "cs407-ex-2-10",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Handle Mixed Data Types",
    "description": "Write a function that converts a column with mixed types to a consistent type (numeric or string).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef convert_to_consistent_type(series, target_type='numeric'):\n    # target_type can be 'numeric' or 'string'\n    # Return converted series, coerce errors to NaN for numeric\n    pass",
    "solution": "import pandas as pd\n\ndef convert_to_consistent_type(series, target_type='numeric'):\n    if target_type == 'numeric':\n        return pd.to_numeric(series, errors='coerce')\n    elif target_type == 'string':\n        return series.astype(str)\n    else:\n        return series",
    "testCases": [
      {
        "input": "pd.Series([1, \"2\", 3.5, \"invalid\"]), \"numeric\"",
        "expectedOutput": "pd.Series([1.0, 2.0, 3.5, NaN])",
        "isHidden": false,
        "description": "Convert mixed types to numeric"
      },
      {
        "input": "pd.Series([1, 2, 3]), \"string\"",
        "expectedOutput": "pd.Series([\"1\", \"2\", \"3\"])",
        "isHidden": false,
        "description": "Convert to strings"
      }
    ],
    "hints": [
      "Use pd.to_numeric() with errors=\"coerce\" for numeric conversion",
      "Use .astype(str) for string conversion",
      "Coerce converts invalid values to NaN"
    ]
  },
  {
    "id": "cs407-ex-2-11",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Normalize Text Data",
    "description": "Write a function that normalizes text in a Series (lowercase, trim whitespace, remove extra spaces).",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef normalize_text(series):\n    # Return series with normalized text\n    pass",
    "solution": "import pandas as pd\n\ndef normalize_text(series):\n    return series.str.strip().str.lower().str.replace(r'\\s+', ' ', regex=True)",
    "testCases": [
      {
        "input": "pd.Series([\"  Hello World  \", \"DATA  Science\", \"Python   \"])",
        "expectedOutput": "pd.Series([\"hello world\", \"data science\", \"python\"])",
        "isHidden": false,
        "description": "Normalize various text formats"
      }
    ],
    "hints": [
      "Use .str.strip() to remove leading/trailing whitespace",
      "Use .str.lower() to convert to lowercase",
      "Use .str.replace() with regex to collapse multiple spaces",
      "Chain string methods together"
    ]
  },
  {
    "id": "cs407-ex-2-12",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Drop High Missing Columns",
    "description": "Write a function that drops columns with missing value percentage above a threshold.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef drop_high_missing_columns(df, threshold=50):\n    # threshold is percentage (e.g., 50 means drop if >50% missing)\n    # Return DataFrame with high-missing columns removed\n    pass",
    "solution": "import pandas as pd\n\ndef drop_high_missing_columns(df, threshold=50):\n    missing_pct = (df.isnull().sum() / len(df)) * 100\n    cols_to_keep = missing_pct[missing_pct <= threshold].index\n    return df[cols_to_keep]",
    "testCases": [
      {
        "input": "pd.DataFrame({\"a\": [1, 2, None, None], \"b\": [1, None, 3, 4], \"c\": [1, 2, 3, 4]}), 50",
        "expectedOutput": "DataFrame with columns b and c only (column a has >50% missing)",
        "isHidden": false,
        "description": "Drop column with high missing rate"
      }
    ],
    "hints": [
      "Calculate missing percentage per column",
      "Divide missing count by total rows and multiply by 100",
      "Filter columns where percentage <= threshold",
      "Return DataFrame with selected columns"
    ]
  },
  {
    "id": "cs407-ex-2-13",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Parse Date Strings",
    "description": "Write a function that parses date strings in various formats to datetime objects.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef parse_dates(series, date_format=None):\n    # Try to parse dates, return datetime series or original if fails\n    pass",
    "solution": "import pandas as pd\n\ndef parse_dates(series, date_format=None):\n    try:\n        if date_format:\n            return pd.to_datetime(series, format=date_format, errors='coerce')\n        else:\n            return pd.to_datetime(series, infer_datetime_format=True, errors='coerce')\n    except Exception:\n        return series",
    "testCases": [
      {
        "input": "pd.Series([\"2023-01-15\", \"2023-02-20\", \"2023-03-25\"])",
        "expectedOutput": "Series of datetime objects",
        "isHidden": false,
        "description": "Parse ISO format dates"
      },
      {
        "input": "pd.Series([\"01/15/2023\", \"02/20/2023\"]), \"%m/%d/%Y\"",
        "expectedOutput": "Series of datetime objects",
        "isHidden": false,
        "description": "Parse with specific format"
      }
    ],
    "hints": [
      "Use pd.to_datetime() to parse dates",
      "Pass format parameter if specific format provided",
      "Use infer_datetime_format=True for automatic detection",
      "Use errors=\"coerce\" to handle invalid dates"
    ]
  },
  {
    "id": "cs407-ex-2-14",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Remove Outliers by IQR",
    "description": "Write a function that removes rows containing outliers detected by IQR method in any numeric column.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef remove_outliers_iqr(df):\n    # Return DataFrame with outlier rows removed\n    pass",
    "solution": "import pandas as pd\n\ndef remove_outliers_iqr(df):\n    df_numeric = df.select_dtypes(include=['number'])\n    outlier_mask = pd.Series([False] * len(df))\n\n    for col in df_numeric.columns:\n        Q1 = df[col].quantile(0.25)\n        Q3 = df[col].quantile(0.75)\n        IQR = Q3 - Q1\n        lower_bound = Q1 - 1.5 * IQR\n        upper_bound = Q3 + 1.5 * IQR\n        outlier_mask |= (df[col] < lower_bound) | (df[col] > upper_bound)\n\n    return df[~outlier_mask]",
    "testCases": [
      {
        "input": "pd.DataFrame({\"a\": [1, 2, 3, 100], \"b\": [10, 20, 30, 40]})",
        "expectedOutput": "DataFrame with outlier row removed",
        "isHidden": false,
        "description": "Remove row with outlier in column a"
      }
    ],
    "hints": [
      "Select numeric columns only",
      "For each numeric column, calculate IQR bounds",
      "Build boolean mask marking outlier rows",
      "Use OR operator to combine masks across columns",
      "Filter DataFrame to keep non-outlier rows"
    ]
  },
  {
    "id": "cs407-ex-2-15",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Fill Missing with Group Mean",
    "description": "Write a function that fills missing values in a column with the mean of its group.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "import pandas as pd\n\ndef fill_missing_with_group_mean(df, target_col, group_col):\n    # Fill missing values in target_col with mean of its group_col\n    # Return DataFrame with filled values\n    pass",
    "solution": "import pandas as pd\n\ndef fill_missing_with_group_mean(df, target_col, group_col):\n    df = df.copy()\n    df[target_col] = df.groupby(group_col)[target_col].transform(lambda x: x.fillna(x.mean()))\n    return df",
    "testCases": [
      {
        "input": "pd.DataFrame({\"group\": [\"A\", \"A\", \"B\", \"B\"], \"value\": [10, None, 20, None]}), \"value\", \"group\"",
        "expectedOutput": "DataFrame with value column: [10, 10, 20, 20]",
        "isHidden": false,
        "description": "Fill missing values with group means"
      }
    ],
    "hints": [
      "Use .groupby() to group by group_col",
      "Use .transform() to apply function within groups",
      "Fill missing with group mean using fillna(x.mean())",
      "Make a copy to avoid modifying original"
    ]
  },
  {
    "id": "cs407-ex-2-16",
    "subjectId": "cs407",
    "topicId": "cs407-t2",
    "title": "Clean Phone Numbers",
    "description": "Write a function that cleans phone number strings by removing non-digit characters and formatting consistently.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "import pandas as pd\nimport re\n\ndef clean_phone_numbers(series):\n    # Remove non-digits, format as XXX-XXX-XXXX (10 digits) or return original if invalid\n    pass",
    "solution": "import pandas as pd\nimport re\n\ndef clean_phone_numbers(series):\n    def format_phone(phone):\n        if pd.isna(phone):\n            return phone\n        digits = re.sub(r'\\D', '', str(phone))\n        if len(digits) == 10:\n            return f\"{digits[:3]}-{digits[3:6]}-{digits[6:]}\"\n        return phone\n\n    return series.apply(format_phone)",
    "testCases": [
      {
        "input": "pd.Series([\"(555) 123-4567\", \"555.123.4567\", \"5551234567\", \"123\"])",
        "expectedOutput": "pd.Series([\"555-123-4567\", \"555-123-4567\", \"555-123-4567\", \"123\"])",
        "isHidden": false,
        "description": "Clean various phone formats"
      }
    ],
    "hints": [
      "Use re.sub(r\"\\D\", \"\", str(phone)) to extract digits",
      "Check if exactly 10 digits",
      "Format as XXX-XXX-XXXX using string slicing",
      "Return original value if not 10 digits",
      "Use .apply() to process each value"
    ]
  }
]

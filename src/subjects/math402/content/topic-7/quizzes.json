[
  {
    "id": "math402-quiz-7a",
    "subjectId": "math402",
    "topicId": "math402-topic-7",
    "title": "Numerical Solutions of ODEs - Fundamentals",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Euler's method approximates y' = f(t,y) using:",
        "options": [
          "y_{n+1} = y_n + h·f(t_n, y_n)",
          "y_{n+1} = y_n + (h/2)·(f(t_n, y_n) + f(t_{n+1}, y_{n+1}))",
          "y_{n+1} = y_n + h·f(t_{n+1}, y_n)",
          "y_{n+1} = y_n + h^2·f(t_n, y_n)"
        ],
        "correctAnswer": 0,
        "explanation": "Euler's method uses forward difference: y_{n+1} = y_n + h·f(t_n, y_n). It's the simplest one-step method with local error O(h^2) and global error O(h)."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "The order of accuracy of Euler's method is:",
        "options": [
          "2",
          "1",
          "4",
          "3"
        ],
        "correctAnswer": 1,
        "explanation": "Euler's method has order 1: the global error is O(h). Each step introduces local truncation error O(h^2), but accumulating over O(1/h) steps gives O(h) global error."
      },
      {
        "id": "q3",
        "type": "code_output",
        "prompt": "What is the output after one Euler step?",
        "codeSnippet": "# Solve y' = y, y(0) = 1\ny = 1.0\nt = 0.0\nh = 0.1\nf = lambda t, y: y\ny_new = y + h * f(t, y)\nprint(f'{y_new:.2f}')",
        "correctAnswer": "1.10",
        "explanation": "Euler step: y_new = 1.0 + 0.1·f(0,1) = 1.0 + 0.1·1 = 1.10. Exact solution is e^0.1 ≈ 1.1052, so Euler underestimates."
      },
      {
        "id": "q4",
        "type": "true_false",
        "prompt": "The classical RK4 (fourth-order Runge-Kutta) method requires four function evaluations per step.",
        "correctAnswer": true,
        "explanation": "True. RK4 uses four stages (k1, k2, k3, k4) with specific weights, achieving fourth-order accuracy with four function evaluations per step."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The ____ method uses a weighted average of slopes at multiple points within the interval to improve accuracy.",
        "correctAnswer": "Runge-Kutta",
        "explanation": "Runge-Kutta methods evaluate f at multiple intermediate points to approximate higher-order Taylor terms without computing derivatives."
      }
    ]
  },
  {
    "id": "math402-quiz-7b",
    "subjectId": "math402",
    "topicId": "math402-topic-7",
    "title": "Numerical Solutions of ODEs - Application",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "The trapezoidal method (implicit Euler) for y' = f(t,y) is:",
        "options": [
          "y_{n+1} = y_n + (h/2)·[f(t_n, y_n) + f(t_{n+1}, y_{n+1})]",
          "y_{n+1} = y_n + h·f(t_{n+1}, y_{n+1})",
          "y_{n+1} = y_n + h·f(t_n, y_n)",
          "y_{n+1} = 2y_n - y_{n-1} + h^2·f(t_n, y_n)"
        ],
        "correctAnswer": 0,
        "explanation": "The trapezoidal (Crank-Nicolson) method averages slopes at t_n and t_{n+1}. It's implicit (requires solving for y_{n+1}), second-order accurate, and A-stable."
      },
      {
        "id": "q2",
        "type": "code_output",
        "prompt": "What does this RK2 (midpoint) method output?",
        "codeSnippet": "# Solve y' = -y, y(0) = 1\ny = 1.0\nt = 0.0\nh = 0.2\nf = lambda t, y: -y\nk1 = f(t, y)\nk2 = f(t + h/2, y + h/2 * k1)\ny_new = y + h * k2\nprint(f'{y_new:.4f}')",
        "correctAnswer": "0.8200",
        "explanation": "RK2 midpoint: k1 = f(0,1) = -1, k2 = f(0.1, 1+0.2/2·(-1)) = f(0.1, 0.9) = -0.9. y_new = 1 + 0.2·(-0.9) = 0.82."
      },
      {
        "id": "q3",
        "type": "multiple_choice",
        "prompt": "Multistep methods (like Adams-Bashforth) use:",
        "options": [
          "Random sampling points",
          "Only the current point y_n",
          "Values from multiple previous steps y_{n}, y_{n-1}, ...",
          "Multiple stages within a single step"
        ],
        "correctAnswer": 2,
        "explanation": "Multistep methods use values from k previous steps: y_{n+1} = Σ a_i y_{n-i} + h Σ b_i f(t_{n-i}, y_{n-i}). They achieve high order efficiently but require special starting procedures."
      },
      {
        "id": "q4",
        "type": "true_false",
        "prompt": "Implicit methods generally have better stability properties than explicit methods.",
        "correctAnswer": true,
        "explanation": "True. Implicit methods can be A-stable (stable for all h on Re(λ) < 0), making them superior for stiff problems where explicit methods require tiny h for stability despite accuracy needs."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "A stiff differential equation has multiple time scales with vastly different ____.",
        "correctAnswer": "rates",
        "explanation": "Stiffness arises when solutions have multiple components evolving at vastly different rates. Explicit methods become impractical (require tiny h for stability), but implicit methods handle stiffness well."
      }
    ]
  },
  {
    "id": "math402-quiz-7c",
    "subjectId": "math402",
    "topicId": "math402-topic-7",
    "title": "Numerical Solutions of ODEs - Mastery",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "A-stability for an ODE method means:",
        "options": [
          "The stability region contains the entire left half-plane Re(z) ≤ 0",
          "The method has high accuracy",
          "The method works for all ODEs",
          "The method is explicit"
        ],
        "correctAnswer": 0,
        "explanation": "A-stable methods have stability regions containing {z ∈ ℂ : Re(z) ≤ 0}, making them stable for all h on stiff problems (where λ has large negative real part). Backward Euler and trapezoidal method are A-stable."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "Adaptive step size control typically uses:",
        "options": [
          "Error estimates from comparing methods of different orders",
          "User-specified h",
          "Random step sizes",
          "Fixed reduction/increase of h"
        ],
        "correctAnswer": 0,
        "explanation": "Adaptive methods estimate local error (e.g., Richardson extrapolation or embedded RK pairs like RK45) and adjust h to maintain error within tolerance: h_new ≈ h(tol/error)^{1/(p+1)}."
      },
      {
        "id": "q3",
        "type": "code_output",
        "prompt": "What is the stability region boundary for forward Euler?",
        "codeSnippet": "import numpy as np\n# For y' = λy, forward Euler: y_{n+1} = y_n(1 + hλ)\n# Stable when |1 + z| <= 1 where z = hλ\n# At boundary: |1 + z| = 1\n# For real z: 1 + z = -1 or 1 + z = 1\nz_min = -2\nz_max = 0\nprint(f'{z_min},{z_max}')",
        "correctAnswer": "-2,0",
        "explanation": "Forward Euler stability: |1 + hλ| ≤ 1. For real λ: -1 ≤ 1 + hλ ≤ 1, so -2 ≤ hλ ≤ 0. The stability region is the disk centered at -1 with radius 1."
      },
      {
        "id": "q4",
        "type": "true_false",
        "prompt": "For stiff ODEs, implicit methods can use much larger step sizes than explicit methods while maintaining stability.",
        "correctAnswer": true,
        "explanation": "True. Explicit methods require h < 2/|λ_max| for stability on stiff problems, which can be very restrictive. A-stable implicit methods have no such restriction, allowing h to be chosen based on accuracy alone."
      },
      {
        "id": "q5",
        "type": "fill_blank",
        "prompt": "The shooting method converts a BVP into an ____ by guessing missing initial conditions.",
        "correctAnswer": "IVP",
        "explanation": "Shooting converts the BVP into an IVP by guessing unknown initial conditions, solving the IVP, and iterating (e.g., Newton's method) until boundary conditions are satisfied."
      }
    ]
  }
]

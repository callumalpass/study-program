[
  {
    "id": "cs203-midterm",
    "subjectId": "cs203",
    "title": "Theory of Computation Midterm Exam",
    "durationMinutes": 90,
    "instructions": [
      "Covers Topics 1-4: Finite Automata, Regular Languages, Context-Free Grammars, and Pushdown Automata.",
      "Answer all questions. Passing score is 70%.",
      "For multiple choice, select the single best answer."
    ],
    "questions": [
      {
        "id": "cs203-mid-q1",
        "type": "multiple_choice",
        "prompt": "A DFA has how many transitions from each state on each input symbol?",
        "options": [
          "Zero",
          "Exactly one",
          "At most one",
          "Any number"
        ],
        "correctAnswer": 1,
        "explanation": "A DFA (Deterministic Finite Automaton) has exactly one transition from each state on each input symbol. This determinism is what distinguishes it from an NFA."
      },
      {
        "id": "cs203-mid-q2",
        "type": "multiple_choice",
        "prompt": "The subset construction algorithm converts:",
        "options": [
          "NFA to DFA",
          "DFA to NFA",
          "NFA to regex",
          "DFA to PDA"
        ],
        "correctAnswer": 0,
        "explanation": "Subset construction converts an NFA to an equivalent DFA by creating states that represent sets of NFA states."
      },
      {
        "id": "cs203-mid-q3",
        "type": "multiple_choice",
        "prompt": "What is the worst-case state blowup when converting an n-state NFA to a DFA?",
        "options": [
          "n",
          "n²",
          "2ⁿ",
          "n!"
        ],
        "correctAnswer": 2,
        "explanation": "In the worst case, subset construction can produce 2ⁿ states since each DFA state corresponds to a subset of the n NFA states."
      },
      {
        "id": "cs203-mid-q4",
        "type": "multiple_choice",
        "prompt": "ε-transitions in an NFA allow the automaton to:",
        "options": [
          "Reject invalid inputs",
          "Accept the empty string only",
          "Loop indefinitely",
          "Change state without consuming input"
        ],
        "correctAnswer": 3,
        "explanation": "ε-transitions let an NFA move between states without reading any input symbol, increasing nondeterminism."
      },
      {
        "id": "cs203-mid-q5",
        "type": "multiple_choice",
        "prompt": "Two DFA states are equivalent (indistinguishable) if:",
        "options": [
          "They have the same incoming transitions",
          "No string distinguishes them (leads to accept from one, reject from other)",
          "They are both accepting or both non-accepting",
          "They have the same outgoing transitions"
        ],
        "correctAnswer": 1,
        "explanation": "States p and q are equivalent if for all strings w: δ*(p,w) ∈ F ⟺ δ*(q,w) ∈ F."
      },
      {
        "id": "cs203-mid-q6",
        "type": "multiple_choice",
        "prompt": "Which language is described by the regular expression (a|b)*abb?",
        "options": [
          "Strings ending with abb",
          "The string abb only",
          "Strings starting with abb",
          "Strings containing abb"
        ],
        "correctAnswer": 0,
        "explanation": "(a|b)* matches any string over {a,b}, and abb at the end requires strings to end with abb."
      },
      {
        "id": "cs203-mid-q7",
        "type": "multiple_choice",
        "prompt": "Which operation does NOT preserve regularity when applied to regular languages?",
        "options": [
          "Union",
          "Intersection",
          "Complement",
          "None - regular languages are closed under all of these"
        ],
        "correctAnswer": 3,
        "explanation": "Regular languages are closed under all Boolean operations: union, intersection, and complement, as well as concatenation and Kleene star."
      },
      {
        "id": "cs203-mid-q8",
        "type": "multiple_choice",
        "prompt": "The pumping lemma for regular languages is used to:",
        "options": [
          "Prove a language is regular",
          "Convert NFAs to DFAs",
          "Minimize DFAs",
          "Prove a language is not regular"
        ],
        "correctAnswer": 3,
        "explanation": "The pumping lemma provides a necessary condition for regularity. By showing a language violates it, we prove it is not regular."
      },
      {
        "id": "cs203-mid-q9",
        "type": "multiple_choice",
        "prompt": "Which of the following is NOT a regular language?",
        "options": [
          "All strings of even length",
          "Strings with equal a's and b's",
          "Strings containing \"ab\"",
          "All strings over {a,b}"
        ],
        "correctAnswer": 1,
        "explanation": "{w | #a(w) = #b(w)} requires counting, which finite automata cannot do. The pumping lemma proves this."
      },
      {
        "id": "cs203-mid-q10",
        "type": "multiple_choice",
        "prompt": "Thompson's construction produces what from a regular expression?",
        "options": [
          "NFA with ε-transitions",
          "Context-free grammar",
          "Parse tree",
          "Minimal DFA"
        ],
        "correctAnswer": 0,
        "explanation": "Thompson's construction recursively builds an NFA (typically with many ε-transitions) from a regular expression."
      },
      {
        "id": "cs203-mid-q11",
        "type": "multiple_choice",
        "prompt": "A context-free grammar consists of:",
        "options": [
          "States and transitions",
          "Variables, terminals, productions, start symbol",
          "Stack and input tape",
          "Regular expressions"
        ],
        "correctAnswer": 1,
        "explanation": "A CFG G = (V, Σ, R, S) has variables (non-terminals), terminals, production rules, and a start symbol."
      },
      {
        "id": "cs203-mid-q12",
        "type": "multiple_choice",
        "prompt": "A grammar is ambiguous if:",
        "options": [
          "It generates an infinite language",
          "It contains ε-productions",
          "It has more than one production",
          "Some string has multiple parse trees"
        ],
        "correctAnswer": 3,
        "explanation": "Ambiguity means at least one string has multiple distinct parse trees (or equivalently, multiple leftmost derivations)."
      },
      {
        "id": "cs203-mid-q13",
        "type": "multiple_choice",
        "prompt": "In Chomsky Normal Form, all productions have the form:",
        "options": [
          "A → aB | a",
          "A → Ba",
          "A → aBb",
          "A → BC | a (plus S → ε if needed)"
        ],
        "correctAnswer": 3,
        "explanation": "CNF requires productions of form A → BC (two variables) or A → a (single terminal), with optional S → ε."
      },
      {
        "id": "cs203-mid-q14",
        "type": "multiple_choice",
        "prompt": "Context-free languages are NOT closed under:",
        "options": [
          "Union",
          "Kleene star",
          "Concatenation",
          "Intersection"
        ],
        "correctAnswer": 3,
        "explanation": "CFLs are closed under union, concatenation, and Kleene star, but NOT under intersection or complement."
      },
      {
        "id": "cs203-mid-q15",
        "type": "multiple_choice",
        "prompt": "The CYK parsing algorithm requires the grammar to be in:",
        "options": [
          "Any form",
          "Greibach Normal Form",
          "Backus-Naur Form",
          "Chomsky Normal Form"
        ],
        "correctAnswer": 3,
        "explanation": "CYK uses dynamic programming based on binary branching, which relies on CNF structure."
      },
      {
        "id": "cs203-mid-q16",
        "type": "multiple_choice",
        "prompt": "A pushdown automaton extends a finite automaton with:",
        "options": [
          "A stack",
          "Two-way head movement",
          "Multiple tapes",
          "An oracle"
        ],
        "correctAnswer": 0,
        "explanation": "A PDA has a stack for auxiliary memory, enabling it to recognize context-free languages."
      },
      {
        "id": "cs203-mid-q17",
        "type": "multiple_choice",
        "prompt": "PDAs recognize exactly which class of languages?",
        "options": [
          "Context-free languages",
          "Context-sensitive languages",
          "Regular languages",
          "Recursively enumerable languages"
        ],
        "correctAnswer": 0,
        "explanation": "PDAs are equivalent to CFGs in power - they recognize exactly the context-free languages."
      },
      {
        "id": "cs203-mid-q18",
        "type": "multiple_choice",
        "prompt": "A deterministic PDA (DPDA) is:",
        "options": [
          "Equivalent to a Turing machine",
          "Strictly stronger than NPDA",
          "Strictly weaker than NPDA",
          "Equivalent in power to NPDA"
        ],
        "correctAnswer": 2,
        "explanation": "DPDAs are strictly weaker than NPDAs. Some CFLs (like palindromes) cannot be recognized by any DPDA."
      },
      {
        "id": "cs203-mid-q19",
        "type": "multiple_choice",
        "prompt": "For the language {wcwᴿ | w ∈ {a,b}*}, which is true?",
        "options": [
          "Regular",
          "Not context-free",
          "Context-free but not deterministic context-free",
          "Deterministic context-free"
        ],
        "correctAnswer": 3,
        "explanation": "The middle marker c tells the DPDA when to switch from pushing to popping, making it deterministic."
      },
      {
        "id": "cs203-mid-q20",
        "type": "multiple_choice",
        "prompt": "Acceptance by empty stack and acceptance by final state for PDAs are:",
        "options": [
          "Empty stack is stronger",
          "Final state is stronger",
          "Equivalent in power",
          "Incomparable in power"
        ],
        "correctAnswer": 2,
        "explanation": "Both acceptance modes define exactly the context-free languages. Any PDA can be converted between modes."
      },
      {
        "id": "cs203-mid-q21",
        "type": "multiple_choice",
        "prompt": "The language {aⁿbⁿ | n ≥ 0} is:",
        "options": [
          "Context-free but not regular",
          "Decidable but not context-free",
          "Not context-free",
          "Regular"
        ],
        "correctAnswer": 0,
        "explanation": "{aⁿbⁿ} is the classic example of a CFL that is not regular. It can be generated by S → aSb | ε."
      },
      {
        "id": "cs203-mid-q22",
        "type": "multiple_choice",
        "prompt": "The language {aⁿbⁿcⁿ | n ≥ 0} is:",
        "options": [
          "Context-sensitive but not context-free",
          "Not context-sensitive",
          "Context-free",
          "Regular"
        ],
        "correctAnswer": 0,
        "explanation": "{aⁿbⁿcⁿ} cannot be recognized by a PDA (pumping lemma for CFLs proves this) but is context-sensitive."
      },
      {
        "id": "cs203-mid-q23",
        "type": "multiple_choice",
        "prompt": "The Myhill-Nerode theorem provides:",
        "options": [
          "A proof that all finite languages are regular",
          "An algorithm for DFA minimization only",
          "A characterization of regular languages via equivalence classes",
          "A pumping condition for regularity"
        ],
        "correctAnswer": 2,
        "explanation": "Myhill-Nerode states L is regular iff the equivalence relation ≡_L has finitely many classes, and this number equals the minimum DFA states."
      },
      {
        "id": "cs203-mid-q24",
        "type": "multiple_choice",
        "prompt": "For CFGs, which problem is decidable?",
        "options": [
          "Is the grammar ambiguous?",
          "Does the grammar generate all strings?",
          "Does the grammar generate the empty language?",
          "Are two grammars equivalent?"
        ],
        "correctAnswer": 2,
        "explanation": "CFG emptiness is decidable (check if start symbol derives any terminal string). Ambiguity, universality, and equivalence are undecidable."
      },
      {
        "id": "cs203-mid-q25",
        "type": "multiple_choice",
        "prompt": "The pumping lemma for CFLs states that long strings can be written as:",
        "options": [
          "xyz with y pumpable",
          "abcde with b and d pumpable",
          "uvwxy with v and x pumpable",
          "uvxyz with v and y pumpable"
        ],
        "correctAnswer": 3,
        "explanation": "The CFL pumping lemma: s = uvxyz where |vy| > 0, |vxy| ≤ p, and uvⁱxyⁱz ∈ L for all i ≥ 0."
      },
      {
        "id": "cs203-mid-q26",
        "type": "multiple_choice",
        "prompt": "Which closure property do CFLs have that regular languages also have?",
        "options": [
          "Closure under complement",
          "Closure under intersection",
          "All of the above",
          "Closure under union"
        ],
        "correctAnswer": 3,
        "explanation": "Both regular languages and CFLs are closed under union. However, CFLs are not closed under intersection or complement (while regular languages are)."
      }
    ]
  },
  {
    "id": "cs203-final",
    "subjectId": "cs203",
    "title": "Theory of Computation Final Exam",
    "durationMinutes": 120,
    "instructions": [
      "Covers all topics with emphasis on Topics 5-7: Turing Machines, Decidability, and Computational Complexity.",
      "Answer all questions. Passing score is 70%.",
      "For multiple choice, select the single best answer."
    ],
    "questions": [
      {
        "id": "cs203-final-q1",
        "type": "multiple_choice",
        "prompt": "A Turing machine differs from a PDA primarily in having:",
        "options": [
          "Nondeterminism",
          "Multiple stacks",
          "A read/write tape with bidirectional head movement",
          "More states"
        ],
        "correctAnswer": 2,
        "explanation": "A TM has an infinite tape that can be read and written, with a head that moves both left and right."
      },
      {
        "id": "cs203-final-q2",
        "type": "multiple_choice",
        "prompt": "A language L is decidable if:",
        "options": [
          "Some TM accepts all strings in L",
          "Some TM accepts strings in L and rejects strings not in L (always halts)",
          "L is context-free",
          "L is finite"
        ],
        "correctAnswer": 1,
        "explanation": "Decidable (recursive) means there is a TM that accepts members, rejects non-members, and always halts."
      },
      {
        "id": "cs203-final-q3",
        "type": "multiple_choice",
        "prompt": "The Universal Turing Machine can:",
        "options": [
          "Simulate any other Turing machine",
          "Solve the halting problem",
          "Compute non-computable functions",
          "Run faster than any specific TM"
        ],
        "correctAnswer": 0,
        "explanation": "The UTM takes ⟨M, w⟩ as input and simulates M on w, making it a \"programmable computer.\""
      },
      {
        "id": "cs203-final-q4",
        "type": "multiple_choice",
        "prompt": "Nondeterministic Turing machines compared to deterministic TMs:",
        "options": [
          "Are strictly more powerful",
          "Recognize the same languages",
          "Are strictly weaker",
          "Are incomparable"
        ],
        "correctAnswer": 1,
        "explanation": "NTMs and DTMs are equivalent in power - they recognize the same languages (though NTMs may be faster)."
      },
      {
        "id": "cs203-final-q5",
        "type": "multiple_choice",
        "prompt": "The Church-Turing thesis states:",
        "options": [
          "All languages are decidable",
          "P = NP",
          "Every effectively computable function is Turing computable",
          "TMs are the fastest computation model"
        ],
        "correctAnswer": 2,
        "explanation": "The thesis asserts that TMs capture the intuitive notion of algorithm - anything we consider computable can be computed by a TM."
      },
      {
        "id": "cs203-final-q6",
        "type": "multiple_choice",
        "prompt": "Multi-tape Turing machines are:",
        "options": [
          "More powerful than single-tape TMs",
          "Equivalent to single-tape TMs",
          "Less powerful than single-tape TMs",
          "Only useful for specific problems"
        ],
        "correctAnswer": 1,
        "explanation": "Multi-tape TMs can be simulated by single-tape TMs with polynomial overhead. They recognize the same languages."
      },
      {
        "id": "cs203-final-q7",
        "type": "multiple_choice",
        "prompt": "The halting problem is:",
        "options": [
          "Undecidable but recognizable",
          "Not even recognizable",
          "Decidable",
          "Decidable for some TMs"
        ],
        "correctAnswer": 0,
        "explanation": "HALT is undecidable (proved by diagonalization) but Turing-recognizable (simulate and accept if TM halts)."
      },
      {
        "id": "cs203-final-q8",
        "type": "multiple_choice",
        "prompt": "A language L is decidable if and only if:",
        "options": [
          "L is regular",
          "Both L and L̄ are recognizable",
          "L is context-free",
          "L is finite"
        ],
        "correctAnswer": 1,
        "explanation": "This is a key theorem: L decidable ⟺ both L and its complement are Turing-recognizable."
      },
      {
        "id": "cs203-final-q9",
        "type": "multiple_choice",
        "prompt": "Rice's theorem applies to:",
        "options": [
          "All properties of TMs",
          "Non-trivial semantic properties of TM languages",
          "Syntactic properties of TMs",
          "Only the halting problem"
        ],
        "correctAnswer": 1,
        "explanation": "Rice's theorem: any non-trivial semantic property of TM languages is undecidable."
      },
      {
        "id": "cs203-final-q10",
        "type": "multiple_choice",
        "prompt": "Which of these problems is decidable?",
        "options": [
          "Is CFG G ambiguous?",
          "Does TM M halt on input w?",
          "Is L(M) = ∅ for TM M?",
          "Does DFA D accept string w?"
        ],
        "correctAnswer": 3,
        "explanation": "DFA membership is decidable by simulation. The others are undecidable."
      },
      {
        "id": "cs203-final-q11",
        "type": "multiple_choice",
        "prompt": "A mapping reduction A ≤_m B shows that:",
        "options": [
          "A is decidable",
          "If B is decidable, then A is decidable",
          "A and B are equal",
          "B is undecidable"
        ],
        "correctAnswer": 1,
        "explanation": "A ≤_m B means \"A is no harder than B.\" If we can solve B, we can solve A via the reduction."
      },
      {
        "id": "cs203-final-q12",
        "type": "multiple_choice",
        "prompt": "The Post Correspondence Problem (PCP) is:",
        "options": [
          "Decidable",
          "Undecidable",
          "PSPACE-complete",
          "NP-complete"
        ],
        "correctAnswer": 1,
        "explanation": "PCP is undecidable, proved by reduction from A_TM (encoding TM computations as domino sequences)."
      },
      {
        "id": "cs203-final-q13",
        "type": "multiple_choice",
        "prompt": "Class P is defined as:",
        "options": [
          "Problems solvable in linear time",
          "Problems solvable in polynomial time",
          "Problems with polynomial-size solutions",
          "Problems solvable in exponential time"
        ],
        "correctAnswer": 1,
        "explanation": "P = ∪_k TIME(n^k) — languages decidable in polynomial time by a deterministic TM."
      },
      {
        "id": "cs203-final-q14",
        "type": "multiple_choice",
        "prompt": "NP is defined as languages that:",
        "options": [
          "Have no polynomial algorithms",
          "Have polynomial-time verifiers",
          "Are not in P",
          "Require exponential time"
        ],
        "correctAnswer": 1,
        "explanation": "NP = languages with polynomial-time verifiers (certificate can be checked quickly)."
      },
      {
        "id": "cs203-final-q15",
        "type": "multiple_choice",
        "prompt": "If P = NP, then:",
        "options": [
          "Some problems would become undecidable",
          "Nothing would change practically",
          "All NP problems would have polynomial algorithms",
          "Cryptography would become more secure"
        ],
        "correctAnswer": 2,
        "explanation": "P = NP means every efficiently verifiable problem is efficiently solvable, including NP-complete problems."
      },
      {
        "id": "cs203-final-q16",
        "type": "multiple_choice",
        "prompt": "A problem is NP-complete if:",
        "options": [
          "It is NP-hard",
          "It is in NP",
          "It is not in P",
          "It is in NP and NP-hard"
        ],
        "correctAnswer": 3,
        "explanation": "NP-complete = in NP (verifiable in polynomial time) AND NP-hard (all NP problems reduce to it)."
      },
      {
        "id": "cs203-final-q17",
        "type": "multiple_choice",
        "prompt": "The first problem proved NP-complete was:",
        "options": [
          "SAT",
          "HAMPATH",
          "VERTEX-COVER",
          "CLIQUE"
        ],
        "correctAnswer": 0,
        "explanation": "Cook (1971) and Levin proved SAT is NP-complete, enabling all other NP-completeness proofs."
      },
      {
        "id": "cs203-final-q18",
        "type": "multiple_choice",
        "prompt": "To prove problem B is NP-complete, we:",
        "options": [
          "Reduce B to SAT",
          "Show B ∈ NP and reduce a known NP-complete problem to B",
          "Show B is undecidable",
          "Show B requires exponential time"
        ],
        "correctAnswer": 1,
        "explanation": "Prove B ∈ NP (give verifier), then reduce known NP-complete A to B (showing A ≤_p B)."
      },
      {
        "id": "cs203-final-q19",
        "type": "multiple_choice",
        "prompt": "Savitch's theorem shows:",
        "options": [
          "NSPACE(f(n)) ⊆ SPACE(f(n)²)",
          "PSPACE = EXPTIME",
          "L = NL",
          "P = NP"
        ],
        "correctAnswer": 0,
        "explanation": "Savitch's theorem: nondeterministic space can be simulated deterministically with square blowup. Corollary: PSPACE = NPSPACE."
      },
      {
        "id": "cs203-final-q20",
        "type": "multiple_choice",
        "prompt": "Which relationship is known to be true?",
        "options": [
          "NP = PSPACE",
          "P ⊊ EXPTIME",
          "L = P",
          "P = NP"
        ],
        "correctAnswer": 1,
        "explanation": "P ⊊ EXPTIME is proven by the time hierarchy theorem. The others are open."
      },
      {
        "id": "cs203-final-q21",
        "type": "multiple_choice",
        "prompt": "PSPACE-complete problems include:",
        "options": [
          "TQBF (True Quantified Boolean Formulas)",
          "CLIQUE",
          "HAMPATH",
          "SAT"
        ],
        "correctAnswer": 0,
        "explanation": "TQBF is PSPACE-complete. SAT, CLIQUE, and HAMPATH are NP-complete."
      },
      {
        "id": "cs203-final-q22",
        "type": "multiple_choice",
        "prompt": "L (log space) is contained in:",
        "options": [
          "Only NL",
          "Only P",
          "Neither NL nor P",
          "Both NL and P"
        ],
        "correctAnswer": 3,
        "explanation": "L ⊆ NL (deterministic is special case of nondeterministic) and L ⊆ P (log space computations run in polynomial time)."
      },
      {
        "id": "cs203-final-q23",
        "type": "multiple_choice",
        "prompt": "The Immerman-Szelepcsényi theorem shows:",
        "options": [
          "NL = coNL",
          "PSPACE = NPSPACE",
          "L = NL",
          "P = NP"
        ],
        "correctAnswer": 0,
        "explanation": "NL = coNL: nondeterministic log space is closed under complement (unlike the NP vs coNP question which is open)."
      },
      {
        "id": "cs203-final-q24",
        "type": "multiple_choice",
        "prompt": "The correct inclusion chain is:",
        "options": [
          "CFL ⊆ Regular ⊆ Decidable ⊆ RE",
          "RE ⊆ Decidable ⊆ CFL ⊆ Regular",
          "Regular ⊆ CFL ⊆ Decidable ⊆ RE",
          "Regular ⊆ Decidable ⊆ CFL ⊆ RE"
        ],
        "correctAnswer": 2,
        "explanation": "The Chomsky hierarchy: Regular ⊂ Context-free ⊂ Context-sensitive ⊂ Decidable ⊂ RE."
      },
      {
        "id": "cs203-final-q25",
        "type": "multiple_choice",
        "prompt": "coNP is the class of languages whose:",
        "options": [
          "Have polynomial algorithms",
          "Are definitely not in NP",
          "Cannot be verified",
          "Complements are in NP"
        ],
        "correctAnswer": 3,
        "explanation": "coNP = {L | L̄ ∈ NP}. These are languages where NO instances have short proofs."
      },
      {
        "id": "cs203-final-q26",
        "type": "multiple_choice",
        "prompt": "The time hierarchy theorem proves:",
        "options": [
          "Space and time are equivalent",
          "P ≠ NP",
          "All languages are decidable",
          "More time allows solving strictly more problems"
        ],
        "correctAnswer": 3,
        "explanation": "Time hierarchy: TIME(f(n)) ⊊ TIME(f(n)²), proving that more time gives strictly more power."
      },
      {
        "id": "cs203-final-q27",
        "type": "multiple_choice",
        "prompt": "Which complexity class relationship is proven?",
        "options": [
          "NP ≠ PSPACE",
          "L ≠ PSPACE",
          "P ≠ PSPACE",
          "P ≠ NP"
        ],
        "correctAnswer": 1,
        "explanation": "L ⊊ PSPACE by the space hierarchy theorem. The others are open."
      },
      {
        "id": "cs203-final-q28",
        "type": "multiple_choice",
        "prompt": "An NP-hard problem that is not in NP is:",
        "options": [
          "CLIQUE",
          "HAMPATH",
          "The halting problem",
          "SAT"
        ],
        "correctAnswer": 2,
        "explanation": "The halting problem is NP-hard (reduces from any NP problem) but not in NP (undecidable)."
      },
      {
        "id": "cs203-final-q29",
        "type": "multiple_choice",
        "prompt": "Which problem about DFAs is NOT decidable?",
        "options": [
          "Is L(M) = ∅?",
          "Does M accept string w?",
          "Are M₁ and M₂ equivalent?",
          "All DFA problems are decidable"
        ],
        "correctAnswer": 3,
        "explanation": "All standard decision problems about DFAs (emptiness, membership, equivalence) are decidable."
      },
      {
        "id": "cs203-final-q30",
        "type": "multiple_choice",
        "prompt": "The 3-SAT problem:",
        "options": [
          "Is NP-complete",
          "Is undecidable",
          "Is PSPACE-complete",
          "Is in P"
        ],
        "correctAnswer": 0,
        "explanation": "3-SAT is NP-complete. It is the most commonly used source for NP-completeness reductions."
      },
      {
        "id": "cs203-final-q31",
        "type": "multiple_choice",
        "prompt": "Diagonalization is used to prove:",
        "options": [
          "DFAs can be minimized",
          "CFLs are closed under union",
          "The pumping lemma",
          "The halting problem is undecidable"
        ],
        "correctAnswer": 3,
        "explanation": "Diagonalization constructs a machine that differs from every enumerated TM, proving undecidability of halting."
      },
      {
        "id": "cs203-final-q32",
        "type": "multiple_choice",
        "prompt": "For polynomial-time reductions, A ≤_p B means:",
        "options": [
          "A and B are equivalent",
          "A is harder than B",
          "B is at least as hard as A",
          "A and B are in P"
        ],
        "correctAnswer": 2,
        "explanation": "A ≤_p B means \"A reduces to B in polynomial time\" — B is at least as hard as A."
      },
      {
        "id": "cs203-final-q33",
        "type": "multiple_choice",
        "prompt": "Which statement about TM encoding is true?",
        "options": [
          "TMs cannot be encoded as strings",
          "Encoding makes all problems decidable",
          "All encodings produce strings of the same length",
          "Encoding enables TMs to operate on descriptions of other TMs"
        ],
        "correctAnswer": 3,
        "explanation": "Encoding TMs as strings enables the Universal TM, self-reference, and undecidability proofs."
      },
      {
        "id": "cs203-final-q34",
        "type": "multiple_choice",
        "prompt": "If NP = coNP, then:",
        "options": [
          "SAT would have short proofs of unsatisfiability",
          "Nothing would change",
          "SAT would have polynomial algorithm",
          "P = NP definitely"
        ],
        "correctAnswer": 0,
        "explanation": "NP = coNP would mean NO instances of NP problems have short proofs (UNSAT would be in NP)."
      },
      {
        "id": "cs203-final-q35",
        "type": "multiple_choice",
        "prompt": "The polynomial hierarchy (PH) is:",
        "options": [
          "Known to equal P",
          "Built from alternating quantifiers/oracles",
          "Known to equal PSPACE",
          "Only contains NP"
        ],
        "correctAnswer": 1,
        "explanation": "PH is built from levels Σₖᴾ and Πₖᴾ with alternating quantifiers. PH ⊆ PSPACE."
      },
      {
        "id": "cs203-final-q36",
        "type": "multiple_choice",
        "prompt": "Two-player games (like generalized chess) are typically:",
        "options": [
          "PSPACE-complete",
          "NP-complete",
          "In P",
          "Undecidable"
        ],
        "correctAnswer": 0,
        "explanation": "Many two-player games are PSPACE-complete due to the alternation of moves (∃∀∃∀...)."
      },
      {
        "id": "cs203-final-q37",
        "type": "multiple_choice",
        "prompt": "The relationship TIME(f(n)) ⊆ SPACE(f(n)) holds because:",
        "options": [
          "Space is more powerful than time",
          "In f(n) steps, you can visit at most f(n) tape cells",
          "Every TM uses exactly f(n) space",
          "Time and space are equivalent"
        ],
        "correctAnswer": 1,
        "explanation": "In f(n) time steps, the head can visit at most f(n) distinct cells, bounding space usage."
      },
      {
        "id": "cs203-final-q38",
        "type": "multiple_choice",
        "prompt": "The recursion theorem for TMs says:",
        "options": [
          "Recursion requires infinite tape",
          "TMs cannot self-reference",
          "TMs can obtain and use their own description",
          "All recursive functions are TM-computable"
        ],
        "correctAnswer": 2,
        "explanation": "The recursion theorem allows TMs to access their own encoding, enabling self-printing programs (quines)."
      },
      {
        "id": "cs203-final-q39",
        "type": "multiple_choice",
        "prompt": "Linear Bounded Automata (LBAs) recognize:",
        "options": [
          "Regular languages",
          "Context-free languages",
          "Context-sensitive languages",
          "All decidable languages"
        ],
        "correctAnswer": 2,
        "explanation": "LBAs (TMs with tape limited to input length) recognize exactly the context-sensitive languages."
      },
      {
        "id": "cs203-final-q40",
        "type": "multiple_choice",
        "prompt": "The \"barriers\" (relativization, natural proofs, algebrization) show that:",
        "options": [
          "P = NP is true",
          "P ≠ NP is true",
          "Standard proof techniques cannot resolve P vs NP",
          "The question is undecidable"
        ],
        "correctAnswer": 2,
        "explanation": "The barriers show that diagonalization, combinatorial, and algebraic techniques won't settle P vs NP."
      },
      {
        "id": "cs203-final-q41",
        "type": "multiple_choice",
        "prompt": "Which of the following is in NP ∩ coNP?",
        "options": [
          "Primality testing",
          "Graph coloring",
          "SAT",
          "Halting problem"
        ],
        "correctAnswer": 0,
        "explanation": "Primality is in NP (Pratt certificates) and coNP (factors prove compositeness). Now known to be in P (AKS)."
      },
      {
        "id": "cs203-final-q42",
        "type": "multiple_choice",
        "prompt": "The Busy Beaver function BB(n) is:",
        "options": [
          "Exponential",
          "Computable",
          "Not computable",
          "Polynomial"
        ],
        "correctAnswer": 2,
        "explanation": "BB(n) is not computable. If it were, we could solve the halting problem by simulation."
      }
    ]
  }
]

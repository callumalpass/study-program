# Grammar Definition

A **Context-Free Grammar (CFG)** is a formal system for generating strings through a recursive rewriting process. CFGs can describe nested structures that regular languages cannot, making them essential for programming language syntax, natural language processing, and formal verification.

## Historical Context and Motivation

Context-free grammars were introduced by Noam Chomsky in 1956 as part of his work on natural language theory. Chomsky classified grammars into four types (the Chomsky hierarchy), with context-free grammars being Type 2. The name "context-free" comes from the fact that production rules can be applied regardless of the surrounding context.

John Backus later applied these ideas to programming languages, creating what became known as Backus-Naur Form (BNF) for specifying ALGOL syntax in 1959. This application demonstrated that CFGs provide an elegant, precise way to define programming language syntax, and virtually every programming language since has used some variant of CFG-based syntax specification.

## Intuitive Understanding

Think of a CFG as a recipe for building strings. You start with a "start symbol" and repeatedly apply rules to expand variables into other variables and terminal symbols until only terminals remain. The key insight is that variables can expand in a nested, recursive fashion—a variable can indirectly produce copies of itself, enabling descriptions of nested structures like matching parentheses or balanced HTML tags.

## Formal Definition

A CFG is a 4-tuple G = (V, Σ, R, S) where:

- **V** is a finite set of variables (non-terminals)
- **Σ** is a finite set of terminals (disjoint from V)
- **R** is a finite set of production rules of the form A → α
  - A ∈ V (a single variable on the left)
  - α ∈ (V ∪ Σ)* (string of variables and terminals on the right)
- **S ∈ V** is the start variable

## Notation Conventions

- Variables: uppercase letters (A, B, S, ...)
- Terminals: lowercase letters, digits, symbols (a, b, 0, 1, +, ...)
- Mixed strings (α, β, γ, ...): elements of (V ∪ Σ)*
- Multiple rules with same left side: A → α | β | γ

## Example: Balanced Parentheses

G = ({S}, {(, )}, R, S) with rules:
- S → (S)
- S → SS
- S → ε

This generates: ε, (), (()), ()(), (())(), ...

## Example: Arithmetic Expressions

G = ({E, T, F}, {+, *, (, ), id}, R, E)

Rules:
- E → E + T | T
- T → T * F | F
- F → (E) | id

Generates expressions like: id, id + id, id * id + id, (id + id) * id

## Productions and Derivations

A **derivation** shows how a string is generated from S.

Single step: αAβ ⇒ αγβ if A → γ is a rule

Multiple steps: ⇒* (zero or more steps)

**Example**: S ⇒ (S) ⇒ (SS) ⇒ ((S)S) ⇒ (()S) ⇒ (()())

## Language of a Grammar

The **language generated by G** is:

L(G) = {w ∈ Σ* | S ⇒* w}

Strings of terminals derivable from the start variable.

## Types of Derivations

### Leftmost Derivation
Always expand the leftmost variable.

S ⇒_lm αAβ (A is the leftmost variable in αAβ)

### Rightmost Derivation
Always expand the rightmost variable.

S ⇒_rm αAβ (A is the rightmost variable)

For unambiguous grammars, these give unique derivations for each string.

## Sentential Forms

A **sentential form** is any string derivable from S (may contain variables).

A **sentence** is a sentential form with no variables (a string in L(G)).

## CFG Design Techniques

### Union Construction
For L₁ ∪ L₂:
- Add new start S
- Add S → S₁ | S₂

### Concatenation Construction
For L₁L₂:
- Add new start S
- Add S → S₁S₂

### Star Construction
For L*:
- Add new start S
- Add S → SS₁ | ε

## Comparison with Regular Grammars

**Regular grammars** restrict productions to:
- A → aB (right-linear)
- A → a
- A → ε

These generate exactly the regular languages. CFGs allow more general rules.

## Why Context-Free?

The name "context-free" means the left side is always a single variable—we can replace A with γ regardless of the **context** (surrounding symbols).

**Context-sensitive** grammars allow αAβ → αγβ, where the context matters.

## Practical Applications

CFGs are foundational in several areas:

**Compiler Design**: The syntax of virtually every programming language is defined using CFGs or their extensions. Parser generators like YACC, Bison, and ANTLR take grammar specifications and automatically generate parsers.

**Natural Language Processing**: While natural languages are not perfectly context-free, CFG-based models provide useful approximations for syntactic parsing of sentences.

**XML and HTML Validation**: Document type definitions (DTDs) and XML schemas use context-free concepts to specify valid document structures.

**Protocol Specification**: Network protocols and data formats often have nested structure that CFGs can describe precisely.

## Key Takeaways

- CFGs extend regular languages to handle nested, recursive structures
- The 4-tuple definition (V, Σ, R, S) completely specifies a grammar
- Production rules have a single variable on the left side (context-free property)
- Derivations show step-by-step string generation from the start variable
- CFGs form the theoretical foundation for programming language syntax
- The class of context-free languages properly contains regular languages

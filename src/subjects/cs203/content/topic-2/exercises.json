[
  {
    "id": "cs203-t2-ex1",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Basic Regular Expression",
    "description": "Write a regular expression for the language L = {w ∈ {a,b}* | w contains at least two a's}.",
    "difficulty": 1,
    "hints": [
      "Two a's with anything before, between, and after",
      "Use (a|b)* for \"any string\"",
      "Think: stuff, then a, then stuff, then a, then stuff"
    ],
    "solution": "**Regular Expression:** (a|b)*a(a|b)*a(a|b)*\n\n**Alternative forms:**\n- b*ab*a(a|b)*\n- (b|ab*a)*ab*a(a|b)* (more complex)\n\n**Explanation:**\n- (a|b)* matches any string (zero or more of 'a' or 'b')\n- First 'a' ensures at least one a\n- Second 'a' ensures at least two a's\n- Pattern: [anything] a [anything] a [anything]\n\n**Verification:**\n- \"aa\" ∈ L: (a|b)* = ε, first a, (a|b)* = ε, second a, (a|b)* = ε ✓\n- \"bab\" ∉ L: only one a ✗\n- \"abba\" ∈ L: ε, a, bb, a, ε ✓\n- \"baba\" ∈ L: b, a, b, a, ε ✓"
  },
  {
    "id": "cs203-t2-ex2",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Language from Regular Expression",
    "description": "Describe in English the language defined by the regular expression (0|1)*1(0|1)(0|1). List all strings of length 4 or less in this language.",
    "difficulty": 1,
    "hints": [
      "Read the regex from left to right",
      "The suffix is fixed: 1 followed by two symbols",
      "Enumerate systematically"
    ],
    "solution": "**Language description:**\nAll binary strings where the third-to-last symbol is 1.\n\nOr equivalently: All binary strings ending with \"1\" followed by any two binary symbols.\n\n**Structure:**\n- (0|1)*: any prefix (including empty)\n- 1: third-to-last must be 1\n- (0|1): second-to-last is any bit\n- (0|1): last is any bit\n\n**Strings of length 4 or less:**\n\nLength 3 (minimum): 1xy where x,y ∈ {0,1}\n- 100, 101, 110, 111\n\nLength 4: z1xy where z,x,y ∈ {0,1}\n- 0100, 0101, 0110, 0111\n- 1100, 1101, 1110, 1111\n\n**Complete list:**\n{100, 101, 110, 111, 0100, 0101, 0110, 0111, 1100, 1101, 1110, 1111}\n\n**Total: 12 strings** (4 of length 3, 8 of length 4)\n\nNote: No valid strings of length < 3 exist (need at least 3 symbols for \"1 _ _\" pattern)."
  },
  {
    "id": "cs203-t2-ex3",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Thompson's Construction",
    "description": "Apply Thompson's construction to build an NFA for the regular expression (ab|b)*. Show the construction step by step.",
    "difficulty": 3,
    "hints": [
      "Build NFAs for primitives first",
      "Combine using standard constructions for |, ·, and *",
      "The result will have many ε-transitions"
    ],
    "solution": "**Thompson's Construction for (ab|b)***\n\n**Step 1: Build NFA for 'a'**\n```\n(1) --a--> (2)\n```\n\n**Step 2: Build NFA for 'b'**\n```\n(3) --b--> (4)\n```\n\n**Step 3: Build NFA for 'ab' (concatenation)**\nConnect NFA(a) to NFA(b):\n```\n(1) --a--> (2) --ε--> (3) --b--> (4)\n```\n\n**Step 4: Build another NFA for 'b'**\n```\n(5) --b--> (6)\n```\n\n**Step 5: Build NFA for 'ab|b' (union)**\nAdd new start (7) with ε to both sub-NFAs, new accept (8):\n```\n        ε--> (1) --a--> (2) --ε--> (3) --b--> (4) --ε--\n       /                                              \\\n(7) --<                                                >-- (8)\n       \\                                              /\n        ε--> (5) --b--> (6) --ε---------------------ε--\n```\n\n**Step 6: Build NFA for (ab|b)* (Kleene star)**\nAdd new start (9) with ε to old start and new accept (10):\n```\n     ε (skip)\n(9) ---------> (10)\n |    ε         ^\n v              | ε (loop back)\n(7) --> [ab|b NFA] --> (8) --ε--> (10)\n                        |\n                        ε--> (7)\n```\n\n**Final NFA:**\n- States: {9, 7, 1, 2, 3, 4, 5, 6, 8, 10}\n- Start: 9\n- Accept: {10}\n- Transitions include ε-transitions for all connections"
  },
  {
    "id": "cs203-t2-ex4",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "State Elimination Details",
    "description": "Use state elimination to convert this DFA to a regex: States {1, 2, 3}, start 1, accept 3. δ(1,a)=2, δ(1,b)=3, δ(2,a)=3, δ(2,b)=1, δ(3,a)=3, δ(3,b)=3. Eliminate state 2 first.",
    "difficulty": 5,
    "hints": [
      "First convert to GNFA with new start and accept",
      "When eliminating state 2, find all paths through it",
      "Update edge labels to include detour through eliminated state"
    ],
    "solution": "**State Elimination Process**\n\n**Step 1: Convert to GNFA**\nAdd start state S (→ε→ 1) and accept state F (3 →ε→ F)\n\nInitial edges:\n- S →ε→ 1\n- 1 →a→ 2\n- 1 →b→ 3\n- 2 →a→ 3\n- 2 →b→ 1\n- 3 →(a|b)→ 3 (combine self-loops)\n- 3 →ε→ F\n\n**Step 2: Eliminate state 2**\nFind paths through state 2:\n- 1 →a→ 2 →a→ 3: path \"aa\"\n- 1 →a→ 2 →b→ 1: path \"ab\" (back to 1)\n\nNo self-loop on state 2, so no iteration.\n\nAfter elimination:\n- S →ε→ 1\n- 1 →b→ 3 (direct)\n- 1 →aa→ 3 (through 2)\n- 1 →ab→ 1 (through 2, back to 1)\n- 3 →(a|b)→ 3\n- 3 →ε→ F\n\nCombine 1→3 edges: 1 →(b|aa)→ 3\n\n**Step 3: Eliminate state 1**\nPaths through 1:\n- S →ε→ 1 →(b|aa)→ 3\n- 1 has self-loop: 1 →ab→ 1\n\nPath S to 3 through 1: ε·(ab)*·(b|aa) = (ab)*(b|aa)\n\nAfter elimination:\n- S →(ab)*(b|aa)→ 3\n- 3 →(a|b)→ 3\n- 3 →ε→ F\n\n**Step 4: Eliminate state 3**\nPath S to F through 3:\n- S →(ab)*(b|aa)→ 3 →(a|b)*→ 3 →ε→ F\n\n**Final regex: (ab)*(b|aa)(a|b)***\n\n**Verification:**\n- \"b\": (ab)⁰·b·(a|b)⁰ ✓\n- \"aa\": (ab)⁰·aa·(a|b)⁰ ✓\n- \"aba\": (ab)¹·a·(a|b)⁰ — but \"aba\" needs checking: 1→a→2→b→1→a→2→a→3 ✓"
  },
  {
    "id": "cs203-t2-ex5",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Algebraic Simplification",
    "description": "Simplify the following regular expression using algebraic identities: (a|b)*(a|ε)(b|ε) Give the simplified form and list the identities used.",
    "difficulty": 3,
    "hints": [
      "Expand using distributivity",
      "Use (a|b)* properties",
      "a*a = a* · a, and (a|b)*a ⊆ (a|b)*"
    ],
    "solution": "**Simplification of (a|b)*(a|ε)(b|ε)**\n\n**Step 1: Expand (a|ε)(b|ε)**\nUsing distributivity: (r|s)(t|u) = rt|ru|st|su\n\n(a|ε)(b|ε) = ab | a·ε | ε·b | ε·ε\n           = ab | a | b | ε\n\n**Step 2: Substitute back**\n(a|b)*(ab | a | b | ε)\n\n**Step 3: Distribute (a|b)***\n= (a|b)*ab | (a|b)*a | (a|b)*b | (a|b)*ε\n\n**Step 4: Simplify each term**\n- (a|b)*ε = (a|b)* (identity: r·ε = r)\n- (a|b)*a ⊆ (a|b)* (since (a|b)*a matches strings ending in 'a')\n- Similarly (a|b)*b ⊆ (a|b)* and (a|b)*ab ⊆ (a|b)*\n\n**Step 5: Key insight**\n(a|b)* already contains all strings over {a,b}!\n\nSo: (a|b)*ab | (a|b)*a | (a|b)*b | (a|b)* = (a|b)*\n\n(Union with subsets doesn't change the result)\n\n**Final simplified form: (a|b)***\n\n**Identities used:**\n1. Distributivity: r(s|t) = rs|rt\n2. Identity: r·ε = r\n3. Absorption: r | rs = r for any s (when (a|b)*X ⊆ (a|b)*)\n4. Idempotence: r | r = r"
  },
  {
    "id": "cs203-t2-ex6",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Regex for Fixed Length",
    "description": "Write a regular expression for all binary strings of length exactly 4 that do not contain \"00\" as a substring.",
    "difficulty": 3,
    "hints": [
      "Enumerate patterns or think about \"never two 0s in a row\"",
      "After a 0, must have a 1",
      "Build up valid 4-symbol sequences"
    ],
    "solution": "**Analysis:**\nNeed binary strings of length 4 with no \"00\" substring.\n\n**Approach 1: Systematic enumeration**\nAfter 0, must see 1. After 1, can see 0 or 1.\n\nValid patterns (where 0 can't be followed by 0):\nStarting with 1: 1___ where each position follows the rule\nStarting with 0: 01__ where each position follows the rule\n\n**Building the regex:**\nLet's think of it as: (1|01)* but constrained to length 4.\n\nPossible 4-character strings:\n- 1111 ✓\n- 1110 ✓\n- 1101 ✓\n- 1100 ✗ (has \"00\")\n- 1011 ✓\n- 1010 ✓\n- 1001 ✗\n- 1000 ✗\n- 0111 ✓\n- 0110 ✓\n- 0101 ✓\n- 0100 ✗\n- 0011 ✗\n- 0010 ✗\n- 0001 ✗\n- 0000 ✗\n\nValid: {1111, 1110, 1101, 1011, 1010, 0111, 0110, 0101}\n\n**Regular expression (explicit union):**\n1111 | 1110 | 1101 | 1011 | 1010 | 0111 | 0110 | 0101\n\n**Factored form:**\n= 1(111|110|101|011|010) | 01(11|10|01)\n= 1(1(11|10|01)|01(1|0)) | 01(1(1|0)|01)\n\n**Cleaner factored form:**\n(1|01)(1|01)(1|0)(1|ε) where we ensure length 4...\n\nActually simplest: **1(1|01)*(1|0) constrained to length 4:**\n\n**(11|101|01)(11|10|01) | 1(11|10|01)(1|0)**\n\nOr just enumerate: **1111|1110|1101|1011|1010|0111|0110|0101**"
  },
  {
    "id": "cs203-t2-ex7",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Decision Problem - Emptiness",
    "description": "Describe an algorithm to decide whether the language of a given DFA is empty. What is the time complexity? Apply it to determine if the DFA with states {1,2,3}, start 1, accept {3}, δ(1,a)=2, δ(1,b)=1, δ(2,a)=2, δ(2,b)=2 has an empty language.",
    "difficulty": 3,
    "hints": [
      "Empty language means no accepting state is reachable",
      "Use graph reachability (BFS or DFS)",
      "The DFA is a directed graph"
    ],
    "solution": "**Algorithm for DFA Emptiness:**\n\n**Input:** DFA M = (Q, Σ, δ, q₀, F)\n**Output:** TRUE if L(M) = ∅, FALSE otherwise\n\n**Algorithm:**\n1. Perform BFS/DFS from start state q₀\n2. Mark all reachable states\n3. Return TRUE if F ∩ (reachable states) = ∅\n4. Return FALSE otherwise\n\n**Pseudocode:**\n```\nfunction isEmpty(M):\n    visited = {q₀}\n    queue = [q₀]\n    while queue not empty:\n        q = queue.dequeue()\n        for each a in Σ:\n            p = δ(q, a)\n            if p not in visited:\n                visited.add(p)\n                queue.enqueue(p)\n    return (F ∩ visited) == ∅\n```\n\n**Time Complexity:** O(|Q| × |Σ|)\n- Visit each state at most once\n- Check |Σ| transitions per state\n- Linear in DFA size\n\n**Application to given DFA:**\n- States: {1, 2, 3}, Start: 1, Accept: {3}\n- δ(1,a)=2, δ(1,b)=1, δ(2,a)=2, δ(2,b)=2\n\n**BFS from state 1:**\n- Initial: visited = {1}, queue = [1]\n- Process 1: δ(1,a)=2, δ(1,b)=1\n  - Add 2: visited = {1,2}, queue = [2]\n- Process 2: δ(2,a)=2, δ(2,b)=2\n  - 2 already visited\n\n**Reachable states: {1, 2}**\n**Accept states: {3}**\n**Intersection: ∅**\n\n**Result: Language is EMPTY (TRUE)**\n\nState 3 is unreachable from the start state, so no string is accepted."
  },
  {
    "id": "cs203-t2-ex8",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Decision Problem - Universality",
    "description": "Describe an algorithm to decide whether a given DFA accepts all strings (L = Σ*). What is the time complexity?",
    "difficulty": 3,
    "hints": [
      "L = Σ* iff L̄ = ∅",
      "Complement a DFA by swapping accept and non-accept states",
      "Then test for emptiness"
    ],
    "solution": "**Algorithm for DFA Universality:**\n\n**Input:** DFA M = (Q, Σ, δ, q₀, F)\n**Output:** TRUE if L(M) = Σ*, FALSE otherwise\n\n**Key insight:** L(M) = Σ* ⟺ L̄(M) = ∅\n\n**Algorithm:**\n1. Construct complement DFA M̄:\n   - Same states, transitions, and start state\n   - Accept states F̄ = Q - F\n2. Test if L(M̄) = ∅ using emptiness algorithm\n3. Return TRUE if empty (original is universal)\n4. Return FALSE otherwise\n\n**Pseudocode:**\n```\nfunction isUniversal(M):\n    // Construct complement\n    M_bar = (Q, Σ, δ, q₀, Q - F)\n\n    // Test emptiness of complement\n    return isEmpty(M_bar)\n```\n\n**Detailed steps for emptiness check:**\n```\nfunction isUniversal(M):\n    visited = {q₀}\n    queue = [q₀]\n    rejecting_states = Q - F\n\n    while queue not empty:\n        q = queue.dequeue()\n        if q in rejecting_states:\n            // Found reachable rejecting state\n            // So some string is rejected\n            return FALSE\n        for each a in Σ:\n            p = δ(q, a)\n            if p not in visited:\n                visited.add(p)\n                queue.enqueue(p)\n\n    // No rejecting state reachable\n    return TRUE\n```\n\n**Time Complexity:** O(|Q| × |Σ|)\n- Same as emptiness test\n- No actual construction needed\n- Just check if any non-accepting state is reachable\n\n**Correctness:**\n- L(M) = Σ* ⟺ no string is rejected\n- String w is rejected ⟺ δ*(q₀, w) ∉ F\n- ⟺ some non-accepting state is reachable\n- ⟺ complement is non-empty"
  },
  {
    "id": "cs203-t2-ex9",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Homomorphism on Regular Languages",
    "description": "Define a homomorphism h: {a,b}* → {0,1}* where h(a) = 01 and h(b) = 1. If L is the regular language a*b, what is h(L)? Write a regular expression for h(L).",
    "difficulty": 3,
    "hints": [
      "Apply h to each symbol in strings of L",
      "h extends to strings: h(w₁w₂) = h(w₁)h(w₂)",
      "Think about what strings in a*b look like"
    ],
    "solution": "**Homomorphism h: {a,b}* → {0,1}***\n- h(a) = 01\n- h(b) = 1\n\n**Language L = a*b**\nL = {b, ab, aab, aaab, ...} = {aⁿb | n ≥ 0}\n\n**Computing h(L):**\nh(aⁿb) = h(a)ⁿh(b) = (01)ⁿ1\n\nSo h(L) = {(01)ⁿ1 | n ≥ 0} = {1, 011, 01011, 0101011, ...}\n\n**Regular expression for h(L):**\n**(01)*1**\n\n**Verification:**\n- h(b) = h(a⁰b) = (01)⁰·1 = 1 ✓\n- h(ab) = h(a¹b) = (01)¹·1 = 011 ✓\n- h(aab) = h(a²b) = (01)²·1 = 01011 ✓\n\n**Properties demonstrated:**\n1. Homomorphism maps each symbol to a string\n2. Extends to strings by concatenation\n3. Regular languages are closed under homomorphism\n4. If L is described by regex r, h(L) is described by h(r) where h is applied to each symbol\n\nFor L = a*b:\n- h(a*b) = h(a)*h(b) = (01)*1 ✓"
  },
  {
    "id": "cs203-t2-ex10",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Inverse Homomorphism",
    "description": "For the same homomorphism h(a)=01, h(b)=1, let L = {011, 0111}. Compute h⁻¹(L) = {w | h(w) ∈ L}.",
    "difficulty": 5,
    "hints": [
      "Find all strings w where h(w) equals something in L",
      "h(w) = 011 means w must expand to 011",
      "Try different combinations of a and b"
    ],
    "solution": "**Inverse Homomorphism h⁻¹(L)**\n\nh(a) = 01, h(b) = 1\nL = {011, 0111}\n\nNeed to find all w ∈ {a,b}* such that h(w) ∈ L.\n\n**For h(w) = 011:**\nNeed h(w) to have length 3 and be \"011\".\n\nPossible factorizations of \"011\":\n- (01)(1) → h(a)h(b) = h(ab), length(ab) = 2 ✓\n- (0)(11) → no single symbol maps to 0 ✗\n- (011) → no single symbol maps to 011 ✗\n- (0)(1)(1) → no single symbol maps to 0 ✗\n\nSo h(ab) = 011 → ab ∈ h⁻¹(L) ✓\n\n**For h(w) = 0111:**\nNeed h(w) to have length 4 and be \"0111\".\n\nPossible factorizations:\n- (01)(1)(1) → h(a)h(b)h(b) = h(abb), check: h(abb) = 01·1·1 = 0111 ✓\n- (01)(11) → h(a)(11), but no symbol maps to 11 ✗\n- (0)(111) → no symbol maps to 0 ✗\n- (0111) → no symbol maps to 0111 ✗\n\nSo h(abb) = 0111 → abb ∈ h⁻¹(L) ✓\n\n**Are there other possibilities?**\n- bb: h(bb) = 11 ≠ 011, 0111 ✗\n- aa: h(aa) = 0101 ≠ 011, 0111 ✗\n- a: h(a) = 01 ≠ 011, 0111 ✗\n- b: h(b) = 1 ≠ 011, 0111 ✗\n- aab: h(aab) = 01011 ≠ 011, 0111 ✗\n- bab: h(bab) = 1011 ≠ 011, 0111 ✗\n\n**h⁻¹(L) = {ab, abb}**"
  },
  {
    "id": "cs203-t2-ex11",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Regular Expression Equivalence",
    "description": "Prove or disprove: The regular expressions (a|b)* and a*b*a*b* are equivalent (describe the same language).",
    "difficulty": 3,
    "hints": [
      "What languages do they describe?",
      "Is every string in one also in the other?",
      "Try to find a counterexample"
    ],
    "solution": "**Claim: (a|b)* and a*b*a*b* are NOT equivalent.**\n\n**Language of (a|b)*:**\nAll strings over {a,b}, including:\n- ε, a, b, aa, ab, ba, bb, aaa, aba, bab, ...\n- Any combination of a's and b's in any order\n\n**Language of a*b*a*b*:**\nStrings of form: (some a's)(some b's)(some a's)(some b's)\n- ε (all parts empty) ✓\n- a, aa, aaa, ... (first part only) ✓\n- b, bb, ... (second part only) ✓\n- ab, aab, abb, ... ✓\n- ba, bba, ... (third and fourth parts) ✓\n- aba, abab, ... ✓\n\n**Finding a counterexample:**\nConsider \"bab\":\n- In (a|b)*: Yes (b·a·b) ✓\n- In a*b*a*b*: Need to split as aⁱbʲaᵏbˡ\n  - b = a⁰b¹a⁰b⁰? Then \"ab\" part is b, need to place \"ab\" at end...\n  - Actually: a⁰b¹a¹b¹ = \"bab\" ✓\n\nConsider \"abab\":\n- In (a|b)*: Yes ✓\n- In a*b*a*b*: a¹b¹a¹b¹ = \"abab\" ✓\n\nConsider \"baba\":\n- In (a|b)*: Yes ✓\n- In a*b*a*b*: We need aⁱbʲaᵏbˡ = \"baba\"\n  - If i=0: bʲaᵏbˡ = \"baba\", so j=1, then aᵏbˡ = \"aba\"\n  - Then k≥1 (need 'a'), k=1 gives bˡ = \"ba\" - but b* can't produce \"ba\"!\n\n**Counterexample found: \"baba\" ∈ (a|b)* but baba ∉ a*b*a*b***\n\n**Proof that baba ∉ a*b*a*b*:**\nAny string in a*b*a*b* has at most 2 \"runs\" of a's (consecutive a's) and at most 2 \"runs\" of b's, with structure (a-run)(b-run)(a-run)(b-run).\n\n\"baba\" has structure: b, a, b, a = 4 alternations, which requires 2 b-runs with an a-run between them. This pattern (b-a-b-a) cannot fit a*b*a*b*.\n\n**Conclusion: The expressions are NOT equivalent. ∎**"
  },
  {
    "id": "cs203-t2-ex12",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Kleene Star Properties",
    "description": "Prove the identity (r*)* = r* for regular expressions. That is, show L((r*)*) = L(r*).",
    "difficulty": 3,
    "hints": [
      "Show inclusion in both directions",
      "(r*)* = concatenations of concatenations of L(r) strings",
      "Concatenation is associative"
    ],
    "solution": "**Theorem: (r*)* = r***\n\nLet L = L(r). We show L((r*)*) = L(r*).\n\n**Recall definitions:**\n- L(r*) = L* = {ε} ∪ L ∪ LL ∪ LLL ∪ ... = ⋃_{n≥0} Lⁿ\n- L((r*)*) = (L*)* = ⋃_{n≥0} (L*)ⁿ\n\n**Part 1: L* ⊆ (L*)***\n- L* is the set of all concatenations of L strings\n- (L*)* is the set of all concatenations of L* strings\n- Since ε ∈ L*, we have L* = L* · {ε} ⊆ L* · L* ⊆ (L*)*\n- Therefore L* ⊆ (L*)* ✓\n\n**Part 2: (L*)* ⊆ L***\nLet w ∈ (L*)*.\nThen w = w₁w₂...wₖ where each wᵢ ∈ L*.\n\nEach wᵢ ∈ L* means wᵢ = uᵢ₁uᵢ₂...uᵢₘᵢ where each uᵢⱼ ∈ L.\n\nSo w = u₁₁u₁₂...u₁ₘ₁ u₂₁u₂₂...u₂ₘ₂ ... uₖ₁...uₖₘₖ\n\nThis is a concatenation of strings from L, hence w ∈ L*.\n\nTherefore (L*)* ⊆ L* ✓\n\n**Conclusion: (L*)* = L*, so (r*)* = r* ∎**\n\n**Intuition:**\n- L* = \"any number of L strings concatenated\"\n- (L*)* = \"any number of (any number of L strings) concatenated\"\n- But concatenating concatenations is just concatenation\n- So (L*)* = L*\n\n**Analogous to arithmetic:** ((n×a) + (m×a)) is still a multiple of a."
  },
  {
    "id": "cs203-t2-ex13",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Decision Problem - Infiniteness",
    "description": "Describe an algorithm to decide whether a given DFA accepts infinitely many strings. What is the key insight?",
    "difficulty": 3,
    "hints": [
      "When can a DFA accept infinitely many strings?",
      "Think about cycles in the transition graph",
      "A cycle reachable from start and reaching accept gives infinity"
    ],
    "solution": "**Algorithm for DFA Infiniteness:**\n\n**Key Insight:**\nL(M) is infinite ⟺ M has a cycle on a path from start to some accepting state.\n\nIf there's such a cycle, we can traverse it any number of times, generating infinitely many accepted strings.\n\n**Algorithm:**\n\n**Input:** DFA M = (Q, Σ, δ, q₀, F)\n**Output:** TRUE if |L(M)| = ∞, FALSE otherwise\n\n1. Find all states reachable from q₀ (forward reachability)\n2. Find all states that can reach some f ∈ F (backward reachability)\n3. Let U = (forward reachable) ∩ (backward reachable) = \"useful\" states\n4. Check if the subgraph induced by U contains a cycle\n5. Return TRUE if cycle exists, FALSE otherwise\n\n**Pseudocode:**\n```\nfunction isInfinite(M):\n    // Step 1: Forward reachability from q₀\n    forward = BFS_forward(q₀)\n\n    // Step 2: Backward reachability to F\n    backward = BFS_backward(F)\n\n    // Step 3: Useful states\n    useful = forward ∩ backward\n\n    // Step 4: Check for cycle in useful subgraph\n    return hasCycle(useful, δ)\n```\n\n**Time Complexity:** O(|Q| × |Σ|)\n- BFS is O(|Q| × |Σ|)\n- Cycle detection is O(|Q| + |E|) = O(|Q| × |Σ|)\n\n**Alternative using pumping:**\nL is infinite ⟺ ∃ string w ∈ L with |Q| ≤ |w| < 2|Q|\n\nThis follows from pumping lemma: if L has strings of all lengths ≥ |Q|, it's infinite.\n\nSo: enumerate/test strings of length |Q| to 2|Q|-1.\nLess efficient but theoretically interesting."
  },
  {
    "id": "cs203-t2-ex14",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Regex to NFA Size",
    "description": "If a regular expression r has length n (total symbols and operators), how many states does Thompson's construction produce? Give a tight bound.",
    "difficulty": 3,
    "hints": [
      "Count states added for each construction",
      "Base cases add 2 states each",
      "Union adds 2, concatenation adds 0, star adds 2"
    ],
    "solution": "**Thompson's Construction State Count**\n\n**State counts per construction:**\n\n1. **Base case ∅:** 2 states (start, accept)\n2. **Base case ε:** 2 states (start, accept with ε-edge)\n3. **Base case a (symbol):** 2 states (start →a→ accept)\n4. **Union r|s:** 2 new states (new start and accept)\n5. **Concatenation rs:** 0 new states (merge accept of r with start of s)\n6. **Kleene star r*:** 2 new states (new start and accept)\n\n**Counting for expression of length n:**\n\nAn expression of length n has:\n- k symbols (base cases), where k ≤ n\n- Operators: at most n - k operators (union, concat, star)\n\nEach symbol creates 2 states.\nEach union/star creates 2 additional states.\nConcatenation creates 0 additional states.\n\n**Upper bound analysis:**\n- Worst case: all base cases are symbols, rest are | or *\n- Symbols: ≤ n, each adds 2 states\n- Operators | and *: each adds 2 states\n\n**Tight bound: O(n) states**\n\nMore precisely: ≤ 2n states\n\n**Proof:**\n- Expression with n nodes in syntax tree\n- Each leaf (symbol, ε, ∅) contributes 2 states\n- Each internal node (|, ·, *) contributes at most 2 states\n- Total internal nodes ≤ number of leaves - 1\n- So total states ≤ 2 × (leaves) + 2 × (leaves - 1) ≤ 4 × leaves ≤ 2n\n\n**Exact count:** The NFA from Thompson's construction has exactly 2n states where n is the number of nodes in the regex syntax tree (counting each symbol and operator).\n\nFor a regex string of length n, this is **O(n) states**."
  },
  {
    "id": "cs203-t2-ex15",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Quotient Operation",
    "description": "For languages L₁ and L₂, define L₁/L₂ = {x | ∃y ∈ L₂: xy ∈ L₁} (right quotient). Prove that if L₁ is regular and L₂ is any language, then L₁/L₂ is regular.",
    "difficulty": 5,
    "hints": [
      "Build from a DFA for L₁",
      "What states should be accepting in the quotient DFA?",
      "State q should accept if some y ∈ L₂ leads from q to accepting"
    ],
    "solution": "**Theorem:** If L₁ is regular, then L₁/L₂ is regular for any L₂.\n\n**Proof by construction:**\n\nLet M = (Q, Σ, δ, q₀, F) be a DFA for L₁.\n\nConstruct DFA M' = (Q, Σ, δ, q₀, F') for L₁/L₂ where:\n- F' = {q ∈ Q | ∃y ∈ L₂: δ*(q, y) ∈ F}\n\nThat is, a state is accepting in M' if some string from L₂ leads from it to an accepting state of M.\n\n**Correctness:**\n\nx ∈ L₁/L₂ ⟺ ∃y ∈ L₂: xy ∈ L₁\n           ⟺ ∃y ∈ L₂: δ*(q₀, xy) ∈ F\n           ⟺ ∃y ∈ L₂: δ*(δ*(q₀, x), y) ∈ F\n           ⟺ δ*(q₀, x) ∈ F'\n           ⟺ M' accepts x\n\n**Why this works:**\n- M' has the same states and transitions as M\n- Only the accepting states change\n- A state q is in F' if reaching q gives \"hope\" of accepting with some suffix from L₂\n\n**Key insight:**\nThe quotient construction only changes F, so:\n- Number of states: same as M\n- Transitions: same as M\n- Only accepting states are redefined\n\n**Regularity preserved:**\nEven if L₂ is non-regular (or even non-recursive), F' is still a finite set of states (subset of Q).\n\nThe construction doesn't need to \"compute\" anything about L₂ at runtime - F' is determined statically.\n\n**Example:**\nL₁ = a*b*, L₂ = {aⁿbⁿ | n ≥ 0}\nL₁/L₂ = {x | ∃y ∈ L₂: xy ∈ a*b*}\n      = {aⁱ | ∃aⁿbⁿ: aⁱaⁿbⁿ ∈ a*b*}\n      = a* (since aⁱ⁺ⁿbⁿ ∈ a*b* for any i, n)\n\nL₁/L₂ is regular even though L₂ is not! ∎"
  },
  {
    "id": "cs203-t2-ex16",
    "subjectId": "cs203",
    "topicId": "cs203-topic-2",
    "type": "written",
    "title": "Concatenation Star Identity",
    "description": "Prove or disprove: (rs)* = ε | r(sr)*s for all regular expressions r and s.",
    "difficulty": 5,
    "hints": [
      "Think about what strings are in (rs)*",
      "Think about what strings are in ε | r(sr)*s",
      "Try specific examples first"
    ],
    "solution": "**Claim: (rs)* = ε | r(sr)*s is FALSE in general.**\n\n**Analysis of both sides:**\n\n**Left side: (rs)***\nL((rs)*) = {ε, rs, rsrs, rsrsrs, ...} = {(rs)ⁿ | n ≥ 0}\n\n**Right side: ε | r(sr)*s**\nL(ε | r(sr)*s) = {ε} ∪ L(r(sr)*s)\n               = {ε} ∪ {r·(sr)ⁿ·s | n ≥ 0}\n               = {ε, rs, rsrs, rsrsrs, ...} where each has r at front, s at back\n\nWait, let's compute more carefully:\n- r(sr)⁰s = rs\n- r(sr)¹s = rsrs\n- r(sr)²s = rsrsrs\n\nSo L(ε | r(sr)*s) = {ε, rs, rsrs, rsrsrs, ...}\n\nThis looks the same as (rs)*!\n\n**Let's verify the identity:**\n\nFor n ≥ 1: (rs)ⁿ vs r(sr)ⁿ⁻¹s\n\n(rs)ⁿ = (rs)(rs)...(rs) [n times]\nr(sr)ⁿ⁻¹s = r(sr)(sr)...(sr)s [n-1 copies of sr]\n          = r·s·r·s·r...·s·r·s [this has n r's and n s's alternating]\n          = (rs)(rs)...(rs) [n times] ✓\n\n**The identity appears to be TRUE!**\n\n**Formal Proof:**\n\n**Part 1: (rs)* ⊆ ε | r(sr)*s**\n- ε ∈ (rs)* and ε ∈ {ε | r(sr)*s} ✓\n- (rs)ⁿ for n ≥ 1:\n  - (rs)ⁿ = rs·(rs)ⁿ⁻¹ = r·(s·r)ⁿ⁻¹·s = r(sr)ⁿ⁻¹s ∈ r(sr)*s ✓\n\n**Part 2: ε | r(sr)*s ⊆ (rs)***\n- ε ∈ (rs)* ✓\n- r(sr)ⁿs = r·(sr)ⁿ·s = (rs)·(rs)ⁿ⁻¹·(rs)...\n\nHmm, let me recompute: r(sr)ⁿs with n=1:\nrsrs = r·sr·s. And (rs)² = rsrs ✓\n\n**Conclusion: The identity (rs)* = ε | r(sr)*s is TRUE. ∎**"
  }
]

[
  {
    "id": "cs401-midterm",
    "subjectId": "cs401",
    "title": "CS401 Midterm Exam",
    "durationMinutes": 120,
    "questions": [
      {
        "id": "cs401-midterm-q1",
        "type": "multiple_choice",
        "prompt": "Which of the following best describes a distributed system?",
        "options": [
          "A collection of independent computers that appears to users as a single coherent system",
          "Multiple programs running on a single computer",
          "A cloud-based application",
          "Any networked system"
        ],
        "correctAnswer": 0,
        "explanation": "A distributed system consists of multiple autonomous computers coordinating to appear as a single system to users, providing transparency and resource sharing."
      },
      {
        "id": "cs401-midterm-q2",
        "type": "multiple_choice",
        "prompt": "What is the primary challenge that makes distributed systems more complex than centralized systems?",
        "options": [
          "Lack of shared global state and partial failures",
          "Higher cost of hardware",
          "Slower processing speed",
          "Limited programming languages"
        ],
        "correctAnswer": 0,
        "explanation": "Distributed systems lack shared memory and must handle partial failures where some components fail while others continue, making them fundamentally more complex."
      },
      {
        "id": "cs401-midterm-q3",
        "type": "multiple_choice",
        "prompt": "According to the CAP theorem, what must a distributed system sacrifice during a network partition?",
        "options": [
          "Either Consistency or Availability",
          "Partition tolerance",
          "Performance",
          "Security"
        ],
        "correctAnswer": 0,
        "explanation": "CAP theorem states that during network partitions (P), systems must choose between Consistency (all nodes see same data) and Availability (all requests get responses)."
      },
      {
        "id": "cs401-midterm-q4",
        "type": "multiple_choice",
        "prompt": "In a client-server architecture, what is a primary disadvantage?",
        "options": [
          "Server becomes a single point of failure",
          "Complex client implementation",
          "Poor scalability",
          "Difficult to secure"
        ],
        "correctAnswer": 0,
        "explanation": "Client-server architecture centralizes logic and data on the server, making it a single point of failure. If the server fails, the entire system becomes unavailable."
      },
      {
        "id": "cs401-midterm-q5",
        "type": "multiple_choice",
        "prompt": "What transparency type hides whether a resource is replicated?",
        "options": [
          "Replication transparency",
          "Location transparency",
          "Concurrency transparency",
          "Failure transparency"
        ],
        "correctAnswer": 0,
        "explanation": "Replication transparency hides that multiple copies of a resource exist, making the system appear to have only one copy while actually maintaining replicas for availability."
      },
      {
        "id": "cs401-midterm-q6",
        "type": "multiple_choice",
        "prompt": "Which RPC semantic guarantees the procedure executes exactly once or not at all?",
        "options": [
          "Exactly-once semantics",
          "At-least-once semantics",
          "At-most-once semantics",
          "Best-effort semantics"
        ],
        "correctAnswer": 0,
        "explanation": "Exactly-once semantics guarantee the remote procedure executes exactly once, which is ideal but difficult to achieve in practice due to failures and network issues."
      },
      {
        "id": "cs401-midterm-q7",
        "type": "multiple_choice",
        "prompt": "Why can't we rely on physical clocks alone for ordering events in distributed systems?",
        "options": [
          "Clock drift and network delays make synchronization imperfect",
          "Physical clocks are too expensive",
          "Physical clocks are not precise enough",
          "Time zones create confusion"
        ],
        "correctAnswer": 0,
        "explanation": "Physical clocks drift at different rates and network delays are variable, making perfect clock synchronization impossible and unreliable for determining event ordering."
      },
      {
        "id": "cs401-midterm-q8",
        "type": "multiple_choice",
        "prompt": "In Lamport's logical clocks, what rule applies when a process sends a message?",
        "options": [
          "Include the current logical timestamp with the message",
          "Decrement the clock",
          "Reset the clock to zero",
          "Wait for acknowledgment before incrementing"
        ],
        "correctAnswer": 0,
        "explanation": "When sending a message, the process includes its current logical timestamp, allowing the receiver to update its clock to maintain the happens-before relationship."
      },
      {
        "id": "cs401-midterm-q9",
        "type": "multiple_choice",
        "prompt": "What property do vector clocks have that Lamport clocks lack?",
        "options": [
          "Ability to detect concurrent events",
          "Lower overhead",
          "Simpler implementation",
          "Better performance"
        ],
        "correctAnswer": 0,
        "explanation": "Vector clocks can determine if two events are concurrent (neither causally precedes the other), while Lamport clocks only provide a total ordering but cannot detect concurrency."
      },
      {
        "id": "cs401-midterm-q10",
        "type": "multiple_choice",
        "prompt": "If event A sends a message and event B receives it, what is their relationship?",
        "options": [
          "A happens-before B (A → B)",
          "B happens-before A (B → A)",
          "A and B are concurrent",
          "No relationship exists"
        ],
        "correctAnswer": 0,
        "explanation": "Message sending creates a happens-before relationship: the send event causally precedes the receive event, establishing A → B in the distributed system."
      },
      {
        "id": "cs401-midterm-q11",
        "type": "multiple_choice",
        "prompt": "What does causal ordering of messages guarantee?",
        "options": [
          "If message m1 causally precedes m2, m1 is delivered before m2",
          "All messages arrive in send order",
          "Messages from same sender arrive in order",
          "No message is lost"
        ],
        "correctAnswer": 0,
        "explanation": "Causal ordering ensures causally related messages are delivered in causal order, preserving the happens-before relationship while allowing concurrent messages to be delivered in any order."
      },
      {
        "id": "cs401-midterm-q12",
        "type": "multiple_choice",
        "prompt": "How does Network Time Protocol (NTP) account for network delay?",
        "options": [
          "Measures round-trip time and estimates one-way delay",
          "Ignores delay",
          "Uses guaranteed delay bounds",
          "Requires dedicated timing networks"
        ],
        "correctAnswer": 0,
        "explanation": "NTP measures round-trip time to time servers and estimates one-way delay (typically as half the round-trip), adjusting for network delays to improve synchronization accuracy."
      },
      {
        "id": "cs401-midterm-q13",
        "type": "multiple_choice",
        "prompt": "What does the FLP impossibility result prove?",
        "options": [
          "Deterministic consensus is impossible in asynchronous systems with failures",
          "Consensus requires Byzantine fault tolerance",
          "Paxos cannot work",
          "Distributed systems are impossible"
        ],
        "correctAnswer": 0,
        "explanation": "FLP proves that no deterministic algorithm can guarantee consensus in an asynchronous system with even one crash failure, though practical systems use timeouts and partial synchrony."
      },
      {
        "id": "cs401-midterm-q14",
        "type": "multiple_choice",
        "prompt": "In two-phase commit, what happens if any participant votes \"abort\" in the prepare phase?",
        "options": [
          "The coordinator aborts the entire transaction",
          "The coordinator commits anyway",
          "Only that participant aborts",
          "The system retries the transaction"
        ],
        "correctAnswer": 0,
        "explanation": "In 2PC, all participants must vote \"commit\" for the transaction to proceed. If any participant votes \"abort\" or fails to respond, the coordinator aborts the entire transaction."
      },
      {
        "id": "cs401-midterm-q15",
        "type": "multiple_choice",
        "prompt": "What is the main problem with two-phase commit?",
        "options": [
          "Blocking if coordinator fails after prepare phase",
          "Too slow",
          "Cannot handle more than two participants",
          "Requires Byzantine fault tolerance"
        ],
        "correctAnswer": 0,
        "explanation": "If the coordinator fails after participants vote but before sending the final decision, participants are blocked and cannot unilaterally decide whether to commit or abort."
      },
      {
        "id": "cs401-midterm-q16",
        "type": "multiple_choice",
        "prompt": "In Paxos, what is required for a value to be chosen?",
        "options": [
          "Accepted by a majority of acceptors",
          "Accepted by all acceptors",
          "Proposed by the leader",
          "Accepted by any single acceptor"
        ],
        "correctAnswer": 0,
        "explanation": "Paxos requires a value to be accepted by a majority (quorum) of acceptors to be chosen, ensuring safety since any two majorities overlap."
      },
      {
        "id": "cs401-midterm-q17",
        "type": "multiple_choice",
        "prompt": "What distinguishes Raft from Paxos?",
        "options": [
          "Raft uses a strong leader and is designed for understandability",
          "Raft is faster",
          "Raft handles Byzantine failures",
          "Raft requires fewer nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Raft was designed to be more understandable than Paxos, using a strong leader model where all log entries flow from leader to followers, simplifying the algorithm."
      },
      {
        "id": "cs401-midterm-q18",
        "type": "multiple_choice",
        "prompt": "In Raft, when does a follower grant its vote to a candidate?",
        "options": [
          "If the candidate's log is at least as up-to-date as the follower's",
          "Always to the first candidate",
          "To the candidate with highest ID",
          "Randomly"
        ],
        "correctAnswer": 0,
        "explanation": "Followers only vote for candidates whose logs are at least as up-to-date, ensuring the elected leader has all committed entries and maintaining safety."
      },
      {
        "id": "cs401-midterm-q19",
        "type": "multiple_choice",
        "prompt": "What consistency model does Amazon DynamoDB use by default?",
        "options": [
          "Eventual consistency",
          "Strong consistency",
          "Causal consistency",
          "Linearizability"
        ],
        "correctAnswer": 0,
        "explanation": "DynamoDB uses eventual consistency by default for better performance and availability, though it offers strongly consistent reads as an option when needed."
      },
      {
        "id": "cs401-midterm-q20",
        "type": "multiple_choice",
        "prompt": "What is the key property of linearizability?",
        "options": [
          "Operations appear to execute instantaneously at some point between invocation and response",
          "All operations execute in program order",
          "Eventually all replicas converge",
          "Reads always see latest write from same client"
        ],
        "correctAnswer": 0,
        "explanation": "Linearizability (strongest consistency) requires operations to appear atomic and instantaneous, with a total order consistent with real-time ordering."
      },
      {
        "id": "cs401-midterm-q21",
        "type": "multiple_choice",
        "prompt": "In quorum-based replication with N=5 replicas, what is the minimum read quorum to guarantee seeing the latest write (with write quorum of 3)?",
        "options": [
          "3",
          "1",
          "5",
          "2"
        ],
        "correctAnswer": 0,
        "explanation": "Read quorum + Write quorum must exceed N to guarantee overlap. With N=5 and write quorum=3, read quorum must be at least 3 (3+3=6>5) to ensure seeing the latest write."
      },
      {
        "id": "cs401-midterm-q22",
        "type": "multiple_choice",
        "prompt": "What property must CRDT merge operations satisfy?",
        "options": [
          "Commutative, associative, and idempotent",
          "Fast and efficient",
          "Atomic and isolated",
          "Consistent and available"
        ],
        "correctAnswer": 0,
        "explanation": "CRDTs require merge operations to be commutative (order independent), associative (grouping independent), and idempotent (repeated application safe) for automatic conflict resolution."
      },
      {
        "id": "cs401-midterm-q23",
        "type": "multiple_choice",
        "prompt": "What is the main advantage of asynchronous replication?",
        "options": [
          "Lower latency and better availability",
          "Stronger consistency",
          "No data loss",
          "Simpler implementation"
        ],
        "correctAnswer": 0,
        "explanation": "Asynchronous replication doesn't wait for replicas before acknowledging writes, providing lower latency and better availability, though at the risk of data loss on failures."
      },
      {
        "id": "cs401-midterm-q24",
        "type": "multiple_choice",
        "prompt": "What does read-your-writes consistency guarantee?",
        "options": [
          "A client always sees their own previous writes",
          "All clients see all writes immediately",
          "Reads never return stale data",
          "Writes are durable"
        ],
        "correctAnswer": 0,
        "explanation": "Read-your-writes consistency ensures clients see their own updates, improving user experience even if other clients might temporarily see stale data."
      },
      {
        "id": "cs401-midterm-q25",
        "type": "multiple_choice",
        "prompt": "In primary-backup replication, what happens when the primary fails?",
        "options": [
          "A backup is promoted to become the new primary",
          "The system becomes unavailable",
          "Clients connect to random backups",
          "All data is lost"
        ],
        "correctAnswer": 0,
        "explanation": "When the primary fails, one backup is promoted to primary (through election or predetermined order), allowing the system to continue serving requests."
      },
      {
        "id": "cs401-midterm-q26",
        "type": "multiple_choice",
        "prompt": "What is the difference between state-based and operation-based CRDTs?",
        "options": [
          "State-based replicas share entire state; Op-based share operations",
          "State-based is faster",
          "Op-based uses less memory",
          "State-based handles conflicts better"
        ],
        "correctAnswer": 0,
        "explanation": "State-based CRDTs periodically share complete state and merge using semilattice join. Operation-based CRDTs share individual operations which must be commutative."
      }
    ]
  },
  {
    "id": "cs401-final",
    "subjectId": "cs401",
    "title": "CS401 Final Exam",
    "durationMinutes": 180,
    "questions": [
      {
        "id": "cs401-final-q1",
        "type": "multiple_choice",
        "prompt": "What is the fundamental tradeoff highlighted by the CAP theorem?",
        "options": [
          "During partitions, choose between consistency and availability",
          "Between performance and security",
          "Between cost and reliability",
          "Between scalability and simplicity"
        ],
        "correctAnswer": 0,
        "explanation": "CAP theorem shows that when network partitions occur, distributed systems must choose between maintaining consistency or availability; both cannot be guaranteed simultaneously."
      },
      {
        "id": "cs401-final-q2",
        "type": "multiple_choice",
        "prompt": "Why were logical clocks developed for distributed systems?",
        "options": [
          "To order events without perfect physical clock synchronization",
          "To reduce network bandwidth",
          "To improve performance",
          "To simplify programming"
        ],
        "correctAnswer": 0,
        "explanation": "Logical clocks (Lamport and vector clocks) capture causal relationships between events without requiring perfect physical clock synchronization, which is impossible in distributed systems."
      },
      {
        "id": "cs401-final-q3",
        "type": "multiple_choice",
        "prompt": "What makes consensus difficult in distributed systems?",
        "options": [
          "Asynchrony, failures, and lack of global knowledge",
          "High network latency",
          "Limited bandwidth",
          "Complex algorithms"
        ],
        "correctAnswer": 0,
        "explanation": "Consensus is difficult because of unbounded message delays (asynchrony), partial failures, and lack of global knowledge, as proven by the FLP impossibility result."
      },
      {
        "id": "cs401-final-q4",
        "type": "multiple_choice",
        "prompt": "In Raft, why is the leader election mechanism important?",
        "options": [
          "Ensures exactly one leader per term for safety",
          "Improves performance",
          "Reduces network traffic",
          "Simplifies implementation"
        ],
        "correctAnswer": 0,
        "explanation": "Raft's election ensures at most one leader per term through majority voting, preventing split-brain scenarios and maintaining safety of the replicated log."
      },
      {
        "id": "cs401-final-q5",
        "type": "multiple_choice",
        "prompt": "How many Byzantine failures can be tolerated in a system with 10 nodes using BFT?",
        "options": [
          "3 failures",
          "5 failures",
          "9 failures",
          "4 failures"
        ],
        "correctAnswer": 0,
        "explanation": "BFT requires 3f+1 nodes to tolerate f Byzantine failures. With 10 nodes: 3f+1≤10, so f≤3. The system can tolerate 3 Byzantine failures."
      },
      {
        "id": "cs401-final-q6",
        "type": "multiple_choice",
        "prompt": "What is the difference between fail-stop and Byzantine failures?",
        "options": [
          "Fail-stop processes halt; Byzantine processes exhibit arbitrary behavior",
          "Fail-stop is more severe",
          "Byzantine failures are easier to detect",
          "Fail-stop requires more nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Fail-stop failures involve processes halting (detectable), while Byzantine failures involve arbitrary/malicious behavior (corrupted messages, lies), which is harder to handle."
      },
      {
        "id": "cs401-final-q7",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a failure detector in distributed systems?",
        "options": [
          "Monitor processes and suspect failures using timeouts",
          "Prevent failures from occurring",
          "Recover from failures automatically",
          "Log all system events"
        ],
        "correctAnswer": 0,
        "explanation": "Failure detectors monitor processes (via heartbeats) and use timeouts to suspect failures, though they may make mistakes in asynchronous systems."
      },
      {
        "id": "cs401-final-q8",
        "type": "multiple_choice",
        "prompt": "What does an eventually perfect failure detector guarantee?",
        "options": [
          "Eventually stops making mistakes about correct processes",
          "Never makes any mistakes",
          "Detects failures instantly",
          "Works in fully asynchronous systems"
        ],
        "correctAnswer": 0,
        "explanation": "Eventually perfect detectors may initially suspect correct processes but eventually stabilize and accurately identify crashed vs. correct processes."
      },
      {
        "id": "cs401-final-q9",
        "type": "multiple_choice",
        "prompt": "How does checkpointing help with fault tolerance?",
        "options": [
          "Allows recovery to a consistent state after failures",
          "Prevents failures",
          "Detects failures faster",
          "Reduces network traffic"
        ],
        "correctAnswer": 0,
        "explanation": "Checkpointing saves process state periodically, enabling recovery to a known consistent state after failure without restarting from the beginning."
      },
      {
        "id": "cs401-final-q10",
        "type": "multiple_choice",
        "prompt": "When should a circuit breaker transition from Closed to Open state?",
        "options": [
          "When failure rate exceeds a threshold",
          "After a fixed time period",
          "When load increases",
          "Randomly"
        ],
        "correctAnswer": 0,
        "explanation": "Circuit breakers monitor failure rates and open when failures exceed a threshold, preventing calls to failing services and allowing time for recovery."
      },
      {
        "id": "cs401-final-q11",
        "type": "multiple_choice",
        "prompt": "What is the purpose of the Half-Open state in circuit breakers?",
        "options": [
          "Test if the service has recovered with limited requests",
          "Partially block traffic",
          "Gradual shutdown",
          "Load balancing"
        ],
        "correctAnswer": 0,
        "explanation": "Half-Open state allows a few test requests through to determine if the service has recovered, transitioning back to Closed if successful or Open if still failing."
      },
      {
        "id": "cs401-final-q12",
        "type": "multiple_choice",
        "prompt": "What is the bulkhead pattern designed to prevent?",
        "options": [
          "Cascading failures across system components",
          "Network congestion",
          "Data corruption",
          "Unauthorized access"
        ],
        "correctAnswer": 0,
        "explanation": "Bulkhead pattern isolates resources (thread pools, connections) so failures in one component don't exhaust resources and cascade to other parts of the system."
      },
      {
        "id": "cs401-final-q13",
        "type": "multiple_choice",
        "prompt": "Why use exponential backoff for retries?",
        "options": [
          "Avoid overwhelming recovering services with retry storms",
          "Guarantee eventual success",
          "Reduce implementation complexity",
          "Improve performance"
        ],
        "correctAnswer": 0,
        "explanation": "Exponential backoff increases delays between retries, preventing retry storms that could overwhelm a recovering service and giving it time to stabilize."
      },
      {
        "id": "cs401-final-q14",
        "type": "multiple_choice",
        "prompt": "What challenge does setting timeouts in distributed systems face?",
        "options": [
          "Distinguishing between slow responses and failures",
          "Implementation complexity",
          "High CPU usage",
          "Memory overhead"
        ],
        "correctAnswer": 0,
        "explanation": "Setting timeouts is difficult because you must distinguish between legitimately slow responses and actual failures, balancing false positives vs. detection speed."
      },
      {
        "id": "cs401-final-q15",
        "type": "multiple_choice",
        "prompt": "What problem does consistent hashing solve?",
        "options": [
          "Minimizing data movement when nodes are added/removed",
          "Data encryption",
          "Load balancing",
          "Replication"
        ],
        "correctAnswer": 0,
        "explanation": "Consistent hashing maps data and nodes to a ring, so adding/removing nodes only requires remapping a small fraction of keys, minimizing data movement."
      },
      {
        "id": "cs401-final-q16",
        "type": "multiple_choice",
        "prompt": "In MapReduce, what happens between Map and Reduce phases?",
        "options": [
          "Shuffle and sort groups values by key",
          "Data validation",
          "Compression",
          "Encryption"
        ],
        "correctAnswer": 0,
        "explanation": "The shuffle phase groups all values for each key together and sorts them, preparing data for the Reduce phase which processes each key's values."
      },
      {
        "id": "cs401-final-q17",
        "type": "multiple_choice",
        "prompt": "How does HDFS achieve fault tolerance?",
        "options": [
          "Replicating blocks across multiple DataNodes",
          "RAID storage",
          "Daily backups",
          "Erasure coding only"
        ],
        "correctAnswer": 0,
        "explanation": "HDFS replicates each block (typically 3 copies) across different DataNodes and racks, ensuring data survives individual node and rack failures."
      },
      {
        "id": "cs401-final-q18",
        "type": "multiple_choice",
        "prompt": "What is the role of the NameNode in HDFS?",
        "options": [
          "Manages file system metadata and namespace",
          "Stores actual file data",
          "Processes computation",
          "Handles authentication"
        ],
        "correctAnswer": 0,
        "explanation": "NameNode is the master that manages metadata (file-to-block mapping, locations) while DataNodes store actual blocks, making NameNode critical for file system operations."
      },
      {
        "id": "cs401-final-q19",
        "type": "multiple_choice",
        "prompt": "What is data locality in distributed processing?",
        "options": [
          "Scheduling computation where data is already stored",
          "Storing data in local caches",
          "Using local databases",
          "Regional data centers"
        ],
        "correctAnswer": 0,
        "explanation": "Data locality schedules tasks on nodes that already have the required data, minimizing network transfer and improving performance in systems like MapReduce."
      },
      {
        "id": "cs401-final-q20",
        "type": "multiple_choice",
        "prompt": "What distinguishes stream processing from batch processing?",
        "options": [
          "Stream processes unbounded data continuously; Batch processes bounded datasets",
          "Stream is slower",
          "Batch uses less memory",
          "Stream is simpler"
        ],
        "correctAnswer": 0,
        "explanation": "Stream processing handles continuous unbounded data streams with low latency, while batch processing handles complete bounded datasets with higher latency but simpler semantics."
      },
      {
        "id": "cs401-final-q21",
        "type": "multiple_choice",
        "prompt": "What is sharding in distributed databases?",
        "options": [
          "Horizontally partitioning data across nodes by a shard key",
          "Encrypting sensitive data",
          "Caching frequently accessed data",
          "Replicating data for availability"
        ],
        "correctAnswer": 0,
        "explanation": "Sharding splits data horizontally across nodes using a shard key (e.g., user ID ranges), distributing load and enabling scaling beyond single-node capacity."
      },
      {
        "id": "cs401-final-q22",
        "type": "multiple_choice",
        "prompt": "What is the primary advantage of NoSQL databases over relational databases?",
        "options": [
          "Better horizontal scalability and flexible schemas",
          "ACID transactions",
          "SQL query support",
          "Lower cost"
        ],
        "correctAnswer": 0,
        "explanation": "NoSQL databases sacrifice some ACID guarantees for better horizontal scalability and schema flexibility, making them suitable for large-scale distributed applications."
      },
      {
        "id": "cs401-final-q23",
        "type": "multiple_choice",
        "prompt": "What type of NoSQL database is Cassandra?",
        "options": [
          "Column-family store",
          "Document store",
          "Key-value store",
          "Graph database"
        ],
        "correctAnswer": 0,
        "explanation": "Cassandra is a column-family store that groups related columns together, optimized for high write throughput and massive scale across distributed nodes."
      },
      {
        "id": "cs401-final-q24",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a distributed cache like Redis?",
        "options": [
          "Provide low-latency access to frequently used data",
          "Permanent data storage",
          "Data processing",
          "Authentication"
        ],
        "correctAnswer": 0,
        "explanation": "Distributed caches store frequently accessed data in memory across nodes, providing microsecond latency and reducing load on backend databases."
      },
      {
        "id": "cs401-final-q25",
        "type": "multiple_choice",
        "prompt": "What is the primary role of an API Gateway?",
        "options": [
          "Single entry point routing requests to microservices",
          "Data storage",
          "Service implementation",
          "Database management"
        ],
        "correctAnswer": 0,
        "explanation": "API Gateways provide a unified entry point, routing requests to appropriate microservices while handling authentication, rate limiting, and other cross-cutting concerns."
      },
      {
        "id": "cs401-final-q26",
        "type": "multiple_choice",
        "prompt": "What does a service mesh provide?",
        "options": [
          "Infrastructure for service-to-service communication",
          "Data storage",
          "User interface",
          "Database clustering"
        ],
        "correctAnswer": 0,
        "explanation": "Service meshes (like Istio) handle service-to-service communication, providing features like load balancing, encryption, observability, and resilience without changing application code."
      },
      {
        "id": "cs401-final-q27",
        "type": "multiple_choice",
        "prompt": "How do Saga patterns handle distributed transactions?",
        "options": [
          "Break into local transactions with compensating actions",
          "Use two-phase commit",
          "Use distributed locks",
          "Require global transactions"
        ],
        "correctAnswer": 0,
        "explanation": "Sagas split distributed transactions into local transactions on each service, using compensating transactions to undo changes if any step fails, avoiding distributed locks."
      },
      {
        "id": "cs401-final-q28",
        "type": "multiple_choice",
        "prompt": "What is the difference between orchestration and choreography in Sagas?",
        "options": [
          "Orchestration uses central coordinator; Choreography uses events",
          "Orchestration is faster",
          "Choreography is simpler",
          "Orchestration uses fewer resources"
        ],
        "correctAnswer": 0,
        "explanation": "Orchestration sagas use a central coordinator directing each step. Choreography sagas use events where services listen and react, trading centralized control for loose coupling."
      },
      {
        "id": "cs401-final-q29",
        "type": "multiple_choice",
        "prompt": "What is event sourcing?",
        "options": [
          "Storing all state changes as an immutable event log",
          "Publishing events to message queues",
          "Event-driven architecture",
          "Real-time event processing"
        ],
        "correctAnswer": 0,
        "explanation": "Event sourcing persists all state changes as events in an append-only log, enabling state reconstruction, audit trails, and time-travel queries."
      },
      {
        "id": "cs401-final-q30",
        "type": "multiple_choice",
        "prompt": "What does CQRS (Command Query Responsibility Segregation) separate?",
        "options": [
          "Read and write data models",
          "Commands and queries syntactically",
          "Frontend and backend",
          "Synchronous and asynchronous operations"
        ],
        "correctAnswer": 0,
        "explanation": "CQRS separates the models for reading and writing data, allowing independent optimization, scaling, and evolution of each side, often paired with event sourcing."
      },
      {
        "id": "cs401-final-q31",
        "type": "multiple_choice",
        "prompt": "What is distributed tracing used for?",
        "options": [
          "Track requests across multiple microservices",
          "Debug single applications",
          "Monitor CPU usage",
          "Log aggregation"
        ],
        "correctAnswer": 0,
        "explanation": "Distributed tracing (Jaeger, Zipkin) tracks requests as they flow through microservices, identifying latency bottlenecks, failures, and service dependencies."
      },
      {
        "id": "cs401-final-q32",
        "type": "multiple_choice",
        "prompt": "What is the sidecar pattern?",
        "options": [
          "Deploying helper containers alongside main application containers",
          "Backup services",
          "Load balancing strategy",
          "Data replication method"
        ],
        "correctAnswer": 0,
        "explanation": "Sidecar pattern deploys auxiliary containers (for logging, monitoring, proxying) alongside application containers in the same pod, extending functionality without code changes."
      },
      {
        "id": "cs401-final-q33",
        "type": "multiple_choice",
        "prompt": "What is the strangler fig pattern used for?",
        "options": [
          "Gradually migrating from legacy to new systems",
          "Removing dead code",
          "Performance optimization",
          "Security hardening"
        ],
        "correctAnswer": 0,
        "explanation": "Strangler fig pattern incrementally replaces legacy systems by routing increasing traffic to new implementations while maintaining old ones until complete replacement."
      },
      {
        "id": "cs401-final-q34",
        "type": "multiple_choice",
        "prompt": "Why implement rate limiting in distributed systems?",
        "options": [
          "Protect services from overload and ensure fair usage",
          "Improve performance",
          "Reduce costs",
          "Simplify implementation"
        ],
        "correctAnswer": 0,
        "explanation": "Rate limiting controls request rates to prevent service overload, implement fair usage policies, and protect against denial-of-service attacks."
      },
      {
        "id": "cs401-final-q35",
        "type": "multiple_choice",
        "prompt": "What is the difference between horizontal and vertical scaling?",
        "options": [
          "Horizontal adds machines; Vertical adds resources to existing machines",
          "Horizontal is always better",
          "Vertical is cheaper",
          "Horizontal is simpler"
        ],
        "correctAnswer": 0,
        "explanation": "Horizontal scaling (scale-out) adds more machines for virtually unlimited capacity. Vertical scaling (scale-up) adds CPU/RAM to existing machines but has hardware limits."
      },
      {
        "id": "cs401-final-q36",
        "type": "multiple_choice",
        "prompt": "What is backpressure in distributed systems?",
        "options": [
          "Feedback mechanism where consumers signal producers to slow down",
          "Network congestion",
          "Database load",
          "Memory pressure"
        ],
        "correctAnswer": 0,
        "explanation": "Backpressure allows overloaded consumers to signal producers to slow down, preventing buffer overflow and maintaining system stability under varying load."
      },
      {
        "id": "cs401-final-q37",
        "type": "multiple_choice",
        "prompt": "Why is idempotency important in distributed systems?",
        "options": [
          "Allows safe retries of operations without side effects",
          "Improves performance",
          "Reduces complexity",
          "Saves bandwidth"
        ],
        "correctAnswer": 0,
        "explanation": "Idempotent operations produce the same result when executed multiple times, making them safe to retry on failures and handle duplicate messages without adverse effects."
      },
      {
        "id": "cs401-final-q38",
        "type": "multiple_choice",
        "prompt": "What is the purpose of message queues in microservices?",
        "options": [
          "Enable asynchronous communication and decouple services",
          "Synchronous RPC",
          "Data storage",
          "Load balancing"
        ],
        "correctAnswer": 0,
        "explanation": "Message queues enable asynchronous communication, decoupling services temporally and spatially, buffering during load spikes, and providing reliable delivery."
      },
      {
        "id": "cs401-final-q39",
        "type": "multiple_choice",
        "prompt": "What does exactly-once message delivery guarantee?",
        "options": [
          "Each message is processed exactly one time",
          "Messages arrive quickly",
          "Messages are never lost",
          "Messages arrive in order"
        ],
        "correctAnswer": 0,
        "explanation": "Exactly-once delivery guarantees each message is processed exactly once (not lost, not duplicated), which is the strongest but most expensive delivery guarantee to implement."
      },
      {
        "id": "cs401-final-q40",
        "type": "multiple_choice",
        "prompt": "What is the tradeoff between at-least-once and at-most-once delivery?",
        "options": [
          "At-least-once may duplicate; At-most-once may lose messages",
          "At-least-once is faster",
          "At-most-once uses less bandwidth",
          "At-least-once is simpler"
        ],
        "correctAnswer": 0,
        "explanation": "At-least-once guarantees delivery but may duplicate messages (requiring idempotent processing). At-most-once never duplicates but may lose messages on failures."
      },
      {
        "id": "cs401-final-q41",
        "type": "multiple_choice",
        "prompt": "What is the purpose of load balancing in distributed systems?",
        "options": [
          "Distribute requests evenly across multiple servers",
          "Increase server capacity",
          "Reduce latency",
          "Improve security"
        ],
        "correctAnswer": 0,
        "explanation": "Load balancers distribute incoming requests across multiple servers, improving resource utilization, preventing overload, and providing fault tolerance through redundancy."
      },
      {
        "id": "cs401-final-q42",
        "type": "multiple_choice",
        "prompt": "What metric is most important for measuring distributed system reliability?",
        "options": [
          "Availability (uptime percentage)",
          "Throughput",
          "Latency",
          "Cost"
        ],
        "correctAnswer": 0,
        "explanation": "Availability (percentage of time the system is operational) is the primary reliability metric, often measured in \"nines\" (99.9%, 99.99%, etc.), directly impacting user experience."
      }
    ]
  }
]

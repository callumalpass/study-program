[
  {
    "id": "cs404-ex-1-1",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Create MoSCoW Prioritization Function",
    "difficulty": 1,
    "description": "Implement a function that categorizes project features using the MoSCoW prioritization method.\n\nCreate a TypeScript function that takes a list of features with their importance and effort scores, and categorizes them into Must Have, Should Have, Could Have, and Won't Have categories based on a scoring algorithm.\n\nFeatures with high importance and feasible effort are Must Have.\nFeatures with moderate importance are Should Have.\nFeatures with low effort but low importance are Could Have.\nFeatures with very high effort and low importance are Won't Have.",
    "starterCode": "interface Feature {\n  name: string;\n  importance: number; // 1-10\n  effort: number; // 1-10\n}\n\ntype MoSCoWCategory = 'Must Have' | 'Should Have' | 'Could Have' | \"Won't Have\";\n\ninterface CategorizedFeature extends Feature {\n  category: MoSCoWCategory;\n}\n\nfunction prioritizeFeatures(features: Feature[]): CategorizedFeature[] {\n  // TODO: Implement MoSCoW prioritization logic\n  return [];\n}\n\n// Test cases\nconst features: Feature[] = [\n  { name: 'User Authentication', importance: 10, effort: 5 },\n  { name: 'Dark Mode', importance: 3, effort: 2 },\n  { name: 'Social Media Sharing', importance: 4, effort: 3 },\n  { name: 'Video Upload', importance: 2, effort: 9 },\n  { name: 'Activity Logging', importance: 9, effort: 4 },\n];\n\nconsole.log(prioritizeFeatures(features));",
    "solution": "interface Feature {\n  name: string;\n  importance: number; // 1-10\n  effort: number; // 1-10\n}\n\ntype MoSCoWCategory = 'Must Have' | 'Should Have' | 'Could Have' | \"Won't Have\";\n\ninterface CategorizedFeature extends Feature {\n  category: MoSCoWCategory;\n}\n\nfunction prioritizeFeatures(features: Feature[]): CategorizedFeature[] {\n  return features.map(feature => {\n    const { importance, effort } = feature;\n    \n    // Calculate priority score (higher importance / lower effort = higher priority)\n    const priorityScore = importance / effort;\n    \n    // Categorize based on importance and effort\n    let category: MoSCoWCategory;\n    \n    if (importance >= 8 && effort <= 7) {\n      // High importance, reasonable effort -> Must Have\n      category = 'Must Have';\n    } else if (importance >= 6 && effort <= 8) {\n      // Moderate importance, reasonable effort -> Should Have\n      category = 'Should Have';\n    } else if (effort > 8 || importance < 4) {\n      // Very high effort or low importance -> Won't Have\n      category = \"Won't Have\";\n    } else {\n      // Everything else -> Could Have\n      category = 'Could Have';\n    }\n    \n    return {\n      ...feature,\n      category\n    };\n  });\n}\n\n// Test cases\nconst features: Feature[] = [\n  { name: 'User Authentication', importance: 10, effort: 5 },\n  { name: 'Dark Mode', importance: 3, effort: 2 },\n  { name: 'Social Media Sharing', importance: 4, effort: 3 },\n  { name: 'Video Upload', importance: 2, effort: 9 },\n  { name: 'Activity Logging', importance: 9, effort: 4 },\n];\n\nconst prioritized = prioritizeFeatures(features);\nconsole.log(prioritized);\n\n/*\nOutput:\n[\n  { name: 'User Authentication', importance: 10, effort: 5, category: 'Must Have' },\n  { name: 'Dark Mode', importance: 3, effort: 2, category: 'Could Have' },\n  { name: 'Social Media Sharing', importance: 4, effort: 3, category: 'Could Have' },\n  { name: 'Video Upload', importance: 2, effort: 9, category: \"Won't Have\" },\n  { name: 'Activity Logging', importance: 9, effort: 4, category: 'Must Have' }\n]\n*/",
    "hints": [
      "Calculate a priority score based on importance/effort ratio",
      "Use threshold values to categorize features",
      "Consider both importance and effort in your logic",
      "Must Have: high importance, feasible effort",
      "Won't Have: very high effort OR very low importance"
    ],
    "testCases": [
      {
        "input": "[{ name: \"Feature A\", importance: 10, effort: 3 }]",
        "expectedOutput": "[{ name: \"Feature A\", importance: 10, effort: 3, category: \"Must Have\" }]",
        "isHidden": false,
        "description": "High importance, low effort should be Must Have"
      },
      {
        "input": "[{ name: \"Feature B\", importance: 2, effort: 9 }]",
        "expectedOutput": "[{ name: \"Feature B\", importance: 2, effort: 9, category: \"Won't Have\" }]",
        "isHidden": false,
        "description": "Low importance, high effort should be Won't Have"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-2",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Calculate Three-Point Time Estimates",
    "difficulty": 1,
    "description": "Implement a function to calculate expected task duration using three-point estimation.\n\nCreate a function that takes optimistic, most likely, and pessimistic time estimates for tasks and calculates the expected duration using the formula: (O + 4M + P) / 6\n\nThis is a common estimation technique in project management that accounts for uncertainty.",
    "starterCode": "interface TaskEstimate {\n  task: string;\n  optimistic: number;  // Best case (hours)\n  mostLikely: number;  // Realistic estimate (hours)\n  pessimistic: number; // Worst case (hours)\n}\n\ninterface TaskDuration extends TaskEstimate {\n  expectedDuration: number;\n  standardDeviation: number;\n}\n\nfunction calculateTaskDurations(tasks: TaskEstimate[]): TaskDuration[] {\n  // TODO: Implement three-point estimation\n  // Expected Duration = (O + 4M + P) / 6\n  // Standard Deviation = (P - O) / 6\n  return [];\n}\n\nconst tasks: TaskEstimate[] = [\n  { task: 'User Authentication', optimistic: 3, mostLikely: 6, pessimistic: 12 },\n  { task: 'Database Setup', optimistic: 2, mostLikely: 4, pessimistic: 8 },\n];\n\nconsole.log(calculateTaskDurations(tasks));",
    "solution": "interface TaskEstimate {\n  task: string;\n  optimistic: number;  // Best case (hours)\n  mostLikely: number;  // Realistic estimate (hours)\n  pessimistic: number; // Worst case (hours)\n}\n\ninterface TaskDuration extends TaskEstimate {\n  expectedDuration: number;\n  standardDeviation: number;\n}\n\nfunction calculateTaskDurations(tasks: TaskEstimate[]): TaskDuration[] {\n  return tasks.map(task => {\n    const { optimistic, mostLikely, pessimistic } = task;\n    \n    // Three-point estimation formula\n    const expectedDuration = (optimistic + 4 * mostLikely + pessimistic) / 6;\n    \n    // Standard deviation shows uncertainty\n    const standardDeviation = (pessimistic - optimistic) / 6;\n    \n    return {\n      ...task,\n      expectedDuration: Math.round(expectedDuration * 10) / 10, // Round to 1 decimal\n      standardDeviation: Math.round(standardDeviation * 10) / 10\n    };\n  });\n}\n\nconst tasks: TaskEstimate[] = [\n  { task: 'User Authentication', optimistic: 3, mostLikely: 6, pessimistic: 12 },\n  { task: 'Database Setup', optimistic: 2, mostLikely: 4, pessimistic: 8 },\n  { task: 'Frontend Dashboard', optimistic: 8, mostLikely: 12, pessimistic: 20 },\n];\n\nconst durations = calculateTaskDurations(tasks);\nconsole.log(durations);\n\n// Calculate total project duration\nconst totalDuration = durations.reduce((sum, task) => sum + task.expectedDuration, 0);\nconsole.log(`Total expected duration: ${totalDuration} hours`);\n\n/*\nOutput:\n[\n  {\n    task: 'User Authentication',\n    optimistic: 3,\n    mostLikely: 6,\n    pessimistic: 12,\n    expectedDuration: 6.5,\n    standardDeviation: 1.5\n  },\n  {\n    task: 'Database Setup',\n    optimistic: 2,\n    mostLikely: 4,\n    pessimistic: 8,\n    expectedDuration: 4.3,\n    standardDeviation: 1.0\n  },\n  {\n    task: 'Frontend Dashboard',\n    optimistic: 8,\n    mostLikely: 12,\n    pessimistic: 20,\n    expectedDuration: 12.7,\n    standardDeviation: 2.0\n  }\n]\nTotal expected duration: 23.5 hours\n*/",
    "hints": [
      "Use the formula: (O + 4M + P) / 6 for expected duration",
      "Standard deviation shows uncertainty: (P - O) / 6",
      "Round results to reasonable precision (1 decimal place)",
      "Higher standard deviation means more uncertainty"
    ],
    "testCases": [
      {
        "input": "{ optimistic: 4, mostLikely: 6, pessimistic: 8 }",
        "expectedOutput": "expectedDuration: 6.0",
        "isHidden": false,
        "description": "Calculate expected duration with balanced estimates"
      },
      {
        "input": "{ optimistic: 1, mostLikely: 5, pessimistic: 15 }",
        "expectedOutput": "expectedDuration: 6.0, standardDeviation: 2.3",
        "isHidden": false,
        "description": "Calculate with wide range showing high uncertainty"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-3",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Risk Assessment Calculator",
    "difficulty": 3,
    "description": "Create a risk assessment tool that calculates risk exposure and prioritizes risks.\n\nBuild a function that takes risks with probability and impact scores, calculates risk exposure, and categorizes them by priority.\n\nRisk Exposure = Probability × Impact\n\nPriority levels:\n- Critical: exposure >= 15\n- High: exposure >= 10\n- Medium: exposure >= 5\n- Low: exposure < 5",
    "starterCode": "interface Risk {\n  id: string;\n  description: string;\n  probability: number; // 1-5 scale\n  impact: number; // 1-5 scale\n}\n\ninterface AssessedRisk extends Risk {\n  exposure: number;\n  priority: 'Critical' | 'High' | 'Medium' | 'Low';\n}\n\nfunction assessRisks(risks: Risk[]): AssessedRisk[] {\n  // TODO: Calculate risk exposure and assign priority\n  return [];\n}\n\nconst risks: Risk[] = [\n  { id: 'R1', description: 'API deprecated during development', probability: 2, impact: 5 },\n  { id: 'R2', description: 'Task underestimation', probability: 5, impact: 3 },\n  { id: 'R3', description: 'Hard drive failure', probability: 1, impact: 5 },\n];\n\nconsole.log(assessRisks(risks));",
    "solution": "interface Risk {\n  id: string;\n  description: string;\n  probability: number; // 1-5 scale\n  impact: number; // 1-5 scale\n}\n\ninterface AssessedRisk extends Risk {\n  exposure: number;\n  priority: 'Critical' | 'High' | 'Medium' | 'Low';\n}\n\nfunction assessRisks(risks: Risk[]): AssessedRisk[] {\n  const assessed = risks.map(risk => {\n    // Calculate risk exposure\n    const exposure = risk.probability * risk.impact;\n    \n    // Assign priority based on exposure\n    let priority: 'Critical' | 'High' | 'Medium' | 'Low';\n    if (exposure >= 15) {\n      priority = 'Critical';\n    } else if (exposure >= 10) {\n      priority = 'High';\n    } else if (exposure >= 5) {\n      priority = 'Medium';\n    } else {\n      priority = 'Low';\n    }\n    \n    return {\n      ...risk,\n      exposure,\n      priority\n    };\n  });\n  \n  // Sort by exposure (highest first)\n  return assessed.sort((a, b) => b.exposure - a.exposure);\n}\n\nconst risks: Risk[] = [\n  { id: 'R1', description: 'API deprecated during development', probability: 2, impact: 5 },\n  { id: 'R2', description: 'Task underestimation', probability: 5, impact: 3 },\n  { id: 'R3', description: 'Hard drive failure', probability: 1, impact: 5 },\n  { id: 'R4', description: 'Learning curve for new tech', probability: 4, impact: 4 },\n  { id: 'R5', description: 'Minor UI bug', probability: 3, impact: 1 },\n];\n\nconst assessed = assessRisks(risks);\nconsole.log('Risk Assessment Results:');\nconsole.log('========================');\nassessed.forEach(risk => {\n  console.log(`${risk.priority} - ${risk.description}`);\n  console.log(`  Probability: ${risk.probability}, Impact: ${risk.impact}, Exposure: ${risk.exposure}`);\n  console.log();\n});\n\n/*\nOutput:\nRisk Assessment Results:\n========================\nHigh - Learning curve for new tech\n  Probability: 4, Impact: 4, Exposure: 16\n\nHigh - Task underestimation\n  Probability: 5, Impact: 3, Exposure: 15\n\nHigh - API deprecated during development\n  Probability: 2, Impact: 5, Exposure: 10\n\nMedium - Hard drive failure\n  Probability: 1, Impact: 5, Exposure: 5\n\nLow - Minor UI bug\n  Probability: 3, Impact: 1, Exposure: 3\n*/",
    "hints": [
      "Risk Exposure = Probability × Impact",
      "Sort risks by exposure (highest priority first)",
      "Use clear threshold values for priority categories",
      "High probability + high impact = critical risk"
    ],
    "testCases": [
      {
        "input": "{ probability: 5, impact: 5 }",
        "expectedOutput": "{ exposure: 25, priority: \"Critical\" }",
        "isHidden": false,
        "description": "Maximum risk should be Critical priority"
      },
      {
        "input": "{ probability: 1, impact: 2 }",
        "expectedOutput": "{ exposure: 2, priority: \"Low\" }",
        "isHidden": false,
        "description": "Low probability and impact should be Low priority"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-4",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "User Story Validator",
    "difficulty": 2,
    "description": "Create a function that validates user stories follow the correct format.\n\nA valid user story must:\n- Start with \"As a\"\n- Contain \"I want to\" or \"I want\"\n- Contain \"so that\" or \"so\"\n- Be between 20 and 200 characters\n\nReturn validation results with specific error messages.",
    "starterCode": "interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nfunction validateUserStory(story: string): ValidationResult {\n  // TODO: Implement user story validation\n  return { isValid: false, errors: [] };\n}\n\n// Test cases\nconsole.log(validateUserStory('As a user, I want to log in so that I can access my account'));\nconsole.log(validateUserStory('Add login feature'));\nconsole.log(validateUserStory('As a user'));",
    "solution": "interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nfunction validateUserStory(story: string): ValidationResult {\n  const errors: string[] = [];\n\n  // Check length\n  if (story.length < 20) {\n    errors.push('Story is too short (minimum 20 characters)');\n  }\n  if (story.length > 200) {\n    errors.push('Story is too long (maximum 200 characters)');\n  }\n\n  // Check format components\n  if (!story.toLowerCase().startsWith('as a')) {\n    errors.push('Story must start with \"As a\"');\n  }\n\n  if (!story.toLowerCase().includes('i want')) {\n    errors.push('Story must contain \"I want to\" or \"I want\"');\n  }\n\n  if (!story.toLowerCase().includes('so that') && !story.toLowerCase().includes('so ')) {\n    errors.push('Story must contain \"so that\" or \"so\" to explain the benefit');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n// Test cases\nconsole.log(validateUserStory('As a user, I want to log in so that I can access my account'));\n// { isValid: true, errors: [] }\n\nconsole.log(validateUserStory('Add login feature'));\n// { isValid: false, errors: [...] }\n\nconsole.log(validateUserStory('As a user'));\n// { isValid: false, errors: ['Story is too short...', 'Story must contain \"I want\"', ...] }",
    "hints": [
      "Use toLowerCase() for case-insensitive matching",
      "Check each component separately and collect errors",
      "Return isValid: true only if errors array is empty",
      "Use includes() to check for required phrases"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-5",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Milestone Tracker",
    "difficulty": 2,
    "description": "Build a milestone tracking system that calculates completion percentage and identifies overdue milestones.\n\nEach milestone has a title, target date, completion status, and weight (importance).\nCalculate overall project completion and list overdue milestones.",
    "starterCode": "interface Milestone {\n  title: string;\n  targetDate: Date;\n  completed: boolean;\n  weight: number; // 1-10\n}\n\ninterface ProjectStatus {\n  completionPercentage: number;\n  overdueMilestones: string[];\n  onTrack: boolean;\n}\n\nfunction trackMilestones(milestones: Milestone[], currentDate: Date): ProjectStatus {\n  // TODO: Calculate completion and identify overdue milestones\n  return { completionPercentage: 0, overdueMilestones: [], onTrack: true };\n}",
    "solution": "interface Milestone {\n  title: string;\n  targetDate: Date;\n  completed: boolean;\n  weight: number; // 1-10\n}\n\ninterface ProjectStatus {\n  completionPercentage: number;\n  overdueMilestones: string[];\n  onTrack: boolean;\n}\n\nfunction trackMilestones(milestones: Milestone[], currentDate: Date): ProjectStatus {\n  const totalWeight = milestones.reduce((sum, m) => sum + m.weight, 0);\n  const completedWeight = milestones\n    .filter(m => m.completed)\n    .reduce((sum, m) => sum + m.weight, 0);\n\n  const completionPercentage = totalWeight > 0\n    ? Math.round((completedWeight / totalWeight) * 100)\n    : 0;\n\n  const overdueMilestones = milestones\n    .filter(m => !m.completed && m.targetDate < currentDate)\n    .map(m => m.title);\n\n  const onTrack = overdueMilestones.length === 0;\n\n  return {\n    completionPercentage,\n    overdueMilestones,\n    onTrack\n  };\n}\n\n// Example usage\nconst milestones: Milestone[] = [\n  { title: 'Project Proposal', targetDate: new Date('2024-01-15'), completed: true, weight: 5 },\n  { title: 'Database Design', targetDate: new Date('2024-02-01'), completed: true, weight: 8 },\n  { title: 'API Implementation', targetDate: new Date('2024-02-15'), completed: false, weight: 10 },\n  { title: 'Frontend MVP', targetDate: new Date('2024-03-01'), completed: false, weight: 10 },\n];\n\nconst status = trackMilestones(milestones, new Date('2024-02-20'));\nconsole.log(status);\n// { completionPercentage: 39, overdueMilestones: ['API Implementation'], onTrack: false }",
    "hints": [
      "Use weighted completion: completed weight / total weight",
      "Filter for incomplete milestones with past target dates",
      "onTrack is true when no overdue milestones exist",
      "Use reduce() to sum milestone weights"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-6",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Sprint Capacity Calculator",
    "difficulty": 2,
    "description": "Calculate sprint capacity based on team availability and task complexity.\n\nGiven team members with their available hours per week and tasks with estimated hours,\ndetermine if the sprint is over-capacity and calculate utilization percentage.",
    "starterCode": "interface TeamMember {\n  name: string;\n  hoursPerWeek: number;\n}\n\ninterface Task {\n  title: string;\n  estimatedHours: number;\n}\n\ninterface SprintCapacity {\n  totalCapacity: number;\n  plannedWork: number;\n  utilization: number; // percentage\n  overCapacity: boolean;\n}\n\nfunction calculateSprintCapacity(\n  team: TeamMember[],\n  tasks: Task[],\n  sprintWeeks: number\n): SprintCapacity {\n  // TODO: Calculate sprint capacity and utilization\n  return { totalCapacity: 0, plannedWork: 0, utilization: 0, overCapacity: false };\n}",
    "solution": "interface TeamMember {\n  name: string;\n  hoursPerWeek: number;\n}\n\ninterface Task {\n  title: string;\n  estimatedHours: number;\n}\n\ninterface SprintCapacity {\n  totalCapacity: number;\n  plannedWork: number;\n  utilization: number; // percentage\n  overCapacity: boolean;\n}\n\nfunction calculateSprintCapacity(\n  team: TeamMember[],\n  tasks: Task[],\n  sprintWeeks: number\n): SprintCapacity {\n  // Calculate total team capacity\n  const totalCapacity = team.reduce((sum, member) => {\n    return sum + (member.hoursPerWeek * sprintWeeks);\n  }, 0);\n\n  // Calculate total planned work\n  const plannedWork = tasks.reduce((sum, task) => {\n    return sum + task.estimatedHours;\n  }, 0);\n\n  // Calculate utilization percentage\n  const utilization = totalCapacity > 0\n    ? Math.round((plannedWork / totalCapacity) * 100)\n    : 0;\n\n  // Check if over capacity (>85% is considered risky)\n  const overCapacity = utilization > 85;\n\n  return {\n    totalCapacity,\n    plannedWork,\n    utilization,\n    overCapacity\n  };\n}\n\n// Example usage\nconst team: TeamMember[] = [\n  { name: 'Alice', hoursPerWeek: 40 },\n  { name: 'Bob', hoursPerWeek: 30 }, // Part-time\n  { name: 'Carol', hoursPerWeek: 40 }\n];\n\nconst tasks: Task[] = [\n  { title: 'User Authentication', estimatedHours: 20 },\n  { title: 'Database Setup', estimatedHours: 15 },\n  { title: 'API Endpoints', estimatedHours: 30 },\n  { title: 'Frontend Components', estimatedHours: 40 },\n];\n\nconst sprint = calculateSprintCapacity(team, tasks, 2);\nconsole.log(sprint);\n// { totalCapacity: 220, plannedWork: 105, utilization: 48, overCapacity: false }",
    "hints": [
      "Total capacity = sum of (member hours/week × sprint weeks)",
      "Planned work = sum of all task estimated hours",
      "Utilization = (planned work / total capacity) × 100",
      "Over 85% utilization is risky and considered over-capacity"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-7",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Dependency Chain Analyzer",
    "difficulty": 3,
    "description": "Analyze task dependencies to find the critical path and identify potential bottlenecks.\n\nGiven tasks with dependencies and durations, calculate the minimum project duration\nand identify which tasks are on the critical path (any delay will delay the project).",
    "starterCode": "interface Task {\n  id: string;\n  name: string;\n  duration: number; // days\n  dependencies: string[]; // task IDs that must complete first\n}\n\ninterface CriticalPath {\n  minimumDuration: number;\n  criticalTasks: string[];\n  bottlenecks: string[]; // tasks with many dependencies on them\n}\n\nfunction analyzeDependencies(tasks: Task[]): CriticalPath {\n  // TODO: Find critical path and bottlenecks\n  return { minimumDuration: 0, criticalTasks: [], bottlenecks: [] };\n}",
    "solution": "interface Task {\n  id: string;\n  name: string;\n  duration: number; // days\n  dependencies: string[]; // task IDs that must complete first\n}\n\ninterface CriticalPath {\n  minimumDuration: number;\n  criticalTasks: string[];\n  bottlenecks: string[]; // tasks with many dependencies on them\n}\n\nfunction analyzeDependencies(tasks: Task[]): CriticalPath {\n  // Create a map for quick task lookup\n  const taskMap = new Map(tasks.map(t => [t.id, t]));\n\n  // Calculate earliest start time for each task\n  const earliestStart = new Map<string, number>();\n\n  function calculateEarliestStart(taskId: string): number {\n    if (earliestStart.has(taskId)) {\n      return earliestStart.get(taskId)!;\n    }\n\n    const task = taskMap.get(taskId)!;\n    let maxDependencyEnd = 0;\n\n    for (const depId of task.dependencies) {\n      const depStart = calculateEarliestStart(depId);\n      const depTask = taskMap.get(depId)!;\n      maxDependencyEnd = Math.max(maxDependencyEnd, depStart + depTask.duration);\n    }\n\n    earliestStart.set(taskId, maxDependencyEnd);\n    return maxDependencyEnd;\n  }\n\n  // Calculate for all tasks\n  tasks.forEach(task => calculateEarliestStart(task.id));\n\n  // Find minimum duration (max end time)\n  let minimumDuration = 0;\n  let lastTask = '';\n\n  for (const task of tasks) {\n    const endTime = earliestStart.get(task.id)! + task.duration;\n    if (endTime > minimumDuration) {\n      minimumDuration = endTime;\n      lastTask = task.id;\n    }\n  }\n\n  // Find critical path by backtracking\n  const criticalTasks: string[] = [];\n  const visited = new Set<string>();\n\n  function findCriticalPath(taskId: string, targetEnd: number) {\n    if (visited.has(taskId)) return;\n    visited.add(taskId);\n\n    const task = taskMap.get(taskId)!;\n    const start = earliestStart.get(taskId)!;\n\n    if (start + task.duration === targetEnd) {\n      criticalTasks.push(taskId);\n\n      for (const depId of task.dependencies) {\n        findCriticalPath(depId, start);\n      }\n    }\n  }\n\n  findCriticalPath(lastTask, minimumDuration);\n\n  // Find bottlenecks (tasks that many others depend on)\n  const dependencyCount = new Map<string, number>();\n  tasks.forEach(task => dependencyCount.set(task.id, 0));\n\n  tasks.forEach(task => {\n    task.dependencies.forEach(depId => {\n      dependencyCount.set(depId, (dependencyCount.get(depId) || 0) + 1);\n    });\n  });\n\n  const bottlenecks = Array.from(dependencyCount.entries())\n    .filter(([_, count]) => count >= 2)\n    .map(([id, _]) => id);\n\n  return {\n    minimumDuration,\n    criticalTasks: criticalTasks.reverse(),\n    bottlenecks\n  };\n}\n\n// Example\nconst tasks: Task[] = [\n  { id: 'A', name: 'Requirements', duration: 5, dependencies: [] },\n  { id: 'B', name: 'Design', duration: 7, dependencies: ['A'] },\n  { id: 'C', name: 'Database Setup', duration: 3, dependencies: ['A'] },\n  { id: 'D', name: 'Backend', duration: 10, dependencies: ['B', 'C'] },\n  { id: 'E', name: 'Frontend', duration: 8, dependencies: ['B'] },\n  { id: 'F', name: 'Testing', duration: 5, dependencies: ['D', 'E'] },\n];\n\nconsole.log(analyzeDependencies(tasks));",
    "hints": [
      "Use recursion to calculate earliest start times",
      "Critical path = longest chain of dependencies",
      "Backtrack from the last task to find critical tasks",
      "Bottlenecks are tasks that multiple others depend on"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-8",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Requirements Prioritization Matrix",
    "difficulty": 2,
    "description": "Create a prioritization matrix based on value vs. complexity scores.\n\nPlot requirements on a 2x2 matrix: Quick Wins (high value, low complexity),\nBig Bets (high value, high complexity), Fill-ins (low value, low complexity),\nand Money Pits (low value, high complexity).",
    "starterCode": "interface Requirement {\n  id: string;\n  title: string;\n  value: number; // 1-10\n  complexity: number; // 1-10\n}\n\ntype Quadrant = 'Quick Win' | 'Big Bet' | 'Fill-in' | 'Money Pit';\n\ninterface CategorizedRequirement extends Requirement {\n  quadrant: Quadrant;\n  priority: number; // 1-4 (1=highest)\n}\n\nfunction prioritizeRequirements(requirements: Requirement[]): CategorizedRequirement[] {\n  // TODO: Categorize and prioritize requirements\n  return [];\n}",
    "solution": "interface Requirement {\n  id: string;\n  title: string;\n  value: number; // 1-10\n  complexity: number; // 1-10\n}\n\ntype Quadrant = 'Quick Win' | 'Big Bet' | 'Fill-in' | 'Money Pit';\n\ninterface CategorizedRequirement extends Requirement {\n  quadrant: Quadrant;\n  priority: number; // 1-4 (1=highest)\n}\n\nfunction prioritizeRequirements(requirements: Requirement[]): CategorizedRequirement[] {\n  return requirements.map(req => {\n    const { value, complexity } = req;\n\n    // Determine quadrant based on value and complexity\n    let quadrant: Quadrant;\n    let priority: number;\n\n    if (value >= 6 && complexity <= 5) {\n      // High value, low complexity\n      quadrant = 'Quick Win';\n      priority = 1; // Highest priority\n    } else if (value >= 6 && complexity > 5) {\n      // High value, high complexity\n      quadrant = 'Big Bet';\n      priority = 2; // Second priority\n    } else if (value < 6 && complexity <= 5) {\n      // Low value, low complexity\n      quadrant = 'Fill-in';\n      priority = 3; // Third priority\n    } else {\n      // Low value, high complexity\n      quadrant = 'Money Pit';\n      priority = 4; // Lowest priority (avoid)\n    }\n\n    return {\n      ...req,\n      quadrant,\n      priority\n    };\n  }).sort((a, b) => {\n    // Sort by priority, then by value (descending)\n    if (a.priority !== b.priority) {\n      return a.priority - b.priority;\n    }\n    return b.value - a.value;\n  });\n}\n\n// Example\nconst requirements: Requirement[] = [\n  { id: 'R1', title: 'User Login', value: 9, complexity: 4 },\n  { id: 'R2', title: 'Social Sharing', value: 3, complexity: 7 },\n  { id: 'R3', title: 'Email Notifications', value: 7, complexity: 3 },\n  { id: 'R4', title: 'Advanced Analytics', value: 8, complexity: 9 },\n  { id: 'R5', title: 'Dark Mode', value: 4, complexity: 2 },\n];\n\nconsole.log(prioritizeRequirements(requirements));\n/*\nOutput shows requirements sorted by priority:\n1. Quick Wins first (R1, R3)\n2. Big Bets second (R4)\n3. Fill-ins third (R5)\n4. Money Pits last (R2)\n*/",
    "hints": [
      "Use thresholds to categorize: value >= 6 is high, complexity > 5 is high",
      "Quick Wins should be done first (priority 1)",
      "Avoid Money Pits (low value, high complexity)",
      "Sort by priority, then by value within same priority"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-9",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Project Scope Validator",
    "difficulty": 2,
    "description": "Validate that a project scope is realistic for a capstone timeframe.\n\nCheck if the scope meets criteria: reasonable feature count, realistic timeline,\nclear MVP definition, and manageable technical complexity.",
    "starterCode": "interface ProjectScope {\n  features: string[];\n  weeksDuration: number;\n  mvpFeatures: string[];\n  technicalComplexity: 'low' | 'medium' | 'high' | 'very high';\n  teamSize: number;\n}\n\ninterface ScopeValidation {\n  isRealistic: boolean;\n  warnings: string[];\n  recommendations: string[];\n}\n\nfunction validateProjectScope(scope: ProjectScope): ScopeValidation {\n  // TODO: Validate scope realism\n  return { isRealistic: true, warnings: [], recommendations: [] };\n}",
    "solution": "interface ProjectScope {\n  features: string[];\n  weeksDuration: number;\n  mvpFeatures: string[];\n  technicalComplexity: 'low' | 'medium' | 'high' | 'very high';\n  teamSize: number;\n}\n\ninterface ScopeValidation {\n  isRealistic: boolean;\n  warnings: string[];\n  recommendations: string[];\n}\n\nfunction validateProjectScope(scope: ProjectScope): ScopeValidation {\n  const warnings: string[] = [];\n  const recommendations: string[] = [];\n\n  // Check feature count\n  const featuresPerWeek = scope.features.length / scope.weeksDuration;\n  if (featuresPerWeek > 2) {\n    warnings.push(`Planning ${featuresPerWeek.toFixed(1)} features/week is aggressive`);\n    recommendations.push('Consider reducing scope or extending timeline');\n  }\n\n  // Check MVP ratio\n  const mvpRatio = scope.mvpFeatures.length / scope.features.length;\n  if (mvpRatio > 0.8) {\n    warnings.push('MVP contains most features - may not be truly minimal');\n    recommendations.push('Identify and defer non-essential MVP features');\n  }\n  if (mvpRatio < 0.3) {\n    warnings.push('MVP is very small - may not demonstrate sufficient functionality');\n  }\n\n  // Check complexity vs. timeline\n  const weeksNeeded = {\n    'low': 8,\n    'medium': 12,\n    'high': 16,\n    'very high': 20\n  };\n\n  if (scope.weeksDuration < weeksNeeded[scope.technicalComplexity]) {\n    warnings.push(`${scope.technicalComplexity} complexity typically needs ${weeksNeeded[scope.technicalComplexity]}+ weeks`);\n    recommendations.push('Simplify technical approach or extend timeline');\n  }\n\n  // Check team size consideration\n  if (scope.teamSize === 1 && scope.features.length > 10) {\n    warnings.push('Large scope for solo developer');\n    recommendations.push('Consider reducing features or finding a partner');\n  }\n\n  // Determine if realistic\n  const isRealistic = warnings.length <= 2;\n\n  if (isRealistic && warnings.length === 0) {\n    recommendations.push('Scope appears realistic - proceed with planning');\n  }\n\n  return {\n    isRealistic,\n    warnings,\n    recommendations\n  };\n}\n\n// Example\nconst scope: ProjectScope = {\n  features: ['User Auth', 'Dashboard', 'Data Entry', 'Reports', 'Export', 'API'],\n  weeksDuration: 10,\n  mvpFeatures: ['User Auth', 'Dashboard', 'Data Entry'],\n  technicalComplexity: 'medium',\n  teamSize: 1\n};\n\nconsole.log(validateProjectScope(scope));",
    "hints": [
      "More than 2 features/week is aggressive for capstone",
      "MVP should be 30-60% of total features",
      "Match complexity to timeline: high complexity needs more time",
      "Solo developers should limit scope"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-10",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Burndown Chart Calculator",
    "difficulty": 2,
    "description": "Calculate burndown data for sprint progress tracking.\n\nGiven total story points, days remaining, and completed points per day,\ncalculate ideal burndown, actual progress, and whether the sprint is on track.",
    "starterCode": "interface DailyProgress {\n  day: number;\n  completedPoints: number;\n}\n\ninterface BurndownData {\n  day: number;\n  idealRemaining: number;\n  actualRemaining: number;\n  onTrack: boolean;\n}\n\nfunction calculateBurndown(\n  totalPoints: number,\n  sprintDays: number,\n  progress: DailyProgress[]\n): BurndownData[] {\n  // TODO: Calculate burndown chart data\n  return [];\n}",
    "solution": "interface DailyProgress {\n  day: number;\n  completedPoints: number;\n}\n\ninterface BurndownData {\n  day: number;\n  idealRemaining: number;\n  actualRemaining: number;\n  onTrack: boolean;\n}\n\nfunction calculateBurndown(\n  totalPoints: number,\n  sprintDays: number,\n  progress: DailyProgress[]\n): BurndownData[] {\n  const idealBurnRate = totalPoints / sprintDays;\n  const burndown: BurndownData[] = [];\n\n  let actualRemaining = totalPoints;\n\n  for (let day = 0; day <= sprintDays; day++) {\n    // Calculate ideal remaining (linear burndown)\n    const idealRemaining = Math.max(0, totalPoints - (idealBurnRate * day));\n\n    // Find actual progress for this day\n    const dayProgress = progress.find(p => p.day === day);\n    if (dayProgress) {\n      actualRemaining -= dayProgress.completedPoints;\n    }\n\n    // On track if actual <= ideal (or within 10% tolerance)\n    const tolerance = totalPoints * 0.1;\n    const onTrack = actualRemaining <= idealRemaining + tolerance;\n\n    burndown.push({\n      day,\n      idealRemaining: Math.round(idealRemaining * 10) / 10,\n      actualRemaining: Math.max(0, actualRemaining),\n      onTrack\n    });\n  }\n\n  return burndown;\n}\n\n// Example\nconst progress: DailyProgress[] = [\n  { day: 1, completedPoints: 5 },\n  { day: 2, completedPoints: 3 },\n  { day: 3, completedPoints: 8 },\n  { day: 4, completedPoints: 4 },\n  { day: 5, completedPoints: 6 },\n];\n\nconst burndown = calculateBurndown(50, 10, progress);\nconsole.log(burndown);\n/*\nShows daily: ideal vs. actual remaining points\nand whether sprint is on track\n*/",
    "hints": [
      "Ideal burn rate = total points / sprint days",
      "Ideal remaining decreases linearly each day",
      "Actual remaining = previous - completed that day",
      "Allow 10% tolerance for \"on track\" determination"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-11",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Feature Estimation Confidence",
    "difficulty": 2,
    "description": "Calculate confidence levels for feature estimates based on familiarity and complexity.\n\nFeatures you've built before have high confidence. New technologies or complex\nfeatures have lower confidence and should include larger buffers.",
    "starterCode": "interface FeatureEstimate {\n  name: string;\n  baseEstimate: number; // hours\n  familiarity: 'high' | 'medium' | 'low'; // have you done this before?\n  complexity: 'simple' | 'moderate' | 'complex';\n  dependencies: number; // number of dependencies\n}\n\ninterface ConfidentEstimate extends FeatureEstimate {\n  confidence: number; // 0-100%\n  bufferedEstimate: number; // with appropriate buffer\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\nfunction calculateEstimateConfidence(features: FeatureEstimate[]): ConfidentEstimate[] {\n  // TODO: Calculate confidence and buffered estimates\n  return [];\n}",
    "solution": "interface FeatureEstimate {\n  name: string;\n  baseEstimate: number; // hours\n  familiarity: 'high' | 'medium' | 'low';\n  complexity: 'simple' | 'moderate' | 'complex';\n  dependencies: number;\n}\n\ninterface ConfidentEstimate extends FeatureEstimate {\n  confidence: number; // 0-100%\n  bufferedEstimate: number;\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\nfunction calculateEstimateConfidence(features: FeatureEstimate[]): ConfidentEstimate[] {\n  return features.map(feature => {\n    // Base confidence from familiarity\n    const familiarityScore = {\n      'high': 85,\n      'medium': 60,\n      'low': 40\n    }[feature.familiarity];\n\n    // Complexity penalty\n    const complexityPenalty = {\n      'simple': 0,\n      'moderate': 10,\n      'complex': 20\n    }[feature.complexity];\n\n    // Dependency penalty (5% per dependency)\n    const dependencyPenalty = Math.min(feature.dependencies * 5, 20);\n\n    // Calculate final confidence\n    const confidence = Math.max(20, familiarityScore - complexityPenalty - dependencyPenalty);\n\n    // Calculate buffer multiplier based on confidence\n    const bufferMultiplier = confidence >= 70 ? 1.2 :\n                            confidence >= 50 ? 1.5 :\n                            confidence >= 30 ? 2.0 : 2.5;\n\n    const bufferedEstimate = Math.round(feature.baseEstimate * bufferMultiplier);\n\n    // Determine risk level\n    const riskLevel = confidence >= 60 ? 'low' :\n                     confidence >= 40 ? 'medium' : 'high';\n\n    return {\n      ...feature,\n      confidence,\n      bufferedEstimate,\n      riskLevel\n    };\n  });\n}\n\n// Example\nconst features: FeatureEstimate[] = [\n  { name: 'User Registration', baseEstimate: 8, familiarity: 'high', complexity: 'simple', dependencies: 1 },\n  { name: 'Real-time Chat', baseEstimate: 16, familiarity: 'low', complexity: 'complex', dependencies: 3 },\n  { name: 'Dashboard', baseEstimate: 12, familiarity: 'medium', complexity: 'moderate', dependencies: 2 },\n];\n\nconsole.log(calculateEstimateConfidence(features));",
    "hints": [
      "High familiarity = 85% base confidence, low = 40%",
      "Reduce confidence for complexity and dependencies",
      "Low confidence needs larger buffer (2-2.5x)",
      "High confidence can use smaller buffer (1.2x)"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-12",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Project Risk Mitigation Planner",
    "difficulty": 3,
    "description": "Create a risk mitigation planning system that suggests strategies for each risk.\n\nBased on risk type and exposure, recommend appropriate mitigation strategies:\naccept, monitor, mitigate, or avoid.",
    "starterCode": "interface Risk {\n  id: string;\n  description: string;\n  type: 'technical' | 'schedule' | 'resource' | 'external';\n  probability: number; // 1-5\n  impact: number; // 1-5\n}\n\ntype MitigationStrategy = 'accept' | 'monitor' | 'mitigate' | 'avoid';\n\ninterface RiskMitigation extends Risk {\n  exposure: number;\n  strategy: MitigationStrategy;\n  actions: string[];\n}\n\nfunction planRiskMitigation(risks: Risk[]): RiskMitigation[] {\n  // TODO: Determine mitigation strategies and actions\n  return [];\n}",
    "solution": "interface Risk {\n  id: string;\n  description: string;\n  type: 'technical' | 'schedule' | 'resource' | 'external';\n  probability: number; // 1-5\n  impact: number; // 1-5\n}\n\ntype MitigationStrategy = 'accept' | 'monitor' | 'monitor' | 'mitigate' | 'avoid';\n\ninterface RiskMitigation extends Risk {\n  exposure: number;\n  strategy: MitigationStrategy;\n  actions: string[];\n}\n\nfunction planRiskMitigation(risks: Risk[]): RiskMitigation[] {\n  return risks.map(risk => {\n    const exposure = risk.probability * risk.impact;\n\n    // Determine strategy based on exposure\n    let strategy: MitigationStrategy;\n    let actions: string[] = [];\n\n    if (exposure >= 20) {\n      // Critical risk - avoid or heavily mitigate\n      strategy = 'avoid';\n      actions = getAvoidanceActions(risk);\n    } else if (exposure >= 12) {\n      // High risk - mitigate\n      strategy = 'mitigate';\n      actions = getMitigationActions(risk);\n    } else if (exposure >= 6) {\n      // Medium risk - monitor closely\n      strategy = 'monitor';\n      actions = getMonitoringActions(risk);\n    } else {\n      // Low risk - accept\n      strategy = 'accept';\n      actions = ['Document risk', 'Review periodically'];\n    }\n\n    return {\n      ...risk,\n      exposure,\n      strategy,\n      actions\n    };\n  }).sort((a, b) => b.exposure - a.exposure);\n}\n\nfunction getAvoidanceActions(risk: Risk): string[] {\n  const actions: string[] = [];\n\n  switch (risk.type) {\n    case 'technical':\n      actions.push('Choose proven technology instead');\n      actions.push('Build prototype to validate approach');\n      actions.push('Have backup technology ready');\n      break;\n    case 'schedule':\n      actions.push('Reduce scope significantly');\n      actions.push('Add buffer to timeline');\n      actions.push('Increase team size if possible');\n      break;\n    case 'resource':\n      actions.push('Identify alternative resources early');\n      actions.push('Cross-train team members');\n      break;\n    case 'external':\n      actions.push('Have contingency plan');\n      actions.push('Reduce dependency on external factors');\n      break;\n  }\n\n  return actions;\n}\n\nfunction getMitigationActions(risk: Risk): string[] {\n  const actions: string[] = [];\n\n  switch (risk.type) {\n    case 'technical':\n      actions.push('Conduct spike/proof-of-concept');\n      actions.push('Allocate extra time for learning');\n      actions.push('Seek expert consultation');\n      break;\n    case 'schedule':\n      actions.push('Add 20-30% buffer to estimates');\n      actions.push('Identify tasks that can be parallelized');\n      actions.push('Define clear MVP to enable scope cuts');\n      break;\n    case 'resource':\n      actions.push('Document critical knowledge');\n      actions.push('Have backup team members identified');\n      break;\n    case 'external':\n      actions.push('Maintain regular communication');\n      actions.push('Document dependencies clearly');\n      break;\n  }\n\n  return actions;\n}\n\nfunction getMonitoringActions(risk: Risk): string[] {\n  return [\n    'Check status weekly',\n    'Define clear trigger conditions for escalation',\n    'Document risk in project status reports',\n    'Prepare mitigation plan in advance'\n  ];\n}\n\n// Example\nconst risks: Risk[] = [\n  { id: 'R1', description: 'Learning new framework', type: 'technical', probability: 4, impact: 4 },\n  { id: 'R2', description: 'Tight deadline', type: 'schedule', probability: 3, impact: 5 },\n  { id: 'R3', description: 'API might change', type: 'external', probability: 2, impact: 3 },\n];\n\nconsole.log(planRiskMitigation(risks));",
    "hints": [
      "Exposure >= 20: avoid the risk entirely",
      "Exposure 12-19: actively mitigate",
      "Exposure 6-11: monitor closely",
      "Exposure < 6: accept and document",
      "Different risk types need different mitigation actions"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-13",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Stakeholder Communication Matrix",
    "difficulty": 2,
    "description": "Create a stakeholder communication plan based on interest and influence levels.\n\nCategorize stakeholders and determine appropriate communication frequency and detail level.",
    "starterCode": "interface Stakeholder {\n  name: string;\n  role: string;\n  interest: 'low' | 'medium' | 'high';\n  influence: 'low' | 'medium' | 'high';\n}\n\ninterface CommunicationPlan extends Stakeholder {\n  category: 'Monitor' | 'Keep Informed' | 'Keep Satisfied' | 'Manage Closely';\n  frequency: string;\n  detailLevel: 'summary' | 'moderate' | 'detailed';\n  channels: string[];\n}\n\nfunction createCommunicationPlan(stakeholders: Stakeholder[]): CommunicationPlan[] {\n  // TODO: Categorize and plan communication\n  return [];\n}",
    "solution": "interface Stakeholder {\n  name: string;\n  role: string;\n  interest: 'low' | 'medium' | 'high';\n  influence: 'low' | 'medium' | 'high';\n}\n\ninterface CommunicationPlan extends Stakeholder {\n  category: 'Monitor' | 'Keep Informed' | 'Keep Satisfied' | 'Manage Closely';\n  frequency: string;\n  detailLevel: 'summary' | 'moderate' | 'detailed';\n  channels: string[];\n}\n\nfunction createCommunicationPlan(stakeholders: Stakeholder[]): CommunicationPlan[] {\n  return stakeholders.map(stakeholder => {\n    const { interest, influence } = stakeholder;\n\n    // Determine category based on interest/influence matrix\n    let category: CommunicationPlan['category'];\n    let frequency: string;\n    let detailLevel: 'summary' | 'moderate' | 'detailed';\n    let channels: string[];\n\n    if (influence === 'high' && interest === 'high') {\n      // Key players - manage closely\n      category = 'Manage Closely';\n      frequency = 'Weekly updates + ad-hoc';\n      detailLevel = 'detailed';\n      channels = ['One-on-one meetings', 'Email', 'Demo sessions'];\n    } else if (influence === 'high' && interest !== 'high') {\n      // Important but not engaged - keep satisfied\n      category = 'Keep Satisfied';\n      frequency = 'Bi-weekly summaries';\n      detailLevel = 'moderate';\n      channels = ['Email updates', 'Monthly meetings'];\n    } else if (influence !== 'high' && interest === 'high') {\n      // Engaged but less influential - keep informed\n      category = 'Keep Informed';\n      frequency = 'Weekly updates';\n      detailLevel = 'moderate';\n      channels = ['Email', 'Slack', 'Demo sessions'];\n    } else {\n      // Low priority - monitor\n      category = 'Monitor';\n      frequency = 'Monthly summaries';\n      detailLevel = 'summary';\n      channels = ['Email newsletter'];\n    }\n\n    return {\n      ...stakeholder,\n      category,\n      frequency,\n      detailLevel,\n      channels\n    };\n  });\n}\n\n// Example\nconst stakeholders: Stakeholder[] = [\n  { name: 'Dr. Smith', role: 'Advisor', interest: 'high', influence: 'high' },\n  { name: 'John Doe', role: 'Department Head', interest: 'low', influence: 'high' },\n  { name: 'Jane User', role: 'Beta Tester', interest: 'high', influence: 'low' },\n  { name: 'Bob', role: 'Peer Reviewer', interest: 'medium', influence: 'low' },\n];\n\nconsole.log(createCommunicationPlan(stakeholders));",
    "hints": [
      "High influence + high interest = Manage Closely",
      "High influence + low interest = Keep Satisfied",
      "Low influence + high interest = Keep Informed",
      "Low influence + low interest = Monitor",
      "Tailor frequency and detail level to category"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-14",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Project Timeline Optimizer",
    "difficulty": 3,
    "description": "Optimize project timeline by identifying tasks that can be parallelized.\n\nGiven tasks with dependencies and durations, reorganize them to minimize total\nduration by running independent tasks in parallel.",
    "starterCode": "interface Task {\n  id: string;\n  name: string;\n  duration: number;\n  dependencies: string[];\n  assignee?: string;\n}\n\ninterface OptimizedSchedule {\n  phases: {\n    phaseNumber: number;\n    tasks: string[];\n    duration: number;\n  }[];\n  totalDuration: number;\n  parallelizationGain: number; // days saved vs. sequential\n}\n\nfunction optimizeTimeline(tasks: Task[]): OptimizedSchedule {\n  // TODO: Optimize schedule by parallelizing independent tasks\n  return { phases: [], totalDuration: 0, parallelizationGain: 0 };\n}",
    "solution": "interface Task {\n  id: string;\n  name: string;\n  duration: number;\n  dependencies: string[];\n  assignee?: string;\n}\n\ninterface OptimizedSchedule {\n  phases: {\n    phaseNumber: number;\n    tasks: string[];\n    duration: number;\n  }[];\n  totalDuration: number;\n  parallelizationGain: number;\n}\n\nfunction optimizeTimeline(tasks: Task[]): OptimizedSchedule {\n  const taskMap = new Map(tasks.map(t => [t.id, t]));\n  const completed = new Set<string>();\n  const phases: OptimizedSchedule['phases'] = [];\n\n  let phaseNumber = 1;\n\n  // Assign tasks to phases\n  while (completed.size < tasks.length) {\n    // Find tasks that can run in this phase\n    const availableTasks = tasks.filter(task => {\n      if (completed.has(task.id)) return false;\n      return task.dependencies.every(dep => completed.has(dep));\n    });\n\n    if (availableTasks.length === 0) break; // Circular dependency or error\n\n    // Group by assignee if specified (can't parallelize same person's tasks)\n    const assigneeGroups = new Map<string, Task[]>();\n    availableTasks.forEach(task => {\n      const assignee = task.assignee || 'unassigned';\n      if (!assigneeGroups.has(assignee)) {\n        assigneeGroups.set(assignee, []);\n      }\n      assigneeGroups.get(assignee)!.push(task);\n    });\n\n    // For simplicity, take one task per assignee per phase\n    const phaseTasks = Array.from(assigneeGroups.values())\n      .map(group => group[0])\n      .slice(0, 3); // Limit parallelization\n\n    const phaseDuration = Math.max(...phaseTasks.map(t => t.duration));\n\n    phases.push({\n      phaseNumber,\n      tasks: phaseTasks.map(t => t.id),\n      duration: phaseDuration\n    });\n\n    phaseTasks.forEach(t => completed.add(t.id));\n    phaseNumber++;\n  }\n\n  // Calculate total duration\n  const totalDuration = phases.reduce((sum, phase) => sum + phase.duration, 0);\n\n  // Calculate sequential duration for comparison\n  const sequentialDuration = tasks.reduce((sum, task) => sum + task.duration, 0);\n  const parallelizationGain = sequentialDuration - totalDuration;\n\n  return {\n    phases,\n    totalDuration,\n    parallelizationGain\n  };\n}\n\n// Example\nconst tasks: Task[] = [\n  { id: 'A', name: 'Requirements', duration: 5, dependencies: [], assignee: 'Alice' },\n  { id: 'B', name: 'Database Design', duration: 3, dependencies: ['A'], assignee: 'Bob' },\n  { id: 'C', name: 'UI Design', duration: 4, dependencies: ['A'], assignee: 'Carol' },\n  { id: 'D', name: 'Backend API', duration: 8, dependencies: ['B'], assignee: 'Bob' },\n  { id: 'E', name: 'Frontend', duration: 6, dependencies: ['C'], assignee: 'Carol' },\n  { id: 'F', name: 'Integration', duration: 3, dependencies: ['D', 'E'], assignee: 'Alice' },\n];\n\nconsole.log(optimizeTimeline(tasks));",
    "hints": [
      "Tasks can run in parallel if dependencies are met",
      "Group tasks by phase based on dependency completion",
      "Phase duration = longest task in that phase",
      "Compare to sequential duration to show gain"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-15",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Acceptance Criteria Generator",
    "difficulty": 2,
    "description": "Generate acceptance criteria from user stories using best practices.\n\nFor each user story, generate specific, measurable, testable acceptance criteria\nthat cover happy path, edge cases, and error scenarios.",
    "starterCode": "interface UserStory {\n  id: string;\n  role: string;\n  action: string;\n  benefit: string;\n}\n\ninterface AcceptanceCriteria {\n  storyId: string;\n  criteria: {\n    scenario: string;\n    given: string;\n    when: string;\n    then: string;\n  }[];\n}\n\nfunction generateAcceptanceCriteria(story: UserStory): AcceptanceCriteria {\n  // TODO: Generate acceptance criteria\n  return { storyId: story.id, criteria: [] };\n}",
    "solution": "interface UserStory {\n  id: string;\n  role: string;\n  action: string;\n  benefit: string;\n}\n\ninterface AcceptanceCriteria {\n  storyId: string;\n  criteria: {\n    scenario: string;\n    given: string;\n    when: string;\n    then: string;\n  }[];\n}\n\nfunction generateAcceptanceCriteria(story: UserStory): AcceptanceCriteria {\n  const criteria: AcceptanceCriteria['criteria'] = [];\n\n  // Detect story type and generate appropriate criteria\n  const action = story.action.toLowerCase();\n\n  if (action.includes('log in') || action.includes('sign in')) {\n    criteria.push(\n      {\n        scenario: 'Successful login',\n        given: 'I have a valid account',\n        when: 'I enter correct username and password',\n        then: 'I should be logged in and redirected to dashboard'\n      },\n      {\n        scenario: 'Invalid credentials',\n        given: 'I have an account',\n        when: 'I enter incorrect password',\n        then: 'I should see \"Invalid credentials\" error and remain on login page'\n      },\n      {\n        scenario: 'Account lockout',\n        given: 'I have failed login 5 times',\n        when: 'I try to log in again',\n        then: 'I should see \"Account temporarily locked\" message'\n      }\n    );\n  } else if (action.includes('create') || action.includes('add')) {\n    criteria.push(\n      {\n        scenario: 'Successful creation',\n        given: 'I am authenticated',\n        when: 'I submit valid data',\n        then: 'The item should be created and I should see confirmation'\n      },\n      {\n        scenario: 'Invalid data',\n        given: 'I am authenticated',\n        when: 'I submit incomplete data',\n        then: 'I should see validation errors for each field'\n      },\n      {\n        scenario: 'Duplicate prevention',\n        given: 'An item with same identifier exists',\n        when: 'I try to create a duplicate',\n        then: 'I should see \"Already exists\" error'\n      }\n    );\n  } else if (action.includes('edit') || action.includes('update')) {\n    criteria.push(\n      {\n        scenario: 'Successful update',\n        given: 'I own the item',\n        when: 'I submit valid changes',\n        then: 'The item should be updated and I should see confirmation'\n      },\n      {\n        scenario: 'Unauthorized edit',\n        given: 'I do not own the item',\n        when: 'I try to edit it',\n        then: 'I should see \"Access denied\" error'\n      },\n      {\n        scenario: 'Validation on edit',\n        given: 'I am editing an item',\n        when: 'I clear required fields',\n        then: 'I should see validation errors'\n      }\n    );\n  } else if (action.includes('delete') || action.includes('remove')) {\n    criteria.push(\n      {\n        scenario: 'Successful deletion',\n        given: 'I own the item',\n        when: 'I confirm deletion',\n        then: 'The item should be deleted and I should see confirmation'\n      },\n      {\n        scenario: 'Deletion confirmation',\n        given: 'I click delete',\n        when: 'The confirmation dialog appears',\n        then: 'I should be able to cancel or confirm'\n      },\n      {\n        scenario: 'Unauthorized deletion',\n        given: 'I do not own the item',\n        when: 'I try to delete it',\n        then: 'I should see \"Access denied\" error'\n      }\n    );\n  } else {\n    // Generic criteria for other actions\n    criteria.push(\n      {\n        scenario: 'Happy path',\n        given: `I am a ${story.role}`,\n        when: `I ${story.action}`,\n        then: `I should achieve: ${story.benefit}`\n      },\n      {\n        scenario: 'Error handling',\n        given: 'An error occurs',\n        when: `I attempt to ${story.action}`,\n        then: 'I should see a helpful error message'\n      },\n      {\n        scenario: 'Authorization check',\n        given: 'I am not authorized',\n        when: `I try to ${story.action}`,\n        then: 'I should see \"Access denied\" message'\n      }\n    );\n  }\n\n  return {\n    storyId: story.id,\n    criteria\n  };\n}\n\n// Example\nconst story: UserStory = {\n  id: 'US-101',\n  role: 'registered user',\n  action: 'log in with my email and password',\n  benefit: 'I can access my personal dashboard'\n};\n\nconsole.log(generateAcceptanceCriteria(story));",
    "hints": [
      "Use Given-When-Then format for each criterion",
      "Always include: happy path, validation, and authorization",
      "Pattern match common actions (login, create, edit, delete)",
      "Generate 3-5 criteria per story"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-1-16",
    "subjectId": "cs404",
    "topicId": "topic-1",
    "title": "Project Health Score Calculator",
    "difficulty": 3,
    "description": "Calculate overall project health score based on multiple metrics.\n\nConsider: schedule adherence, scope changes, risk status, team morale indicators,\nand technical debt. Generate an overall health score and recommendations.",
    "starterCode": "interface ProjectMetrics {\n  scheduleVariance: number; // percentage: negative is behind, positive is ahead\n  scopeChanges: number; // number of approved scope changes\n  openHighRisks: number; // count of high/critical risks\n  codeQualityScore: number; // 0-100\n  testCoverage: number; // percentage\n  teamVelocityTrend: 'increasing' | 'stable' | 'decreasing';\n}\n\ninterface HealthReport {\n  overallScore: number; // 0-100\n  status: 'healthy' | 'at-risk' | 'critical';\n  concerns: string[];\n  recommendations: string[];\n}\n\nfunction calculateProjectHealth(metrics: ProjectMetrics): HealthReport {\n  // TODO: Calculate health score and generate report\n  return { overallScore: 0, status: 'healthy', concerns: [], recommendations: [] };\n}",
    "solution": "interface ProjectMetrics {\n  scheduleVariance: number;\n  scopeChanges: number;\n  openHighRisks: number;\n  codeQualityScore: number;\n  testCoverage: number;\n  teamVelocityTrend: 'increasing' | 'stable' | 'decreasing';\n}\n\ninterface HealthReport {\n  overallScore: number;\n  status: 'healthy' | 'at-risk' | 'critical';\n  concerns: string[];\n  recommendations: string[];\n}\n\nfunction calculateProjectHealth(metrics: ProjectMetrics): HealthReport {\n  const concerns: string[] = [];\n  const recommendations: string[] = [];\n  let score = 100;\n\n  // Schedule adherence (weight: 25 points)\n  if (metrics.scheduleVariance < -20) {\n    score -= 25;\n    concerns.push('Significantly behind schedule');\n    recommendations.push('Review and adjust timeline or reduce scope');\n  } else if (metrics.scheduleVariance < -10) {\n    score -= 15;\n    concerns.push('Moderately behind schedule');\n    recommendations.push('Identify and address bottlenecks');\n  } else if (metrics.scheduleVariance < -5) {\n    score -= 5;\n  }\n\n  // Scope stability (weight: 15 points)\n  if (metrics.scopeChanges > 5) {\n    score -= 15;\n    concerns.push('Frequent scope changes');\n    recommendations.push('Lock down scope and defer new requests');\n  } else if (metrics.scopeChanges > 3) {\n    score -= 8;\n    concerns.push('Some scope volatility');\n  }\n\n  // Risk management (weight: 20 points)\n  if (metrics.openHighRisks > 3) {\n    score -= 20;\n    concerns.push('Multiple high-priority risks open');\n    recommendations.push('Address critical risks immediately');\n  } else if (metrics.openHighRisks > 1) {\n    score -= 10;\n    concerns.push('High-priority risks need attention');\n    recommendations.push('Develop mitigation plans for open risks');\n  }\n\n  // Code quality (weight: 20 points)\n  if (metrics.codeQualityScore < 60) {\n    score -= 20;\n    concerns.push('Low code quality score');\n    recommendations.push('Allocate time for refactoring and code review');\n  } else if (metrics.codeQualityScore < 75) {\n    score -= 10;\n    concerns.push('Code quality needs improvement');\n    recommendations.push('Increase code review rigor');\n  }\n\n  // Test coverage (weight: 10 points)\n  if (metrics.testCoverage < 50) {\n    score -= 10;\n    concerns.push('Insufficient test coverage');\n    recommendations.push('Prioritize writing tests for critical paths');\n  } else if (metrics.testCoverage < 70) {\n    score -= 5;\n    recommendations.push('Continue increasing test coverage');\n  }\n\n  // Team velocity (weight: 10 points)\n  if (metrics.teamVelocityTrend === 'decreasing') {\n    score -= 10;\n    concerns.push('Team velocity is declining');\n    recommendations.push('Investigate team blockers and morale issues');\n  } else if (metrics.teamVelocityTrend === 'stable') {\n    // No penalty, stable is okay\n  } else {\n    score += 5; // Bonus for increasing velocity\n  }\n\n  // Ensure score stays in valid range\n  score = Math.max(0, Math.min(100, score));\n\n  // Determine status\n  const status: HealthReport['status'] =\n    score >= 75 ? 'healthy' :\n    score >= 50 ? 'at-risk' : 'critical';\n\n  // Add positive notes if healthy\n  if (status === 'healthy' && concerns.length === 0) {\n    recommendations.push('Project is on track - maintain current practices');\n  }\n\n  return {\n    overallScore: score,\n    status,\n    concerns,\n    recommendations\n  };\n}\n\n// Example\nconst metrics: ProjectMetrics = {\n  scheduleVariance: -15,\n  scopeChanges: 2,\n  openHighRisks: 1,\n  codeQualityScore: 78,\n  testCoverage: 68,\n  teamVelocityTrend: 'stable'\n};\n\nconsole.log(calculateProjectHealth(metrics));",
    "hints": [
      "Weight different metrics by importance",
      "Schedule and risks are most critical (25 + 20 points)",
      "Generate specific concerns and actionable recommendations",
      "Status: healthy (75+), at-risk (50-74), critical (<50)"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-2-1",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Implement Repository Pattern",
    "difficulty": 3,
    "description": "Create a repository class that abstracts database operations for a User entity. Implement a UserRepository class with CRUD operations that can work with any database implementation.",
    "starterCode": "interface User {\n  id: string;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  create(user: Omit<User, 'id' | 'created_at'>): Promise<User>;\n  update(id: string, data: Partial<User>): Promise<User>;\n  delete(id: string): Promise<void>;\n}\n\n// TODO: Implement UserRepository class\nclass InMemoryUserRepository implements UserRepository {\n  private users: Map<string, User> = new Map();\n\n  async findById(id: string): Promise<User | null> {\n    // TODO\n    return null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    // TODO\n    return null;\n  }\n\n  async create(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {\n    // TODO\n    throw new Error('Not implemented');\n  }\n\n  async update(id: string, data: Partial<User>): Promise<User> {\n    // TODO\n    throw new Error('Not implemented');\n  }\n\n  async delete(id: string): Promise<void> {\n    // TODO\n  }\n}",
    "solution": "interface User {\n  id: string;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  create(user: Omit<User, 'id' | 'created_at'>): Promise<User>;\n  update(id: string, data: Partial<User>): Promise<User>;\n  delete(id: string): Promise<void>;\n}\n\nclass InMemoryUserRepository implements UserRepository {\n  private users: Map<string, User> = new Map();\n\n  async findById(id: string): Promise<User | null> {\n    return this.users.get(id) || null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    const users = Array.from(this.users.values());\n    return users.find(user => user.email === email) || null;\n  }\n\n  async create(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {\n    const user: User = {\n      id: crypto.randomUUID(),\n      ...userData,\n      created_at: new Date()\n    };\n\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  async update(id: string, data: Partial<User>): Promise<User> {\n    const existing = await this.findById(id);\n    if (!existing) {\n      throw new Error('User not found');\n    }\n\n    const updated = { ...existing, ...data };\n    this.users.set(id, updated);\n    return updated;\n  }\n\n  async delete(id: string): Promise<void> {\n    this.users.delete(id);\n  }\n}\n\n// Usage example\nasync function main() {\n  const repo = new InMemoryUserRepository();\n\n  // Create user\n  const user = await repo.create({\n    email: 'test@example.com',\n    name: 'Test User'\n  });\n  console.log('Created:', user);\n\n  // Find by ID\n  const found = await repo.findById(user.id);\n  console.log('Found:', found);\n\n  // Update\n  const updated = await repo.update(user.id, { name: 'Updated Name' });\n  console.log('Updated:', updated);\n\n  // Find by email\n  const byEmail = await repo.findByEmail('test@example.com');\n  console.log('By email:', byEmail);\n\n  // Delete\n  await repo.delete(user.id);\n  const deleted = await repo.findById(user.id);\n  console.log('After delete:', deleted); // null\n}\n\nmain();",
    "hints": [
      "Use Map to store users in memory",
      "Generate UUIDs for new users",
      "Return null when user not found",
      "Throw error on update if user doesn't exist"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-2-2",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Strategy Pattern for Calculations",
    "difficulty": 3,
    "description": "Implement the Strategy pattern for different carbon emission calculations. Create different calculation strategies for different transportation types.",
    "starterCode": "interface CarbonCalculationStrategy {\n  calculate(miles: number): number;\n}\n\n// TODO: Implement strategies for car, bus, and plane\nclass CarStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    // TODO: 0.404 kg CO2 per mile\n    return 0;\n  }\n}\n\nclass Calculator {\n  private strategy: CarbonCalculationStrategy;\n\n  setStrategy(strategy: CarbonCalculationStrategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(miles: number): number {\n    return this.strategy.calculate(miles);\n  }\n}",
    "solution": "interface CarbonCalculationStrategy {\n  calculate(miles: number): number;\n}\n\nclass CarStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    return miles * 0.404; // kg CO2 per mile\n  }\n}\n\nclass BusStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    return miles * 0.089; // kg CO2 per mile\n  }\n}\n\nclass PlaneStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    return miles * 0.257; // kg CO2 per mile\n  }\n}\n\nclass CarbonCalculator {\n  private strategy: CarbonCalculationStrategy;\n\n  constructor(strategy: CarbonCalculationStrategy) {\n    this.strategy = strategy;\n  }\n\n  setStrategy(strategy: CarbonCalculationStrategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(miles: number): number {\n    return Math.round(this.strategy.calculate(miles) * 100) / 100;\n  }\n}\n\n// Usage\nconst calculator = new CarbonCalculator(new CarStrategy());\nconsole.log('Car 100 miles:', calculator.calculate(100), 'kg CO2');\n\ncalculator.setStrategy(new BusStrategy());\nconsole.log('Bus 100 miles:', calculator.calculate(100), 'kg CO2');\n\ncalculator.setStrategy(new PlaneStrategy());\nconsole.log('Plane 1000 miles:', calculator.calculate(1000), 'kg CO2');\n\n/*\nOutput:\nCar 100 miles: 40.4 kg CO2\nBus 100 miles: 8.9 kg CO2\nPlane 1000 miles: 257 kg CO2\n*/",
    "hints": [
      "Each strategy implements the same interface",
      "Calculator can switch strategies at runtime",
      "Round results to 2 decimal places"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex03",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Layered Architecture - Three Tier System",
    "difficulty": 1,
    "description": "Implement a simple three-tier architecture with Presentation, Business Logic, and Data Access layers. Create a basic user authentication system that demonstrates separation of concerns across layers.\n\nThe presentation layer handles input/output, the business layer contains authentication logic, and the data layer manages user storage.",
    "starterCode": "// Data Access Layer\nclass UserDataAccess {\n  private users: Map<string, { username: string; password: string }> = new Map();\n\n  findByUsername(username: string) {\n    // TODO: Return user or undefined\n  }\n\n  save(username: string, password: string) {\n    // TODO: Save user to storage\n  }\n}\n\n// Business Logic Layer\nclass AuthService {\n  constructor(private dataAccess: UserDataAccess) {}\n\n  register(username: string, password: string): boolean {\n    // TODO: Check if user exists, validate, and save\n    return false;\n  }\n\n  login(username: string, password: string): boolean {\n    // TODO: Verify credentials\n    return false;\n  }\n}\n\n// Presentation Layer\nclass AuthController {\n  constructor(private authService: AuthService) {}\n\n  handleRegister(username: string, password: string): string {\n    // TODO: Call service and return user-friendly message\n    return '';\n  }\n\n  handleLogin(username: string, password: string): string {\n    // TODO: Call service and return user-friendly message\n    return '';\n  }\n}",
    "solution": "// Data Access Layer\nclass UserDataAccess {\n  private users: Map<string, { username: string; password: string }> = new Map();\n\n  findByUsername(username: string) {\n    return this.users.get(username);\n  }\n\n  save(username: string, password: string) {\n    this.users.set(username, { username, password });\n  }\n}\n\n// Business Logic Layer\nclass AuthService {\n  constructor(private dataAccess: UserDataAccess) {}\n\n  register(username: string, password: string): boolean {\n    if (username.length < 3 || password.length < 6) {\n      return false;\n    }\n\n    if (this.dataAccess.findByUsername(username)) {\n      return false;\n    }\n\n    this.dataAccess.save(username, password);\n    return true;\n  }\n\n  login(username: string, password: string): boolean {\n    const user = this.dataAccess.findByUsername(username);\n    return user !== undefined && user.password === password;\n  }\n}\n\n// Presentation Layer\nclass AuthController {\n  constructor(private authService: AuthService) {}\n\n  handleRegister(username: string, password: string): string {\n    const success = this.authService.register(username, password);\n    return success\n      ? `User ${username} registered successfully`\n      : 'Registration failed: invalid credentials or user exists';\n  }\n\n  handleLogin(username: string, password: string): string {\n    const success = this.authService.login(username, password);\n    return success\n      ? `Welcome, ${username}!`\n      : 'Login failed: invalid credentials';\n  }\n}\n\n// Usage\nconst dataAccess = new UserDataAccess();\nconst authService = new AuthService(dataAccess);\nconst controller = new AuthController(authService);\n\nconsole.log(controller.handleRegister('john', 'pass123'));\nconsole.log(controller.handleLogin('john', 'pass123'));\nconsole.log(controller.handleLogin('john', 'wrongpass'));",
    "hints": [
      "Each layer should only communicate with adjacent layers",
      "Data layer only handles storage, no validation",
      "Business layer validates and enforces rules",
      "Presentation layer handles user interaction and formatting"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex04",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "MVC Pattern Implementation",
    "difficulty": 2,
    "description": "Implement the Model-View-Controller pattern for a simple Todo application. The Model manages data, the View handles display logic, and the Controller coordinates between them.\n\nCreate a TodoMVC that can add, remove, and list todos while maintaining separation of concerns.",
    "starterCode": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\n// Model: Manages data and business logic\nclass TodoModel {\n  private todos: Todo[] = [];\n  private nextId = 1;\n\n  addTodo(text: string): Todo {\n    // TODO: Create and add todo\n    return null as any;\n  }\n\n  removeTodo(id: number): boolean {\n    // TODO: Remove todo by id\n    return false;\n  }\n\n  toggleTodo(id: number): boolean {\n    // TODO: Toggle completed status\n    return false;\n  }\n\n  getAllTodos(): Todo[] {\n    // TODO: Return all todos\n    return [];\n  }\n}\n\n// View: Handles presentation\nclass TodoView {\n  displayTodos(todos: Todo[]): void {\n    // TODO: Format and display todos\n  }\n\n  displayMessage(message: string): void {\n    console.log(message);\n  }\n}\n\n// Controller: Coordinates Model and View\nclass TodoController {\n  constructor(\n    private model: TodoModel,\n    private view: TodoView\n  ) {}\n\n  addTodo(text: string): void {\n    // TODO: Add todo via model, update view\n  }\n\n  removeTodo(id: number): void {\n    // TODO: Remove todo via model, update view\n  }\n\n  showTodos(): void {\n    // TODO: Get todos from model, display via view\n  }\n}",
    "solution": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\n// Model: Manages data and business logic\nclass TodoModel {\n  private todos: Todo[] = [];\n  private nextId = 1;\n\n  addTodo(text: string): Todo {\n    const todo: Todo = {\n      id: this.nextId++,\n      text,\n      completed: false\n    };\n    this.todos.push(todo);\n    return todo;\n  }\n\n  removeTodo(id: number): boolean {\n    const index = this.todos.findIndex(t => t.id === id);\n    if (index === -1) return false;\n    this.todos.splice(index, 1);\n    return true;\n  }\n\n  toggleTodo(id: number): boolean {\n    const todo = this.todos.find(t => t.id === id);\n    if (!todo) return false;\n    todo.completed = !todo.completed;\n    return true;\n  }\n\n  getAllTodos(): Todo[] {\n    return [...this.todos];\n  }\n}\n\n// View: Handles presentation\nclass TodoView {\n  displayTodos(todos: Todo[]): void {\n    console.log('\\n=== Todo List ===');\n    if (todos.length === 0) {\n      console.log('No todos yet!');\n      return;\n    }\n\n    todos.forEach(todo => {\n      const status = todo.completed ? '✓' : ' ';\n      console.log(`[${status}] ${todo.id}. ${todo.text}`);\n    });\n  }\n\n  displayMessage(message: string): void {\n    console.log(message);\n  }\n}\n\n// Controller: Coordinates Model and View\nclass TodoController {\n  constructor(\n    private model: TodoModel,\n    private view: TodoView\n  ) {}\n\n  addTodo(text: string): void {\n    const todo = this.model.addTodo(text);\n    this.view.displayMessage(`Added: ${todo.text}`);\n    this.showTodos();\n  }\n\n  removeTodo(id: number): void {\n    const success = this.model.removeTodo(id);\n    if (success) {\n      this.view.displayMessage(`Removed todo #${id}`);\n      this.showTodos();\n    } else {\n      this.view.displayMessage(`Todo #${id} not found`);\n    }\n  }\n\n  showTodos(): void {\n    const todos = this.model.getAllTodos();\n    this.view.displayTodos(todos);\n  }\n}\n\n// Usage\nconst model = new TodoModel();\nconst view = new TodoView();\nconst controller = new TodoController(model, view);\n\ncontroller.addTodo('Learn MVC pattern');\ncontroller.addTodo('Build a web app');\ncontroller.removeTodo(1);",
    "hints": [
      "Model should not know about View or Controller",
      "View should only handle presentation logic",
      "Controller mediates between Model and View",
      "Model returns data, View formats it for display"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex05",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Factory Pattern for Multi-Database Support",
    "difficulty": 1,
    "description": "Implement the Factory pattern to create different database connection objects. Support multiple database types (PostgreSQL, MySQL, MongoDB) through a unified factory interface.\n\nThe factory should return database-specific implementations that conform to a common interface.",
    "starterCode": "interface Database {\n  connect(): string;\n  query(sql: string): string;\n  disconnect(): string;\n}\n\nclass PostgresDatabase implements Database {\n  connect(): string {\n    // TODO\n    return '';\n  }\n\n  query(sql: string): string {\n    // TODO\n    return '';\n  }\n\n  disconnect(): string {\n    // TODO\n    return '';\n  }\n}\n\n// TODO: Implement MySQLDatabase and MongoDatabase\n\nclass DatabaseFactory {\n  static create(type: 'postgres' | 'mysql' | 'mongo'): Database {\n    // TODO: Return appropriate database instance\n    throw new Error('Not implemented');\n  }\n}",
    "solution": "interface Database {\n  connect(): string;\n  query(sql: string): string;\n  disconnect(): string;\n}\n\nclass PostgresDatabase implements Database {\n  connect(): string {\n    return 'Connected to PostgreSQL on port 5432';\n  }\n\n  query(sql: string): string {\n    return `PostgreSQL executing: ${sql}`;\n  }\n\n  disconnect(): string {\n    return 'Disconnected from PostgreSQL';\n  }\n}\n\nclass MySQLDatabase implements Database {\n  connect(): string {\n    return 'Connected to MySQL on port 3306';\n  }\n\n  query(sql: string): string {\n    return `MySQL executing: ${sql}`;\n  }\n\n  disconnect(): string {\n    return 'Disconnected from MySQL';\n  }\n}\n\nclass MongoDatabase implements Database {\n  connect(): string {\n    return 'Connected to MongoDB on port 27017';\n  }\n\n  query(sql: string): string {\n    return `MongoDB executing: ${sql}`;\n  }\n\n  disconnect(): string {\n    return 'Disconnected from MongoDB';\n  }\n}\n\nclass DatabaseFactory {\n  static create(type: 'postgres' | 'mysql' | 'mongo'): Database {\n    switch (type) {\n      case 'postgres':\n        return new PostgresDatabase();\n      case 'mysql':\n        return new MySQLDatabase();\n      case 'mongo':\n        return new MongoDatabase();\n      default:\n        throw new Error(`Unknown database type: ${type}`);\n    }\n  }\n}\n\n// Usage\nconst db1 = DatabaseFactory.create('postgres');\nconsole.log(db1.connect());\nconsole.log(db1.query('SELECT * FROM users'));\n\nconst db2 = DatabaseFactory.create('mongo');\nconsole.log(db2.connect());\nconsole.log(db2.query('db.users.find()'));",
    "hints": [
      "All database classes implement the same interface",
      "Factory method uses switch or if-else to determine type",
      "Each database has different connection details",
      "Client code works with Database interface, not concrete classes"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex06",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Observer Pattern for Event System",
    "difficulty": 2,
    "description": "Implement the Observer pattern for a real-time notification system. Create a subject that notifies multiple observers when events occur.\n\nBuild a stock price tracker that notifies different types of observers (email, SMS, dashboard) when prices change.",
    "starterCode": "interface Observer {\n  update(stock: string, price: number): void;\n}\n\nclass Subject {\n  private observers: Observer[] = [];\n\n  attach(observer: Observer): void {\n    // TODO\n  }\n\n  detach(observer: Observer): void {\n    // TODO\n  }\n\n  notify(stock: string, price: number): void {\n    // TODO\n  }\n}\n\nclass StockTracker extends Subject {\n  private prices: Map<string, number> = new Map();\n\n  setPrice(stock: string, price: number): void {\n    // TODO: Update price and notify observers\n  }\n\n  getPrice(stock: string): number | undefined {\n    return this.prices.get(stock);\n  }\n}\n\n// TODO: Implement EmailObserver, SMSObserver, DashboardObserver",
    "solution": "interface Observer {\n  update(stock: string, price: number): void;\n}\n\nclass Subject {\n  private observers: Observer[] = [];\n\n  attach(observer: Observer): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n    }\n  }\n\n  detach(observer: Observer): void {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(stock: string, price: number): void {\n    this.observers.forEach(observer => observer.update(stock, price));\n  }\n}\n\nclass StockTracker extends Subject {\n  private prices: Map<string, number> = new Map();\n\n  setPrice(stock: string, price: number): void {\n    this.prices.set(stock, price);\n    this.notify(stock, price);\n  }\n\n  getPrice(stock: string): number | undefined {\n    return this.prices.get(stock);\n  }\n}\n\nclass EmailObserver implements Observer {\n  constructor(private email: string) {}\n\n  update(stock: string, price: number): void {\n    console.log(`[EMAIL to ${this.email}] ${stock} is now $${price}`);\n  }\n}\n\nclass SMSObserver implements Observer {\n  constructor(private phone: string) {}\n\n  update(stock: string, price: number): void {\n    console.log(`[SMS to ${this.phone}] ${stock}: $${price}`);\n  }\n}\n\nclass DashboardObserver implements Observer {\n  update(stock: string, price: number): void {\n    console.log(`[DASHBOARD] Updated ${stock} = $${price}`);\n  }\n}\n\n// Usage\nconst tracker = new StockTracker();\n\nconst emailObs = new EmailObserver('investor@example.com');\nconst smsObs = new SMSObserver('+1234567890');\nconst dashObs = new DashboardObserver();\n\ntracker.attach(emailObs);\ntracker.attach(smsObs);\ntracker.attach(dashObs);\n\ntracker.setPrice('AAPL', 150.25);\ntracker.setPrice('GOOGL', 2800.50);\n\ntracker.detach(smsObs);\ntracker.setPrice('AAPL', 151.00);",
    "hints": [
      "Subject maintains a list of observers",
      "attach() adds observer to the list",
      "notify() calls update() on all observers",
      "Each observer implements update() differently"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex07",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Database Schema Design - E-Commerce",
    "difficulty": 3,
    "description": "Design a normalized database schema for an e-commerce platform. Create TypeScript interfaces representing database tables for users, products, orders, and order items.\n\nImplement proper relationships (one-to-many, many-to-many) and demonstrate CRUD operations with referential integrity.",
    "starterCode": "// TODO: Define interfaces for User, Product, Order, OrderItem\n\nclass ECommerceDB {\n  private users: Map<string, any> = new Map();\n  private products: Map<string, any> = new Map();\n  private orders: Map<string, any> = new Map();\n  private orderItems: Map<string, any> = new Map();\n\n  // User operations\n  createUser(email: string, name: string) {\n    // TODO\n  }\n\n  // Product operations\n  createProduct(name: string, price: number, stock: number) {\n    // TODO\n  }\n\n  // Order operations\n  createOrder(userId: string) {\n    // TODO\n  }\n\n  addOrderItem(orderId: string, productId: string, quantity: number) {\n    // TODO: Check stock, update quantities\n  }\n\n  getOrderDetails(orderId: string) {\n    // TODO: Return order with all items and user info\n  }\n}",
    "solution": "interface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: Date;\n}\n\ninterface Product {\n  id: string;\n  name: string;\n  price: number;\n  stock: number;\n}\n\ninterface Order {\n  id: string;\n  userId: string;\n  status: 'pending' | 'paid' | 'shipped' | 'delivered';\n  total: number;\n  createdAt: Date;\n}\n\ninterface OrderItem {\n  id: string;\n  orderId: string;\n  productId: string;\n  quantity: number;\n  priceAtPurchase: number;\n}\n\nclass ECommerceDB {\n  private users: Map<string, User> = new Map();\n  private products: Map<string, Product> = new Map();\n  private orders: Map<string, Order> = new Map();\n  private orderItems: Map<string, OrderItem> = new Map();\n  private nextId = 1;\n\n  // User operations\n  createUser(email: string, name: string): User {\n    const user: User = {\n      id: `user_${this.nextId++}`,\n      email,\n      name,\n      createdAt: new Date()\n    };\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  // Product operations\n  createProduct(name: string, price: number, stock: number): Product {\n    const product: Product = {\n      id: `prod_${this.nextId++}`,\n      name,\n      price,\n      stock\n    };\n    this.products.set(product.id, product);\n    return product;\n  }\n\n  // Order operations\n  createOrder(userId: string): Order {\n    const user = this.users.get(userId);\n    if (!user) throw new Error('User not found');\n\n    const order: Order = {\n      id: `order_${this.nextId++}`,\n      userId,\n      status: 'pending',\n      total: 0,\n      createdAt: new Date()\n    };\n    this.orders.set(order.id, order);\n    return order;\n  }\n\n  addOrderItem(orderId: string, productId: string, quantity: number): OrderItem {\n    const order = this.orders.get(orderId);\n    const product = this.products.get(productId);\n\n    if (!order) throw new Error('Order not found');\n    if (!product) throw new Error('Product not found');\n    if (product.stock < quantity) throw new Error('Insufficient stock');\n\n    const orderItem: OrderItem = {\n      id: `item_${this.nextId++}`,\n      orderId,\n      productId,\n      quantity,\n      priceAtPurchase: product.price\n    };\n\n    // Update stock and order total\n    product.stock -= quantity;\n    order.total += product.price * quantity;\n\n    this.orderItems.set(orderItem.id, orderItem);\n    return orderItem;\n  }\n\n  getOrderDetails(orderId: string) {\n    const order = this.orders.get(orderId);\n    if (!order) throw new Error('Order not found');\n\n    const user = this.users.get(order.userId);\n    const items = Array.from(this.orderItems.values())\n      .filter(item => item.orderId === orderId)\n      .map(item => {\n        const product = this.products.get(item.productId);\n        return {\n          ...item,\n          productName: product?.name,\n          subtotal: item.priceAtPurchase * item.quantity\n        };\n      });\n\n    return {\n      order,\n      user,\n      items\n    };\n  }\n}\n\n// Usage\nconst db = new ECommerceDB();\n\nconst user = db.createUser('alice@example.com', 'Alice');\nconst laptop = db.createProduct('Laptop', 999.99, 10);\nconst mouse = db.createProduct('Mouse', 29.99, 50);\n\nconst order = db.createOrder(user.id);\ndb.addOrderItem(order.id, laptop.id, 1);\ndb.addOrderItem(order.id, mouse.id, 2);\n\nconsole.log(db.getOrderDetails(order.id));",
    "hints": [
      "Use foreign keys (IDs) to establish relationships",
      "Store price at purchase time to preserve historical data",
      "Update stock levels when adding order items",
      "Calculate order total by summing item subtotals"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex08",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "RESTful API Design",
    "difficulty": 3,
    "description": "Design a RESTful API for a blog platform. Create endpoint definitions with proper HTTP methods, URL structures, request/response formats, and status codes.\n\nImplement a mock API handler that demonstrates REST principles: resource-based URLs, proper HTTP verbs, and stateless operations.",
    "starterCode": "interface BlogPost {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface ApiResponse<T = any> {\n  status: number;\n  data?: T;\n  error?: string;\n}\n\nclass BlogAPI {\n  private posts: Map<string, BlogPost> = new Map();\n  private nextId = 1;\n\n  // GET /api/posts\n  getAllPosts(): ApiResponse<BlogPost[]> {\n    // TODO\n    return { status: 200 };\n  }\n\n  // GET /api/posts/:id\n  getPost(id: string): ApiResponse<BlogPost> {\n    // TODO\n    return { status: 200 };\n  }\n\n  // POST /api/posts\n  createPost(title: string, content: string, authorId: string): ApiResponse<BlogPost> {\n    // TODO\n    return { status: 201 };\n  }\n\n  // PUT /api/posts/:id\n  updatePost(id: string, updates: Partial<BlogPost>): ApiResponse<BlogPost> {\n    // TODO\n    return { status: 200 };\n  }\n\n  // DELETE /api/posts/:id\n  deletePost(id: string): ApiResponse {\n    // TODO\n    return { status: 204 };\n  }\n}",
    "solution": "interface BlogPost {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface ApiResponse<T = any> {\n  status: number;\n  data?: T;\n  error?: string;\n}\n\nclass BlogAPI {\n  private posts: Map<string, BlogPost> = new Map();\n  private nextId = 1;\n\n  // GET /api/posts - List all posts\n  getAllPosts(): ApiResponse<BlogPost[]> {\n    return {\n      status: 200,\n      data: Array.from(this.posts.values())\n    };\n  }\n\n  // GET /api/posts/:id - Get single post\n  getPost(id: string): ApiResponse<BlogPost> {\n    const post = this.posts.get(id);\n    if (!post) {\n      return {\n        status: 404,\n        error: 'Post not found'\n      };\n    }\n    return {\n      status: 200,\n      data: post\n    };\n  }\n\n  // POST /api/posts - Create new post\n  createPost(title: string, content: string, authorId: string): ApiResponse<BlogPost> {\n    if (!title || !content || !authorId) {\n      return {\n        status: 400,\n        error: 'Missing required fields'\n      };\n    }\n\n    const post: BlogPost = {\n      id: `post_${this.nextId++}`,\n      title,\n      content,\n      authorId,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    this.posts.set(post.id, post);\n    return {\n      status: 201,\n      data: post\n    };\n  }\n\n  // PUT /api/posts/:id - Update existing post\n  updatePost(id: string, updates: Partial<BlogPost>): ApiResponse<BlogPost> {\n    const post = this.posts.get(id);\n    if (!post) {\n      return {\n        status: 404,\n        error: 'Post not found'\n      };\n    }\n\n    const updated: BlogPost = {\n      ...post,\n      ...updates,\n      id: post.id, // Prevent ID change\n      createdAt: post.createdAt, // Preserve creation date\n      updatedAt: new Date()\n    };\n\n    this.posts.set(id, updated);\n    return {\n      status: 200,\n      data: updated\n    };\n  }\n\n  // DELETE /api/posts/:id - Delete post\n  deletePost(id: string): ApiResponse {\n    if (!this.posts.has(id)) {\n      return {\n        status: 404,\n        error: 'Post not found'\n      };\n    }\n\n    this.posts.delete(id);\n    return {\n      status: 204 // No content\n    };\n  }\n}\n\n// Usage demonstration\nconst api = new BlogAPI();\n\n// Create posts\nconsole.log('Creating post:', api.createPost('First Post', 'Hello World', 'user1'));\nconsole.log('Creating post:', api.createPost('Second Post', 'REST API', 'user1'));\n\n// Get all posts\nconsole.log('All posts:', api.getAllPosts());\n\n// Get single post\nconsole.log('Get post:', api.getPost('post_1'));\n\n// Update post\nconsole.log('Update post:', api.updatePost('post_1', { title: 'Updated Title' }));\n\n// Delete post\nconsole.log('Delete post:', api.deletePost('post_2'));\n\n// Try to get deleted post\nconsole.log('Get deleted post:', api.getPost('post_2'));",
    "hints": [
      "Use appropriate HTTP status codes: 200 OK, 201 Created, 204 No Content, 404 Not Found",
      "Resource URLs should be nouns (posts), not verbs",
      "PUT updates should preserve id and createdAt",
      "Return error messages for 4xx responses"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex09",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "GraphQL vs REST Comparison",
    "difficulty": 3,
    "description": "Implement both REST and GraphQL-style APIs for the same data model to understand the differences. Create a user/posts system that demonstrates over-fetching in REST vs precise queries in GraphQL.\n\nShow how GraphQL allows clients to request exactly the data they need.",
    "starterCode": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  bio: string;\n}\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n}\n\n// REST API - Returns all fields\nclass RestAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  getUser(id: string) {\n    // TODO: Returns entire user object\n  }\n\n  getUserPosts(userId: string) {\n    // TODO: Returns all posts by user\n  }\n}\n\n// GraphQL-style API - Returns only requested fields\nclass GraphQLAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  query(queryString: string) {\n    // TODO: Parse query and return only requested fields\n    // Example query: \"user(id: '1') { name, posts { title } }\"\n  }\n}",
    "solution": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  bio: string;\n}\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n}\n\n// REST API - Returns all fields (over-fetching)\nclass RestAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  constructor() {\n    // Seed data\n    this.users.set('1', {\n      id: '1',\n      name: 'Alice',\n      email: 'alice@example.com',\n      bio: 'Software engineer'\n    });\n    this.posts.set('1', {\n      id: '1',\n      title: 'First Post',\n      content: 'Long content here...',\n      authorId: '1'\n    });\n  }\n\n  getUser(id: string) {\n    return this.users.get(id); // Returns ALL user fields\n  }\n\n  getUserPosts(userId: string) {\n    return Array.from(this.posts.values())\n      .filter(p => p.authorId === userId); // Returns ALL post fields\n  }\n}\n\n// GraphQL-style API - Returns only requested fields\nclass GraphQLAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  constructor() {\n    // Seed data\n    this.users.set('1', {\n      id: '1',\n      name: 'Alice',\n      email: 'alice@example.com',\n      bio: 'Software engineer'\n    });\n    this.posts.set('1', {\n      id: '1',\n      title: 'First Post',\n      content: 'Long content here...',\n      authorId: '1'\n    });\n  }\n\n  query(fields: { user?: { id: string; fields: string[] }; posts?: boolean }) {\n    const result: any = {};\n\n    if (fields.user) {\n      const user = this.users.get(fields.user.id);\n      if (user) {\n        result.user = {};\n        fields.user.fields.forEach(field => {\n          if (field in user) {\n            result.user[field] = user[field as keyof User];\n          }\n        });\n\n        if (fields.posts && result.user) {\n          result.user.posts = Array.from(this.posts.values())\n            .filter(p => p.authorId === user.id)\n            .map(p => ({ id: p.id, title: p.title }));\n        }\n      }\n    }\n\n    return result;\n  }\n}\n\n// Usage comparison\nconsole.log('=== REST API (Over-fetching) ===');\nconst restApi = new RestAPI();\nconsole.log('Get user (only need name):');\nconsole.log(restApi.getUser('1')); // Returns all fields including email, bio\n\nconsole.log('\\n=== GraphQL API (Precise) ===');\nconst graphqlApi = new GraphQLAPI();\nconsole.log('Get user (only need name):');\nconsole.log(graphqlApi.query({\n  user: { id: '1', fields: ['name'] }\n})); // Returns only name\n\nconsole.log('\\nGet user name and post titles:');\nconsole.log(graphqlApi.query({\n  user: { id: '1', fields: ['name'] },\n  posts: true\n})); // Returns only requested fields\n\n/*\nREST returns everything:\n{ id: '1', name: 'Alice', email: 'alice@example.com', bio: 'Software engineer' }\n\nGraphQL returns only what you need:\n{ user: { name: 'Alice' } }\n{ user: { name: 'Alice', posts: [{ id: '1', title: 'First Post' }] } }\n*/",
    "hints": [
      "REST always returns the complete resource",
      "GraphQL allows specifying exactly which fields to return",
      "GraphQL can fetch related data in a single request",
      "Over-fetching wastes bandwidth and processing"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex10",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "JWT Authentication System",
    "difficulty": 4,
    "description": "Implement a JWT (JSON Web Token) based authentication system. Create functions to generate tokens, verify tokens, and protect routes.\n\nBuild a complete auth flow: login generates JWT, protected routes verify JWT, and tokens expire after a set time.",
    "starterCode": "interface JWTPayload {\n  userId: string;\n  email: string;\n  exp: number; // Expiration timestamp\n  iat: number; // Issued at timestamp\n}\n\nclass JWTAuth {\n  private secret = 'your-secret-key';\n  private expirationMinutes = 60;\n\n  // Simple base64 encoding (in production, use crypto libraries)\n  private encode(data: string): string {\n    return Buffer.from(data).toString('base64');\n  }\n\n  private decode(data: string): string {\n    return Buffer.from(data, 'base64').toString('utf-8');\n  }\n\n  generateToken(userId: string, email: string): string {\n    // TODO: Create JWT with header, payload, signature\n    return '';\n  }\n\n  verifyToken(token: string): JWTPayload | null {\n    // TODO: Verify signature and expiration\n    return null;\n  }\n\n  isTokenExpired(payload: JWTPayload): boolean {\n    // TODO: Check if current time > expiration\n    return true;\n  }\n}\n\nclass ProtectedAPI {\n  constructor(private auth: JWTAuth) {}\n\n  login(email: string, password: string): { token: string } | { error: string } {\n    // TODO: Validate credentials and return token\n    return { error: 'Not implemented' };\n  }\n\n  getProfile(token: string): { user: any } | { error: string } {\n    // TODO: Verify token and return user data\n    return { error: 'Not implemented' };\n  }\n}",
    "solution": "interface JWTPayload {\n  userId: string;\n  email: string;\n  exp: number; // Expiration timestamp\n  iat: number; // Issued at timestamp\n}\n\nclass JWTAuth {\n  private secret = 'your-secret-key';\n  private expirationMinutes = 60;\n\n  // Simple base64 encoding (in production, use crypto libraries)\n  private encode(data: string): string {\n    return Buffer.from(data).toString('base64');\n  }\n\n  private decode(data: string): string {\n    return Buffer.from(data, 'base64').toString('utf-8');\n  }\n\n  private sign(data: string): string {\n    // Simple signature (in production, use HMAC-SHA256)\n    return this.encode(data + this.secret);\n  }\n\n  private verify(data: string, signature: string): boolean {\n    return this.sign(data) === signature;\n  }\n\n  generateToken(userId: string, email: string): string {\n    const header = { alg: 'HS256', typ: 'JWT' };\n    const now = Math.floor(Date.now() / 1000);\n    const payload: JWTPayload = {\n      userId,\n      email,\n      iat: now,\n      exp: now + (this.expirationMinutes * 60)\n    };\n\n    const encodedHeader = this.encode(JSON.stringify(header));\n    const encodedPayload = this.encode(JSON.stringify(payload));\n    const signature = this.sign(`${encodedHeader}.${encodedPayload}`);\n\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\n  }\n\n  verifyToken(token: string): JWTPayload | null {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return null;\n\n      const [encodedHeader, encodedPayload, signature] = parts;\n\n      // Verify signature\n      if (!this.verify(`${encodedHeader}.${encodedPayload}`, signature)) {\n        return null;\n      }\n\n      // Decode payload\n      const payload: JWTPayload = JSON.parse(this.decode(encodedPayload));\n\n      // Check expiration\n      if (this.isTokenExpired(payload)) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  isTokenExpired(payload: JWTPayload): boolean {\n    const now = Math.floor(Date.now() / 1000);\n    return now > payload.exp;\n  }\n}\n\nclass ProtectedAPI {\n  private users = new Map([\n    ['alice@example.com', { userId: '1', email: 'alice@example.com', password: 'pass123', name: 'Alice' }]\n  ]);\n\n  constructor(private auth: JWTAuth) {}\n\n  login(email: string, password: string): { token: string } | { error: string } {\n    const user = this.users.get(email);\n    if (!user || user.password !== password) {\n      return { error: 'Invalid credentials' };\n    }\n\n    const token = this.auth.generateToken(user.userId, user.email);\n    return { token };\n  }\n\n  getProfile(token: string): { user: any } | { error: string } {\n    const payload = this.auth.verifyToken(token);\n    if (!payload) {\n      return { error: 'Invalid or expired token' };\n    }\n\n    const user = this.users.get(payload.email);\n    if (!user) {\n      return { error: 'User not found' };\n    }\n\n    const { password, ...safeUser } = user;\n    return { user: safeUser };\n  }\n}\n\n// Usage\nconst auth = new JWTAuth();\nconst api = new ProtectedAPI(auth);\n\n// Login\nconst loginResult = api.login('alice@example.com', 'pass123');\nconsole.log('Login:', loginResult);\n\nif ('token' in loginResult) {\n  // Access protected route\n  console.log('Profile:', api.getProfile(loginResult.token));\n\n  // Try invalid token\n  console.log('Invalid token:', api.getProfile('invalid.token.here'));\n}",
    "hints": [
      "JWT structure: header.payload.signature (all base64 encoded)",
      "Include expiration timestamp in payload",
      "Verify both signature and expiration",
      "Never store sensitive data in JWT payload (it's not encrypted)"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex11",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Role-Based Access Control (RBAC)",
    "difficulty": 4,
    "description": "Implement a Role-Based Access Control system with roles, permissions, and resource protection. Create an authorization system that checks if users have the required permissions to perform actions.\n\nSupport multiple roles (admin, editor, viewer) with different permission sets.",
    "starterCode": "type Permission = 'create' | 'read' | 'update' | 'delete';\ntype Role = 'admin' | 'editor' | 'viewer';\n\ninterface User {\n  id: string;\n  name: string;\n  role: Role;\n}\n\nclass RBAC {\n  private rolePermissions: Map<Role, Permission[]> = new Map();\n\n  constructor() {\n    // TODO: Define role permissions\n    // admin: all permissions\n    // editor: create, read, update\n    // viewer: read only\n  }\n\n  hasPermission(user: User, permission: Permission): boolean {\n    // TODO: Check if user's role has the permission\n    return false;\n  }\n\n  authorize(user: User, action: Permission): void {\n    // TODO: Throw error if user lacks permission\n  }\n}\n\nclass DocumentService {\n  private documents: Map<string, any> = new Map();\n\n  constructor(private rbac: RBAC) {}\n\n  createDocument(user: User, title: string, content: string) {\n    // TODO: Check permission, then create\n  }\n\n  readDocument(user: User, id: string) {\n    // TODO: Check permission, then read\n  }\n\n  updateDocument(user: User, id: string, updates: any) {\n    // TODO: Check permission, then update\n  }\n\n  deleteDocument(user: User, id: string) {\n    // TODO: Check permission, then delete\n  }\n}",
    "solution": "type Permission = 'create' | 'read' | 'update' | 'delete';\ntype Role = 'admin' | 'editor' | 'viewer';\n\ninterface User {\n  id: string;\n  name: string;\n  role: Role;\n}\n\nclass RBAC {\n  private rolePermissions: Map<Role, Permission[]> = new Map();\n\n  constructor() {\n    // Define role permissions\n    this.rolePermissions.set('admin', ['create', 'read', 'update', 'delete']);\n    this.rolePermissions.set('editor', ['create', 'read', 'update']);\n    this.rolePermissions.set('viewer', ['read']);\n  }\n\n  hasPermission(user: User, permission: Permission): boolean {\n    const permissions = this.rolePermissions.get(user.role);\n    return permissions ? permissions.includes(permission) : false;\n  }\n\n  authorize(user: User, action: Permission): void {\n    if (!this.hasPermission(user, action)) {\n      throw new Error(`User ${user.name} (${user.role}) is not authorized to ${action}`);\n    }\n  }\n}\n\nclass DocumentService {\n  private documents: Map<string, any> = new Map();\n  private nextId = 1;\n\n  constructor(private rbac: RBAC) {}\n\n  createDocument(user: User, title: string, content: string) {\n    this.rbac.authorize(user, 'create');\n\n    const doc = {\n      id: `doc_${this.nextId++}`,\n      title,\n      content,\n      createdBy: user.id,\n      createdAt: new Date()\n    };\n\n    this.documents.set(doc.id, doc);\n    return doc;\n  }\n\n  readDocument(user: User, id: string) {\n    this.rbac.authorize(user, 'read');\n\n    const doc = this.documents.get(id);\n    if (!doc) throw new Error('Document not found');\n    return doc;\n  }\n\n  updateDocument(user: User, id: string, updates: any) {\n    this.rbac.authorize(user, 'update');\n\n    const doc = this.documents.get(id);\n    if (!doc) throw new Error('Document not found');\n\n    const updated = { ...doc, ...updates, updatedAt: new Date() };\n    this.documents.set(id, updated);\n    return updated;\n  }\n\n  deleteDocument(user: User, id: string) {\n    this.rbac.authorize(user, 'delete');\n\n    if (!this.documents.has(id)) {\n      throw new Error('Document not found');\n    }\n\n    this.documents.delete(id);\n    return { message: 'Document deleted' };\n  }\n}\n\n// Usage\nconst rbac = new RBAC();\nconst docService = new DocumentService(rbac);\n\nconst admin: User = { id: '1', name: 'Admin User', role: 'admin' };\nconst editor: User = { id: '2', name: 'Editor User', role: 'editor' };\nconst viewer: User = { id: '3', name: 'Viewer User', role: 'viewer' };\n\n// Admin can do everything\nconst doc = docService.createDocument(admin, 'First Doc', 'Content');\nconsole.log('Created:', doc);\n\n// Editor can read and update\nconsole.log('Read:', docService.readDocument(editor, doc.id));\nconsole.log('Update:', docService.updateDocument(editor, doc.id, { content: 'New content' }));\n\n// Viewer can only read\nconsole.log('Read:', docService.readDocument(viewer, doc.id));\n\ntry {\n  // Viewer cannot delete\n  docService.deleteDocument(viewer, doc.id);\n} catch (err: any) {\n  console.log('Error:', err.message);\n}\n\n// Admin can delete\nconsole.log('Delete:', docService.deleteDocument(admin, doc.id));",
    "hints": [
      "Map roles to their allowed permissions",
      "Check permissions before executing actions",
      "Throw errors for unauthorized actions",
      "More restrictive roles should have fewer permissions"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex12",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Microservices vs Monolith Decision Framework",
    "difficulty": 4,
    "description": "Create a decision framework that helps evaluate whether to use microservices or monolithic architecture. Implement a scoring system based on various factors.\n\nConsider team size, deployment frequency, scalability needs, and complexity to recommend an architecture.",
    "starterCode": "interface ProjectRequirements {\n  teamSize: number;\n  deploymentFrequency: 'daily' | 'weekly' | 'monthly';\n  expectedScale: 'small' | 'medium' | 'large';\n  serviceDiversity: 'low' | 'medium' | 'high'; // Different tech needs\n  timeline: 'short' | 'medium' | 'long';\n  budget: 'low' | 'medium' | 'high';\n}\n\ninterface ArchitectureRecommendation {\n  recommendation: 'monolith' | 'microservices' | 'modular-monolith';\n  score: number; // -10 to +10 (negative = monolith, positive = microservices)\n  reasoning: string[];\n  risks: string[];\n}\n\nclass ArchitectureDecisionFramework {\n  evaluate(requirements: ProjectRequirements): ArchitectureRecommendation {\n    // TODO: Implement scoring logic\n    // Consider:\n    // - Small teams favor monolith\n    // - High deployment frequency favors microservices\n    // - Large scale favors microservices\n    // - High service diversity favors microservices\n    // - Short timeline favors monolith\n    // - Low budget favors monolith\n\n    return {\n      recommendation: 'monolith',\n      score: 0,\n      reasoning: [],\n      risks: []\n    };\n  }\n}",
    "solution": "interface ProjectRequirements {\n  teamSize: number;\n  deploymentFrequency: 'daily' | 'weekly' | 'monthly';\n  expectedScale: 'small' | 'medium' | 'large';\n  serviceDiversity: 'low' | 'medium' | 'high';\n  timeline: 'short' | 'medium' | 'long';\n  budget: 'low' | 'medium' | 'high';\n}\n\ninterface ArchitectureRecommendation {\n  recommendation: 'monolith' | 'microservices' | 'modular-monolith';\n  score: number;\n  reasoning: string[];\n  risks: string[];\n}\n\nclass ArchitectureDecisionFramework {\n  evaluate(requirements: ProjectRequirements): ArchitectureRecommendation {\n    let score = 0;\n    const reasoning: string[] = [];\n    const risks: string[] = [];\n\n    // Team size factor\n    if (requirements.teamSize < 5) {\n      score -= 3;\n      reasoning.push('Small team size favors monolith for simpler coordination');\n    } else if (requirements.teamSize > 15) {\n      score += 3;\n      reasoning.push('Large team can manage distributed microservices');\n    } else {\n      score += 1;\n      reasoning.push('Medium team size can handle either architecture');\n    }\n\n    // Deployment frequency\n    const deploymentScores = { daily: 2, weekly: 1, monthly: -2 };\n    score += deploymentScores[requirements.deploymentFrequency];\n    reasoning.push(`${requirements.deploymentFrequency} deployments ${\n      deploymentScores[requirements.deploymentFrequency] > 0\n        ? 'benefit from microservices independence'\n        : 'acceptable with monolith'\n    }`);\n\n    // Scale requirements\n    const scaleScores = { small: -2, medium: 0, large: 3 };\n    score += scaleScores[requirements.expectedScale];\n    reasoning.push(`${requirements.expectedScale} scale ${\n      scaleScores[requirements.expectedScale] > 0\n        ? 'requires independent scaling of microservices'\n        : 'manageable with monolith'\n    }`);\n\n    // Service diversity (different tech stacks)\n    const diversityScores = { low: -1, medium: 1, high: 3 };\n    score += diversityScores[requirements.serviceDiversity];\n    reasoning.push(`${requirements.serviceDiversity} service diversity ${\n      diversityScores[requirements.serviceDiversity] > 0\n        ? 'benefits from polyglot microservices'\n        : 'suits unified monolith stack'\n    }`);\n\n    // Timeline\n    const timelineScores = { short: -3, medium: 0, long: 2 };\n    score += timelineScores[requirements.timeline];\n    reasoning.push(`${requirements.timeline} timeline ${\n      timelineScores[requirements.timeline] < 0\n        ? 'requires fast monolith development'\n        : 'allows time for microservices setup'\n    }`);\n\n    // Budget\n    const budgetScores = { low: -2, medium: 0, high: 1 };\n    score += budgetScores[requirements.budget];\n    reasoning.push(`${requirements.budget} budget ${\n      budgetScores[requirements.budget] < 0\n        ? 'limits infrastructure for microservices'\n        : 'supports distributed infrastructure'\n    }`);\n\n    // Determine recommendation\n    let recommendation: 'monolith' | 'microservices' | 'modular-monolith';\n    if (score <= -3) {\n      recommendation = 'monolith';\n      risks.push('May face scaling challenges as system grows');\n      risks.push('Deployment of entire application required for any change');\n    } else if (score >= 5) {\n      recommendation = 'microservices';\n      risks.push('Increased operational complexity');\n      risks.push('Network latency and distributed system challenges');\n      risks.push('Higher infrastructure costs');\n    } else {\n      recommendation = 'modular-monolith';\n      reasoning.push('Balanced approach: modular design with monolith simplicity');\n      risks.push('Must maintain strong module boundaries');\n    }\n\n    return {\n      recommendation,\n      score,\n      reasoning,\n      risks\n    };\n  }\n\n  printRecommendation(rec: ArchitectureRecommendation): void {\n    console.log(`\\n=== Architecture Recommendation ===`);\n    console.log(`Recommendation: ${rec.recommendation.toUpperCase()}`);\n    console.log(`Score: ${rec.score}`);\n    console.log(`\\nReasoning:`);\n    rec.reasoning.forEach((r, i) => console.log(`  ${i + 1}. ${r}`));\n    console.log(`\\nRisks to Consider:`);\n    rec.risks.forEach((r, i) => console.log(`  ${i + 1}. ${r}`));\n  }\n}\n\n// Usage examples\nconst framework = new ArchitectureDecisionFramework();\n\n// Startup scenario - favor monolith\nconst startup = framework.evaluate({\n  teamSize: 3,\n  deploymentFrequency: 'weekly',\n  expectedScale: 'small',\n  serviceDiversity: 'low',\n  timeline: 'short',\n  budget: 'low'\n});\nframework.printRecommendation(startup);\n\n// Enterprise scenario - favor microservices\nconst enterprise = framework.evaluate({\n  teamSize: 50,\n  deploymentFrequency: 'daily',\n  expectedScale: 'large',\n  serviceDiversity: 'high',\n  timeline: 'long',\n  budget: 'high'\n});\nframework.printRecommendation(enterprise);",
    "hints": [
      "Assign positive scores for factors favoring microservices",
      "Assign negative scores for factors favoring monolith",
      "Consider modular monolith for borderline cases",
      "Include both benefits and risks in the recommendation"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex13",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Caching Strategy Implementation",
    "difficulty": 3,
    "description": "Implement multiple caching strategies: LRU (Least Recently Used), LFU (Least Frequently Used), and TTL (Time To Live). Create a cache manager that supports different eviction policies.\n\nDemonstrate how different strategies behave under various access patterns.",
    "starterCode": "interface CacheEntry<T> {\n  key: string;\n  value: T;\n  accessCount: number;\n  lastAccessed: number;\n  expiresAt?: number;\n}\n\ninterface CacheStrategy {\n  get(key: string): any;\n  set(key: string, value: any, ttl?: number): void;\n  evict(): void; // Remove one item based on strategy\n}\n\nclass LRUCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | null {\n    // TODO: Update last accessed, return value\n    return null;\n  }\n\n  set(key: string, value: T): void {\n    // TODO: Add/update entry, evict if needed\n  }\n\n  evict(): void {\n    // TODO: Remove least recently used\n  }\n}\n\n// TODO: Implement LFUCache and TTLCache",
    "solution": "interface CacheEntry<T> {\n  key: string;\n  value: T;\n  accessCount: number;\n  lastAccessed: number;\n  expiresAt?: number;\n}\n\ninterface CacheStrategy {\n  get(key: string): any;\n  set(key: string, value: any, ttl?: number): void;\n  evict(): void;\n}\n\n// Least Recently Used Cache\nclass LRUCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Update last accessed\n    entry.lastAccessed = Date.now();\n    return entry.value;\n  }\n\n  set(key: string, value: T): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evict();\n    }\n\n    this.cache.set(key, {\n      key,\n      value,\n      accessCount: 0,\n      lastAccessed: Date.now()\n    });\n  }\n\n  evict(): void {\n    let lruKey = '';\n    let oldestTime = Infinity;\n\n    for (const [key, entry] of this.cache) {\n      if (entry.lastAccessed < oldestTime) {\n        oldestTime = entry.lastAccessed;\n        lruKey = key;\n      }\n    }\n\n    if (lruKey) {\n      this.cache.delete(lruKey);\n      console.log(`[LRU] Evicted: ${lruKey}`);\n    }\n  }\n}\n\n// Least Frequently Used Cache\nclass LFUCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Increment access count\n    entry.accessCount++;\n    entry.lastAccessed = Date.now();\n    return entry.value;\n  }\n\n  set(key: string, value: T): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evict();\n    }\n\n    this.cache.set(key, {\n      key,\n      value,\n      accessCount: 0,\n      lastAccessed: Date.now()\n    });\n  }\n\n  evict(): void {\n    let lfuKey = '';\n    let lowestCount = Infinity;\n\n    for (const [key, entry] of this.cache) {\n      if (entry.accessCount < lowestCount) {\n        lowestCount = entry.accessCount;\n        lfuKey = key;\n      }\n    }\n\n    if (lfuKey) {\n      this.cache.delete(lfuKey);\n      console.log(`[LFU] Evicted: ${lfuKey}`);\n    }\n  }\n}\n\n// Time To Live Cache\nclass TTLCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number, private defaultTTL: number = 60000) {}\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Check expiration\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      console.log(`[TTL] Expired: ${key}`);\n      return null;\n    }\n\n    entry.lastAccessed = Date.now();\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evict();\n    }\n\n    const expiresAt = Date.now() + (ttl || this.defaultTTL);\n    this.cache.set(key, {\n      key,\n      value,\n      accessCount: 0,\n      lastAccessed: Date.now(),\n      expiresAt\n    });\n  }\n\n  evict(): void {\n    // Evict expired entries first\n    for (const [key, entry] of this.cache) {\n      if (entry.expiresAt && Date.now() > entry.expiresAt) {\n        this.cache.delete(key);\n        console.log(`[TTL] Evicted expired: ${key}`);\n        return;\n      }\n    }\n\n    // If no expired, evict oldest\n    let oldestKey = '';\n    let oldestTime = Infinity;\n    for (const [key, entry] of this.cache) {\n      if ((entry.expiresAt || 0) < oldestTime) {\n        oldestTime = entry.expiresAt || 0;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n      console.log(`[TTL] Evicted: ${oldestKey}`);\n    }\n  }\n}\n\n// Usage comparison\nconsole.log('=== LRU Cache ===');\nconst lru = new LRUCache<string>(3);\nlru.set('a', 'value_a');\nlru.set('b', 'value_b');\nlru.set('c', 'value_c');\nlru.get('a'); // Access 'a' to make it recently used\nlru.set('d', 'value_d'); // Should evict 'b' (least recently used)\n\nconsole.log('\\n=== LFU Cache ===');\nconst lfu = new LFUCache<string>(3);\nlfu.set('a', 'value_a');\nlfu.set('b', 'value_b');\nlfu.set('c', 'value_c');\nlfu.get('a'); // Access 'a' twice\nlfu.get('a');\nlfu.set('d', 'value_d'); // Should evict 'b' or 'c' (least frequently used)\n\nconsole.log('\\n=== TTL Cache ===');\nconst ttl = new TTLCache<string>(3, 1000); // 1 second TTL\nttl.set('a', 'value_a', 500); // 500ms TTL\nttl.set('b', 'value_b', 2000); // 2s TTL\nsetTimeout(() => {\n  console.log('After 600ms:', ttl.get('a')); // Should be null (expired)\n  console.log('After 600ms:', ttl.get('b')); // Should exist\n}, 600);",
    "hints": [
      "LRU evicts items not accessed for longest time",
      "LFU evicts items with lowest access count",
      "TTL evicts items past their expiration time",
      "Track both lastAccessed and accessCount for different strategies"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex14",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Load Balancer Implementation",
    "difficulty": 5,
    "description": "Implement a load balancer with multiple distribution strategies: Round Robin, Least Connections, and Weighted Round Robin. Track server health and distribute requests accordingly.\n\nCreate a simulation that demonstrates how different strategies distribute load across servers.",
    "starterCode": "interface Server {\n  id: string;\n  url: string;\n  activeConnections: number;\n  weight?: number; // For weighted strategies\n  healthy: boolean;\n}\n\ninterface LoadBalancerStrategy {\n  selectServer(servers: Server[]): Server | null;\n}\n\nclass RoundRobinStrategy implements LoadBalancerStrategy {\n  private currentIndex = 0;\n\n  selectServer(servers: Server[]): Server | null {\n    // TODO: Select next server in rotation\n    return null;\n  }\n}\n\n// TODO: Implement LeastConnectionsStrategy and WeightedRoundRobinStrategy\n\nclass LoadBalancer {\n  private servers: Server[] = [];\n\n  constructor(private strategy: LoadBalancerStrategy) {}\n\n  addServer(server: Server): void {\n    // TODO\n  }\n\n  handleRequest(requestId: string): string {\n    // TODO: Select server, track connection, simulate request\n    return '';\n  }\n\n  completeRequest(serverId: string): void {\n    // TODO: Decrement active connections\n  }\n}",
    "solution": "interface Server {\n  id: string;\n  url: string;\n  activeConnections: number;\n  weight?: number;\n  healthy: boolean;\n}\n\ninterface LoadBalancerStrategy {\n  selectServer(servers: Server[]): Server | null;\n}\n\nclass RoundRobinStrategy implements LoadBalancerStrategy {\n  private currentIndex = 0;\n\n  selectServer(servers: Server[]): Server | null {\n    const healthyServers = servers.filter(s => s.healthy);\n    if (healthyServers.length === 0) return null;\n\n    const server = healthyServers[this.currentIndex % healthyServers.length];\n    this.currentIndex++;\n    return server;\n  }\n}\n\nclass LeastConnectionsStrategy implements LoadBalancerStrategy {\n  selectServer(servers: Server[]): Server | null {\n    const healthyServers = servers.filter(s => s.healthy);\n    if (healthyServers.length === 0) return null;\n\n    return healthyServers.reduce((min, server) =>\n      server.activeConnections < min.activeConnections ? server : min\n    );\n  }\n}\n\nclass WeightedRoundRobinStrategy implements LoadBalancerStrategy {\n  private currentIndex = 0;\n  private currentWeight = 0;\n\n  selectServer(servers: Server[]): Server | null {\n    const healthyServers = servers.filter(s => s.healthy);\n    if (healthyServers.length === 0) return null;\n\n    const maxWeight = Math.max(...healthyServers.map(s => s.weight || 1));\n\n    while (true) {\n      this.currentIndex = (this.currentIndex + 1) % healthyServers.length;\n\n      if (this.currentIndex === 0) {\n        this.currentWeight = this.currentWeight - 1;\n        if (this.currentWeight <= 0) {\n          this.currentWeight = maxWeight;\n        }\n      }\n\n      const server = healthyServers[this.currentIndex];\n      if ((server.weight || 1) >= this.currentWeight) {\n        return server;\n      }\n    }\n  }\n}\n\nclass LoadBalancer {\n  private servers: Server[] = [];\n\n  constructor(private strategy: LoadBalancerStrategy) {}\n\n  addServer(server: Server): void {\n    this.servers.push(server);\n  }\n\n  removeServer(serverId: string): void {\n    this.servers = this.servers.filter(s => s.id !== serverId);\n  }\n\n  setServerHealth(serverId: string, healthy: boolean): void {\n    const server = this.servers.find(s => s.id === serverId);\n    if (server) {\n      server.healthy = healthy;\n      console.log(`Server ${serverId} marked as ${healthy ? 'healthy' : 'unhealthy'}`);\n    }\n  }\n\n  handleRequest(requestId: string): string {\n    const server = this.strategy.selectServer(this.servers);\n\n    if (!server) {\n      return `Request ${requestId}: No healthy servers available`;\n    }\n\n    server.activeConnections++;\n    return `Request ${requestId} -> ${server.id} (connections: ${server.activeConnections})`;\n  }\n\n  completeRequest(serverId: string): void {\n    const server = this.servers.find(s => s.id === serverId);\n    if (server && server.activeConnections > 0) {\n      server.activeConnections--;\n    }\n  }\n\n  getStatus(): void {\n    console.log('\\n=== Server Status ===');\n    this.servers.forEach(server => {\n      console.log(`${server.id}: ${server.activeConnections} active, ${\n        server.healthy ? 'healthy' : 'UNHEALTHY'\n      }${server.weight ? `, weight: ${server.weight}` : ''}`);\n    });\n  }\n}\n\n// Usage comparison\nconsole.log('=== Round Robin Strategy ===');\nconst rrLB = new LoadBalancer(new RoundRobinStrategy());\nrrLB.addServer({ id: 'server1', url: 'http://server1', activeConnections: 0, healthy: true });\nrrLB.addServer({ id: 'server2', url: 'http://server2', activeConnections: 0, healthy: true });\nrrLB.addServer({ id: 'server3', url: 'http://server3', activeConnections: 0, healthy: true });\n\nfor (let i = 1; i <= 5; i++) {\n  console.log(rrLB.handleRequest(`req${i}`));\n}\nrrLB.getStatus();\n\nconsole.log('\\n=== Least Connections Strategy ===');\nconst lcLB = new LoadBalancer(new LeastConnectionsStrategy());\nlcLB.addServer({ id: 'server1', url: 'http://server1', activeConnections: 3, healthy: true });\nlcLB.addServer({ id: 'server2', url: 'http://server2', activeConnections: 1, healthy: true });\nlcLB.addServer({ id: 'server3', url: 'http://server3', activeConnections: 5, healthy: true });\n\nfor (let i = 1; i <= 3; i++) {\n  console.log(lcLB.handleRequest(`req${i}`));\n}\nlcLB.getStatus();\n\nconsole.log('\\n=== Weighted Round Robin Strategy ===');\nconst wrrLB = new LoadBalancer(new WeightedRoundRobinStrategy());\nwrrLB.addServer({ id: 'server1', url: 'http://server1', activeConnections: 0, healthy: true, weight: 3 });\nwrrLB.addServer({ id: 'server2', url: 'http://server2', activeConnections: 0, healthy: true, weight: 1 });\n\nfor (let i = 1; i <= 8; i++) {\n  console.log(wrrLB.handleRequest(`req${i}`));\n}\nwrrLB.getStatus();",
    "hints": [
      "Round Robin cycles through servers sequentially",
      "Least Connections selects server with fewest active requests",
      "Weighted Round Robin favors servers with higher weights",
      "Always filter out unhealthy servers before selection"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex15",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Horizontal vs Vertical Scaling Simulator",
    "difficulty": 5,
    "description": "Create a simulator that demonstrates the differences between horizontal and vertical scaling. Model server capacity, request handling, and scaling decisions.\n\nImplement auto-scaling logic that decides when to scale horizontally (add servers) or vertically (increase server capacity).",
    "starterCode": "interface ServerInstance {\n  id: string;\n  cpu: number; // cores\n  memory: number; // GB\n  maxRequests: number;\n  currentRequests: number;\n  utilizationPercent: number;\n}\n\nclass VerticalScaling {\n  private server: ServerInstance;\n\n  constructor(initialCPU: number, initialMemory: number) {\n    // TODO: Initialize server\n  }\n\n  scaleUp(): void {\n    // TODO: Increase CPU and memory\n  }\n\n  canHandle(requests: number): boolean {\n    // TODO: Check if server can handle load\n    return false;\n  }\n}\n\nclass HorizontalScaling {\n  private servers: ServerInstance[] = [];\n\n  addServer(): void {\n    // TODO: Add new server instance\n  }\n\n  removeServer(): void {\n    // TODO: Remove least utilized server\n  }\n\n  distributeLoad(totalRequests: number): void {\n    // TODO: Distribute requests across servers\n  }\n}\n\nclass AutoScaler {\n  decide(currentLoad: number, capacity: number): 'scale-up' | 'scale-out' | 'none' {\n    // TODO: Decide scaling strategy\n    return 'none';\n  }\n}",
    "solution": "interface ServerInstance {\n  id: string;\n  cpu: number;\n  memory: number;\n  maxRequests: number;\n  currentRequests: number;\n  utilizationPercent: number;\n}\n\nclass VerticalScaling {\n  private server: ServerInstance;\n  private scaleCount = 0;\n\n  constructor(initialCPU: number, initialMemory: number) {\n    this.server = {\n      id: 'vertical-server',\n      cpu: initialCPU,\n      memory: initialMemory,\n      maxRequests: initialCPU * 100,\n      currentRequests: 0,\n      utilizationPercent: 0\n    };\n  }\n\n  scaleUp(): void {\n    this.scaleCount++;\n    this.server.cpu *= 2;\n    this.server.memory *= 2;\n    this.server.maxRequests = this.server.cpu * 100;\n    console.log(`[Vertical] Scaled UP to ${this.server.cpu} CPU, ${this.server.memory}GB RAM`);\n    console.log(`[Vertical] Max requests: ${this.server.maxRequests}`);\n  }\n\n  handleLoad(requests: number): void {\n    this.server.currentRequests = requests;\n    this.server.utilizationPercent = (requests / this.server.maxRequests) * 100;\n  }\n\n  canHandle(requests: number): boolean {\n    return requests <= this.server.maxRequests;\n  }\n\n  getStatus(): string {\n    return `Vertical: ${this.server.cpu} CPU, ${this.server.memory}GB, ${\n      this.server.currentRequests\n    }/${this.server.maxRequests} requests (${\n      this.server.utilizationPercent.toFixed(1)\n    }% utilized)`;\n  }\n\n  getCost(): number {\n    // Cost increases exponentially with vertical scaling\n    return Math.pow(this.server.cpu, 1.5) * 10;\n  }\n}\n\nclass HorizontalScaling {\n  private servers: ServerInstance[] = [];\n  private nextId = 1;\n  private serverCPU = 2;\n  private serverMemory = 8;\n\n  constructor() {\n    this.addServer(); // Start with one server\n  }\n\n  addServer(): void {\n    const server: ServerInstance = {\n      id: `horizontal-server-${this.nextId++}`,\n      cpu: this.serverCPU,\n      memory: this.serverMemory,\n      maxRequests: this.serverCPU * 100,\n      currentRequests: 0,\n      utilizationPercent: 0\n    };\n    this.servers.push(server);\n    console.log(`[Horizontal] Added ${server.id}`);\n  }\n\n  removeServer(): void {\n    if (this.servers.length <= 1) return;\n\n    const removed = this.servers.pop();\n    console.log(`[Horizontal] Removed ${removed?.id}`);\n  }\n\n  distributeLoad(totalRequests: number): void {\n    const requestsPerServer = Math.ceil(totalRequests / this.servers.length);\n\n    this.servers.forEach(server => {\n      server.currentRequests = Math.min(requestsPerServer, server.maxRequests);\n      server.utilizationPercent = (server.currentRequests / server.maxRequests) * 100;\n    });\n  }\n\n  canHandle(requests: number): boolean {\n    const totalCapacity = this.servers.reduce((sum, s) => sum + s.maxRequests, 0);\n    return requests <= totalCapacity;\n  }\n\n  getStatus(): string {\n    const total = this.servers.reduce((sum, s) => sum + s.currentRequests, 0);\n    const capacity = this.servers.reduce((sum, s) => sum + s.maxRequests, 0);\n    const avgUtil = (total / capacity) * 100;\n\n    return `Horizontal: ${this.servers.length} servers, ${total}/${capacity} requests (${\n      avgUtil.toFixed(1)\n    }% avg utilized)`;\n  }\n\n  getCost(): number {\n    // Cost increases linearly with horizontal scaling\n    return this.servers.length * this.serverCPU * 10;\n  }\n}\n\nclass AutoScaler {\n  decide(\n    currentLoad: number,\n    capacity: number,\n    costVertical: number,\n    costHorizontal: number\n  ): 'scale-up' | 'scale-out' | 'none' {\n    const utilization = (currentLoad / capacity) * 100;\n\n    if (utilization < 60) {\n      return 'none'; // Underutilized\n    }\n\n    if (utilization > 80) {\n      // Need to scale - decide which approach\n      if (costHorizontal < costVertical * 0.8) {\n        return 'scale-out'; // Horizontal is more cost-effective\n      } else {\n        return 'scale-up'; // Vertical is more cost-effective\n      }\n    }\n\n    return 'none';\n  }\n}\n\n// Simulation\nconsole.log('=== Scaling Comparison Simulation ===\\n');\n\nconst vertical = new VerticalScaling(2, 8);\nconst horizontal = new HorizontalScaling();\nconst autoScaler = new AutoScaler();\n\nconst loadLevels = [100, 200, 500, 1000, 2000];\n\nloadLevels.forEach(load => {\n  console.log(`\\n--- Load: ${load} requests ---`);\n\n  // Vertical scaling\n  while (!vertical.canHandle(load)) {\n    vertical.scaleUp();\n  }\n  vertical.handleLoad(load);\n  console.log(vertical.getStatus());\n  console.log(`Vertical cost: $${vertical.getCost().toFixed(2)}`);\n\n  // Horizontal scaling\n  while (!horizontal.canHandle(load)) {\n    horizontal.addServer();\n  }\n  horizontal.distributeLoad(load);\n  console.log(horizontal.getStatus());\n  console.log(`Horizontal cost: $${horizontal.getCost().toFixed(2)}`);\n});\n\nconsole.log(`\\n=== Summary ===`);\nconsole.log('Vertical Scaling:');\nconsole.log('  Pros: Simple, no distributed system complexity');\nconsole.log('  Cons: Hardware limits, downtime during scaling, exponential cost');\nconsole.log('\\nHorizontal Scaling:');\nconsole.log('  Pros: No hardware limits, high availability, linear cost');\nconsole.log('  Cons: Distributed system complexity, load balancing needed');",
    "hints": [
      "Vertical scaling increases single server capacity",
      "Horizontal scaling adds more server instances",
      "Vertical scaling has hardware limits and downtime",
      "Horizontal scaling provides redundancy and fault tolerance"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex16",
    "subjectId": "cs404",
    "topicId": "topic-2",
    "title": "Technology Stack Evaluation Matrix",
    "difficulty": 5,
    "description": "Create a comprehensive technology stack evaluation system that scores different tech stacks based on project requirements. Consider factors like performance, developer experience, ecosystem, scalability, and cost.\n\nBuild a decision matrix that recommends the best stack for different project types (startup MVP, enterprise app, high-traffic service).",
    "starterCode": "interface TechStack {\n  name: string;\n  frontend: string;\n  backend: string;\n  database: string;\n  deployment: string;\n}\n\ninterface ProjectRequirements {\n  projectType: 'mvp' | 'enterprise' | 'high-traffic';\n  teamExpertise: string[]; // Languages/frameworks team knows\n  budget: 'low' | 'medium' | 'high';\n  timeToMarket: 'fast' | 'medium' | 'slow';\n  scalabilityNeeds: 'low' | 'medium' | 'high';\n  performanceCritical: boolean;\n}\n\ninterface StackEvaluation {\n  stack: TechStack;\n  score: number;\n  strengths: string[];\n  weaknesses: string[];\n  estimatedCost: number;\n  learningCurve: 'low' | 'medium' | 'high';\n}\n\nclass StackEvaluator {\n  private stacks: TechStack[] = [];\n\n  addStack(stack: TechStack): void {\n    // TODO\n  }\n\n  evaluate(requirements: ProjectRequirements): StackEvaluation[] {\n    // TODO: Score each stack based on requirements\n    return [];\n  }\n\n  recommend(requirements: ProjectRequirements): StackEvaluation {\n    // TODO: Return best stack\n    return null as any;\n  }\n}",
    "solution": "interface TechStack {\n  name: string;\n  frontend: string;\n  backend: string;\n  database: string;\n  deployment: string;\n  maturity: number; // 1-10\n  communitySize: number; // 1-10\n  performance: number; // 1-10\n  scalability: number; // 1-10\n  devSpeed: number; // 1-10 (how fast to develop)\n  hostingCost: number; // 1-10 (10 = most expensive)\n  learningCurve: 'low' | 'medium' | 'high';\n}\n\ninterface ProjectRequirements {\n  projectType: 'mvp' | 'enterprise' | 'high-traffic';\n  teamExpertise: string[];\n  budget: 'low' | 'medium' | 'high';\n  timeToMarket: 'fast' | 'medium' | 'slow';\n  scalabilityNeeds: 'low' | 'medium' | 'high';\n  performanceCritical: boolean;\n}\n\ninterface StackEvaluation {\n  stack: TechStack;\n  score: number;\n  strengths: string[];\n  weaknesses: string[];\n  estimatedCost: number;\n  learningCurve: 'low' | 'medium' | 'high';\n}\n\nclass StackEvaluator {\n  private stacks: TechStack[] = [];\n\n  constructor() {\n    // Define common tech stacks\n    this.addStack({\n      name: 'MERN (MongoDB, Express, React, Node.js)',\n      frontend: 'React',\n      backend: 'Node.js/Express',\n      database: 'MongoDB',\n      deployment: 'Vercel/Heroku',\n      maturity: 8,\n      communitySize: 10,\n      performance: 7,\n      scalability: 7,\n      devSpeed: 9,\n      hostingCost: 4,\n      learningCurve: 'medium'\n    });\n\n    this.addStack({\n      name: 'Django/PostgreSQL',\n      frontend: 'React/Vue',\n      backend: 'Django/Python',\n      database: 'PostgreSQL',\n      deployment: 'AWS/GCP',\n      maturity: 10,\n      communitySize: 9,\n      performance: 8,\n      scalability: 8,\n      devSpeed: 8,\n      hostingCost: 6,\n      learningCurve: 'medium'\n    });\n\n    this.addStack({\n      name: 'Spring Boot/Java Enterprise',\n      frontend: 'Angular',\n      backend: 'Spring Boot/Java',\n      database: 'Oracle/PostgreSQL',\n      deployment: 'Enterprise servers',\n      maturity: 10,\n      communitySize: 8,\n      performance: 9,\n      scalability: 10,\n      devSpeed: 6,\n      hostingCost: 8,\n      learningCurve: 'high'\n    });\n\n    this.addStack({\n      name: 'Jamstack (Next.js, Serverless)',\n      frontend: 'Next.js/React',\n      backend: 'Serverless Functions',\n      database: 'Firebase/Supabase',\n      deployment: 'Vercel/Netlify',\n      maturity: 7,\n      communitySize: 9,\n      performance: 9,\n      scalability: 9,\n      devSpeed: 10,\n      hostingCost: 3,\n      learningCurve: 'low'\n    });\n\n    this.addStack({\n      name: 'Go Microservices',\n      frontend: 'React/Vue',\n      backend: 'Go',\n      database: 'PostgreSQL/Redis',\n      deployment: 'Kubernetes',\n      maturity: 8,\n      communitySize: 7,\n      performance: 10,\n      scalability: 10,\n      devSpeed: 7,\n      hostingCost: 7,\n      learningCurve: 'high'\n    });\n  }\n\n  addStack(stack: TechStack): void {\n    this.stacks.push(stack);\n  }\n\n  evaluate(requirements: ProjectRequirements): StackEvaluation[] {\n    return this.stacks.map(stack => {\n      let score = 0;\n      const strengths: string[] = [];\n      const weaknesses: string[] = [];\n\n      // Project type scoring\n      if (requirements.projectType === 'mvp') {\n        score += stack.devSpeed * 3; // Fast development is critical\n        score += stack.hostingCost * -1; // Low cost is important\n        if (stack.devSpeed >= 8) strengths.push('Fast development for MVP');\n        if (stack.learningCurve === 'high') weaknesses.push('Steep learning curve slows MVP');\n      } else if (requirements.projectType === 'enterprise') {\n        score += stack.maturity * 2;\n        score += stack.scalability * 2;\n        if (stack.maturity >= 9) strengths.push('Battle-tested for enterprise');\n        if (stack.communitySize < 7) weaknesses.push('Smaller community support');\n      } else if (requirements.projectType === 'high-traffic') {\n        score += stack.performance * 3;\n        score += stack.scalability * 3;\n        if (stack.performance >= 9) strengths.push('Excellent performance characteristics');\n        if (stack.scalability < 8) weaknesses.push('May struggle at high scale');\n      }\n\n      // Team expertise bonus\n      const stackTechs = [stack.frontend, stack.backend, stack.database].join(' ').toLowerCase();\n      const expertiseMatch = requirements.teamExpertise.some(skill =>\n        stackTechs.includes(skill.toLowerCase())\n      );\n      if (expertiseMatch) {\n        score += 10;\n        strengths.push('Team has relevant expertise');\n      } else {\n        weaknesses.push('Team needs to learn new technologies');\n      }\n\n      // Budget constraints\n      const budgetScores = { low: 3, medium: 6, high: 10 };\n      if (stack.hostingCost <= budgetScores[requirements.budget]) {\n        score += 5;\n        strengths.push('Fits within budget constraints');\n      } else {\n        score -= 5;\n        weaknesses.push('Higher hosting costs than budget allows');\n      }\n\n      // Time to market\n      if (requirements.timeToMarket === 'fast' && stack.devSpeed >= 8) {\n        score += 8;\n        strengths.push('Enables rapid development');\n      }\n\n      // Scalability needs\n      const scalabilityScores = { low: 5, medium: 7, high: 9 };\n      if (stack.scalability >= scalabilityScores[requirements.scalabilityNeeds]) {\n        score += 5;\n        strengths.push('Meets scalability requirements');\n      } else {\n        weaknesses.push('May not scale to requirements');\n      }\n\n      // Performance critical\n      if (requirements.performanceCritical && stack.performance >= 8) {\n        score += 10;\n        strengths.push('High-performance capabilities');\n      } else if (requirements.performanceCritical && stack.performance < 7) {\n        score -= 5;\n        weaknesses.push('Performance may not meet requirements');\n      }\n\n      const estimatedCost = stack.hostingCost * 100; // Monthly cost estimate\n\n      return {\n        stack,\n        score,\n        strengths,\n        weaknesses,\n        estimatedCost,\n        learningCurve: stack.learningCurve\n      };\n    }).sort((a, b) => b.score - a.score);\n  }\n\n  recommend(requirements: ProjectRequirements): StackEvaluation {\n    const evaluations = this.evaluate(requirements);\n    return evaluations[0];\n  }\n\n  printEvaluation(evaluation: StackEvaluation): void {\n    console.log(`\\n=== ${evaluation.stack.name} ===`);\n    console.log(`Score: ${evaluation.score}`);\n    console.log(`Frontend: ${evaluation.stack.frontend}`);\n    console.log(`Backend: ${evaluation.stack.backend}`);\n    console.log(`Database: ${evaluation.stack.database}`);\n    console.log(`Estimated Monthly Cost: $${evaluation.estimatedCost}`);\n    console.log(`Learning Curve: ${evaluation.learningCurve}`);\n    console.log(`\\nStrengths:`);\n    evaluation.strengths.forEach(s => console.log(`  + ${s}`));\n    console.log(`\\nWeaknesses:`);\n    evaluation.weaknesses.forEach(w => console.log(`  - ${w}`));\n  }\n}\n\n// Usage examples\nconst evaluator = new StackEvaluator();\n\nconsole.log('=== Startup MVP Scenario ===');\nconst mvpRequirements: ProjectRequirements = {\n  projectType: 'mvp',\n  teamExpertise: ['JavaScript', 'React'],\n  budget: 'low',\n  timeToMarket: 'fast',\n  scalabilityNeeds: 'low',\n  performanceCritical: false\n};\n\nconst mvpRecommendation = evaluator.recommend(mvpRequirements);\nevaluator.printEvaluation(mvpRecommendation);\n\nconsole.log('\\n\\n=== Enterprise Application Scenario ===');\nconst enterpriseRequirements: ProjectRequirements = {\n  projectType: 'enterprise',\n  teamExpertise: ['Java', 'Spring'],\n  budget: 'high',\n  timeToMarket: 'medium',\n  scalabilityNeeds: 'high',\n  performanceCritical: true\n};\n\nconst enterpriseRecommendation = evaluator.recommend(enterpriseRequirements);\nevaluator.printEvaluation(enterpriseRecommendation);\n\nconsole.log('\\n\\n=== High-Traffic Service Scenario ===');\nconst highTrafficRequirements: ProjectRequirements = {\n  projectType: 'high-traffic',\n  teamExpertise: ['Go', 'Kubernetes'],\n  budget: 'medium',\n  timeToMarket: 'medium',\n  scalabilityNeeds: 'high',\n  performanceCritical: true\n};\n\nconst highTrafficRecommendation = evaluator.recommend(highTrafficRequirements);\nevaluator.printEvaluation(highTrafficRecommendation);",
    "hints": [
      "Score stacks differently based on project type",
      "Give bonus points for team expertise matches",
      "Consider both technical and business requirements",
      "Balance immediate needs with long-term scalability"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-3-1",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Input Validation with Zod",
    "difficulty": 1,
    "description": "Create Zod schemas for API input validation. Build validation schemas for user registration and activity creation.",
    "starterCode": "import { z } from 'zod';\n\n// TODO: Create registration schema\nconst registerSchema = z.object({\n  // email: valid email\n  // password: min 12 chars, contains uppercase, lowercase, number, special char\n  // name: 1-100 characters\n});\n\n// TODO: Create activity schema\nconst createActivitySchema = z.object({\n  // category: one of 'transportation', 'energy', 'food', 'waste', 'purchases'\n  // quantity: positive number\n  // date: YYYY-MM-DD format\n});\n\nexport { registerSchema, createActivitySchema };",
    "solution": "import { z } from 'zod';\n\nconst registerSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string()\n    .min(12, 'Password must be at least 12 characters')\n    .regex(/[A-Z]/, 'Must contain uppercase letter')\n    .regex(/[a-z]/, 'Must contain lowercase letter')\n    .regex(/[0-9]/, 'Must contain number')\n    .regex(/[@$!%*?&]/, 'Must contain special character'),\n  name: z.string().min(1).max(100)\n});\n\nconst createActivitySchema = z.object({\n  category: z.enum(['transportation', 'energy', 'food', 'waste', 'purchases']),\n  activity_type: z.string().min(1).max(100),\n  quantity: z.number().positive(),\n  unit: z.string().min(1).max(20),\n  activity_date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Must be YYYY-MM-DD format'),\n  notes: z.string().max(500).optional()\n});\n\n// Usage example\ntry {\n  const validUser = registerSchema.parse({\n    email: 'user@example.com',\n    password: 'SecureP@ssw0rd123',\n    name: 'John Doe'\n  });\n  console.log('Valid user:', validUser);\n} catch (error) {\n  console.error('Validation error:', error);\n}\n\ntry {\n  const validActivity = createActivitySchema.parse({\n    category: 'transportation',\n    activity_type: 'car',\n    quantity: 25.5,\n    unit: 'miles',\n    activity_date: '2024-01-15'\n  });\n  console.log('Valid activity:', validActivity);\n} catch (error) {\n  console.error('Validation error:', error);\n}\n\nexport { registerSchema, createActivitySchema };",
    "hints": [
      "Use z.string().email() for email validation",
      "Use regex for password complexity",
      "Use z.enum() for limited value sets",
      "Use .optional() for optional fields"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-3-2",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "API Error Handler Middleware",
    "difficulty": 3,
    "description": "Create Express middleware for consistent error handling. Build error handler middleware that catches and formats all errors consistently.",
    "starterCode": "import { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\n\nclass AppError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public code?: string\n  ) {\n    super(message);\n  }\n}\n\nfunction errorHandler(\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // TODO: Handle different error types\n  // - ZodError (validation errors)\n  // - AppError (custom application errors)\n  // - Default errors\n}\n\nexport { AppError, errorHandler };",
    "solution": "import { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\n\nclass AppError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public code?: string\n  ) {\n    super(message);\n  }\n}\n\nfunction errorHandler(\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // Log error\n  console.error('Error:', error);\n\n  // Zod validation errors\n  if (error instanceof ZodError) {\n    return res.status(422).json({\n      error: {\n        code: 'VALIDATION_ERROR',\n        message: 'Invalid input data',\n        details: error.errors.map(err => ({\n          field: err.path.join('.'),\n          message: err.message\n        }))\n      }\n    });\n  }\n\n  // Application errors\n  if (error instanceof AppError) {\n    return res.status(error.statusCode).json({\n      error: {\n        code: error.code,\n        message: error.message\n      }\n    });\n  }\n\n  // Default error (hide internals in production)\n  const message = process.env.NODE_ENV === 'production'\n    ? 'Internal server error'\n    : error.message;\n\n  res.status(500).json({\n    error: {\n      code: 'INTERNAL_ERROR',\n      message\n    }\n  });\n}\n\n// Usage example\napp.post('/api/users', async (req, res, next) => {\n  try {\n    const validated = userSchema.parse(req.body);\n    const user = await userService.create(validated);\n    res.status(201).json({ data: user });\n  } catch (error) {\n    next(error);\n  }\n});\n\napp.get('/api/users/:id', async (req, res, next) => {\n  try {\n    const user = await userService.findById(req.params.id);\n    if (!user) {\n      throw new AppError(404, 'User not found', 'USER_NOT_FOUND');\n    }\n    res.json({ data: user });\n  } catch (error) {\n    next(error);\n  }\n});\n\napp.use(errorHandler);\n\nexport { AppError, errorHandler };",
    "hints": [
      "Check error type with instanceof",
      "Return different status codes for different errors",
      "Format errors consistently",
      "Don't expose internal errors in production"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex03",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Environment Configuration Manager",
    "difficulty": 1,
    "description": "Create a configuration manager that loads and validates environment variables using dotenv. Implement type-safe access to configuration values with validation and default values.",
    "starterCode": "import dotenv from 'dotenv';\n\ninterface Config {\n  nodeEnv: 'development' | 'production' | 'test';\n  port: number;\n  databaseUrl: string;\n  jwtSecret: string;\n  corsOrigin: string;\n}\n\n// TODO: Load environment variables\n// TODO: Validate required variables\n// TODO: Export typed config object\n\nexport function getConfig(): Config {\n  // Implement configuration loading\n}",
    "solution": "import dotenv from 'dotenv';\n\ninterface Config {\n  nodeEnv: 'development' | 'production' | 'test';\n  port: number;\n  databaseUrl: string;\n  jwtSecret: string;\n  corsOrigin: string;\n}\n\n// Load environment variables\ndotenv.config();\n\nfunction getEnvVariable(key: string, defaultValue?: string): string {\n  const value = process.env[key] || defaultValue;\n  if (!value) {\n    throw new Error(`Missing required environment variable: ${key}`);\n  }\n  return value;\n}\n\nexport function getConfig(): Config {\n  return {\n    nodeEnv: (process.env.NODE_ENV || 'development') as Config['nodeEnv'],\n    port: parseInt(process.env.PORT || '3000', 10),\n    databaseUrl: getEnvVariable('DATABASE_URL'),\n    jwtSecret: getEnvVariable('JWT_SECRET'),\n    corsOrigin: getEnvVariable('CORS_ORIGIN', 'http://localhost:5173')\n  };\n}\n\n// Usage example\nconst config = getConfig();\nconsole.log(`Server running in ${config.nodeEnv} mode on port ${config.port}`);\n\nexport { config };",
    "hints": [
      "Use dotenv.config() to load .env file",
      "Check if required variables exist using process.env",
      "Throw descriptive errors for missing required variables",
      "Use parseInt() for numeric values with fallback defaults"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex04",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Git Branch Name Validator",
    "difficulty": 1,
    "description": "Create a function that validates Git branch names according to best practices. Check for proper naming conventions like feature/*, bugfix/*, hotfix/*, etc.",
    "starterCode": "interface BranchValidation {\n  valid: boolean;\n  type?: 'feature' | 'bugfix' | 'hotfix' | 'release' | 'chore';\n  message?: string;\n}\n\n// TODO: Validate branch name format\n// Valid patterns:\n// - feature/description-of-feature\n// - bugfix/issue-123-description\n// - hotfix/critical-bug\n// - release/v1.2.3\n// - chore/update-dependencies\n\nfunction validateBranchName(branchName: string): BranchValidation {\n  // Implement validation\n}\n\nexport { validateBranchName };",
    "solution": "interface BranchValidation {\n  valid: boolean;\n  type?: 'feature' | 'bugfix' | 'hotfix' | 'release' | 'chore';\n  message?: string;\n}\n\nfunction validateBranchName(branchName: string): BranchValidation {\n  // Regex pattern for valid branch names\n  const patterns = [\n    { regex: /^feature\\/[a-z0-9-]+$/, type: 'feature' as const },\n    { regex: /^bugfix\\/(issue-\\d+-)?[a-z0-9-]+$/, type: 'bugfix' as const },\n    { regex: /^hotfix\\/[a-z0-9-]+$/, type: 'hotfix' as const },\n    { regex: /^release\\/v?\\d+\\.\\d+\\.\\d+$/, type: 'release' as const },\n    { regex: /^chore\\/[a-z0-9-]+$/, type: 'chore' as const }\n  ];\n\n  // Check if branch name is empty\n  if (!branchName.trim()) {\n    return {\n      valid: false,\n      message: 'Branch name cannot be empty'\n    };\n  }\n\n  // Check against valid patterns\n  for (const { regex, type } of patterns) {\n    if (regex.test(branchName)) {\n      return {\n        valid: true,\n        type,\n        message: `Valid ${type} branch`\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    message: 'Branch name must follow pattern: type/description (e.g., feature/add-login)'\n  };\n}\n\n// Usage examples\nconsole.log(validateBranchName('feature/user-authentication'));\n// { valid: true, type: 'feature', message: 'Valid feature branch' }\n\nconsole.log(validateBranchName('bugfix/issue-123-fix-login'));\n// { valid: true, type: 'bugfix', message: 'Valid bugfix branch' }\n\nconsole.log(validateBranchName('invalid-branch'));\n// { valid: false, message: 'Branch name must follow pattern...' }\n\nexport { validateBranchName };",
    "hints": [
      "Use regex patterns to match each branch type",
      "Check for empty or invalid branch names first",
      "Use lowercase and hyphens in branch descriptions",
      "Return descriptive error messages for invalid formats"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex05",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Conventional Commit Message Formatter",
    "difficulty": 2,
    "description": "Build a commit message formatter that follows Conventional Commits specification. Parse and format commit messages with type, scope, description, and optional body/footer.",
    "starterCode": "interface CommitMessage {\n  type: 'feat' | 'fix' | 'docs' | 'style' | 'refactor' | 'test' | 'chore';\n  scope?: string;\n  description: string;\n  body?: string;\n  breaking?: boolean;\n}\n\n// TODO: Format commit message according to Conventional Commits\n// Format: type(scope): description\n// Example: feat(auth): add login endpoint\n\nfunction formatCommitMessage(commit: CommitMessage): string {\n  // Implement formatter\n}\n\n// TODO: Parse conventional commit message\nfunction parseCommitMessage(message: string): CommitMessage | null {\n  // Implement parser\n}\n\nexport { formatCommitMessage, parseCommitMessage };",
    "solution": "interface CommitMessage {\n  type: 'feat' | 'fix' | 'docs' | 'style' | 'refactor' | 'test' | 'chore';\n  scope?: string;\n  description: string;\n  body?: string;\n  breaking?: boolean;\n}\n\nfunction formatCommitMessage(commit: CommitMessage): string {\n  let message = commit.type;\n\n  if (commit.scope) {\n    message += `(${commit.scope})`;\n  }\n\n  if (commit.breaking) {\n    message += '!';\n  }\n\n  message += `: ${commit.description}`;\n\n  if (commit.body) {\n    message += `\\n\\n${commit.body}`;\n  }\n\n  if (commit.breaking) {\n    message += '\\n\\nBREAKING CHANGE: This introduces a breaking change';\n  }\n\n  return message;\n}\n\nfunction parseCommitMessage(message: string): CommitMessage | null {\n  // Regex for conventional commit format\n  const regex = /^(feat|fix|docs|style|refactor|test|chore)(?:\\(([^)]+)\\))?(!)?:\\s*(.+)$/;\n  const match = message.match(regex);\n\n  if (!match) {\n    return null;\n  }\n\n  const [, type, scope, breaking, description] = match;\n\n  return {\n    type: type as CommitMessage['type'],\n    scope: scope || undefined,\n    description: description.trim(),\n    breaking: breaking === '!'\n  };\n}\n\n// Usage examples\nconst commit: CommitMessage = {\n  type: 'feat',\n  scope: 'api',\n  description: 'add user registration endpoint',\n  body: 'Implements POST /api/auth/register with email validation'\n};\n\nconsole.log(formatCommitMessage(commit));\n// Output: feat(api): add user registration endpoint\n//\n// Implements POST /api/auth/register with email validation\n\nconst parsed = parseCommitMessage('fix(auth): resolve token expiration bug');\nconsole.log(parsed);\n// { type: 'fix', scope: 'auth', description: 'resolve token expiration bug' }\n\nexport { formatCommitMessage, parseCommitMessage };",
    "hints": [
      "Build the message string step by step: type, scope, breaking indicator, description",
      "Use regex with capture groups to parse commit message components",
      "Handle optional scope and breaking change indicator",
      "Validate the commit type against allowed values"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex06",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Express Route Handler with Async Error Handling",
    "difficulty": 2,
    "description": "Create a utility function that wraps Express route handlers to automatically catch async errors. This eliminates the need for try-catch blocks in every route handler.",
    "starterCode": "import { Request, Response, NextFunction } from 'express';\n\ntype AsyncHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<any>;\n\n// TODO: Create wrapper that catches async errors\nfunction asyncHandler(handler: AsyncHandler) {\n  // Implement wrapper\n}\n\n// Example route handler to wrap\nasync function getUserById(req: Request, res: Response) {\n  const user = await database.users.findUnique({\n    where: { id: req.params.id }\n  });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  res.json({ data: user });\n}\n\nexport { asyncHandler };",
    "solution": "import { Request, Response, NextFunction } from 'express';\n\ntype AsyncHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<any>;\n\nfunction asyncHandler(handler: AsyncHandler) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(handler(req, res, next))\n      .catch(next);\n  };\n}\n\n// Example route handler to wrap\nasync function getUserById(req: Request, res: Response) {\n  const user = await database.users.findUnique({\n    where: { id: req.params.id }\n  });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  res.json({ data: user });\n}\n\n// Usage example\nimport express from 'express';\nconst app = express();\n\n// Without asyncHandler (verbose)\napp.get('/api/users/:id', async (req, res, next) => {\n  try {\n    await getUserById(req, res);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// With asyncHandler (clean)\napp.get('/api/users/:id', asyncHandler(async (req, res) => {\n  const user = await database.users.findUnique({\n    where: { id: req.params.id }\n  });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  res.json({ data: user });\n}));\n\nexport { asyncHandler };",
    "hints": [
      "Return a new function that matches Express handler signature",
      "Wrap the handler call in Promise.resolve() to handle both sync and async",
      "Use .catch() to pass errors to the next() function",
      "The wrapper should preserve the original handler parameters"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex07",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Request Logging Middleware Chain",
    "difficulty": 3,
    "description": "Implement a middleware chain for request logging that tracks request ID, duration, and user information. Build composable middleware functions that work together.",
    "starterCode": "import { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\ninterface RequestLog {\n  requestId: string;\n  method: string;\n  path: string;\n  userId?: string;\n  startTime: number;\n  duration?: number;\n}\n\n// TODO: Add unique request ID to each request\nfunction requestIdMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Implement request ID generation\n}\n\n// TODO: Log request details with timing\nfunction requestLoggerMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Implement request logging with duration\n}\n\n// TODO: Extract user ID from auth header\nfunction userContextMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Implement user context extraction\n}\n\nexport { requestIdMiddleware, requestLoggerMiddleware, userContextMiddleware };",
    "solution": "import { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\ninterface RequestLog {\n  requestId: string;\n  method: string;\n  path: string;\n  userId?: string;\n  startTime: number;\n  duration?: number;\n}\n\n// Extend Express Request type\ndeclare global {\n  namespace Express {\n    interface Request {\n      requestId?: string;\n      userId?: string;\n      startTime?: number;\n    }\n  }\n}\n\nfunction requestIdMiddleware(req: Request, res: Response, next: NextFunction) {\n  req.requestId = randomUUID();\n  res.setHeader('X-Request-ID', req.requestId);\n  next();\n}\n\nfunction requestLoggerMiddleware(req: Request, res: Response, next: NextFunction) {\n  req.startTime = Date.now();\n\n  // Log on response finish\n  res.on('finish', () => {\n    const duration = Date.now() - (req.startTime || Date.now());\n    const log: RequestLog = {\n      requestId: req.requestId || 'unknown',\n      method: req.method,\n      path: req.path,\n      userId: req.userId,\n      startTime: req.startTime || Date.now(),\n      duration\n    };\n\n    console.log(`[${log.requestId}] ${log.method} ${log.path} - ${duration}ms - User: ${log.userId || 'anonymous'}`);\n  });\n\n  next();\n}\n\nfunction userContextMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Extract user ID from Authorization header or JWT\n  const authHeader = req.headers.authorization;\n\n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    // In real app, decode JWT here\n    // For demo, extract mock user ID\n    try {\n      // Mock: extract user ID from token\n      req.userId = 'user-123'; // In reality: jwt.verify(token).userId\n    } catch (error) {\n      // Invalid token, continue as anonymous\n      req.userId = undefined;\n    }\n  }\n\n  next();\n}\n\n// Usage example\nimport express from 'express';\nconst app = express();\n\n// Apply middleware chain\napp.use(requestIdMiddleware);\napp.use(userContextMiddleware);\napp.use(requestLoggerMiddleware);\n\n// Example route\napp.get('/api/data', (req, res) => {\n  res.json({\n    message: 'Success',\n    requestId: req.requestId,\n    userId: req.userId\n  });\n});\n\nexport { requestIdMiddleware, requestLoggerMiddleware, userContextMiddleware };",
    "hints": [
      "Use res.on(\"finish\") to log after response is sent",
      "Store request metadata on the req object",
      "Generate UUID for each request using randomUUID()",
      "Calculate duration by comparing timestamps"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex08",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "React Form with Controlled Inputs",
    "difficulty": 3,
    "description": "Build a React registration form component with controlled inputs, real-time validation, and error display. Implement proper state management and validation feedback.",
    "starterCode": "import React, { useState } from 'react';\n\ninterface FormData {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ninterface FormErrors {\n  email?: string;\n  password?: string;\n  confirmPassword?: string;\n}\n\n// TODO: Create registration form component\n// - Controlled inputs for email, password, confirm password\n// - Real-time validation\n// - Display errors under each field\n// - Disable submit button if form is invalid\n\nexport function RegistrationForm() {\n  // Implement form component\n}",
    "solution": "import React, { useState, useEffect } from 'react';\n\ninterface FormData {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ninterface FormErrors {\n  email?: string;\n  password?: string;\n  confirmPassword?: string;\n}\n\nexport function RegistrationForm() {\n  const [formData, setFormData] = useState<FormData>({\n    email: '',\n    password: '',\n    confirmPassword: ''\n  });\n\n  const [errors, setErrors] = useState<FormErrors>({});\n  const [touched, setTouched] = useState<Record<string, boolean>>({});\n\n  // Validate email\n  const validateEmail = (email: string): string | undefined => {\n    if (!email) return 'Email is required';\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n      return 'Invalid email format';\n    }\n    return undefined;\n  };\n\n  // Validate password\n  const validatePassword = (password: string): string | undefined => {\n    if (!password) return 'Password is required';\n    if (password.length < 8) return 'Password must be at least 8 characters';\n    if (!/[A-Z]/.test(password)) return 'Must contain uppercase letter';\n    if (!/[a-z]/.test(password)) return 'Must contain lowercase letter';\n    if (!/[0-9]/.test(password)) return 'Must contain number';\n    return undefined;\n  };\n\n  // Validate confirm password\n  const validateConfirmPassword = (confirmPassword: string, password: string): string | undefined => {\n    if (!confirmPassword) return 'Please confirm password';\n    if (confirmPassword !== password) return 'Passwords do not match';\n    return undefined;\n  };\n\n  // Validate form on change\n  useEffect(() => {\n    const newErrors: FormErrors = {};\n\n    if (touched.email) {\n      newErrors.email = validateEmail(formData.email);\n    }\n    if (touched.password) {\n      newErrors.password = validatePassword(formData.password);\n    }\n    if (touched.confirmPassword) {\n      newErrors.confirmPassword = validateConfirmPassword(\n        formData.confirmPassword,\n        formData.password\n      );\n    }\n\n    setErrors(newErrors);\n  }, [formData, touched]);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n  };\n\n  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    setTouched(prev => ({ ...prev, [e.target.name]: true }));\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n\n    // Validate all fields\n    const allErrors: FormErrors = {\n      email: validateEmail(formData.email),\n      password: validatePassword(formData.password),\n      confirmPassword: validateConfirmPassword(\n        formData.confirmPassword,\n        formData.password\n      )\n    };\n\n    if (Object.values(allErrors).some(error => error)) {\n      setErrors(allErrors);\n      setTouched({ email: true, password: true, confirmPassword: true });\n      return;\n    }\n\n    // Submit form\n    console.log('Form submitted:', formData);\n  };\n\n  const isFormValid = !Object.values(errors).some(error => error) &&\n    formData.email && formData.password && formData.confirmPassword;\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.email && errors.email && (\n          <span className=\"error\">{errors.email}</span>\n        )}\n      </div>\n\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input\n          type=\"password\"\n          id=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.password && errors.password && (\n          <span className=\"error\">{errors.password}</span>\n        )}\n      </div>\n\n      <div>\n        <label htmlFor=\"confirmPassword\">Confirm Password</label>\n        <input\n          type=\"password\"\n          id=\"confirmPassword\"\n          name=\"confirmPassword\"\n          value={formData.confirmPassword}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.confirmPassword && errors.confirmPassword && (\n          <span className=\"error\">{errors.confirmPassword}</span>\n        )}\n      </div>\n\n      <button type=\"submit\" disabled={!isFormValid}>\n        Register\n      </button>\n    </form>\n  );\n}",
    "hints": [
      "Use useState for form data and errors separately",
      "Track which fields have been touched for validation timing",
      "Validate on blur and on change after first touch",
      "Use useEffect to run validation when form data changes"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex09",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Custom React Hook for Data Fetching",
    "difficulty": 3,
    "description": "Create a reusable React hook for data fetching with loading states, error handling, and automatic retries. Implement proper cleanup to prevent memory leaks.",
    "starterCode": "import { useState, useEffect } from 'react';\n\ninterface FetchState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n}\n\n// TODO: Create useFetch hook\n// - Accepts URL and options\n// - Handles loading, error, and data states\n// - Implements retry logic\n// - Cleans up on unmount\n\nexport function useFetch<T>(url: string, options?: RequestInit) {\n  // Implement hook\n}",
    "solution": "import { useState, useEffect, useRef } from 'react';\n\ninterface FetchState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface FetchOptions extends RequestInit {\n  retries?: number;\n  retryDelay?: number;\n}\n\nexport function useFetch<T>(\n  url: string,\n  options: FetchOptions = {}\n): FetchState<T> & { refetch: () => void } {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [refetchTrigger, setRefetchTrigger] = useState(0);\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const { retries = 3, retryDelay = 1000, ...fetchOptions } = options;\n\n  useEffect(() => {\n    let isMounted = true;\n\n    const fetchData = async () => {\n      // Create new AbortController for this request\n      abortControllerRef.current = new AbortController();\n\n      setLoading(true);\n      setError(null);\n\n      let lastError: Error | null = null;\n\n      // Retry logic\n      for (let attempt = 0; attempt <= retries; attempt++) {\n        try {\n          const response = await fetch(url, {\n            ...fetchOptions,\n            signal: abortControllerRef.current.signal\n          });\n\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n\n          const result = await response.json();\n\n          if (isMounted) {\n            setData(result);\n            setError(null);\n            setLoading(false);\n          }\n\n          return; // Success, exit retry loop\n\n        } catch (err) {\n          lastError = err instanceof Error ? err : new Error('Unknown error');\n\n          // Don't retry if aborted\n          if (lastError.name === 'AbortError') {\n            break;\n          }\n\n          // Wait before retry (except on last attempt)\n          if (attempt < retries) {\n            await new Promise(resolve => setTimeout(resolve, retryDelay));\n          }\n        }\n      }\n\n      // All retries failed\n      if (isMounted && lastError) {\n        setError(lastError);\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      abortControllerRef.current?.abort();\n    };\n  }, [url, refetchTrigger, retries, retryDelay]);\n\n  const refetch = () => {\n    setRefetchTrigger(prev => prev + 1);\n  };\n\n  return { data, loading, error, refetch };\n}\n\n// Usage example\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, loading, error, refetch } = useFetch<User>(\n    `/api/users/${userId}`,\n    { retries: 3, retryDelay: 1000 }\n  );\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message} <button onClick={refetch}>Retry</button></div>;\n  if (!data) return <div>No data</div>;\n\n  return <div>Welcome, {data.name}!</div>;\n}",
    "hints": [
      "Use AbortController to cancel requests on unmount",
      "Track isMounted with a flag to prevent state updates after unmount",
      "Implement retry loop with delay using setTimeout",
      "Provide a refetch function using state trigger"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex10",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "API Client with Interceptors",
    "difficulty": 4,
    "description": "Build a type-safe API client with request/response interceptors for authentication, error handling, and request transformation. Implement automatic token refresh and retry logic.",
    "starterCode": "interface RequestInterceptor {\n  onRequest?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface ResponseInterceptor {\n  onResponse?: (response: Response) => Response | Promise<Response>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface RequestConfig extends RequestInit {\n  url: string;\n  params?: Record<string, string>;\n}\n\n// TODO: Create API client class\n// - Add request/response interceptors\n// - Handle authentication tokens\n// - Implement automatic token refresh\n// - Type-safe methods (get, post, put, delete)\n\nclass ApiClient {\n  // Implement API client\n}\n\nexport { ApiClient };",
    "solution": "interface RequestInterceptor {\n  onRequest?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface ResponseInterceptor {\n  onResponse?: (response: Response) => Response | Promise<Response>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface RequestConfig extends RequestInit {\n  url: string;\n  params?: Record<string, string>;\n  skipAuth?: boolean;\n}\n\nclass ApiClient {\n  private baseURL: string;\n  private requestInterceptors: RequestInterceptor[] = [];\n  private responseInterceptors: ResponseInterceptor[] = [];\n  private accessToken: string | null = null;\n  private refreshToken: string | null = null;\n\n  constructor(baseURL: string) {\n    this.baseURL = baseURL;\n\n    // Add default auth interceptor\n    this.addRequestInterceptor({\n      onRequest: async (config) => {\n        if (!config.skipAuth && this.accessToken) {\n          config.headers = {\n            ...config.headers,\n            'Authorization': `Bearer ${this.accessToken}`\n          };\n        }\n        return config;\n      }\n    });\n\n    // Add default response interceptor for token refresh\n    this.addResponseInterceptor({\n      onError: async (error: any) => {\n        const originalRequest = error.config;\n\n        // If 401 and we have refresh token, try to refresh\n        if (error.response?.status === 401 && this.refreshToken && !originalRequest._retry) {\n          originalRequest._retry = true;\n\n          try {\n            const response = await this.post<{ accessToken: string }>('/auth/refresh', {\n              refreshToken: this.refreshToken\n            }, { skipAuth: true });\n\n            this.setAccessToken(response.accessToken);\n\n            // Retry original request\n            return this.request(originalRequest);\n          } catch (refreshError) {\n            // Refresh failed, clear tokens\n            this.clearTokens();\n            throw refreshError;\n          }\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  addRequestInterceptor(interceptor: RequestInterceptor) {\n    this.requestInterceptors.push(interceptor);\n  }\n\n  addResponseInterceptor(interceptor: ResponseInterceptor) {\n    this.responseInterceptors.push(interceptor);\n  }\n\n  setAccessToken(token: string) {\n    this.accessToken = token;\n  }\n\n  setRefreshToken(token: string) {\n    this.refreshToken = token;\n  }\n\n  clearTokens() {\n    this.accessToken = null;\n    this.refreshToken = null;\n  }\n\n  private buildURL(url: string, params?: Record<string, string>): string {\n    const fullURL = url.startsWith('http') ? url : `${this.baseURL}${url}`;\n\n    if (params) {\n      const searchParams = new URLSearchParams(params);\n      return `${fullURL}?${searchParams}`;\n    }\n\n    return fullURL;\n  }\n\n  async request<T>(config: RequestConfig): Promise<T> {\n    // Apply request interceptors\n    let finalConfig = config;\n    for (const interceptor of this.requestInterceptors) {\n      if (interceptor.onRequest) {\n        try {\n          finalConfig = await interceptor.onRequest(finalConfig);\n        } catch (error) {\n          if (interceptor.onError) {\n            throw await interceptor.onError(error as Error);\n          }\n          throw error;\n        }\n      }\n    }\n\n    // Build URL with params\n    const url = this.buildURL(finalConfig.url, finalConfig.params);\n\n    try {\n      // Make request\n      let response = await fetch(url, {\n        ...finalConfig,\n        headers: {\n          'Content-Type': 'application/json',\n          ...finalConfig.headers\n        }\n      });\n\n      // Apply response interceptors\n      for (const interceptor of this.responseInterceptors) {\n        if (interceptor.onResponse) {\n          response = await interceptor.onResponse(response);\n        }\n      }\n\n      if (!response.ok) {\n        const error: any = new Error(`HTTP error! status: ${response.status}`);\n        error.response = response;\n        error.config = finalConfig;\n        throw error;\n      }\n\n      return await response.json();\n\n    } catch (error) {\n      // Apply error interceptors\n      let finalError = error as Error;\n      for (const interceptor of this.responseInterceptors) {\n        if (interceptor.onError) {\n          finalError = await interceptor.onError(finalError);\n        }\n      }\n      throw finalError;\n    }\n  }\n\n  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({ ...config, url, method: 'GET' });\n  }\n\n  async post<T>(url: string, data?: any, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({\n      ...config,\n      url,\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  }\n\n  async put<T>(url: string, data?: any, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({\n      ...config,\n      url,\n      method: 'PUT',\n      body: JSON.stringify(data)\n    });\n  }\n\n  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({ ...config, url, method: 'DELETE' });\n  }\n}\n\n// Usage example\nconst api = new ApiClient('https://api.example.com');\n\n// Add custom logging interceptor\napi.addRequestInterceptor({\n  onRequest: (config) => {\n    console.log(`Making request to ${config.url}`);\n    return config;\n  }\n});\n\n// Login and set tokens\nconst loginResponse = await api.post('/auth/login', {\n  email: 'user@example.com',\n  password: 'password'\n});\napi.setAccessToken(loginResponse.accessToken);\napi.setRefreshToken(loginResponse.refreshToken);\n\n// Make authenticated request\nconst userData = await api.get('/users/me');\n\nexport { ApiClient };",
    "hints": [
      "Store interceptors in arrays and apply them in sequence",
      "Use a retry flag on the request config to prevent infinite loops",
      "Apply request interceptors before the fetch call",
      "Apply response interceptors after receiving the response"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex11",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Database Connection Pool Manager",
    "difficulty": 4,
    "description": "Implement a connection pool manager for PostgreSQL with health checks, connection recycling, and monitoring. Handle connection failures gracefully and provide pool statistics.",
    "starterCode": "import { Pool, PoolClient, PoolConfig } from 'pg';\n\ninterface PoolStats {\n  total: number;\n  idle: number;\n  waiting: number;\n}\n\n// TODO: Create connection pool manager\n// - Initialize pool with config\n// - Health check functionality\n// - Connection acquisition with timeout\n// - Pool statistics\n// - Graceful shutdown\n\nclass DatabasePool {\n  // Implement pool manager\n}\n\nexport { DatabasePool };",
    "solution": "import { Pool, PoolClient, PoolConfig } from 'pg';\n\ninterface PoolStats {\n  total: number;\n  idle: number;\n  waiting: number;\n}\n\ninterface DatabasePoolConfig extends PoolConfig {\n  healthCheckInterval?: number;\n  connectionTimeout?: number;\n}\n\nclass DatabasePool {\n  private pool: Pool;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private connectionTimeout: number;\n\n  constructor(config: DatabasePoolConfig) {\n    const {\n      healthCheckInterval = 30000,\n      connectionTimeout = 5000,\n      ...poolConfig\n    } = config;\n\n    this.connectionTimeout = connectionTimeout;\n\n    // Create pool with default config\n    this.pool = new Pool({\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: connectionTimeout,\n      ...poolConfig\n    });\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Start health checks if enabled\n    if (healthCheckInterval > 0) {\n      this.startHealthChecks(healthCheckInterval);\n    }\n  }\n\n  private setupEventListeners() {\n    this.pool.on('connect', (client) => {\n      console.log('New client connected to pool');\n    });\n\n    this.pool.on('acquire', (client) => {\n      console.log('Client acquired from pool');\n    });\n\n    this.pool.on('remove', (client) => {\n      console.log('Client removed from pool');\n    });\n\n    this.pool.on('error', (err, client) => {\n      console.error('Unexpected error on idle client', err);\n    });\n  }\n\n  private startHealthChecks(interval: number) {\n    this.healthCheckInterval = setInterval(async () => {\n      try {\n        await this.healthCheck();\n        console.log('Health check passed');\n      } catch (error) {\n        console.error('Health check failed:', error);\n      }\n    }, interval);\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      const client = await this.pool.connect();\n      try {\n        const result = await client.query('SELECT 1');\n        return result.rows.length === 1;\n      } finally {\n        client.release();\n      }\n    } catch (error) {\n      throw new Error(`Health check failed: ${error}`);\n    }\n  }\n\n  async getConnection(): Promise<PoolClient> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Connection acquisition timeout'));\n      }, this.connectionTimeout);\n\n      this.pool.connect()\n        .then(client => {\n          clearTimeout(timeout);\n          resolve(client);\n        })\n        .catch(error => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n    });\n  }\n\n  async query<T = any>(text: string, params?: any[]): Promise<T[]> {\n    const client = await this.getConnection();\n    try {\n      const result = await client.query(text, params);\n      return result.rows;\n    } finally {\n      client.release();\n    }\n  }\n\n  async transaction<T>(callback: (client: PoolClient) => Promise<T>): Promise<T> {\n    const client = await this.getConnection();\n\n    try {\n      await client.query('BEGIN');\n      const result = await callback(client);\n      await client.query('COMMIT');\n      return result;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  getStats(): PoolStats {\n    return {\n      total: this.pool.totalCount,\n      idle: this.pool.idleCount,\n      waiting: this.pool.waitingCount\n    };\n  }\n\n  async shutdown(): Promise<void> {\n    console.log('Shutting down database pool...');\n\n    // Stop health checks\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n\n    // End pool\n    await this.pool.end();\n    console.log('Database pool shut down successfully');\n  }\n}\n\n// Usage example\nconst db = new DatabasePool({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,\n  healthCheckInterval: 30000\n});\n\n// Query with automatic connection management\nconst users = await db.query('SELECT * FROM users WHERE active = $1', [true]);\n\n// Transaction example\nawait db.transaction(async (client) => {\n  await client.query('INSERT INTO users (email) VALUES ($1)', ['user@example.com']);\n  await client.query('INSERT INTO audit_log (action) VALUES ($1)', ['user_created']);\n});\n\n// Get pool statistics\nconst stats = db.getStats();\nconsole.log(`Pool: ${stats.idle}/${stats.total} idle, ${stats.waiting} waiting`);\n\n// Graceful shutdown\nprocess.on('SIGTERM', async () => {\n  await db.shutdown();\n  process.exit(0);\n});\n\nexport { DatabasePool };",
    "hints": [
      "Use Pool event listeners to monitor connection lifecycle",
      "Implement health check using a simple SELECT 1 query",
      "Wrap connection acquisition in a promise with timeout",
      "Always release connections in finally blocks"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex12",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Type-Safe CRUD Repository with Prisma",
    "difficulty": 4,
    "description": "Create a generic repository pattern for CRUD operations using Prisma ORM. Implement type-safe methods with query building, pagination, and filtering capabilities.",
    "starterCode": "import { PrismaClient } from '@prisma/client';\n\ninterface PaginationParams {\n  page: number;\n  limit: number;\n}\n\ninterface PaginatedResult<T> {\n  data: T[];\n  total: number;\n  page: number;\n  totalPages: number;\n}\n\n// TODO: Create generic repository class\n// - Type-safe CRUD operations\n// - Pagination support\n// - Dynamic filtering\n// - Sorting capabilities\n// - Include relations\n\nclass Repository<T> {\n  // Implement repository\n}\n\nexport { Repository };",
    "solution": "import { PrismaClient } from '@prisma/client';\n\ninterface PaginationParams {\n  page: number;\n  limit: number;\n}\n\ninterface PaginatedResult<T> {\n  data: T[];\n  total: number;\n  page: number;\n  totalPages: number;\n}\n\ninterface QueryOptions<T> {\n  where?: any;\n  include?: any;\n  orderBy?: any;\n  select?: any;\n}\n\nclass Repository<T extends Record<string, any>> {\n  protected prisma: PrismaClient;\n  protected modelName: string;\n\n  constructor(prisma: PrismaClient, modelName: string) {\n    this.prisma = prisma;\n    this.modelName = modelName;\n  }\n\n  private getModel() {\n    return (this.prisma as any)[this.modelName];\n  }\n\n  async findById(id: string | number, options?: QueryOptions<T>): Promise<T | null> {\n    return this.getModel().findUnique({\n      where: { id },\n      ...options\n    });\n  }\n\n  async findOne(options: QueryOptions<T>): Promise<T | null> {\n    return this.getModel().findFirst(options);\n  }\n\n  async findMany(options?: QueryOptions<T>): Promise<T[]> {\n    return this.getModel().findMany(options);\n  }\n\n  async findWithPagination(\n    pagination: PaginationParams,\n    options?: QueryOptions<T>\n  ): Promise<PaginatedResult<T>> {\n    const { page, limit } = pagination;\n    const skip = (page - 1) * limit;\n\n    const [data, total] = await Promise.all([\n      this.getModel().findMany({\n        ...options,\n        skip,\n        take: limit\n      }),\n      this.getModel().count({ where: options?.where })\n    ]);\n\n    return {\n      data,\n      total,\n      page,\n      totalPages: Math.ceil(total / limit)\n    };\n  }\n\n  async create(data: Partial<T>): Promise<T> {\n    return this.getModel().create({ data });\n  }\n\n  async createMany(data: Partial<T>[]): Promise<{ count: number }> {\n    return this.getModel().createMany({ data });\n  }\n\n  async update(id: string | number, data: Partial<T>): Promise<T> {\n    return this.getModel().update({\n      where: { id },\n      data\n    });\n  }\n\n  async updateMany(where: any, data: Partial<T>): Promise<{ count: number }> {\n    return this.getModel().updateMany({\n      where,\n      data\n    });\n  }\n\n  async delete(id: string | number): Promise<T> {\n    return this.getModel().delete({\n      where: { id }\n    });\n  }\n\n  async deleteMany(where: any): Promise<{ count: number }> {\n    return this.getModel().deleteMany({ where });\n  }\n\n  async count(where?: any): Promise<number> {\n    return this.getModel().count({ where });\n  }\n\n  async exists(where: any): Promise<boolean> {\n    const count = await this.count(where);\n    return count > 0;\n  }\n}\n\n// Usage example with specific models\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: Date;\n}\n\ninterface Activity {\n  id: string;\n  userId: string;\n  category: string;\n  quantity: number;\n  date: Date;\n}\n\nconst prisma = new PrismaClient();\n\nclass UserRepository extends Repository<User> {\n  constructor() {\n    super(prisma, 'user');\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.findOne({ where: { email } });\n  }\n\n  async findActiveUsers(): Promise<User[]> {\n    return this.findMany({\n      where: { active: true },\n      orderBy: { createdAt: 'desc' }\n    });\n  }\n}\n\nclass ActivityRepository extends Repository<Activity> {\n  constructor() {\n    super(prisma, 'activity');\n  }\n\n  async findByUser(userId: string, pagination: PaginationParams): Promise<PaginatedResult<Activity>> {\n    return this.findWithPagination(pagination, {\n      where: { userId },\n      orderBy: { date: 'desc' }\n    });\n  }\n\n  async getTotalByCategory(userId: string): Promise<Record<string, number>> {\n    const activities = await this.findMany({\n      where: { userId },\n      select: { category: true, quantity: true }\n    });\n\n    return activities.reduce((acc, activity) => {\n      acc[activity.category] = (acc[activity.category] || 0) + activity.quantity;\n      return acc;\n    }, {} as Record<string, number>);\n  }\n}\n\n// Example usage\nconst userRepo = new UserRepository();\nconst activityRepo = new ActivityRepository();\n\n// Create user\nconst user = await userRepo.create({\n  email: 'user@example.com',\n  name: 'John Doe'\n});\n\n// Find with pagination\nconst activities = await activityRepo.findByUser(user.id, {\n  page: 1,\n  limit: 10\n});\n\nconsole.log(`Found ${activities.total} activities, showing page ${activities.page} of ${activities.totalPages}`);\n\nexport { Repository, UserRepository, ActivityRepository };",
    "hints": [
      "Use (this.prisma as any)[modelName] to access models dynamically",
      "Combine findMany and count queries with Promise.all for pagination",
      "Accept generic QueryOptions to allow flexible querying",
      "Extend the base Repository class for model-specific methods"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex13",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Frontend-Backend Integration Layer",
    "difficulty": 5,
    "description": "Build a complete integration layer that connects React frontend with Express backend. Implement real-time updates with Server-Sent Events, optimistic updates, and cache management.",
    "starterCode": "// Backend: SSE endpoint\nimport { Request, Response } from 'express';\n\n// TODO: Implement SSE endpoint for real-time updates\nexport function setupSSE(req: Request, res: Response) {\n  // Implement SSE\n}\n\n// Frontend: Integration hook\nimport { useState, useEffect } from 'react';\n\ninterface DataState<T> {\n  data: T[];\n  loading: boolean;\n  error: Error | null;\n}\n\n// TODO: Create integration hook with:\n// - CRUD operations\n// - Optimistic updates\n// - SSE for real-time updates\n// - Cache management\n\nexport function useDataSync<T>(endpoint: string) {\n  // Implement hook\n}",
    "solution": "// Backend: SSE endpoint\nimport { Request, Response } from 'express';\nimport { EventEmitter } from 'events';\n\nclass SSEManager extends EventEmitter {\n  private clients: Map<string, Response> = new Map();\n\n  addClient(clientId: string, res: Response) {\n    this.clients.set(clientId, res);\n\n    res.on('close', () => {\n      this.clients.delete(clientId);\n      console.log(`Client ${clientId} disconnected`);\n    });\n  }\n\n  broadcast(event: string, data: any) {\n    const message = `event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n\n    this.clients.forEach((client, clientId) => {\n      try {\n        client.write(message);\n      } catch (error) {\n        console.error(`Failed to send to client ${clientId}`, error);\n        this.clients.delete(clientId);\n      }\n    });\n  }\n\n  sendToClient(clientId: string, event: string, data: any) {\n    const client = this.clients.get(clientId);\n    if (client) {\n      const message = `event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n      client.write(message);\n    }\n  }\n}\n\nconst sseManager = new SSEManager();\n\nexport function setupSSE(req: Request, res: Response) {\n  const clientId = req.query.clientId as string || `client-${Date.now()}`;\n\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n  res.setHeader('Access-Control-Allow-Origin', '*');\n\n  // Send initial connection message\n  res.write(`data: ${JSON.stringify({ type: 'connected', clientId })}\\n\\n`);\n\n  // Add client to manager\n  sseManager.addClient(clientId, res);\n\n  // Keep connection alive with heartbeat\n  const heartbeat = setInterval(() => {\n    res.write(': heartbeat\\n\\n');\n  }, 30000);\n\n  res.on('close', () => {\n    clearInterval(heartbeat);\n  });\n}\n\n// Broadcast updates when data changes\nexport function broadcastUpdate(event: string, data: any) {\n  sseManager.broadcast(event, data);\n}\n\n// Frontend: Integration hook\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\ninterface DataState<T> {\n  data: T[];\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface CacheEntry<T> {\n  data: T[];\n  timestamp: number;\n}\n\nconst cache = new Map<string, CacheEntry<any>>();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport function useDataSync<T extends { id: string }>(\n  endpoint: string,\n  options: { realtime?: boolean; cacheKey?: string } = {}\n) {\n  const [state, setState] = useState<DataState<T>>({\n    data: [],\n    loading: true,\n    error: null\n  });\n\n  const eventSourceRef = useRef<EventSource | null>(null);\n  const { realtime = true, cacheKey = endpoint } = options;\n\n  // Check cache\n  const getCachedData = useCallback(() => {\n    const cached = cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n      return cached.data;\n    }\n    return null;\n  }, [cacheKey]);\n\n  // Update cache\n  const updateCache = useCallback((data: T[]) => {\n    cache.set(cacheKey, {\n      data,\n      timestamp: Date.now()\n    });\n  }, [cacheKey]);\n\n  // Fetch data\n  const fetchData = useCallback(async () => {\n    try {\n      // Check cache first\n      const cachedData = getCachedData();\n      if (cachedData) {\n        setState({ data: cachedData, loading: false, error: null });\n        return;\n      }\n\n      setState(prev => ({ ...prev, loading: true }));\n\n      const response = await fetch(`/api${endpoint}`);\n      if (!response.ok) throw new Error('Failed to fetch');\n\n      const data = await response.json();\n      updateCache(data);\n      setState({ data, loading: false, error: null });\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        loading: false,\n        error: error as Error\n      }));\n    }\n  }, [endpoint, getCachedData, updateCache]);\n\n  // Create item with optimistic update\n  const create = useCallback(async (item: Omit<T, 'id'>) => {\n    const tempId = `temp-${Date.now()}`;\n    const optimisticItem = { ...item, id: tempId } as T;\n\n    // Optimistic update\n    setState(prev => ({\n      ...prev,\n      data: [...prev.data, optimisticItem]\n    }));\n\n    try {\n      const response = await fetch(`/api${endpoint}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(item)\n      });\n\n      if (!response.ok) throw new Error('Failed to create');\n\n      const created = await response.json();\n\n      // Replace optimistic item with real one\n      setState(prev => ({\n        ...prev,\n        data: prev.data.map(i => i.id === tempId ? created : i)\n      }));\n\n      updateCache(state.data);\n      return created;\n    } catch (error) {\n      // Rollback optimistic update\n      setState(prev => ({\n        ...prev,\n        data: prev.data.filter(i => i.id !== tempId),\n        error: error as Error\n      }));\n      throw error;\n    }\n  }, [endpoint, state.data, updateCache]);\n\n  // Update item with optimistic update\n  const update = useCallback(async (id: string, updates: Partial<T>) => {\n    const originalData = [...state.data];\n\n    // Optimistic update\n    setState(prev => ({\n      ...prev,\n      data: prev.data.map(item =>\n        item.id === id ? { ...item, ...updates } : item\n      )\n    }));\n\n    try {\n      const response = await fetch(`/api${endpoint}/${id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(updates)\n      });\n\n      if (!response.ok) throw new Error('Failed to update');\n\n      const updated = await response.json();\n\n      setState(prev => ({\n        ...prev,\n        data: prev.data.map(i => i.id === id ? updated : i)\n      }));\n\n      updateCache(state.data);\n      return updated;\n    } catch (error) {\n      // Rollback\n      setState(prev => ({\n        ...prev,\n        data: originalData,\n        error: error as Error\n      }));\n      throw error;\n    }\n  }, [endpoint, state.data, updateCache]);\n\n  // Delete item with optimistic update\n  const remove = useCallback(async (id: string) => {\n    const originalData = [...state.data];\n\n    // Optimistic update\n    setState(prev => ({\n      ...prev,\n      data: prev.data.filter(item => item.id !== id)\n    }));\n\n    try {\n      const response = await fetch(`/api${endpoint}/${id}`, {\n        method: 'DELETE'\n      });\n\n      if (!response.ok) throw new Error('Failed to delete');\n\n      updateCache(state.data);\n    } catch (error) {\n      // Rollback\n      setState(prev => ({\n        ...prev,\n        data: originalData,\n        error: error as Error\n      }));\n      throw error;\n    }\n  }, [endpoint, state.data, updateCache]);\n\n  // Setup SSE for real-time updates\n  useEffect(() => {\n    if (!realtime) return;\n\n    const clientId = `client-${Date.now()}`;\n    const eventSource = new EventSource(`/api/events?clientId=${clientId}`);\n    eventSourceRef.current = eventSource;\n\n    eventSource.addEventListener('created', (event) => {\n      const item = JSON.parse(event.data);\n      setState(prev => ({\n        ...prev,\n        data: [...prev.data, item]\n      }));\n    });\n\n    eventSource.addEventListener('updated', (event) => {\n      const item = JSON.parse(event.data);\n      setState(prev => ({\n        ...prev,\n        data: prev.data.map(i => i.id === item.id ? item : i)\n      }));\n    });\n\n    eventSource.addEventListener('deleted', (event) => {\n      const { id } = JSON.parse(event.data);\n      setState(prev => ({\n        ...prev,\n        data: prev.data.filter(i => i.id !== id)\n      }));\n    });\n\n    return () => {\n      eventSource.close();\n    };\n  }, [realtime]);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return {\n    ...state,\n    create,\n    update,\n    remove,\n    refetch: fetchData\n  };\n}\n\n// Usage example\nfunction ActivityList() {\n  const {\n    data: activities,\n    loading,\n    error,\n    create,\n    update,\n    remove\n  } = useDataSync<Activity>('/activities', { realtime: true });\n\n  const handleCreate = async () => {\n    await create({\n      category: 'transportation',\n      quantity: 10,\n      date: new Date()\n    });\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <button onClick={handleCreate}>Add Activity</button>\n      {activities.map(activity => (\n        <div key={activity.id}>\n          {activity.category} - {activity.quantity}\n          <button onClick={() => update(activity.id, { quantity: activity.quantity + 1 })}>\n            +\n          </button>\n          <button onClick={() => remove(activity.id)}>Delete</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport { setupSSE, broadcastUpdate, useDataSync };",
    "hints": [
      "Use EventSource API for SSE on the frontend",
      "Store original data before optimistic updates for rollback",
      "Implement cache with timestamps for TTL management",
      "Use EventEmitter pattern for managing SSE clients on backend"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex14",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Code Review Checklist Validator",
    "difficulty": 5,
    "description": "Create an automated code review checklist validator that analyzes TypeScript code for common issues. Check for proper error handling, type safety, naming conventions, and code complexity.",
    "starterCode": "import * as ts from 'typescript';\n\ninterface ReviewIssue {\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  line?: number;\n  column?: number;\n}\n\ninterface ReviewResult {\n  passed: boolean;\n  issues: ReviewIssue[];\n  score: number;\n}\n\n// TODO: Create code review validator\n// - Parse TypeScript code\n// - Check for proper error handling (try-catch)\n// - Verify type annotations\n// - Check naming conventions\n// - Detect code smells\n// - Calculate complexity score\n\nexport class CodeReviewValidator {\n  // Implement validator\n}",
    "solution": "import * as ts from 'typescript';\n\ninterface ReviewIssue {\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  line?: number;\n  column?: number;\n  rule: string;\n}\n\ninterface ReviewResult {\n  passed: boolean;\n  issues: ReviewIssue[];\n  score: number;\n  metrics: {\n    complexity: number;\n    linesOfCode: number;\n    typeAnnotationCoverage: number;\n  };\n}\n\nexport class CodeReviewValidator {\n  private sourceFile: ts.SourceFile;\n  private issues: ReviewIssue[] = [];\n\n  constructor(code: string, fileName: string = 'temp.ts') {\n    this.sourceFile = ts.createSourceFile(\n      fileName,\n      code,\n      ts.ScriptTarget.Latest,\n      true\n    );\n  }\n\n  validate(): ReviewResult {\n    this.issues = [];\n\n    // Run all checks\n    this.checkErrorHandling();\n    this.checkTypeAnnotations();\n    this.checkNamingConventions();\n    this.checkComplexity();\n    this.checkCodeSmells();\n\n    const metrics = {\n      complexity: this.calculateComplexity(),\n      linesOfCode: this.sourceFile.getLineAndCharacterOfPosition(this.sourceFile.end).line + 1,\n      typeAnnotationCoverage: this.calculateTypeAnnotationCoverage()\n    };\n\n    // Calculate score (0-100)\n    const errorCount = this.issues.filter(i => i.severity === 'error').length;\n    const warningCount = this.issues.filter(i => i.severity === 'warning').length;\n    const score = Math.max(0, 100 - (errorCount * 10) - (warningCount * 5));\n\n    return {\n      passed: errorCount === 0 && score >= 70,\n      issues: this.issues,\n      score,\n      metrics\n    };\n  }\n\n  private addIssue(issue: ReviewIssue) {\n    this.issues.push(issue);\n  }\n\n  private getLineAndColumn(node: ts.Node) {\n    const { line, character } = this.sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    return { line: line + 1, column: character + 1 };\n  }\n\n  private checkErrorHandling() {\n    const visit = (node: ts.Node) => {\n      // Check async functions without try-catch\n      if (ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) || ts.isMethodDeclaration(node)) {\n        const isAsync = node.modifiers?.some(m => m.kind === ts.SyntaxKind.AsyncKeyword);\n\n        if (isAsync) {\n          let hasTryCatch = false;\n\n          const checkBody = (body: ts.Node) => {\n            if (ts.isTryStatement(body)) {\n              hasTryCatch = true;\n            }\n            ts.forEachChild(body, checkBody);\n          };\n\n          if (node.body) {\n            checkBody(node.body);\n          }\n\n          if (!hasTryCatch) {\n            const { line, column } = this.getLineAndColumn(node);\n            this.addIssue({\n              severity: 'warning',\n              message: 'Async function should have error handling (try-catch)',\n              line,\n              column,\n              rule: 'error-handling'\n            });\n          }\n        }\n      }\n\n      // Check Promise usage without .catch()\n      if (ts.isCallExpression(node)) {\n        const text = node.expression.getText(this.sourceFile);\n        if (text.includes('fetch') || text.includes('Promise')) {\n          // Check if .catch() is chained\n          let parent = node.parent;\n          let hasCatch = false;\n\n          while (parent && ts.isCallExpression(parent)) {\n            if (parent.expression.getText(this.sourceFile).includes('.catch')) {\n              hasCatch = true;\n              break;\n            }\n            parent = parent.parent;\n          }\n\n          if (!hasCatch) {\n            const { line, column } = this.getLineAndColumn(node);\n            this.addIssue({\n              severity: 'info',\n              message: 'Promise should have .catch() handler',\n              line,\n              column,\n              rule: 'promise-catch'\n            });\n          }\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private checkTypeAnnotations() {\n    const visit = (node: ts.Node) => {\n      // Check function parameters\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) || ts.isArrowFunction(node)) {\n        node.parameters.forEach(param => {\n          if (!param.type && !param.initializer) {\n            const { line, column } = this.getLineAndColumn(param);\n            this.addIssue({\n              severity: 'warning',\n              message: `Parameter '${param.name.getText(this.sourceFile)}' should have type annotation`,\n              line,\n              column,\n              rule: 'type-annotation'\n            });\n          }\n        });\n\n        // Check return type\n        if (!node.type && ts.isFunctionDeclaration(node)) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'warning',\n            message: 'Function should have return type annotation',\n            line,\n            column,\n            rule: 'return-type'\n          });\n        }\n      }\n\n      // Check variable declarations\n      if (ts.isVariableDeclaration(node)) {\n        if (!node.type && !node.initializer) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'info',\n            message: `Variable '${node.name.getText(this.sourceFile)}' should have type annotation`,\n            line,\n            column,\n            rule: 'var-type'\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private checkNamingConventions() {\n    const visit = (node: ts.Node) => {\n      // Check function names (camelCase)\n      if (ts.isFunctionDeclaration(node) && node.name) {\n        const name = node.name.text;\n        if (!/^[a-z][a-zA-Z0-9]*$/.test(name)) {\n          const { line, column } = this.getLineAndColumn(node.name);\n          this.addIssue({\n            severity: 'info',\n            message: `Function '${name}' should use camelCase`,\n            line,\n            column,\n            rule: 'naming-convention'\n          });\n        }\n      }\n\n      // Check class names (PascalCase)\n      if (ts.isClassDeclaration(node) && node.name) {\n        const name = node.name.text;\n        if (!/^[A-Z][a-zA-Z0-9]*$/.test(name)) {\n          const { line, column } = this.getLineAndColumn(node.name);\n          this.addIssue({\n            severity: 'info',\n            message: `Class '${name}' should use PascalCase`,\n            line,\n            column,\n            rule: 'naming-convention'\n          });\n        }\n      }\n\n      // Check constants (UPPER_CASE)\n      if (ts.isVariableDeclaration(node)) {\n        const name = node.name.getText(this.sourceFile);\n        const parent = node.parent;\n        if (parent && ts.isVariableDeclarationList(parent)) {\n          const isConst = (parent.flags & ts.NodeFlags.Const) !== 0;\n          if (isConst && /^[A-Z_]+$/.test(name) === false && name === name.toUpperCase()) {\n            // Allow UPPER_CASE for constants, but don't require it\n          }\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private checkComplexity() {\n    const visit = (node: ts.Node) => {\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n        const complexity = this.calculateFunctionComplexity(node);\n\n        if (complexity > 10) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'warning',\n            message: `Function has high cyclomatic complexity (${complexity}). Consider refactoring.`,\n            line,\n            column,\n            rule: 'complexity'\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private calculateFunctionComplexity(node: ts.FunctionDeclaration | ts.MethodDeclaration): number {\n    let complexity = 1;\n\n    const visit = (n: ts.Node) => {\n      if (ts.isIfStatement(n) || ts.isConditionalExpression(n)) complexity++;\n      if (ts.isWhileStatement(n) || ts.isDoStatement(n) || ts.isForStatement(n) || ts.isForInStatement(n) || ts.isForOfStatement(n)) complexity++;\n      if (ts.isCaseClause(n)) complexity++;\n      if (ts.isCatchClause(n)) complexity++;\n      if (ts.isBinaryExpression(n) && (n.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken || n.operatorToken.kind === ts.SyntaxKind.BarBarToken)) complexity++;\n\n      ts.forEachChild(n, visit);\n    };\n\n    if (node.body) {\n      visit(node.body);\n    }\n\n    return complexity;\n  }\n\n  private calculateComplexity(): number {\n    let totalComplexity = 0;\n    let functionCount = 0;\n\n    const visit = (node: ts.Node) => {\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n        totalComplexity += this.calculateFunctionComplexity(node);\n        functionCount++;\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n\n    return functionCount > 0 ? totalComplexity / functionCount : 0;\n  }\n\n  private calculateTypeAnnotationCoverage(): number {\n    let total = 0;\n    let annotated = 0;\n\n    const visit = (node: ts.Node) => {\n      if (ts.isParameter(node) || ts.isVariableDeclaration(node)) {\n        total++;\n        if (node.type || node.initializer) annotated++;\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n\n    return total > 0 ? (annotated / total) * 100 : 100;\n  }\n\n  private checkCodeSmells() {\n    const visit = (node: ts.Node) => {\n      // Check for magic numbers\n      if (ts.isNumericLiteral(node)) {\n        const value = parseInt(node.text);\n        if (value > 1 && !this.isInConstDeclaration(node)) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'info',\n            message: `Magic number ${value} should be a named constant`,\n            line,\n            column,\n            rule: 'magic-number'\n          });\n        }\n      }\n\n      // Check for long parameter lists\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n        if (node.parameters.length > 4) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'info',\n            message: `Function has ${node.parameters.length} parameters. Consider using an options object.`,\n            line,\n            column,\n            rule: 'parameter-count'\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private isInConstDeclaration(node: ts.Node): boolean {\n    let parent = node.parent;\n    while (parent) {\n      if (ts.isVariableDeclaration(parent)) {\n        const grandParent = parent.parent;\n        if (grandParent && ts.isVariableDeclarationList(grandParent)) {\n          return (grandParent.flags & ts.NodeFlags.Const) !== 0;\n        }\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n}\n\n// Usage example\nconst code = `\nasync function fetchUser(id: string) {\n  const response = await fetch(\\`/api/users/\\${id}\\`);\n  return response.json();\n}\n\nfunction calculateTotal(a, b, c, d, e) {\n  return a + b + c + d + e + 100;\n}\n`;\n\nconst validator = new CodeReviewValidator(code);\nconst result = validator.validate();\n\nconsole.log(`Review Score: ${result.score}/100`);\nconsole.log(`Passed: ${result.passed}`);\nconsole.log(`\\nIssues:`);\nresult.issues.forEach(issue => {\n  console.log(`  [${issue.severity}] Line ${issue.line}: ${issue.message}`);\n});\n\nexport { CodeReviewValidator };",
    "hints": [
      "Use TypeScript Compiler API to parse and traverse the AST",
      "Track different node types for different checks (functions, variables, etc)",
      "Calculate cyclomatic complexity by counting decision points",
      "Use node.parent to traverse up the tree for context"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex15",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Pull Request Template Generator",
    "difficulty": 3,
    "description": "Create a tool that generates comprehensive pull request descriptions by analyzing Git diff and commit history. Extract meaningful information and format it according to PR templates.",
    "starterCode": "import { execSync } from 'child_process';\n\ninterface PRTemplate {\n  title: string;\n  description: string;\n  changes: string[];\n  testPlan: string[];\n  breaking: boolean;\n  linkedIssues: string[];\n}\n\n// TODO: Create PR template generator\n// - Analyze git diff\n// - Parse commit messages\n// - Extract file changes\n// - Detect breaking changes\n// - Generate formatted PR description\n\nexport class PRTemplateGenerator {\n  // Implement generator\n}",
    "solution": "import { execSync } from 'child_process';\n\ninterface PRTemplate {\n  title: string;\n  description: string;\n  changes: string[];\n  testPlan: string[];\n  breaking: boolean;\n  linkedIssues: string[];\n  filesChanged: {\n    added: string[];\n    modified: string[];\n    deleted: string[];\n  };\n}\n\ninterface CommitInfo {\n  hash: string;\n  message: string;\n  type?: string;\n  scope?: string;\n  breaking: boolean;\n}\n\nexport class PRTemplateGenerator {\n  private baseBranch: string;\n\n  constructor(baseBranch: string = 'main') {\n    this.baseBranch = baseBranch;\n  }\n\n  generate(): PRTemplate {\n    const commits = this.getCommits();\n    const fileChanges = this.getFileChanges();\n    const diff = this.getDiff();\n\n    const title = this.generateTitle(commits);\n    const description = this.generateDescription(commits);\n    const changes = this.extractChanges(commits);\n    const testPlan = this.generateTestPlan(fileChanges);\n    const breaking = commits.some(c => c.breaking);\n    const linkedIssues = this.extractIssues(commits);\n\n    return {\n      title,\n      description,\n      changes,\n      testPlan,\n      breaking,\n      linkedIssues,\n      filesChanged: fileChanges\n    };\n  }\n\n  private getCommits(): CommitInfo[] {\n    try {\n      const output = execSync(\n        `git log ${this.baseBranch}..HEAD --pretty=format:\"%H|%s\"`,\n        { encoding: 'utf-8' }\n      );\n\n      return output\n        .split('\\n')\n        .filter(line => line.trim())\n        .map(line => {\n          const [hash, message] = line.split('|');\n          return this.parseCommit(hash, message);\n        });\n    } catch (error) {\n      console.error('Failed to get commits:', error);\n      return [];\n    }\n  }\n\n  private parseCommit(hash: string, message: string): CommitInfo {\n    // Parse conventional commit format\n    const conventionalRegex = /^(\\w+)(\\(([^)]+)\\))?(!)?:\\s*(.+)$/;\n    const match = message.match(conventionalRegex);\n\n    if (match) {\n      const [, type, , scope, breaking, msg] = match;\n      return {\n        hash,\n        message: msg,\n        type,\n        scope,\n        breaking: breaking === '!'\n      };\n    }\n\n    // Check for BREAKING CHANGE in message\n    const breaking = message.includes('BREAKING CHANGE');\n\n    return {\n      hash,\n      message,\n      breaking\n    };\n  }\n\n  private getFileChanges() {\n    try {\n      const added = this.getFilesByStatus('A');\n      const modified = this.getFilesByStatus('M');\n      const deleted = this.getFilesByStatus('D');\n\n      return { added, modified, deleted };\n    } catch (error) {\n      console.error('Failed to get file changes:', error);\n      return { added: [], modified: [], deleted: [] };\n    }\n  }\n\n  private getFilesByStatus(status: string): string[] {\n    try {\n      const output = execSync(\n        `git diff --name-only --diff-filter=${status} ${this.baseBranch}..HEAD`,\n        { encoding: 'utf-8' }\n      );\n\n      return output.split('\\n').filter(line => line.trim());\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private getDiff(): string {\n    try {\n      return execSync(`git diff ${this.baseBranch}..HEAD`, { encoding: 'utf-8' });\n    } catch (error) {\n      return '';\n    }\n  }\n\n  private generateTitle(commits: CommitInfo[]): string {\n    if (commits.length === 0) {\n      return 'Update';\n    }\n\n    // Group by type\n    const types = commits.map(c => c.type).filter(Boolean);\n    const uniqueTypes = [...new Set(types)];\n\n    if (uniqueTypes.length === 1) {\n      const type = uniqueTypes[0];\n      const typeMap: Record<string, string> = {\n        feat: 'Add',\n        fix: 'Fix',\n        docs: 'Update documentation',\n        refactor: 'Refactor',\n        test: 'Add tests',\n        chore: 'Update'\n      };\n\n      const prefix = typeMap[type] || 'Update';\n\n      // Use first commit message\n      const firstCommit = commits[0];\n      return `${prefix}: ${firstCommit.message}`;\n    }\n\n    // Multiple types - use generic title\n    return `Update: Multiple changes (${commits.length} commits)`;\n  }\n\n  private generateDescription(commits: CommitInfo[]): string {\n    const parts: string[] = [];\n\n    // Group commits by type\n    const grouped = commits.reduce((acc, commit) => {\n      const type = commit.type || 'other';\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(commit);\n      return acc;\n    }, {} as Record<string, CommitInfo[]>);\n\n    // Format each group\n    Object.entries(grouped).forEach(([type, commits]) => {\n      const typeLabel = type.charAt(0).toUpperCase() + type.slice(1);\n      parts.push(`### ${typeLabel}`);\n      commits.forEach(commit => {\n        const scope = commit.scope ? `**${commit.scope}**: ` : '';\n        parts.push(`- ${scope}${commit.message}`);\n      });\n      parts.push('');\n    });\n\n    return parts.join('\\n');\n  }\n\n  private extractChanges(commits: CommitInfo[]): string[] {\n    return commits.map(commit => {\n      const scope = commit.scope ? `[${commit.scope}] ` : '';\n      return `${scope}${commit.message}`;\n    });\n  }\n\n  private generateTestPlan(fileChanges: PRTemplate['filesChanged']): string[] {\n    const plan: string[] = [];\n\n    if (fileChanges.added.length > 0) {\n      plan.push('Test new functionality in added files');\n      fileChanges.added.forEach(file => {\n        if (file.includes('test')) {\n          plan.push(`Run tests in ${file}`);\n        }\n      });\n    }\n\n    if (fileChanges.modified.length > 0) {\n      plan.push('Verify existing functionality still works');\n\n      // Check for specific file types\n      const hasBackend = fileChanges.modified.some(f =>\n        f.includes('api/') || f.includes('server/') || f.endsWith('.controller.ts')\n      );\n      const hasFrontend = fileChanges.modified.some(f =>\n        f.includes('components/') || f.endsWith('.tsx')\n      );\n\n      if (hasBackend) {\n        plan.push('Test API endpoints manually or with Postman');\n      }\n      if (hasFrontend) {\n        plan.push('Test UI changes in browser');\n      }\n    }\n\n    if (plan.length === 0) {\n      plan.push('Run all tests: npm test');\n      plan.push('Verify build: npm run build');\n    }\n\n    return plan;\n  }\n\n  private extractIssues(commits: CommitInfo[]): string[] {\n    const issues = new Set<string>();\n    const issueRegex = /#(\\d+)/g;\n\n    commits.forEach(commit => {\n      const matches = commit.message.matchAll(issueRegex);\n      for (const match of matches) {\n        issues.add(match[1]);\n      }\n    });\n\n    return Array.from(issues);\n  }\n\n  formatAsMarkdown(): string {\n    const template = this.generate();\n\n    const sections: string[] = [];\n\n    // Title\n    sections.push(`# ${template.title}\\n`);\n\n    // Breaking change warning\n    if (template.breaking) {\n      sections.push('## ⚠️ BREAKING CHANGE\\n');\n      sections.push('This PR contains breaking changes. Please review carefully.\\n');\n    }\n\n    // Description\n    sections.push('## Description\\n');\n    sections.push(template.description);\n\n    // Changes\n    if (template.changes.length > 0) {\n      sections.push('## Changes\\n');\n      template.changes.forEach(change => {\n        sections.push(`- ${change}`);\n      });\n      sections.push('');\n    }\n\n    // Files changed\n    sections.push('## Files Changed\\n');\n    if (template.filesChanged.added.length > 0) {\n      sections.push(`**Added (${template.filesChanged.added.length}):**`);\n      template.filesChanged.added.forEach(file => sections.push(`- ${file}`));\n      sections.push('');\n    }\n    if (template.filesChanged.modified.length > 0) {\n      sections.push(`**Modified (${template.filesChanged.modified.length}):**`);\n      template.filesChanged.modified.forEach(file => sections.push(`- ${file}`));\n      sections.push('');\n    }\n    if (template.filesChanged.deleted.length > 0) {\n      sections.push(`**Deleted (${template.filesChanged.deleted.length}):**`);\n      template.filesChanged.deleted.forEach(file => sections.push(`- ${file}`));\n      sections.push('');\n    }\n\n    // Test plan\n    sections.push('## Test Plan\\n');\n    template.testPlan.forEach((step, i) => {\n      sections.push(`${i + 1}. ${step}`);\n    });\n    sections.push('');\n\n    // Linked issues\n    if (template.linkedIssues.length > 0) {\n      sections.push('## Related Issues\\n');\n      template.linkedIssues.forEach(issue => {\n        sections.push(`- Closes #${issue}`);\n      });\n      sections.push('');\n    }\n\n    return sections.join('\\n');\n  }\n}\n\n// Usage example\nconst generator = new PRTemplateGenerator('main');\nconst markdown = generator.formatAsMarkdown();\nconsole.log(markdown);\n\n// Output to file\nimport { writeFileSync } from 'fs';\nwriteFileSync('PR_DESCRIPTION.md', markdown);\n\nexport { PRTemplateGenerator };",
    "hints": [
      "Use git log with custom format to get commit messages",
      "Parse conventional commit format with regex",
      "Use git diff --name-only with --diff-filter to get file changes by status",
      "Extract issue numbers from commit messages using regex"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex16",
    "subjectId": "cs404",
    "topicId": "topic-3",
    "title": "Development Workflow Automation Script",
    "difficulty": 5,
    "description": "Build a comprehensive workflow automation tool that handles common development tasks: branch creation, commit formatting, pre-push checks, and deployment preparation. Integrate multiple Git operations and validation steps.",
    "starterCode": "import { execSync } from 'child_process';\nimport prompts from 'prompts';\n\ninterface WorkflowConfig {\n  baseBranch: string;\n  requireTests: boolean;\n  requireLinting: boolean;\n  conventionalCommits: boolean;\n}\n\n// TODO: Create workflow automation tool\n// - Interactive branch creation\n// - Automated commit message formatting\n// - Pre-push validation (tests, lint, build)\n// - Change detection and impact analysis\n// - Deployment checklist generation\n\nexport class WorkflowAutomation {\n  // Implement automation tool\n}",
    "solution": "import { execSync } from 'child_process';\nimport prompts from 'prompts';\nimport chalk from 'chalk';\n\ninterface WorkflowConfig {\n  baseBranch: string;\n  requireTests: boolean;\n  requireLinting: boolean;\n  conventionalCommits: boolean;\n  remoteUrl?: string;\n}\n\ninterface BranchInfo {\n  name: string;\n  type: 'feature' | 'bugfix' | 'hotfix' | 'release' | 'chore';\n  description: string;\n}\n\ninterface CommitInfo {\n  type: string;\n  scope?: string;\n  message: string;\n  breaking: boolean;\n}\n\ninterface ValidationResult {\n  passed: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport class WorkflowAutomation {\n  private config: WorkflowConfig;\n\n  constructor(config: Partial<WorkflowConfig> = {}) {\n    this.config = {\n      baseBranch: 'main',\n      requireTests: true,\n      requireLinting: true,\n      conventionalCommits: true,\n      ...config\n    };\n  }\n\n  private exec(command: string, silent: boolean = false): string {\n    try {\n      return execSync(command, {\n        encoding: 'utf-8',\n        stdio: silent ? 'pipe' : 'inherit'\n      });\n    } catch (error: any) {\n      throw new Error(`Command failed: ${command}\\n${error.message}`);\n    }\n  }\n\n  private execSilent(command: string): string {\n    return this.exec(command, true);\n  }\n\n  async createBranch(): Promise<void> {\n    console.log(chalk.blue('\\n📦 Creating new branch...\\n'));\n\n    // Get current branch\n    const currentBranch = this.execSilent('git rev-parse --abbrev-ref HEAD').trim();\n\n    if (currentBranch !== this.config.baseBranch) {\n      const { switchBase } = await prompts({\n        type: 'confirm',\n        name: 'switchBase',\n        message: `You're on '${currentBranch}'. Switch to '${this.config.baseBranch}'?`,\n        initial: true\n      });\n\n      if (switchBase) {\n        this.exec(`git checkout ${this.config.baseBranch}`);\n        this.exec('git pull origin ' + this.config.baseBranch);\n      }\n    }\n\n    // Get branch details\n    const response = await prompts([\n      {\n        type: 'select',\n        name: 'type',\n        message: 'Branch type:',\n        choices: [\n          { title: 'Feature', value: 'feature' },\n          { title: 'Bugfix', value: 'bugfix' },\n          { title: 'Hotfix', value: 'hotfix' },\n          { title: 'Release', value: 'release' },\n          { title: 'Chore', value: 'chore' }\n        ]\n      },\n      {\n        type: 'text',\n        name: 'description',\n        message: 'Branch description (kebab-case):',\n        validate: (value: string) =>\n          /^[a-z0-9-]+$/.test(value) || 'Use lowercase letters, numbers, and hyphens only'\n      }\n    ]);\n\n    const branchName = `${response.type}/${response.description}`;\n\n    // Create and checkout branch\n    this.exec(`git checkout -b ${branchName}`);\n\n    console.log(chalk.green(`\\n✓ Created and switched to branch: ${branchName}\\n`));\n  }\n\n  async createCommit(): Promise<void> {\n    console.log(chalk.blue('\\n📝 Creating commit...\\n'));\n\n    // Check for staged changes\n    const stagedFiles = this.execSilent('git diff --cached --name-only').trim();\n\n    if (!stagedFiles) {\n      console.log(chalk.yellow('No staged changes. Stage files first with: git add <files>'));\n      return;\n    }\n\n    console.log(chalk.gray('Staged files:'));\n    stagedFiles.split('\\n').forEach(file => {\n      console.log(chalk.gray(`  - ${file}`));\n    });\n    console.log('');\n\n    let commitMessage: string;\n\n    if (this.config.conventionalCommits) {\n      const response = await prompts([\n        {\n          type: 'select',\n          name: 'type',\n          message: 'Commit type:',\n          choices: [\n            { title: 'feat: New feature', value: 'feat' },\n            { title: 'fix: Bug fix', value: 'fix' },\n            { title: 'docs: Documentation', value: 'docs' },\n            { title: 'style: Code style', value: 'style' },\n            { title: 'refactor: Code refactoring', value: 'refactor' },\n            { title: 'test: Tests', value: 'test' },\n            { title: 'chore: Maintenance', value: 'chore' }\n          ]\n        },\n        {\n          type: 'text',\n          name: 'scope',\n          message: 'Scope (optional):',\n        },\n        {\n          type: 'text',\n          name: 'message',\n          message: 'Commit message:',\n          validate: (value: string) => value.length > 0 || 'Message required'\n        },\n        {\n          type: 'confirm',\n          name: 'breaking',\n          message: 'Breaking change?',\n          initial: false\n        },\n        {\n          type: (prev: boolean) => prev ? 'text' : null,\n          name: 'breakingDescription',\n          message: 'Describe the breaking change:'\n        }\n      ]);\n\n      // Format conventional commit\n      const scope = response.scope ? `(${response.scope})` : '';\n      const breaking = response.breaking ? '!' : '';\n      commitMessage = `${response.type}${scope}${breaking}: ${response.message}`;\n\n      if (response.breaking && response.breakingDescription) {\n        commitMessage += `\\n\\nBREAKING CHANGE: ${response.breakingDescription}`;\n      }\n    } else {\n      const { message } = await prompts({\n        type: 'text',\n        name: 'message',\n        message: 'Commit message:',\n        validate: (value: string) => value.length > 0 || 'Message required'\n      });\n      commitMessage = message;\n    }\n\n    // Create commit\n    this.exec(`git commit -m \"${commitMessage}\"`);\n\n    console.log(chalk.green('\\n✓ Commit created successfully\\n'));\n  }\n\n  async prePushCheck(): Promise<boolean> {\n    console.log(chalk.blue('\\n🔍 Running pre-push checks...\\n'));\n\n    const results: ValidationResult = {\n      passed: true,\n      errors: [],\n      warnings: []\n    };\n\n    // Check for uncommitted changes\n    const uncommitted = this.execSilent('git status --porcelain').trim();\n    if (uncommitted) {\n      results.warnings.push('You have uncommitted changes');\n    }\n\n    // Run linting\n    if (this.config.requireLinting) {\n      console.log(chalk.gray('Running linter...'));\n      try {\n        this.execSilent('npm run lint');\n        console.log(chalk.green('✓ Linting passed'));\n      } catch (error) {\n        results.errors.push('Linting failed');\n        results.passed = false;\n        console.log(chalk.red('✗ Linting failed'));\n      }\n    }\n\n    // Run tests\n    if (this.config.requireTests) {\n      console.log(chalk.gray('Running tests...'));\n      try {\n        this.execSilent('npm test');\n        console.log(chalk.green('✓ Tests passed'));\n      } catch (error) {\n        results.errors.push('Tests failed');\n        results.passed = false;\n        console.log(chalk.red('✗ Tests failed'));\n      }\n    }\n\n    // Check build\n    console.log(chalk.gray('Checking build...'));\n    try {\n      this.execSilent('npm run build');\n      console.log(chalk.green('✓ Build successful'));\n    } catch (error) {\n      results.errors.push('Build failed');\n      results.passed = false;\n      console.log(chalk.red('✗ Build failed'));\n    }\n\n    // Check for merge conflicts with base branch\n    try {\n      this.execSilent(`git fetch origin ${this.config.baseBranch}`);\n      const conflicts = this.execSilent(\n        `git merge-tree \\`git merge-base HEAD origin/${this.config.baseBranch}\\` HEAD origin/${this.config.baseBranch}`\n      );\n\n      if (conflicts.includes('<<<<<<<')) {\n        results.warnings.push('Potential merge conflicts with base branch');\n      }\n    } catch (error) {\n      results.warnings.push('Could not check for merge conflicts');\n    }\n\n    // Display results\n    console.log('');\n    if (results.errors.length > 0) {\n      console.log(chalk.red('\\n❌ Pre-push checks failed:\\n'));\n      results.errors.forEach(error => {\n        console.log(chalk.red(`  ✗ ${error}`));\n      });\n    }\n\n    if (results.warnings.length > 0) {\n      console.log(chalk.yellow('\\n⚠️  Warnings:\\n'));\n      results.warnings.forEach(warning => {\n        console.log(chalk.yellow(`  ! ${warning}`));\n      });\n    }\n\n    if (results.passed) {\n      console.log(chalk.green('\\n✓ All checks passed!\\n'));\n    }\n\n    return results.passed;\n  }\n\n  async push(): Promise<void> {\n    console.log(chalk.blue('\\n🚀 Pushing changes...\\n'));\n\n    // Run pre-push checks\n    const checksPass = await this.prePushCheck();\n\n    if (!checksPass) {\n      const { forcePush } = await prompts({\n        type: 'confirm',\n        name: 'forcePush',\n        message: 'Checks failed. Push anyway?',\n        initial: false\n      });\n\n      if (!forcePush) {\n        console.log(chalk.yellow('\\nPush cancelled\\n'));\n        return;\n      }\n    }\n\n    // Get current branch\n    const branch = this.execSilent('git rev-parse --abbrev-ref HEAD').trim();\n\n    // Push\n    try {\n      this.exec(`git push -u origin ${branch}`);\n      console.log(chalk.green(`\\n✓ Pushed to origin/${branch}\\n`));\n\n      // Generate PR URL\n      const remoteUrl = this.execSilent('git config --get remote.origin.url').trim();\n      if (remoteUrl.includes('github.com')) {\n        const repoPath = remoteUrl\n          .replace(/^.*github\\.com[:\\/]/, '')\n          .replace(/\\.git$/, '');\n        const prUrl = `https://github.com/${repoPath}/compare/${this.config.baseBranch}...${branch}?expand=1`;\n        console.log(chalk.blue(`Create PR: ${prUrl}\\n`));\n      }\n    } catch (error) {\n      console.log(chalk.red('\\n✗ Push failed\\n'));\n      throw error;\n    }\n  }\n\n  async deploymentChecklist(): Promise<void> {\n    console.log(chalk.blue('\\n📋 Deployment Checklist\\n'));\n\n    const checklist = [\n      'All tests passing',\n      'Linting checks pass',\n      'Build successful',\n      'No merge conflicts',\n      'Database migrations ready',\n      'Environment variables configured',\n      'Documentation updated',\n      'Change log updated',\n      'Version bumped (if needed)',\n      'Backup plan in place'\n    ];\n\n    const responses = await prompts(\n      checklist.map((item, i) => ({\n        type: 'confirm',\n        name: `check${i}`,\n        message: item,\n        initial: false\n      }))\n    );\n\n    const allChecked = Object.values(responses).every(v => v === true);\n\n    if (allChecked) {\n      console.log(chalk.green('\\n✓ All deployment checks completed!\\n'));\n    } else {\n      console.log(chalk.yellow('\\n⚠️  Some checks incomplete\\n'));\n    }\n  }\n\n  async run(): Promise<void> {\n    const { action } = await prompts({\n      type: 'select',\n      name: 'action',\n      message: 'What would you like to do?',\n      choices: [\n        { title: 'Create branch', value: 'branch' },\n        { title: 'Create commit', value: 'commit' },\n        { title: 'Run pre-push checks', value: 'check' },\n        { title: 'Push changes', value: 'push' },\n        { title: 'Deployment checklist', value: 'deploy' }\n      ]\n    });\n\n    switch (action) {\n      case 'branch':\n        await this.createBranch();\n        break;\n      case 'commit':\n        await this.createCommit();\n        break;\n      case 'check':\n        await this.prePushCheck();\n        break;\n      case 'push':\n        await this.push();\n        break;\n      case 'deploy':\n        await this.deploymentChecklist();\n        break;\n    }\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const automation = new WorkflowAutomation();\n  automation.run().catch(error => {\n    console.error(chalk.red('Error:', error.message));\n    process.exit(1);\n  });\n}\n\nexport { WorkflowAutomation };",
    "hints": [
      "Use prompts library for interactive CLI inputs",
      "Use execSync with { stdio: \"pipe\" } for silent execution",
      "Run validation checks in sequence and collect all errors",
      "Use chalk for colored console output to improve UX"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex01",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Debounce User Input",
    "difficulty": 1,
    "description": "Create a debounce function that delays the execution of a callback until after a specified wait time has elapsed since the last invocation. This is commonly used for search inputs to reduce API calls.",
    "starterCode": "function debounce(func: Function, wait: number): Function {\n  // TODO: Implement debounce logic\n  // Return a function that delays calling func\n}\n\n// Example usage:\nconst search = debounce((query: string) => {\n  console.log('Searching for:', query);\n}, 300);",
    "solution": "function debounce(func: Function, wait: number): Function {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function(this: any, ...args: any[]) {\n    const context = this;\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(() => {\n      func.apply(context, args);\n    }, wait);\n  };\n}\n\n// Example usage:\nconst search = debounce((query: string) => {\n  console.log('Searching for:', query);\n}, 300);",
    "hints": [
      "Use a timeout variable to track the delayed execution",
      "Clear the previous timeout before setting a new one",
      "Use setTimeout to delay the function execution",
      "Preserve the context (this) and arguments when calling the function"
    ],
    "testCases": [
      {
        "input": "Multiple rapid calls should execute only once",
        "expected": "Function executes only after wait period",
        "passed": false
      },
      {
        "input": "Debounced function with 100ms wait",
        "expected": "Executes after 100ms of inactivity",
        "passed": false
      },
      {
        "input": "Context and arguments preserved",
        "expected": "Original function receives correct this and args",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex02",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Basic Input Validation",
    "difficulty": 1,
    "description": "Create a simple input validator that checks if a user registration form has valid data. Validate email format, password length, and username requirements.",
    "starterCode": "interface UserInput {\n  username: string;\n  email: string;\n  password: string;\n}\n\ninterface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nfunction validateUserInput(input: UserInput): ValidationResult {\n  // TODO: Implement validation logic\n  // Username: 3-20 characters, alphanumeric\n  // Email: valid email format\n  // Password: minimum 8 characters\n}",
    "solution": "interface UserInput {\n  username: string;\n  email: string;\n  password: string;\n}\n\ninterface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nfunction validateUserInput(input: UserInput): ValidationResult {\n  const errors: string[] = [];\n\n  // Validate username\n  if (input.username.length < 3 || input.username.length > 20) {\n    errors.push('Username must be 3-20 characters');\n  }\n  if (!/^[a-zA-Z0-9]+$/.test(input.username)) {\n    errors.push('Username must be alphanumeric');\n  }\n\n  // Validate email\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(input.email)) {\n    errors.push('Invalid email format');\n  }\n\n  // Validate password\n  if (input.password.length < 8) {\n    errors.push('Password must be at least 8 characters');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}",
    "hints": [
      "Create an errors array to collect validation messages",
      "Use regular expressions to validate email format",
      "Check string length for username and password constraints",
      "Return both validity status and error messages"
    ],
    "testCases": [
      {
        "input": "{ username: \"ab\", email: \"test@test.com\", password: \"password123\" }",
        "expected": "{ isValid: false, errors: [\"Username must be 3-20 characters\"] }",
        "passed": false
      },
      {
        "input": "{ username: \"john\", email: \"invalid-email\", password: \"password123\" }",
        "expected": "{ isValid: false, errors: [\"Invalid email format\"] }",
        "passed": false
      },
      {
        "input": "{ username: \"john\", email: \"john@example.com\", password: \"pass\" }",
        "expected": "{ isValid: false, errors: [\"Password must be at least 8 characters\"] }",
        "passed": false
      },
      {
        "input": "{ username: \"john\", email: \"john@example.com\", password: \"password123\" }",
        "expected": "{ isValid: true, errors: [] }",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex03",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "ARIA Label Generator",
    "difficulty": 1,
    "description": "Create a function that generates appropriate ARIA attributes for common UI elements to improve accessibility. Handle buttons, inputs, and navigation elements.",
    "starterCode": "type ElementType = 'button' | 'input' | 'nav';\n\ninterface AriaAttributes {\n  role?: string;\n  'aria-label'?: string;\n  'aria-describedby'?: string;\n}\n\nfunction generateAriaAttributes(\n  type: ElementType,\n  label: string,\n  description?: string\n): AriaAttributes {\n  // TODO: Generate appropriate ARIA attributes\n}",
    "solution": "type ElementType = 'button' | 'input' | 'nav';\n\ninterface AriaAttributes {\n  role?: string;\n  'aria-label'?: string;\n  'aria-describedby'?: string;\n}\n\nfunction generateAriaAttributes(\n  type: ElementType,\n  label: string,\n  description?: string\n): AriaAttributes {\n  const attributes: AriaAttributes = {\n    'aria-label': label\n  };\n\n  if (type === 'button') {\n    attributes.role = 'button';\n  } else if (type === 'input') {\n    attributes.role = 'textbox';\n  } else if (type === 'nav') {\n    attributes.role = 'navigation';\n  }\n\n  if (description) {\n    attributes['aria-describedby'] = `${type}-description`;\n  }\n\n  return attributes;\n}",
    "hints": [
      "Set appropriate role based on element type",
      "Always include aria-label with the provided label",
      "Add aria-describedby only when description is provided",
      "Return an object with ARIA attribute key-value pairs"
    ],
    "testCases": [
      {
        "input": "type: \"button\", label: \"Submit Form\"",
        "expected": "{ role: \"button\", \"aria-label\": \"Submit Form\" }",
        "passed": false
      },
      {
        "input": "type: \"input\", label: \"Email Address\", description: \"Enter your email\"",
        "expected": "{ role: \"textbox\", \"aria-label\": \"Email Address\", \"aria-describedby\": \"input-description\" }",
        "passed": false
      },
      {
        "input": "type: \"nav\", label: \"Main Navigation\"",
        "expected": "{ role: \"navigation\", \"aria-label\": \"Main Navigation\" }",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex04",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "React.memo Optimization",
    "difficulty": 2,
    "description": "Implement a React component that uses React.memo to prevent unnecessary re-renders. Create a custom comparison function to handle complex props.",
    "starterCode": "import React from 'react';\n\ninterface UserCardProps {\n  user: {\n    id: number;\n    name: string;\n    email: string;\n    metadata: Record<string, any>;\n  };\n  onSelect: (id: number) => void;\n}\n\n// TODO: Implement UserCard with React.memo\n// Use custom comparison to check only id, name, and email\nconst UserCard: React.FC<UserCardProps> = ({ user, onSelect }) => {\n  return (\n    <div onClick={() => onSelect(user.id)}>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  );\n};\n\nexport default UserCard;",
    "solution": "import React from 'react';\n\ninterface UserCardProps {\n  user: {\n    id: number;\n    name: string;\n    email: string;\n    metadata: Record<string, any>;\n  };\n  onSelect: (id: number) => void;\n}\n\nconst UserCard: React.FC<UserCardProps> = ({ user, onSelect }) => {\n  console.log('Rendering UserCard:', user.id);\n\n  return (\n    <div onClick={() => onSelect(user.id)}>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  );\n};\n\n// Custom comparison function\nfunction arePropsEqual(\n  prevProps: UserCardProps,\n  nextProps: UserCardProps\n): boolean {\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.user.email === nextProps.user.email &&\n    prevProps.onSelect === nextProps.onSelect\n  );\n}\n\nexport default React.memo(UserCard, arePropsEqual);",
    "hints": [
      "Use React.memo() to wrap the component",
      "Create a custom comparison function as the second argument",
      "Compare only the relevant props (id, name, email)",
      "Return true if props are equal (skip re-render), false otherwise",
      "Don't forget to compare the onSelect callback"
    ],
    "testCases": [
      {
        "input": "Props with same id, name, email but different metadata",
        "expected": "Component does not re-render",
        "passed": false
      },
      {
        "input": "Props with different name",
        "expected": "Component re-renders",
        "passed": false
      },
      {
        "input": "Props with different onSelect callback",
        "expected": "Component re-renders",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex05",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Keyboard Navigation Handler",
    "difficulty": 2,
    "description": "Create a keyboard navigation handler for a dropdown menu. Support arrow keys for navigation, Enter for selection, and Escape to close.",
    "starterCode": "interface MenuItem {\n  id: string;\n  label: string;\n  action: () => void;\n}\n\nclass KeyboardNavigator {\n  private items: MenuItem[];\n  private currentIndex: number = -1;\n\n  constructor(items: MenuItem[]) {\n    this.items = items;\n  }\n\n  handleKeyDown(event: KeyboardEvent): void {\n    // TODO: Implement keyboard navigation\n    // ArrowDown: move to next item\n    // ArrowUp: move to previous item\n    // Enter: select current item\n    // Escape: reset selection\n  }\n\n  getCurrentIndex(): number {\n    return this.currentIndex;\n  }\n}",
    "solution": "interface MenuItem {\n  id: string;\n  label: string;\n  action: () => void;\n}\n\nclass KeyboardNavigator {\n  private items: MenuItem[];\n  private currentIndex: number = -1;\n\n  constructor(items: MenuItem[]) {\n    this.items = items;\n  }\n\n  handleKeyDown(event: KeyboardEvent): void {\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        this.currentIndex = Math.min(\n          this.currentIndex + 1,\n          this.items.length - 1\n        );\n        break;\n\n      case 'ArrowUp':\n        event.preventDefault();\n        this.currentIndex = Math.max(this.currentIndex - 1, 0);\n        break;\n\n      case 'Enter':\n        event.preventDefault();\n        if (this.currentIndex >= 0 && this.currentIndex < this.items.length) {\n          this.items[this.currentIndex].action();\n        }\n        break;\n\n      case 'Escape':\n        event.preventDefault();\n        this.currentIndex = -1;\n        break;\n    }\n  }\n\n  getCurrentIndex(): number {\n    return this.currentIndex;\n  }\n}",
    "hints": [
      "Use a switch statement to handle different key events",
      "Prevent default behavior for navigation keys",
      "Use Math.min and Math.max to keep index within bounds",
      "Execute the action of the currently selected item on Enter",
      "Reset currentIndex to -1 on Escape"
    ],
    "testCases": [
      {
        "input": "ArrowDown from initial state",
        "expected": "currentIndex becomes 0",
        "passed": false
      },
      {
        "input": "ArrowUp when at index 0",
        "expected": "currentIndex stays at 0",
        "passed": false
      },
      {
        "input": "ArrowDown at last item",
        "expected": "currentIndex stays at last index",
        "passed": false
      },
      {
        "input": "Enter at index 1",
        "expected": "items[1].action() is called",
        "passed": false
      },
      {
        "input": "Escape key",
        "expected": "currentIndex becomes -1",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex06",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Simple Translation System",
    "difficulty": 2,
    "description": "Create a basic internationalization (i18n) system that supports multiple languages and nested translation keys.",
    "starterCode": "type Translations = {\n  [key: string]: string | Translations;\n};\n\nclass I18n {\n  private translations: Record<string, Translations>;\n  private currentLocale: string;\n\n  constructor(translations: Record<string, Translations>, defaultLocale: string) {\n    this.translations = translations;\n    this.currentLocale = defaultLocale;\n  }\n\n  setLocale(locale: string): void {\n    // TODO: Set the current locale\n  }\n\n  t(key: string): string {\n    // TODO: Get translation for key (supports dot notation like \"user.welcome\")\n    // Return the key itself if translation not found\n  }\n}\n\n// Example usage:\nconst i18n = new I18n({\n  en: {\n    user: {\n      welcome: 'Welcome',\n      goodbye: 'Goodbye'\n    }\n  },\n  es: {\n    user: {\n      welcome: 'Bienvenido',\n      goodbye: 'Adiós'\n    }\n  }\n}, 'en');",
    "solution": "type Translations = {\n  [key: string]: string | Translations;\n};\n\nclass I18n {\n  private translations: Record<string, Translations>;\n  private currentLocale: string;\n\n  constructor(translations: Record<string, Translations>, defaultLocale: string) {\n    this.translations = translations;\n    this.currentLocale = defaultLocale;\n  }\n\n  setLocale(locale: string): void {\n    if (this.translations[locale]) {\n      this.currentLocale = locale;\n    }\n  }\n\n  t(key: string): string {\n    const keys = key.split('.');\n    let value: any = this.translations[this.currentLocale];\n\n    for (const k of keys) {\n      if (value && typeof value === 'object' && k in value) {\n        value = value[k];\n      } else {\n        return key; // Return key if translation not found\n      }\n    }\n\n    return typeof value === 'string' ? value : key;\n  }\n}\n\n// Example usage:\nconst i18n = new I18n({\n  en: {\n    user: {\n      welcome: 'Welcome',\n      goodbye: 'Goodbye'\n    }\n  },\n  es: {\n    user: {\n      welcome: 'Bienvenido',\n      goodbye: 'Adiós'\n    }\n  }\n}, 'en');",
    "hints": [
      "Split the key by dots to handle nested paths",
      "Traverse the translations object using each key segment",
      "Return the key itself if translation is not found",
      "Check if the locale exists before setting it",
      "Ensure the final value is a string before returning"
    ],
    "testCases": [
      {
        "input": "i18n.t(\"user.welcome\") with locale \"en\"",
        "expected": "\"Welcome\"",
        "passed": false
      },
      {
        "input": "i18n.setLocale(\"es\"); i18n.t(\"user.goodbye\")",
        "expected": "\"Adiós\"",
        "passed": false
      },
      {
        "input": "i18n.t(\"user.nonexistent\")",
        "expected": "\"user.nonexistent\"",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex07",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "useMemo and useCallback Optimization",
    "difficulty": 3,
    "description": "Optimize a React component that performs expensive calculations and passes callbacks to child components. Use useMemo for calculations and useCallback for event handlers.",
    "starterCode": "import React, { useState, useMemo, useCallback } from 'react';\n\ninterface DataItem {\n  id: number;\n  value: number;\n  category: string;\n}\n\ninterface Props {\n  data: DataItem[];\n}\n\n// Expensive calculation (simulated)\nfunction calculateStatistics(data: DataItem[]) {\n  console.log('Calculating statistics...');\n  return {\n    total: data.reduce((sum, item) => sum + item.value, 0),\n    average: data.reduce((sum, item) => sum + item.value, 0) / data.length,\n    max: Math.max(...data.map(item => item.value)),\n    min: Math.min(...data.map(item => item.value))\n  };\n}\n\nconst DataDashboard: React.FC<Props> = ({ data }) => {\n  const [filter, setFilter] = useState('');\n  const [selectedId, setSelectedId] = useState<number | null>(null);\n\n  // TODO: Memoize filtered data\n  const filteredData = data.filter(item =>\n    item.category.toLowerCase().includes(filter.toLowerCase())\n  );\n\n  // TODO: Memoize statistics calculation\n  const stats = calculateStatistics(filteredData);\n\n  // TODO: Memoize callback\n  const handleSelect = (id: number) => {\n    setSelectedId(id);\n    console.log('Selected:', id);\n  };\n\n  return (\n    <div>\n      <input\n        value={filter}\n        onChange={(e) => setFilter(e.target.value)}\n        placeholder=\"Filter by category\"\n      />\n      <div>Total: {stats.total}</div>\n      <div>Average: {stats.average}</div>\n      {/* Child components would use handleSelect */}\n    </div>\n  );\n};",
    "solution": "import React, { useState, useMemo, useCallback } from 'react';\n\ninterface DataItem {\n  id: number;\n  value: number;\n  category: string;\n}\n\ninterface Props {\n  data: DataItem[];\n}\n\n// Expensive calculation (simulated)\nfunction calculateStatistics(data: DataItem[]) {\n  console.log('Calculating statistics...');\n  return {\n    total: data.reduce((sum, item) => sum + item.value, 0),\n    average: data.reduce((sum, item) => sum + item.value, 0) / data.length,\n    max: Math.max(...data.map(item => item.value)),\n    min: Math.min(...data.map(item => item.value))\n  };\n}\n\nconst DataDashboard: React.FC<Props> = ({ data }) => {\n  const [filter, setFilter] = useState('');\n  const [selectedId, setSelectedId] = useState<number | null>(null);\n\n  // Memoize filtered data - only recalculate when data or filter changes\n  const filteredData = useMemo(() => {\n    console.log('Filtering data...');\n    return data.filter(item =>\n      item.category.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [data, filter]);\n\n  // Memoize statistics - only recalculate when filtered data changes\n  const stats = useMemo(() => {\n    return calculateStatistics(filteredData);\n  }, [filteredData]);\n\n  // Memoize callback - prevent child re-renders\n  const handleSelect = useCallback((id: number) => {\n    setSelectedId(id);\n    console.log('Selected:', id);\n  }, []); // No dependencies as it only uses setSelectedId (stable)\n\n  return (\n    <div>\n      <input\n        value={filter}\n        onChange={(e) => setFilter(e.target.value)}\n        placeholder=\"Filter by category\"\n      />\n      <div>Total: {stats.total}</div>\n      <div>Average: {stats.average}</div>\n      {/* Child components would use handleSelect */}\n    </div>\n  );\n};",
    "hints": [
      "Use useMemo for the filtered data with [data, filter] dependencies",
      "Use useMemo for statistics with [filteredData] dependency",
      "Use useCallback for handleSelect to maintain referential equality",
      "setSelectedId is stable, so handleSelect needs no dependencies",
      "Add console.logs to verify optimizations are working"
    ],
    "testCases": [
      {
        "input": "Typing in filter input",
        "expected": "Filtering runs, stats recalculated, handleSelect reference unchanged",
        "passed": false
      },
      {
        "input": "selectedId state change",
        "expected": "No filtering or stats recalculation",
        "passed": false
      },
      {
        "input": "data prop changes",
        "expected": "Filtering and stats recalculated",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex08",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Error Boundary Implementation",
    "difficulty": 3,
    "description": "Implement a React Error Boundary component that catches errors in child components, logs them, and displays a fallback UI. Include error recovery functionality.",
    "starterCode": "import React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nclass ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null\n    };\n  }\n\n  // TODO: Implement static getDerivedStateFromError\n\n  // TODO: Implement componentDidCatch\n\n  // TODO: Implement reset method\n\n  render() {\n    // TODO: Render fallback UI or children\n  }\n}\n\nexport default ErrorBoundary;",
    "solution": "import React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nclass ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null\n    };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    // Update state to trigger fallback UI\n    return {\n      hasError: true,\n      error\n    };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    // Log error to console or error reporting service\n    console.error('Error caught by boundary:', error);\n    console.error('Error info:', errorInfo.componentStack);\n\n    // Call optional error handler\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({\n      hasError: false,\n      error: null\n    });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      // Render custom fallback or default error UI\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div style={{ padding: '20px', border: '2px solid red' }}>\n          <h2>Something went wrong</h2>\n          <p>{this.state.error?.message}</p>\n          <button onClick={this.resetError}>Try Again</button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;",
    "hints": [
      "getDerivedStateFromError should return the new state object",
      "componentDidCatch is for side effects like logging",
      "Store both hasError flag and error object in state",
      "Provide a reset method to clear the error state",
      "Check for custom fallback prop before rendering default UI"
    ],
    "testCases": [
      {
        "input": "Child component throws error",
        "expected": "Fallback UI is displayed",
        "passed": false
      },
      {
        "input": "Custom fallback provided",
        "expected": "Custom fallback is rendered instead of default",
        "passed": false
      },
      {
        "input": "Reset button clicked",
        "expected": "Error cleared, children re-rendered",
        "passed": false
      },
      {
        "input": "onError callback provided",
        "expected": "Callback is called with error and errorInfo",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex09",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Database Query Optimizer",
    "difficulty": 3,
    "description": "Analyze SQL-like query objects and suggest optimizations such as adding indexes, avoiding SELECT *, and fixing N+1 query problems.",
    "starterCode": "interface Query {\n  table: string;\n  select: string[];\n  where?: Record<string, any>;\n  joins?: Array<{\n    table: string;\n    on: string;\n  }>;\n}\n\ninterface Optimization {\n  type: 'index' | 'select' | 'n+1';\n  message: string;\n  suggestion: string;\n}\n\nfunction analyzeQuery(query: Query, tableColumns: Record<string, string[]>): Optimization[] {\n  // TODO: Analyze the query and return optimization suggestions\n  // 1. Check if SELECT * is used\n  // 2. Check if WHERE clauses would benefit from indexes\n  // 3. Suggest using JOINs instead of multiple queries\n}",
    "solution": "interface Query {\n  table: string;\n  select: string[];\n  where?: Record<string, any>;\n  joins?: Array<{\n    table: string;\n    on: string;\n  }>;\n}\n\ninterface Optimization {\n  type: 'index' | 'select' | 'n+1';\n  message: string;\n  suggestion: string;\n}\n\nfunction analyzeQuery(query: Query, tableColumns: Record<string, string[]>): Optimization[] {\n  const optimizations: Optimization[] = [];\n\n  // Check for SELECT *\n  if (query.select.includes('*')) {\n    optimizations.push({\n      type: 'select',\n      message: 'Using SELECT * returns unnecessary columns',\n      suggestion: `Specify only needed columns: [${tableColumns[query.table].slice(0, 3).join(', ')}...]`\n    });\n  }\n\n  // Check WHERE clauses for potential indexes\n  if (query.where) {\n    const whereColumns = Object.keys(query.where);\n    whereColumns.forEach(column => {\n      optimizations.push({\n        type: 'index',\n        message: `WHERE clause on '${column}' may benefit from an index`,\n        suggestion: `CREATE INDEX idx_${query.table}_${column} ON ${query.table}(${column})`\n      });\n    });\n  }\n\n  // Check for potential N+1 problems (no joins when filtering on foreign keys)\n  if (query.where && !query.joins) {\n    const potentialForeignKeys = Object.keys(query.where).filter(\n      col => col.endsWith('_id') || col.endsWith('Id')\n    );\n\n    if (potentialForeignKeys.length > 0) {\n      potentialForeignKeys.forEach(fk => {\n        const relatedTable = fk.replace(/_id$|Id$/, '');\n        optimizations.push({\n          type: 'n+1',\n          message: `Filtering on '${fk}' without JOIN may cause N+1 queries`,\n          suggestion: `Add JOIN with ${relatedTable} table to fetch related data in single query`\n        });\n      });\n    }\n  }\n\n  return optimizations;\n}",
    "hints": [
      "Check if the select array includes \"*\"",
      "Iterate through WHERE clause keys to suggest indexes",
      "Look for foreign key patterns (_id or Id suffix)",
      "Suggest JOINs when filtering on foreign keys without existing joins",
      "Return an array of optimization objects with type, message, and suggestion"
    ],
    "testCases": [
      {
        "input": "{ table: \"users\", select: [\"*\"] }",
        "expected": "Optimization suggesting specific columns instead of *",
        "passed": false
      },
      {
        "input": "{ table: \"orders\", select: [\"id\", \"total\"], where: { user_id: 123 } }",
        "expected": "Suggestions for index on user_id and potential N+1 problem",
        "passed": false
      },
      {
        "input": "{ table: \"posts\", select: [\"id\"], where: { author_id: 5 }, joins: [{ table: \"authors\", on: \"id\" }] }",
        "expected": "No N+1 warning (JOIN already present), but index suggestion",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex10",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Color Contrast Checker",
    "difficulty": 3,
    "description": "Create a WCAG 2.1 compliant color contrast checker that validates if text is readable against a background color. Calculate relative luminance and contrast ratio.",
    "starterCode": "interface ColorRGB {\n  r: number; // 0-255\n  g: number; // 0-255\n  b: number; // 0-255\n}\n\ninterface ContrastResult {\n  ratio: number;\n  passAANormal: boolean;    // 4.5:1\n  passAALarge: boolean;     // 3:1\n  passAAANormal: boolean;   // 7:1\n  passAAALarge: boolean;    // 4.5:1\n}\n\nfunction hexToRgb(hex: string): ColorRGB {\n  // TODO: Convert hex color to RGB\n}\n\nfunction calculateLuminance(color: ColorRGB): number {\n  // TODO: Calculate relative luminance (WCAG formula)\n  // For each channel: if <= 0.03928, divide by 12.92, else ((value + 0.055) / 1.055) ^ 2.4\n  // Luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B\n}\n\nfunction checkContrast(foreground: string, background: string): ContrastResult {\n  // TODO: Calculate contrast ratio and check WCAG compliance\n  // Contrast ratio = (lighter + 0.05) / (darker + 0.05)\n}",
    "solution": "interface ColorRGB {\n  r: number; // 0-255\n  g: number; // 0-255\n  b: number; // 0-255\n}\n\ninterface ContrastResult {\n  ratio: number;\n  passAANormal: boolean;    // 4.5:1\n  passAALarge: boolean;     // 3:1\n  passAAANormal: boolean;   // 7:1\n  passAAALarge: boolean;    // 4.5:1\n}\n\nfunction hexToRgb(hex: string): ColorRGB {\n  // Remove # if present\n  const cleanHex = hex.replace('#', '');\n\n  return {\n    r: parseInt(cleanHex.substring(0, 2), 16),\n    g: parseInt(cleanHex.substring(2, 4), 16),\n    b: parseInt(cleanHex.substring(4, 6), 16)\n  };\n}\n\nfunction calculateLuminance(color: ColorRGB): number {\n  // Normalize RGB values to 0-1 range\n  const r = color.r / 255;\n  const g = color.g / 255;\n  const b = color.b / 255;\n\n  // Apply gamma correction\n  const rLinear = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);\n  const gLinear = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);\n  const bLinear = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);\n\n  // Calculate luminance using WCAG formula\n  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;\n}\n\nfunction checkContrast(foreground: string, background: string): ContrastResult {\n  const fgRgb = hexToRgb(foreground);\n  const bgRgb = hexToRgb(background);\n\n  const fgLuminance = calculateLuminance(fgRgb);\n  const bgLuminance = calculateLuminance(bgRgb);\n\n  // Calculate contrast ratio\n  const lighter = Math.max(fgLuminance, bgLuminance);\n  const darker = Math.min(fgLuminance, bgLuminance);\n  const ratio = (lighter + 0.05) / (darker + 0.05);\n\n  return {\n    ratio: Math.round(ratio * 100) / 100,\n    passAANormal: ratio >= 4.5,\n    passAALarge: ratio >= 3,\n    passAAANormal: ratio >= 7,\n    passAAALarge: ratio >= 4.5\n  };\n}",
    "hints": [
      "Remove the # from hex strings before parsing",
      "Parse hex in pairs: first 2 chars for R, next 2 for G, last 2 for B",
      "Normalize RGB values by dividing by 255",
      "Apply gamma correction with the WCAG formula",
      "Contrast ratio uses the lighter and darker luminance values",
      "Round the final ratio to 2 decimal places"
    ],
    "testCases": [
      {
        "input": "foreground: \"#000000\", background: \"#FFFFFF\"",
        "expected": "ratio: 21, all WCAG levels pass",
        "passed": false
      },
      {
        "input": "foreground: \"#777777\", background: \"#FFFFFF\"",
        "expected": "ratio: ~4.48, only AA Large passes",
        "passed": false
      },
      {
        "input": "foreground: \"#595959\", background: \"#FFFFFF\"",
        "expected": "ratio: ~7.0, AA passes, AAA Normal passes",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex11",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Input Validation with Zod",
    "difficulty": 4,
    "description": "Create a comprehensive validation system using Zod schemas for a complex form with nested objects, arrays, and custom validation rules.",
    "starterCode": "import { z } from 'zod';\n\n// TODO: Create Zod schemas for the following requirements:\n// 1. User profile with email, age (18-100), username (3-20 chars)\n// 2. Nested address object (street, city, zipCode, country)\n// 3. Array of skills (min 1, max 10, each 2-50 chars)\n// 4. Phone number (optional, format: +1-XXX-XXX-XXXX or similar)\n// 5. Password with custom validation (min 8 chars, 1 uppercase, 1 number, 1 special char)\n\nconst userProfileSchema = z.object({\n  // TODO: Define schema\n});\n\ntype UserProfile = z.infer<typeof userProfileSchema>;\n\nfunction validateUserProfile(data: unknown): {\n  success: boolean;\n  data?: UserProfile;\n  errors?: string[]\n} {\n  // TODO: Validate data and return formatted result\n}",
    "solution": "import { z } from 'zod';\n\n// Custom password validator\nconst passwordSchema = z.string()\n  .min(8, 'Password must be at least 8 characters')\n  .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\n  .regex(/[0-9]/, 'Password must contain at least one number')\n  .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character');\n\n// Phone number validator (optional)\nconst phoneSchema = z.string()\n  .regex(/^\\+?[1-9]\\d{0,3}-?\\d{3}-?\\d{3}-?\\d{4}$/, 'Invalid phone format')\n  .optional();\n\n// Address schema\nconst addressSchema = z.object({\n  street: z.string().min(1, 'Street is required'),\n  city: z.string().min(1, 'City is required'),\n  zipCode: z.string().regex(/^\\d{5}(-\\d{4})?$/, 'Invalid zip code'),\n  country: z.string().min(2, 'Country code must be at least 2 characters')\n});\n\n// Skills array schema\nconst skillsSchema = z.array(\n  z.string().min(2, 'Skill must be at least 2 characters')\n    .max(50, 'Skill must not exceed 50 characters')\n).min(1, 'At least one skill is required')\n  .max(10, 'Maximum 10 skills allowed');\n\n// Main user profile schema\nconst userProfileSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  age: z.number()\n    .int('Age must be an integer')\n    .min(18, 'Must be at least 18 years old')\n    .max(100, 'Age must not exceed 100'),\n  username: z.string()\n    .min(3, 'Username must be at least 3 characters')\n    .max(20, 'Username must not exceed 20 characters')\n    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),\n  address: addressSchema,\n  skills: skillsSchema,\n  phone: phoneSchema,\n  password: passwordSchema\n});\n\ntype UserProfile = z.infer<typeof userProfileSchema>;\n\nfunction validateUserProfile(data: unknown): {\n  success: boolean;\n  data?: UserProfile;\n  errors?: string[]\n} {\n  try {\n    const validData = userProfileSchema.parse(data);\n    return {\n      success: true,\n      data: validData\n    };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        errors: error.errors.map(err => `${err.path.join('.')}: ${err.message}`)\n      };\n    }\n    return {\n      success: false,\n      errors: ['Unknown validation error']\n    };\n  }\n}",
    "hints": [
      "Use z.string().regex() for pattern matching (password, phone, zip)",
      "Chain validation methods like .min(), .max(), .email()",
      "Use z.array() with min/max for the skills array",
      "Nest schemas using z.object() for the address",
      "Use .optional() for the phone field",
      "Catch ZodError and format errors with path and message",
      "Use z.infer to extract the TypeScript type from schema"
    ],
    "testCases": [
      {
        "input": "Valid complete user profile",
        "expected": "success: true with parsed data",
        "passed": false
      },
      {
        "input": "Invalid email format",
        "expected": "success: false with email error message",
        "passed": false
      },
      {
        "input": "Age = 17 (under minimum)",
        "expected": "success: false with age error",
        "passed": false
      },
      {
        "input": "Password without special character",
        "expected": "success: false with password error",
        "passed": false
      },
      {
        "input": "Empty skills array",
        "expected": "success: false with skills minimum error",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex12",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Code Splitting Implementation",
    "difficulty": 4,
    "description": "Implement a dynamic module loader with code splitting that loads modules on-demand, handles loading states, errors, and caching.",
    "starterCode": "interface Module {\n  default: any;\n  [key: string]: any;\n}\n\ninterface LoaderState<T> {\n  loading: boolean;\n  data: T | null;\n  error: Error | null;\n}\n\nclass DynamicModuleLoader {\n  private cache: Map<string, Promise<Module>>;\n  private loadedModules: Map<string, Module>;\n\n  constructor() {\n    this.cache = new Map();\n    this.loadedModules = new Map();\n  }\n\n  async loadModule<T = any>(modulePath: string): Promise<LoaderState<T>> {\n    // TODO: Implement dynamic module loading\n    // 1. Check if module is already loaded (cache)\n    // 2. If loading, return existing promise\n    // 3. Otherwise, create new import() promise\n    // 4. Handle success and errors\n    // 5. Store in cache\n  }\n\n  preload(modulePaths: string[]): void {\n    // TODO: Preload modules without waiting\n  }\n\n  clearCache(modulePath?: string): void {\n    // TODO: Clear cache for specific module or all modules\n  }\n}",
    "solution": "interface Module {\n  default: any;\n  [key: string]: any;\n}\n\ninterface LoaderState<T> {\n  loading: boolean;\n  data: T | null;\n  error: Error | null;\n}\n\nclass DynamicModuleLoader {\n  private cache: Map<string, Promise<Module>>;\n  private loadedModules: Map<string, Module>;\n\n  constructor() {\n    this.cache = new Map();\n    this.loadedModules = new Map();\n  }\n\n  async loadModule<T = any>(modulePath: string): Promise<LoaderState<T>> {\n    // Return cached module if already loaded\n    if (this.loadedModules.has(modulePath)) {\n      return {\n        loading: false,\n        data: this.loadedModules.get(modulePath)!.default as T,\n        error: null\n      };\n    }\n\n    // Return in-progress load if already loading\n    if (this.cache.has(modulePath)) {\n      try {\n        const module = await this.cache.get(modulePath)!;\n        return {\n          loading: false,\n          data: module.default as T,\n          error: null\n        };\n      } catch (error) {\n        return {\n          loading: false,\n          data: null,\n          error: error as Error\n        };\n      }\n    }\n\n    // Start new module load\n    const loadPromise = import(/* webpackChunkName: \"[request]\" */ modulePath);\n    this.cache.set(modulePath, loadPromise);\n\n    try {\n      const module = await loadPromise;\n      this.loadedModules.set(modulePath, module);\n      this.cache.delete(modulePath); // Remove from in-progress cache\n\n      return {\n        loading: false,\n        data: module.default as T,\n        error: null\n      };\n    } catch (error) {\n      this.cache.delete(modulePath); // Remove failed load\n\n      return {\n        loading: false,\n        data: null,\n        error: error as Error\n      };\n    }\n  }\n\n  preload(modulePaths: string[]): void {\n    modulePaths.forEach(path => {\n      if (!this.loadedModules.has(path) && !this.cache.has(path)) {\n        const loadPromise = import(/* webpackChunkName: \"[request]\" */ path);\n        this.cache.set(path, loadPromise);\n\n        loadPromise\n          .then(module => {\n            this.loadedModules.set(path, module);\n            this.cache.delete(path);\n          })\n          .catch(() => {\n            this.cache.delete(path);\n          });\n      }\n    });\n  }\n\n  clearCache(modulePath?: string): void {\n    if (modulePath) {\n      this.cache.delete(modulePath);\n      this.loadedModules.delete(modulePath);\n    } else {\n      this.cache.clear();\n      this.loadedModules.clear();\n    }\n  }\n}",
    "hints": [
      "Use two separate caches: one for in-progress loads, one for loaded modules",
      "Check loadedModules first for instant returns",
      "Check cache for in-progress loads to avoid duplicate requests",
      "Use dynamic import() with webpack magic comments for chunk names",
      "Remove from cache after successful load or error",
      "Preload should fire-and-forget without blocking",
      "Handle both specific and global cache clearing"
    ],
    "testCases": [
      {
        "input": "Load module for first time",
        "expected": "loading: false, data: module content, cached",
        "passed": false
      },
      {
        "input": "Load same module again",
        "expected": "Instant return from cache",
        "passed": false
      },
      {
        "input": "Concurrent loads of same module",
        "expected": "Only one network request made",
        "passed": false
      },
      {
        "input": "Preload array of modules",
        "expected": "All modules load in background",
        "passed": false
      },
      {
        "input": "clearCache with specific path",
        "expected": "Only that module removed from cache",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex13",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Defensive Programming with Type Guards",
    "difficulty": 4,
    "description": "Implement defensive programming patterns using TypeScript type guards, runtime validation, and error handling for external API data.",
    "starterCode": "// External API response (unknown shape)\ninterface ApiResponse {\n  data: unknown;\n  status: number;\n  message?: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user' | 'guest';\n  metadata?: {\n    lastLogin?: string;\n    preferences?: Record<string, any>;\n  };\n}\n\n// TODO: Implement type guards\nfunction isString(value: unknown): value is string {\n  // TODO\n}\n\nfunction isNumber(value: unknown): value is number {\n  // TODO\n}\n\nfunction isValidRole(value: unknown): value is 'admin' | 'user' | 'guest' {\n  // TODO\n}\n\nfunction isUser(value: unknown): value is User {\n  // TODO: Comprehensive validation\n}\n\n// TODO: Safe parser with detailed error messages\nfunction parseUserResponse(response: ApiResponse): User {\n  // TODO: Validate and parse safely, throw descriptive errors\n}",
    "solution": "// External API response (unknown shape)\ninterface ApiResponse {\n  data: unknown;\n  status: number;\n  message?: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user' | 'guest';\n  metadata?: {\n    lastLogin?: string;\n    preferences?: Record<string, any>;\n  };\n}\n\n// Type guards\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction isValidRole(value: unknown): value is 'admin' | 'user' | 'guest' {\n  return value === 'admin' || value === 'user' || value === 'guest';\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction isUser(value: unknown): value is User {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  // Check required fields\n  if (!isNumber(value.id) || !isString(value.name) ||\n      !isString(value.email) || !isValidRole(value.role)) {\n    return false;\n  }\n\n  // Validate email format\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(value.email)) {\n    return false;\n  }\n\n  // Check optional metadata\n  if (value.metadata !== undefined) {\n    if (!isObject(value.metadata)) {\n      return false;\n    }\n\n    if (value.metadata.lastLogin !== undefined &&\n        !isString(value.metadata.lastLogin)) {\n      return false;\n    }\n\n    if (value.metadata.preferences !== undefined &&\n        !isObject(value.metadata.preferences)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Safe parser with detailed error messages\nfunction parseUserResponse(response: ApiResponse): User {\n  // Check response status\n  if (response.status !== 200) {\n    throw new Error(\n      `API error: status ${response.status}${\n        response.message ? `, ${response.message}` : ''\n      }`\n    );\n  }\n\n  // Check data exists\n  if (!response.data) {\n    throw new Error('API response missing data field');\n  }\n\n  // Validate data structure\n  if (!isObject(response.data)) {\n    throw new Error(\n      `Expected data to be an object, got ${typeof response.data}`\n    );\n  }\n\n  const data = response.data;\n\n  // Validate required fields with specific errors\n  if (!isNumber(data.id)) {\n    throw new Error(\n      `Invalid id: expected number, got ${typeof data.id}`\n    );\n  }\n\n  if (!isString(data.name)) {\n    throw new Error(\n      `Invalid name: expected string, got ${typeof data.name}`\n    );\n  }\n\n  if (!isString(data.email)) {\n    throw new Error(\n      `Invalid email: expected string, got ${typeof data.email}`\n    );\n  }\n\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(data.email)) {\n    throw new Error(`Invalid email format: ${data.email}`);\n  }\n\n  if (!isValidRole(data.role)) {\n    throw new Error(\n      `Invalid role: expected 'admin', 'user', or 'guest', got ${data.role}`\n    );\n  }\n\n  // Use type guard for final validation\n  if (!isUser(data)) {\n    throw new Error('Data failed comprehensive user validation');\n  }\n\n  return data;\n}",
    "hints": [
      "Type guards use \"value is Type\" return type syntax",
      "Check typeof for primitives, but remember typeof null === \"object\"",
      "For objects, verify it's not null and not an array",
      "Validate optional fields only when they exist",
      "Throw specific errors for each validation failure",
      "Use type guards to narrow types progressively",
      "Final validation can use comprehensive isUser guard"
    ],
    "testCases": [
      {
        "input": "Valid user response with all fields",
        "expected": "Returns parsed User object",
        "passed": false
      },
      {
        "input": "Response with status 500",
        "expected": "Throws error with status code",
        "passed": false
      },
      {
        "input": "Invalid email format",
        "expected": "Throws \"Invalid email format\" error",
        "passed": false
      },
      {
        "input": "Invalid role value",
        "expected": "Throws error about expected roles",
        "passed": false
      },
      {
        "input": "Missing required field (name)",
        "expected": "Throws specific error about name field",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex14",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "N+1 Query Detection and Fix",
    "difficulty": 5,
    "description": "Build a system that detects N+1 query problems in ORM-like code and automatically suggests JOIN-based solutions. Analyze query patterns and generate optimized versions.",
    "starterCode": "interface Query {\n  type: 'select' | 'insert' | 'update' | 'delete';\n  table: string;\n  where?: Record<string, any>;\n  select?: string[];\n}\n\ninterface QueryLog {\n  queries: Query[];\n  executionOrder: number[];\n}\n\ninterface N1Problem {\n  initialQuery: Query;\n  repeatedQueries: Query[];\n  count: number;\n  foreignKey: string;\n  optimizedQuery: string;\n}\n\nclass QueryAnalyzer {\n  analyzeQueryLog(log: QueryLog): N1Problem[] {\n    // TODO: Detect N+1 patterns\n    // 1. Find initial query that returns multiple rows\n    // 2. Find subsequent queries in loop with WHERE on foreign key\n    // 3. Group by pattern\n    // 4. Generate optimized JOIN query\n  }\n\n  private generateOptimizedQuery(problem: N1Problem): string {\n    // TODO: Generate SQL with JOIN to eliminate N+1\n  }\n\n  private detectForeignKey(initialTable: string, repeatedQuery: Query): string | null {\n    // TODO: Identify foreign key relationship\n  }\n}",
    "solution": "interface Query {\n  type: 'select' | 'insert' | 'update' | 'delete';\n  table: string;\n  where?: Record<string, any>;\n  select?: string[];\n}\n\ninterface QueryLog {\n  queries: Query[];\n  executionOrder: number[];\n}\n\ninterface N1Problem {\n  initialQuery: Query;\n  repeatedQueries: Query[];\n  count: number;\n  foreignKey: string;\n  optimizedQuery: string;\n}\n\nclass QueryAnalyzer {\n  analyzeQueryLog(log: QueryLog): N1Problem[] {\n    const problems: N1Problem[] = [];\n    const queries = log.queries;\n\n    for (let i = 0; i < queries.length - 1; i++) {\n      const current = queries[i];\n\n      // Only analyze SELECT queries\n      if (current.type !== 'select') continue;\n\n      // Look for repeated pattern in next queries\n      const pattern = this.findRepeatedPattern(queries, i + 1);\n\n      if (pattern.queries.length >= 2) {\n        const foreignKey = this.detectForeignKey(current.table, pattern.queries[0]);\n\n        if (foreignKey) {\n          const problem: N1Problem = {\n            initialQuery: current,\n            repeatedQueries: pattern.queries,\n            count: pattern.queries.length,\n            foreignKey,\n            optimizedQuery: ''\n          };\n\n          problem.optimizedQuery = this.generateOptimizedQuery(problem);\n          problems.push(problem);\n\n          // Skip past analyzed queries\n          i += pattern.queries.length;\n        }\n      }\n    }\n\n    return problems;\n  }\n\n  private findRepeatedPattern(\n    queries: Query[],\n    startIndex: number\n  ): { queries: Query[] } {\n    const repeated: Query[] = [];\n\n    if (startIndex >= queries.length) {\n      return { queries: repeated };\n    }\n\n    const pattern = queries[startIndex];\n\n    // Find all queries matching the pattern\n    for (let i = startIndex; i < queries.length; i++) {\n      const q = queries[i];\n\n      // Check if query matches pattern (same table and similar WHERE structure)\n      if (q.type === pattern.type &&\n          q.table === pattern.table &&\n          q.where && pattern.where &&\n          this.hasSimilarWhereClause(q.where, pattern.where)) {\n        repeated.push(q);\n      } else if (repeated.length > 0) {\n        // Pattern broken\n        break;\n      }\n    }\n\n    return { queries: repeated };\n  }\n\n  private hasSimilarWhereClause(\n    where1: Record<string, any>,\n    where2: Record<string, any>\n  ): boolean {\n    const keys1 = Object.keys(where1);\n    const keys2 = Object.keys(where2);\n\n    // Same WHERE clause structure (same keys, different values)\n    return keys1.length === keys2.length &&\n           keys1.every(key => keys2.includes(key));\n  }\n\n  private detectForeignKey(initialTable: string, repeatedQuery: Query): string | null {\n    if (!repeatedQuery.where) return null;\n\n    const whereKeys = Object.keys(repeatedQuery.where);\n\n    // Look for foreign key patterns\n    for (const key of whereKeys) {\n      // Pattern 1: table_id (e.g., user_id when initial table is users)\n      if (key === `${initialTable}_id` || key === `${initialTable}Id`) {\n        return key;\n      }\n\n      // Pattern 2: ends with _id or Id\n      if (key.endsWith('_id') || key.endsWith('Id')) {\n        // Check if it could reference the initial table\n        const possibleTable = key.replace(/_id$|Id$/, '');\n        if (possibleTable === initialTable ||\n            possibleTable === initialTable.slice(0, -1)) { // singular form\n          return key;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  private generateOptimizedQuery(problem: N1Problem): string {\n    const { initialQuery, repeatedQueries, foreignKey } = problem;\n\n    // Get columns from both queries\n    const initialColumns = (initialQuery.select || ['*'])\n      .map(col => `${initialQuery.table}.${col}`)\n      .join(', ');\n\n    const repeatedColumns = (repeatedQueries[0].select || ['*'])\n      .map(col => `${repeatedQueries[0].table}.${col}`)\n      .join(', ');\n\n    // Build JOIN query\n    let optimized = `SELECT ${initialColumns}, ${repeatedColumns}\\n`;\n    optimized += `FROM ${initialQuery.table}\\n`;\n    optimized += `LEFT JOIN ${repeatedQueries[0].table} `;\n    optimized += `ON ${initialQuery.table}.id = ${repeatedQueries[0].table}.${foreignKey}`;\n\n    // Add WHERE clause from initial query if exists\n    if (initialQuery.where) {\n      const whereConditions = Object.entries(initialQuery.where)\n        .map(([key, value]) =>\n          `${initialQuery.table}.${key} = ${JSON.stringify(value)}`\n        )\n        .join(' AND ');\n      optimized += `\\nWHERE ${whereConditions}`;\n    }\n\n    return optimized;\n  }\n}",
    "hints": [
      "Look for a SELECT query followed by multiple similar SELECTs",
      "Repeated queries have same table and WHERE clause structure",
      "Foreign keys often follow patterns like table_id or tableId",
      "Group consecutive repeated queries together",
      "Generate LEFT JOIN to include all initial rows",
      "Combine columns from both tables in SELECT",
      "Preserve WHERE conditions from initial query",
      "Skip already-analyzed queries to avoid duplicate detection"
    ],
    "testCases": [
      {
        "input": "SELECT users, then SELECT posts WHERE user_id for each user",
        "expected": "Detects N+1, suggests LEFT JOIN users with posts",
        "passed": false
      },
      {
        "input": "Single query only",
        "expected": "No N+1 problems detected",
        "passed": false
      },
      {
        "input": "Multiple different queries",
        "expected": "No N+1 problems (no pattern)",
        "passed": false
      },
      {
        "input": "SELECT orders, then 10x SELECT order_items WHERE order_id",
        "expected": "Detects N+1 with count=10, generates JOIN query",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex15",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Advanced Code Refactoring Tool",
    "difficulty": 5,
    "description": "Create a code analysis tool that detects code duplication, extracts common patterns into reusable functions, and suggests refactoring opportunities.",
    "starterCode": "interface CodeBlock {\n  code: string;\n  startLine: number;\n  endLine: number;\n}\n\ninterface DuplicationReport {\n  duplicates: Array<{\n    pattern: string;\n    occurrences: CodeBlock[];\n    suggestion: string;\n  }>;\n  complexity: number;\n  recommendations: string[];\n}\n\nclass CodeRefactoringAnalyzer {\n  analyze(code: string, minDuplicateLength: number = 3): DuplicationReport {\n    // TODO: Analyze code for refactoring opportunities\n    // 1. Detect duplicated code blocks\n    // 2. Calculate code complexity\n    // 3. Suggest extracted functions\n  }\n\n  private findDuplicates(lines: string[], minLength: number): Array<{\n    pattern: string;\n    occurrences: CodeBlock[];\n  }> {\n    // TODO: Find duplicate code blocks (ignoring whitespace/variables)\n  }\n\n  private normalizeCode(code: string): string {\n    // TODO: Normalize for comparison (remove whitespace, generalize variables)\n  }\n\n  private calculateComplexity(code: string): number {\n    // TODO: Calculate cyclomatic complexity\n  }\n\n  private generateExtractedFunction(pattern: string, index: number): string {\n    // TODO: Generate extracted function suggestion\n  }\n}",
    "solution": "interface CodeBlock {\n  code: string;\n  startLine: number;\n  endLine: number;\n}\n\ninterface DuplicationReport {\n  duplicates: Array<{\n    pattern: string;\n    occurrences: CodeBlock[];\n    suggestion: string;\n  }>;\n  complexity: number;\n  recommendations: string[];\n}\n\nclass CodeRefactoringAnalyzer {\n  analyze(code: string, minDuplicateLength: number = 3): DuplicationReport {\n    const lines = code.split('\\n');\n    const duplicates = this.findDuplicates(lines, minDuplicateLength);\n    const complexity = this.calculateComplexity(code);\n    const recommendations: string[] = [];\n\n    // Generate suggestions for each duplicate\n    const duplicatesWithSuggestions = duplicates.map((dup, index) => {\n      const suggestion = this.generateExtractedFunction(dup.pattern, index);\n      return {\n        ...dup,\n        suggestion\n      };\n    });\n\n    // Add recommendations based on analysis\n    if (duplicates.length > 0) {\n      recommendations.push(\n        `Found ${duplicates.length} duplicate code patterns. Consider extracting to functions.`\n      );\n    }\n\n    if (complexity > 10) {\n      recommendations.push(\n        `Cyclomatic complexity is ${complexity}. Consider breaking down into smaller functions.`\n      );\n    }\n\n    if (complexity > 20) {\n      recommendations.push(\n        'High complexity detected. Urgent refactoring recommended.'\n      );\n    }\n\n    return {\n      duplicates: duplicatesWithSuggestions,\n      complexity,\n      recommendations\n    };\n  }\n\n  private findDuplicates(lines: string[], minLength: number): Array<{\n    pattern: string;\n    occurrences: CodeBlock[];\n  }> {\n    const patterns = new Map<string, CodeBlock[]>();\n\n    // Check all possible windows of size >= minLength\n    for (let size = minLength; size <= Math.floor(lines.length / 2); size++) {\n      for (let i = 0; i <= lines.length - size; i++) {\n        const block = lines.slice(i, i + size).join('\\n');\n        const normalized = this.normalizeCode(block);\n\n        // Skip if too simple (empty or just braces)\n        if (normalized.trim().length < 10) continue;\n\n        const codeBlock: CodeBlock = {\n          code: block,\n          startLine: i + 1,\n          endLine: i + size\n        };\n\n        if (patterns.has(normalized)) {\n          // Check if this overlaps with existing occurrences\n          const existing = patterns.get(normalized)!;\n          const overlaps = existing.some(exist =>\n            (codeBlock.startLine >= exist.startLine &&\n             codeBlock.startLine <= exist.endLine) ||\n            (codeBlock.endLine >= exist.startLine &&\n             codeBlock.endLine <= exist.endLine)\n          );\n\n          if (!overlaps) {\n            existing.push(codeBlock);\n          }\n        } else {\n          patterns.set(normalized, [codeBlock]);\n        }\n      }\n    }\n\n    // Filter to only patterns with 2+ occurrences\n    const duplicates: Array<{ pattern: string; occurrences: CodeBlock[] }> = [];\n\n    patterns.forEach((occurrences, pattern) => {\n      if (occurrences.length >= 2) {\n        duplicates.push({ pattern, occurrences });\n      }\n    });\n\n    // Sort by number of occurrences (most duplicated first)\n    return duplicates.sort((a, b) => b.occurrences.length - a.occurrences.length);\n  }\n\n  private normalizeCode(code: string): string {\n    return code\n      // Remove comments\n      .replace(/\\/\\/.*$/gm, '')\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      // Normalize whitespace\n      .replace(/\\s+/g, ' ')\n      // Remove variable names (replace with placeholder)\n      .replace(/\\b[a-z][a-zA-Z0-9]*\\b/g, 'VAR')\n      // Remove string literals\n      .replace(/\"[^\"]*\"/g, '\"STR\"')\n      .replace(/'[^']*'/g, \"'STR'\")\n      // Remove numbers\n      .replace(/\\b\\d+\\b/g, 'NUM')\n      .trim();\n  }\n\n  private calculateComplexity(code: string): number {\n    let complexity = 1; // Base complexity\n\n    // Decision points increase complexity\n    const decisionKeywords = [\n      /\\bif\\b/g,\n      /\\belse\\s+if\\b/g,\n      /\\bfor\\b/g,\n      /\\bwhile\\b/g,\n      /\\bcase\\b/g,\n      /\\bcatch\\b/g,\n      /\\b&&\\b/g,\n      /\\b\\|\\|\\b/g,\n      /\\?/g, // Ternary operator\n    ];\n\n    decisionKeywords.forEach(keyword => {\n      const matches = code.match(keyword);\n      if (matches) {\n        complexity += matches.length;\n      }\n    });\n\n    return complexity;\n  }\n\n  private generateExtractedFunction(pattern: string, index: number): string {\n    // Identify potential parameters (look for variables)\n    const variables = new Set<string>();\n    const varMatches = pattern.matchAll(/\\b[a-z][a-zA-Z0-9]*\\b/g);\n\n    for (const match of varMatches) {\n      if (!['const', 'let', 'var', 'function', 'return', 'if', 'else',\n           'for', 'while', 'do', 'switch', 'case'].includes(match[0])) {\n        variables.add(match[0]);\n      }\n    }\n\n    const params = Array.from(variables).slice(0, 3).join(', '); // Limit to 3 params\n\n    return `function extracted_${index + 1}(${params}) {\n  // TODO: Implement extracted logic\n  ${pattern.split('\\n').map(line => '  ' + line).join('\\n')}\n}`;\n  }\n}",
    "hints": [
      "Use sliding windows to find duplicate blocks of different sizes",
      "Normalize code by removing whitespace, comments, and variable names",
      "Replace literals (strings, numbers) with placeholders for comparison",
      "Track line numbers for each code block",
      "Avoid overlapping duplicates in the same location",
      "Calculate cyclomatic complexity by counting decision points",
      "Count if, for, while, case, catch, &&, ||, and ternary operators",
      "Generate function names like extracted_1, extracted_2",
      "Extract variable names from pattern for function parameters"
    ],
    "testCases": [
      {
        "input": "Code with identical blocks repeated 3 times",
        "expected": "Detects 1 pattern with 3 occurrences",
        "passed": false
      },
      {
        "input": "Code with high nesting (if/for/while)",
        "expected": "High complexity score, recommendations generated",
        "passed": false
      },
      {
        "input": "Unique code with no duplication",
        "expected": "No duplicates found, low complexity",
        "passed": false
      },
      {
        "input": "Similar code with different variable names",
        "expected": "Detects as duplicate after normalization",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t4-ex16",
    "subjectId": "cs404",
    "topicId": "topic-4",
    "title": "Performance Profiler and Optimizer",
    "difficulty": 5,
    "description": "Build a comprehensive performance profiler that tracks function execution times, memory usage, identifies bottlenecks, and suggests optimizations.",
    "starterCode": "interface PerformanceMetric {\n  functionName: string;\n  executionTime: number;\n  callCount: number;\n  averageTime: number;\n  memoryUsed?: number;\n}\n\ninterface PerformanceReport {\n  metrics: PerformanceMetric[];\n  bottlenecks: string[];\n  optimizationSuggestions: Array<{\n    function: string;\n    issue: string;\n    suggestion: string;\n    priority: 'high' | 'medium' | 'low';\n  }>;\n  totalTime: number;\n}\n\nclass PerformanceProfiler {\n  private metrics: Map<string, {\n    times: number[];\n    memory: number[];\n  }>;\n\n  constructor() {\n    this.metrics = new Map();\n  }\n\n  profile<T>(functionName: string, fn: () => T): T {\n    // TODO: Profile function execution\n    // Track time, memory, call count\n  }\n\n  async profileAsync<T>(functionName: string, fn: () => Promise<T>): Promise<T> {\n    // TODO: Profile async function execution\n  }\n\n  generateReport(): PerformanceReport {\n    // TODO: Analyze metrics and generate report\n    // Identify bottlenecks (>100ms or >10% of total time)\n    // Suggest optimizations based on patterns\n  }\n\n  private analyzeBottlenecks(metrics: PerformanceMetric[]): string[] {\n    // TODO: Identify performance bottlenecks\n  }\n\n  private generateOptimizations(metrics: PerformanceMetric[]): Array<{\n    function: string;\n    issue: string;\n    suggestion: string;\n    priority: 'high' | 'medium' | 'low';\n  }> {\n    // TODO: Generate optimization suggestions\n  }\n\n  reset(): void {\n    this.metrics.clear();\n  }\n}",
    "solution": "interface PerformanceMetric {\n  functionName: string;\n  executionTime: number;\n  callCount: number;\n  averageTime: number;\n  memoryUsed?: number;\n}\n\ninterface PerformanceReport {\n  metrics: PerformanceMetric[];\n  bottlenecks: string[];\n  optimizationSuggestions: Array<{\n    function: string;\n    issue: string;\n    suggestion: string;\n    priority: 'high' | 'medium' | 'low';\n  }>;\n  totalTime: number;\n}\n\nclass PerformanceProfiler {\n  private metrics: Map<string, {\n    times: number[];\n    memory: number[];\n  }>;\n\n  constructor() {\n    this.metrics = new Map();\n  }\n\n  profile<T>(functionName: string, fn: () => T): T {\n    const startTime = performance.now();\n    const startMemory = (performance as any).memory?.usedJSHeapSize || 0;\n\n    try {\n      const result = fn();\n\n      const endTime = performance.now();\n      const endMemory = (performance as any).memory?.usedJSHeapSize || 0;\n\n      this.recordMetric(\n        functionName,\n        endTime - startTime,\n        endMemory - startMemory\n      );\n\n      return result;\n    } catch (error) {\n      // Record even if function throws\n      const endTime = performance.now();\n      this.recordMetric(functionName, endTime - startTime, 0);\n      throw error;\n    }\n  }\n\n  async profileAsync<T>(functionName: string, fn: () => Promise<T>): Promise<T> {\n    const startTime = performance.now();\n    const startMemory = (performance as any).memory?.usedJSHeapSize || 0;\n\n    try {\n      const result = await fn();\n\n      const endTime = performance.now();\n      const endMemory = (performance as any).memory?.usedJSHeapSize || 0;\n\n      this.recordMetric(\n        functionName,\n        endTime - startTime,\n        endMemory - startMemory\n      );\n\n      return result;\n    } catch (error) {\n      const endTime = performance.now();\n      this.recordMetric(functionName, endTime - startTime, 0);\n      throw error;\n    }\n  }\n\n  private recordMetric(functionName: string, time: number, memory: number): void {\n    if (!this.metrics.has(functionName)) {\n      this.metrics.set(functionName, {\n        times: [],\n        memory: []\n      });\n    }\n\n    const metric = this.metrics.get(functionName)!;\n    metric.times.push(time);\n    metric.memory.push(memory);\n  }\n\n  generateReport(): PerformanceReport {\n    const metrics: PerformanceMetric[] = [];\n    let totalTime = 0;\n\n    // Calculate metrics for each function\n    this.metrics.forEach((data, functionName) => {\n      const executionTime = data.times.reduce((a, b) => a + b, 0);\n      const averageTime = executionTime / data.times.length;\n      const averageMemory = data.memory.length > 0\n        ? data.memory.reduce((a, b) => a + b, 0) / data.memory.length\n        : undefined;\n\n      totalTime += executionTime;\n\n      metrics.push({\n        functionName,\n        executionTime,\n        callCount: data.times.length,\n        averageTime,\n        memoryUsed: averageMemory\n      });\n    });\n\n    // Sort by total execution time (descending)\n    metrics.sort((a, b) => b.executionTime - a.executionTime);\n\n    const bottlenecks = this.analyzeBottlenecks(metrics, totalTime);\n    const optimizationSuggestions = this.generateOptimizations(metrics, totalTime);\n\n    return {\n      metrics,\n      bottlenecks,\n      optimizationSuggestions,\n      totalTime\n    };\n  }\n\n  private analyzeBottlenecks(metrics: PerformanceMetric[], totalTime: number): string[] {\n    const bottlenecks: string[] = [];\n\n    metrics.forEach(metric => {\n      const percentOfTotal = (metric.executionTime / totalTime) * 100;\n\n      // Bottleneck if >100ms or >10% of total time\n      if (metric.executionTime > 100 || percentOfTotal > 10) {\n        bottlenecks.push(\n          `${metric.functionName}: ${metric.executionTime.toFixed(2)}ms (${percentOfTotal.toFixed(1)}% of total)`\n        );\n      }\n    });\n\n    return bottlenecks;\n  }\n\n  private generateOptimizations(\n    metrics: PerformanceMetric[],\n    totalTime: number\n  ): Array<{\n    function: string;\n    issue: string;\n    suggestion: string;\n    priority: 'high' | 'medium' | 'low';\n  }> {\n    const suggestions: Array<{\n      function: string;\n      issue: string;\n      suggestion: string;\n      priority: 'high' | 'medium' | 'low';\n    }> = [];\n\n    metrics.forEach(metric => {\n      const percentOfTotal = (metric.executionTime / totalTime) * 100;\n\n      // High priority: slow functions called frequently\n      if (metric.callCount > 100 && metric.averageTime > 10) {\n        suggestions.push({\n          function: metric.functionName,\n          issue: `Called ${metric.callCount} times with ${metric.averageTime.toFixed(2)}ms average`,\n          suggestion: 'Consider memoization or caching results',\n          priority: 'high'\n        });\n      }\n\n      // High priority: major bottleneck\n      if (percentOfTotal > 20) {\n        suggestions.push({\n          function: metric.functionName,\n          issue: `Consumes ${percentOfTotal.toFixed(1)}% of total execution time`,\n          suggestion: 'Critical optimization target. Consider algorithm improvements or code splitting',\n          priority: 'high'\n        });\n      }\n\n      // Medium priority: moderate performance impact\n      if (metric.averageTime > 50 && metric.averageTime <= 100) {\n        suggestions.push({\n          function: metric.functionName,\n          issue: `Average execution time of ${metric.averageTime.toFixed(2)}ms`,\n          suggestion: 'Consider optimizing algorithms or reducing complexity',\n          priority: 'medium'\n        });\n      }\n\n      // Memory-based suggestions\n      if (metric.memoryUsed && metric.memoryUsed > 1000000) { // >1MB\n        suggestions.push({\n          function: metric.functionName,\n          issue: `High memory usage: ${(metric.memoryUsed / 1000000).toFixed(2)}MB`,\n          suggestion: 'Check for memory leaks or large object allocations',\n          priority: 'medium'\n        });\n      }\n\n      // Low priority: minor optimizations\n      if (metric.callCount > 50 && metric.averageTime > 5 && metric.averageTime <= 10) {\n        suggestions.push({\n          function: metric.functionName,\n          issue: `Frequent calls (${metric.callCount}) with small overhead`,\n          suggestion: 'Consider batching operations or debouncing',\n          priority: 'low'\n        });\n      }\n    });\n\n    // Sort by priority\n    const priorityOrder = { high: 0, medium: 1, low: 2 };\n    suggestions.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n\n    return suggestions;\n  }\n\n  reset(): void {\n    this.metrics.clear();\n  }\n}",
    "hints": [
      "Use performance.now() for high-resolution timing",
      "Access memory via performance.memory API (Chrome-specific)",
      "Store arrays of times and memory for each function",
      "Calculate averages, totals, and percentages in report",
      "Bottlenecks are functions >100ms or >10% of total time",
      "High priority: functions called frequently with high average time",
      "Medium priority: moderate execution time or high memory",
      "Low priority: minor optimizations for frequently called functions",
      "Record metrics even if function throws error",
      "Sort metrics by total execution time descending"
    ],
    "testCases": [
      {
        "input": "Profile fast function called 1000 times",
        "expected": "High call count, suggestion for memoization",
        "passed": false
      },
      {
        "input": "Profile slow function taking 200ms",
        "expected": "Identified as bottleneck, high priority optimization",
        "passed": false
      },
      {
        "input": "Profile multiple functions, one consuming 50% of time",
        "expected": "Critical optimization suggestion for dominant function",
        "passed": false
      },
      {
        "input": "Profile async function",
        "expected": "Correctly measures async execution time",
        "passed": false
      },
      {
        "input": "Generate report after multiple profiled functions",
        "expected": "Metrics sorted by total time, bottlenecks identified",
        "passed": false
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex01",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Basic Unit Test for Pure Function",
    "difficulty": 1,
    "description": "Write unit tests for a simple calculator function. Learn the fundamentals of testing pure functions with Jest.",
    "starterCode": "// Calculator function to test\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Write your tests here\ndescribe('Calculator', () => {\n  // TODO: Write test cases for the add function\n  // Test: should add two positive numbers\n  // Test: should add negative numbers\n  // Test: should handle zero\n});",
    "solution": "// Calculator function to test\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Complete test suite\ndescribe('Calculator', () => {\n  test('should add two positive numbers', () => {\n    expect(add(2, 3)).toBe(5);\n    expect(add(10, 15)).toBe(25);\n  });\n\n  test('should add negative numbers', () => {\n    expect(add(-5, -3)).toBe(-8);\n    expect(add(-10, 5)).toBe(-5);\n  });\n\n  test('should handle zero', () => {\n    expect(add(0, 0)).toBe(0);\n    expect(add(5, 0)).toBe(5);\n    expect(add(0, 7)).toBe(7);\n  });\n\n  test('should add decimal numbers', () => {\n    expect(add(1.5, 2.3)).toBeCloseTo(3.8);\n  });\n});",
    "hints": [
      "Use describe() to group related tests together",
      "Each test() should verify a specific behavior",
      "Use expect() and toBe() for exact equality checks",
      "For decimal numbers, use toBeCloseTo() instead of toBe()"
    ],
    "testCases": [
      {
        "input": "add(2, 3)",
        "expectedOutput": "5",
        "description": "Should add two positive numbers"
      },
      {
        "input": "add(-5, -3)",
        "expectedOutput": "-8",
        "description": "Should add negative numbers"
      },
      {
        "input": "add(0, 7)",
        "expectedOutput": "7",
        "description": "Should handle zero"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex02",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Test Fixture Creation",
    "difficulty": 1,
    "description": "Create reusable test fixtures for user data. Learn how to set up common test data that can be used across multiple tests.",
    "starterCode": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  role: 'admin' | 'user' | 'guest';\n}\n\n// TODO: Create test fixtures\n// Create a function createTestUser() that generates a user with default values\n// Allow overriding specific properties\nfunction createTestUser(overrides?: Partial<User>): User {\n  // Your implementation here\n}\n\n// TODO: Write tests using the fixture\ndescribe('User Fixtures', () => {\n  // Test: should create default user\n  // Test: should override specific properties\n});",
    "solution": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  role: 'admin' | 'user' | 'guest';\n}\n\n// Test fixture factory function\nfunction createTestUser(overrides?: Partial<User>): User {\n  return {\n    id: '123',\n    name: 'Test User',\n    email: 'test@example.com',\n    role: 'user',\n    ...overrides\n  };\n}\n\n// Tests using the fixture\ndescribe('User Fixtures', () => {\n  test('should create default user', () => {\n    const user = createTestUser();\n    expect(user.id).toBe('123');\n    expect(user.name).toBe('Test User');\n    expect(user.email).toBe('test@example.com');\n    expect(user.role).toBe('user');\n  });\n\n  test('should override specific properties', () => {\n    const admin = createTestUser({ role: 'admin', name: 'Admin User' });\n    expect(admin.role).toBe('admin');\n    expect(admin.name).toBe('Admin User');\n    expect(admin.email).toBe('test@example.com'); // default value\n  });\n\n  test('should create multiple unique users', () => {\n    const user1 = createTestUser({ id: '1', email: 'user1@example.com' });\n    const user2 = createTestUser({ id: '2', email: 'user2@example.com' });\n    expect(user1.id).not.toBe(user2.id);\n    expect(user1.email).not.toBe(user2.email);\n  });\n});",
    "hints": [
      "Use the spread operator (...) to merge default values with overrides",
      "Partial<User> allows optional override of any User property",
      "Test fixtures reduce code duplication across tests",
      "Factory functions make it easy to create test data with sensible defaults"
    ],
    "testCases": [
      {
        "input": "createTestUser()",
        "expectedOutput": "{ id: \"123\", name: \"Test User\", email: \"test@example.com\", role: \"user\" }",
        "description": "Should create user with default values"
      },
      {
        "input": "createTestUser({ role: \"admin\" })",
        "expectedOutput": "{ id: \"123\", name: \"Test User\", email: \"test@example.com\", role: \"admin\" }",
        "description": "Should override role while keeping other defaults"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex03",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Bug Report Template Generator",
    "difficulty": 1,
    "description": "Create a function that generates structured bug report templates. Learn how to standardize bug reporting for QA processes.",
    "starterCode": "interface BugReport {\n  title: string;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  description: string;\n  stepsToReproduce: string[];\n  expectedBehavior: string;\n  actualBehavior: string;\n  environment: string;\n}\n\n// TODO: Implement the bug report generator\nfunction generateBugReport(data: Partial<BugReport>): string {\n  // Return a formatted markdown string\n}\n\n// TODO: Write tests for the generator\ndescribe('Bug Report Generator', () => {\n  // Test: should generate complete report\n  // Test: should handle missing optional fields\n});",
    "solution": "interface BugReport {\n  title: string;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  description: string;\n  stepsToReproduce: string[];\n  expectedBehavior: string;\n  actualBehavior: string;\n  environment: string;\n}\n\n// Bug report generator\nfunction generateBugReport(data: Partial<BugReport>): string {\n  const report = `# Bug Report: ${data.title || 'Untitled'}\n\n**Severity:** ${data.severity || 'medium'}\n\n## Description\n${data.description || 'No description provided'}\n\n## Steps to Reproduce\n${data.stepsToReproduce?.map((step, i) => `${i + 1}. ${step}`).join('\\n') || 'No steps provided'}\n\n## Expected Behavior\n${data.expectedBehavior || 'Not specified'}\n\n## Actual Behavior\n${data.actualBehavior || 'Not specified'}\n\n## Environment\n${data.environment || 'Not specified'}\n`;\n  return report;\n}\n\n// Tests\ndescribe('Bug Report Generator', () => {\n  test('should generate complete report', () => {\n    const report = generateBugReport({\n      title: 'Login fails with valid credentials',\n      severity: 'high',\n      description: 'Users cannot log in',\n      stepsToReproduce: ['Navigate to login page', 'Enter valid credentials', 'Click submit'],\n      expectedBehavior: 'User should be logged in',\n      actualBehavior: 'Error message displayed',\n      environment: 'Chrome 120, Windows 11'\n    });\n\n    expect(report).toContain('# Bug Report: Login fails with valid credentials');\n    expect(report).toContain('**Severity:** high');\n    expect(report).toContain('1. Navigate to login page');\n  });\n\n  test('should handle missing optional fields', () => {\n    const report = generateBugReport({ title: 'Test Bug' });\n    expect(report).toContain('# Bug Report: Test Bug');\n    expect(report).toContain('**Severity:** medium');\n    expect(report).toContain('No description provided');\n  });\n});",
    "hints": [
      "Use template literals for formatted string output",
      "Provide default values for missing fields",
      "Use array.map() to format the steps to reproduce list",
      "Check if fields exist before accessing them with optional chaining (?.)"
    ],
    "testCases": [
      {
        "input": "generateBugReport({ title: \"Test Bug\", severity: \"critical\" })",
        "expectedOutput": "String containing \"# Bug Report: Test Bug\" and \"**Severity:** critical\"",
        "description": "Should generate report with provided fields"
      },
      {
        "input": "generateBugReport({})",
        "expectedOutput": "String containing default values",
        "description": "Should handle empty input with defaults"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex04",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Testing Async Functions with Jest",
    "difficulty": 2,
    "description": "Write tests for asynchronous functions using async/await. Learn to test promises and handle asynchronous behavior in tests.",
    "starterCode": "// Async function to fetch user data\nasync function fetchUser(id: string): Promise<{ id: string; name: string }> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ id, name: `User ${id}` });\n    }, 100);\n  });\n}\n\n// TODO: Write async tests\ndescribe('Async Functions', () => {\n  // Test: should fetch user successfully\n  // Test: should handle multiple async calls\n  // Use async/await pattern\n});",
    "solution": "// Async function to fetch user data\nasync function fetchUser(id: string): Promise<{ id: string; name: string }> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ id, name: `User ${id}` });\n    }, 100);\n  });\n}\n\n// Complete async test suite\ndescribe('Async Functions', () => {\n  test('should fetch user successfully', async () => {\n    const user = await fetchUser('123');\n    expect(user.id).toBe('123');\n    expect(user.name).toBe('User 123');\n  });\n\n  test('should handle multiple async calls', async () => {\n    const users = await Promise.all([\n      fetchUser('1'),\n      fetchUser('2'),\n      fetchUser('3')\n    ]);\n\n    expect(users).toHaveLength(3);\n    expect(users[0].id).toBe('1');\n    expect(users[1].id).toBe('2');\n    expect(users[2].id).toBe('3');\n  });\n\n  test('should resolve promises correctly', async () => {\n    await expect(fetchUser('999')).resolves.toEqual({\n      id: '999',\n      name: 'User 999'\n    });\n  });\n\n  test('should complete within timeout', async () => {\n    const start = Date.now();\n    await fetchUser('123');\n    const duration = Date.now() - start;\n    expect(duration).toBeGreaterThanOrEqual(100);\n    expect(duration).toBeLessThan(200);\n  }, 300);\n});",
    "hints": [
      "Mark test functions as async when testing async code",
      "Use await keyword to wait for promises to resolve",
      "Use expect().resolves for promise matchers",
      "Promise.all() can test multiple async operations in parallel"
    ],
    "testCases": [
      {
        "input": "await fetchUser(\"123\")",
        "expectedOutput": "{ id: \"123\", name: \"User 123\" }",
        "description": "Should return user object with correct data"
      },
      {
        "input": "await Promise.all([fetchUser(\"1\"), fetchUser(\"2\")])",
        "expectedOutput": "Array with 2 user objects",
        "description": "Should handle multiple async calls"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex05",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Snapshot Testing for UI Components",
    "difficulty": 2,
    "description": "Implement snapshot testing for UI components. Learn how to detect unintended UI changes automatically.",
    "starterCode": "interface ButtonProps {\n  label: string;\n  variant: 'primary' | 'secondary' | 'danger';\n  disabled?: boolean;\n}\n\n// Simple button renderer\nfunction renderButton(props: ButtonProps): string {\n  const className = `btn btn-${props.variant}${props.disabled ? ' btn-disabled' : ''}`;\n  return `<button class=\"${className}\">${props.label}</button>`;\n}\n\n// TODO: Implement snapshot tests\ndescribe('Button Snapshots', () => {\n  // Test: should match snapshot for primary button\n  // Test: should match snapshot for disabled button\n  // Use toMatchInlineSnapshot() or toMatchSnapshot()\n});",
    "solution": "interface ButtonProps {\n  label: string;\n  variant: 'primary' | 'secondary' | 'danger';\n  disabled?: boolean;\n}\n\n// Simple button renderer\nfunction renderButton(props: ButtonProps): string {\n  const className = `btn btn-${props.variant}${props.disabled ? ' btn-disabled' : ''}`;\n  return `<button class=\"${className}\">${props.label}</button>`;\n}\n\n// Snapshot tests\ndescribe('Button Snapshots', () => {\n  test('should match snapshot for primary button', () => {\n    const output = renderButton({ label: 'Click me', variant: 'primary' });\n    expect(output).toMatchInlineSnapshot(\n      `\"<button class=\"btn btn-primary\">Click me</button>\"`\n    );\n  });\n\n  test('should match snapshot for secondary button', () => {\n    const output = renderButton({ label: 'Cancel', variant: 'secondary' });\n    expect(output).toMatchInlineSnapshot(\n      `\"<button class=\"btn btn-secondary\">Cancel</button>\"`\n    );\n  });\n\n  test('should match snapshot for disabled button', () => {\n    const output = renderButton({\n      label: 'Submit',\n      variant: 'primary',\n      disabled: true\n    });\n    expect(output).toMatchInlineSnapshot(\n      `\"<button class=\"btn btn-primary btn-disabled\">Submit</button>\"`\n    );\n  });\n\n  test('should match snapshot for danger button', () => {\n    const output = renderButton({ label: 'Delete', variant: 'danger' });\n    expect(output).toMatchInlineSnapshot(\n      `\"<button class=\"btn btn-danger\">Delete</button>\"`\n    );\n  });\n});",
    "hints": [
      "Snapshot tests capture the output and compare it on subsequent runs",
      "Use toMatchInlineSnapshot() to store snapshots directly in the test file",
      "Snapshots help detect unintended UI changes",
      "Update snapshots with jest -u when changes are intentional"
    ],
    "testCases": [
      {
        "input": "renderButton({ label: \"Click me\", variant: \"primary\" })",
        "expectedOutput": "<button class=\"btn btn-primary\">Click me</button>",
        "description": "Should render primary button correctly"
      },
      {
        "input": "renderButton({ label: \"Submit\", variant: \"primary\", disabled: true })",
        "expectedOutput": "<button class=\"btn btn-primary btn-disabled\">Submit</button>",
        "description": "Should render disabled button with correct classes"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex06",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Code Coverage Report Analysis",
    "difficulty": 2,
    "description": "Analyze code coverage and write tests to improve coverage. Learn to identify untested code paths and edge cases.",
    "starterCode": "// Function with multiple branches\nfunction calculateDiscount(price: number, customerType: 'regular' | 'premium' | 'vip'): number {\n  if (price <= 0) {\n    throw new Error('Price must be positive');\n  }\n\n  let discount = 0;\n\n  if (customerType === 'premium') {\n    discount = price * 0.1;\n  } else if (customerType === 'vip') {\n    discount = price * 0.2;\n  }\n\n  if (price > 1000) {\n    discount += 50;\n  }\n\n  return discount;\n}\n\n// TODO: Write comprehensive tests to achieve 100% coverage\n// Cover all branches: regular/premium/vip customers\n// Cover edge cases: price <= 0, price > 1000\ndescribe('Calculate Discount', () => {\n  // Add tests here\n});",
    "solution": "// Function with multiple branches\nfunction calculateDiscount(price: number, customerType: 'regular' | 'premium' | 'vip'): number {\n  if (price <= 0) {\n    throw new Error('Price must be positive');\n  }\n\n  let discount = 0;\n\n  if (customerType === 'premium') {\n    discount = price * 0.1;\n  } else if (customerType === 'vip') {\n    discount = price * 0.2;\n  }\n\n  if (price > 1000) {\n    discount += 50;\n  }\n\n  return discount;\n}\n\n// Comprehensive test suite with 100% coverage\ndescribe('Calculate Discount', () => {\n  describe('Error cases', () => {\n    test('should throw error for zero price', () => {\n      expect(() => calculateDiscount(0, 'regular')).toThrow('Price must be positive');\n    });\n\n    test('should throw error for negative price', () => {\n      expect(() => calculateDiscount(-10, 'regular')).toThrow('Price must be positive');\n    });\n  });\n\n  describe('Regular customers', () => {\n    test('should return 0 discount for regular customer', () => {\n      expect(calculateDiscount(100, 'regular')).toBe(0);\n    });\n\n    test('should return 50 bonus for regular customer with price > 1000', () => {\n      expect(calculateDiscount(1500, 'regular')).toBe(50);\n    });\n  });\n\n  describe('Premium customers', () => {\n    test('should return 10% discount for premium customer', () => {\n      expect(calculateDiscount(100, 'premium')).toBe(10);\n    });\n\n    test('should return 10% + 50 bonus for premium customer with price > 1000', () => {\n      expect(calculateDiscount(1500, 'premium')).toBe(200); // 150 + 50\n    });\n  });\n\n  describe('VIP customers', () => {\n    test('should return 20% discount for vip customer', () => {\n      expect(calculateDiscount(100, 'vip')).toBe(20);\n    });\n\n    test('should return 20% + 50 bonus for vip customer with price > 1000', () => {\n      expect(calculateDiscount(1500, 'vip')).toBe(350); // 300 + 50\n    });\n  });\n});",
    "hints": [
      "Test each branch condition separately (if/else statements)",
      "Test boundary conditions (price = 0, price = 1000, price = 1001)",
      "Test error cases with expect(() => fn()).toThrow()",
      "Organize tests with nested describe() blocks for clarity"
    ],
    "testCases": [
      {
        "input": "calculateDiscount(100, \"regular\")",
        "expectedOutput": "0",
        "description": "Regular customer gets no discount"
      },
      {
        "input": "calculateDiscount(100, \"premium\")",
        "expectedOutput": "10",
        "description": "Premium customer gets 10% discount"
      },
      {
        "input": "calculateDiscount(1500, \"vip\")",
        "expectedOutput": "350",
        "description": "VIP customer gets 20% + 50 bonus"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex07",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Mocking Dependencies with Jest",
    "difficulty": 3,
    "description": "Learn to mock external dependencies and isolate units under test. Practice using jest.mock() and mock functions.",
    "starterCode": "// External API module\nconst API = {\n  fetchUser: async (id: string) => {\n    // Actual implementation would call external API\n    throw new Error('Should be mocked in tests');\n  }\n};\n\n// Service that uses the API\nclass UserService {\n  async getUserName(id: string): Promise<string> {\n    const user = await API.fetchUser(id);\n    return user.name;\n  }\n\n  async isAdmin(id: string): Promise<boolean> {\n    const user = await API.fetchUser(id);\n    return user.role === 'admin';\n  }\n}\n\n// TODO: Write tests with mocked API\n// Mock the API.fetchUser function\n// Test UserService methods without calling real API\ndescribe('UserService with Mocks', () => {\n  // Setup mocks and tests here\n});",
    "solution": "// External API module\nconst API = {\n  fetchUser: async (id: string) => {\n    // Actual implementation would call external API\n    throw new Error('Should be mocked in tests');\n  }\n};\n\n// Service that uses the API\nclass UserService {\n  async getUserName(id: string): Promise<string> {\n    const user = await API.fetchUser(id);\n    return user.name;\n  }\n\n  async isAdmin(id: string): Promise<boolean> {\n    const user = await API.fetchUser(id);\n    return user.role === 'admin';\n  }\n}\n\n// Tests with mocked dependencies\ndescribe('UserService with Mocks', () => {\n  let service: UserService;\n  let mockFetchUser: jest.SpyInstance;\n\n  beforeEach(() => {\n    service = new UserService();\n    // Mock the API.fetchUser function\n    mockFetchUser = jest.spyOn(API, 'fetchUser');\n  });\n\n  afterEach(() => {\n    // Restore original implementation\n    mockFetchUser.mockRestore();\n  });\n\n  describe('getUserName', () => {\n    test('should return user name from API', async () => {\n      mockFetchUser.mockResolvedValue({ id: '1', name: 'John Doe', role: 'user' });\n\n      const name = await service.getUserName('1');\n\n      expect(name).toBe('John Doe');\n      expect(mockFetchUser).toHaveBeenCalledWith('1');\n      expect(mockFetchUser).toHaveBeenCalledTimes(1);\n    });\n\n    test('should handle API errors', async () => {\n      mockFetchUser.mockRejectedValue(new Error('API Error'));\n\n      await expect(service.getUserName('1')).rejects.toThrow('API Error');\n    });\n  });\n\n  describe('isAdmin', () => {\n    test('should return true for admin user', async () => {\n      mockFetchUser.mockResolvedValue({ id: '1', name: 'Admin', role: 'admin' });\n\n      const isAdmin = await service.isAdmin('1');\n\n      expect(isAdmin).toBe(true);\n    });\n\n    test('should return false for regular user', async () => {\n      mockFetchUser.mockResolvedValue({ id: '2', name: 'User', role: 'user' });\n\n      const isAdmin = await service.isAdmin('2');\n\n      expect(isAdmin).toBe(false);\n    });\n  });\n\n  test('should verify mock was called with correct arguments', async () => {\n    mockFetchUser.mockResolvedValue({ id: '123', name: 'Test', role: 'user' });\n\n    await service.getUserName('123');\n\n    expect(mockFetchUser).toHaveBeenCalledWith('123');\n  });\n});",
    "hints": [
      "Use jest.spyOn() to mock methods on existing objects",
      "mockResolvedValue() sets the resolved value for async functions",
      "mockRejectedValue() simulates errors from async functions",
      "Use beforeEach() and afterEach() to set up and clean up mocks"
    ],
    "testCases": [
      {
        "input": "service.getUserName(\"1\") with mocked API returning { name: \"John\" }",
        "expectedOutput": "\"John\"",
        "description": "Should return mocked user name"
      },
      {
        "input": "service.isAdmin(\"1\") with mocked API returning { role: \"admin\" }",
        "expectedOutput": "true",
        "description": "Should identify admin users"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex08",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Integration Test for API Endpoints",
    "difficulty": 3,
    "description": "Write integration tests for REST API endpoints. Test the full request/response cycle including routing and data handling.",
    "starterCode": "// Simple in-memory store\nconst users: { [id: string]: { id: string; name: string; email: string } } = {};\n\n// API endpoint handlers\nconst api = {\n  createUser: (req: { body: { name: string; email: string } }) => {\n    const id = Math.random().toString(36).substr(2, 9);\n    users[id] = { id, ...req.body };\n    return { status: 201, data: users[id] };\n  },\n\n  getUser: (req: { params: { id: string } }) => {\n    const user = users[req.params.id];\n    if (!user) {\n      return { status: 404, error: 'User not found' };\n    }\n    return { status: 200, data: user };\n  },\n\n  updateUser: (req: { params: { id: string }; body: Partial<{ name: string; email: string }> }) => {\n    const user = users[req.params.id];\n    if (!user) {\n      return { status: 404, error: 'User not found' };\n    }\n    users[req.params.id] = { ...user, ...req.body };\n    return { status: 200, data: users[req.params.id] };\n  }\n};\n\n// TODO: Write integration tests for the API\ndescribe('User API Integration Tests', () => {\n  beforeEach(() => {\n    // Clear users before each test\n  });\n\n  // Test: should create a new user\n  // Test: should get user by id\n  // Test: should return 404 for non-existent user\n  // Test: should update user\n});",
    "solution": "// Simple in-memory store\nconst users: { [id: string]: { id: string; name: string; email: string } } = {};\n\n// API endpoint handlers\nconst api = {\n  createUser: (req: { body: { name: string; email: string } }) => {\n    const id = Math.random().toString(36).substr(2, 9);\n    users[id] = { id, ...req.body };\n    return { status: 201, data: users[id] };\n  },\n\n  getUser: (req: { params: { id: string } }) => {\n    const user = users[req.params.id];\n    if (!user) {\n      return { status: 404, error: 'User not found' };\n    }\n    return { status: 200, data: user };\n  },\n\n  updateUser: (req: { params: { id: string }; body: Partial<{ name: string; email: string }> }) => {\n    const user = users[req.params.id];\n    if (!user) {\n      return { status: 404, error: 'User not found' };\n    }\n    users[req.params.id] = { ...user, ...req.body };\n    return { status: 200, data: users[req.params.id] };\n  }\n};\n\n// Integration tests\ndescribe('User API Integration Tests', () => {\n  beforeEach(() => {\n    // Clear users before each test\n    Object.keys(users).forEach(key => delete users[key]);\n  });\n\n  describe('POST /users', () => {\n    test('should create a new user', () => {\n      const response = api.createUser({\n        body: { name: 'John Doe', email: 'john@example.com' }\n      });\n\n      expect(response.status).toBe(201);\n      expect(response.data).toHaveProperty('id');\n      expect(response.data.name).toBe('John Doe');\n      expect(response.data.email).toBe('john@example.com');\n    });\n\n    test('should store created user', () => {\n      const createResponse = api.createUser({\n        body: { name: 'Jane Doe', email: 'jane@example.com' }\n      });\n\n      const getResponse = api.getUser({ params: { id: createResponse.data.id } });\n\n      expect(getResponse.status).toBe(200);\n      expect(getResponse.data).toEqual(createResponse.data);\n    });\n  });\n\n  describe('GET /users/:id', () => {\n    test('should get user by id', () => {\n      const createResponse = api.createUser({\n        body: { name: 'Test User', email: 'test@example.com' }\n      });\n\n      const response = api.getUser({ params: { id: createResponse.data.id } });\n\n      expect(response.status).toBe(200);\n      expect(response.data.id).toBe(createResponse.data.id);\n      expect(response.data.name).toBe('Test User');\n    });\n\n    test('should return 404 for non-existent user', () => {\n      const response = api.getUser({ params: { id: 'nonexistent' } });\n\n      expect(response.status).toBe(404);\n      expect(response.error).toBe('User not found');\n    });\n  });\n\n  describe('PUT /users/:id', () => {\n    test('should update user', () => {\n      const createResponse = api.createUser({\n        body: { name: 'Original Name', email: 'original@example.com' }\n      });\n\n      const updateResponse = api.updateUser({\n        params: { id: createResponse.data.id },\n        body: { name: 'Updated Name' }\n      });\n\n      expect(updateResponse.status).toBe(200);\n      expect(updateResponse.data.name).toBe('Updated Name');\n      expect(updateResponse.data.email).toBe('original@example.com');\n    });\n\n    test('should return 404 when updating non-existent user', () => {\n      const response = api.updateUser({\n        params: { id: 'nonexistent' },\n        body: { name: 'New Name' }\n      });\n\n      expect(response.status).toBe(404);\n      expect(response.error).toBe('User not found');\n    });\n  });\n});",
    "hints": [
      "Integration tests verify that multiple components work together",
      "Use beforeEach() to reset state between tests",
      "Test the complete flow: create, retrieve, update",
      "Test both success and error cases (404, validation errors)"
    ],
    "testCases": [
      {
        "input": "api.createUser({ body: { name: \"John\", email: \"john@example.com\" } })",
        "expectedOutput": "{ status: 201, data: { id: \"...\", name: \"John\", email: \"john@example.com\" } }",
        "description": "Should create user and return 201 status"
      },
      {
        "input": "api.getUser({ params: { id: \"nonexistent\" } })",
        "expectedOutput": "{ status: 404, error: \"User not found\" }",
        "description": "Should return 404 for missing user"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex09",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Test-Driven Development (TDD) Practice",
    "difficulty": 3,
    "description": "Practice TDD by writing tests first, then implementing code to make them pass. Build a shopping cart with TDD methodology.",
    "starterCode": "interface CartItem {\n  id: string;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\n// TODO: Implement ShoppingCart class using TDD\n// First write the tests below, then implement the class\nclass ShoppingCart {\n  // Your implementation here\n}\n\n// TODO: Write tests FIRST following TDD\ndescribe('ShoppingCart TDD', () => {\n  // Test: should start with empty cart\n  // Test: should add item to cart\n  // Test: should increase quantity if item exists\n  // Test: should calculate total\n  // Test: should remove item from cart\n  // Test: should apply discount\n});",
    "solution": "interface CartItem {\n  id: string;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\n// Implementation (written AFTER tests)\nclass ShoppingCart {\n  private items: CartItem[] = [];\n  private discountPercent: number = 0;\n\n  addItem(item: Omit<CartItem, 'quantity'>, quantity: number = 1): void {\n    const existing = this.items.find(i => i.id === item.id);\n    if (existing) {\n      existing.quantity += quantity;\n    } else {\n      this.items.push({ ...item, quantity });\n    }\n  }\n\n  removeItem(id: string): void {\n    this.items = this.items.filter(item => item.id !== id);\n  }\n\n  getItems(): CartItem[] {\n    return [...this.items];\n  }\n\n  getTotal(): number {\n    const subtotal = this.items.reduce((sum, item) => {\n      return sum + (item.price * item.quantity);\n    }, 0);\n    return subtotal * (1 - this.discountPercent / 100);\n  }\n\n  applyDiscount(percent: number): void {\n    this.discountPercent = percent;\n  }\n\n  clear(): void {\n    this.items = [];\n    this.discountPercent = 0;\n  }\n}\n\n// Tests (written FIRST in TDD)\ndescribe('ShoppingCart TDD', () => {\n  let cart: ShoppingCart;\n\n  beforeEach(() => {\n    cart = new ShoppingCart();\n  });\n\n  test('should start with empty cart', () => {\n    expect(cart.getItems()).toEqual([]);\n    expect(cart.getTotal()).toBe(0);\n  });\n\n  test('should add item to cart', () => {\n    cart.addItem({ id: '1', name: 'Apple', price: 1.5 }, 2);\n\n    const items = cart.getItems();\n    expect(items).toHaveLength(1);\n    expect(items[0].id).toBe('1');\n    expect(items[0].quantity).toBe(2);\n  });\n\n  test('should increase quantity if item exists', () => {\n    cart.addItem({ id: '1', name: 'Apple', price: 1.5 }, 2);\n    cart.addItem({ id: '1', name: 'Apple', price: 1.5 }, 3);\n\n    const items = cart.getItems();\n    expect(items).toHaveLength(1);\n    expect(items[0].quantity).toBe(5);\n  });\n\n  test('should calculate total', () => {\n    cart.addItem({ id: '1', name: 'Apple', price: 1.5 }, 2);\n    cart.addItem({ id: '2', name: 'Banana', price: 0.5 }, 3);\n\n    expect(cart.getTotal()).toBe(4.5); // 1.5*2 + 0.5*3 = 4.5\n  });\n\n  test('should remove item from cart', () => {\n    cart.addItem({ id: '1', name: 'Apple', price: 1.5 }, 2);\n    cart.addItem({ id: '2', name: 'Banana', price: 0.5 }, 3);\n\n    cart.removeItem('1');\n\n    const items = cart.getItems();\n    expect(items).toHaveLength(1);\n    expect(items[0].id).toBe('2');\n  });\n\n  test('should apply discount', () => {\n    cart.addItem({ id: '1', name: 'Apple', price: 10 }, 1);\n    cart.applyDiscount(10); // 10% discount\n\n    expect(cart.getTotal()).toBe(9);\n  });\n\n  test('should handle multiple operations', () => {\n    cart.addItem({ id: '1', name: 'Apple', price: 2 }, 5);\n    cart.addItem({ id: '2', name: 'Banana', price: 1 }, 10);\n    cart.removeItem('1');\n    cart.applyDiscount(20);\n\n    expect(cart.getTotal()).toBe(8); // (10 * 1) * 0.8 = 8\n  });\n});",
    "hints": [
      "TDD cycle: Write test -> Watch it fail -> Write minimal code -> Pass test -> Refactor",
      "Write tests that describe the desired behavior before implementation",
      "Start with simple tests and gradually add complexity",
      "Each test should verify one specific behavior"
    ],
    "testCases": [
      {
        "input": "cart.addItem({ id: \"1\", name: \"Apple\", price: 1.5 }, 2); cart.getTotal()",
        "expectedOutput": "3",
        "description": "Should calculate correct total"
      },
      {
        "input": "cart.addItem({ id: \"1\", name: \"Apple\", price: 10 }, 1); cart.applyDiscount(10); cart.getTotal()",
        "expectedOutput": "9",
        "description": "Should apply discount correctly"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex10",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Regression Test Suite",
    "difficulty": 3,
    "description": "Create a regression test suite to prevent previously fixed bugs from reoccurring. Learn to document and test bug fixes.",
    "starterCode": "// Date utility function with historical bugs\nclass DateUtils {\n  // Bug fix #1: Handle month boundaries correctly\n  static addDays(date: Date, days: number): Date {\n    const result = new Date(date);\n    result.setDate(result.getDate() + days);\n    return result;\n  }\n\n  // Bug fix #2: Handle leap years\n  static isLeapYear(year: number): boolean {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n  }\n\n  // Bug fix #3: Calculate business days (excluding weekends)\n  static addBusinessDays(date: Date, days: number): Date {\n    const result = new Date(date);\n    let added = 0;\n\n    while (added < days) {\n      result.setDate(result.getDate() + 1);\n      const dayOfWeek = result.getDay();\n      if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n        added++;\n      }\n    }\n\n    return result;\n  }\n}\n\n// TODO: Create regression tests for each historical bug\ndescribe('DateUtils Regression Tests', () => {\n  // Document each bug and create test to prevent regression\n});",
    "solution": "// Date utility function with historical bugs\nclass DateUtils {\n  // Bug fix #1: Handle month boundaries correctly\n  static addDays(date: Date, days: number): Date {\n    const result = new Date(date);\n    result.setDate(result.getDate() + days);\n    return result;\n  }\n\n  // Bug fix #2: Handle leap years\n  static isLeapYear(year: number): boolean {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n  }\n\n  // Bug fix #3: Calculate business days (excluding weekends)\n  static addBusinessDays(date: Date, days: number): Date {\n    const result = new Date(date);\n    let added = 0;\n\n    while (added < days) {\n      result.setDate(result.getDate() + 1);\n      const dayOfWeek = result.getDay();\n      if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n        added++;\n      }\n    }\n\n    return result;\n  }\n}\n\n// Regression tests for historical bugs\ndescribe('DateUtils Regression Tests', () => {\n  describe('Bug #1: Month boundary handling', () => {\n    // Original bug: Adding days at end of month caused incorrect dates\n    test('should correctly add days across month boundary', () => {\n      const jan31 = new Date(2024, 0, 31); // January 31\n      const result = DateUtils.addDays(jan31, 1);\n      expect(result.getMonth()).toBe(1); // February\n      expect(result.getDate()).toBe(1);\n    });\n\n    test('should handle end of year boundary', () => {\n      const dec31 = new Date(2024, 11, 31); // December 31\n      const result = DateUtils.addDays(dec31, 1);\n      expect(result.getFullYear()).toBe(2025);\n      expect(result.getMonth()).toBe(0); // January\n      expect(result.getDate()).toBe(1);\n    });\n  });\n\n  describe('Bug #2: Leap year calculation', () => {\n    // Original bug: Only checked divisibility by 4, not century exceptions\n    test('should correctly identify leap years', () => {\n      expect(DateUtils.isLeapYear(2024)).toBe(true);  // Divisible by 4\n      expect(DateUtils.isLeapYear(2000)).toBe(true);  // Divisible by 400\n    });\n\n    test('should correctly identify non-leap years', () => {\n      expect(DateUtils.isLeapYear(2023)).toBe(false); // Not divisible by 4\n      expect(DateUtils.isLeapYear(1900)).toBe(false); // Divisible by 100 but not 400\n      expect(DateUtils.isLeapYear(2100)).toBe(false); // Century year exception\n    });\n  });\n\n  describe('Bug #3: Business days calculation', () => {\n    // Original bug: Didn't skip weekends correctly\n    test('should skip weekends when adding business days', () => {\n      const friday = new Date(2024, 0, 5); // Friday, January 5, 2024\n      const result = DateUtils.addBusinessDays(friday, 1);\n\n      expect(result.getDay()).toBe(1); // Monday\n      expect(result.getDate()).toBe(8); // January 8\n    });\n\n    test('should handle multiple weeks', () => {\n      const monday = new Date(2024, 0, 8); // Monday, January 8, 2024\n      const result = DateUtils.addBusinessDays(monday, 5);\n\n      expect(result.getDate()).toBe(15); // Next Monday (skipped weekend)\n    });\n\n    test('should handle starting from weekend', () => {\n      const saturday = new Date(2024, 0, 6); // Saturday, January 6, 2024\n      const result = DateUtils.addBusinessDays(saturday, 1);\n\n      expect(result.getDay()).toBe(1); // Should be Monday\n    });\n  });\n\n  describe('Integration regression tests', () => {\n    test('should handle leap year February correctly', () => {\n      const feb28_2024 = new Date(2024, 1, 28); // Feb 28 in leap year\n      const result = DateUtils.addDays(feb28_2024, 1);\n      expect(result.getDate()).toBe(29); // Should be Feb 29\n    });\n  });\n});",
    "hints": [
      "Regression tests prevent old bugs from coming back",
      "Document each bug with comments explaining the original issue",
      "Test edge cases that previously caused failures",
      "Group related regression tests with describe() blocks"
    ],
    "testCases": [
      {
        "input": "DateUtils.addDays(new Date(2024, 0, 31), 1)",
        "expectedOutput": "Date with month=1 (February) and date=1",
        "description": "Should handle month boundary correctly"
      },
      {
        "input": "DateUtils.isLeapYear(1900)",
        "expectedOutput": "false",
        "description": "Should correctly identify century year exception"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex11",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Testing React Components with Testing Library",
    "difficulty": 4,
    "description": "Write comprehensive tests for React components using Testing Library. Learn to test user interactions and component behavior.",
    "starterCode": "// Simple Counter component\ninterface CounterProps {\n  initialValue?: number;\n  step?: number;\n  onCountChange?: (count: number) => void;\n}\n\nfunction Counter({ initialValue = 0, step = 1, onCountChange }: CounterProps) {\n  const [count, setCount] = React.useState(initialValue);\n\n  const increment = () => {\n    const newCount = count + step;\n    setCount(newCount);\n    onCountChange?.(newCount);\n  };\n\n  const decrement = () => {\n    const newCount = count - step;\n    setCount(newCount);\n    onCountChange?.(newCount);\n  };\n\n  const reset = () => {\n    setCount(initialValue);\n    onCountChange?.(initialValue);\n  };\n\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n\n// TODO: Write comprehensive component tests\ndescribe('Counter Component', () => {\n  // Test: should render with initial value\n  // Test: should increment count when button clicked\n  // Test: should decrement count\n  // Test: should reset to initial value\n  // Test: should call onCountChange callback\n  // Test: should use custom step value\n});",
    "solution": "// Simple Counter component\ninterface CounterProps {\n  initialValue?: number;\n  step?: number;\n  onCountChange?: (count: number) => void;\n}\n\nfunction Counter({ initialValue = 0, step = 1, onCountChange }: CounterProps) {\n  const [count, setCount] = React.useState(initialValue);\n\n  const increment = () => {\n    const newCount = count + step;\n    setCount(newCount);\n    onCountChange?.(newCount);\n  };\n\n  const decrement = () => {\n    const newCount = count - step;\n    setCount(newCount);\n    onCountChange?.(newCount);\n  };\n\n  const reset = () => {\n    setCount(initialValue);\n    onCountChange?.(initialValue);\n  };\n\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n\n// Comprehensive component tests\ndescribe('Counter Component', () => {\n  test('should render with default initial value', () => {\n    const { getByText } = render(<Counter />);\n    expect(getByText('Count: 0')).toBeInTheDocument();\n  });\n\n  test('should render with custom initial value', () => {\n    const { getByText } = render(<Counter initialValue={10} />);\n    expect(getByText('Count: 10')).toBeInTheDocument();\n  });\n\n  test('should increment count when button clicked', () => {\n    const { getByText } = render(<Counter />);\n    const incrementButton = getByText('Increment');\n\n    fireEvent.click(incrementButton);\n    expect(getByText('Count: 1')).toBeInTheDocument();\n\n    fireEvent.click(incrementButton);\n    expect(getByText('Count: 2')).toBeInTheDocument();\n  });\n\n  test('should decrement count when button clicked', () => {\n    const { getByText } = render(<Counter initialValue={5} />);\n    const decrementButton = getByText('Decrement');\n\n    fireEvent.click(decrementButton);\n    expect(getByText('Count: 4')).toBeInTheDocument();\n  });\n\n  test('should reset to initial value', () => {\n    const { getByText } = render(<Counter initialValue={10} />);\n\n    fireEvent.click(getByText('Increment'));\n    fireEvent.click(getByText('Increment'));\n    expect(getByText('Count: 12')).toBeInTheDocument();\n\n    fireEvent.click(getByText('Reset'));\n    expect(getByText('Count: 10')).toBeInTheDocument();\n  });\n\n  test('should call onCountChange callback', () => {\n    const mockCallback = jest.fn();\n    const { getByText } = render(<Counter onCountChange={mockCallback} />);\n\n    fireEvent.click(getByText('Increment'));\n    expect(mockCallback).toHaveBeenCalledWith(1);\n\n    fireEvent.click(getByText('Decrement'));\n    expect(mockCallback).toHaveBeenCalledWith(0);\n\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n  });\n\n  test('should use custom step value', () => {\n    const { getByText } = render(<Counter initialValue={0} step={5} />);\n\n    fireEvent.click(getByText('Increment'));\n    expect(getByText('Count: 5')).toBeInTheDocument();\n\n    fireEvent.click(getByText('Increment'));\n    expect(getByText('Count: 10')).toBeInTheDocument();\n\n    fireEvent.click(getByText('Decrement'));\n    expect(getByText('Count: 5')).toBeInTheDocument();\n  });\n\n  test('should handle multiple interactions', () => {\n    const mockCallback = jest.fn();\n    const { getByText } = render(\n      <Counter initialValue={100} step={10} onCountChange={mockCallback} />\n    );\n\n    fireEvent.click(getByText('Increment')); // 110\n    fireEvent.click(getByText('Increment')); // 120\n    fireEvent.click(getByText('Decrement')); // 110\n    fireEvent.click(getByText('Reset'));     // 100\n\n    expect(getByText('Count: 100')).toBeInTheDocument();\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(mockCallback).toHaveBeenLastCalledWith(100);\n  });\n});",
    "hints": [
      "Use render() from Testing Library to render components",
      "Use getByText() to find elements by their text content",
      "Use fireEvent.click() to simulate user clicks",
      "Mock callback functions with jest.fn() to verify they are called"
    ],
    "testCases": [
      {
        "input": "Click increment button once",
        "expectedOutput": "Count: 1 displayed",
        "description": "Should increment count on button click"
      },
      {
        "input": "Click increment twice, then reset",
        "expectedOutput": "Count: 0 displayed",
        "description": "Should reset to initial value"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex12",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Database Integration Test Setup",
    "difficulty": 4,
    "description": "Set up and write integration tests for database operations. Learn to test CRUD operations with a test database.",
    "starterCode": "// Simple in-memory database\nclass Database {\n  private data: Map<string, any> = new Map();\n\n  async connect(): Promise<void> {\n    // Simulate connection\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n\n  async disconnect(): Promise<void> {\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n\n  async insert(table: string, record: any): Promise<string> {\n    const id = Math.random().toString(36).substr(2, 9);\n    const key = `${table}:${id}`;\n    this.data.set(key, { id, ...record });\n    return id;\n  }\n\n  async findById(table: string, id: string): Promise<any | null> {\n    return this.data.get(`${table}:${id}`) || null;\n  }\n\n  async update(table: string, id: string, updates: any): Promise<boolean> {\n    const key = `${table}:${id}`;\n    const existing = this.data.get(key);\n    if (!existing) return false;\n    this.data.set(key, { ...existing, ...updates });\n    return true;\n  }\n\n  async delete(table: string, id: string): Promise<boolean> {\n    return this.data.delete(`${table}:${id}`);\n  }\n\n  async clear(): Promise<void> {\n    this.data.clear();\n  }\n}\n\n// TODO: Write database integration tests\ndescribe('Database Integration Tests', () => {\n  let db: Database;\n\n  // Setup: connect before all tests\n  // Cleanup: clear after each test, disconnect after all\n\n  // Test: should insert and retrieve record\n  // Test: should update existing record\n  // Test: should delete record\n  // Test: should return null for non-existent record\n  // Test: should handle concurrent operations\n});",
    "solution": "// Simple in-memory database\nclass Database {\n  private data: Map<string, any> = new Map();\n\n  async connect(): Promise<void> {\n    // Simulate connection\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n\n  async disconnect(): Promise<void> {\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n\n  async insert(table: string, record: any): Promise<string> {\n    const id = Math.random().toString(36).substr(2, 9);\n    const key = `${table}:${id}`;\n    this.data.set(key, { id, ...record });\n    return id;\n  }\n\n  async findById(table: string, id: string): Promise<any | null> {\n    return this.data.get(`${table}:${id}`) || null;\n  }\n\n  async update(table: string, id: string, updates: any): Promise<boolean> {\n    const key = `${table}:${id}`;\n    const existing = this.data.get(key);\n    if (!existing) return false;\n    this.data.set(key, { ...existing, ...updates });\n    return true;\n  }\n\n  async delete(table: string, id: string): Promise<boolean> {\n    return this.data.delete(`${table}:${id}`);\n  }\n\n  async clear(): Promise<void> {\n    this.data.clear();\n  }\n}\n\n// Database integration tests\ndescribe('Database Integration Tests', () => {\n  let db: Database;\n\n  beforeAll(async () => {\n    db = new Database();\n    await db.connect();\n  });\n\n  afterAll(async () => {\n    await db.disconnect();\n  });\n\n  afterEach(async () => {\n    await db.clear();\n  });\n\n  describe('CRUD Operations', () => {\n    test('should insert and retrieve record', async () => {\n      const id = await db.insert('users', { name: 'John', email: 'john@example.com' });\n\n      const user = await db.findById('users', id);\n\n      expect(user).not.toBeNull();\n      expect(user.id).toBe(id);\n      expect(user.name).toBe('John');\n      expect(user.email).toBe('john@example.com');\n    });\n\n    test('should update existing record', async () => {\n      const id = await db.insert('users', { name: 'Jane', email: 'jane@example.com' });\n\n      const updated = await db.update('users', id, { name: 'Jane Smith' });\n      expect(updated).toBe(true);\n\n      const user = await db.findById('users', id);\n      expect(user.name).toBe('Jane Smith');\n      expect(user.email).toBe('jane@example.com'); // unchanged\n    });\n\n    test('should delete record', async () => {\n      const id = await db.insert('users', { name: 'Bob' });\n\n      const deleted = await db.delete('users', id);\n      expect(deleted).toBe(true);\n\n      const user = await db.findById('users', id);\n      expect(user).toBeNull();\n    });\n\n    test('should return null for non-existent record', async () => {\n      const user = await db.findById('users', 'nonexistent');\n      expect(user).toBeNull();\n    });\n\n    test('should return false when updating non-existent record', async () => {\n      const updated = await db.update('users', 'nonexistent', { name: 'Test' });\n      expect(updated).toBe(false);\n    });\n\n    test('should return false when deleting non-existent record', async () => {\n      const deleted = await db.delete('users', 'nonexistent');\n      expect(deleted).toBe(false);\n    });\n  });\n\n  describe('Multiple records', () => {\n    test('should handle multiple inserts', async () => {\n      const id1 = await db.insert('users', { name: 'User 1' });\n      const id2 = await db.insert('users', { name: 'User 2' });\n      const id3 = await db.insert('users', { name: 'User 3' });\n\n      const user1 = await db.findById('users', id1);\n      const user2 = await db.findById('users', id2);\n      const user3 = await db.findById('users', id3);\n\n      expect(user1.name).toBe('User 1');\n      expect(user2.name).toBe('User 2');\n      expect(user3.name).toBe('User 3');\n    });\n\n    test('should isolate different tables', async () => {\n      const userId = await db.insert('users', { name: 'John' });\n      const productId = await db.insert('products', { name: 'Widget' });\n\n      const user = await db.findById('users', userId);\n      const product = await db.findById('products', productId);\n\n      expect(user.name).toBe('John');\n      expect(product.name).toBe('Widget');\n\n      // Should not find user in products table\n      const notFound = await db.findById('products', userId);\n      expect(notFound).toBeNull();\n    });\n  });\n\n  describe('Concurrent operations', () => {\n    test('should handle concurrent inserts', async () => {\n      const promises = [\n        db.insert('users', { name: 'User 1' }),\n        db.insert('users', { name: 'User 2' }),\n        db.insert('users', { name: 'User 3' })\n      ];\n\n      const ids = await Promise.all(promises);\n\n      expect(ids).toHaveLength(3);\n      expect(new Set(ids).size).toBe(3); // All IDs should be unique\n    });\n  });\n});",
    "hints": [
      "Use beforeAll() to set up database connection once",
      "Use afterEach() to clear data between tests for isolation",
      "Test all CRUD operations: Create, Read, Update, Delete",
      "Test error cases like non-existent records"
    ],
    "testCases": [
      {
        "input": "await db.insert(\"users\", { name: \"John\" }); await db.findById(\"users\", id)",
        "expectedOutput": "{ id: \"...\", name: \"John\" }",
        "description": "Should insert and retrieve record"
      },
      {
        "input": "await db.update(\"users\", \"nonexistent\", { name: \"Test\" })",
        "expectedOutput": "false",
        "description": "Should return false for non-existent record"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex13",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "E2E User Flow Test",
    "difficulty": 4,
    "description": "Write end-to-end tests for a complete user flow. Test a multi-step user journey from start to finish.",
    "starterCode": "// Simple application state\nclass AppState {\n  private user: any = null;\n  private cart: any[] = [];\n  private orders: any[] = [];\n\n  // User authentication\n  login(email: string, password: string): boolean {\n    if (password === 'password123') {\n      this.user = { email, id: '123' };\n      return true;\n    }\n    return false;\n  }\n\n  logout(): void {\n    this.user = null;\n    this.cart = [];\n  }\n\n  isLoggedIn(): boolean {\n    return this.user !== null;\n  }\n\n  // Shopping cart\n  addToCart(product: { id: string; name: string; price: number }): void {\n    if (!this.isLoggedIn()) throw new Error('Must be logged in');\n    this.cart.push(product);\n  }\n\n  getCart(): any[] {\n    return [...this.cart];\n  }\n\n  // Checkout\n  checkout(): { orderId: string; total: number } {\n    if (!this.isLoggedIn()) throw new Error('Must be logged in');\n    if (this.cart.length === 0) throw new Error('Cart is empty');\n\n    const total = this.cart.reduce((sum, item) => sum + item.price, 0);\n    const orderId = Math.random().toString(36).substr(2, 9);\n\n    this.orders.push({ orderId, items: [...this.cart], total });\n    this.cart = [];\n\n    return { orderId, total };\n  }\n\n  getOrders(): any[] {\n    if (!this.isLoggedIn()) throw new Error('Must be logged in');\n    return [...this.orders];\n  }\n}\n\n// TODO: Write E2E test for complete user flow\ndescribe('E2E User Flow Tests', () => {\n  // Test complete flow: login -> add items -> checkout -> verify order\n  // Test error cases: not logged in, empty cart, etc.\n});",
    "solution": "// Simple application state\nclass AppState {\n  private user: any = null;\n  private cart: any[] = [];\n  private orders: any[] = [];\n\n  // User authentication\n  login(email: string, password: string): boolean {\n    if (password === 'password123') {\n      this.user = { email, id: '123' };\n      return true;\n    }\n    return false;\n  }\n\n  logout(): void {\n    this.user = null;\n    this.cart = [];\n  }\n\n  isLoggedIn(): boolean {\n    return this.user !== null;\n  }\n\n  // Shopping cart\n  addToCart(product: { id: string; name: string; price: number }): void {\n    if (!this.isLoggedIn()) throw new Error('Must be logged in');\n    this.cart.push(product);\n  }\n\n  getCart(): any[] {\n    return [...this.cart];\n  }\n\n  // Checkout\n  checkout(): { orderId: string; total: number } {\n    if (!this.isLoggedIn()) throw new Error('Must be logged in');\n    if (this.cart.length === 0) throw new Error('Cart is empty');\n\n    const total = this.cart.reduce((sum, item) => sum + item.price, 0);\n    const orderId = Math.random().toString(36).substr(2, 9);\n\n    this.orders.push({ orderId, items: [...this.cart], total });\n    this.cart = [];\n\n    return { orderId, total };\n  }\n\n  getOrders(): any[] {\n    if (!this.isLoggedIn()) throw new Error('Must be logged in');\n    return [...this.orders];\n  }\n}\n\n// E2E User Flow Tests\ndescribe('E2E User Flow Tests', () => {\n  let app: AppState;\n\n  beforeEach(() => {\n    app = new AppState();\n  });\n\n  describe('Happy Path: Complete Purchase Flow', () => {\n    test('should complete full purchase journey', () => {\n      // Step 1: User logs in\n      const loginSuccess = app.login('user@example.com', 'password123');\n      expect(loginSuccess).toBe(true);\n      expect(app.isLoggedIn()).toBe(true);\n\n      // Step 2: User adds items to cart\n      app.addToCart({ id: '1', name: 'Product 1', price: 29.99 });\n      app.addToCart({ id: '2', name: 'Product 2', price: 49.99 });\n      app.addToCart({ id: '3', name: 'Product 3', price: 19.99 });\n\n      const cart = app.getCart();\n      expect(cart).toHaveLength(3);\n      expect(cart[0].name).toBe('Product 1');\n\n      // Step 3: User proceeds to checkout\n      const order = app.checkout();\n      expect(order.orderId).toBeDefined();\n      expect(order.total).toBe(99.97); // 29.99 + 49.99 + 19.99\n\n      // Step 4: Cart is cleared after checkout\n      expect(app.getCart()).toHaveLength(0);\n\n      // Step 5: Order appears in order history\n      const orders = app.getOrders();\n      expect(orders).toHaveLength(1);\n      expect(orders[0].orderId).toBe(order.orderId);\n      expect(orders[0].items).toHaveLength(3);\n    });\n\n    test('should handle multiple orders', () => {\n      app.login('user@example.com', 'password123');\n\n      // First order\n      app.addToCart({ id: '1', name: 'Product 1', price: 10 });\n      const order1 = app.checkout();\n\n      // Second order\n      app.addToCart({ id: '2', name: 'Product 2', price: 20 });\n      app.addToCart({ id: '3', name: 'Product 3', price: 30 });\n      const order2 = app.checkout();\n\n      const orders = app.getOrders();\n      expect(orders).toHaveLength(2);\n      expect(orders[0].total).toBe(10);\n      expect(orders[1].total).toBe(50);\n    });\n  });\n\n  describe('Error Cases', () => {\n    test('should prevent adding to cart when not logged in', () => {\n      expect(() => {\n        app.addToCart({ id: '1', name: 'Product', price: 10 });\n      }).toThrow('Must be logged in');\n    });\n\n    test('should prevent checkout when not logged in', () => {\n      expect(() => {\n        app.checkout();\n      }).toThrow('Must be logged in');\n    });\n\n    test('should prevent checkout with empty cart', () => {\n      app.login('user@example.com', 'password123');\n\n      expect(() => {\n        app.checkout();\n      }).toThrow('Cart is empty');\n    });\n\n    test('should fail login with wrong password', () => {\n      const loginSuccess = app.login('user@example.com', 'wrongpassword');\n      expect(loginSuccess).toBe(false);\n      expect(app.isLoggedIn()).toBe(false);\n    });\n\n    test('should clear cart on logout', () => {\n      app.login('user@example.com', 'password123');\n      app.addToCart({ id: '1', name: 'Product', price: 10 });\n\n      expect(app.getCart()).toHaveLength(1);\n\n      app.logout();\n      expect(app.isLoggedIn()).toBe(false);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    test('should handle single item purchase', () => {\n      app.login('user@example.com', 'password123');\n      app.addToCart({ id: '1', name: 'Single Product', price: 99.99 });\n\n      const order = app.checkout();\n      expect(order.total).toBe(99.99);\n    });\n\n    test('should calculate correct total for many items', () => {\n      app.login('user@example.com', 'password123');\n\n      for (let i = 0; i < 10; i++) {\n        app.addToCart({ id: `${i}`, name: `Product ${i}`, price: 10 });\n      }\n\n      const order = app.checkout();\n      expect(order.total).toBe(100);\n    });\n  });\n});",
    "hints": [
      "E2E tests verify complete user journeys from start to finish",
      "Test the happy path (successful flow) and error cases",
      "Each step should verify the expected state before moving to next step",
      "Test that side effects occur correctly (cart cleared after checkout)"
    ],
    "testCases": [
      {
        "input": "login -> addToCart (3 items) -> checkout",
        "expectedOutput": "Order created with correct total, cart cleared",
        "description": "Should complete full purchase journey"
      },
      {
        "input": "addToCart without login",
        "expectedOutput": "Error: Must be logged in",
        "description": "Should prevent unauthorized actions"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex14",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "E2E Test with Playwright Basics",
    "difficulty": 5,
    "description": "Write end-to-end browser tests using Playwright. Learn to automate browser interactions and test real user scenarios.",
    "starterCode": "// Playwright test structure for a login form\n// This is pseudocode to demonstrate the testing approach\n\ninterface LoginPage {\n  navigate(): Promise<void>;\n  fillEmail(email: string): Promise<void>;\n  fillPassword(password: string): Promise<void>;\n  clickSubmit(): Promise<void>;\n  getErrorMessage(): Promise<string | null>;\n  isLoggedIn(): Promise<boolean>;\n}\n\n// TODO: Implement LoginPage class and write E2E tests\nclass LoginPageImpl implements LoginPage {\n  // Implement page object methods\n  // Use selectors like: '#email', '#password', 'button[type=\"submit\"]'\n}\n\n// TODO: Write E2E tests\ndescribe('Login E2E Tests', () => {\n  let page: LoginPage;\n\n  // Setup browser before tests\n  // Test: successful login with valid credentials\n  // Test: error message with invalid credentials\n  // Test: validation for empty fields\n  // Test: navigation after successful login\n});",
    "solution": "// Playwright test structure for a login form\ninterface LoginPage {\n  navigate(): Promise<void>;\n  fillEmail(email: string): Promise<void>;\n  fillPassword(password: string): Promise<void>;\n  clickSubmit(): Promise<void>;\n  getErrorMessage(): Promise<string | null>;\n  isLoggedIn(): Promise<boolean>;\n}\n\n// Mock implementation simulating Playwright page interactions\nclass LoginPageImpl implements LoginPage {\n  private formState = {\n    email: '',\n    password: '',\n    submitted: false,\n    loggedIn: false,\n    error: null as string | null\n  };\n\n  async navigate(): Promise<void> {\n    // Simulate: await page.goto('http://localhost:3000/login')\n    this.formState = {\n      email: '',\n      password: '',\n      submitted: false,\n      loggedIn: false,\n      error: null\n    };\n  }\n\n  async fillEmail(email: string): Promise<void> {\n    // Simulate: await page.fill('#email', email)\n    this.formState.email = email;\n  }\n\n  async fillPassword(password: string): Promise<void> {\n    // Simulate: await page.fill('#password', password)\n    this.formState.password = password;\n  }\n\n  async clickSubmit(): Promise<void> {\n    // Simulate: await page.click('button[type=\"submit\"]')\n    this.formState.submitted = true;\n\n    if (!this.formState.email || !this.formState.password) {\n      this.formState.error = 'Email and password are required';\n      return;\n    }\n\n    if (this.formState.email === 'test@example.com' &&\n        this.formState.password === 'password123') {\n      this.formState.loggedIn = true;\n      this.formState.error = null;\n    } else {\n      this.formState.error = 'Invalid email or password';\n    }\n  }\n\n  async getErrorMessage(): Promise<string | null> {\n    // Simulate: await page.textContent('.error-message')\n    return this.formState.error;\n  }\n\n  async isLoggedIn(): Promise<boolean> {\n    // Simulate: await page.isVisible('.user-dashboard')\n    return this.formState.loggedIn;\n  }\n}\n\n// E2E tests using Page Object pattern\ndescribe('Login E2E Tests', () => {\n  let page: LoginPage;\n\n  beforeEach(async () => {\n    page = new LoginPageImpl();\n    await page.navigate();\n  });\n\n  describe('Successful Login', () => {\n    test('should login with valid credentials', async () => {\n      await page.fillEmail('test@example.com');\n      await page.fillPassword('password123');\n      await page.clickSubmit();\n\n      const isLoggedIn = await page.isLoggedIn();\n      expect(isLoggedIn).toBe(true);\n\n      const error = await page.getErrorMessage();\n      expect(error).toBeNull();\n    });\n\n    test('should redirect to dashboard after login', async () => {\n      await page.fillEmail('test@example.com');\n      await page.fillPassword('password123');\n      await page.clickSubmit();\n\n      // Verify user is on dashboard\n      expect(await page.isLoggedIn()).toBe(true);\n    });\n  });\n\n  describe('Failed Login', () => {\n    test('should show error with invalid credentials', async () => {\n      await page.fillEmail('wrong@example.com');\n      await page.fillPassword('wrongpassword');\n      await page.clickSubmit();\n\n      const error = await page.getErrorMessage();\n      expect(error).toBe('Invalid email or password');\n\n      const isLoggedIn = await page.isLoggedIn();\n      expect(isLoggedIn).toBe(false);\n    });\n\n    test('should show error with wrong password', async () => {\n      await page.fillEmail('test@example.com');\n      await page.fillPassword('wrongpassword');\n      await page.clickSubmit();\n\n      const error = await page.getErrorMessage();\n      expect(error).toBe('Invalid email or password');\n    });\n\n    test('should show error with wrong email', async () => {\n      await page.fillEmail('wrong@example.com');\n      await page.fillPassword('password123');\n      await page.clickSubmit();\n\n      const error = await page.getErrorMessage();\n      expect(error).toBe('Invalid email or password');\n    });\n  });\n\n  describe('Validation', () => {\n    test('should require email field', async () => {\n      await page.fillPassword('password123');\n      await page.clickSubmit();\n\n      const error = await page.getErrorMessage();\n      expect(error).toBe('Email and password are required');\n      expect(await page.isLoggedIn()).toBe(false);\n    });\n\n    test('should require password field', async () => {\n      await page.fillEmail('test@example.com');\n      await page.clickSubmit();\n\n      const error = await page.getErrorMessage();\n      expect(error).toBe('Email and password are required');\n      expect(await page.isLoggedIn()).toBe(false);\n    });\n\n    test('should require both fields', async () => {\n      await page.clickSubmit();\n\n      const error = await page.getErrorMessage();\n      expect(error).toBe('Email and password are required');\n    });\n  });\n\n  describe('User Flow', () => {\n    test('should allow retry after failed login', async () => {\n      // First attempt with wrong credentials\n      await page.fillEmail('wrong@example.com');\n      await page.fillPassword('wrongpassword');\n      await page.clickSubmit();\n\n      expect(await page.getErrorMessage()).toBe('Invalid email or password');\n\n      // Second attempt with correct credentials\n      await page.navigate(); // Reset form\n      await page.fillEmail('test@example.com');\n      await page.fillPassword('password123');\n      await page.clickSubmit();\n\n      expect(await page.isLoggedIn()).toBe(true);\n      expect(await page.getErrorMessage()).toBeNull();\n    });\n  });\n});\n\n/*\nReal Playwright test would look like:\n\nimport { test, expect } from '@playwright/test';\n\ntest('should login successfully', async ({ page }) => {\n  await page.goto('http://localhost:3000/login');\n  await page.fill('#email', 'test@example.com');\n  await page.fill('#password', 'password123');\n  await page.click('button[type=\"submit\"]');\n\n  await expect(page).toHaveURL('http://localhost:3000/dashboard');\n  await expect(page.locator('.user-dashboard')).toBeVisible();\n});\n*/",
    "hints": [
      "Use Page Object pattern to encapsulate page interactions",
      "Test real user flows: fill form, submit, verify results",
      "Wait for navigation and element visibility in real browser tests",
      "Test both success and failure scenarios"
    ],
    "testCases": [
      {
        "input": "Fill email and password, click submit",
        "expectedOutput": "User logged in, no error message",
        "description": "Should login with valid credentials"
      },
      {
        "input": "Click submit without filling fields",
        "expectedOutput": "Error: Email and password are required",
        "description": "Should validate required fields"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex15",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "Performance Testing Utilities",
    "difficulty": 5,
    "description": "Create utilities for performance testing and benchmarking. Learn to measure execution time, memory usage, and detect performance regressions.",
    "starterCode": "// Performance testing utilities\ninterface PerformanceResult {\n  name: string;\n  duration: number;\n  iterations: number;\n  avgTime: number;\n  minTime: number;\n  maxTime: number;\n  memoryUsed?: number;\n}\n\n// TODO: Implement performance testing utilities\nclass PerformanceTester {\n  // Measure execution time of a function\n  async benchmark(\n    name: string,\n    fn: () => any,\n    iterations: number = 100\n  ): Promise<PerformanceResult> {\n    // Your implementation here\n  }\n\n  // Compare two implementations\n  async compare(\n    name1: string,\n    fn1: () => any,\n    name2: string,\n    fn2: () => any,\n    iterations: number = 100\n  ): Promise<{ winner: string; speedup: number }> {\n    // Your implementation here\n  }\n\n  // Assert performance threshold\n  assertPerformance(\n    result: PerformanceResult,\n    maxAvgTime: number\n  ): void {\n    // Your implementation here\n  }\n}\n\n// TODO: Write performance tests\ndescribe('Performance Tests', () => {\n  // Test: benchmark a function\n  // Test: compare two implementations\n  // Test: assert performance thresholds\n  // Test: detect performance regressions\n});",
    "solution": "// Performance testing utilities\ninterface PerformanceResult {\n  name: string;\n  duration: number;\n  iterations: number;\n  avgTime: number;\n  minTime: number;\n  maxTime: number;\n  memoryUsed?: number;\n}\n\n// Performance testing utilities\nclass PerformanceTester {\n  // Measure execution time of a function\n  async benchmark(\n    name: string,\n    fn: () => any,\n    iterations: number = 100\n  ): Promise<PerformanceResult> {\n    const times: number[] = [];\n    const startMemory = process.memoryUsage?.().heapUsed || 0;\n    const startTime = performance.now();\n\n    for (let i = 0; i < iterations; i++) {\n      const iterStart = performance.now();\n      await fn();\n      const iterEnd = performance.now();\n      times.push(iterEnd - iterStart);\n    }\n\n    const endTime = performance.now();\n    const endMemory = process.memoryUsage?.().heapUsed || 0;\n\n    return {\n      name,\n      duration: endTime - startTime,\n      iterations,\n      avgTime: times.reduce((a, b) => a + b, 0) / times.length,\n      minTime: Math.min(...times),\n      maxTime: Math.max(...times),\n      memoryUsed: endMemory - startMemory\n    };\n  }\n\n  // Compare two implementations\n  async compare(\n    name1: string,\n    fn1: () => any,\n    name2: string,\n    fn2: () => any,\n    iterations: number = 100\n  ): Promise<{ winner: string; speedup: number; results: [PerformanceResult, PerformanceResult] }> {\n    const result1 = await this.benchmark(name1, fn1, iterations);\n    const result2 = await this.benchmark(name2, fn2, iterations);\n\n    const winner = result1.avgTime < result2.avgTime ? name1 : name2;\n    const speedup = result1.avgTime < result2.avgTime\n      ? result2.avgTime / result1.avgTime\n      : result1.avgTime / result2.avgTime;\n\n    return { winner, speedup, results: [result1, result2] };\n  }\n\n  // Assert performance threshold\n  assertPerformance(\n    result: PerformanceResult,\n    maxAvgTime: number\n  ): void {\n    if (result.avgTime > maxAvgTime) {\n      throw new Error(\n        `Performance regression: ${result.name} took ${result.avgTime.toFixed(2)}ms ` +\n        `(expected < ${maxAvgTime}ms)`\n      );\n    }\n  }\n\n  // Generate performance report\n  generateReport(results: PerformanceResult[]): string {\n    let report = '\\n=== Performance Report ===\\n';\n    results.forEach(result => {\n      report += `\\n${result.name}:\\n`;\n      report += `  Iterations: ${result.iterations}\\n`;\n      report += `  Total: ${result.duration.toFixed(2)}ms\\n`;\n      report += `  Average: ${result.avgTime.toFixed(2)}ms\\n`;\n      report += `  Min: ${result.minTime.toFixed(2)}ms\\n`;\n      report += `  Max: ${result.maxTime.toFixed(2)}ms\\n`;\n      if (result.memoryUsed) {\n        report += `  Memory: ${(result.memoryUsed / 1024).toFixed(2)}KB\\n`;\n      }\n    });\n    return report;\n  }\n}\n\n// Performance tests\ndescribe('Performance Tests', () => {\n  let tester: PerformanceTester;\n\n  beforeEach(() => {\n    tester = new PerformanceTester();\n  });\n\n  describe('Benchmarking', () => {\n    test('should benchmark a simple function', async () => {\n      const result = await tester.benchmark(\n        'Simple addition',\n        () => {\n          let sum = 0;\n          for (let i = 0; i < 1000; i++) sum += i;\n          return sum;\n        },\n        50\n      );\n\n      expect(result.iterations).toBe(50);\n      expect(result.avgTime).toBeGreaterThan(0);\n      expect(result.minTime).toBeLessThanOrEqual(result.avgTime);\n      expect(result.maxTime).toBeGreaterThanOrEqual(result.avgTime);\n    });\n\n    test('should benchmark async function', async () => {\n      const result = await tester.benchmark(\n        'Async operation',\n        async () => {\n          await new Promise(resolve => setTimeout(resolve, 1));\n        },\n        10\n      );\n\n      expect(result.avgTime).toBeGreaterThan(1);\n      expect(result.iterations).toBe(10);\n    });\n  });\n\n  describe('Performance Comparison', () => {\n    test('should compare two implementations', async () => {\n      // Slower implementation\n      const slowSort = () => {\n        const arr = Array.from({ length: 100 }, () => Math.random());\n        return arr.sort((a, b) => a - b);\n      };\n\n      // Faster implementation (same result, but we'll simulate)\n      const fastSort = () => {\n        const arr = Array.from({ length: 100 }, () => Math.random());\n        return arr.sort((a, b) => a - b);\n      };\n\n      const comparison = await tester.compare(\n        'Implementation A',\n        slowSort,\n        'Implementation B',\n        fastSort,\n        20\n      );\n\n      expect(comparison.winner).toBeDefined();\n      expect(comparison.speedup).toBeGreaterThan(0);\n      expect(comparison.results).toHaveLength(2);\n    });\n\n    test('should identify faster implementation', async () => {\n      const slow = () => {\n        let result = 0;\n        for (let i = 0; i < 10000; i++) {\n          result += Math.sqrt(i);\n        }\n      };\n\n      const fast = () => {\n        let result = 0;\n        for (let i = 0; i < 1000; i++) {\n          result += i;\n        }\n      };\n\n      const comparison = await tester.compare('Slow', slow, 'Fast', fast, 10);\n      expect(comparison.winner).toBe('Fast');\n    });\n  });\n\n  describe('Performance Assertions', () => {\n    test('should pass when performance is acceptable', async () => {\n      const result = await tester.benchmark(\n        'Fast operation',\n        () => 1 + 1,\n        100\n      );\n\n      expect(() => {\n        tester.assertPerformance(result, 10); // Very generous threshold\n      }).not.toThrow();\n    });\n\n    test('should throw when performance threshold exceeded', async () => {\n      const result = await tester.benchmark(\n        'Slow operation',\n        () => {\n          let sum = 0;\n          for (let i = 0; i < 100000; i++) sum += i;\n        },\n        10\n      );\n\n      expect(() => {\n        tester.assertPerformance(result, 0.001); // Unrealistic threshold\n      }).toThrow('Performance regression');\n    });\n  });\n\n  describe('Performance Regression Detection', () => {\n    test('should detect performance regression', async () => {\n      // Baseline performance\n      const baseline = await tester.benchmark(\n        'Baseline',\n        () => {\n          let sum = 0;\n          for (let i = 0; i < 1000; i++) sum += i;\n        },\n        20\n      );\n\n      // Simulated regression (10x slower)\n      const regressed = await tester.benchmark(\n        'Regressed',\n        () => {\n          let sum = 0;\n          for (let i = 0; i < 10000; i++) sum += i;\n        },\n        20\n      );\n\n      // Allow 2x slowdown, but 10x should fail\n      expect(() => {\n        tester.assertPerformance(regressed, baseline.avgTime * 2);\n      }).toThrow();\n    });\n  });\n\n  describe('Report Generation', () => {\n    test('should generate performance report', async () => {\n      const result1 = await tester.benchmark('Test 1', () => 1 + 1, 10);\n      const result2 = await tester.benchmark('Test 2', () => 2 + 2, 10);\n\n      const report = tester.generateReport([result1, result2]);\n\n      expect(report).toContain('Performance Report');\n      expect(report).toContain('Test 1');\n      expect(report).toContain('Test 2');\n      expect(report).toContain('Average:');\n    });\n  });\n});",
    "hints": [
      "Use performance.now() for high-resolution timing",
      "Run multiple iterations to get stable averages",
      "Track min, max, and average times for comprehensive analysis",
      "Use process.memoryUsage() to measure memory consumption (Node.js)"
    ],
    "testCases": [
      {
        "input": "tester.benchmark(\"Test\", () => sum += 1, 100)",
        "expectedOutput": "PerformanceResult with avgTime, minTime, maxTime",
        "description": "Should measure function performance"
      },
      {
        "input": "tester.compare(\"Slow\", slowFn, \"Fast\", fastFn, 50)",
        "expectedOutput": "{ winner: \"Fast\", speedup: 2.5, ... }",
        "description": "Should identify faster implementation"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t5-ex16",
    "subjectId": "cs404",
    "topicId": "topic-5",
    "title": "CI Test Pipeline Configuration",
    "difficulty": 5,
    "description": "Create a CI/CD test pipeline configuration. Learn to automate testing, generate coverage reports, and enforce quality gates.",
    "starterCode": "// CI Pipeline configuration and testing utilities\ninterface TestResult {\n  passed: number;\n  failed: number;\n  skipped: number;\n  total: number;\n  duration: number;\n  coverage?: {\n    lines: number;\n    branches: number;\n    functions: number;\n    statements: number;\n  };\n}\n\ninterface PipelineConfig {\n  stages: string[];\n  testCommand: string;\n  coverageThreshold: number;\n  failOnWarnings: boolean;\n}\n\n// TODO: Implement CI pipeline utilities\nclass CIPipeline {\n  constructor(private config: PipelineConfig) {}\n\n  // Run test suite and collect results\n  async runTests(): Promise<TestResult> {\n    // Simulate running tests\n  }\n\n  // Generate coverage report\n  async generateCoverage(): Promise<TestResult['coverage']> {\n    // Simulate coverage generation\n  }\n\n  // Check if quality gates pass\n  checkQualityGates(result: TestResult): { passed: boolean; reasons: string[] } {\n    // Implement quality gate checks\n  }\n\n  // Run full pipeline\n  async run(): Promise<{ success: boolean; result: TestResult }> {\n    // Implement pipeline execution\n  }\n}\n\n// TODO: Write tests for CI pipeline\ndescribe('CI Pipeline Tests', () => {\n  // Test: should run all test stages\n  // Test: should fail if coverage below threshold\n  // Test: should enforce quality gates\n  // Test: should generate coverage report\n});",
    "solution": "// CI Pipeline configuration and testing utilities\ninterface TestResult {\n  passed: number;\n  failed: number;\n  skipped: number;\n  total: number;\n  duration: number;\n  coverage?: {\n    lines: number;\n    branches: number;\n    functions: number;\n    statements: number;\n  };\n}\n\ninterface PipelineConfig {\n  stages: string[];\n  testCommand: string;\n  coverageThreshold: number;\n  failOnWarnings: boolean;\n}\n\n// CI pipeline utilities\nclass CIPipeline {\n  constructor(private config: PipelineConfig) {}\n\n  // Run test suite and collect results\n  async runTests(): Promise<TestResult> {\n    // Simulate running tests with some randomness for realism\n    const total = 100;\n    const failed = Math.floor(Math.random() * 5);\n    const skipped = Math.floor(Math.random() * 3);\n    const passed = total - failed - skipped;\n\n    return {\n      passed,\n      failed,\n      skipped,\n      total,\n      duration: 1500 + Math.random() * 500\n    };\n  }\n\n  // Generate coverage report\n  async generateCoverage(): Promise<TestResult['coverage']> {\n    return {\n      lines: 85 + Math.random() * 15,\n      branches: 80 + Math.random() * 15,\n      functions: 90 + Math.random() * 10,\n      statements: 85 + Math.random() * 15\n    };\n  }\n\n  // Check if quality gates pass\n  checkQualityGates(result: TestResult): { passed: boolean; reasons: string[] } {\n    const reasons: string[] = [];\n\n    // Check for test failures\n    if (result.failed > 0) {\n      reasons.push(`${result.failed} test(s) failed`);\n    }\n\n    // Check coverage threshold\n    if (result.coverage) {\n      const avgCoverage = (\n        result.coverage.lines +\n        result.coverage.branches +\n        result.coverage.functions +\n        result.coverage.statements\n      ) / 4;\n\n      if (avgCoverage < this.config.coverageThreshold) {\n        reasons.push(\n          `Coverage ${avgCoverage.toFixed(2)}% below threshold ${this.config.coverageThreshold}%`\n        );\n      }\n    }\n\n    // Check for warnings (skipped tests)\n    if (this.config.failOnWarnings && result.skipped > 0) {\n      reasons.push(`${result.skipped} test(s) skipped`);\n    }\n\n    return {\n      passed: reasons.length === 0,\n      reasons\n    };\n  }\n\n  // Run full pipeline\n  async run(): Promise<{ success: boolean; result: TestResult; report: string }> {\n    console.log('Starting CI Pipeline...');\n\n    let report = '=== CI Pipeline Report ===\\n\\n';\n\n    // Execute stages\n    for (const stage of this.config.stages) {\n      report += `Stage: ${stage}\\n`;\n\n      if (stage === 'test') {\n        const result = await this.runTests();\n        report += `  Tests: ${result.passed}/${result.total} passed\\n`;\n        if (result.failed > 0) report += `  Failed: ${result.failed}\\n`;\n        if (result.skipped > 0) report += `  Skipped: ${result.skipped}\\n`;\n      }\n\n      if (stage === 'coverage') {\n        const coverage = await this.generateCoverage();\n        report += `  Coverage:\\n`;\n        report += `    Lines: ${coverage.lines.toFixed(2)}%\\n`;\n        report += `    Branches: ${coverage.branches.toFixed(2)}%\\n`;\n        report += `    Functions: ${coverage.functions.toFixed(2)}%\\n`;\n      }\n    }\n\n    // Get final results\n    const testResult = await this.runTests();\n    testResult.coverage = await this.generateCoverage();\n\n    const qualityGates = this.checkQualityGates(testResult);\n\n    report += `\\nQuality Gates: ${qualityGates.passed ? 'PASSED' : 'FAILED'}\\n`;\n    if (!qualityGates.passed) {\n      report += 'Reasons:\\n';\n      qualityGates.reasons.forEach(reason => {\n        report += `  - ${reason}\\n`;\n      });\n    }\n\n    return {\n      success: qualityGates.passed,\n      result: testResult,\n      report\n    };\n  }\n}\n\n// Tests for CI pipeline\ndescribe('CI Pipeline Tests', () => {\n  describe('Test Execution', () => {\n    test('should run all test stages', async () => {\n      const pipeline = new CIPipeline({\n        stages: ['lint', 'test', 'coverage'],\n        testCommand: 'npm test',\n        coverageThreshold: 80,\n        failOnWarnings: false\n      });\n\n      const result = await pipeline.runTests();\n\n      expect(result.total).toBeGreaterThan(0);\n      expect(result.passed + result.failed + result.skipped).toBe(result.total);\n      expect(result.duration).toBeGreaterThan(0);\n    });\n\n    test('should generate coverage report', async () => {\n      const pipeline = new CIPipeline({\n        stages: ['test', 'coverage'],\n        testCommand: 'npm test',\n        coverageThreshold: 80,\n        failOnWarnings: false\n      });\n\n      const coverage = await pipeline.generateCoverage();\n\n      expect(coverage).toBeDefined();\n      expect(coverage.lines).toBeGreaterThan(0);\n      expect(coverage.lines).toBeLessThanOrEqual(100);\n      expect(coverage.branches).toBeGreaterThan(0);\n      expect(coverage.functions).toBeGreaterThan(0);\n      expect(coverage.statements).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Quality Gates', () => {\n    test('should pass quality gates with good results', () => {\n      const pipeline = new CIPipeline({\n        stages: ['test'],\n        testCommand: 'npm test',\n        coverageThreshold: 80,\n        failOnWarnings: false\n      });\n\n      const result: TestResult = {\n        passed: 100,\n        failed: 0,\n        skipped: 0,\n        total: 100,\n        duration: 1500,\n        coverage: {\n          lines: 90,\n          branches: 85,\n          functions: 95,\n          statements: 90\n        }\n      };\n\n      const gates = pipeline.checkQualityGates(result);\n\n      expect(gates.passed).toBe(true);\n      expect(gates.reasons).toHaveLength(0);\n    });\n\n    test('should fail quality gates with test failures', () => {\n      const pipeline = new CIPipeline({\n        stages: ['test'],\n        testCommand: 'npm test',\n        coverageThreshold: 80,\n        failOnWarnings: false\n      });\n\n      const result: TestResult = {\n        passed: 95,\n        failed: 5,\n        skipped: 0,\n        total: 100,\n        duration: 1500,\n        coverage: {\n          lines: 90,\n          branches: 85,\n          functions: 95,\n          statements: 90\n        }\n      };\n\n      const gates = pipeline.checkQualityGates(result);\n\n      expect(gates.passed).toBe(false);\n      expect(gates.reasons).toContain('5 test(s) failed');\n    });\n\n    test('should fail quality gates with low coverage', () => {\n      const pipeline = new CIPipeline({\n        stages: ['test', 'coverage'],\n        testCommand: 'npm test',\n        coverageThreshold: 90,\n        failOnWarnings: false\n      });\n\n      const result: TestResult = {\n        passed: 100,\n        failed: 0,\n        skipped: 0,\n        total: 100,\n        duration: 1500,\n        coverage: {\n          lines: 70,\n          branches: 65,\n          functions: 75,\n          statements: 70\n        }\n      };\n\n      const gates = pipeline.checkQualityGates(result);\n\n      expect(gates.passed).toBe(false);\n      expect(gates.reasons.some(r => r.includes('Coverage'))).toBe(true);\n    });\n\n    test('should fail on warnings when configured', () => {\n      const pipeline = new CIPipeline({\n        stages: ['test'],\n        testCommand: 'npm test',\n        coverageThreshold: 80,\n        failOnWarnings: true\n      });\n\n      const result: TestResult = {\n        passed: 95,\n        failed: 0,\n        skipped: 5,\n        total: 100,\n        duration: 1500\n      };\n\n      const gates = pipeline.checkQualityGates(result);\n\n      expect(gates.passed).toBe(false);\n      expect(gates.reasons).toContain('5 test(s) skipped');\n    });\n  });\n\n  describe('Full Pipeline Execution', () => {\n    test('should run complete pipeline', async () => {\n      const pipeline = new CIPipeline({\n        stages: ['lint', 'test', 'coverage', 'build'],\n        testCommand: 'npm test',\n        coverageThreshold: 70,\n        failOnWarnings: false\n      });\n\n      const execution = await pipeline.run();\n\n      expect(execution.success).toBeDefined();\n      expect(execution.result).toBeDefined();\n      expect(execution.report).toContain('CI Pipeline Report');\n      expect(execution.report).toContain('Quality Gates');\n    });\n\n    test('should generate detailed report', async () => {\n      const pipeline = new CIPipeline({\n        stages: ['test', 'coverage'],\n        testCommand: 'npm test',\n        coverageThreshold: 80,\n        failOnWarnings: false\n      });\n\n      const execution = await pipeline.run();\n\n      expect(execution.report).toContain('Stage: test');\n      expect(execution.report).toContain('Stage: coverage');\n      expect(execution.report).toContain('Coverage:');\n      expect(execution.report).toContain('Lines:');\n    });\n  });\n\n  describe('Configuration Scenarios', () => {\n    test('should handle minimal configuration', async () => {\n      const pipeline = new CIPipeline({\n        stages: ['test'],\n        testCommand: 'npm test',\n        coverageThreshold: 0,\n        failOnWarnings: false\n      });\n\n      const execution = await pipeline.run();\n      expect(execution).toBeDefined();\n    });\n\n    test('should handle strict configuration', async () => {\n      const pipeline = new CIPipeline({\n        stages: ['lint', 'test', 'coverage', 'security', 'build'],\n        testCommand: 'npm test',\n        coverageThreshold: 95,\n        failOnWarnings: true\n      });\n\n      const execution = await pipeline.run();\n      expect(execution.report).toContain('lint');\n      expect(execution.report).toContain('security');\n    });\n  });\n});",
    "hints": [
      "CI pipelines automate testing, coverage, and quality checks",
      "Quality gates prevent merging code that fails standards",
      "Coverage thresholds ensure code is adequately tested",
      "Generate detailed reports for debugging pipeline failures"
    ],
    "testCases": [
      {
        "input": "pipeline.checkQualityGates({ passed: 100, failed: 0, coverage: 90% })",
        "expectedOutput": "{ passed: true, reasons: [] }",
        "description": "Should pass with good metrics"
      },
      {
        "input": "pipeline.checkQualityGates({ passed: 95, failed: 5, coverage: 70% })",
        "expectedOutput": "{ passed: false, reasons: [\"5 test(s) failed\", \"Coverage below threshold\"] }",
        "description": "Should fail with failures and low coverage"
      }
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex01",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Basic GitHub Actions Workflow",
    "difficulty": 1,
    "description": "Create a basic GitHub Actions workflow YAML configuration that runs on push to main branch and executes npm install and npm test commands.",
    "starterCode": "// Create a GitHub Actions workflow configuration\n// Return the YAML content as a string\nfunction createBasicWorkflow(): string {\n  // TODO: Return YAML configuration string\n  return ``;\n}",
    "solution": "function createBasicWorkflow(): string {\n  return `name: CI\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - name: Install dependencies\n        run: npm install\n      - name: Run tests\n        run: npm test`;\n}",
    "testCases": [
      {
        "input": "const yaml = createBasicWorkflow(); console.log(yaml.includes(\"npm install\") && yaml.includes(\"npm test\"))",
        "isHidden": false,
        "description": "Includes npm commands"
      },
      {
        "input": "const yaml = createBasicWorkflow(); console.log(yaml.includes(\"on:\") && yaml.includes(\"push:\"))",
        "isHidden": false,
        "description": "Has push trigger"
      },
      {
        "input": "const yaml = createBasicWorkflow(); console.log(yaml.includes(\"ubuntu-latest\"))",
        "isHidden": true,
        "description": "Uses Ubuntu runner"
      }
    ],
    "hints": [
      "Use YAML syntax with proper indentation",
      "Start with name and on triggers",
      "Define jobs with runs-on and steps",
      "Use actions/checkout to get the code"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex02",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Health Check Endpoint",
    "difficulty": 1,
    "description": "Create a health check endpoint function that returns status \"ok\" and the current timestamp.",
    "starterCode": "interface HealthCheckResponse {\n  status: string;\n  timestamp: number;\n}\n\nfunction healthCheck(): HealthCheckResponse {\n  // TODO: Return health check response\n}",
    "solution": "interface HealthCheckResponse {\n  status: string;\n  timestamp: number;\n}\n\nfunction healthCheck(): HealthCheckResponse {\n  return {\n    status: 'ok',\n    timestamp: Date.now(),\n  };\n}",
    "testCases": [
      {
        "input": "const result = healthCheck(); console.log(result.status === \"ok\")",
        "isHidden": false,
        "description": "Status is ok"
      },
      {
        "input": "const result = healthCheck(); console.log(typeof result.timestamp === \"number\")",
        "isHidden": false,
        "description": "Timestamp is a number"
      },
      {
        "input": "const r1 = healthCheck(); const r2 = healthCheck(); console.log(r2.timestamp >= r1.timestamp)",
        "isHidden": true,
        "description": "Timestamp updates"
      }
    ],
    "hints": [
      "Return an object with status and timestamp",
      "Use Date.now() for current timestamp",
      "Status should be \"ok\" when healthy"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex03",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Environment Variable Parser",
    "difficulty": 1,
    "description": "Create a function that parses environment variables from a .env file format string and returns them as an object.",
    "starterCode": "function parseEnvFile(content: string): Record<string, string> {\n  // TODO: Parse KEY=VALUE lines into object\n}",
    "solution": "function parseEnvFile(content: string): Record<string, string> {\n  const result: Record<string, string> = {};\n  const lines = content.split('\\n');\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('#')) continue;\n\n    const [key, ...valueParts] = trimmed.split('=');\n    if (key && valueParts.length > 0) {\n      result[key.trim()] = valueParts.join('=').trim();\n    }\n  }\n\n  return result;\n}",
    "testCases": [
      {
        "input": "const env = parseEnvFile(\"PORT=3000\\nHOST=localhost\"); console.log(env.PORT === \"3000\" && env.HOST === \"localhost\")",
        "isHidden": false,
        "description": "Parses basic key-value pairs"
      },
      {
        "input": "const env = parseEnvFile(\"# Comment\\nKEY=value\"); console.log(Object.keys(env).length === 1)",
        "isHidden": false,
        "description": "Ignores comments"
      },
      {
        "input": "const env = parseEnvFile(\"URL=http://example.com\"); console.log(env.URL === \"http://example.com\")",
        "isHidden": true,
        "description": "Handles values with ="
      }
    ],
    "hints": [
      "Split content by newlines",
      "Skip empty lines and comments (starting with #)",
      "Split each line by = to get key and value",
      "Handle values that contain = character"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex04",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "CI Pipeline with Multiple Stages",
    "difficulty": 2,
    "description": "Create a function that generates a GitHub Actions workflow with separate lint, test, and build stages that run in sequence.",
    "starterCode": "function createMultiStageWorkflow(): string {\n  // TODO: Create workflow with lint, test, build stages\n  return ``;\n}",
    "solution": "function createMultiStageWorkflow(): string {\n  return `name: CI Pipeline\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm ci\n      - run: npm run lint\n\n  test:\n    needs: lint\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm ci\n      - run: npm test\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm ci\n      - run: npm run build`;\n}",
    "testCases": [
      {
        "input": "const yaml = createMultiStageWorkflow(); console.log(yaml.includes(\"lint\") && yaml.includes(\"test\") && yaml.includes(\"build\"))",
        "isHidden": false,
        "description": "Has all three stages"
      },
      {
        "input": "const yaml = createMultiStageWorkflow(); console.log(yaml.includes(\"needs:\"))",
        "isHidden": false,
        "description": "Uses needs for sequencing"
      },
      {
        "input": "const yaml = createMultiStageWorkflow(); console.log(yaml.includes(\"pull_request\"))",
        "isHidden": true,
        "description": "Runs on PRs"
      }
    ],
    "hints": [
      "Create separate jobs for lint, test, and build",
      "Use needs keyword to create dependencies between jobs",
      "Each job should checkout code and setup Node.js",
      "Run appropriate npm commands in each job"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex05",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Basic Dockerfile Generator",
    "difficulty": 2,
    "description": "Create a function that generates a Dockerfile for a Node.js application with proper multi-stage build.",
    "starterCode": "function generateDockerfile(nodeVersion: string = '18'): string {\n  // TODO: Generate Dockerfile content\n  return ``;\n}",
    "solution": "function generateDockerfile(nodeVersion: string = '18'): string {\n  return `FROM node:${nodeVersion}-alpine AS builder\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci\n\nCOPY . .\nRUN npm run build\n\nFROM node:${nodeVersion}-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --production\n\nCOPY --from=builder /app/dist ./dist\n\nEXPOSE 3000\n\nCMD [\"node\", \"dist/index.js\"]`;\n}",
    "testCases": [
      {
        "input": "const df = generateDockerfile(); console.log(df.includes(\"FROM node:\") && df.includes(\"WORKDIR\"))",
        "isHidden": false,
        "description": "Has FROM and WORKDIR"
      },
      {
        "input": "const df = generateDockerfile(\"16\"); console.log(df.includes(\"node:16\"))",
        "isHidden": false,
        "description": "Uses specified version"
      },
      {
        "input": "const df = generateDockerfile(); console.log(df.includes(\"COPY --from=builder\"))",
        "isHidden": true,
        "description": "Multi-stage build"
      }
    ],
    "hints": [
      "Use multi-stage build with AS builder",
      "Copy package.json first for layer caching",
      "Run npm ci for reproducible builds",
      "Copy build artifacts from builder stage",
      "Use --production for final image"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex06",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Structured Logger",
    "difficulty": 2,
    "description": "Create a structured logger that outputs JSON-formatted logs with timestamp, level, message, and metadata.",
    "starterCode": "interface LogEntry {\n  timestamp: string;\n  level: string;\n  message: string;\n  metadata?: Record<string, any>;\n}\n\nclass StructuredLogger {\n  log(level: string, message: string, metadata?: Record<string, any>): string {\n    // TODO: Create and return JSON log entry\n  }\n\n  info(message: string, metadata?: Record<string, any>): string {\n    // TODO: Log at info level\n  }\n\n  error(message: string, metadata?: Record<string, any>): string {\n    // TODO: Log at error level\n  }\n}",
    "solution": "interface LogEntry {\n  timestamp: string;\n  level: string;\n  message: string;\n  metadata?: Record<string, any>;\n}\n\nclass StructuredLogger {\n  log(level: string, message: string, metadata?: Record<string, any>): string {\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n    };\n\n    if (metadata && Object.keys(metadata).length > 0) {\n      entry.metadata = metadata;\n    }\n\n    return JSON.stringify(entry);\n  }\n\n  info(message: string, metadata?: Record<string, any>): string {\n    return this.log('info', message, metadata);\n  }\n\n  error(message: string, metadata?: Record<string, any>): string {\n    return this.log('error', message, metadata);\n  }\n}",
    "testCases": [
      {
        "input": "const logger = new StructuredLogger(); const log = JSON.parse(logger.info(\"test\")); console.log(log.level === \"info\" && log.message === \"test\")",
        "isHidden": false,
        "description": "Logs info messages"
      },
      {
        "input": "const logger = new StructuredLogger(); const log = JSON.parse(logger.error(\"err\", {code: 500})); console.log(log.metadata.code === 500)",
        "isHidden": false,
        "description": "Includes metadata"
      },
      {
        "input": "const logger = new StructuredLogger(); const log = JSON.parse(logger.log(\"warn\", \"msg\")); console.log(log.timestamp && log.level)",
        "isHidden": true,
        "description": "Has timestamp and level"
      }
    ],
    "hints": [
      "Create log entry object with required fields",
      "Use new Date().toISOString() for timestamp",
      "Only include metadata if provided",
      "Return JSON.stringify of the entry"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex07",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Docker Compose Configuration",
    "difficulty": 3,
    "description": "Create a function that generates a docker-compose.yml for an app with web service and PostgreSQL database.",
    "starterCode": "function generateDockerCompose(): string {\n  // TODO: Generate docker-compose.yml content\n  return ``;\n}",
    "solution": "function generateDockerCompose(): string {\n  return `version: '3.8'\n\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DATABASE_URL=postgres://user:password@db:5432/myapp\n      - NODE_ENV=production\n    depends_on:\n      - db\n    restart: unless-stopped\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=myapp\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:`;\n}",
    "testCases": [
      {
        "input": "const dc = generateDockerCompose(); console.log(dc.includes(\"services:\") && dc.includes(\"web:\") && dc.includes(\"db:\"))",
        "isHidden": false,
        "description": "Has services section"
      },
      {
        "input": "const dc = generateDockerCompose(); console.log(dc.includes(\"depends_on\"))",
        "isHidden": false,
        "description": "Web depends on db"
      },
      {
        "input": "const dc = generateDockerCompose(); console.log(dc.includes(\"volumes:\") && dc.includes(\"postgres_data\"))",
        "isHidden": true,
        "description": "Has persistent volumes"
      }
    ],
    "hints": [
      "Use version 3.8 for docker-compose",
      "Define web and db services",
      "Web service should depend_on db",
      "Use environment variables for database connection",
      "Create named volume for database persistence"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex08",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Environment-Aware Configuration",
    "difficulty": 3,
    "description": "Create a configuration manager that loads different settings based on NODE_ENV (development, staging, production).",
    "starterCode": "interface Config {\n  environment: string;\n  port: number;\n  databaseUrl: string;\n  logLevel: string;\n  enableDebug: boolean;\n}\n\nclass ConfigManager {\n  getConfig(env: string): Config {\n    // TODO: Return environment-specific config\n  }\n}",
    "solution": "interface Config {\n  environment: string;\n  port: number;\n  databaseUrl: string;\n  logLevel: string;\n  enableDebug: boolean;\n}\n\nclass ConfigManager {\n  getConfig(env: string): Config {\n    const baseConfig = {\n      environment: env,\n    };\n\n    switch (env) {\n      case 'production':\n        return {\n          ...baseConfig,\n          port: 80,\n          databaseUrl: process.env.DATABASE_URL || 'postgres://prod-db:5432/app',\n          logLevel: 'error',\n          enableDebug: false,\n        };\n\n      case 'staging':\n        return {\n          ...baseConfig,\n          port: 3000,\n          databaseUrl: process.env.DATABASE_URL || 'postgres://staging-db:5432/app',\n          logLevel: 'warn',\n          enableDebug: true,\n        };\n\n      case 'development':\n      default:\n        return {\n          ...baseConfig,\n          port: 3000,\n          databaseUrl: 'postgres://localhost:5432/app_dev',\n          logLevel: 'debug',\n          enableDebug: true,\n        };\n    }\n  }\n}",
    "testCases": [
      {
        "input": "const cm = new ConfigManager(); const cfg = cm.getConfig(\"production\"); console.log(cfg.enableDebug === false && cfg.logLevel === \"error\")",
        "isHidden": false,
        "description": "Production disables debug"
      },
      {
        "input": "const cm = new ConfigManager(); const cfg = cm.getConfig(\"development\"); console.log(cfg.enableDebug === true && cfg.logLevel === \"debug\")",
        "isHidden": false,
        "description": "Development enables debug"
      },
      {
        "input": "const cm = new ConfigManager(); const cfg = cm.getConfig(\"staging\"); console.log(cfg.port === 3000 && cfg.logLevel === \"warn\")",
        "isHidden": true,
        "description": "Staging config"
      }
    ],
    "hints": [
      "Use switch statement for different environments",
      "Production should have minimal logging and no debug",
      "Development should have verbose logging",
      "Allow environment variable overrides"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex09",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Metric Collector",
    "difficulty": 3,
    "description": "Create a metric collector that tracks request count, response times, and calculates average response time.",
    "starterCode": "interface Metrics {\n  requestCount: number;\n  totalResponseTime: number;\n  averageResponseTime: number;\n  errors: number;\n}\n\nclass MetricCollector {\n  private requestCount = 0;\n  private totalResponseTime = 0;\n  private errors = 0;\n\n  recordRequest(responseTimeMs: number, isError: boolean = false): void {\n    // TODO: Record metrics\n  }\n\n  getMetrics(): Metrics {\n    // TODO: Return current metrics\n  }\n\n  reset(): void {\n    // TODO: Reset all metrics\n  }\n}",
    "solution": "interface Metrics {\n  requestCount: number;\n  totalResponseTime: number;\n  averageResponseTime: number;\n  errors: number;\n}\n\nclass MetricCollector {\n  private requestCount = 0;\n  private totalResponseTime = 0;\n  private errors = 0;\n\n  recordRequest(responseTimeMs: number, isError: boolean = false): void {\n    this.requestCount++;\n    this.totalResponseTime += responseTimeMs;\n    if (isError) {\n      this.errors++;\n    }\n  }\n\n  getMetrics(): Metrics {\n    return {\n      requestCount: this.requestCount,\n      totalResponseTime: this.totalResponseTime,\n      averageResponseTime: this.requestCount > 0\n        ? this.totalResponseTime / this.requestCount\n        : 0,\n      errors: this.errors,\n    };\n  }\n\n  reset(): void {\n    this.requestCount = 0;\n    this.totalResponseTime = 0;\n    this.errors = 0;\n  }\n}",
    "testCases": [
      {
        "input": "const mc = new MetricCollector(); mc.recordRequest(100); mc.recordRequest(200); const m = mc.getMetrics(); console.log(m.requestCount === 2 && m.averageResponseTime === 150)",
        "isHidden": false,
        "description": "Tracks requests and average"
      },
      {
        "input": "const mc = new MetricCollector(); mc.recordRequest(100, true); const m = mc.getMetrics(); console.log(m.errors === 1)",
        "isHidden": false,
        "description": "Counts errors"
      },
      {
        "input": "const mc = new MetricCollector(); mc.recordRequest(100); mc.reset(); const m = mc.getMetrics(); console.log(m.requestCount === 0)",
        "isHidden": true,
        "description": "Reset clears metrics"
      }
    ],
    "hints": [
      "Increment counters in recordRequest",
      "Track total response time for average calculation",
      "Average = total / count (handle division by zero)",
      "Reset should clear all private fields"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex10",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Vercel Deployment Configuration",
    "difficulty": 3,
    "description": "Create a function that generates a vercel.json configuration file with redirects, headers, and environment variables.",
    "starterCode": "function generateVercelConfig(): string {\n  // TODO: Generate vercel.json configuration\n  return ``;\n}",
    "solution": "function generateVercelConfig(): string {\n  const config = {\n    version: 2,\n    builds: [\n      {\n        src: 'package.json',\n        use: '@vercel/node',\n      },\n    ],\n    routes: [\n      {\n        src: '/api/(.*)',\n        dest: '/api/$1',\n      },\n      {\n        src: '/(.*)',\n        dest: '/$1',\n      },\n    ],\n    headers: [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff',\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY',\n          },\n          {\n            key: 'X-XSS-Protection',\n            value: '1; mode=block',\n          },\n        ],\n      },\n    ],\n    env: {\n      NODE_ENV: 'production',\n    },\n  };\n\n  return JSON.stringify(config, null, 2);\n}",
    "testCases": [
      {
        "input": "const cfg = JSON.parse(generateVercelConfig()); console.log(cfg.version === 2 && cfg.builds)",
        "isHidden": false,
        "description": "Has version and builds"
      },
      {
        "input": "const cfg = JSON.parse(generateVercelConfig()); console.log(cfg.headers && cfg.headers.length > 0)",
        "isHidden": false,
        "description": "Includes security headers"
      },
      {
        "input": "const cfg = JSON.parse(generateVercelConfig()); console.log(cfg.env.NODE_ENV === \"production\")",
        "isHidden": true,
        "description": "Sets NODE_ENV"
      }
    ],
    "hints": [
      "Use version 2 of Vercel config",
      "Define builds with @vercel/node",
      "Add security headers (X-Frame-Options, etc.)",
      "Set up routing for API and static files"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex11",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Database Backup Script Generator",
    "difficulty": 4,
    "description": "Create a function that generates a PostgreSQL backup script with compression and timestamped filenames.",
    "starterCode": "interface BackupConfig {\n  host: string;\n  database: string;\n  user: string;\n  backupDir: string;\n}\n\nfunction generateBackupScript(config: BackupConfig): string {\n  // TODO: Generate backup shell script\n  return ``;\n}",
    "solution": "interface BackupConfig {\n  host: string;\n  database: string;\n  user: string;\n  backupDir: string;\n}\n\nfunction generateBackupScript(config: BackupConfig): string {\n  return `#!/bin/bash\n\n# PostgreSQL Backup Script\n# Generated: ${new Date().toISOString()}\n\nset -e\n\nBACKUP_DIR=\"${config.backupDir}\"\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nBACKUP_FILE=\"${BACKUP_DIR}/${config.database}_${TIMESTAMP}.sql.gz\"\n\n# Create backup directory if it doesn't exist\nmkdir -p \"${BACKUP_DIR}\"\n\n# Perform backup\necho \"Starting backup of ${config.database}...\"\npg_dump -h ${config.host} -U ${config.user} -d ${config.database} | gzip > \"${BACKUP_FILE}\"\n\n# Verify backup\nif [ -f \"${BACKUP_FILE}\" ]; then\n  SIZE=$(du -h \"${BACKUP_FILE}\" | cut -f1)\n  echo \"Backup completed: ${BACKUP_FILE} (${SIZE})\"\nelse\n  echo \"Backup failed!\" >&2\n  exit 1\nfi\n\n# Remove backups older than 30 days\nfind \"${BACKUP_DIR}\" -name \"*.sql.gz\" -mtime +30 -delete\necho \"Old backups cleaned up\"\n\nexit 0`;\n}",
    "testCases": [
      {
        "input": "const script = generateBackupScript({host: \"localhost\", database: \"mydb\", user: \"admin\", backupDir: \"/backups\"}); console.log(script.includes(\"pg_dump\") && script.includes(\"gzip\"))",
        "isHidden": false,
        "description": "Uses pg_dump with compression"
      },
      {
        "input": "const script = generateBackupScript({host: \"db.example.com\", database: \"prod\", user: \"backup\", backupDir: \"/data\"}); console.log(script.includes(\"TIMESTAMP\"))",
        "isHidden": false,
        "description": "Includes timestamp in filename"
      },
      {
        "input": "const script = generateBackupScript({host: \"localhost\", database: \"test\", user: \"user\", backupDir: \"/tmp\"}); console.log(script.includes(\"mtime +30\"))",
        "isHidden": true,
        "description": "Cleans up old backups"
      }
    ],
    "hints": [
      "Start with #!/bin/bash shebang",
      "Use date command for timestamp",
      "Pipe pg_dump output to gzip",
      "Add error checking and cleanup of old files",
      "Use set -e to exit on error"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex12",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Feature Flag System",
    "difficulty": 4,
    "description": "Create a feature flag system that can enable/disable features based on environment and user percentage rollout.",
    "starterCode": "interface FeatureFlag {\n  name: string;\n  enabled: boolean;\n  environments: string[];\n  rolloutPercentage: number;\n}\n\nclass FeatureFlagManager {\n  private flags: Map<string, FeatureFlag> = new Map();\n\n  addFlag(flag: FeatureFlag): void {\n    // TODO: Add feature flag\n  }\n\n  isEnabled(flagName: string, environment: string, userId?: string): boolean {\n    // TODO: Check if feature is enabled\n  }\n\n  private hashUserId(userId: string): number {\n    // TODO: Simple hash function for consistent rollout\n  }\n}",
    "solution": "interface FeatureFlag {\n  name: string;\n  enabled: boolean;\n  environments: string[];\n  rolloutPercentage: number;\n}\n\nclass FeatureFlagManager {\n  private flags: Map<string, FeatureFlag> = new Map();\n\n  addFlag(flag: FeatureFlag): void {\n    this.flags.set(flag.name, flag);\n  }\n\n  isEnabled(flagName: string, environment: string, userId?: string): boolean {\n    const flag = this.flags.get(flagName);\n\n    if (!flag) {\n      return false;\n    }\n\n    if (!flag.enabled) {\n      return false;\n    }\n\n    if (!flag.environments.includes(environment)) {\n      return false;\n    }\n\n    // Check rollout percentage\n    if (flag.rolloutPercentage < 100 && userId) {\n      const hash = this.hashUserId(userId);\n      const userPercentage = hash % 100;\n      return userPercentage < flag.rolloutPercentage;\n    }\n\n    return flag.rolloutPercentage === 100;\n  }\n\n  private hashUserId(userId: string): number {\n    let hash = 0;\n    for (let i = 0; i < userId.length; i++) {\n      hash = ((hash << 5) - hash) + userId.charCodeAt(i);\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n}",
    "testCases": [
      {
        "input": "const fm = new FeatureFlagManager(); fm.addFlag({name: \"new-ui\", enabled: true, environments: [\"production\"], rolloutPercentage: 100}); console.log(fm.isEnabled(\"new-ui\", \"production\"))",
        "isHidden": false,
        "description": "100% rollout enabled"
      },
      {
        "input": "const fm = new FeatureFlagManager(); fm.addFlag({name: \"beta\", enabled: true, environments: [\"staging\"], rolloutPercentage: 100}); console.log(!fm.isEnabled(\"beta\", \"production\"))",
        "isHidden": false,
        "description": "Environment restrictions work"
      },
      {
        "input": "const fm = new FeatureFlagManager(); fm.addFlag({name: \"test\", enabled: false, environments: [\"production\"], rolloutPercentage: 100}); console.log(!fm.isEnabled(\"test\", \"production\"))",
        "isHidden": true,
        "description": "Disabled flags return false"
      }
    ],
    "hints": [
      "Check if flag exists and is enabled",
      "Verify environment is in allowed list",
      "For percentage rollout, hash userId consistently",
      "Return true only if all conditions pass"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex13",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Rollback Strategy Manager",
    "difficulty": 4,
    "description": "Create a deployment rollback manager that tracks versions and can rollback to previous stable version.",
    "starterCode": "interface Deployment {\n  version: string;\n  timestamp: number;\n  status: 'success' | 'failed' | 'rolled-back';\n  healthCheckPassed: boolean;\n}\n\nclass RollbackManager {\n  private deployments: Deployment[] = [];\n\n  recordDeployment(version: string, healthCheckPassed: boolean): void {\n    // TODO: Record deployment\n  }\n\n  shouldRollback(): boolean {\n    // TODO: Determine if rollback needed\n  }\n\n  rollback(): string | null {\n    // TODO: Perform rollback to last stable version\n  }\n\n  getCurrentVersion(): string | null {\n    // TODO: Get current deployed version\n  }\n}",
    "solution": "interface Deployment {\n  version: string;\n  timestamp: number;\n  status: 'success' | 'failed' | 'rolled-back';\n  healthCheckPassed: boolean;\n}\n\nclass RollbackManager {\n  private deployments: Deployment[] = [];\n\n  recordDeployment(version: string, healthCheckPassed: boolean): void {\n    const deployment: Deployment = {\n      version,\n      timestamp: Date.now(),\n      status: healthCheckPassed ? 'success' : 'failed',\n      healthCheckPassed,\n    };\n    this.deployments.push(deployment);\n  }\n\n  shouldRollback(): boolean {\n    if (this.deployments.length === 0) {\n      return false;\n    }\n\n    const latest = this.deployments[this.deployments.length - 1];\n    return !latest.healthCheckPassed;\n  }\n\n  rollback(): string | null {\n    if (this.deployments.length < 2) {\n      return null;\n    }\n\n    // Mark current as rolled back\n    const current = this.deployments[this.deployments.length - 1];\n    current.status = 'rolled-back';\n\n    // Find last successful deployment\n    for (let i = this.deployments.length - 2; i >= 0; i--) {\n      if (this.deployments[i].status === 'success' && this.deployments[i].healthCheckPassed) {\n        return this.deployments[i].version;\n      }\n    }\n\n    return null;\n  }\n\n  getCurrentVersion(): string | null {\n    if (this.deployments.length === 0) {\n      return null;\n    }\n\n    // Find the most recent non-rolled-back deployment\n    for (let i = this.deployments.length - 1; i >= 0; i--) {\n      if (this.deployments[i].status !== 'rolled-back') {\n        return this.deployments[i].version;\n      }\n    }\n\n    return null;\n  }\n}",
    "testCases": [
      {
        "input": "const rm = new RollbackManager(); rm.recordDeployment(\"v1.0\", true); rm.recordDeployment(\"v1.1\", false); console.log(rm.shouldRollback())",
        "isHidden": false,
        "description": "Detects failed deployment"
      },
      {
        "input": "const rm = new RollbackManager(); rm.recordDeployment(\"v1.0\", true); rm.recordDeployment(\"v1.1\", false); const prev = rm.rollback(); console.log(prev === \"v1.0\")",
        "isHidden": false,
        "description": "Rolls back to stable version"
      },
      {
        "input": "const rm = new RollbackManager(); rm.recordDeployment(\"v1.0\", true); console.log(rm.getCurrentVersion() === \"v1.0\")",
        "isHidden": true,
        "description": "Tracks current version"
      }
    ],
    "hints": [
      "Store deployments in chronological order",
      "Track health check results",
      "Rollback should find last successful deployment",
      "Mark rolled-back deployments appropriately"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex14",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Blue-Green Deployment Router",
    "difficulty": 5,
    "description": "Create a blue-green deployment router that can switch traffic between two environments and handle gradual migration.",
    "starterCode": "interface Environment {\n  name: 'blue' | 'green';\n  version: string;\n  healthy: boolean;\n}\n\nclass BlueGreenRouter {\n  private blue: Environment;\n  private green: Environment;\n  private activeEnvironment: 'blue' | 'green' = 'blue';\n  private trafficSplit: number = 100; // Percentage to active\n\n  constructor() {\n    this.blue = { name: 'blue', version: '0.0.0', healthy: true };\n    this.green = { name: 'green', version: '0.0.0', healthy: true };\n  }\n\n  deployToInactive(version: string): 'blue' | 'green' {\n    // TODO: Deploy to inactive environment\n  }\n\n  switchTraffic(percentage: number): void {\n    // TODO: Gradually shift traffic (0-100)\n  }\n\n  completeSwitch(): void {\n    // TODO: Complete switch to new environment\n  }\n\n  routeRequest(requestId: string): 'blue' | 'green' {\n    // TODO: Route request based on traffic split\n  }\n\n  getStatus(): { active: string; version: string; split: number } {\n    // TODO: Return current status\n  }\n}",
    "solution": "interface Environment {\n  name: 'blue' | 'green';\n  version: string;\n  healthy: boolean;\n}\n\nclass BlueGreenRouter {\n  private blue: Environment;\n  private green: Environment;\n  private activeEnvironment: 'blue' | 'green' = 'blue';\n  private trafficSplit: number = 100; // Percentage to active\n\n  constructor() {\n    this.blue = { name: 'blue', version: '0.0.0', healthy: true };\n    this.green = { name: 'green', version: '0.0.0', healthy: true };\n  }\n\n  deployToInactive(version: string): 'blue' | 'green' {\n    const inactive = this.activeEnvironment === 'blue' ? 'green' : 'blue';\n    const env = inactive === 'blue' ? this.blue : this.green;\n    env.version = version;\n    env.healthy = true;\n    return inactive;\n  }\n\n  switchTraffic(percentage: number): void {\n    // Clamp percentage between 0 and 100\n    this.trafficSplit = Math.max(0, Math.min(100, percentage));\n  }\n\n  completeSwitch(): void {\n    // Switch active environment\n    this.activeEnvironment = this.activeEnvironment === 'blue' ? 'green' : 'blue';\n    this.trafficSplit = 100;\n  }\n\n  routeRequest(requestId: string): 'blue' | 'green' {\n    if (this.trafficSplit === 100) {\n      return this.activeEnvironment;\n    }\n\n    if (this.trafficSplit === 0) {\n      return this.activeEnvironment === 'blue' ? 'green' : 'blue';\n    }\n\n    // Hash request ID for consistent routing\n    let hash = 0;\n    for (let i = 0; i < requestId.length; i++) {\n      hash = ((hash << 5) - hash) + requestId.charCodeAt(i);\n      hash = hash & hash;\n    }\n\n    const percentage = Math.abs(hash) % 100;\n\n    if (percentage < this.trafficSplit) {\n      return this.activeEnvironment;\n    } else {\n      return this.activeEnvironment === 'blue' ? 'green' : 'blue';\n    }\n  }\n\n  getStatus(): { active: string; version: string; split: number } {\n    const activeEnv = this.activeEnvironment === 'blue' ? this.blue : this.green;\n    return {\n      active: this.activeEnvironment,\n      version: activeEnv.version,\n      split: this.trafficSplit,\n    };\n  }\n}",
    "testCases": [
      {
        "input": "const router = new BlueGreenRouter(); const inactive = router.deployToInactive(\"v2.0\"); console.log(inactive === \"green\")",
        "isHidden": false,
        "description": "Deploys to inactive env"
      },
      {
        "input": "const router = new BlueGreenRouter(); router.switchTraffic(50); const status = router.getStatus(); console.log(status.split === 50)",
        "isHidden": false,
        "description": "Splits traffic"
      },
      {
        "input": "const router = new BlueGreenRouter(); router.deployToInactive(\"v2.0\"); router.completeSwitch(); console.log(router.getStatus().active === \"green\")",
        "isHidden": true,
        "description": "Completes switch"
      }
    ],
    "hints": [
      "Track which environment is active",
      "Deploy new version to inactive environment",
      "Use traffic split percentage for gradual migration",
      "Hash request ID for consistent routing",
      "Complete switch changes active environment"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex15",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "SSL/TLS Configuration Validator",
    "difficulty": 5,
    "description": "Create an SSL/TLS configuration validator that checks certificate expiry, protocols, and cipher suites.",
    "starterCode": "interface SSLConfig {\n  certificateExpiry: Date;\n  protocols: string[];\n  cipherSuites: string[];\n  httpsOnly: boolean;\n  hsts: boolean;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  warnings: string[];\n  errors: string[];\n}\n\nclass SSLValidator {\n  private readonly SECURE_PROTOCOLS = ['TLSv1.2', 'TLSv1.3'];\n  private readonly INSECURE_CIPHERS = ['RC4', 'MD5', 'DES', '3DES'];\n\n  validate(config: SSLConfig): ValidationResult {\n    // TODO: Validate SSL configuration\n  }\n\n  private checkCertificateExpiry(expiry: Date): { error?: string; warning?: string } {\n    // TODO: Check certificate expiration\n  }\n\n  private checkProtocols(protocols: string[]): { errors: string[]; warnings: string[] } {\n    // TODO: Check TLS protocols\n  }\n\n  private checkCiphers(cipherSuites: string[]): { errors: string[]; warnings: string[] } {\n    // TODO: Check cipher suites\n  }\n}",
    "solution": "interface SSLConfig {\n  certificateExpiry: Date;\n  protocols: string[];\n  cipherSuites: string[];\n  httpsOnly: boolean;\n  hsts: boolean;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  warnings: string[];\n  errors: string[];\n}\n\nclass SSLValidator {\n  private readonly SECURE_PROTOCOLS = ['TLSv1.2', 'TLSv1.3'];\n  private readonly INSECURE_CIPHERS = ['RC4', 'MD5', 'DES', '3DES'];\n\n  validate(config: SSLConfig): ValidationResult {\n    const warnings: string[] = [];\n    const errors: string[] = [];\n\n    // Check certificate expiry\n    const expiryCheck = this.checkCertificateExpiry(config.certificateExpiry);\n    if (expiryCheck.error) errors.push(expiryCheck.error);\n    if (expiryCheck.warning) warnings.push(expiryCheck.warning);\n\n    // Check protocols\n    const protocolCheck = this.checkProtocols(config.protocols);\n    errors.push(...protocolCheck.errors);\n    warnings.push(...protocolCheck.warnings);\n\n    // Check ciphers\n    const cipherCheck = this.checkCiphers(config.cipherSuites);\n    errors.push(...cipherCheck.errors);\n    warnings.push(...cipherCheck.warnings);\n\n    // Check HTTPS and HSTS\n    if (!config.httpsOnly) {\n      errors.push('HTTPS-only mode is not enabled');\n    }\n\n    if (!config.hsts) {\n      warnings.push('HSTS header is not enabled');\n    }\n\n    return {\n      valid: errors.length === 0,\n      warnings,\n      errors,\n    };\n  }\n\n  private checkCertificateExpiry(expiry: Date): { error?: string; warning?: string } {\n    const now = new Date();\n    const daysUntilExpiry = Math.floor((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n\n    if (daysUntilExpiry < 0) {\n      return { error: 'Certificate has expired' };\n    }\n\n    if (daysUntilExpiry < 30) {\n      return { warning: `Certificate expires in ${daysUntilExpiry} days` };\n    }\n\n    return {};\n  }\n\n  private checkProtocols(protocols: string[]): { errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (protocols.length === 0) {\n      errors.push('No TLS protocols configured');\n      return { errors, warnings };\n    }\n\n    const hasSecureProtocol = protocols.some(p => this.SECURE_PROTOCOLS.includes(p));\n    if (!hasSecureProtocol) {\n      errors.push('No secure TLS protocol (TLSv1.2 or TLSv1.3) enabled');\n    }\n\n    const insecureProtocols = protocols.filter(p => !this.SECURE_PROTOCOLS.includes(p));\n    if (insecureProtocols.length > 0) {\n      warnings.push(`Insecure protocols enabled: ${insecureProtocols.join(', ')}`);\n    }\n\n    return { errors, warnings };\n  }\n\n  private checkCiphers(cipherSuites: string[]): { errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (cipherSuites.length === 0) {\n      errors.push('No cipher suites configured');\n      return { errors, warnings };\n    }\n\n    const insecureCiphers = cipherSuites.filter(cipher =>\n      this.INSECURE_CIPHERS.some(insecure => cipher.includes(insecure))\n    );\n\n    if (insecureCiphers.length > 0) {\n      errors.push(`Insecure ciphers detected: ${insecureCiphers.join(', ')}`);\n    }\n\n    return { errors, warnings };\n  }\n}",
    "testCases": [
      {
        "input": "const validator = new SSLValidator(); const result = validator.validate({certificateExpiry: new Date(Date.now() - 1000), protocols: [\"TLSv1.2\"], cipherSuites: [\"AES256\"], httpsOnly: true, hsts: true}); console.log(!result.valid && result.errors.some(e => e.includes(\"expired\")))",
        "isHidden": false,
        "description": "Detects expired certificate"
      },
      {
        "input": "const validator = new SSLValidator(); const result = validator.validate({certificateExpiry: new Date(Date.now() + 100000000), protocols: [\"TLSv1.0\"], cipherSuites: [\"AES256\"], httpsOnly: true, hsts: true}); console.log(result.warnings.some(w => w.includes(\"Insecure\")))",
        "isHidden": false,
        "description": "Warns about insecure protocols"
      },
      {
        "input": "const validator = new SSLValidator(); const result = validator.validate({certificateExpiry: new Date(Date.now() + 100000000), protocols: [\"TLSv1.3\"], cipherSuites: [\"RC4-SHA\"], httpsOnly: true, hsts: true}); console.log(!result.valid && result.errors.some(e => e.includes(\"cipher\")))",
        "isHidden": true,
        "description": "Detects insecure ciphers"
      }
    ],
    "hints": [
      "Check certificate expiry date against current time",
      "Validate TLS protocols (1.2 and 1.3 are secure)",
      "Check for insecure ciphers (RC4, MD5, DES)",
      "Verify HTTPS-only and HSTS settings",
      "Separate errors (must fix) from warnings (should fix)"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-t6-ex16",
    "subjectId": "cs404",
    "topicId": "topic-6",
    "title": "Production Readiness Checklist",
    "difficulty": 5,
    "description": "Create a production readiness checker that validates all deployment requirements are met before going live.",
    "starterCode": "interface ChecklistItem {\n  category: string;\n  item: string;\n  required: boolean;\n  checked: boolean;\n}\n\ninterface ReadinessReport {\n  ready: boolean;\n  completionPercentage: number;\n  categories: {\n    [category: string]: {\n      total: number;\n      completed: number;\n      blocking: number;\n    };\n  };\n  blockers: string[];\n}\n\nclass ProductionReadinessChecker {\n  private checklist: ChecklistItem[] = [];\n\n  addItem(category: string, item: string, required: boolean = true): void {\n    // TODO: Add checklist item\n  }\n\n  checkItem(category: string, item: string): void {\n    // TODO: Mark item as checked\n  }\n\n  getReport(): ReadinessReport {\n    // TODO: Generate readiness report\n  }\n\n  isReady(): boolean {\n    // TODO: Check if all required items are complete\n  }\n}",
    "solution": "interface ChecklistItem {\n  category: string;\n  item: string;\n  required: boolean;\n  checked: boolean;\n}\n\ninterface ReadinessReport {\n  ready: boolean;\n  completionPercentage: number;\n  categories: {\n    [category: string]: {\n      total: number;\n      completed: number;\n      blocking: number;\n    };\n  };\n  blockers: string[];\n}\n\nclass ProductionReadinessChecker {\n  private checklist: ChecklistItem[] = [];\n\n  addItem(category: string, item: string, required: boolean = true): void {\n    this.checklist.push({\n      category,\n      item,\n      required,\n      checked: false,\n    });\n  }\n\n  checkItem(category: string, item: string): void {\n    const checklistItem = this.checklist.find(\n      i => i.category === category && i.item === item\n    );\n\n    if (checklistItem) {\n      checklistItem.checked = true;\n    }\n  }\n\n  getReport(): ReadinessReport {\n    const categories: ReadinessReport['categories'] = {};\n    const blockers: string[] = [];\n\n    // Group by category\n    for (const item of this.checklist) {\n      if (!categories[item.category]) {\n        categories[item.category] = {\n          total: 0,\n          completed: 0,\n          blocking: 0,\n        };\n      }\n\n      categories[item.category].total++;\n\n      if (item.checked) {\n        categories[item.category].completed++;\n      } else if (item.required) {\n        categories[item.category].blocking++;\n        blockers.push(`[${item.category}] ${item.item}`);\n      }\n    }\n\n    // Calculate completion percentage\n    const totalItems = this.checklist.length;\n    const completedItems = this.checklist.filter(i => i.checked).length;\n    const completionPercentage = totalItems > 0\n      ? Math.round((completedItems / totalItems) * 100)\n      : 0;\n\n    // Check if ready (all required items complete)\n    const ready = this.isReady();\n\n    return {\n      ready,\n      completionPercentage,\n      categories,\n      blockers,\n    };\n  }\n\n  isReady(): boolean {\n    return this.checklist\n      .filter(item => item.required)\n      .every(item => item.checked);\n  }\n}",
    "testCases": [
      {
        "input": "const checker = new ProductionReadinessChecker(); checker.addItem(\"Security\", \"SSL configured\", true); checker.addItem(\"Security\", \"CORS configured\", true); checker.checkItem(\"Security\", \"SSL configured\"); console.log(!checker.isReady())",
        "isHidden": false,
        "description": "Not ready with unchecked required items"
      },
      {
        "input": "const checker = new ProductionReadinessChecker(); checker.addItem(\"Monitoring\", \"Logs configured\", true); checker.checkItem(\"Monitoring\", \"Logs configured\"); const report = checker.getReport(); console.log(report.ready && report.completionPercentage === 100)",
        "isHidden": false,
        "description": "Ready when all items checked"
      },
      {
        "input": "const checker = new ProductionReadinessChecker(); checker.addItem(\"Performance\", \"CDN\", false); checker.addItem(\"Security\", \"SSL\", true); checker.checkItem(\"Security\", \"SSL\"); console.log(checker.isReady())",
        "isHidden": true,
        "description": "Optional items do not block"
      }
    ],
    "hints": [
      "Store checklist items with category, name, required flag, and checked status",
      "Group items by category for reporting",
      "Track blocking items (required but not checked)",
      "Calculate completion percentage across all items",
      "Ready = all required items are checked"
    ],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-7-1",
    "subjectId": "cs404",
    "topicId": "topic-7",
    "title": "Topic 7 Coding Exercise",
    "difficulty": 3,
    "description": "Practical coding exercise for topic 7. Complete the implementation following best practices.",
    "starterCode": "// TODO: Implement the solution",
    "solution": "// Complete implementation with best practices",
    "hints": [
      "Follow the examples in the lessons",
      "Test your code thoroughly"
    ],
    "testCases": [],
    "language": "typescript"
  }
]
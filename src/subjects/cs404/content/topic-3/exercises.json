[
  {
    "id": "cs404-ex-3-1",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Input Validation with Zod",
    "difficulty": 1,
    "description": "Create Zod schemas for API input validation. Build validation schemas for user registration and activity creation.",
    "starterCode": "import { z } from 'zod';\n\n// TODO: Create registration schema\nconst registerSchema = z.object({\n  // email: valid email\n  // password: min 12 chars, contains uppercase, lowercase, number, special char\n  // name: 1-100 characters\n});\n\n// TODO: Create activity schema\nconst createActivitySchema = z.object({\n  // category: one of 'transportation', 'energy', 'food', 'waste', 'purchases'\n  // quantity: positive number\n  // date: YYYY-MM-DD format\n});\n\nexport { registerSchema, createActivitySchema };",
    "solution": "import { z } from 'zod';\n\nconst registerSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string()\n    .min(12, 'Password must be at least 12 characters')\n    .regex(/[A-Z]/, 'Must contain uppercase letter')\n    .regex(/[a-z]/, 'Must contain lowercase letter')\n    .regex(/[0-9]/, 'Must contain number')\n    .regex(/[@$!%*?&]/, 'Must contain special character'),\n  name: z.string().min(1).max(100)\n});\n\nconst createActivitySchema = z.object({\n  category: z.enum(['transportation', 'energy', 'food', 'waste', 'purchases']),\n  activity_type: z.string().min(1).max(100),\n  quantity: z.number().positive(),\n  unit: z.string().min(1).max(20),\n  activity_date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Must be YYYY-MM-DD format'),\n  notes: z.string().max(500).optional()\n});\n\n// Usage example\ntry {\n  const validUser = registerSchema.parse({\n    email: 'user@example.com',\n    password: 'SecureP@ssw0rd123',\n    name: 'John Doe'\n  });\n  console.log('Valid user:', validUser);\n} catch (error) {\n  console.error('Validation error:', error);\n}\n\ntry {\n  const validActivity = createActivitySchema.parse({\n    category: 'transportation',\n    activity_type: 'car',\n    quantity: 25.5,\n    unit: 'miles',\n    activity_date: '2024-01-15'\n  });\n  console.log('Valid activity:', validActivity);\n} catch (error) {\n  console.error('Validation error:', error);\n}\n\nexport { registerSchema, createActivitySchema };",
    "hints": [
      "Use z.string().email() for email validation",
      "Use regex for password complexity",
      "Use z.enum() for limited value sets",
      "Use .optional() for optional fields"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-3-2",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "API Error Handler Middleware",
    "difficulty": 3,
    "description": "Create Express middleware for consistent error handling. Build error handler middleware that catches and formats all errors consistently.",
    "starterCode": "import { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\n\nclass AppError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public code?: string\n  ) {\n    super(message);\n  }\n}\n\nfunction errorHandler(\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // TODO: Handle different error types\n  // - ZodError (validation errors)\n  // - AppError (custom application errors)\n  // - Default errors\n}\n\nexport { AppError, errorHandler };",
    "solution": "import { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\n\nclass AppError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public code?: string\n  ) {\n    super(message);\n  }\n}\n\nfunction errorHandler(\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // Log error\n  console.error('Error:', error);\n\n  // Zod validation errors\n  if (error instanceof ZodError) {\n    return res.status(422).json({\n      error: {\n        code: 'VALIDATION_ERROR',\n        message: 'Invalid input data',\n        details: error.errors.map(err => ({\n          field: err.path.join('.'),\n          message: err.message\n        }))\n      }\n    });\n  }\n\n  // Application errors\n  if (error instanceof AppError) {\n    return res.status(error.statusCode).json({\n      error: {\n        code: error.code,\n        message: error.message\n      }\n    });\n  }\n\n  // Default error (hide internals in production)\n  const message = process.env.NODE_ENV === 'production'\n    ? 'Internal server error'\n    : error.message;\n\n  res.status(500).json({\n    error: {\n      code: 'INTERNAL_ERROR',\n      message\n    }\n  });\n}\n\n// Usage example\napp.post('/api/users', async (req, res, next) => {\n  try {\n    const validated = userSchema.parse(req.body);\n    const user = await userService.create(validated);\n    res.status(201).json({ data: user });\n  } catch (error) {\n    next(error);\n  }\n});\n\napp.get('/api/users/:id', async (req, res, next) => {\n  try {\n    const user = await userService.findById(req.params.id);\n    if (!user) {\n      throw new AppError(404, 'User not found', 'USER_NOT_FOUND');\n    }\n    res.json({ data: user });\n  } catch (error) {\n    next(error);\n  }\n});\n\napp.use(errorHandler);\n\nexport { AppError, errorHandler };",
    "hints": [
      "Check error type with instanceof",
      "Return different status codes for different errors",
      "Format errors consistently",
      "Don't expose internal errors in production"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex03",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Environment Configuration Manager",
    "difficulty": 1,
    "description": "Create a configuration manager that loads and validates environment variables using dotenv. Implement type-safe access to configuration values with validation and default values.",
    "starterCode": "import dotenv from 'dotenv';\n\ninterface Config {\n  nodeEnv: 'development' | 'production' | 'test';\n  port: number;\n  databaseUrl: string;\n  jwtSecret: string;\n  corsOrigin: string;\n}\n\n// TODO: Load environment variables\n// TODO: Validate required variables\n// TODO: Export typed config object\n\nexport function getConfig(): Config {\n  // Implement configuration loading\n}",
    "solution": "import dotenv from 'dotenv';\n\ninterface Config {\n  nodeEnv: 'development' | 'production' | 'test';\n  port: number;\n  databaseUrl: string;\n  jwtSecret: string;\n  corsOrigin: string;\n}\n\n// Load environment variables\ndotenv.config();\n\nfunction getEnvVariable(key: string, defaultValue?: string): string {\n  const value = process.env[key] || defaultValue;\n  if (!value) {\n    throw new Error(`Missing required environment variable: ${key}`);\n  }\n  return value;\n}\n\nexport function getConfig(): Config {\n  return {\n    nodeEnv: (process.env.NODE_ENV || 'development') as Config['nodeEnv'],\n    port: parseInt(process.env.PORT || '3000', 10),\n    databaseUrl: getEnvVariable('DATABASE_URL'),\n    jwtSecret: getEnvVariable('JWT_SECRET'),\n    corsOrigin: getEnvVariable('CORS_ORIGIN', 'http://localhost:5173')\n  };\n}\n\n// Usage example\nconst config = getConfig();\nconsole.log(`Server running in ${config.nodeEnv} mode on port ${config.port}`);\n\nexport { config };",
    "hints": [
      "Use dotenv.config() to load .env file",
      "Check if required variables exist using process.env",
      "Throw descriptive errors for missing required variables",
      "Use parseInt() for numeric values with fallback defaults"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex04",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Git Branch Name Validator",
    "difficulty": 1,
    "description": "Create a function that validates Git branch names according to best practices. Check for proper naming conventions like feature/*, bugfix/*, hotfix/*, etc.",
    "starterCode": "interface BranchValidation {\n  valid: boolean;\n  type?: 'feature' | 'bugfix' | 'hotfix' | 'release' | 'chore';\n  message?: string;\n}\n\n// TODO: Validate branch name format\n// Valid patterns:\n// - feature/description-of-feature\n// - bugfix/issue-123-description\n// - hotfix/critical-bug\n// - release/v1.2.3\n// - chore/update-dependencies\n\nfunction validateBranchName(branchName: string): BranchValidation {\n  // Implement validation\n}\n\nexport { validateBranchName };",
    "solution": "interface BranchValidation {\n  valid: boolean;\n  type?: 'feature' | 'bugfix' | 'hotfix' | 'release' | 'chore';\n  message?: string;\n}\n\nfunction validateBranchName(branchName: string): BranchValidation {\n  // Regex pattern for valid branch names\n  const patterns = [\n    { regex: /^feature\\/[a-z0-9-]+$/, type: 'feature' as const },\n    { regex: /^bugfix\\/(issue-\\d+-)?[a-z0-9-]+$/, type: 'bugfix' as const },\n    { regex: /^hotfix\\/[a-z0-9-]+$/, type: 'hotfix' as const },\n    { regex: /^release\\/v?\\d+\\.\\d+\\.\\d+$/, type: 'release' as const },\n    { regex: /^chore\\/[a-z0-9-]+$/, type: 'chore' as const }\n  ];\n\n  // Check if branch name is empty\n  if (!branchName.trim()) {\n    return {\n      valid: false,\n      message: 'Branch name cannot be empty'\n    };\n  }\n\n  // Check against valid patterns\n  for (const { regex, type } of patterns) {\n    if (regex.test(branchName)) {\n      return {\n        valid: true,\n        type,\n        message: `Valid ${type} branch`\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    message: 'Branch name must follow pattern: type/description (e.g., feature/add-login)'\n  };\n}\n\n// Usage examples\nconsole.log(validateBranchName('feature/user-authentication'));\n// { valid: true, type: 'feature', message: 'Valid feature branch' }\n\nconsole.log(validateBranchName('bugfix/issue-123-fix-login'));\n// { valid: true, type: 'bugfix', message: 'Valid bugfix branch' }\n\nconsole.log(validateBranchName('invalid-branch'));\n// { valid: false, message: 'Branch name must follow pattern...' }\n\nexport { validateBranchName };",
    "hints": [
      "Use regex patterns to match each branch type",
      "Check for empty or invalid branch names first",
      "Use lowercase and hyphens in branch descriptions",
      "Return descriptive error messages for invalid formats"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex05",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Conventional Commit Message Formatter",
    "difficulty": 2,
    "description": "Build a commit message formatter that follows Conventional Commits specification. Parse and format commit messages with type, scope, description, and optional body/footer.",
    "starterCode": "interface CommitMessage {\n  type: 'feat' | 'fix' | 'docs' | 'style' | 'refactor' | 'test' | 'chore';\n  scope?: string;\n  description: string;\n  body?: string;\n  breaking?: boolean;\n}\n\n// TODO: Format commit message according to Conventional Commits\n// Format: type(scope): description\n// Example: feat(auth): add login endpoint\n\nfunction formatCommitMessage(commit: CommitMessage): string {\n  // Implement formatter\n}\n\n// TODO: Parse conventional commit message\nfunction parseCommitMessage(message: string): CommitMessage | null {\n  // Implement parser\n}\n\nexport { formatCommitMessage, parseCommitMessage };",
    "solution": "interface CommitMessage {\n  type: 'feat' | 'fix' | 'docs' | 'style' | 'refactor' | 'test' | 'chore';\n  scope?: string;\n  description: string;\n  body?: string;\n  breaking?: boolean;\n}\n\nfunction formatCommitMessage(commit: CommitMessage): string {\n  let message = commit.type;\n\n  if (commit.scope) {\n    message += `(${commit.scope})`;\n  }\n\n  if (commit.breaking) {\n    message += '!';\n  }\n\n  message += `: ${commit.description}`;\n\n  if (commit.body) {\n    message += `\\n\\n${commit.body}`;\n  }\n\n  if (commit.breaking) {\n    message += '\\n\\nBREAKING CHANGE: This introduces a breaking change';\n  }\n\n  return message;\n}\n\nfunction parseCommitMessage(message: string): CommitMessage | null {\n  // Regex for conventional commit format\n  const regex = /^(feat|fix|docs|style|refactor|test|chore)(?:\\(([^)]+)\\))?(!)?:\\s*(.+)$/;\n  const match = message.match(regex);\n\n  if (!match) {\n    return null;\n  }\n\n  const [, type, scope, breaking, description] = match;\n\n  return {\n    type: type as CommitMessage['type'],\n    scope: scope || undefined,\n    description: description.trim(),\n    breaking: breaking === '!'\n  };\n}\n\n// Usage examples\nconst commit: CommitMessage = {\n  type: 'feat',\n  scope: 'api',\n  description: 'add user registration endpoint',\n  body: 'Implements POST /api/auth/register with email validation'\n};\n\nconsole.log(formatCommitMessage(commit));\n// Output: feat(api): add user registration endpoint\n//\n// Implements POST /api/auth/register with email validation\n\nconst parsed = parseCommitMessage('fix(auth): resolve token expiration bug');\nconsole.log(parsed);\n// { type: 'fix', scope: 'auth', description: 'resolve token expiration bug' }\n\nexport { formatCommitMessage, parseCommitMessage };",
    "hints": [
      "Build the message string step by step: type, scope, breaking indicator, description",
      "Use regex with capture groups to parse commit message components",
      "Handle optional scope and breaking change indicator",
      "Validate the commit type against allowed values"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex06",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Express Route Handler with Async Error Handling",
    "difficulty": 2,
    "description": "Create a utility function that wraps Express route handlers to automatically catch async errors. This eliminates the need for try-catch blocks in every route handler.",
    "starterCode": "import { Request, Response, NextFunction } from 'express';\n\ntype AsyncHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<any>;\n\n// TODO: Create wrapper that catches async errors\nfunction asyncHandler(handler: AsyncHandler) {\n  // Implement wrapper\n}\n\n// Example route handler to wrap\nasync function getUserById(req: Request, res: Response) {\n  const user = await database.users.findUnique({\n    where: { id: req.params.id }\n  });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  res.json({ data: user });\n}\n\nexport { asyncHandler };",
    "solution": "import { Request, Response, NextFunction } from 'express';\n\ntype AsyncHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<any>;\n\nfunction asyncHandler(handler: AsyncHandler) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(handler(req, res, next))\n      .catch(next);\n  };\n}\n\n// Example route handler to wrap\nasync function getUserById(req: Request, res: Response) {\n  const user = await database.users.findUnique({\n    where: { id: req.params.id }\n  });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  res.json({ data: user });\n}\n\n// Usage example\nimport express from 'express';\nconst app = express();\n\n// Without asyncHandler (verbose)\napp.get('/api/users/:id', async (req, res, next) => {\n  try {\n    await getUserById(req, res);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// With asyncHandler (clean)\napp.get('/api/users/:id', asyncHandler(async (req, res) => {\n  const user = await database.users.findUnique({\n    where: { id: req.params.id }\n  });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  res.json({ data: user });\n}));\n\nexport { asyncHandler };",
    "hints": [
      "Return a new function that matches Express handler signature",
      "Wrap the handler call in Promise.resolve() to handle both sync and async",
      "Use .catch() to pass errors to the next() function",
      "The wrapper should preserve the original handler parameters"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex07",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Request Logging Middleware Chain",
    "difficulty": 3,
    "description": "Implement a middleware chain for request logging that tracks request ID, duration, and user information. Build composable middleware functions that work together.",
    "starterCode": "import { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\ninterface RequestLog {\n  requestId: string;\n  method: string;\n  path: string;\n  userId?: string;\n  startTime: number;\n  duration?: number;\n}\n\n// TODO: Add unique request ID to each request\nfunction requestIdMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Implement request ID generation\n}\n\n// TODO: Log request details with timing\nfunction requestLoggerMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Implement request logging with duration\n}\n\n// TODO: Extract user ID from auth header\nfunction userContextMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Implement user context extraction\n}\n\nexport { requestIdMiddleware, requestLoggerMiddleware, userContextMiddleware };",
    "solution": "import { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\ninterface RequestLog {\n  requestId: string;\n  method: string;\n  path: string;\n  userId?: string;\n  startTime: number;\n  duration?: number;\n}\n\n// Extend Express Request type\ndeclare global {\n  namespace Express {\n    interface Request {\n      requestId?: string;\n      userId?: string;\n      startTime?: number;\n    }\n  }\n}\n\nfunction requestIdMiddleware(req: Request, res: Response, next: NextFunction) {\n  req.requestId = randomUUID();\n  res.setHeader('X-Request-ID', req.requestId);\n  next();\n}\n\nfunction requestLoggerMiddleware(req: Request, res: Response, next: NextFunction) {\n  req.startTime = Date.now();\n\n  // Log on response finish\n  res.on('finish', () => {\n    const duration = Date.now() - (req.startTime || Date.now());\n    const log: RequestLog = {\n      requestId: req.requestId || 'unknown',\n      method: req.method,\n      path: req.path,\n      userId: req.userId,\n      startTime: req.startTime || Date.now(),\n      duration\n    };\n\n    console.log(`[${log.requestId}] ${log.method} ${log.path} - ${duration}ms - User: ${log.userId || 'anonymous'}`);\n  });\n\n  next();\n}\n\nfunction userContextMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Extract user ID from Authorization header or JWT\n  const authHeader = req.headers.authorization;\n\n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    // In real app, decode JWT here\n    // For demo, extract mock user ID\n    try {\n      // Mock: extract user ID from token\n      req.userId = 'user-123'; // In reality: jwt.verify(token).userId\n    } catch (error) {\n      // Invalid token, continue as anonymous\n      req.userId = undefined;\n    }\n  }\n\n  next();\n}\n\n// Usage example\nimport express from 'express';\nconst app = express();\n\n// Apply middleware chain\napp.use(requestIdMiddleware);\napp.use(userContextMiddleware);\napp.use(requestLoggerMiddleware);\n\n// Example route\napp.get('/api/data', (req, res) => {\n  res.json({\n    message: 'Success',\n    requestId: req.requestId,\n    userId: req.userId\n  });\n});\n\nexport { requestIdMiddleware, requestLoggerMiddleware, userContextMiddleware };",
    "hints": [
      "Use res.on(\"finish\") to log after response is sent",
      "Store request metadata on the req object",
      "Generate UUID for each request using randomUUID()",
      "Calculate duration by comparing timestamps"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex08",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "React Form with Controlled Inputs",
    "difficulty": 3,
    "description": "Build a React registration form component with controlled inputs, real-time validation, and error display. Implement proper state management and validation feedback.",
    "starterCode": "import React, { useState } from 'react';\n\ninterface FormData {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ninterface FormErrors {\n  email?: string;\n  password?: string;\n  confirmPassword?: string;\n}\n\n// TODO: Create registration form component\n// - Controlled inputs for email, password, confirm password\n// - Real-time validation\n// - Display errors under each field\n// - Disable submit button if form is invalid\n\nexport function RegistrationForm() {\n  // Implement form component\n}",
    "solution": "import React, { useState, useEffect } from 'react';\n\ninterface FormData {\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ninterface FormErrors {\n  email?: string;\n  password?: string;\n  confirmPassword?: string;\n}\n\nexport function RegistrationForm() {\n  const [formData, setFormData] = useState<FormData>({\n    email: '',\n    password: '',\n    confirmPassword: ''\n  });\n\n  const [errors, setErrors] = useState<FormErrors>({});\n  const [touched, setTouched] = useState<Record<string, boolean>>({});\n\n  // Validate email\n  const validateEmail = (email: string): string | undefined => {\n    if (!email) return 'Email is required';\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n      return 'Invalid email format';\n    }\n    return undefined;\n  };\n\n  // Validate password\n  const validatePassword = (password: string): string | undefined => {\n    if (!password) return 'Password is required';\n    if (password.length < 8) return 'Password must be at least 8 characters';\n    if (!/[A-Z]/.test(password)) return 'Must contain uppercase letter';\n    if (!/[a-z]/.test(password)) return 'Must contain lowercase letter';\n    if (!/[0-9]/.test(password)) return 'Must contain number';\n    return undefined;\n  };\n\n  // Validate confirm password\n  const validateConfirmPassword = (confirmPassword: string, password: string): string | undefined => {\n    if (!confirmPassword) return 'Please confirm password';\n    if (confirmPassword !== password) return 'Passwords do not match';\n    return undefined;\n  };\n\n  // Validate form on change\n  useEffect(() => {\n    const newErrors: FormErrors = {};\n\n    if (touched.email) {\n      newErrors.email = validateEmail(formData.email);\n    }\n    if (touched.password) {\n      newErrors.password = validatePassword(formData.password);\n    }\n    if (touched.confirmPassword) {\n      newErrors.confirmPassword = validateConfirmPassword(\n        formData.confirmPassword,\n        formData.password\n      );\n    }\n\n    setErrors(newErrors);\n  }, [formData, touched]);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n  };\n\n  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    setTouched(prev => ({ ...prev, [e.target.name]: true }));\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n\n    // Validate all fields\n    const allErrors: FormErrors = {\n      email: validateEmail(formData.email),\n      password: validatePassword(formData.password),\n      confirmPassword: validateConfirmPassword(\n        formData.confirmPassword,\n        formData.password\n      )\n    };\n\n    if (Object.values(allErrors).some(error => error)) {\n      setErrors(allErrors);\n      setTouched({ email: true, password: true, confirmPassword: true });\n      return;\n    }\n\n    // Submit form\n    console.log('Form submitted:', formData);\n  };\n\n  const isFormValid = !Object.values(errors).some(error => error) &&\n    formData.email && formData.password && formData.confirmPassword;\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.email && errors.email && (\n          <span className=\"error\">{errors.email}</span>\n        )}\n      </div>\n\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input\n          type=\"password\"\n          id=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.password && errors.password && (\n          <span className=\"error\">{errors.password}</span>\n        )}\n      </div>\n\n      <div>\n        <label htmlFor=\"confirmPassword\">Confirm Password</label>\n        <input\n          type=\"password\"\n          id=\"confirmPassword\"\n          name=\"confirmPassword\"\n          value={formData.confirmPassword}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.confirmPassword && errors.confirmPassword && (\n          <span className=\"error\">{errors.confirmPassword}</span>\n        )}\n      </div>\n\n      <button type=\"submit\" disabled={!isFormValid}>\n        Register\n      </button>\n    </form>\n  );\n}",
    "hints": [
      "Use useState for form data and errors separately",
      "Track which fields have been touched for validation timing",
      "Validate on blur and on change after first touch",
      "Use useEffect to run validation when form data changes"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex09",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Custom React Hook for Data Fetching",
    "difficulty": 3,
    "description": "Create a reusable React hook for data fetching with loading states, error handling, and automatic retries. Implement proper cleanup to prevent memory leaks.",
    "starterCode": "import { useState, useEffect } from 'react';\n\ninterface FetchState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n}\n\n// TODO: Create useFetch hook\n// - Accepts URL and options\n// - Handles loading, error, and data states\n// - Implements retry logic\n// - Cleans up on unmount\n\nexport function useFetch<T>(url: string, options?: RequestInit) {\n  // Implement hook\n}",
    "solution": "import { useState, useEffect, useRef } from 'react';\n\ninterface FetchState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface FetchOptions extends RequestInit {\n  retries?: number;\n  retryDelay?: number;\n}\n\nexport function useFetch<T>(\n  url: string,\n  options: FetchOptions = {}\n): FetchState<T> & { refetch: () => void } {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [refetchTrigger, setRefetchTrigger] = useState(0);\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const { retries = 3, retryDelay = 1000, ...fetchOptions } = options;\n\n  useEffect(() => {\n    let isMounted = true;\n\n    const fetchData = async () => {\n      // Create new AbortController for this request\n      abortControllerRef.current = new AbortController();\n\n      setLoading(true);\n      setError(null);\n\n      let lastError: Error | null = null;\n\n      // Retry logic\n      for (let attempt = 0; attempt <= retries; attempt++) {\n        try {\n          const response = await fetch(url, {\n            ...fetchOptions,\n            signal: abortControllerRef.current.signal\n          });\n\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n\n          const result = await response.json();\n\n          if (isMounted) {\n            setData(result);\n            setError(null);\n            setLoading(false);\n          }\n\n          return; // Success, exit retry loop\n\n        } catch (err) {\n          lastError = err instanceof Error ? err : new Error('Unknown error');\n\n          // Don't retry if aborted\n          if (lastError.name === 'AbortError') {\n            break;\n          }\n\n          // Wait before retry (except on last attempt)\n          if (attempt < retries) {\n            await new Promise(resolve => setTimeout(resolve, retryDelay));\n          }\n        }\n      }\n\n      // All retries failed\n      if (isMounted && lastError) {\n        setError(lastError);\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      abortControllerRef.current?.abort();\n    };\n  }, [url, refetchTrigger, retries, retryDelay]);\n\n  const refetch = () => {\n    setRefetchTrigger(prev => prev + 1);\n  };\n\n  return { data, loading, error, refetch };\n}\n\n// Usage example\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, loading, error, refetch } = useFetch<User>(\n    `/api/users/${userId}`,\n    { retries: 3, retryDelay: 1000 }\n  );\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message} <button onClick={refetch}>Retry</button></div>;\n  if (!data) return <div>No data</div>;\n\n  return <div>Welcome, {data.name}!</div>;\n}",
    "hints": [
      "Use AbortController to cancel requests on unmount",
      "Track isMounted with a flag to prevent state updates after unmount",
      "Implement retry loop with delay using setTimeout",
      "Provide a refetch function using state trigger"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex10",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "API Client with Interceptors",
    "difficulty": 4,
    "description": "Build a type-safe API client with request/response interceptors for authentication, error handling, and request transformation. Implement automatic token refresh and retry logic.",
    "starterCode": "interface RequestInterceptor {\n  onRequest?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface ResponseInterceptor {\n  onResponse?: (response: Response) => Response | Promise<Response>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface RequestConfig extends RequestInit {\n  url: string;\n  params?: Record<string, string>;\n}\n\n// TODO: Create API client class\n// - Add request/response interceptors\n// - Handle authentication tokens\n// - Implement automatic token refresh\n// - Type-safe methods (get, post, put, delete)\n\nclass ApiClient {\n  // Implement API client\n}\n\nexport { ApiClient };",
    "solution": "interface RequestInterceptor {\n  onRequest?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface ResponseInterceptor {\n  onResponse?: (response: Response) => Response | Promise<Response>;\n  onError?: (error: Error) => Error | Promise<Error>;\n}\n\ninterface RequestConfig extends RequestInit {\n  url: string;\n  params?: Record<string, string>;\n  skipAuth?: boolean;\n}\n\nclass ApiClient {\n  private baseURL: string;\n  private requestInterceptors: RequestInterceptor[] = [];\n  private responseInterceptors: ResponseInterceptor[] = [];\n  private accessToken: string | null = null;\n  private refreshToken: string | null = null;\n\n  constructor(baseURL: string) {\n    this.baseURL = baseURL;\n\n    // Add default auth interceptor\n    this.addRequestInterceptor({\n      onRequest: async (config) => {\n        if (!config.skipAuth && this.accessToken) {\n          config.headers = {\n            ...config.headers,\n            'Authorization': `Bearer ${this.accessToken}`\n          };\n        }\n        return config;\n      }\n    });\n\n    // Add default response interceptor for token refresh\n    this.addResponseInterceptor({\n      onError: async (error: any) => {\n        const originalRequest = error.config;\n\n        // If 401 and we have refresh token, try to refresh\n        if (error.response?.status === 401 && this.refreshToken && !originalRequest._retry) {\n          originalRequest._retry = true;\n\n          try {\n            const response = await this.post<{ accessToken: string }>('/auth/refresh', {\n              refreshToken: this.refreshToken\n            }, { skipAuth: true });\n\n            this.setAccessToken(response.accessToken);\n\n            // Retry original request\n            return this.request(originalRequest);\n          } catch (refreshError) {\n            // Refresh failed, clear tokens\n            this.clearTokens();\n            throw refreshError;\n          }\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  addRequestInterceptor(interceptor: RequestInterceptor) {\n    this.requestInterceptors.push(interceptor);\n  }\n\n  addResponseInterceptor(interceptor: ResponseInterceptor) {\n    this.responseInterceptors.push(interceptor);\n  }\n\n  setAccessToken(token: string) {\n    this.accessToken = token;\n  }\n\n  setRefreshToken(token: string) {\n    this.refreshToken = token;\n  }\n\n  clearTokens() {\n    this.accessToken = null;\n    this.refreshToken = null;\n  }\n\n  private buildURL(url: string, params?: Record<string, string>): string {\n    const fullURL = url.startsWith('http') ? url : `${this.baseURL}${url}`;\n\n    if (params) {\n      const searchParams = new URLSearchParams(params);\n      return `${fullURL}?${searchParams}`;\n    }\n\n    return fullURL;\n  }\n\n  async request<T>(config: RequestConfig): Promise<T> {\n    // Apply request interceptors\n    let finalConfig = config;\n    for (const interceptor of this.requestInterceptors) {\n      if (interceptor.onRequest) {\n        try {\n          finalConfig = await interceptor.onRequest(finalConfig);\n        } catch (error) {\n          if (interceptor.onError) {\n            throw await interceptor.onError(error as Error);\n          }\n          throw error;\n        }\n      }\n    }\n\n    // Build URL with params\n    const url = this.buildURL(finalConfig.url, finalConfig.params);\n\n    try {\n      // Make request\n      let response = await fetch(url, {\n        ...finalConfig,\n        headers: {\n          'Content-Type': 'application/json',\n          ...finalConfig.headers\n        }\n      });\n\n      // Apply response interceptors\n      for (const interceptor of this.responseInterceptors) {\n        if (interceptor.onResponse) {\n          response = await interceptor.onResponse(response);\n        }\n      }\n\n      if (!response.ok) {\n        const error: any = new Error(`HTTP error! status: ${response.status}`);\n        error.response = response;\n        error.config = finalConfig;\n        throw error;\n      }\n\n      return await response.json();\n\n    } catch (error) {\n      // Apply error interceptors\n      let finalError = error as Error;\n      for (const interceptor of this.responseInterceptors) {\n        if (interceptor.onError) {\n          finalError = await interceptor.onError(finalError);\n        }\n      }\n      throw finalError;\n    }\n  }\n\n  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({ ...config, url, method: 'GET' });\n  }\n\n  async post<T>(url: string, data?: any, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({\n      ...config,\n      url,\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  }\n\n  async put<T>(url: string, data?: any, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({\n      ...config,\n      url,\n      method: 'PUT',\n      body: JSON.stringify(data)\n    });\n  }\n\n  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<T> {\n    return this.request<T>({ ...config, url, method: 'DELETE' });\n  }\n}\n\n// Usage example\nconst api = new ApiClient('https://api.example.com');\n\n// Add custom logging interceptor\napi.addRequestInterceptor({\n  onRequest: (config) => {\n    console.log(`Making request to ${config.url}`);\n    return config;\n  }\n});\n\n// Login and set tokens\nconst loginResponse = await api.post('/auth/login', {\n  email: 'user@example.com',\n  password: 'password'\n});\napi.setAccessToken(loginResponse.accessToken);\napi.setRefreshToken(loginResponse.refreshToken);\n\n// Make authenticated request\nconst userData = await api.get('/users/me');\n\nexport { ApiClient };",
    "hints": [
      "Store interceptors in arrays and apply them in sequence",
      "Use a retry flag on the request config to prevent infinite loops",
      "Apply request interceptors before the fetch call",
      "Apply response interceptors after receiving the response"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex11",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Database Connection Pool Manager",
    "difficulty": 4,
    "description": "Implement a connection pool manager for PostgreSQL with health checks, connection recycling, and monitoring. Handle connection failures gracefully and provide pool statistics.",
    "starterCode": "import { Pool, PoolClient, PoolConfig } from 'pg';\n\ninterface PoolStats {\n  total: number;\n  idle: number;\n  waiting: number;\n}\n\n// TODO: Create connection pool manager\n// - Initialize pool with config\n// - Health check functionality\n// - Connection acquisition with timeout\n// - Pool statistics\n// - Graceful shutdown\n\nclass DatabasePool {\n  // Implement pool manager\n}\n\nexport { DatabasePool };",
    "solution": "import { Pool, PoolClient, PoolConfig } from 'pg';\n\ninterface PoolStats {\n  total: number;\n  idle: number;\n  waiting: number;\n}\n\ninterface DatabasePoolConfig extends PoolConfig {\n  healthCheckInterval?: number;\n  connectionTimeout?: number;\n}\n\nclass DatabasePool {\n  private pool: Pool;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private connectionTimeout: number;\n\n  constructor(config: DatabasePoolConfig) {\n    const {\n      healthCheckInterval = 30000,\n      connectionTimeout = 5000,\n      ...poolConfig\n    } = config;\n\n    this.connectionTimeout = connectionTimeout;\n\n    // Create pool with default config\n    this.pool = new Pool({\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: connectionTimeout,\n      ...poolConfig\n    });\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Start health checks if enabled\n    if (healthCheckInterval > 0) {\n      this.startHealthChecks(healthCheckInterval);\n    }\n  }\n\n  private setupEventListeners() {\n    this.pool.on('connect', (client) => {\n      console.log('New client connected to pool');\n    });\n\n    this.pool.on('acquire', (client) => {\n      console.log('Client acquired from pool');\n    });\n\n    this.pool.on('remove', (client) => {\n      console.log('Client removed from pool');\n    });\n\n    this.pool.on('error', (err, client) => {\n      console.error('Unexpected error on idle client', err);\n    });\n  }\n\n  private startHealthChecks(interval: number) {\n    this.healthCheckInterval = setInterval(async () => {\n      try {\n        await this.healthCheck();\n        console.log('Health check passed');\n      } catch (error) {\n        console.error('Health check failed:', error);\n      }\n    }, interval);\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      const client = await this.pool.connect();\n      try {\n        const result = await client.query('SELECT 1');\n        return result.rows.length === 1;\n      } finally {\n        client.release();\n      }\n    } catch (error) {\n      throw new Error(`Health check failed: ${error}`);\n    }\n  }\n\n  async getConnection(): Promise<PoolClient> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Connection acquisition timeout'));\n      }, this.connectionTimeout);\n\n      this.pool.connect()\n        .then(client => {\n          clearTimeout(timeout);\n          resolve(client);\n        })\n        .catch(error => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n    });\n  }\n\n  async query<T = any>(text: string, params?: any[]): Promise<T[]> {\n    const client = await this.getConnection();\n    try {\n      const result = await client.query(text, params);\n      return result.rows;\n    } finally {\n      client.release();\n    }\n  }\n\n  async transaction<T>(callback: (client: PoolClient) => Promise<T>): Promise<T> {\n    const client = await this.getConnection();\n\n    try {\n      await client.query('BEGIN');\n      const result = await callback(client);\n      await client.query('COMMIT');\n      return result;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  getStats(): PoolStats {\n    return {\n      total: this.pool.totalCount,\n      idle: this.pool.idleCount,\n      waiting: this.pool.waitingCount\n    };\n  }\n\n  async shutdown(): Promise<void> {\n    console.log('Shutting down database pool...');\n\n    // Stop health checks\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n\n    // End pool\n    await this.pool.end();\n    console.log('Database pool shut down successfully');\n  }\n}\n\n// Usage example\nconst db = new DatabasePool({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,\n  healthCheckInterval: 30000\n});\n\n// Query with automatic connection management\nconst users = await db.query('SELECT * FROM users WHERE active = $1', [true]);\n\n// Transaction example\nawait db.transaction(async (client) => {\n  await client.query('INSERT INTO users (email) VALUES ($1)', ['user@example.com']);\n  await client.query('INSERT INTO audit_log (action) VALUES ($1)', ['user_created']);\n});\n\n// Get pool statistics\nconst stats = db.getStats();\nconsole.log(`Pool: ${stats.idle}/${stats.total} idle, ${stats.waiting} waiting`);\n\n// Graceful shutdown\nprocess.on('SIGTERM', async () => {\n  await db.shutdown();\n  process.exit(0);\n});\n\nexport { DatabasePool };",
    "hints": [
      "Use Pool event listeners to monitor connection lifecycle",
      "Implement health check using a simple SELECT 1 query",
      "Wrap connection acquisition in a promise with timeout",
      "Always release connections in finally blocks"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex12",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Type-Safe CRUD Repository with Prisma",
    "difficulty": 4,
    "description": "Create a generic repository pattern for CRUD operations using Prisma ORM. Implement type-safe methods with query building, pagination, and filtering capabilities.",
    "starterCode": "import { PrismaClient } from '@prisma/client';\n\ninterface PaginationParams {\n  page: number;\n  limit: number;\n}\n\ninterface PaginatedResult<T> {\n  data: T[];\n  total: number;\n  page: number;\n  totalPages: number;\n}\n\n// TODO: Create generic repository class\n// - Type-safe CRUD operations\n// - Pagination support\n// - Dynamic filtering\n// - Sorting capabilities\n// - Include relations\n\nclass Repository<T> {\n  // Implement repository\n}\n\nexport { Repository };",
    "solution": "import { PrismaClient } from '@prisma/client';\n\ninterface PaginationParams {\n  page: number;\n  limit: number;\n}\n\ninterface PaginatedResult<T> {\n  data: T[];\n  total: number;\n  page: number;\n  totalPages: number;\n}\n\ninterface QueryOptions<T> {\n  where?: any;\n  include?: any;\n  orderBy?: any;\n  select?: any;\n}\n\nclass Repository<T extends Record<string, any>> {\n  protected prisma: PrismaClient;\n  protected modelName: string;\n\n  constructor(prisma: PrismaClient, modelName: string) {\n    this.prisma = prisma;\n    this.modelName = modelName;\n  }\n\n  private getModel() {\n    return (this.prisma as any)[this.modelName];\n  }\n\n  async findById(id: string | number, options?: QueryOptions<T>): Promise<T | null> {\n    return this.getModel().findUnique({\n      where: { id },\n      ...options\n    });\n  }\n\n  async findOne(options: QueryOptions<T>): Promise<T | null> {\n    return this.getModel().findFirst(options);\n  }\n\n  async findMany(options?: QueryOptions<T>): Promise<T[]> {\n    return this.getModel().findMany(options);\n  }\n\n  async findWithPagination(\n    pagination: PaginationParams,\n    options?: QueryOptions<T>\n  ): Promise<PaginatedResult<T>> {\n    const { page, limit } = pagination;\n    const skip = (page - 1) * limit;\n\n    const [data, total] = await Promise.all([\n      this.getModel().findMany({\n        ...options,\n        skip,\n        take: limit\n      }),\n      this.getModel().count({ where: options?.where })\n    ]);\n\n    return {\n      data,\n      total,\n      page,\n      totalPages: Math.ceil(total / limit)\n    };\n  }\n\n  async create(data: Partial<T>): Promise<T> {\n    return this.getModel().create({ data });\n  }\n\n  async createMany(data: Partial<T>[]): Promise<{ count: number }> {\n    return this.getModel().createMany({ data });\n  }\n\n  async update(id: string | number, data: Partial<T>): Promise<T> {\n    return this.getModel().update({\n      where: { id },\n      data\n    });\n  }\n\n  async updateMany(where: any, data: Partial<T>): Promise<{ count: number }> {\n    return this.getModel().updateMany({\n      where,\n      data\n    });\n  }\n\n  async delete(id: string | number): Promise<T> {\n    return this.getModel().delete({\n      where: { id }\n    });\n  }\n\n  async deleteMany(where: any): Promise<{ count: number }> {\n    return this.getModel().deleteMany({ where });\n  }\n\n  async count(where?: any): Promise<number> {\n    return this.getModel().count({ where });\n  }\n\n  async exists(where: any): Promise<boolean> {\n    const count = await this.count(where);\n    return count > 0;\n  }\n}\n\n// Usage example with specific models\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: Date;\n}\n\ninterface Activity {\n  id: string;\n  userId: string;\n  category: string;\n  quantity: number;\n  date: Date;\n}\n\nconst prisma = new PrismaClient();\n\nclass UserRepository extends Repository<User> {\n  constructor() {\n    super(prisma, 'user');\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.findOne({ where: { email } });\n  }\n\n  async findActiveUsers(): Promise<User[]> {\n    return this.findMany({\n      where: { active: true },\n      orderBy: { createdAt: 'desc' }\n    });\n  }\n}\n\nclass ActivityRepository extends Repository<Activity> {\n  constructor() {\n    super(prisma, 'activity');\n  }\n\n  async findByUser(userId: string, pagination: PaginationParams): Promise<PaginatedResult<Activity>> {\n    return this.findWithPagination(pagination, {\n      where: { userId },\n      orderBy: { date: 'desc' }\n    });\n  }\n\n  async getTotalByCategory(userId: string): Promise<Record<string, number>> {\n    const activities = await this.findMany({\n      where: { userId },\n      select: { category: true, quantity: true }\n    });\n\n    return activities.reduce((acc, activity) => {\n      acc[activity.category] = (acc[activity.category] || 0) + activity.quantity;\n      return acc;\n    }, {} as Record<string, number>);\n  }\n}\n\n// Example usage\nconst userRepo = new UserRepository();\nconst activityRepo = new ActivityRepository();\n\n// Create user\nconst user = await userRepo.create({\n  email: 'user@example.com',\n  name: 'John Doe'\n});\n\n// Find with pagination\nconst activities = await activityRepo.findByUser(user.id, {\n  page: 1,\n  limit: 10\n});\n\nconsole.log(`Found ${activities.total} activities, showing page ${activities.page} of ${activities.totalPages}`);\n\nexport { Repository, UserRepository, ActivityRepository };",
    "hints": [
      "Use (this.prisma as any)[modelName] to access models dynamically",
      "Combine findMany and count queries with Promise.all for pagination",
      "Accept generic QueryOptions to allow flexible querying",
      "Extend the base Repository class for model-specific methods"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex13",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Frontend-Backend Integration Layer",
    "difficulty": 5,
    "description": "Build a complete integration layer that connects React frontend with Express backend. Implement real-time updates with Server-Sent Events, optimistic updates, and cache management.",
    "starterCode": "// Backend: SSE endpoint\nimport { Request, Response } from 'express';\n\n// TODO: Implement SSE endpoint for real-time updates\nexport function setupSSE(req: Request, res: Response) {\n  // Implement SSE\n}\n\n// Frontend: Integration hook\nimport { useState, useEffect } from 'react';\n\ninterface DataState<T> {\n  data: T[];\n  loading: boolean;\n  error: Error | null;\n}\n\n// TODO: Create integration hook with:\n// - CRUD operations\n// - Optimistic updates\n// - SSE for real-time updates\n// - Cache management\n\nexport function useDataSync<T>(endpoint: string) {\n  // Implement hook\n}",
    "solution": "// Backend: SSE endpoint\nimport { Request, Response } from 'express';\nimport { EventEmitter } from 'events';\n\nclass SSEManager extends EventEmitter {\n  private clients: Map<string, Response> = new Map();\n\n  addClient(clientId: string, res: Response) {\n    this.clients.set(clientId, res);\n\n    res.on('close', () => {\n      this.clients.delete(clientId);\n      console.log(`Client ${clientId} disconnected`);\n    });\n  }\n\n  broadcast(event: string, data: any) {\n    const message = `event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n\n    this.clients.forEach((client, clientId) => {\n      try {\n        client.write(message);\n      } catch (error) {\n        console.error(`Failed to send to client ${clientId}`, error);\n        this.clients.delete(clientId);\n      }\n    });\n  }\n\n  sendToClient(clientId: string, event: string, data: any) {\n    const client = this.clients.get(clientId);\n    if (client) {\n      const message = `event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n      client.write(message);\n    }\n  }\n}\n\nconst sseManager = new SSEManager();\n\nexport function setupSSE(req: Request, res: Response) {\n  const clientId = req.query.clientId as string || `client-${Date.now()}`;\n\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n  res.setHeader('Access-Control-Allow-Origin', '*');\n\n  // Send initial connection message\n  res.write(`data: ${JSON.stringify({ type: 'connected', clientId })}\\n\\n`);\n\n  // Add client to manager\n  sseManager.addClient(clientId, res);\n\n  // Keep connection alive with heartbeat\n  const heartbeat = setInterval(() => {\n    res.write(': heartbeat\\n\\n');\n  }, 30000);\n\n  res.on('close', () => {\n    clearInterval(heartbeat);\n  });\n}\n\n// Broadcast updates when data changes\nexport function broadcastUpdate(event: string, data: any) {\n  sseManager.broadcast(event, data);\n}\n\n// Frontend: Integration hook\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\ninterface DataState<T> {\n  data: T[];\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface CacheEntry<T> {\n  data: T[];\n  timestamp: number;\n}\n\nconst cache = new Map<string, CacheEntry<any>>();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport function useDataSync<T extends { id: string }>(\n  endpoint: string,\n  options: { realtime?: boolean; cacheKey?: string } = {}\n) {\n  const [state, setState] = useState<DataState<T>>({\n    data: [],\n    loading: true,\n    error: null\n  });\n\n  const eventSourceRef = useRef<EventSource | null>(null);\n  const { realtime = true, cacheKey = endpoint } = options;\n\n  // Check cache\n  const getCachedData = useCallback(() => {\n    const cached = cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n      return cached.data;\n    }\n    return null;\n  }, [cacheKey]);\n\n  // Update cache\n  const updateCache = useCallback((data: T[]) => {\n    cache.set(cacheKey, {\n      data,\n      timestamp: Date.now()\n    });\n  }, [cacheKey]);\n\n  // Fetch data\n  const fetchData = useCallback(async () => {\n    try {\n      // Check cache first\n      const cachedData = getCachedData();\n      if (cachedData) {\n        setState({ data: cachedData, loading: false, error: null });\n        return;\n      }\n\n      setState(prev => ({ ...prev, loading: true }));\n\n      const response = await fetch(`/api${endpoint}`);\n      if (!response.ok) throw new Error('Failed to fetch');\n\n      const data = await response.json();\n      updateCache(data);\n      setState({ data, loading: false, error: null });\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        loading: false,\n        error: error as Error\n      }));\n    }\n  }, [endpoint, getCachedData, updateCache]);\n\n  // Create item with optimistic update\n  const create = useCallback(async (item: Omit<T, 'id'>) => {\n    const tempId = `temp-${Date.now()}`;\n    const optimisticItem = { ...item, id: tempId } as T;\n\n    // Optimistic update\n    setState(prev => ({\n      ...prev,\n      data: [...prev.data, optimisticItem]\n    }));\n\n    try {\n      const response = await fetch(`/api${endpoint}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(item)\n      });\n\n      if (!response.ok) throw new Error('Failed to create');\n\n      const created = await response.json();\n\n      // Replace optimistic item with real one\n      setState(prev => ({\n        ...prev,\n        data: prev.data.map(i => i.id === tempId ? created : i)\n      }));\n\n      updateCache(state.data);\n      return created;\n    } catch (error) {\n      // Rollback optimistic update\n      setState(prev => ({\n        ...prev,\n        data: prev.data.filter(i => i.id !== tempId),\n        error: error as Error\n      }));\n      throw error;\n    }\n  }, [endpoint, state.data, updateCache]);\n\n  // Update item with optimistic update\n  const update = useCallback(async (id: string, updates: Partial<T>) => {\n    const originalData = [...state.data];\n\n    // Optimistic update\n    setState(prev => ({\n      ...prev,\n      data: prev.data.map(item =>\n        item.id === id ? { ...item, ...updates } : item\n      )\n    }));\n\n    try {\n      const response = await fetch(`/api${endpoint}/${id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(updates)\n      });\n\n      if (!response.ok) throw new Error('Failed to update');\n\n      const updated = await response.json();\n\n      setState(prev => ({\n        ...prev,\n        data: prev.data.map(i => i.id === id ? updated : i)\n      }));\n\n      updateCache(state.data);\n      return updated;\n    } catch (error) {\n      // Rollback\n      setState(prev => ({\n        ...prev,\n        data: originalData,\n        error: error as Error\n      }));\n      throw error;\n    }\n  }, [endpoint, state.data, updateCache]);\n\n  // Delete item with optimistic update\n  const remove = useCallback(async (id: string) => {\n    const originalData = [...state.data];\n\n    // Optimistic update\n    setState(prev => ({\n      ...prev,\n      data: prev.data.filter(item => item.id !== id)\n    }));\n\n    try {\n      const response = await fetch(`/api${endpoint}/${id}`, {\n        method: 'DELETE'\n      });\n\n      if (!response.ok) throw new Error('Failed to delete');\n\n      updateCache(state.data);\n    } catch (error) {\n      // Rollback\n      setState(prev => ({\n        ...prev,\n        data: originalData,\n        error: error as Error\n      }));\n      throw error;\n    }\n  }, [endpoint, state.data, updateCache]);\n\n  // Setup SSE for real-time updates\n  useEffect(() => {\n    if (!realtime) return;\n\n    const clientId = `client-${Date.now()}`;\n    const eventSource = new EventSource(`/api/events?clientId=${clientId}`);\n    eventSourceRef.current = eventSource;\n\n    eventSource.addEventListener('created', (event) => {\n      const item = JSON.parse(event.data);\n      setState(prev => ({\n        ...prev,\n        data: [...prev.data, item]\n      }));\n    });\n\n    eventSource.addEventListener('updated', (event) => {\n      const item = JSON.parse(event.data);\n      setState(prev => ({\n        ...prev,\n        data: prev.data.map(i => i.id === item.id ? item : i)\n      }));\n    });\n\n    eventSource.addEventListener('deleted', (event) => {\n      const { id } = JSON.parse(event.data);\n      setState(prev => ({\n        ...prev,\n        data: prev.data.filter(i => i.id !== id)\n      }));\n    });\n\n    return () => {\n      eventSource.close();\n    };\n  }, [realtime]);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return {\n    ...state,\n    create,\n    update,\n    remove,\n    refetch: fetchData\n  };\n}\n\n// Usage example\nfunction ActivityList() {\n  const {\n    data: activities,\n    loading,\n    error,\n    create,\n    update,\n    remove\n  } = useDataSync<Activity>('/activities', { realtime: true });\n\n  const handleCreate = async () => {\n    await create({\n      category: 'transportation',\n      quantity: 10,\n      date: new Date()\n    });\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <button onClick={handleCreate}>Add Activity</button>\n      {activities.map(activity => (\n        <div key={activity.id}>\n          {activity.category} - {activity.quantity}\n          <button onClick={() => update(activity.id, { quantity: activity.quantity + 1 })}>\n            +\n          </button>\n          <button onClick={() => remove(activity.id)}>Delete</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport { setupSSE, broadcastUpdate, useDataSync };",
    "hints": [
      "Use EventSource API for SSE on the frontend",
      "Store original data before optimistic updates for rollback",
      "Implement cache with timestamps for TTL management",
      "Use EventEmitter pattern for managing SSE clients on backend"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex14",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Code Review Checklist Validator",
    "difficulty": 5,
    "description": "Create an automated code review checklist validator that analyzes TypeScript code for common issues. Check for proper error handling, type safety, naming conventions, and code complexity.",
    "starterCode": "import * as ts from 'typescript';\n\ninterface ReviewIssue {\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  line?: number;\n  column?: number;\n}\n\ninterface ReviewResult {\n  passed: boolean;\n  issues: ReviewIssue[];\n  score: number;\n}\n\n// TODO: Create code review validator\n// - Parse TypeScript code\n// - Check for proper error handling (try-catch)\n// - Verify type annotations\n// - Check naming conventions\n// - Detect code smells\n// - Calculate complexity score\n\nexport class CodeReviewValidator {\n  // Implement validator\n}",
    "solution": "import * as ts from 'typescript';\n\ninterface ReviewIssue {\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  line?: number;\n  column?: number;\n  rule: string;\n}\n\ninterface ReviewResult {\n  passed: boolean;\n  issues: ReviewIssue[];\n  score: number;\n  metrics: {\n    complexity: number;\n    linesOfCode: number;\n    typeAnnotationCoverage: number;\n  };\n}\n\nexport class CodeReviewValidator {\n  private sourceFile: ts.SourceFile;\n  private issues: ReviewIssue[] = [];\n\n  constructor(code: string, fileName: string = 'temp.ts') {\n    this.sourceFile = ts.createSourceFile(\n      fileName,\n      code,\n      ts.ScriptTarget.Latest,\n      true\n    );\n  }\n\n  validate(): ReviewResult {\n    this.issues = [];\n\n    // Run all checks\n    this.checkErrorHandling();\n    this.checkTypeAnnotations();\n    this.checkNamingConventions();\n    this.checkComplexity();\n    this.checkCodeSmells();\n\n    const metrics = {\n      complexity: this.calculateComplexity(),\n      linesOfCode: this.sourceFile.getLineAndCharacterOfPosition(this.sourceFile.end).line + 1,\n      typeAnnotationCoverage: this.calculateTypeAnnotationCoverage()\n    };\n\n    // Calculate score (0-100)\n    const errorCount = this.issues.filter(i => i.severity === 'error').length;\n    const warningCount = this.issues.filter(i => i.severity === 'warning').length;\n    const score = Math.max(0, 100 - (errorCount * 10) - (warningCount * 5));\n\n    return {\n      passed: errorCount === 0 && score >= 70,\n      issues: this.issues,\n      score,\n      metrics\n    };\n  }\n\n  private addIssue(issue: ReviewIssue) {\n    this.issues.push(issue);\n  }\n\n  private getLineAndColumn(node: ts.Node) {\n    const { line, character } = this.sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    return { line: line + 1, column: character + 1 };\n  }\n\n  private checkErrorHandling() {\n    const visit = (node: ts.Node) => {\n      // Check async functions without try-catch\n      if (ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) || ts.isMethodDeclaration(node)) {\n        const isAsync = node.modifiers?.some(m => m.kind === ts.SyntaxKind.AsyncKeyword);\n\n        if (isAsync) {\n          let hasTryCatch = false;\n\n          const checkBody = (body: ts.Node) => {\n            if (ts.isTryStatement(body)) {\n              hasTryCatch = true;\n            }\n            ts.forEachChild(body, checkBody);\n          };\n\n          if (node.body) {\n            checkBody(node.body);\n          }\n\n          if (!hasTryCatch) {\n            const { line, column } = this.getLineAndColumn(node);\n            this.addIssue({\n              severity: 'warning',\n              message: 'Async function should have error handling (try-catch)',\n              line,\n              column,\n              rule: 'error-handling'\n            });\n          }\n        }\n      }\n\n      // Check Promise usage without .catch()\n      if (ts.isCallExpression(node)) {\n        const text = node.expression.getText(this.sourceFile);\n        if (text.includes('fetch') || text.includes('Promise')) {\n          // Check if .catch() is chained\n          let parent = node.parent;\n          let hasCatch = false;\n\n          while (parent && ts.isCallExpression(parent)) {\n            if (parent.expression.getText(this.sourceFile).includes('.catch')) {\n              hasCatch = true;\n              break;\n            }\n            parent = parent.parent;\n          }\n\n          if (!hasCatch) {\n            const { line, column } = this.getLineAndColumn(node);\n            this.addIssue({\n              severity: 'info',\n              message: 'Promise should have .catch() handler',\n              line,\n              column,\n              rule: 'promise-catch'\n            });\n          }\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private checkTypeAnnotations() {\n    const visit = (node: ts.Node) => {\n      // Check function parameters\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) || ts.isArrowFunction(node)) {\n        node.parameters.forEach(param => {\n          if (!param.type && !param.initializer) {\n            const { line, column } = this.getLineAndColumn(param);\n            this.addIssue({\n              severity: 'warning',\n              message: `Parameter '${param.name.getText(this.sourceFile)}' should have type annotation`,\n              line,\n              column,\n              rule: 'type-annotation'\n            });\n          }\n        });\n\n        // Check return type\n        if (!node.type && ts.isFunctionDeclaration(node)) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'warning',\n            message: 'Function should have return type annotation',\n            line,\n            column,\n            rule: 'return-type'\n          });\n        }\n      }\n\n      // Check variable declarations\n      if (ts.isVariableDeclaration(node)) {\n        if (!node.type && !node.initializer) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'info',\n            message: `Variable '${node.name.getText(this.sourceFile)}' should have type annotation`,\n            line,\n            column,\n            rule: 'var-type'\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private checkNamingConventions() {\n    const visit = (node: ts.Node) => {\n      // Check function names (camelCase)\n      if (ts.isFunctionDeclaration(node) && node.name) {\n        const name = node.name.text;\n        if (!/^[a-z][a-zA-Z0-9]*$/.test(name)) {\n          const { line, column } = this.getLineAndColumn(node.name);\n          this.addIssue({\n            severity: 'info',\n            message: `Function '${name}' should use camelCase`,\n            line,\n            column,\n            rule: 'naming-convention'\n          });\n        }\n      }\n\n      // Check class names (PascalCase)\n      if (ts.isClassDeclaration(node) && node.name) {\n        const name = node.name.text;\n        if (!/^[A-Z][a-zA-Z0-9]*$/.test(name)) {\n          const { line, column } = this.getLineAndColumn(node.name);\n          this.addIssue({\n            severity: 'info',\n            message: `Class '${name}' should use PascalCase`,\n            line,\n            column,\n            rule: 'naming-convention'\n          });\n        }\n      }\n\n      // Check constants (UPPER_CASE)\n      if (ts.isVariableDeclaration(node)) {\n        const name = node.name.getText(this.sourceFile);\n        const parent = node.parent;\n        if (parent && ts.isVariableDeclarationList(parent)) {\n          const isConst = (parent.flags & ts.NodeFlags.Const) !== 0;\n          if (isConst && /^[A-Z_]+$/.test(name) === false && name === name.toUpperCase()) {\n            // Allow UPPER_CASE for constants, but don't require it\n          }\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private checkComplexity() {\n    const visit = (node: ts.Node) => {\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n        const complexity = this.calculateFunctionComplexity(node);\n\n        if (complexity > 10) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'warning',\n            message: `Function has high cyclomatic complexity (${complexity}). Consider refactoring.`,\n            line,\n            column,\n            rule: 'complexity'\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private calculateFunctionComplexity(node: ts.FunctionDeclaration | ts.MethodDeclaration): number {\n    let complexity = 1;\n\n    const visit = (n: ts.Node) => {\n      if (ts.isIfStatement(n) || ts.isConditionalExpression(n)) complexity++;\n      if (ts.isWhileStatement(n) || ts.isDoStatement(n) || ts.isForStatement(n) || ts.isForInStatement(n) || ts.isForOfStatement(n)) complexity++;\n      if (ts.isCaseClause(n)) complexity++;\n      if (ts.isCatchClause(n)) complexity++;\n      if (ts.isBinaryExpression(n) && (n.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken || n.operatorToken.kind === ts.SyntaxKind.BarBarToken)) complexity++;\n\n      ts.forEachChild(n, visit);\n    };\n\n    if (node.body) {\n      visit(node.body);\n    }\n\n    return complexity;\n  }\n\n  private calculateComplexity(): number {\n    let totalComplexity = 0;\n    let functionCount = 0;\n\n    const visit = (node: ts.Node) => {\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n        totalComplexity += this.calculateFunctionComplexity(node);\n        functionCount++;\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n\n    return functionCount > 0 ? totalComplexity / functionCount : 0;\n  }\n\n  private calculateTypeAnnotationCoverage(): number {\n    let total = 0;\n    let annotated = 0;\n\n    const visit = (node: ts.Node) => {\n      if (ts.isParameter(node) || ts.isVariableDeclaration(node)) {\n        total++;\n        if (node.type || node.initializer) annotated++;\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n\n    return total > 0 ? (annotated / total) * 100 : 100;\n  }\n\n  private checkCodeSmells() {\n    const visit = (node: ts.Node) => {\n      // Check for magic numbers\n      if (ts.isNumericLiteral(node)) {\n        const value = parseInt(node.text);\n        if (value > 1 && !this.isInConstDeclaration(node)) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'info',\n            message: `Magic number ${value} should be a named constant`,\n            line,\n            column,\n            rule: 'magic-number'\n          });\n        }\n      }\n\n      // Check for long parameter lists\n      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n        if (node.parameters.length > 4) {\n          const { line, column } = this.getLineAndColumn(node);\n          this.addIssue({\n            severity: 'info',\n            message: `Function has ${node.parameters.length} parameters. Consider using an options object.`,\n            line,\n            column,\n            rule: 'parameter-count'\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(this.sourceFile);\n  }\n\n  private isInConstDeclaration(node: ts.Node): boolean {\n    let parent = node.parent;\n    while (parent) {\n      if (ts.isVariableDeclaration(parent)) {\n        const grandParent = parent.parent;\n        if (grandParent && ts.isVariableDeclarationList(grandParent)) {\n          return (grandParent.flags & ts.NodeFlags.Const) !== 0;\n        }\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n}\n\n// Usage example\nconst code = `\nasync function fetchUser(id: string) {\n  const response = await fetch(\\`/api/users/\\${id}\\`);\n  return response.json();\n}\n\nfunction calculateTotal(a, b, c, d, e) {\n  return a + b + c + d + e + 100;\n}\n`;\n\nconst validator = new CodeReviewValidator(code);\nconst result = validator.validate();\n\nconsole.log(`Review Score: ${result.score}/100`);\nconsole.log(`Passed: ${result.passed}`);\nconsole.log(`\\nIssues:`);\nresult.issues.forEach(issue => {\n  console.log(`  [${issue.severity}] Line ${issue.line}: ${issue.message}`);\n});\n\nexport { CodeReviewValidator };",
    "hints": [
      "Use TypeScript Compiler API to parse and traverse the AST",
      "Track different node types for different checks (functions, variables, etc)",
      "Calculate cyclomatic complexity by counting decision points",
      "Use node.parent to traverse up the tree for context"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex15",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Pull Request Template Generator",
    "difficulty": 3,
    "description": "Create a tool that generates comprehensive pull request descriptions by analyzing Git diff and commit history. Extract meaningful information and format it according to PR templates.",
    "starterCode": "import { execSync } from 'child_process';\n\ninterface PRTemplate {\n  title: string;\n  description: string;\n  changes: string[];\n  testPlan: string[];\n  breaking: boolean;\n  linkedIssues: string[];\n}\n\n// TODO: Create PR template generator\n// - Analyze git diff\n// - Parse commit messages\n// - Extract file changes\n// - Detect breaking changes\n// - Generate formatted PR description\n\nexport class PRTemplateGenerator {\n  // Implement generator\n}",
    "solution": "import { execSync } from 'child_process';\n\ninterface PRTemplate {\n  title: string;\n  description: string;\n  changes: string[];\n  testPlan: string[];\n  breaking: boolean;\n  linkedIssues: string[];\n  filesChanged: {\n    added: string[];\n    modified: string[];\n    deleted: string[];\n  };\n}\n\ninterface CommitInfo {\n  hash: string;\n  message: string;\n  type?: string;\n  scope?: string;\n  breaking: boolean;\n}\n\nexport class PRTemplateGenerator {\n  private baseBranch: string;\n\n  constructor(baseBranch: string = 'main') {\n    this.baseBranch = baseBranch;\n  }\n\n  generate(): PRTemplate {\n    const commits = this.getCommits();\n    const fileChanges = this.getFileChanges();\n    const diff = this.getDiff();\n\n    const title = this.generateTitle(commits);\n    const description = this.generateDescription(commits);\n    const changes = this.extractChanges(commits);\n    const testPlan = this.generateTestPlan(fileChanges);\n    const breaking = commits.some(c => c.breaking);\n    const linkedIssues = this.extractIssues(commits);\n\n    return {\n      title,\n      description,\n      changes,\n      testPlan,\n      breaking,\n      linkedIssues,\n      filesChanged: fileChanges\n    };\n  }\n\n  private getCommits(): CommitInfo[] {\n    try {\n      const output = execSync(\n        `git log ${this.baseBranch}..HEAD --pretty=format:\"%H|%s\"`,\n        { encoding: 'utf-8' }\n      );\n\n      return output\n        .split('\\n')\n        .filter(line => line.trim())\n        .map(line => {\n          const [hash, message] = line.split('|');\n          return this.parseCommit(hash, message);\n        });\n    } catch (error) {\n      console.error('Failed to get commits:', error);\n      return [];\n    }\n  }\n\n  private parseCommit(hash: string, message: string): CommitInfo {\n    // Parse conventional commit format\n    const conventionalRegex = /^(\\w+)(\\(([^)]+)\\))?(!)?:\\s*(.+)$/;\n    const match = message.match(conventionalRegex);\n\n    if (match) {\n      const [, type, , scope, breaking, msg] = match;\n      return {\n        hash,\n        message: msg,\n        type,\n        scope,\n        breaking: breaking === '!'\n      };\n    }\n\n    // Check for BREAKING CHANGE in message\n    const breaking = message.includes('BREAKING CHANGE');\n\n    return {\n      hash,\n      message,\n      breaking\n    };\n  }\n\n  private getFileChanges() {\n    try {\n      const added = this.getFilesByStatus('A');\n      const modified = this.getFilesByStatus('M');\n      const deleted = this.getFilesByStatus('D');\n\n      return { added, modified, deleted };\n    } catch (error) {\n      console.error('Failed to get file changes:', error);\n      return { added: [], modified: [], deleted: [] };\n    }\n  }\n\n  private getFilesByStatus(status: string): string[] {\n    try {\n      const output = execSync(\n        `git diff --name-only --diff-filter=${status} ${this.baseBranch}..HEAD`,\n        { encoding: 'utf-8' }\n      );\n\n      return output.split('\\n').filter(line => line.trim());\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private getDiff(): string {\n    try {\n      return execSync(`git diff ${this.baseBranch}..HEAD`, { encoding: 'utf-8' });\n    } catch (error) {\n      return '';\n    }\n  }\n\n  private generateTitle(commits: CommitInfo[]): string {\n    if (commits.length === 0) {\n      return 'Update';\n    }\n\n    // Group by type\n    const types = commits.map(c => c.type).filter(Boolean);\n    const uniqueTypes = [...new Set(types)];\n\n    if (uniqueTypes.length === 1) {\n      const type = uniqueTypes[0];\n      const typeMap: Record<string, string> = {\n        feat: 'Add',\n        fix: 'Fix',\n        docs: 'Update documentation',\n        refactor: 'Refactor',\n        test: 'Add tests',\n        chore: 'Update'\n      };\n\n      const prefix = typeMap[type] || 'Update';\n\n      // Use first commit message\n      const firstCommit = commits[0];\n      return `${prefix}: ${firstCommit.message}`;\n    }\n\n    // Multiple types - use generic title\n    return `Update: Multiple changes (${commits.length} commits)`;\n  }\n\n  private generateDescription(commits: CommitInfo[]): string {\n    const parts: string[] = [];\n\n    // Group commits by type\n    const grouped = commits.reduce((acc, commit) => {\n      const type = commit.type || 'other';\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(commit);\n      return acc;\n    }, {} as Record<string, CommitInfo[]>);\n\n    // Format each group\n    Object.entries(grouped).forEach(([type, commits]) => {\n      const typeLabel = type.charAt(0).toUpperCase() + type.slice(1);\n      parts.push(`### ${typeLabel}`);\n      commits.forEach(commit => {\n        const scope = commit.scope ? `**${commit.scope}**: ` : '';\n        parts.push(`- ${scope}${commit.message}`);\n      });\n      parts.push('');\n    });\n\n    return parts.join('\\n');\n  }\n\n  private extractChanges(commits: CommitInfo[]): string[] {\n    return commits.map(commit => {\n      const scope = commit.scope ? `[${commit.scope}] ` : '';\n      return `${scope}${commit.message}`;\n    });\n  }\n\n  private generateTestPlan(fileChanges: PRTemplate['filesChanged']): string[] {\n    const plan: string[] = [];\n\n    if (fileChanges.added.length > 0) {\n      plan.push('Test new functionality in added files');\n      fileChanges.added.forEach(file => {\n        if (file.includes('test')) {\n          plan.push(`Run tests in ${file}`);\n        }\n      });\n    }\n\n    if (fileChanges.modified.length > 0) {\n      plan.push('Verify existing functionality still works');\n\n      // Check for specific file types\n      const hasBackend = fileChanges.modified.some(f =>\n        f.includes('api/') || f.includes('server/') || f.endsWith('.controller.ts')\n      );\n      const hasFrontend = fileChanges.modified.some(f =>\n        f.includes('components/') || f.endsWith('.tsx')\n      );\n\n      if (hasBackend) {\n        plan.push('Test API endpoints manually or with Postman');\n      }\n      if (hasFrontend) {\n        plan.push('Test UI changes in browser');\n      }\n    }\n\n    if (plan.length === 0) {\n      plan.push('Run all tests: npm test');\n      plan.push('Verify build: npm run build');\n    }\n\n    return plan;\n  }\n\n  private extractIssues(commits: CommitInfo[]): string[] {\n    const issues = new Set<string>();\n    const issueRegex = /#(\\d+)/g;\n\n    commits.forEach(commit => {\n      const matches = commit.message.matchAll(issueRegex);\n      for (const match of matches) {\n        issues.add(match[1]);\n      }\n    });\n\n    return Array.from(issues);\n  }\n\n  formatAsMarkdown(): string {\n    const template = this.generate();\n\n    const sections: string[] = [];\n\n    // Title\n    sections.push(`# ${template.title}\\n`);\n\n    // Breaking change warning\n    if (template.breaking) {\n      sections.push('##  BREAKING CHANGE\\n');\n      sections.push('This PR contains breaking changes. Please review carefully.\\n');\n    }\n\n    // Description\n    sections.push('## Description\\n');\n    sections.push(template.description);\n\n    // Changes\n    if (template.changes.length > 0) {\n      sections.push('## Changes\\n');\n      template.changes.forEach(change => {\n        sections.push(`- ${change}`);\n      });\n      sections.push('');\n    }\n\n    // Files changed\n    sections.push('## Files Changed\\n');\n    if (template.filesChanged.added.length > 0) {\n      sections.push(`**Added (${template.filesChanged.added.length}):**`);\n      template.filesChanged.added.forEach(file => sections.push(`- ${file}`));\n      sections.push('');\n    }\n    if (template.filesChanged.modified.length > 0) {\n      sections.push(`**Modified (${template.filesChanged.modified.length}):**`);\n      template.filesChanged.modified.forEach(file => sections.push(`- ${file}`));\n      sections.push('');\n    }\n    if (template.filesChanged.deleted.length > 0) {\n      sections.push(`**Deleted (${template.filesChanged.deleted.length}):**`);\n      template.filesChanged.deleted.forEach(file => sections.push(`- ${file}`));\n      sections.push('');\n    }\n\n    // Test plan\n    sections.push('## Test Plan\\n');\n    template.testPlan.forEach((step, i) => {\n      sections.push(`${i + 1}. ${step}`);\n    });\n    sections.push('');\n\n    // Linked issues\n    if (template.linkedIssues.length > 0) {\n      sections.push('## Related Issues\\n');\n      template.linkedIssues.forEach(issue => {\n        sections.push(`- Closes #${issue}`);\n      });\n      sections.push('');\n    }\n\n    return sections.join('\\n');\n  }\n}\n\n// Usage example\nconst generator = new PRTemplateGenerator('main');\nconst markdown = generator.formatAsMarkdown();\nconsole.log(markdown);\n\n// Output to file\nimport { writeFileSync } from 'fs';\nwriteFileSync('PR_DESCRIPTION.md', markdown);\n\nexport { PRTemplateGenerator };",
    "hints": [
      "Use git log with custom format to get commit messages",
      "Parse conventional commit format with regex",
      "Use git diff --name-only with --diff-filter to get file changes by status",
      "Extract issue numbers from commit messages using regex"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t3-ex16",
    "subjectId": "cs404",
    "topicId": "cs404-topic-3",
    "title": "Development Workflow Automation Script",
    "difficulty": 5,
    "description": "Build a comprehensive workflow automation tool that handles common development tasks: branch creation, commit formatting, pre-push checks, and deployment preparation. Integrate multiple Git operations and validation steps.",
    "starterCode": "import { execSync } from 'child_process';\nimport prompts from 'prompts';\n\ninterface WorkflowConfig {\n  baseBranch: string;\n  requireTests: boolean;\n  requireLinting: boolean;\n  conventionalCommits: boolean;\n}\n\n// TODO: Create workflow automation tool\n// - Interactive branch creation\n// - Automated commit message formatting\n// - Pre-push validation (tests, lint, build)\n// - Change detection and impact analysis\n// - Deployment checklist generation\n\nexport class WorkflowAutomation {\n  // Implement automation tool\n}",
    "solution": "import { execSync } from 'child_process';\nimport prompts from 'prompts';\nimport chalk from 'chalk';\n\ninterface WorkflowConfig {\n  baseBranch: string;\n  requireTests: boolean;\n  requireLinting: boolean;\n  conventionalCommits: boolean;\n  remoteUrl?: string;\n}\n\ninterface BranchInfo {\n  name: string;\n  type: 'feature' | 'bugfix' | 'hotfix' | 'release' | 'chore';\n  description: string;\n}\n\ninterface CommitInfo {\n  type: string;\n  scope?: string;\n  message: string;\n  breaking: boolean;\n}\n\ninterface ValidationResult {\n  passed: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport class WorkflowAutomation {\n  private config: WorkflowConfig;\n\n  constructor(config: Partial<WorkflowConfig> = {}) {\n    this.config = {\n      baseBranch: 'main',\n      requireTests: true,\n      requireLinting: true,\n      conventionalCommits: true,\n      ...config\n    };\n  }\n\n  private exec(command: string, silent: boolean = false): string {\n    try {\n      return execSync(command, {\n        encoding: 'utf-8',\n        stdio: silent ? 'pipe' : 'inherit'\n      });\n    } catch (error: any) {\n      throw new Error(`Command failed: ${command}\\n${error.message}`);\n    }\n  }\n\n  private execSilent(command: string): string {\n    return this.exec(command, true);\n  }\n\n  async createBranch(): Promise<void> {\n    console.log(chalk.blue('\\n Creating new branch...\\n'));\n\n    // Get current branch\n    const currentBranch = this.execSilent('git rev-parse --abbrev-ref HEAD').trim();\n\n    if (currentBranch !== this.config.baseBranch) {\n      const { switchBase } = await prompts({\n        type: 'confirm',\n        name: 'switchBase',\n        message: `You're on '${currentBranch}'. Switch to '${this.config.baseBranch}'?`,\n        initial: true\n      });\n\n      if (switchBase) {\n        this.exec(`git checkout ${this.config.baseBranch}`);\n        this.exec('git pull origin ' + this.config.baseBranch);\n      }\n    }\n\n    // Get branch details\n    const response = await prompts([\n      {\n        type: 'select',\n        name: 'type',\n        message: 'Branch type:',\n        choices: [\n          { title: 'Feature', value: 'feature' },\n          { title: 'Bugfix', value: 'bugfix' },\n          { title: 'Hotfix', value: 'hotfix' },\n          { title: 'Release', value: 'release' },\n          { title: 'Chore', value: 'chore' }\n        ]\n      },\n      {\n        type: 'text',\n        name: 'description',\n        message: 'Branch description (kebab-case):',\n        validate: (value: string) =>\n          /^[a-z0-9-]+$/.test(value) || 'Use lowercase letters, numbers, and hyphens only'\n      }\n    ]);\n\n    const branchName = `${response.type}/${response.description}`;\n\n    // Create and checkout branch\n    this.exec(`git checkout -b ${branchName}`);\n\n    console.log(chalk.green(`\\n Created and switched to branch: ${branchName}\\n`));\n  }\n\n  async createCommit(): Promise<void> {\n    console.log(chalk.blue('\\n Creating commit...\\n'));\n\n    // Check for staged changes\n    const stagedFiles = this.execSilent('git diff --cached --name-only').trim();\n\n    if (!stagedFiles) {\n      console.log(chalk.yellow('No staged changes. Stage files first with: git add <files>'));\n      return;\n    }\n\n    console.log(chalk.gray('Staged files:'));\n    stagedFiles.split('\\n').forEach(file => {\n      console.log(chalk.gray(`  - ${file}`));\n    });\n    console.log('');\n\n    let commitMessage: string;\n\n    if (this.config.conventionalCommits) {\n      const response = await prompts([\n        {\n          type: 'select',\n          name: 'type',\n          message: 'Commit type:',\n          choices: [\n            { title: 'feat: New feature', value: 'feat' },\n            { title: 'fix: Bug fix', value: 'fix' },\n            { title: 'docs: Documentation', value: 'docs' },\n            { title: 'style: Code style', value: 'style' },\n            { title: 'refactor: Code refactoring', value: 'refactor' },\n            { title: 'test: Tests', value: 'test' },\n            { title: 'chore: Maintenance', value: 'chore' }\n          ]\n        },\n        {\n          type: 'text',\n          name: 'scope',\n          message: 'Scope (optional):',\n        },\n        {\n          type: 'text',\n          name: 'message',\n          message: 'Commit message:',\n          validate: (value: string) => value.length > 0 || 'Message required'\n        },\n        {\n          type: 'confirm',\n          name: 'breaking',\n          message: 'Breaking change?',\n          initial: false\n        },\n        {\n          type: (prev: boolean) => prev ? 'text' : null,\n          name: 'breakingDescription',\n          message: 'Describe the breaking change:'\n        }\n      ]);\n\n      // Format conventional commit\n      const scope = response.scope ? `(${response.scope})` : '';\n      const breaking = response.breaking ? '!' : '';\n      commitMessage = `${response.type}${scope}${breaking}: ${response.message}`;\n\n      if (response.breaking && response.breakingDescription) {\n        commitMessage += `\\n\\nBREAKING CHANGE: ${response.breakingDescription}`;\n      }\n    } else {\n      const { message } = await prompts({\n        type: 'text',\n        name: 'message',\n        message: 'Commit message:',\n        validate: (value: string) => value.length > 0 || 'Message required'\n      });\n      commitMessage = message;\n    }\n\n    // Create commit\n    this.exec(`git commit -m \"${commitMessage}\"`);\n\n    console.log(chalk.green('\\n Commit created successfully\\n'));\n  }\n\n  async prePushCheck(): Promise<boolean> {\n    console.log(chalk.blue('\\n Running pre-push checks...\\n'));\n\n    const results: ValidationResult = {\n      passed: true,\n      errors: [],\n      warnings: []\n    };\n\n    // Check for uncommitted changes\n    const uncommitted = this.execSilent('git status --porcelain').trim();\n    if (uncommitted) {\n      results.warnings.push('You have uncommitted changes');\n    }\n\n    // Run linting\n    if (this.config.requireLinting) {\n      console.log(chalk.gray('Running linter...'));\n      try {\n        this.execSilent('npm run lint');\n        console.log(chalk.green(' Linting passed'));\n      } catch (error) {\n        results.errors.push('Linting failed');\n        results.passed = false;\n        console.log(chalk.red(' Linting failed'));\n      }\n    }\n\n    // Run tests\n    if (this.config.requireTests) {\n      console.log(chalk.gray('Running tests...'));\n      try {\n        this.execSilent('npm test');\n        console.log(chalk.green(' Tests passed'));\n      } catch (error) {\n        results.errors.push('Tests failed');\n        results.passed = false;\n        console.log(chalk.red(' Tests failed'));\n      }\n    }\n\n    // Check build\n    console.log(chalk.gray('Checking build...'));\n    try {\n      this.execSilent('npm run build');\n      console.log(chalk.green(' Build successful'));\n    } catch (error) {\n      results.errors.push('Build failed');\n      results.passed = false;\n      console.log(chalk.red(' Build failed'));\n    }\n\n    // Check for merge conflicts with base branch\n    try {\n      this.execSilent(`git fetch origin ${this.config.baseBranch}`);\n      const conflicts = this.execSilent(\n        `git merge-tree \\`git merge-base HEAD origin/${this.config.baseBranch}\\` HEAD origin/${this.config.baseBranch}`\n      );\n\n      if (conflicts.includes('<<<<<<<')) {\n        results.warnings.push('Potential merge conflicts with base branch');\n      }\n    } catch (error) {\n      results.warnings.push('Could not check for merge conflicts');\n    }\n\n    // Display results\n    console.log('');\n    if (results.errors.length > 0) {\n      console.log(chalk.red('\\n Pre-push checks failed:\\n'));\n      results.errors.forEach(error => {\n        console.log(chalk.red(`   ${error}`));\n      });\n    }\n\n    if (results.warnings.length > 0) {\n      console.log(chalk.yellow('\\n  Warnings:\\n'));\n      results.warnings.forEach(warning => {\n        console.log(chalk.yellow(`  ! ${warning}`));\n      });\n    }\n\n    if (results.passed) {\n      console.log(chalk.green('\\n All checks passed!\\n'));\n    }\n\n    return results.passed;\n  }\n\n  async push(): Promise<void> {\n    console.log(chalk.blue('\\n Pushing changes...\\n'));\n\n    // Run pre-push checks\n    const checksPass = await this.prePushCheck();\n\n    if (!checksPass) {\n      const { forcePush } = await prompts({\n        type: 'confirm',\n        name: 'forcePush',\n        message: 'Checks failed. Push anyway?',\n        initial: false\n      });\n\n      if (!forcePush) {\n        console.log(chalk.yellow('\\nPush cancelled\\n'));\n        return;\n      }\n    }\n\n    // Get current branch\n    const branch = this.execSilent('git rev-parse --abbrev-ref HEAD').trim();\n\n    // Push\n    try {\n      this.exec(`git push -u origin ${branch}`);\n      console.log(chalk.green(`\\n Pushed to origin/${branch}\\n`));\n\n      // Generate PR URL\n      const remoteUrl = this.execSilent('git config --get remote.origin.url').trim();\n      if (remoteUrl.includes('github.com')) {\n        const repoPath = remoteUrl\n          .replace(/^.*github\\.com[:\\/]/, '')\n          .replace(/\\.git$/, '');\n        const prUrl = `https://github.com/${repoPath}/compare/${this.config.baseBranch}...${branch}?expand=1`;\n        console.log(chalk.blue(`Create PR: ${prUrl}\\n`));\n      }\n    } catch (error) {\n      console.log(chalk.red('\\n Push failed\\n'));\n      throw error;\n    }\n  }\n\n  async deploymentChecklist(): Promise<void> {\n    console.log(chalk.blue('\\n Deployment Checklist\\n'));\n\n    const checklist = [\n      'All tests passing',\n      'Linting checks pass',\n      'Build successful',\n      'No merge conflicts',\n      'Database migrations ready',\n      'Environment variables configured',\n      'Documentation updated',\n      'Change log updated',\n      'Version bumped (if needed)',\n      'Backup plan in place'\n    ];\n\n    const responses = await prompts(\n      checklist.map((item, i) => ({\n        type: 'confirm',\n        name: `check${i}`,\n        message: item,\n        initial: false\n      }))\n    );\n\n    const allChecked = Object.values(responses).every(v => v === true);\n\n    if (allChecked) {\n      console.log(chalk.green('\\n All deployment checks completed!\\n'));\n    } else {\n      console.log(chalk.yellow('\\n  Some checks incomplete\\n'));\n    }\n  }\n\n  async run(): Promise<void> {\n    const { action } = await prompts({\n      type: 'select',\n      name: 'action',\n      message: 'What would you like to do?',\n      choices: [\n        { title: 'Create branch', value: 'branch' },\n        { title: 'Create commit', value: 'commit' },\n        { title: 'Run pre-push checks', value: 'check' },\n        { title: 'Push changes', value: 'push' },\n        { title: 'Deployment checklist', value: 'deploy' }\n      ]\n    });\n\n    switch (action) {\n      case 'branch':\n        await this.createBranch();\n        break;\n      case 'commit':\n        await this.createCommit();\n        break;\n      case 'check':\n        await this.prePushCheck();\n        break;\n      case 'push':\n        await this.push();\n        break;\n      case 'deploy':\n        await this.deploymentChecklist();\n        break;\n    }\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const automation = new WorkflowAutomation();\n  automation.run().catch(error => {\n    console.error(chalk.red('Error:', error.message));\n    process.exit(1);\n  });\n}\n\nexport { WorkflowAutomation };",
    "hints": [
      "Use prompts library for interactive CLI inputs",
      "Use execSync with { stdio: \"pipe\" } for silent execution",
      "Run validation checks in sequence and collect all errors",
      "Use chalk for colored console output to improve UX"
    ],
    "testCases": [],
    "language": "typescript"
  }
]

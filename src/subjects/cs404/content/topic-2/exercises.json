[
  {
    "id": "cs404-ex-2-1",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Implement Repository Pattern",
    "difficulty": 3,
    "description": "Create a repository class that abstracts database operations for a User entity. Implement a UserRepository class with CRUD operations that can work with any database implementation.",
    "starterCode": "interface User {\n  id: string;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  create(user: Omit<User, 'id' | 'created_at'>): Promise<User>;\n  update(id: string, data: Partial<User>): Promise<User>;\n  delete(id: string): Promise<void>;\n}\n\n// TODO: Implement UserRepository class\nclass InMemoryUserRepository implements UserRepository {\n  private users: Map<string, User> = new Map();\n\n  async findById(id: string): Promise<User | null> {\n    // TODO\n    return null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    // TODO\n    return null;\n  }\n\n  async create(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {\n    // TODO\n    throw new Error('Not implemented');\n  }\n\n  async update(id: string, data: Partial<User>): Promise<User> {\n    // TODO\n    throw new Error('Not implemented');\n  }\n\n  async delete(id: string): Promise<void> {\n    // TODO\n  }\n}",
    "solution": "interface User {\n  id: string;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  create(user: Omit<User, 'id' | 'created_at'>): Promise<User>;\n  update(id: string, data: Partial<User>): Promise<User>;\n  delete(id: string): Promise<void>;\n}\n\nclass InMemoryUserRepository implements UserRepository {\n  private users: Map<string, User> = new Map();\n\n  async findById(id: string): Promise<User | null> {\n    return this.users.get(id) || null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    const users = Array.from(this.users.values());\n    return users.find(user => user.email === email) || null;\n  }\n\n  async create(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {\n    const user: User = {\n      id: crypto.randomUUID(),\n      ...userData,\n      created_at: new Date()\n    };\n\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  async update(id: string, data: Partial<User>): Promise<User> {\n    const existing = await this.findById(id);\n    if (!existing) {\n      throw new Error('User not found');\n    }\n\n    const updated = { ...existing, ...data };\n    this.users.set(id, updated);\n    return updated;\n  }\n\n  async delete(id: string): Promise<void> {\n    this.users.delete(id);\n  }\n}\n\n// Usage example\nasync function main() {\n  const repo = new InMemoryUserRepository();\n\n  // Create user\n  const user = await repo.create({\n    email: 'test@example.com',\n    name: 'Test User'\n  });\n  console.log('Created:', user);\n\n  // Find by ID\n  const found = await repo.findById(user.id);\n  console.log('Found:', found);\n\n  // Update\n  const updated = await repo.update(user.id, { name: 'Updated Name' });\n  console.log('Updated:', updated);\n\n  // Find by email\n  const byEmail = await repo.findByEmail('test@example.com');\n  console.log('By email:', byEmail);\n\n  // Delete\n  await repo.delete(user.id);\n  const deleted = await repo.findById(user.id);\n  console.log('After delete:', deleted); // null\n}\n\nmain();",
    "hints": [
      "Use Map to store users in memory",
      "Generate UUIDs for new users",
      "Return null when user not found",
      "Throw error on update if user doesn't exist"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-ex-2-2",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Strategy Pattern for Calculations",
    "difficulty": 3,
    "description": "Implement the Strategy pattern for different carbon emission calculations. Create different calculation strategies for different transportation types.",
    "starterCode": "interface CarbonCalculationStrategy {\n  calculate(miles: number): number;\n}\n\n// TODO: Implement strategies for car, bus, and plane\nclass CarStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    // TODO: 0.404 kg CO2 per mile\n    return 0;\n  }\n}\n\nclass Calculator {\n  private strategy: CarbonCalculationStrategy;\n\n  setStrategy(strategy: CarbonCalculationStrategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(miles: number): number {\n    return this.strategy.calculate(miles);\n  }\n}",
    "solution": "interface CarbonCalculationStrategy {\n  calculate(miles: number): number;\n}\n\nclass CarStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    return miles * 0.404; // kg CO2 per mile\n  }\n}\n\nclass BusStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    return miles * 0.089; // kg CO2 per mile\n  }\n}\n\nclass PlaneStrategy implements CarbonCalculationStrategy {\n  calculate(miles: number): number {\n    return miles * 0.257; // kg CO2 per mile\n  }\n}\n\nclass CarbonCalculator {\n  private strategy: CarbonCalculationStrategy;\n\n  constructor(strategy: CarbonCalculationStrategy) {\n    this.strategy = strategy;\n  }\n\n  setStrategy(strategy: CarbonCalculationStrategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(miles: number): number {\n    return Math.round(this.strategy.calculate(miles) * 100) / 100;\n  }\n}\n\n// Usage\nconst calculator = new CarbonCalculator(new CarStrategy());\nconsole.log('Car 100 miles:', calculator.calculate(100), 'kg CO2');\n\ncalculator.setStrategy(new BusStrategy());\nconsole.log('Bus 100 miles:', calculator.calculate(100), 'kg CO2');\n\ncalculator.setStrategy(new PlaneStrategy());\nconsole.log('Plane 1000 miles:', calculator.calculate(1000), 'kg CO2');\n\n/*\nOutput:\nCar 100 miles: 40.4 kg CO2\nBus 100 miles: 8.9 kg CO2\nPlane 1000 miles: 257 kg CO2\n*/",
    "hints": [
      "Each strategy implements the same interface",
      "Calculator can switch strategies at runtime",
      "Round results to 2 decimal places"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex03",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Layered Architecture - Three Tier System",
    "difficulty": 1,
    "description": "Implement a simple three-tier architecture with Presentation, Business Logic, and Data Access layers. Create a basic user authentication system that demonstrates separation of concerns across layers.\n\nThe presentation layer handles input/output, the business layer contains authentication logic, and the data layer manages user storage.",
    "starterCode": "// Data Access Layer\nclass UserDataAccess {\n  private users: Map<string, { username: string; password: string }> = new Map();\n\n  findByUsername(username: string) {\n    // TODO: Return user or undefined\n  }\n\n  save(username: string, password: string) {\n    // TODO: Save user to storage\n  }\n}\n\n// Business Logic Layer\nclass AuthService {\n  constructor(private dataAccess: UserDataAccess) {}\n\n  register(username: string, password: string): boolean {\n    // TODO: Check if user exists, validate, and save\n    return false;\n  }\n\n  login(username: string, password: string): boolean {\n    // TODO: Verify credentials\n    return false;\n  }\n}\n\n// Presentation Layer\nclass AuthController {\n  constructor(private authService: AuthService) {}\n\n  handleRegister(username: string, password: string): string {\n    // TODO: Call service and return user-friendly message\n    return '';\n  }\n\n  handleLogin(username: string, password: string): string {\n    // TODO: Call service and return user-friendly message\n    return '';\n  }\n}",
    "solution": "// Data Access Layer\nclass UserDataAccess {\n  private users: Map<string, { username: string; password: string }> = new Map();\n\n  findByUsername(username: string) {\n    return this.users.get(username);\n  }\n\n  save(username: string, password: string) {\n    this.users.set(username, { username, password });\n  }\n}\n\n// Business Logic Layer\nclass AuthService {\n  constructor(private dataAccess: UserDataAccess) {}\n\n  register(username: string, password: string): boolean {\n    if (username.length < 3 || password.length < 6) {\n      return false;\n    }\n\n    if (this.dataAccess.findByUsername(username)) {\n      return false;\n    }\n\n    this.dataAccess.save(username, password);\n    return true;\n  }\n\n  login(username: string, password: string): boolean {\n    const user = this.dataAccess.findByUsername(username);\n    return user !== undefined && user.password === password;\n  }\n}\n\n// Presentation Layer\nclass AuthController {\n  constructor(private authService: AuthService) {}\n\n  handleRegister(username: string, password: string): string {\n    const success = this.authService.register(username, password);\n    return success\n      ? `User ${username} registered successfully`\n      : 'Registration failed: invalid credentials or user exists';\n  }\n\n  handleLogin(username: string, password: string): string {\n    const success = this.authService.login(username, password);\n    return success\n      ? `Welcome, ${username}!`\n      : 'Login failed: invalid credentials';\n  }\n}\n\n// Usage\nconst dataAccess = new UserDataAccess();\nconst authService = new AuthService(dataAccess);\nconst controller = new AuthController(authService);\n\nconsole.log(controller.handleRegister('john', 'pass123'));\nconsole.log(controller.handleLogin('john', 'pass123'));\nconsole.log(controller.handleLogin('john', 'wrongpass'));",
    "hints": [
      "Each layer should only communicate with adjacent layers",
      "Data layer only handles storage, no validation",
      "Business layer validates and enforces rules",
      "Presentation layer handles user interaction and formatting"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex04",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "MVC Pattern Implementation",
    "difficulty": 2,
    "description": "Implement the Model-View-Controller pattern for a simple Todo application. The Model manages data, the View handles display logic, and the Controller coordinates between them.\n\nCreate a TodoMVC that can add, remove, and list todos while maintaining separation of concerns.",
    "starterCode": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\n// Model: Manages data and business logic\nclass TodoModel {\n  private todos: Todo[] = [];\n  private nextId = 1;\n\n  addTodo(text: string): Todo {\n    // TODO: Create and add todo\n    return null as any;\n  }\n\n  removeTodo(id: number): boolean {\n    // TODO: Remove todo by id\n    return false;\n  }\n\n  toggleTodo(id: number): boolean {\n    // TODO: Toggle completed status\n    return false;\n  }\n\n  getAllTodos(): Todo[] {\n    // TODO: Return all todos\n    return [];\n  }\n}\n\n// View: Handles presentation\nclass TodoView {\n  displayTodos(todos: Todo[]): void {\n    // TODO: Format and display todos\n  }\n\n  displayMessage(message: string): void {\n    console.log(message);\n  }\n}\n\n// Controller: Coordinates Model and View\nclass TodoController {\n  constructor(\n    private model: TodoModel,\n    private view: TodoView\n  ) {}\n\n  addTodo(text: string): void {\n    // TODO: Add todo via model, update view\n  }\n\n  removeTodo(id: number): void {\n    // TODO: Remove todo via model, update view\n  }\n\n  showTodos(): void {\n    // TODO: Get todos from model, display via view\n  }\n}",
    "solution": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\n// Model: Manages data and business logic\nclass TodoModel {\n  private todos: Todo[] = [];\n  private nextId = 1;\n\n  addTodo(text: string): Todo {\n    const todo: Todo = {\n      id: this.nextId++,\n      text,\n      completed: false\n    };\n    this.todos.push(todo);\n    return todo;\n  }\n\n  removeTodo(id: number): boolean {\n    const index = this.todos.findIndex(t => t.id === id);\n    if (index === -1) return false;\n    this.todos.splice(index, 1);\n    return true;\n  }\n\n  toggleTodo(id: number): boolean {\n    const todo = this.todos.find(t => t.id === id);\n    if (!todo) return false;\n    todo.completed = !todo.completed;\n    return true;\n  }\n\n  getAllTodos(): Todo[] {\n    return [...this.todos];\n  }\n}\n\n// View: Handles presentation\nclass TodoView {\n  displayTodos(todos: Todo[]): void {\n    console.log('\\n=== Todo List ===');\n    if (todos.length === 0) {\n      console.log('No todos yet!');\n      return;\n    }\n\n    todos.forEach(todo => {\n      const status = todo.completed ? 'âœ“' : ' ';\n      console.log(`[${status}] ${todo.id}. ${todo.text}`);\n    });\n  }\n\n  displayMessage(message: string): void {\n    console.log(message);\n  }\n}\n\n// Controller: Coordinates Model and View\nclass TodoController {\n  constructor(\n    private model: TodoModel,\n    private view: TodoView\n  ) {}\n\n  addTodo(text: string): void {\n    const todo = this.model.addTodo(text);\n    this.view.displayMessage(`Added: ${todo.text}`);\n    this.showTodos();\n  }\n\n  removeTodo(id: number): void {\n    const success = this.model.removeTodo(id);\n    if (success) {\n      this.view.displayMessage(`Removed todo #${id}`);\n      this.showTodos();\n    } else {\n      this.view.displayMessage(`Todo #${id} not found`);\n    }\n  }\n\n  showTodos(): void {\n    const todos = this.model.getAllTodos();\n    this.view.displayTodos(todos);\n  }\n}\n\n// Usage\nconst model = new TodoModel();\nconst view = new TodoView();\nconst controller = new TodoController(model, view);\n\ncontroller.addTodo('Learn MVC pattern');\ncontroller.addTodo('Build a web app');\ncontroller.removeTodo(1);",
    "hints": [
      "Model should not know about View or Controller",
      "View should only handle presentation logic",
      "Controller mediates between Model and View",
      "Model returns data, View formats it for display"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex05",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Factory Pattern for Multi-Database Support",
    "difficulty": 1,
    "description": "Implement the Factory pattern to create different database connection objects. Support multiple database types (PostgreSQL, MySQL, MongoDB) through a unified factory interface.\n\nThe factory should return database-specific implementations that conform to a common interface.",
    "starterCode": "interface Database {\n  connect(): string;\n  query(sql: string): string;\n  disconnect(): string;\n}\n\nclass PostgresDatabase implements Database {\n  connect(): string {\n    // TODO\n    return '';\n  }\n\n  query(sql: string): string {\n    // TODO\n    return '';\n  }\n\n  disconnect(): string {\n    // TODO\n    return '';\n  }\n}\n\n// TODO: Implement MySQLDatabase and MongoDatabase\n\nclass DatabaseFactory {\n  static create(type: 'postgres' | 'mysql' | 'mongo'): Database {\n    // TODO: Return appropriate database instance\n    throw new Error('Not implemented');\n  }\n}",
    "solution": "interface Database {\n  connect(): string;\n  query(sql: string): string;\n  disconnect(): string;\n}\n\nclass PostgresDatabase implements Database {\n  connect(): string {\n    return 'Connected to PostgreSQL on port 5432';\n  }\n\n  query(sql: string): string {\n    return `PostgreSQL executing: ${sql}`;\n  }\n\n  disconnect(): string {\n    return 'Disconnected from PostgreSQL';\n  }\n}\n\nclass MySQLDatabase implements Database {\n  connect(): string {\n    return 'Connected to MySQL on port 3306';\n  }\n\n  query(sql: string): string {\n    return `MySQL executing: ${sql}`;\n  }\n\n  disconnect(): string {\n    return 'Disconnected from MySQL';\n  }\n}\n\nclass MongoDatabase implements Database {\n  connect(): string {\n    return 'Connected to MongoDB on port 27017';\n  }\n\n  query(sql: string): string {\n    return `MongoDB executing: ${sql}`;\n  }\n\n  disconnect(): string {\n    return 'Disconnected from MongoDB';\n  }\n}\n\nclass DatabaseFactory {\n  static create(type: 'postgres' | 'mysql' | 'mongo'): Database {\n    switch (type) {\n      case 'postgres':\n        return new PostgresDatabase();\n      case 'mysql':\n        return new MySQLDatabase();\n      case 'mongo':\n        return new MongoDatabase();\n      default:\n        throw new Error(`Unknown database type: ${type}`);\n    }\n  }\n}\n\n// Usage\nconst db1 = DatabaseFactory.create('postgres');\nconsole.log(db1.connect());\nconsole.log(db1.query('SELECT * FROM users'));\n\nconst db2 = DatabaseFactory.create('mongo');\nconsole.log(db2.connect());\nconsole.log(db2.query('db.users.find()'));",
    "hints": [
      "All database classes implement the same interface",
      "Factory method uses switch or if-else to determine type",
      "Each database has different connection details",
      "Client code works with Database interface, not concrete classes"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex06",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Observer Pattern for Event System",
    "difficulty": 2,
    "description": "Implement the Observer pattern for a real-time notification system. Create a subject that notifies multiple observers when events occur.\n\nBuild a stock price tracker that notifies different types of observers (email, SMS, dashboard) when prices change.",
    "starterCode": "interface Observer {\n  update(stock: string, price: number): void;\n}\n\nclass Subject {\n  private observers: Observer[] = [];\n\n  attach(observer: Observer): void {\n    // TODO\n  }\n\n  detach(observer: Observer): void {\n    // TODO\n  }\n\n  notify(stock: string, price: number): void {\n    // TODO\n  }\n}\n\nclass StockTracker extends Subject {\n  private prices: Map<string, number> = new Map();\n\n  setPrice(stock: string, price: number): void {\n    // TODO: Update price and notify observers\n  }\n\n  getPrice(stock: string): number | undefined {\n    return this.prices.get(stock);\n  }\n}\n\n// TODO: Implement EmailObserver, SMSObserver, DashboardObserver",
    "solution": "interface Observer {\n  update(stock: string, price: number): void;\n}\n\nclass Subject {\n  private observers: Observer[] = [];\n\n  attach(observer: Observer): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n    }\n  }\n\n  detach(observer: Observer): void {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(stock: string, price: number): void {\n    this.observers.forEach(observer => observer.update(stock, price));\n  }\n}\n\nclass StockTracker extends Subject {\n  private prices: Map<string, number> = new Map();\n\n  setPrice(stock: string, price: number): void {\n    this.prices.set(stock, price);\n    this.notify(stock, price);\n  }\n\n  getPrice(stock: string): number | undefined {\n    return this.prices.get(stock);\n  }\n}\n\nclass EmailObserver implements Observer {\n  constructor(private email: string) {}\n\n  update(stock: string, price: number): void {\n    console.log(`[EMAIL to ${this.email}] ${stock} is now $${price}`);\n  }\n}\n\nclass SMSObserver implements Observer {\n  constructor(private phone: string) {}\n\n  update(stock: string, price: number): void {\n    console.log(`[SMS to ${this.phone}] ${stock}: $${price}`);\n  }\n}\n\nclass DashboardObserver implements Observer {\n  update(stock: string, price: number): void {\n    console.log(`[DASHBOARD] Updated ${stock} = $${price}`);\n  }\n}\n\n// Usage\nconst tracker = new StockTracker();\n\nconst emailObs = new EmailObserver('investor@example.com');\nconst smsObs = new SMSObserver('+1234567890');\nconst dashObs = new DashboardObserver();\n\ntracker.attach(emailObs);\ntracker.attach(smsObs);\ntracker.attach(dashObs);\n\ntracker.setPrice('AAPL', 150.25);\ntracker.setPrice('GOOGL', 2800.50);\n\ntracker.detach(smsObs);\ntracker.setPrice('AAPL', 151.00);",
    "hints": [
      "Subject maintains a list of observers",
      "attach() adds observer to the list",
      "notify() calls update() on all observers",
      "Each observer implements update() differently"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex07",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Database Schema Design - E-Commerce",
    "difficulty": 3,
    "description": "Design a normalized database schema for an e-commerce platform. Create TypeScript interfaces representing database tables for users, products, orders, and order items.\n\nImplement proper relationships (one-to-many, many-to-many) and demonstrate CRUD operations with referential integrity.",
    "starterCode": "// TODO: Define interfaces for User, Product, Order, OrderItem\n\nclass ECommerceDB {\n  private users: Map<string, any> = new Map();\n  private products: Map<string, any> = new Map();\n  private orders: Map<string, any> = new Map();\n  private orderItems: Map<string, any> = new Map();\n\n  // User operations\n  createUser(email: string, name: string) {\n    // TODO\n  }\n\n  // Product operations\n  createProduct(name: string, price: number, stock: number) {\n    // TODO\n  }\n\n  // Order operations\n  createOrder(userId: string) {\n    // TODO\n  }\n\n  addOrderItem(orderId: string, productId: string, quantity: number) {\n    // TODO: Check stock, update quantities\n  }\n\n  getOrderDetails(orderId: string) {\n    // TODO: Return order with all items and user info\n  }\n}",
    "solution": "interface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: Date;\n}\n\ninterface Product {\n  id: string;\n  name: string;\n  price: number;\n  stock: number;\n}\n\ninterface Order {\n  id: string;\n  userId: string;\n  status: 'pending' | 'paid' | 'shipped' | 'delivered';\n  total: number;\n  createdAt: Date;\n}\n\ninterface OrderItem {\n  id: string;\n  orderId: string;\n  productId: string;\n  quantity: number;\n  priceAtPurchase: number;\n}\n\nclass ECommerceDB {\n  private users: Map<string, User> = new Map();\n  private products: Map<string, Product> = new Map();\n  private orders: Map<string, Order> = new Map();\n  private orderItems: Map<string, OrderItem> = new Map();\n  private nextId = 1;\n\n  // User operations\n  createUser(email: string, name: string): User {\n    const user: User = {\n      id: `user_${this.nextId++}`,\n      email,\n      name,\n      createdAt: new Date()\n    };\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  // Product operations\n  createProduct(name: string, price: number, stock: number): Product {\n    const product: Product = {\n      id: `prod_${this.nextId++}`,\n      name,\n      price,\n      stock\n    };\n    this.products.set(product.id, product);\n    return product;\n  }\n\n  // Order operations\n  createOrder(userId: string): Order {\n    const user = this.users.get(userId);\n    if (!user) throw new Error('User not found');\n\n    const order: Order = {\n      id: `order_${this.nextId++}`,\n      userId,\n      status: 'pending',\n      total: 0,\n      createdAt: new Date()\n    };\n    this.orders.set(order.id, order);\n    return order;\n  }\n\n  addOrderItem(orderId: string, productId: string, quantity: number): OrderItem {\n    const order = this.orders.get(orderId);\n    const product = this.products.get(productId);\n\n    if (!order) throw new Error('Order not found');\n    if (!product) throw new Error('Product not found');\n    if (product.stock < quantity) throw new Error('Insufficient stock');\n\n    const orderItem: OrderItem = {\n      id: `item_${this.nextId++}`,\n      orderId,\n      productId,\n      quantity,\n      priceAtPurchase: product.price\n    };\n\n    // Update stock and order total\n    product.stock -= quantity;\n    order.total += product.price * quantity;\n\n    this.orderItems.set(orderItem.id, orderItem);\n    return orderItem;\n  }\n\n  getOrderDetails(orderId: string) {\n    const order = this.orders.get(orderId);\n    if (!order) throw new Error('Order not found');\n\n    const user = this.users.get(order.userId);\n    const items = Array.from(this.orderItems.values())\n      .filter(item => item.orderId === orderId)\n      .map(item => {\n        const product = this.products.get(item.productId);\n        return {\n          ...item,\n          productName: product?.name,\n          subtotal: item.priceAtPurchase * item.quantity\n        };\n      });\n\n    return {\n      order,\n      user,\n      items\n    };\n  }\n}\n\n// Usage\nconst db = new ECommerceDB();\n\nconst user = db.createUser('alice@example.com', 'Alice');\nconst laptop = db.createProduct('Laptop', 999.99, 10);\nconst mouse = db.createProduct('Mouse', 29.99, 50);\n\nconst order = db.createOrder(user.id);\ndb.addOrderItem(order.id, laptop.id, 1);\ndb.addOrderItem(order.id, mouse.id, 2);\n\nconsole.log(db.getOrderDetails(order.id));",
    "hints": [
      "Use foreign keys (IDs) to establish relationships",
      "Store price at purchase time to preserve historical data",
      "Update stock levels when adding order items",
      "Calculate order total by summing item subtotals"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex08",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "RESTful API Design",
    "difficulty": 3,
    "description": "Design a RESTful API for a blog platform. Create endpoint definitions with proper HTTP methods, URL structures, request/response formats, and status codes.\n\nImplement a mock API handler that demonstrates REST principles: resource-based URLs, proper HTTP verbs, and stateless operations.",
    "starterCode": "interface BlogPost {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface ApiResponse<T = any> {\n  status: number;\n  data?: T;\n  error?: string;\n}\n\nclass BlogAPI {\n  private posts: Map<string, BlogPost> = new Map();\n  private nextId = 1;\n\n  // GET /api/posts\n  getAllPosts(): ApiResponse<BlogPost[]> {\n    // TODO\n    return { status: 200 };\n  }\n\n  // GET /api/posts/:id\n  getPost(id: string): ApiResponse<BlogPost> {\n    // TODO\n    return { status: 200 };\n  }\n\n  // POST /api/posts\n  createPost(title: string, content: string, authorId: string): ApiResponse<BlogPost> {\n    // TODO\n    return { status: 201 };\n  }\n\n  // PUT /api/posts/:id\n  updatePost(id: string, updates: Partial<BlogPost>): ApiResponse<BlogPost> {\n    // TODO\n    return { status: 200 };\n  }\n\n  // DELETE /api/posts/:id\n  deletePost(id: string): ApiResponse {\n    // TODO\n    return { status: 204 };\n  }\n}",
    "solution": "interface BlogPost {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface ApiResponse<T = any> {\n  status: number;\n  data?: T;\n  error?: string;\n}\n\nclass BlogAPI {\n  private posts: Map<string, BlogPost> = new Map();\n  private nextId = 1;\n\n  // GET /api/posts - List all posts\n  getAllPosts(): ApiResponse<BlogPost[]> {\n    return {\n      status: 200,\n      data: Array.from(this.posts.values())\n    };\n  }\n\n  // GET /api/posts/:id - Get single post\n  getPost(id: string): ApiResponse<BlogPost> {\n    const post = this.posts.get(id);\n    if (!post) {\n      return {\n        status: 404,\n        error: 'Post not found'\n      };\n    }\n    return {\n      status: 200,\n      data: post\n    };\n  }\n\n  // POST /api/posts - Create new post\n  createPost(title: string, content: string, authorId: string): ApiResponse<BlogPost> {\n    if (!title || !content || !authorId) {\n      return {\n        status: 400,\n        error: 'Missing required fields'\n      };\n    }\n\n    const post: BlogPost = {\n      id: `post_${this.nextId++}`,\n      title,\n      content,\n      authorId,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    this.posts.set(post.id, post);\n    return {\n      status: 201,\n      data: post\n    };\n  }\n\n  // PUT /api/posts/:id - Update existing post\n  updatePost(id: string, updates: Partial<BlogPost>): ApiResponse<BlogPost> {\n    const post = this.posts.get(id);\n    if (!post) {\n      return {\n        status: 404,\n        error: 'Post not found'\n      };\n    }\n\n    const updated: BlogPost = {\n      ...post,\n      ...updates,\n      id: post.id, // Prevent ID change\n      createdAt: post.createdAt, // Preserve creation date\n      updatedAt: new Date()\n    };\n\n    this.posts.set(id, updated);\n    return {\n      status: 200,\n      data: updated\n    };\n  }\n\n  // DELETE /api/posts/:id - Delete post\n  deletePost(id: string): ApiResponse {\n    if (!this.posts.has(id)) {\n      return {\n        status: 404,\n        error: 'Post not found'\n      };\n    }\n\n    this.posts.delete(id);\n    return {\n      status: 204 // No content\n    };\n  }\n}\n\n// Usage demonstration\nconst api = new BlogAPI();\n\n// Create posts\nconsole.log('Creating post:', api.createPost('First Post', 'Hello World', 'user1'));\nconsole.log('Creating post:', api.createPost('Second Post', 'REST API', 'user1'));\n\n// Get all posts\nconsole.log('All posts:', api.getAllPosts());\n\n// Get single post\nconsole.log('Get post:', api.getPost('post_1'));\n\n// Update post\nconsole.log('Update post:', api.updatePost('post_1', { title: 'Updated Title' }));\n\n// Delete post\nconsole.log('Delete post:', api.deletePost('post_2'));\n\n// Try to get deleted post\nconsole.log('Get deleted post:', api.getPost('post_2'));",
    "hints": [
      "Use appropriate HTTP status codes: 200 OK, 201 Created, 204 No Content, 404 Not Found",
      "Resource URLs should be nouns (posts), not verbs",
      "PUT updates should preserve id and createdAt",
      "Return error messages for 4xx responses"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex09",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "GraphQL vs REST Comparison",
    "difficulty": 3,
    "description": "Implement both REST and GraphQL-style APIs for the same data model to understand the differences. Create a user/posts system that demonstrates over-fetching in REST vs precise queries in GraphQL.\n\nShow how GraphQL allows clients to request exactly the data they need.",
    "starterCode": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  bio: string;\n}\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n}\n\n// REST API - Returns all fields\nclass RestAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  getUser(id: string) {\n    // TODO: Returns entire user object\n  }\n\n  getUserPosts(userId: string) {\n    // TODO: Returns all posts by user\n  }\n}\n\n// GraphQL-style API - Returns only requested fields\nclass GraphQLAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  query(queryString: string) {\n    // TODO: Parse query and return only requested fields\n    // Example query: \"user(id: '1') { name, posts { title } }\"\n  }\n}",
    "solution": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  bio: string;\n}\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n}\n\n// REST API - Returns all fields (over-fetching)\nclass RestAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  constructor() {\n    // Seed data\n    this.users.set('1', {\n      id: '1',\n      name: 'Alice',\n      email: 'alice@example.com',\n      bio: 'Software engineer'\n    });\n    this.posts.set('1', {\n      id: '1',\n      title: 'First Post',\n      content: 'Long content here...',\n      authorId: '1'\n    });\n  }\n\n  getUser(id: string) {\n    return this.users.get(id); // Returns ALL user fields\n  }\n\n  getUserPosts(userId: string) {\n    return Array.from(this.posts.values())\n      .filter(p => p.authorId === userId); // Returns ALL post fields\n  }\n}\n\n// GraphQL-style API - Returns only requested fields\nclass GraphQLAPI {\n  private users: Map<string, User> = new Map();\n  private posts: Map<string, Post> = new Map();\n\n  constructor() {\n    // Seed data\n    this.users.set('1', {\n      id: '1',\n      name: 'Alice',\n      email: 'alice@example.com',\n      bio: 'Software engineer'\n    });\n    this.posts.set('1', {\n      id: '1',\n      title: 'First Post',\n      content: 'Long content here...',\n      authorId: '1'\n    });\n  }\n\n  query(fields: { user?: { id: string; fields: string[] }; posts?: boolean }) {\n    const result: any = {};\n\n    if (fields.user) {\n      const user = this.users.get(fields.user.id);\n      if (user) {\n        result.user = {};\n        fields.user.fields.forEach(field => {\n          if (field in user) {\n            result.user[field] = user[field as keyof User];\n          }\n        });\n\n        if (fields.posts && result.user) {\n          result.user.posts = Array.from(this.posts.values())\n            .filter(p => p.authorId === user.id)\n            .map(p => ({ id: p.id, title: p.title }));\n        }\n      }\n    }\n\n    return result;\n  }\n}\n\n// Usage comparison\nconsole.log('=== REST API (Over-fetching) ===');\nconst restApi = new RestAPI();\nconsole.log('Get user (only need name):');\nconsole.log(restApi.getUser('1')); // Returns all fields including email, bio\n\nconsole.log('\\n=== GraphQL API (Precise) ===');\nconst graphqlApi = new GraphQLAPI();\nconsole.log('Get user (only need name):');\nconsole.log(graphqlApi.query({\n  user: { id: '1', fields: ['name'] }\n})); // Returns only name\n\nconsole.log('\\nGet user name and post titles:');\nconsole.log(graphqlApi.query({\n  user: { id: '1', fields: ['name'] },\n  posts: true\n})); // Returns only requested fields\n\n/*\nREST returns everything:\n{ id: '1', name: 'Alice', email: 'alice@example.com', bio: 'Software engineer' }\n\nGraphQL returns only what you need:\n{ user: { name: 'Alice' } }\n{ user: { name: 'Alice', posts: [{ id: '1', title: 'First Post' }] } }\n*/",
    "hints": [
      "REST always returns the complete resource",
      "GraphQL allows specifying exactly which fields to return",
      "GraphQL can fetch related data in a single request",
      "Over-fetching wastes bandwidth and processing"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex10",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "JWT Authentication System",
    "difficulty": 4,
    "description": "Implement a JWT (JSON Web Token) based authentication system. Create functions to generate tokens, verify tokens, and protect routes.\n\nBuild a complete auth flow: login generates JWT, protected routes verify JWT, and tokens expire after a set time.",
    "starterCode": "interface JWTPayload {\n  userId: string;\n  email: string;\n  exp: number; // Expiration timestamp\n  iat: number; // Issued at timestamp\n}\n\nclass JWTAuth {\n  private secret = 'your-secret-key';\n  private expirationMinutes = 60;\n\n  // Simple base64 encoding (in production, use crypto libraries)\n  private encode(data: string): string {\n    return Buffer.from(data).toString('base64');\n  }\n\n  private decode(data: string): string {\n    return Buffer.from(data, 'base64').toString('utf-8');\n  }\n\n  generateToken(userId: string, email: string): string {\n    // TODO: Create JWT with header, payload, signature\n    return '';\n  }\n\n  verifyToken(token: string): JWTPayload | null {\n    // TODO: Verify signature and expiration\n    return null;\n  }\n\n  isTokenExpired(payload: JWTPayload): boolean {\n    // TODO: Check if current time > expiration\n    return true;\n  }\n}\n\nclass ProtectedAPI {\n  constructor(private auth: JWTAuth) {}\n\n  login(email: string, password: string): { token: string } | { error: string } {\n    // TODO: Validate credentials and return token\n    return { error: 'Not implemented' };\n  }\n\n  getProfile(token: string): { user: any } | { error: string } {\n    // TODO: Verify token and return user data\n    return { error: 'Not implemented' };\n  }\n}",
    "solution": "interface JWTPayload {\n  userId: string;\n  email: string;\n  exp: number; // Expiration timestamp\n  iat: number; // Issued at timestamp\n}\n\nclass JWTAuth {\n  private secret = 'your-secret-key';\n  private expirationMinutes = 60;\n\n  // Simple base64 encoding (in production, use crypto libraries)\n  private encode(data: string): string {\n    return Buffer.from(data).toString('base64');\n  }\n\n  private decode(data: string): string {\n    return Buffer.from(data, 'base64').toString('utf-8');\n  }\n\n  private sign(data: string): string {\n    // Simple signature (in production, use HMAC-SHA256)\n    return this.encode(data + this.secret);\n  }\n\n  private verify(data: string, signature: string): boolean {\n    return this.sign(data) === signature;\n  }\n\n  generateToken(userId: string, email: string): string {\n    const header = { alg: 'HS256', typ: 'JWT' };\n    const now = Math.floor(Date.now() / 1000);\n    const payload: JWTPayload = {\n      userId,\n      email,\n      iat: now,\n      exp: now + (this.expirationMinutes * 60)\n    };\n\n    const encodedHeader = this.encode(JSON.stringify(header));\n    const encodedPayload = this.encode(JSON.stringify(payload));\n    const signature = this.sign(`${encodedHeader}.${encodedPayload}`);\n\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\n  }\n\n  verifyToken(token: string): JWTPayload | null {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return null;\n\n      const [encodedHeader, encodedPayload, signature] = parts;\n\n      // Verify signature\n      if (!this.verify(`${encodedHeader}.${encodedPayload}`, signature)) {\n        return null;\n      }\n\n      // Decode payload\n      const payload: JWTPayload = JSON.parse(this.decode(encodedPayload));\n\n      // Check expiration\n      if (this.isTokenExpired(payload)) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  isTokenExpired(payload: JWTPayload): boolean {\n    const now = Math.floor(Date.now() / 1000);\n    return now > payload.exp;\n  }\n}\n\nclass ProtectedAPI {\n  private users = new Map([\n    ['alice@example.com', { userId: '1', email: 'alice@example.com', password: 'pass123', name: 'Alice' }]\n  ]);\n\n  constructor(private auth: JWTAuth) {}\n\n  login(email: string, password: string): { token: string } | { error: string } {\n    const user = this.users.get(email);\n    if (!user || user.password !== password) {\n      return { error: 'Invalid credentials' };\n    }\n\n    const token = this.auth.generateToken(user.userId, user.email);\n    return { token };\n  }\n\n  getProfile(token: string): { user: any } | { error: string } {\n    const payload = this.auth.verifyToken(token);\n    if (!payload) {\n      return { error: 'Invalid or expired token' };\n    }\n\n    const user = this.users.get(payload.email);\n    if (!user) {\n      return { error: 'User not found' };\n    }\n\n    const { password, ...safeUser } = user;\n    return { user: safeUser };\n  }\n}\n\n// Usage\nconst auth = new JWTAuth();\nconst api = new ProtectedAPI(auth);\n\n// Login\nconst loginResult = api.login('alice@example.com', 'pass123');\nconsole.log('Login:', loginResult);\n\nif ('token' in loginResult) {\n  // Access protected route\n  console.log('Profile:', api.getProfile(loginResult.token));\n\n  // Try invalid token\n  console.log('Invalid token:', api.getProfile('invalid.token.here'));\n}",
    "hints": [
      "JWT structure: header.payload.signature (all base64 encoded)",
      "Include expiration timestamp in payload",
      "Verify both signature and expiration",
      "Never store sensitive data in JWT payload (it's not encrypted)"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex11",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Role-Based Access Control (RBAC)",
    "difficulty": 4,
    "description": "Implement a Role-Based Access Control system with roles, permissions, and resource protection. Create an authorization system that checks if users have the required permissions to perform actions.\n\nSupport multiple roles (admin, editor, viewer) with different permission sets.",
    "starterCode": "type Permission = 'create' | 'read' | 'update' | 'delete';\ntype Role = 'admin' | 'editor' | 'viewer';\n\ninterface User {\n  id: string;\n  name: string;\n  role: Role;\n}\n\nclass RBAC {\n  private rolePermissions: Map<Role, Permission[]> = new Map();\n\n  constructor() {\n    // TODO: Define role permissions\n    // admin: all permissions\n    // editor: create, read, update\n    // viewer: read only\n  }\n\n  hasPermission(user: User, permission: Permission): boolean {\n    // TODO: Check if user's role has the permission\n    return false;\n  }\n\n  authorize(user: User, action: Permission): void {\n    // TODO: Throw error if user lacks permission\n  }\n}\n\nclass DocumentService {\n  private documents: Map<string, any> = new Map();\n\n  constructor(private rbac: RBAC) {}\n\n  createDocument(user: User, title: string, content: string) {\n    // TODO: Check permission, then create\n  }\n\n  readDocument(user: User, id: string) {\n    // TODO: Check permission, then read\n  }\n\n  updateDocument(user: User, id: string, updates: any) {\n    // TODO: Check permission, then update\n  }\n\n  deleteDocument(user: User, id: string) {\n    // TODO: Check permission, then delete\n  }\n}",
    "solution": "type Permission = 'create' | 'read' | 'update' | 'delete';\ntype Role = 'admin' | 'editor' | 'viewer';\n\ninterface User {\n  id: string;\n  name: string;\n  role: Role;\n}\n\nclass RBAC {\n  private rolePermissions: Map<Role, Permission[]> = new Map();\n\n  constructor() {\n    // Define role permissions\n    this.rolePermissions.set('admin', ['create', 'read', 'update', 'delete']);\n    this.rolePermissions.set('editor', ['create', 'read', 'update']);\n    this.rolePermissions.set('viewer', ['read']);\n  }\n\n  hasPermission(user: User, permission: Permission): boolean {\n    const permissions = this.rolePermissions.get(user.role);\n    return permissions ? permissions.includes(permission) : false;\n  }\n\n  authorize(user: User, action: Permission): void {\n    if (!this.hasPermission(user, action)) {\n      throw new Error(`User ${user.name} (${user.role}) is not authorized to ${action}`);\n    }\n  }\n}\n\nclass DocumentService {\n  private documents: Map<string, any> = new Map();\n  private nextId = 1;\n\n  constructor(private rbac: RBAC) {}\n\n  createDocument(user: User, title: string, content: string) {\n    this.rbac.authorize(user, 'create');\n\n    const doc = {\n      id: `doc_${this.nextId++}`,\n      title,\n      content,\n      createdBy: user.id,\n      createdAt: new Date()\n    };\n\n    this.documents.set(doc.id, doc);\n    return doc;\n  }\n\n  readDocument(user: User, id: string) {\n    this.rbac.authorize(user, 'read');\n\n    const doc = this.documents.get(id);\n    if (!doc) throw new Error('Document not found');\n    return doc;\n  }\n\n  updateDocument(user: User, id: string, updates: any) {\n    this.rbac.authorize(user, 'update');\n\n    const doc = this.documents.get(id);\n    if (!doc) throw new Error('Document not found');\n\n    const updated = { ...doc, ...updates, updatedAt: new Date() };\n    this.documents.set(id, updated);\n    return updated;\n  }\n\n  deleteDocument(user: User, id: string) {\n    this.rbac.authorize(user, 'delete');\n\n    if (!this.documents.has(id)) {\n      throw new Error('Document not found');\n    }\n\n    this.documents.delete(id);\n    return { message: 'Document deleted' };\n  }\n}\n\n// Usage\nconst rbac = new RBAC();\nconst docService = new DocumentService(rbac);\n\nconst admin: User = { id: '1', name: 'Admin User', role: 'admin' };\nconst editor: User = { id: '2', name: 'Editor User', role: 'editor' };\nconst viewer: User = { id: '3', name: 'Viewer User', role: 'viewer' };\n\n// Admin can do everything\nconst doc = docService.createDocument(admin, 'First Doc', 'Content');\nconsole.log('Created:', doc);\n\n// Editor can read and update\nconsole.log('Read:', docService.readDocument(editor, doc.id));\nconsole.log('Update:', docService.updateDocument(editor, doc.id, { content: 'New content' }));\n\n// Viewer can only read\nconsole.log('Read:', docService.readDocument(viewer, doc.id));\n\ntry {\n  // Viewer cannot delete\n  docService.deleteDocument(viewer, doc.id);\n} catch (err: any) {\n  console.log('Error:', err.message);\n}\n\n// Admin can delete\nconsole.log('Delete:', docService.deleteDocument(admin, doc.id));",
    "hints": [
      "Map roles to their allowed permissions",
      "Check permissions before executing actions",
      "Throw errors for unauthorized actions",
      "More restrictive roles should have fewer permissions"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex12",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Microservices vs Monolith Decision Framework",
    "difficulty": 4,
    "description": "Create a decision framework that helps evaluate whether to use microservices or monolithic architecture. Implement a scoring system based on various factors.\n\nConsider team size, deployment frequency, scalability needs, and complexity to recommend an architecture.",
    "starterCode": "interface ProjectRequirements {\n  teamSize: number;\n  deploymentFrequency: 'daily' | 'weekly' | 'monthly';\n  expectedScale: 'small' | 'medium' | 'large';\n  serviceDiversity: 'low' | 'medium' | 'high'; // Different tech needs\n  timeline: 'short' | 'medium' | 'long';\n  budget: 'low' | 'medium' | 'high';\n}\n\ninterface ArchitectureRecommendation {\n  recommendation: 'monolith' | 'microservices' | 'modular-monolith';\n  score: number; // -10 to +10 (negative = monolith, positive = microservices)\n  reasoning: string[];\n  risks: string[];\n}\n\nclass ArchitectureDecisionFramework {\n  evaluate(requirements: ProjectRequirements): ArchitectureRecommendation {\n    // TODO: Implement scoring logic\n    // Consider:\n    // - Small teams favor monolith\n    // - High deployment frequency favors microservices\n    // - Large scale favors microservices\n    // - High service diversity favors microservices\n    // - Short timeline favors monolith\n    // - Low budget favors monolith\n\n    return {\n      recommendation: 'monolith',\n      score: 0,\n      reasoning: [],\n      risks: []\n    };\n  }\n}",
    "solution": "interface ProjectRequirements {\n  teamSize: number;\n  deploymentFrequency: 'daily' | 'weekly' | 'monthly';\n  expectedScale: 'small' | 'medium' | 'large';\n  serviceDiversity: 'low' | 'medium' | 'high';\n  timeline: 'short' | 'medium' | 'long';\n  budget: 'low' | 'medium' | 'high';\n}\n\ninterface ArchitectureRecommendation {\n  recommendation: 'monolith' | 'microservices' | 'modular-monolith';\n  score: number;\n  reasoning: string[];\n  risks: string[];\n}\n\nclass ArchitectureDecisionFramework {\n  evaluate(requirements: ProjectRequirements): ArchitectureRecommendation {\n    let score = 0;\n    const reasoning: string[] = [];\n    const risks: string[] = [];\n\n    // Team size factor\n    if (requirements.teamSize < 5) {\n      score -= 3;\n      reasoning.push('Small team size favors monolith for simpler coordination');\n    } else if (requirements.teamSize > 15) {\n      score += 3;\n      reasoning.push('Large team can manage distributed microservices');\n    } else {\n      score += 1;\n      reasoning.push('Medium team size can handle either architecture');\n    }\n\n    // Deployment frequency\n    const deploymentScores = { daily: 2, weekly: 1, monthly: -2 };\n    score += deploymentScores[requirements.deploymentFrequency];\n    reasoning.push(`${requirements.deploymentFrequency} deployments ${\n      deploymentScores[requirements.deploymentFrequency] > 0\n        ? 'benefit from microservices independence'\n        : 'acceptable with monolith'\n    }`);\n\n    // Scale requirements\n    const scaleScores = { small: -2, medium: 0, large: 3 };\n    score += scaleScores[requirements.expectedScale];\n    reasoning.push(`${requirements.expectedScale} scale ${\n      scaleScores[requirements.expectedScale] > 0\n        ? 'requires independent scaling of microservices'\n        : 'manageable with monolith'\n    }`);\n\n    // Service diversity (different tech stacks)\n    const diversityScores = { low: -1, medium: 1, high: 3 };\n    score += diversityScores[requirements.serviceDiversity];\n    reasoning.push(`${requirements.serviceDiversity} service diversity ${\n      diversityScores[requirements.serviceDiversity] > 0\n        ? 'benefits from polyglot microservices'\n        : 'suits unified monolith stack'\n    }`);\n\n    // Timeline\n    const timelineScores = { short: -3, medium: 0, long: 2 };\n    score += timelineScores[requirements.timeline];\n    reasoning.push(`${requirements.timeline} timeline ${\n      timelineScores[requirements.timeline] < 0\n        ? 'requires fast monolith development'\n        : 'allows time for microservices setup'\n    }`);\n\n    // Budget\n    const budgetScores = { low: -2, medium: 0, high: 1 };\n    score += budgetScores[requirements.budget];\n    reasoning.push(`${requirements.budget} budget ${\n      budgetScores[requirements.budget] < 0\n        ? 'limits infrastructure for microservices'\n        : 'supports distributed infrastructure'\n    }`);\n\n    // Determine recommendation\n    let recommendation: 'monolith' | 'microservices' | 'modular-monolith';\n    if (score <= -3) {\n      recommendation = 'monolith';\n      risks.push('May face scaling challenges as system grows');\n      risks.push('Deployment of entire application required for any change');\n    } else if (score >= 5) {\n      recommendation = 'microservices';\n      risks.push('Increased operational complexity');\n      risks.push('Network latency and distributed system challenges');\n      risks.push('Higher infrastructure costs');\n    } else {\n      recommendation = 'modular-monolith';\n      reasoning.push('Balanced approach: modular design with monolith simplicity');\n      risks.push('Must maintain strong module boundaries');\n    }\n\n    return {\n      recommendation,\n      score,\n      reasoning,\n      risks\n    };\n  }\n\n  printRecommendation(rec: ArchitectureRecommendation): void {\n    console.log(`\\n=== Architecture Recommendation ===`);\n    console.log(`Recommendation: ${rec.recommendation.toUpperCase()}`);\n    console.log(`Score: ${rec.score}`);\n    console.log(`\\nReasoning:`);\n    rec.reasoning.forEach((r, i) => console.log(`  ${i + 1}. ${r}`));\n    console.log(`\\nRisks to Consider:`);\n    rec.risks.forEach((r, i) => console.log(`  ${i + 1}. ${r}`));\n  }\n}\n\n// Usage examples\nconst framework = new ArchitectureDecisionFramework();\n\n// Startup scenario - favor monolith\nconst startup = framework.evaluate({\n  teamSize: 3,\n  deploymentFrequency: 'weekly',\n  expectedScale: 'small',\n  serviceDiversity: 'low',\n  timeline: 'short',\n  budget: 'low'\n});\nframework.printRecommendation(startup);\n\n// Enterprise scenario - favor microservices\nconst enterprise = framework.evaluate({\n  teamSize: 50,\n  deploymentFrequency: 'daily',\n  expectedScale: 'large',\n  serviceDiversity: 'high',\n  timeline: 'long',\n  budget: 'high'\n});\nframework.printRecommendation(enterprise);",
    "hints": [
      "Assign positive scores for factors favoring microservices",
      "Assign negative scores for factors favoring monolith",
      "Consider modular monolith for borderline cases",
      "Include both benefits and risks in the recommendation"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex13",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Caching Strategy Implementation",
    "difficulty": 3,
    "description": "Implement multiple caching strategies: LRU (Least Recently Used), LFU (Least Frequently Used), and TTL (Time To Live). Create a cache manager that supports different eviction policies.\n\nDemonstrate how different strategies behave under various access patterns.",
    "starterCode": "interface CacheEntry<T> {\n  key: string;\n  value: T;\n  accessCount: number;\n  lastAccessed: number;\n  expiresAt?: number;\n}\n\ninterface CacheStrategy {\n  get(key: string): any;\n  set(key: string, value: any, ttl?: number): void;\n  evict(): void; // Remove one item based on strategy\n}\n\nclass LRUCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | null {\n    // TODO: Update last accessed, return value\n    return null;\n  }\n\n  set(key: string, value: T): void {\n    // TODO: Add/update entry, evict if needed\n  }\n\n  evict(): void {\n    // TODO: Remove least recently used\n  }\n}\n\n// TODO: Implement LFUCache and TTLCache",
    "solution": "interface CacheEntry<T> {\n  key: string;\n  value: T;\n  accessCount: number;\n  lastAccessed: number;\n  expiresAt?: number;\n}\n\ninterface CacheStrategy {\n  get(key: string): any;\n  set(key: string, value: any, ttl?: number): void;\n  evict(): void;\n}\n\n// Least Recently Used Cache\nclass LRUCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Update last accessed\n    entry.lastAccessed = Date.now();\n    return entry.value;\n  }\n\n  set(key: string, value: T): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evict();\n    }\n\n    this.cache.set(key, {\n      key,\n      value,\n      accessCount: 0,\n      lastAccessed: Date.now()\n    });\n  }\n\n  evict(): void {\n    let lruKey = '';\n    let oldestTime = Infinity;\n\n    for (const [key, entry] of this.cache) {\n      if (entry.lastAccessed < oldestTime) {\n        oldestTime = entry.lastAccessed;\n        lruKey = key;\n      }\n    }\n\n    if (lruKey) {\n      this.cache.delete(lruKey);\n      console.log(`[LRU] Evicted: ${lruKey}`);\n    }\n  }\n}\n\n// Least Frequently Used Cache\nclass LFUCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Increment access count\n    entry.accessCount++;\n    entry.lastAccessed = Date.now();\n    return entry.value;\n  }\n\n  set(key: string, value: T): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evict();\n    }\n\n    this.cache.set(key, {\n      key,\n      value,\n      accessCount: 0,\n      lastAccessed: Date.now()\n    });\n  }\n\n  evict(): void {\n    let lfuKey = '';\n    let lowestCount = Infinity;\n\n    for (const [key, entry] of this.cache) {\n      if (entry.accessCount < lowestCount) {\n        lowestCount = entry.accessCount;\n        lfuKey = key;\n      }\n    }\n\n    if (lfuKey) {\n      this.cache.delete(lfuKey);\n      console.log(`[LFU] Evicted: ${lfuKey}`);\n    }\n  }\n}\n\n// Time To Live Cache\nclass TTLCache<T> implements CacheStrategy {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n\n  constructor(private maxSize: number, private defaultTTL: number = 60000) {}\n\n  get(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Check expiration\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      console.log(`[TTL] Expired: ${key}`);\n      return null;\n    }\n\n    entry.lastAccessed = Date.now();\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evict();\n    }\n\n    const expiresAt = Date.now() + (ttl || this.defaultTTL);\n    this.cache.set(key, {\n      key,\n      value,\n      accessCount: 0,\n      lastAccessed: Date.now(),\n      expiresAt\n    });\n  }\n\n  evict(): void {\n    // Evict expired entries first\n    for (const [key, entry] of this.cache) {\n      if (entry.expiresAt && Date.now() > entry.expiresAt) {\n        this.cache.delete(key);\n        console.log(`[TTL] Evicted expired: ${key}`);\n        return;\n      }\n    }\n\n    // If no expired, evict oldest\n    let oldestKey = '';\n    let oldestTime = Infinity;\n    for (const [key, entry] of this.cache) {\n      if ((entry.expiresAt || 0) < oldestTime) {\n        oldestTime = entry.expiresAt || 0;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n      console.log(`[TTL] Evicted: ${oldestKey}`);\n    }\n  }\n}\n\n// Usage comparison\nconsole.log('=== LRU Cache ===');\nconst lru = new LRUCache<string>(3);\nlru.set('a', 'value_a');\nlru.set('b', 'value_b');\nlru.set('c', 'value_c');\nlru.get('a'); // Access 'a' to make it recently used\nlru.set('d', 'value_d'); // Should evict 'b' (least recently used)\n\nconsole.log('\\n=== LFU Cache ===');\nconst lfu = new LFUCache<string>(3);\nlfu.set('a', 'value_a');\nlfu.set('b', 'value_b');\nlfu.set('c', 'value_c');\nlfu.get('a'); // Access 'a' twice\nlfu.get('a');\nlfu.set('d', 'value_d'); // Should evict 'b' or 'c' (least frequently used)\n\nconsole.log('\\n=== TTL Cache ===');\nconst ttl = new TTLCache<string>(3, 1000); // 1 second TTL\nttl.set('a', 'value_a', 500); // 500ms TTL\nttl.set('b', 'value_b', 2000); // 2s TTL\nsetTimeout(() => {\n  console.log('After 600ms:', ttl.get('a')); // Should be null (expired)\n  console.log('After 600ms:', ttl.get('b')); // Should exist\n}, 600);",
    "hints": [
      "LRU evicts items not accessed for longest time",
      "LFU evicts items with lowest access count",
      "TTL evicts items past their expiration time",
      "Track both lastAccessed and accessCount for different strategies"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex14",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Load Balancer Implementation",
    "difficulty": 5,
    "description": "Implement a load balancer with multiple distribution strategies: Round Robin, Least Connections, and Weighted Round Robin. Track server health and distribute requests accordingly.\n\nCreate a simulation that demonstrates how different strategies distribute load across servers.",
    "starterCode": "interface Server {\n  id: string;\n  url: string;\n  activeConnections: number;\n  weight?: number; // For weighted strategies\n  healthy: boolean;\n}\n\ninterface LoadBalancerStrategy {\n  selectServer(servers: Server[]): Server | null;\n}\n\nclass RoundRobinStrategy implements LoadBalancerStrategy {\n  private currentIndex = 0;\n\n  selectServer(servers: Server[]): Server | null {\n    // TODO: Select next server in rotation\n    return null;\n  }\n}\n\n// TODO: Implement LeastConnectionsStrategy and WeightedRoundRobinStrategy\n\nclass LoadBalancer {\n  private servers: Server[] = [];\n\n  constructor(private strategy: LoadBalancerStrategy) {}\n\n  addServer(server: Server): void {\n    // TODO\n  }\n\n  handleRequest(requestId: string): string {\n    // TODO: Select server, track connection, simulate request\n    return '';\n  }\n\n  completeRequest(serverId: string): void {\n    // TODO: Decrement active connections\n  }\n}",
    "solution": "interface Server {\n  id: string;\n  url: string;\n  activeConnections: number;\n  weight?: number;\n  healthy: boolean;\n}\n\ninterface LoadBalancerStrategy {\n  selectServer(servers: Server[]): Server | null;\n}\n\nclass RoundRobinStrategy implements LoadBalancerStrategy {\n  private currentIndex = 0;\n\n  selectServer(servers: Server[]): Server | null {\n    const healthyServers = servers.filter(s => s.healthy);\n    if (healthyServers.length === 0) return null;\n\n    const server = healthyServers[this.currentIndex % healthyServers.length];\n    this.currentIndex++;\n    return server;\n  }\n}\n\nclass LeastConnectionsStrategy implements LoadBalancerStrategy {\n  selectServer(servers: Server[]): Server | null {\n    const healthyServers = servers.filter(s => s.healthy);\n    if (healthyServers.length === 0) return null;\n\n    return healthyServers.reduce((min, server) =>\n      server.activeConnections < min.activeConnections ? server : min\n    );\n  }\n}\n\nclass WeightedRoundRobinStrategy implements LoadBalancerStrategy {\n  private currentIndex = 0;\n  private currentWeight = 0;\n\n  selectServer(servers: Server[]): Server | null {\n    const healthyServers = servers.filter(s => s.healthy);\n    if (healthyServers.length === 0) return null;\n\n    const maxWeight = Math.max(...healthyServers.map(s => s.weight || 1));\n\n    while (true) {\n      this.currentIndex = (this.currentIndex + 1) % healthyServers.length;\n\n      if (this.currentIndex === 0) {\n        this.currentWeight = this.currentWeight - 1;\n        if (this.currentWeight <= 0) {\n          this.currentWeight = maxWeight;\n        }\n      }\n\n      const server = healthyServers[this.currentIndex];\n      if ((server.weight || 1) >= this.currentWeight) {\n        return server;\n      }\n    }\n  }\n}\n\nclass LoadBalancer {\n  private servers: Server[] = [];\n\n  constructor(private strategy: LoadBalancerStrategy) {}\n\n  addServer(server: Server): void {\n    this.servers.push(server);\n  }\n\n  removeServer(serverId: string): void {\n    this.servers = this.servers.filter(s => s.id !== serverId);\n  }\n\n  setServerHealth(serverId: string, healthy: boolean): void {\n    const server = this.servers.find(s => s.id === serverId);\n    if (server) {\n      server.healthy = healthy;\n      console.log(`Server ${serverId} marked as ${healthy ? 'healthy' : 'unhealthy'}`);\n    }\n  }\n\n  handleRequest(requestId: string): string {\n    const server = this.strategy.selectServer(this.servers);\n\n    if (!server) {\n      return `Request ${requestId}: No healthy servers available`;\n    }\n\n    server.activeConnections++;\n    return `Request ${requestId} -> ${server.id} (connections: ${server.activeConnections})`;\n  }\n\n  completeRequest(serverId: string): void {\n    const server = this.servers.find(s => s.id === serverId);\n    if (server && server.activeConnections > 0) {\n      server.activeConnections--;\n    }\n  }\n\n  getStatus(): void {\n    console.log('\\n=== Server Status ===');\n    this.servers.forEach(server => {\n      console.log(`${server.id}: ${server.activeConnections} active, ${\n        server.healthy ? 'healthy' : 'UNHEALTHY'\n      }${server.weight ? `, weight: ${server.weight}` : ''}`);\n    });\n  }\n}\n\n// Usage comparison\nconsole.log('=== Round Robin Strategy ===');\nconst rrLB = new LoadBalancer(new RoundRobinStrategy());\nrrLB.addServer({ id: 'server1', url: 'http://server1', activeConnections: 0, healthy: true });\nrrLB.addServer({ id: 'server2', url: 'http://server2', activeConnections: 0, healthy: true });\nrrLB.addServer({ id: 'server3', url: 'http://server3', activeConnections: 0, healthy: true });\n\nfor (let i = 1; i <= 5; i++) {\n  console.log(rrLB.handleRequest(`req${i}`));\n}\nrrLB.getStatus();\n\nconsole.log('\\n=== Least Connections Strategy ===');\nconst lcLB = new LoadBalancer(new LeastConnectionsStrategy());\nlcLB.addServer({ id: 'server1', url: 'http://server1', activeConnections: 3, healthy: true });\nlcLB.addServer({ id: 'server2', url: 'http://server2', activeConnections: 1, healthy: true });\nlcLB.addServer({ id: 'server3', url: 'http://server3', activeConnections: 5, healthy: true });\n\nfor (let i = 1; i <= 3; i++) {\n  console.log(lcLB.handleRequest(`req${i}`));\n}\nlcLB.getStatus();\n\nconsole.log('\\n=== Weighted Round Robin Strategy ===');\nconst wrrLB = new LoadBalancer(new WeightedRoundRobinStrategy());\nwrrLB.addServer({ id: 'server1', url: 'http://server1', activeConnections: 0, healthy: true, weight: 3 });\nwrrLB.addServer({ id: 'server2', url: 'http://server2', activeConnections: 0, healthy: true, weight: 1 });\n\nfor (let i = 1; i <= 8; i++) {\n  console.log(wrrLB.handleRequest(`req${i}`));\n}\nwrrLB.getStatus();",
    "hints": [
      "Round Robin cycles through servers sequentially",
      "Least Connections selects server with fewest active requests",
      "Weighted Round Robin favors servers with higher weights",
      "Always filter out unhealthy servers before selection"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex15",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Horizontal vs Vertical Scaling Simulator",
    "difficulty": 5,
    "description": "Create a simulator that demonstrates the differences between horizontal and vertical scaling. Model server capacity, request handling, and scaling decisions.\n\nImplement auto-scaling logic that decides when to scale horizontally (add servers) or vertically (increase server capacity).",
    "starterCode": "interface ServerInstance {\n  id: string;\n  cpu: number; // cores\n  memory: number; // GB\n  maxRequests: number;\n  currentRequests: number;\n  utilizationPercent: number;\n}\n\nclass VerticalScaling {\n  private server: ServerInstance;\n\n  constructor(initialCPU: number, initialMemory: number) {\n    // TODO: Initialize server\n  }\n\n  scaleUp(): void {\n    // TODO: Increase CPU and memory\n  }\n\n  canHandle(requests: number): boolean {\n    // TODO: Check if server can handle load\n    return false;\n  }\n}\n\nclass HorizontalScaling {\n  private servers: ServerInstance[] = [];\n\n  addServer(): void {\n    // TODO: Add new server instance\n  }\n\n  removeServer(): void {\n    // TODO: Remove least utilized server\n  }\n\n  distributeLoad(totalRequests: number): void {\n    // TODO: Distribute requests across servers\n  }\n}\n\nclass AutoScaler {\n  decide(currentLoad: number, capacity: number): 'scale-up' | 'scale-out' | 'none' {\n    // TODO: Decide scaling strategy\n    return 'none';\n  }\n}",
    "solution": "interface ServerInstance {\n  id: string;\n  cpu: number;\n  memory: number;\n  maxRequests: number;\n  currentRequests: number;\n  utilizationPercent: number;\n}\n\nclass VerticalScaling {\n  private server: ServerInstance;\n  private scaleCount = 0;\n\n  constructor(initialCPU: number, initialMemory: number) {\n    this.server = {\n      id: 'vertical-server',\n      cpu: initialCPU,\n      memory: initialMemory,\n      maxRequests: initialCPU * 100,\n      currentRequests: 0,\n      utilizationPercent: 0\n    };\n  }\n\n  scaleUp(): void {\n    this.scaleCount++;\n    this.server.cpu *= 2;\n    this.server.memory *= 2;\n    this.server.maxRequests = this.server.cpu * 100;\n    console.log(`[Vertical] Scaled UP to ${this.server.cpu} CPU, ${this.server.memory}GB RAM`);\n    console.log(`[Vertical] Max requests: ${this.server.maxRequests}`);\n  }\n\n  handleLoad(requests: number): void {\n    this.server.currentRequests = requests;\n    this.server.utilizationPercent = (requests / this.server.maxRequests) * 100;\n  }\n\n  canHandle(requests: number): boolean {\n    return requests <= this.server.maxRequests;\n  }\n\n  getStatus(): string {\n    return `Vertical: ${this.server.cpu} CPU, ${this.server.memory}GB, ${\n      this.server.currentRequests\n    }/${this.server.maxRequests} requests (${\n      this.server.utilizationPercent.toFixed(1)\n    }% utilized)`;\n  }\n\n  getCost(): number {\n    // Cost increases exponentially with vertical scaling\n    return Math.pow(this.server.cpu, 1.5) * 10;\n  }\n}\n\nclass HorizontalScaling {\n  private servers: ServerInstance[] = [];\n  private nextId = 1;\n  private serverCPU = 2;\n  private serverMemory = 8;\n\n  constructor() {\n    this.addServer(); // Start with one server\n  }\n\n  addServer(): void {\n    const server: ServerInstance = {\n      id: `horizontal-server-${this.nextId++}`,\n      cpu: this.serverCPU,\n      memory: this.serverMemory,\n      maxRequests: this.serverCPU * 100,\n      currentRequests: 0,\n      utilizationPercent: 0\n    };\n    this.servers.push(server);\n    console.log(`[Horizontal] Added ${server.id}`);\n  }\n\n  removeServer(): void {\n    if (this.servers.length <= 1) return;\n\n    const removed = this.servers.pop();\n    console.log(`[Horizontal] Removed ${removed?.id}`);\n  }\n\n  distributeLoad(totalRequests: number): void {\n    const requestsPerServer = Math.ceil(totalRequests / this.servers.length);\n\n    this.servers.forEach(server => {\n      server.currentRequests = Math.min(requestsPerServer, server.maxRequests);\n      server.utilizationPercent = (server.currentRequests / server.maxRequests) * 100;\n    });\n  }\n\n  canHandle(requests: number): boolean {\n    const totalCapacity = this.servers.reduce((sum, s) => sum + s.maxRequests, 0);\n    return requests <= totalCapacity;\n  }\n\n  getStatus(): string {\n    const total = this.servers.reduce((sum, s) => sum + s.currentRequests, 0);\n    const capacity = this.servers.reduce((sum, s) => sum + s.maxRequests, 0);\n    const avgUtil = (total / capacity) * 100;\n\n    return `Horizontal: ${this.servers.length} servers, ${total}/${capacity} requests (${\n      avgUtil.toFixed(1)\n    }% avg utilized)`;\n  }\n\n  getCost(): number {\n    // Cost increases linearly with horizontal scaling\n    return this.servers.length * this.serverCPU * 10;\n  }\n}\n\nclass AutoScaler {\n  decide(\n    currentLoad: number,\n    capacity: number,\n    costVertical: number,\n    costHorizontal: number\n  ): 'scale-up' | 'scale-out' | 'none' {\n    const utilization = (currentLoad / capacity) * 100;\n\n    if (utilization < 60) {\n      return 'none'; // Underutilized\n    }\n\n    if (utilization > 80) {\n      // Need to scale - decide which approach\n      if (costHorizontal < costVertical * 0.8) {\n        return 'scale-out'; // Horizontal is more cost-effective\n      } else {\n        return 'scale-up'; // Vertical is more cost-effective\n      }\n    }\n\n    return 'none';\n  }\n}\n\n// Simulation\nconsole.log('=== Scaling Comparison Simulation ===\\n');\n\nconst vertical = new VerticalScaling(2, 8);\nconst horizontal = new HorizontalScaling();\nconst autoScaler = new AutoScaler();\n\nconst loadLevels = [100, 200, 500, 1000, 2000];\n\nloadLevels.forEach(load => {\n  console.log(`\\n--- Load: ${load} requests ---`);\n\n  // Vertical scaling\n  while (!vertical.canHandle(load)) {\n    vertical.scaleUp();\n  }\n  vertical.handleLoad(load);\n  console.log(vertical.getStatus());\n  console.log(`Vertical cost: $${vertical.getCost().toFixed(2)}`);\n\n  // Horizontal scaling\n  while (!horizontal.canHandle(load)) {\n    horizontal.addServer();\n  }\n  horizontal.distributeLoad(load);\n  console.log(horizontal.getStatus());\n  console.log(`Horizontal cost: $${horizontal.getCost().toFixed(2)}`);\n});\n\nconsole.log(`\\n=== Summary ===`);\nconsole.log('Vertical Scaling:');\nconsole.log('  Pros: Simple, no distributed system complexity');\nconsole.log('  Cons: Hardware limits, downtime during scaling, exponential cost');\nconsole.log('\\nHorizontal Scaling:');\nconsole.log('  Pros: No hardware limits, high availability, linear cost');\nconsole.log('  Cons: Distributed system complexity, load balancing needed');",
    "hints": [
      "Vertical scaling increases single server capacity",
      "Horizontal scaling adds more server instances",
      "Vertical scaling has hardware limits and downtime",
      "Horizontal scaling provides redundancy and fault tolerance"
    ],
    "testCases": [],
    "language": "typescript"
  },
  {
    "id": "cs404-t2-ex16",
    "subjectId": "cs404",
    "topicId": "cs404-topic-2",
    "title": "Technology Stack Evaluation Matrix",
    "difficulty": 5,
    "description": "Create a comprehensive technology stack evaluation system that scores different tech stacks based on project requirements. Consider factors like performance, developer experience, ecosystem, scalability, and cost.\n\nBuild a decision matrix that recommends the best stack for different project types (startup MVP, enterprise app, high-traffic service).",
    "starterCode": "interface TechStack {\n  name: string;\n  frontend: string;\n  backend: string;\n  database: string;\n  deployment: string;\n}\n\ninterface ProjectRequirements {\n  projectType: 'mvp' | 'enterprise' | 'high-traffic';\n  teamExpertise: string[]; // Languages/frameworks team knows\n  budget: 'low' | 'medium' | 'high';\n  timeToMarket: 'fast' | 'medium' | 'slow';\n  scalabilityNeeds: 'low' | 'medium' | 'high';\n  performanceCritical: boolean;\n}\n\ninterface StackEvaluation {\n  stack: TechStack;\n  score: number;\n  strengths: string[];\n  weaknesses: string[];\n  estimatedCost: number;\n  learningCurve: 'low' | 'medium' | 'high';\n}\n\nclass StackEvaluator {\n  private stacks: TechStack[] = [];\n\n  addStack(stack: TechStack): void {\n    // TODO\n  }\n\n  evaluate(requirements: ProjectRequirements): StackEvaluation[] {\n    // TODO: Score each stack based on requirements\n    return [];\n  }\n\n  recommend(requirements: ProjectRequirements): StackEvaluation {\n    // TODO: Return best stack\n    return null as any;\n  }\n}",
    "solution": "interface TechStack {\n  name: string;\n  frontend: string;\n  backend: string;\n  database: string;\n  deployment: string;\n  maturity: number; // 1-10\n  communitySize: number; // 1-10\n  performance: number; // 1-10\n  scalability: number; // 1-10\n  devSpeed: number; // 1-10 (how fast to develop)\n  hostingCost: number; // 1-10 (10 = most expensive)\n  learningCurve: 'low' | 'medium' | 'high';\n}\n\ninterface ProjectRequirements {\n  projectType: 'mvp' | 'enterprise' | 'high-traffic';\n  teamExpertise: string[];\n  budget: 'low' | 'medium' | 'high';\n  timeToMarket: 'fast' | 'medium' | 'slow';\n  scalabilityNeeds: 'low' | 'medium' | 'high';\n  performanceCritical: boolean;\n}\n\ninterface StackEvaluation {\n  stack: TechStack;\n  score: number;\n  strengths: string[];\n  weaknesses: string[];\n  estimatedCost: number;\n  learningCurve: 'low' | 'medium' | 'high';\n}\n\nclass StackEvaluator {\n  private stacks: TechStack[] = [];\n\n  constructor() {\n    // Define common tech stacks\n    this.addStack({\n      name: 'MERN (MongoDB, Express, React, Node.js)',\n      frontend: 'React',\n      backend: 'Node.js/Express',\n      database: 'MongoDB',\n      deployment: 'Vercel/Heroku',\n      maturity: 8,\n      communitySize: 10,\n      performance: 7,\n      scalability: 7,\n      devSpeed: 9,\n      hostingCost: 4,\n      learningCurve: 'medium'\n    });\n\n    this.addStack({\n      name: 'Django/PostgreSQL',\n      frontend: 'React/Vue',\n      backend: 'Django/Python',\n      database: 'PostgreSQL',\n      deployment: 'AWS/GCP',\n      maturity: 10,\n      communitySize: 9,\n      performance: 8,\n      scalability: 8,\n      devSpeed: 8,\n      hostingCost: 6,\n      learningCurve: 'medium'\n    });\n\n    this.addStack({\n      name: 'Spring Boot/Java Enterprise',\n      frontend: 'Angular',\n      backend: 'Spring Boot/Java',\n      database: 'Oracle/PostgreSQL',\n      deployment: 'Enterprise servers',\n      maturity: 10,\n      communitySize: 8,\n      performance: 9,\n      scalability: 10,\n      devSpeed: 6,\n      hostingCost: 8,\n      learningCurve: 'high'\n    });\n\n    this.addStack({\n      name: 'Jamstack (Next.js, Serverless)',\n      frontend: 'Next.js/React',\n      backend: 'Serverless Functions',\n      database: 'Firebase/Supabase',\n      deployment: 'Vercel/Netlify',\n      maturity: 7,\n      communitySize: 9,\n      performance: 9,\n      scalability: 9,\n      devSpeed: 10,\n      hostingCost: 3,\n      learningCurve: 'low'\n    });\n\n    this.addStack({\n      name: 'Go Microservices',\n      frontend: 'React/Vue',\n      backend: 'Go',\n      database: 'PostgreSQL/Redis',\n      deployment: 'Kubernetes',\n      maturity: 8,\n      communitySize: 7,\n      performance: 10,\n      scalability: 10,\n      devSpeed: 7,\n      hostingCost: 7,\n      learningCurve: 'high'\n    });\n  }\n\n  addStack(stack: TechStack): void {\n    this.stacks.push(stack);\n  }\n\n  evaluate(requirements: ProjectRequirements): StackEvaluation[] {\n    return this.stacks.map(stack => {\n      let score = 0;\n      const strengths: string[] = [];\n      const weaknesses: string[] = [];\n\n      // Project type scoring\n      if (requirements.projectType === 'mvp') {\n        score += stack.devSpeed * 3; // Fast development is critical\n        score += stack.hostingCost * -1; // Low cost is important\n        if (stack.devSpeed >= 8) strengths.push('Fast development for MVP');\n        if (stack.learningCurve === 'high') weaknesses.push('Steep learning curve slows MVP');\n      } else if (requirements.projectType === 'enterprise') {\n        score += stack.maturity * 2;\n        score += stack.scalability * 2;\n        if (stack.maturity >= 9) strengths.push('Battle-tested for enterprise');\n        if (stack.communitySize < 7) weaknesses.push('Smaller community support');\n      } else if (requirements.projectType === 'high-traffic') {\n        score += stack.performance * 3;\n        score += stack.scalability * 3;\n        if (stack.performance >= 9) strengths.push('Excellent performance characteristics');\n        if (stack.scalability < 8) weaknesses.push('May struggle at high scale');\n      }\n\n      // Team expertise bonus\n      const stackTechs = [stack.frontend, stack.backend, stack.database].join(' ').toLowerCase();\n      const expertiseMatch = requirements.teamExpertise.some(skill =>\n        stackTechs.includes(skill.toLowerCase())\n      );\n      if (expertiseMatch) {\n        score += 10;\n        strengths.push('Team has relevant expertise');\n      } else {\n        weaknesses.push('Team needs to learn new technologies');\n      }\n\n      // Budget constraints\n      const budgetScores = { low: 3, medium: 6, high: 10 };\n      if (stack.hostingCost <= budgetScores[requirements.budget]) {\n        score += 5;\n        strengths.push('Fits within budget constraints');\n      } else {\n        score -= 5;\n        weaknesses.push('Higher hosting costs than budget allows');\n      }\n\n      // Time to market\n      if (requirements.timeToMarket === 'fast' && stack.devSpeed >= 8) {\n        score += 8;\n        strengths.push('Enables rapid development');\n      }\n\n      // Scalability needs\n      const scalabilityScores = { low: 5, medium: 7, high: 9 };\n      if (stack.scalability >= scalabilityScores[requirements.scalabilityNeeds]) {\n        score += 5;\n        strengths.push('Meets scalability requirements');\n      } else {\n        weaknesses.push('May not scale to requirements');\n      }\n\n      // Performance critical\n      if (requirements.performanceCritical && stack.performance >= 8) {\n        score += 10;\n        strengths.push('High-performance capabilities');\n      } else if (requirements.performanceCritical && stack.performance < 7) {\n        score -= 5;\n        weaknesses.push('Performance may not meet requirements');\n      }\n\n      const estimatedCost = stack.hostingCost * 100; // Monthly cost estimate\n\n      return {\n        stack,\n        score,\n        strengths,\n        weaknesses,\n        estimatedCost,\n        learningCurve: stack.learningCurve\n      };\n    }).sort((a, b) => b.score - a.score);\n  }\n\n  recommend(requirements: ProjectRequirements): StackEvaluation {\n    const evaluations = this.evaluate(requirements);\n    return evaluations[0];\n  }\n\n  printEvaluation(evaluation: StackEvaluation): void {\n    console.log(`\\n=== ${evaluation.stack.name} ===`);\n    console.log(`Score: ${evaluation.score}`);\n    console.log(`Frontend: ${evaluation.stack.frontend}`);\n    console.log(`Backend: ${evaluation.stack.backend}`);\n    console.log(`Database: ${evaluation.stack.database}`);\n    console.log(`Estimated Monthly Cost: $${evaluation.estimatedCost}`);\n    console.log(`Learning Curve: ${evaluation.learningCurve}`);\n    console.log(`\\nStrengths:`);\n    evaluation.strengths.forEach(s => console.log(`  + ${s}`));\n    console.log(`\\nWeaknesses:`);\n    evaluation.weaknesses.forEach(w => console.log(`  - ${w}`));\n  }\n}\n\n// Usage examples\nconst evaluator = new StackEvaluator();\n\nconsole.log('=== Startup MVP Scenario ===');\nconst mvpRequirements: ProjectRequirements = {\n  projectType: 'mvp',\n  teamExpertise: ['JavaScript', 'React'],\n  budget: 'low',\n  timeToMarket: 'fast',\n  scalabilityNeeds: 'low',\n  performanceCritical: false\n};\n\nconst mvpRecommendation = evaluator.recommend(mvpRequirements);\nevaluator.printEvaluation(mvpRecommendation);\n\nconsole.log('\\n\\n=== Enterprise Application Scenario ===');\nconst enterpriseRequirements: ProjectRequirements = {\n  projectType: 'enterprise',\n  teamExpertise: ['Java', 'Spring'],\n  budget: 'high',\n  timeToMarket: 'medium',\n  scalabilityNeeds: 'high',\n  performanceCritical: true\n};\n\nconst enterpriseRecommendation = evaluator.recommend(enterpriseRequirements);\nevaluator.printEvaluation(enterpriseRecommendation);\n\nconsole.log('\\n\\n=== High-Traffic Service Scenario ===');\nconst highTrafficRequirements: ProjectRequirements = {\n  projectType: 'high-traffic',\n  teamExpertise: ['Go', 'Kubernetes'],\n  budget: 'medium',\n  timeToMarket: 'medium',\n  scalabilityNeeds: 'high',\n  performanceCritical: true\n};\n\nconst highTrafficRecommendation = evaluator.recommend(highTrafficRequirements);\nevaluator.printEvaluation(highTrafficRecommendation);",
    "hints": [
      "Score stacks differently based on project type",
      "Give bonus points for team expertise matches",
      "Consider both technical and business requirements",
      "Balance immediate needs with long-term scalability"
    ],
    "testCases": [],
    "language": "typescript"
  }
]

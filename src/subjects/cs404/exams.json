[
  {
    "id": "cs404-midterm",
    "subjectId": "cs404",
    "title": "Capstone Project Midterm Assessment",
    "durationMinutes": 75,
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "You are starting a capstone project to build a carbon footprint tracking application. Which of the following should be your FIRST step?",
        "options": [
          "Start coding the frontend interface",
          "Set up the database schema",
          "Define project scope and MVP features",
          "Deploy the application to production"
        ],
        "correctAnswer": 2,
        "explanation": "Always start with scope definition and MVP planning. Understanding WHAT you're building before HOW you'll build it prevents wasted effort and scope creep."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "Your project timeline shows you are 2 weeks behind schedule with 6 weeks remaining. What is the BEST course of action?",
        "options": [
          "Reduce scope by deferring \"Could Have\" features",
          "Request a deadline extension",
          "Continue as planned and hope for the best",
          "Work 16-hour days to catch up"
        ],
        "correctAnswer": 0,
        "explanation": "Reducing scope strategically (cutting non-critical features) is the most sustainable way to get back on track while still delivering a complete MVP."
      },
      {
        "id": "q3",
        "type": "fill_blank",
        "prompt": "The _____ methodology emphasizes iterative development, where requirements evolve through collaboration between cross-functional teams.",
        "correctAnswer": "Agile",
        "explanation": "Agile methodology uses iterative development cycles (sprints) with continuous feedback and adaptation."
      },
      {
        "id": "q4",
        "type": "true_false",
        "prompt": "In MoSCoW prioritization, \"Should Have\" features should be implemented before \"Must Have\" features.",
        "correctAnswer": false,
        "explanation": "Must Have features are the highest priority and must be implemented first as they are critical to the MVP. Should Have features are important but not critical."
      },
      {
        "id": "q5",
        "type": "written",
        "prompt": "Explain the difference between functional and non-functional requirements. Provide one example of each for a carbon tracking app.",
        "correctAnswer": "Functional requirements define what the system should do (features/functionality), while non-functional requirements define how the system should perform (quality attributes). Example: Functional - Users can log transportation activities. Non-functional - The app should load within 2 seconds.",
        "explanation": "Functional requirements specify system behavior and features. Non-functional requirements specify quality attributes like performance, security, and usability.",
        "modelAnswer": "Functional requirements describe specific behaviors or functions of the system, such as \"Users must be able to create an account\" or \"The system must calculate carbon emissions based on activity type.\" Non-functional requirements describe quality attributes or constraints, such as \"The application must respond to user actions within 2 seconds\" or \"The system must support 1000 concurrent users.\" For a carbon tracking app: Functional example - \"Users can log daily transportation activities with distance and mode.\" Non-functional example - \"The app must maintain 99.9% uptime during business hours.\""
      },
      {
        "id": "q6",
        "type": "multiple_choice",
        "prompt": "In the context of a capstone project, what defines a \"good\" requirement?",
        "options": [
          "Written in technical jargon to sound professional",
          "Specific, measurable, achievable, relevant, and time-bound (SMART)",
          "As detailed as possible with every implementation detail",
          "Vague enough to allow flexibility"
        ],
        "correctAnswer": 1,
        "explanation": "Good requirements follow SMART criteria: they're specific enough to be testable, achievable within constraints, and provide clear success criteria."
      },
      {
        "id": "q7",
        "type": "multiple_choice",
        "prompt": "Which risk management strategy involves creating backup plans for critical project dependencies?",
        "options": [
          "Risk mitigation",
          "Risk acceptance",
          "Risk avoidance",
          "Risk transfer"
        ],
        "correctAnswer": 0,
        "explanation": "Risk mitigation involves taking steps to reduce the likelihood or impact of risks, such as creating backup plans for dependencies."
      },
      {
        "id": "q8",
        "type": "multiple_choice",
        "prompt": "Which of the following best demonstrates the Single Responsibility Principle in backend code?",
        "options": [
          "Inline database queries in route handlers",
          "A UserController that handles authentication, profile management, and password reset",
          "One large service file that handles all user-related operations",
          "Separate controllers for AuthController, ProfileController, and PasswordController"
        ],
        "correctAnswer": 3,
        "explanation": "The Single Responsibility Principle states each module should have one reason to change. Separate controllers for distinct concerns follows this principle."
      },
      {
        "id": "q9",
        "type": "multiple_choice",
        "prompt": "Which of the following is a well-structured database schema for a one-to-many relationship between Users and Activities?",
        "options": [
          "Users table has an activities_array column storing JSON",
          "Activities table has a user_id foreign key referencing Users.id",
          "Separate junction table between Users and Activities",
          "Both tables have references to each other"
        ],
        "correctAnswer": 1,
        "explanation": "In one-to-many relationships, the \"many\" side (Activities) should have a foreign key referencing the \"one\" side (Users)."
      },
      {
        "id": "q10",
        "type": "multiple_choice",
        "prompt": "You need to calculate carbon emissions for different activity types (car, bus, plane). Which design pattern is most appropriate?",
        "options": [
          "Singleton Pattern",
          "Observer Pattern",
          "Strategy Pattern",
          "Decorator Pattern"
        ],
        "correctAnswer": 2,
        "explanation": "Strategy Pattern allows you to define a family of algorithms (calculation methods), encapsulate each one, and make them interchangeable."
      },
      {
        "id": "q11",
        "type": "multiple_choice",
        "prompt": "What is the Repository pattern's primary benefit?",
        "options": [
          "It automatically creates database tables",
          "It eliminates the need for a database",
          "It separates data access logic from business logic",
          "It makes code run faster"
        ],
        "correctAnswer": 2,
        "explanation": "The Repository pattern abstracts data access, allowing business logic to work with data through a clean interface without knowing database implementation details."
      },
      {
        "id": "q12",
        "type": "fill_blank",
        "prompt": "The _____ pattern ensures a class has only one instance and provides a global point of access to it.",
        "correctAnswer": "Singleton",
        "explanation": "The Singleton pattern restricts instantiation of a class to a single instance, commonly used for configuration managers or database connections."
      },
      {
        "id": "q13",
        "type": "true_false",
        "prompt": "In a three-tier architecture, the presentation layer should contain business logic for calculating carbon emissions.",
        "correctAnswer": false,
        "explanation": "Business logic belongs in the business/application layer, not the presentation layer. The presentation layer should only handle UI and user interaction."
      },
      {
        "id": "q14",
        "type": "written",
        "prompt": "Describe the MVC (Model-View-Controller) architecture pattern and explain how it promotes separation of concerns.",
        "correctAnswer": "MVC separates an application into three components: Model (data and business logic), View (UI/presentation), and Controller (handles user input and coordinates between Model and View). This separation allows independent development and testing of each component.",
        "explanation": "MVC is a fundamental architectural pattern that separates concerns, making applications more maintainable and testable.",
        "modelAnswer": "MVC (Model-View-Controller) is an architectural pattern that divides an application into three interconnected components. The Model represents the data and business logic, managing the application state and rules. The View is responsible for presentation, displaying data to users without containing business logic. The Controller acts as an intermediary, handling user input, updating the Model, and selecting the appropriate View. This separation of concerns allows developers to modify the UI without affecting business logic, change data structures without touching the presentation layer, and test components independently. For example, in a carbon tracking app, the Model would handle emission calculations, the View would display the results in charts, and the Controller would process user activity inputs."
      },
      {
        "id": "q15",
        "type": "multiple_choice",
        "prompt": "You need to store user passwords in your database. What is the CORRECT approach?",
        "options": [
          "Store passwords in plain text for easy password reset",
          "Encrypt passwords with AES encryption",
          "Hash passwords using bcrypt with appropriate salt rounds",
          "Store passwords in Base64 encoding"
        ],
        "correctAnswer": 2,
        "explanation": "Always hash passwords with bcrypt (or similar). Hashing is one-way and designed for passwords. Encryption is reversible and inappropriate for passwords."
      },
      {
        "id": "q16",
        "type": "multiple_choice",
        "prompt": "What is the purpose of database indexing?",
        "options": [
          "To improve query performance on frequently searched columns",
          "To automatically create backups",
          "To make the database larger",
          "To encrypt sensitive data"
        ],
        "correctAnswer": 0,
        "explanation": "Indexes create data structures that speed up data retrieval on indexed columns, dramatically improving query performance."
      },
      {
        "id": "q17",
        "type": "multiple_choice",
        "prompt": "Which REST API endpoint design is MOST correct for getting a specific user's activities?",
        "options": [
          "GET /api/getUserActivities?userId=123",
          "GET /api/getActivities/123",
          "POST /api/activities/get",
          "GET /api/users/123/activities"
        ],
        "correctAnswer": 3,
        "explanation": "RESTful design uses resource-based URLs (nouns, not verbs) and proper HTTP methods. GET /api/users/123/activities clearly shows the resource hierarchy."
      },
      {
        "id": "q18",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of using environment variables in your application?",
        "options": [
          "To separate configuration (API keys, database URLs) from code",
          "To reduce code file size",
          "To enable debugging",
          "To make the application run faster"
        ],
        "correctAnswer": 0,
        "explanation": "Environment variables externalize configuration, allowing the same code to run in different environments (dev, staging, production) with different settings."
      },
      {
        "id": "q19",
        "type": "code_output",
        "prompt": "What will be logged to the console?",
        "codeSnippet": "const calculateEmissions = (distance: number, type: string): number => {\n  const factors = { car: 0.21, bus: 0.089, bike: 0 };\n  return distance * (factors[type] || 0);\n};\n\nconsole.log(calculateEmissions(100, 'car'));",
        "correctAnswer": "21",
        "explanation": "The function multiplies distance (100) by the emission factor for car (0.21), resulting in 100 * 0.21 = 21."
      },
      {
        "id": "q20",
        "type": "fill_blank",
        "prompt": "In REST APIs, the _____ HTTP method is used to create a new resource on the server.",
        "correctAnswer": "POST",
        "explanation": "POST is the standard HTTP method for creating new resources. GET retrieves, PUT/PATCH updates, and DELETE removes resources."
      },
      {
        "id": "q21",
        "type": "true_false",
        "prompt": "It is acceptable to commit API keys and database passwords directly to a public Git repository as long as you delete them later.",
        "correctAnswer": false,
        "explanation": "Never commit secrets to Git, even temporarily. Git history retains all commits, so secrets remain accessible. Always use environment variables and .gitignore."
      },
      {
        "id": "q22",
        "type": "multiple_choice",
        "prompt": "In a typical web application architecture, which component should handle user authentication?",
        "options": [
          "CDN layer",
          "Database stored procedures",
          "Frontend components directly",
          "Backend API with middleware"
        ],
        "correctAnswer": 3,
        "explanation": "Authentication should be handled on the backend with middleware that validates tokens/sessions before allowing access to protected routes."
      },
      {
        "id": "q23",
        "type": "multiple_choice",
        "prompt": "What is the main advantage of using TypeScript over JavaScript for a capstone project?",
        "options": [
          "TypeScript catches type errors at compile time",
          "TypeScript works in more browsers",
          "TypeScript has more features",
          "TypeScript is faster at runtime"
        ],
        "correctAnswer": 0,
        "explanation": "TypeScript's main benefit is compile-time type checking, which catches errors before runtime and improves code quality and maintainability."
      },
      {
        "id": "q24",
        "type": "multiple_choice",
        "prompt": "Which HTTP status code should your API return when a user tries to access another user's private data?",
        "options": [
          "401 Unauthorized",
          "403 Forbidden",
          "404 Not Found",
          "500 Internal Server Error"
        ],
        "correctAnswer": 1,
        "explanation": "403 Forbidden indicates the user is authenticated but doesn't have permission to access the resource. 401 would mean not authenticated."
      },
      {
        "id": "q25",
        "type": "multiple_choice",
        "prompt": "What is the purpose of a .gitignore file?",
        "options": [
          "To ignore bugs in code",
          "To prevent specific files from being tracked by Git",
          "To hide files from other developers",
          "To compress files before committing"
        ],
        "correctAnswer": 1,
        "explanation": ".gitignore specifies files and directories that Git should not track, such as node_modules, .env files, and build outputs."
      },
      {
        "id": "q26",
        "type": "multiple_choice",
        "prompt": "Your database queries are slow. What should you do FIRST?",
        "options": [
          "Switch to a different database",
          "Rewrite the entire application",
          "Profile queries to identify bottlenecks, then add indexes",
          "Increase server RAM"
        ],
        "correctAnswer": 2,
        "explanation": "Always measure before optimizing. Profile to find slow queries, then add appropriate indexes or optimize query structure."
      },
      {
        "id": "q27",
        "type": "code_output",
        "prompt": "What will be the value of result?",
        "codeSnippet": "interface Activity {\n  type: string;\n  distance: number;\n}\n\nconst activities: Activity[] = [\n  { type: 'car', distance: 10 },\n  { type: 'bus', distance: 5 },\n  { type: 'car', distance: 15 }\n];\n\nconst result = activities\n  .filter(a => a.type === 'car')\n  .reduce((sum, a) => sum + a.distance, 0);\n\nconsole.log(result);",
        "correctAnswer": "25",
        "explanation": "The code filters for car activities (10 and 15), then sums their distances: 10 + 15 = 25."
      },
      {
        "id": "q28",
        "type": "written",
        "prompt": "Explain the difference between authentication and authorization. Provide an example of each in a web application.",
        "correctAnswer": "Authentication verifies who the user is (identity), while authorization determines what the user can access (permissions). Example: Authentication - User logs in with email/password. Authorization - Admin users can delete activities, regular users cannot.",
        "explanation": "Authentication and authorization are distinct security concepts that work together to secure applications.",
        "modelAnswer": "Authentication is the process of verifying a user's identity - confirming they are who they claim to be. This typically involves credentials like username/password, OAuth tokens, or biometrics. Authorization is the process of determining what an authenticated user is allowed to do - what resources they can access and what actions they can perform. For example, in a carbon tracking app: Authentication occurs when a user logs in with their email and password, and the system verifies these credentials are correct and issues a JWT token. Authorization occurs when the authenticated user tries to view their activity history (allowed) or tries to delete another user's data (denied). Authentication answers \"who are you?\" while authorization answers \"what are you allowed to do?\""
      },
      {
        "id": "q29",
        "type": "multiple_choice",
        "prompt": "What is the main purpose of code review, even in a solo capstone project?",
        "options": [
          "To satisfy academic requirements only",
          "To make the project look more complex",
          "To identify bugs, improve code quality, and reflect on design decisions",
          "To delay the project timeline"
        ],
        "correctAnswer": 2,
        "explanation": "Code review (even self-review) catches bugs, improves code quality, identifies refactoring opportunities, and demonstrates professional development practices."
      },
      {
        "id": "q30",
        "type": "multiple_choice",
        "prompt": "When should you commit code to Git?",
        "options": [
          "Only when the entire project is complete",
          "Frequently, after each logical change or working feature",
          "Once per week",
          "Only when requested by your advisor"
        ],
        "correctAnswer": 1,
        "explanation": "Commit frequently with atomic, logical changes. This provides fine-grained history, makes debugging easier, and protects work."
      }
    ]
  },
  {
    "id": "cs404-final",
    "subjectId": "cs404",
    "title": "Capstone Project Final Examination",
    "durationMinutes": 120,
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "Which of the following BEST describes an effective MVP for a capstone project?",
        "options": [
          "The simplest possible version regardless of user value",
          "A fully featured application without advanced features",
          "The minimum set of features that solve the core problem and can be delivered on time",
          "A prototype with minimal functionality and no polish"
        ],
        "correctAnswer": 2,
        "explanation": "An MVP balances delivering real user value with practical constraints. It solves the core problem with essential features only."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "Your capstone project requires integrating with a third-party weather API. What is the MOST important risk mitigation strategy?",
        "options": [
          "Abstract the API behind an interface and identify backup options",
          "Build your own weather service from scratch",
          "Assume the API will never fail",
          "Use the API without any fallback plan"
        ],
        "correctAnswer": 0,
        "explanation": "Abstracting external dependencies behind interfaces allows swapping implementations and protects against API changes or failures."
      },
      {
        "id": "q3",
        "type": "fill_blank",
        "prompt": "A _____ chart is a visual project management tool that shows tasks over time, helping track project progress and deadlines.",
        "correctAnswer": "Gantt",
        "explanation": "A Gantt chart displays project tasks as horizontal bars across a timeline, showing dependencies, duration, and progress."
      },
      {
        "id": "q4",
        "type": "true_false",
        "prompt": "Feature creep refers to the controlled addition of well-planned features during a project.",
        "correctAnswer": false,
        "explanation": "Feature creep is the uncontrolled addition of features beyond the original scope, often leading to delays and reduced quality. It should be avoided."
      },
      {
        "id": "q5",
        "type": "written",
        "prompt": "Describe the purpose of a project charter and list three key components it should contain.",
        "correctAnswer": "A project charter formally authorizes a project and provides direction. Key components: 1) Project objectives and scope, 2) Stakeholders and their roles, 3) Timeline and major milestones.",
        "explanation": "A project charter establishes the foundation and authority for a project, aligning stakeholders on goals and expectations.",
        "modelAnswer": "A project charter is a formal document that authorizes the existence of a project and provides the project manager with authority to allocate resources. It serves as a reference point throughout the project lifecycle. Three key components: 1) Project Purpose and Objectives - clearly states what the project aims to achieve and the problem it solves, 2) Scope Definition - outlines what is included and excluded from the project, defining boundaries and deliverables, 3) Stakeholders and Roles - identifies who is involved, their responsibilities, and decision-making authority. Additional important components include success criteria, constraints, assumptions, and high-level timeline with major milestones."
      },
      {
        "id": "q6",
        "type": "multiple_choice",
        "prompt": "In Agile methodology, what is a sprint retrospective?",
        "options": [
          "A status update meeting with management",
          "A team reflection on what went well and what to improve",
          "A demo of completed work to stakeholders",
          "A meeting to plan the next sprint's features"
        ],
        "correctAnswer": 1,
        "explanation": "A sprint retrospective is a team meeting at the end of each sprint to reflect on processes, identify improvements, and plan adjustments for the next sprint."
      },
      {
        "id": "q7",
        "type": "multiple_choice",
        "prompt": "Which of the following is a key principle of RESTful API design?",
        "options": [
          "State should be stored on the server for each client",
          "Endpoints should contain verbs describing actions",
          "All responses should use HTTP 200 status code",
          "Resources should be represented as nouns in URLs"
        ],
        "correctAnswer": 3,
        "explanation": "RESTful APIs use resource-based URLs with nouns (e.g., /users, /activities), proper HTTP methods, and are stateless."
      },
      {
        "id": "q8",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of an API middleware in Express.js?",
        "options": [
          "To compile TypeScript code",
          "To render HTML templates",
          "To store data in the database",
          "To intercept and process requests before they reach route handlers"
        ],
        "correctAnswer": 3,
        "explanation": "Middleware functions intercept requests, performing tasks like authentication, logging, or data validation before passing control to route handlers."
      },
      {
        "id": "q9",
        "type": "fill_blank",
        "prompt": "The _____ principle states that software entities should be open for extension but closed for modification.",
        "correctAnswer": "Open/Closed",
        "explanation": "The Open/Closed Principle (OCP) is one of the SOLID principles, encouraging design that allows adding new functionality without changing existing code."
      },
      {
        "id": "q10",
        "type": "code_output",
        "prompt": "What will this code output?",
        "codeSnippet": "class EmissionCalculator {\n  private factor: number;\n\n  constructor(factor: number) {\n    this.factor = factor;\n  }\n\n  calculate(distance: number): number {\n    return distance * this.factor;\n  }\n}\n\nconst carCalculator = new EmissionCalculator(0.21);\nconsole.log(carCalculator.calculate(50));",
        "correctAnswer": "10.5",
        "explanation": "The calculator multiplies distance (50) by the factor (0.21): 50 * 0.21 = 10.5 kg CO2."
      },
      {
        "id": "q11",
        "type": "true_false",
        "prompt": "In a microservices architecture, each service should have its own database to maintain independence.",
        "correctAnswer": true,
        "explanation": "Microservices should be independently deployable and scalable, which includes having their own data stores. This prevents coupling between services."
      },
      {
        "id": "q12",
        "type": "written",
        "prompt": "Explain the difference between SQL and NoSQL databases. When would you choose one over the other for a capstone project?",
        "correctAnswer": "SQL databases are relational, structured with schemas, and use SQL queries. NoSQL databases are non-relational, flexible schema, and horizontally scalable. Choose SQL for complex relationships and ACID compliance. Choose NoSQL for flexible data models and high scalability needs.",
        "explanation": "Understanding database types helps select the right tool for your project's data model and scalability requirements.",
        "modelAnswer": "SQL databases (like PostgreSQL, MySQL) are relational databases that store data in structured tables with predefined schemas. They use SQL for querying, enforce ACID properties (Atomicity, Consistency, Isolation, Durability), and excel at complex joins and transactions. NoSQL databases (like MongoDB, DynamoDB) are non-relational, offering flexible schemas, horizontal scaling, and various data models (document, key-value, graph). Choose SQL when: you have complex relationships between entities (users, activities, categories), need strong consistency and transactions, or have a well-defined schema. For a carbon tracking app with user accounts, activities, and categories, SQL is ideal. Choose NoSQL when: you need extreme scalability, have rapidly changing data structures, or work with unstructured data like logs or real-time analytics."
      },
      {
        "id": "q13",
        "type": "multiple_choice",
        "prompt": "What is the purpose of using async/await in JavaScript/TypeScript?",
        "options": [
          "To handle asynchronous operations in a more readable way",
          "To make code run faster",
          "To create multiple threads",
          "To prevent all errors"
        ],
        "correctAnswer": 0,
        "explanation": "Async/await provides syntactic sugar over Promises, making asynchronous code look synchronous and more readable while avoiding callback hell."
      },
      {
        "id": "q14",
        "type": "multiple_choice",
        "prompt": "Which of the following is the correct way to handle errors in an Express.js API route?",
        "options": [
          "Ignore errors and return success anyway",
          "Log errors but don't respond to the client",
          "Let the application crash and restart",
          "Use try-catch blocks and send appropriate error responses"
        ],
        "correctAnswer": 3,
        "explanation": "Always use try-catch for async operations, catch errors, log them, and send appropriate HTTP error responses (4xx or 5xx) to the client."
      },
      {
        "id": "q15",
        "type": "code_output",
        "prompt": "What will be logged?",
        "codeSnippet": "const user = {\n  name: 'Alice',\n  activities: [\n    { type: 'car', distance: 20 },\n    { type: 'bike', distance: 5 }\n  ]\n};\n\nconst totalDistance = user.activities\n  .map(a => a.distance)\n  .reduce((sum, d) => sum + d, 0);\n\nconsole.log(totalDistance);",
        "correctAnswer": "25",
        "explanation": "The code maps activities to distances [20, 5], then reduces them by summing: 20 + 5 = 25."
      },
      {
        "id": "q16",
        "type": "fill_blank",
        "prompt": "A _____ is a reverse proxy that distributes network traffic across multiple servers to ensure no single server becomes overwhelmed.",
        "correctAnswer": "load balancer",
        "explanation": "A load balancer distributes incoming requests across multiple servers, improving performance, availability, and fault tolerance."
      },
      {
        "id": "q17",
        "type": "true_false",
        "prompt": "JSON Web Tokens (JWT) should be stored in localStorage for maximum security.",
        "correctAnswer": false,
        "explanation": "Storing JWTs in localStorage exposes them to XSS attacks. HttpOnly cookies are more secure as they're inaccessible to JavaScript."
      },
      {
        "id": "q18",
        "type": "written",
        "prompt": "Explain what CORS is and why it exists. How would you configure it in a capstone project?",
        "correctAnswer": "CORS (Cross-Origin Resource Sharing) is a security mechanism that restricts web pages from making requests to a different domain. It exists to prevent malicious sites from accessing your API. Configure it to allow requests from your frontend domain while blocking others.",
        "explanation": "CORS is a critical security feature that protects APIs from unauthorized cross-origin requests.",
        "modelAnswer": "CORS (Cross-Origin Resource Sharing) is a browser security feature that restricts web pages from making HTTP requests to a different domain than the one serving the page. It exists to prevent malicious websites from making unauthorized requests to your API using a user's credentials. Without CORS, a malicious site could make requests to your banking API while you're logged in. In a capstone project, configure CORS on your backend to: 1) Allow requests only from your frontend domain (e.g., https://myapp.vercel.app), 2) Specify allowed HTTP methods (GET, POST, PUT, DELETE), 3) Specify allowed headers (Content-Type, Authorization), 4) Enable credentials if using cookies. Example: app.use(cors({ origin: process.env.FRONTEND_URL, credentials: true })). For development, you might allow localhost, but in production, restrict to your deployed frontend domain."
      },
      {
        "id": "q19",
        "type": "multiple_choice",
        "prompt": "What is the primary benefit of using React hooks like useState and useEffect?",
        "options": [
          "They automatically handle all errors",
          "They make React components faster",
          "They eliminate the need for props",
          "They allow using state and lifecycle features in functional components"
        ],
        "correctAnswer": 3,
        "explanation": "Hooks enable functional components to use state, side effects, and other React features previously only available in class components."
      },
      {
        "id": "q20",
        "type": "multiple_choice",
        "prompt": "Which approach best handles form validation in a React application?",
        "options": [
          "Validation only on form submission",
          "No validation, trust user input",
          "Client-side validation only for UX, plus server-side validation for security",
          "Server-side validation only"
        ],
        "correctAnswer": 2,
        "explanation": "Always validate on both client (for UX) and server (for security). Client-side can be bypassed, so server-side validation is essential."
      },
      {
        "id": "q21",
        "type": "code_output",
        "prompt": "What will render on the page?",
        "codeSnippet": "const ActivityList = () => {\n  const activities = [\n    { id: 1, type: 'car', distance: 10 },\n    { id: 2, type: 'bus', distance: 5 }\n  ];\n\n  return (\n    <div>\n      {activities.filter(a => a.distance > 7).length}\n    </div>\n  );\n};",
        "correctAnswer": "1",
        "explanation": "The filter returns activities with distance > 7, which is only the car activity (distance 10). The length is 1."
      },
      {
        "id": "q22",
        "type": "fill_blank",
        "prompt": "In React, _____ allow you to pass data from parent components to child components.",
        "correctAnswer": "props",
        "explanation": "Props (properties) are React's mechanism for passing data and event handlers down the component tree from parent to child."
      },
      {
        "id": "q23",
        "type": "true_false",
        "prompt": "In React, directly mutating state (e.g., state.value = 5) is the correct way to update component state.",
        "correctAnswer": false,
        "explanation": "Never mutate state directly. Always use setState or the state setter from useState to trigger re-renders and maintain React's reactivity."
      },
      {
        "id": "q24",
        "type": "multiple_choice",
        "prompt": "What is the purpose of React Context API?",
        "options": [
          "To make API requests",
          "To replace all props",
          "To style components",
          "To share data across components without prop drilling"
        ],
        "correctAnswer": 3,
        "explanation": "Context API provides a way to share values (like authentication state, theme) across components without passing props through every level."
      },
      {
        "id": "q25",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of CI/CD in a capstone project?",
        "options": [
          "To increase project costs",
          "To make development more complicated",
          "To eliminate the need for manual testing",
          "To automate testing and deployment, catching issues early"
        ],
        "correctAnswer": 3,
        "explanation": "CI/CD automates builds, tests, and deployments, providing fast feedback and reducing manual errors."
      },
      {
        "id": "q26",
        "type": "multiple_choice",
        "prompt": "Which testing type should have the MOST tests in your capstone project?",
        "options": [
          "Unit tests",
          "End-to-end tests",
          "Integration tests",
          "Manual tests"
        ],
        "correctAnswer": 0,
        "explanation": "Following the testing pyramid, unit tests should be most numerous as they're fast, focused, and catch bugs early."
      },
      {
        "id": "q27",
        "type": "multiple_choice",
        "prompt": "What is the AAA pattern in unit testing?",
        "options": [
          "Authenticate, Authorize, Access",
          "Arrange, Act, Assert",
          "Add, Audit, Approve",
          "Accept, Analyze, Adapt"
        ],
        "correctAnswer": 1,
        "explanation": "AAA pattern organizes tests: Arrange (setup), Act (execute the code being tested), Assert (verify the outcome)."
      },
      {
        "id": "q28",
        "type": "fill_blank",
        "prompt": "A _____ test verifies that different parts of the application work together correctly, such as testing API endpoints with database interactions.",
        "correctAnswer": "integration",
        "explanation": "Integration tests verify that multiple components or modules work together correctly, testing interactions between units."
      },
      {
        "id": "q29",
        "type": "true_false",
        "prompt": "Code coverage of 100% guarantees that your application has no bugs.",
        "correctAnswer": false,
        "explanation": "100% code coverage only means all lines were executed during tests, not that all scenarios, edge cases, or logic paths were tested correctly."
      },
      {
        "id": "q30",
        "type": "written",
        "prompt": "Explain the difference between unit tests and end-to-end tests. Provide an example of each for a carbon tracking application.",
        "correctAnswer": "Unit tests verify individual functions in isolation. E2E tests verify entire user workflows. Example: Unit test - test emission calculation function. E2E test - test complete flow of user login, adding activity, and viewing dashboard.",
        "explanation": "Different test types serve different purposes and operate at different levels of abstraction.",
        "modelAnswer": "Unit tests verify individual functions or components in isolation, with dependencies mocked or stubbed. They are fast, focused, and test specific logic. End-to-end (E2E) tests verify complete user workflows through the entire application stack, from UI to database. They are slower but test real-world scenarios. For a carbon tracking app: Unit test example - Test the calculateEmissions(distance, type) function with various inputs to verify correct calculations (e.g., expect(calculateEmissions(100, \"car\")).toBe(21)). E2E test example - Automate a browser to: 1) Navigate to the app, 2) Log in as a user, 3) Click \"Add Activity\", 4) Fill form with activity details, 5) Submit, 6) Verify activity appears in the dashboard with correct emissions. Unit tests catch logic errors quickly, while E2E tests catch integration issues and UX problems."
      },
      {
        "id": "q31",
        "type": "multiple_choice",
        "prompt": "Which deployment platform is MOST suitable for a Next.js capstone project?",
        "options": [
          "Vercel with automatic deployments",
          "Physical server in your home",
          "AWS EC2 with manual configuration",
          "USB drive"
        ],
        "correctAnswer": 0,
        "explanation": "Vercel is built for Next.js (by the same team), offers free hosting, automatic deployments from Git, and excellent developer experience."
      },
      {
        "id": "q32",
        "type": "multiple_choice",
        "prompt": "What is the purpose of database migrations?",
        "options": [
          "To track and version database schema changes",
          "To backup database data",
          "To move data between databases",
          "To improve query performance"
        ],
        "correctAnswer": 0,
        "explanation": "Migrations version control your database schema, allowing you to track changes, rollback if needed, and keep dev/production in sync."
      },
      {
        "id": "q33",
        "type": "multiple_choice",
        "prompt": "You discover a critical bug in production that breaks user registration. What should you do FIRST?",
        "options": [
          "Wait until the next planned deployment",
          "Fix the bug directly in production",
          "Post about it on social media",
          "Rollback to the previous working version"
        ],
        "correctAnswer": 3,
        "explanation": "Always rollback first to restore functionality, then fix the bug in development and redeploy through proper channels."
      },
      {
        "id": "q34",
        "type": "fill_blank",
        "prompt": "A _____ is an isolated environment that contains all dependencies needed to run an application, ensuring consistency across different machines.",
        "correctAnswer": "container",
        "explanation": "Containers (like Docker containers) package applications with all dependencies, ensuring they run consistently regardless of the environment."
      },
      {
        "id": "q35",
        "type": "true_false",
        "prompt": "Environment variables should be different between development, staging, and production environments.",
        "correctAnswer": true,
        "explanation": "Each environment should have its own environment variables (database URLs, API keys, etc.) to prevent development changes from affecting production."
      },
      {
        "id": "q36",
        "type": "written",
        "prompt": "Describe what a CI/CD pipeline is and outline the typical stages it should include for a web application.",
        "correctAnswer": "A CI/CD pipeline automates building, testing, and deploying code. Typical stages: 1) Code commit triggers pipeline, 2) Build and compile, 3) Run tests (unit, integration), 4) Deploy to staging, 5) Run E2E tests, 6) Deploy to production.",
        "explanation": "CI/CD pipelines are essential for modern software development, enabling rapid and reliable releases.",
        "modelAnswer": "A CI/CD (Continuous Integration/Continuous Deployment) pipeline is an automated process that builds, tests, and deploys code changes. When developers commit code, the pipeline automatically executes a series of stages to ensure quality and deploy to production. Typical stages: 1) Source - Code is committed to Git, triggering the pipeline, 2) Build - Application is compiled/built (npm install, TypeScript compilation), 3) Test - Automated tests run (unit tests, integration tests, linting), 4) Staging Deployment - If tests pass, deploy to a staging environment that mirrors production, 5) E2E Testing - Run end-to-end tests against staging, 6) Production Deployment - If all tests pass, automatically (or manually) deploy to production, 7) Monitoring - Watch for errors and performance issues. Benefits include: catching bugs early, ensuring consistent deployments, reducing manual errors, and enabling frequent releases. Tools like GitHub Actions, GitLab CI, or CircleCI implement these pipelines."
      },
      {
        "id": "q37",
        "type": "multiple_choice",
        "prompt": "What is the primary purpose of API documentation?",
        "options": [
          "To help developers understand how to use the API",
          "To hide implementation details",
          "To satisfy academic requirements",
          "To make the project longer"
        ],
        "correctAnswer": 0,
        "explanation": "API documentation explains endpoints, parameters, responses, and examples, enabling developers (including your future self) to use the API effectively."
      },
      {
        "id": "q38",
        "type": "multiple_choice",
        "prompt": "Which of the following makes a README file most effective?",
        "options": [
          "Only a project title",
          "Clear sections: project description, setup instructions, usage examples, and technologies",
          "No information, just code",
          "Lengthy descriptions of every file"
        ],
        "correctAnswer": 1,
        "explanation": "Effective READMEs provide essential information in organized sections: what the project does, how to set it up, how to use it, and what it's built with."
      },
      {
        "id": "q39",
        "type": "multiple_choice",
        "prompt": "What makes a good Git commit message?",
        "options": [
          "\"feat(auth): implement JWT token authentication with refresh tokens\"",
          "\"fixed stuff\"",
          "\"WIP\"",
          "\"updated files\""
        ],
        "correctAnswer": 0,
        "explanation": "Good commit messages are specific, follow conventions (type/scope), and clearly describe what changed and why."
      },
      {
        "id": "q40",
        "type": "fill_blank",
        "prompt": "A _____ diagram shows the flow of data through a system, illustrating how information moves between processes, data stores, and external entities.",
        "correctAnswer": "data flow",
        "explanation": "Data flow diagrams (DFD) visualize how data moves through a system, showing processes, data stores, and external entities."
      },
      {
        "id": "q41",
        "type": "true_false",
        "prompt": "Code comments should explain what the code does, not why design decisions were made.",
        "correctAnswer": false,
        "explanation": "Good comments explain WHY (rationale, design decisions, trade-offs), not WHAT (which should be clear from readable code). Document non-obvious decisions."
      },
      {
        "id": "q42",
        "type": "written",
        "prompt": "Describe three key elements that should be included in a capstone project presentation to effectively communicate your work.",
        "correctAnswer": "Key elements: 1) Problem statement and motivation - why the project matters, 2) Architecture and technical approach - how you built it, 3) Demo and results - showing it works with metrics/outcomes.",
        "explanation": "Effective presentations balance context, technical details, and results to engage both technical and non-technical audiences.",
        "modelAnswer": "A capstone project presentation should include: 1) Problem Statement and Motivation - Clearly articulate what problem you're solving and why it matters. Provide context and explain the impact. For a carbon tracking app: \"Transportation accounts for 29% of emissions, but people lack awareness of their personal impact.\" 2) Technical Architecture and Approach - Explain your system design, technology choices, and key technical challenges you overcame. Use diagrams showing frontend, backend, and database architecture. Justify decisions: \"I chose PostgreSQL over MongoDB because the relational model better fits user-activity relationships.\" 3) Live Demo and Results - Show the application working through a typical user workflow. Present quantitative results: performance metrics, test coverage, user feedback, or feature completion. Include lessons learned and future improvements. Additional important elements: Timeline showing project phases, challenges faced and how you solved them, and code quality practices (testing, CI/CD) demonstrating professional development skills."
      },
      {
        "id": "q43",
        "type": "multiple_choice",
        "prompt": "Your application needs to send emails. What is the recommended approach for a capstone project?",
        "options": [
          "Skip email functionality entirely",
          "Build your own email server",
          "Send emails directly from the frontend",
          "Use an email service like SendGrid or Resend with proper error handling"
        ],
        "correctAnswer": 3,
        "explanation": "Use established email services (SendGrid, Resend) which handle deliverability, spam filtering, and provide free tiers for capstone projects."
      },
      {
        "id": "q44",
        "type": "multiple_choice",
        "prompt": "You need to display a list of 10,000 activities. What is the BEST approach?",
        "options": [
          "Implement pagination or infinite scroll",
          "Load all 10,000 activities at once",
          "Display only the first 100",
          "Store activities in browser localStorage"
        ],
        "correctAnswer": 0,
        "explanation": "Pagination or infinite scroll loads data incrementally, improving performance and user experience with large datasets."
      },
      {
        "id": "q45",
        "type": "code_output",
        "prompt": "What will be the final value of emissions?",
        "codeSnippet": "const activities = [\n  { type: 'car', distance: 20, factor: 0.21 },\n  { type: 'bus', distance: 10, factor: 0.089 },\n  { type: 'bike', distance: 5, factor: 0 }\n];\n\nconst emissions = activities\n  .map(a => a.distance * a.factor)\n  .reduce((total, e) => total + e, 0);\n\nconsole.log(emissions.toFixed(2));",
        "correctAnswer": "5.09",
        "explanation": "Calculate each: car=20*0.21=4.2, bus=10*0.089=0.89, bike=5*0=0. Sum: 4.2+0.89+0=5.09."
      }
    ]
  }
]

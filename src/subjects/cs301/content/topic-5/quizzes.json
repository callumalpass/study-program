[
  {
    "id": "cs301-q5-1",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Concepts",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "How many conditions are necessary for deadlock?",
        "options": [
          "3",
          "4",
          "1",
          "2"
        ],
        "correctAnswer": 1,
        "explanation": "Four conditions must hold: mutual exclusion, hold and wait, no preemption, and circular wait."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What is circular wait?",
        "options": [
          "CPU cycles infinitely",
          "Processes wait in a line",
          "Queue wraps around",
          "Each process waits for resource held by next in cycle"
        ],
        "correctAnswer": 3,
        "explanation": "Circular wait is when P0 waits for P1, P1 waits for P2, ..., Pn waits for P0."
      },
      {
        "id": "q3",
        "type": "true_false",
        "prompt": "Deadlock can occur with a single resource type if there are multiple instances.",
        "correctAnswer": false,
        "explanation": "With single resource type and multiple instances, deadlock requires cycle AND all instances held."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What does a Resource Allocation Graph represent?",
        "options": [
          "CPU usage",
          "Memory layout",
          "File system",
          "Process and resource relationships"
        ],
        "correctAnswer": 3,
        "explanation": "RAG shows processes, resources, request edges, and assignment edges to detect potential deadlock."
      },
      {
        "id": "q5",
        "type": "multiple_choice",
        "prompt": "In RAG with single instances, what indicates deadlock?",
        "options": [
          "Many nodes",
          "No edges",
          "Cycle",
          "Any edge"
        ],
        "correctAnswer": 2,
        "explanation": "With single instance resources, a cycle in the RAG indicates deadlock."
      }
    ]
  },
  {
    "id": "cs301-q5-2",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Handling",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "What does deadlock prevention do?",
        "options": [
          "Ignores deadlock",
          "Ensures at least one condition cannot hold",
          "Detects and recovers",
          "Uses more resources"
        ],
        "correctAnswer": 1,
        "explanation": "Prevention eliminates deadlock by ensuring at least one necessary condition cannot occur."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "How can hold-and-wait be prevented?",
        "options": [
          "Allow preemption",
          "Request all resources at once",
          "Use timeouts",
          "Add more resources"
        ],
        "correctAnswer": 1,
        "explanation": "Requiring processes to request all needed resources before execution prevents hold-and-wait."
      },
      {
        "id": "q3",
        "type": "multiple_choice",
        "prompt": "What is the Banker's Algorithm used for?",
        "options": [
          "Memory allocation",
          "Financial calculations",
          "CPU scheduling",
          "Deadlock avoidance"
        ],
        "correctAnswer": 3,
        "explanation": "Banker's Algorithm avoids deadlock by checking if granting a request leads to a safe state."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What is a safe state?",
        "options": [
          "Minimum memory usage",
          "No processes running",
          "Maximum security",
          "A sequence exists where all processes can finish"
        ],
        "correctAnswer": 3,
        "explanation": "A safe state means there exists a safe sequence where all processes can complete."
      },
      {
        "id": "q5",
        "type": "true_false",
        "prompt": "If a system is in an unsafe state, deadlock will definitely occur.",
        "correctAnswer": false,
        "explanation": "Unsafe state means deadlock might occur, not that it will definitely occur."
      }
    ]
  },
  {
    "id": "cs301-q5-3",
    "subjectId": "cs301",
    "topicId": "cs301-t5",
    "title": "Deadlock Detection and Recovery",
    "questions": [
      {
        "id": "q1",
        "type": "multiple_choice",
        "prompt": "How is deadlock detected with single instance resources?",
        "options": [
          "User report",
          "Memory analysis",
          "Cycle detection in wait-for graph",
          "Timer expiry"
        ],
        "correctAnswer": 2,
        "explanation": "With single instances, a cycle in the wait-for graph indicates deadlock."
      },
      {
        "id": "q2",
        "type": "multiple_choice",
        "prompt": "What is deadlock recovery by termination?",
        "options": [
          "Add resources",
          "Ignore the problem",
          "Kill deadlocked processes",
          "Preempt memory"
        ],
        "correctAnswer": 2,
        "explanation": "One recovery method is to terminate some or all deadlocked processes."
      },
      {
        "id": "q3",
        "type": "multiple_choice",
        "prompt": "What is resource preemption in deadlock recovery?",
        "options": [
          "Adding resources",
          "Deleting resources",
          "Sharing resources",
          "Taking resources from processes to break deadlock"
        ],
        "correctAnswer": 3,
        "explanation": "Resource preemption takes resources from some processes to give to others, breaking deadlock."
      },
      {
        "id": "q4",
        "type": "multiple_choice",
        "prompt": "What is the ostrich algorithm?",
        "options": [
          "Parallel deadlock handling",
          "Running from deadlock",
          "Complex deadlock solution",
          "Ignoring deadlock"
        ],
        "correctAnswer": 3,
        "explanation": "The ostrich algorithm ignores deadlock, assuming it's rare enough to not warrant overhead."
      },
      {
        "id": "q5",
        "type": "true_false",
        "prompt": "Most general-purpose operating systems use deadlock prevention.",
        "correctAnswer": false,
        "explanation": "Most general-purpose OSes use the ostrich algorithm, ignoring deadlock due to overhead concerns."
      }
    ]
  }
]

[
  {
    "id": "cs301-ex-4-1",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Race Condition Check",
    "description": "Given operations from two threads, detect if a race condition could occur.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "def has_race_condition(thread1_ops, thread2_ops, shared_vars):\n    # ops are lists of (\"read\", var) or (\"write\", var)\n    # Return True if race condition possible\n    pass",
    "solution": "def has_race_condition(thread1_ops, thread2_ops, shared_vars):\n    t1_writes = {var for op, var in thread1_ops if op == \"write\" and var in shared_vars}\n    t2_writes = {var for op, var in thread2_ops if op == \"write\" and var in shared_vars}\n    t1_reads = {var for op, var in thread1_ops if op == \"read\" and var in shared_vars}\n    t2_reads = {var for op, var in thread2_ops if op == \"read\" and var in shared_vars}\n\n    # Race: write-write or read-write on same variable\n    if t1_writes & t2_writes:\n        return True\n    if t1_writes & t2_reads or t2_writes & t1_reads:\n        return True\n    return False",
    "testCases": [
      {
        "input": "[(\"read\", \"x\"), (\"write\", \"x\")], [(\"write\", \"x\")], {\"x\"}",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Write-write race"
      },
      {
        "input": "[(\"read\", \"x\")], [(\"read\", \"x\")], {\"x\"}",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Read-read no race"
      }
    ],
    "hints": [
      "Race requires at least one write",
      "Check write-write and read-write conflicts"
    ]
  },
  {
    "id": "cs301-ex-4-2",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Critical Section Validator",
    "description": "Check if a solution satisfies mutual exclusion given execution traces.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def validates_mutual_exclusion(traces):\n    # traces: list of (time, thread_id, \"enter\"|\"exit\")\n    # Return True if at most one thread in CS at any time\n    pass",
    "solution": "def validates_mutual_exclusion(traces):\n    sorted_traces = sorted(traces, key=lambda x: x[0])\n    in_cs = set()\n    for time, tid, action in sorted_traces:\n        if action == \"enter\":\n            if in_cs:  # Someone already in CS\n                return False\n            in_cs.add(tid)\n        else:  # exit\n            in_cs.discard(tid)\n    return True",
    "testCases": [
      {
        "input": "[(0, 1, \"enter\"), (5, 1, \"exit\"), (6, 2, \"enter\")]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Sequential access"
      },
      {
        "input": "[(0, 1, \"enter\"), (2, 2, \"enter\"), (5, 1, \"exit\")]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Overlap violation"
      }
    ],
    "hints": [
      "Sort by time",
      "Track who is in CS"
    ]
  },
  {
    "id": "cs301-ex-4-3",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Simple Mutex",
    "description": "Implement a mutex with lock and unlock operations.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class Mutex:\n    def __init__(self):\n        pass\n    \n    def lock(self, thread_id):\n        # Return True if acquired, False if already held\n        pass\n    \n    def unlock(self, thread_id):\n        # Return True if released, False if not owner\n        pass\n    \n    def is_locked(self):\n        pass",
    "solution": "class Mutex:\n    def __init__(self):\n        self.owner = None\n\n    def lock(self, thread_id):\n        if self.owner is None:\n            self.owner = thread_id\n            return True\n        return False\n\n    def unlock(self, thread_id):\n        if self.owner == thread_id:\n            self.owner = None\n            return True\n        return False\n\n    def is_locked(self):\n        return self.owner is not None",
    "testCases": [
      {
        "input": "m = Mutex(); m.lock(1)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Acquire free lock"
      },
      {
        "input": "m = Mutex(); m.lock(1); m.lock(2)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Already held"
      },
      {
        "input": "m = Mutex(); m.lock(1); m.unlock(2)",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "Wrong owner"
      }
    ],
    "hints": [
      "Track the owner",
      "Only owner can unlock"
    ]
  },
  {
    "id": "cs301-ex-4-4",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Counting Semaphore",
    "description": "Implement a counting semaphore with wait and signal operations.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class Semaphore:\n    def __init__(self, initial):\n        pass\n    \n    def wait(self):\n        # Return True if acquired, False if would block\n        pass\n    \n    def signal(self):\n        pass\n    \n    def get_value(self):\n        pass",
    "solution": "class Semaphore:\n    def __init__(self, initial):\n        self.value = initial\n\n    def wait(self):\n        if self.value > 0:\n            self.value -= 1\n            return True\n        return False\n\n    def signal(self):\n        self.value += 1\n\n    def get_value(self):\n        return self.value",
    "testCases": [
      {
        "input": "s = Semaphore(2); s.wait(); s.wait(); s.wait()",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Semaphore exhausted"
      },
      {
        "input": "s = Semaphore(0); s.signal(); s.wait()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Signal then wait"
      }
    ],
    "hints": [
      "Wait decrements if positive",
      "Signal always increments"
    ]
  },
  {
    "id": "cs301-ex-4-5",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Bounded Buffer",
    "description": "Implement a bounded buffer for producer-consumer with size tracking.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class BoundedBuffer:\n    def __init__(self, capacity):\n        pass\n    \n    def produce(self, item):\n        # Return True if added, False if full\n        pass\n    \n    def consume(self):\n        # Return item or None if empty\n        pass\n    \n    def is_empty(self):\n        pass\n    \n    def is_full(self):\n        pass",
    "solution": "class BoundedBuffer:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.buffer = []\n\n    def produce(self, item):\n        if len(self.buffer) < self.capacity:\n            self.buffer.append(item)\n            return True\n        return False\n\n    def consume(self):\n        if self.buffer:\n            return self.buffer.pop(0)\n        return None\n\n    def is_empty(self):\n        return len(self.buffer) == 0\n\n    def is_full(self):\n        return len(self.buffer) >= self.capacity",
    "testCases": [
      {
        "input": "bb = BoundedBuffer(2); bb.produce(1); bb.produce(2); bb.produce(3)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Buffer full"
      },
      {
        "input": "bb = BoundedBuffer(2); bb.produce(1); bb.consume()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Produce and consume"
      }
    ],
    "hints": [
      "Check capacity before producing",
      "FIFO order"
    ]
  },
  {
    "id": "cs301-ex-4-6",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Readers-Writers Counter",
    "description": "Track readers and writers for readers-writers problem.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class ReadersWriters:\n    def __init__(self):\n        pass\n    \n    def start_read(self):\n        # Return True if can start reading\n        pass\n    \n    def end_read(self):\n        pass\n    \n    def start_write(self):\n        # Return True if can start writing\n        pass\n    \n    def end_write(self):\n        pass",
    "solution": "class ReadersWriters:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n\n    def start_read(self):\n        if not self.writer:\n            self.readers += 1\n            return True\n        return False\n\n    def end_read(self):\n        if self.readers > 0:\n            self.readers -= 1\n\n    def start_write(self):\n        if self.readers == 0 and not self.writer:\n            self.writer = True\n            return True\n        return False\n\n    def end_write(self):\n        self.writer = False",
    "testCases": [
      {
        "input": "rw = ReadersWriters(); rw.start_read(); rw.start_read()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Multiple readers OK"
      },
      {
        "input": "rw = ReadersWriters(); rw.start_read(); rw.start_write()",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "No write while reading"
      },
      {
        "input": "rw = ReadersWriters(); rw.start_write(); rw.start_read()",
        "expectedOutput": "False",
        "isHidden": true,
        "description": "No read while writing"
      }
    ],
    "hints": [
      "Multiple readers allowed",
      "Writer needs exclusive access"
    ]
  },
  {
    "id": "cs301-ex-4-7",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Dining Philosophers State",
    "description": "Track fork states for dining philosophers problem.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class DiningTable:\n    def __init__(self, n):\n        # n philosophers, n forks\n        pass\n    \n    def pickup_forks(self, philosopher_id):\n        # Try to pick up both forks, return True if successful\n        pass\n    \n    def putdown_forks(self, philosopher_id):\n        pass\n    \n    def can_eat(self, philosopher_id):\n        pass",
    "solution": "class DiningTable:\n    def __init__(self, n):\n        self.n = n\n        self.forks = [None] * n  # None = free, else holder id\n\n    def pickup_forks(self, philosopher_id):\n        left = philosopher_id\n        right = (philosopher_id + 1) % self.n\n        if self.forks[left] is None and self.forks[right] is None:\n            self.forks[left] = philosopher_id\n            self.forks[right] = philosopher_id\n            return True\n        return False\n\n    def putdown_forks(self, philosopher_id):\n        left = philosopher_id\n        right = (philosopher_id + 1) % self.n\n        if self.forks[left] == philosopher_id:\n            self.forks[left] = None\n        if self.forks[right] == philosopher_id:\n            self.forks[right] = None\n\n    def can_eat(self, philosopher_id):\n        left = philosopher_id\n        right = (philosopher_id + 1) % self.n\n        return self.forks[left] == philosopher_id and self.forks[right] == philosopher_id",
    "testCases": [
      {
        "input": "dt = DiningTable(5); dt.pickup_forks(0)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Pick up free forks"
      },
      {
        "input": "dt = DiningTable(5); dt.pickup_forks(0); dt.pickup_forks(1)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Neighbor conflict"
      }
    ],
    "hints": [
      "Each philosopher needs two adjacent forks",
      "Both forks must be free"
    ]
  },
  {
    "id": "cs301-ex-4-8",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Condition Variable Queue",
    "description": "Implement a simple condition variable wait queue.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class ConditionVariable:\n    def __init__(self):\n        pass\n    \n    def wait(self, thread_id):\n        # Add thread to wait queue\n        pass\n    \n    def signal(self):\n        # Wake one thread, return its id or None\n        pass\n    \n    def broadcast(self):\n        # Wake all threads, return list of ids\n        pass",
    "solution": "class ConditionVariable:\n    def __init__(self):\n        self.wait_queue = []\n\n    def wait(self, thread_id):\n        self.wait_queue.append(thread_id)\n\n    def signal(self):\n        if self.wait_queue:\n            return self.wait_queue.pop(0)\n        return None\n\n    def broadcast(self):\n        all_waiting = self.wait_queue[:]\n        self.wait_queue.clear()\n        return all_waiting",
    "testCases": [
      {
        "input": "cv = ConditionVariable(); cv.wait(1); cv.wait(2); cv.signal()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "FIFO wakeup"
      },
      {
        "input": "cv = ConditionVariable(); cv.wait(1); cv.wait(2); cv.broadcast()",
        "expectedOutput": "[1, 2]",
        "isHidden": false,
        "description": "Wake all"
      }
    ],
    "hints": [
      "Wait adds to queue",
      "Signal wakes first, broadcast wakes all"
    ]
  },
  {
    "id": "cs301-ex-4-9",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Lock Ordering Check",
    "description": "Check if locks are acquired in consistent order (for deadlock prevention).",
    "difficulty": 3,
    "language": "python",
    "starterCode": "def consistent_lock_order(sequences):\n    # sequences: list of lock acquisition sequences per thread\n    # Each sequence is list of lock ids\n    # Return True if all follow consistent ordering\n    pass",
    "solution": "def consistent_lock_order(sequences):\n    # Build a partial order from each sequence\n    order_constraints = set()\n    for seq in sequences:\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                order_constraints.add((seq[i], seq[j]))\n\n    # Check for conflicts (a < b and b < a)\n    for a, b in order_constraints:\n        if (b, a) in order_constraints:\n            return False\n    return True",
    "testCases": [
      {
        "input": "[[1, 2, 3], [1, 2]]",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Consistent order"
      },
      {
        "input": "[[1, 2], [2, 1]]",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Conflicting order"
      }
    ],
    "hints": [
      "Build ordering constraints",
      "Check for cycles in order"
    ]
  },
  {
    "id": "cs301-ex-4-10",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Spinlock with Retry Count",
    "description": "Implement a spinlock that tracks spin attempts.",
    "difficulty": 2,
    "language": "python",
    "starterCode": "class Spinlock:\n    def __init__(self):\n        pass\n    \n    def try_lock(self, thread_id):\n        # Return True if acquired, False otherwise\n        pass\n    \n    def unlock(self, thread_id):\n        pass\n    \n    def get_contention_count(self):\n        # Return number of failed lock attempts\n        pass",
    "solution": "class Spinlock:\n    def __init__(self):\n        self.owner = None\n        self.contention_count = 0\n\n    def try_lock(self, thread_id):\n        if self.owner is None:\n            self.owner = thread_id\n            return True\n        self.contention_count += 1\n        return False\n\n    def unlock(self, thread_id):\n        if self.owner == thread_id:\n            self.owner = None\n\n    def get_contention_count(self):\n        return self.contention_count",
    "testCases": [
      {
        "input": "sl = Spinlock(); sl.try_lock(1); sl.try_lock(2); sl.get_contention_count()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "One contention"
      },
      {
        "input": "sl = Spinlock(); sl.try_lock(1)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Acquire free lock"
      }
    ],
    "hints": [
      "Track failed attempts",
      "Only count failures"
    ]
  },
  {
    "id": "cs301-ex-4-11",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Simple Monitor",
    "description": "Implement a monitor with entry and exit tracking.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class Monitor:\n    def __init__(self):\n        pass\n    \n    def enter(self, thread_id):\n        # Return True if entered, False if already occupied\n        pass\n    \n    def exit(self, thread_id):\n        # Return True if exited, False if not inside\n        pass\n    \n    def get_occupant(self):\n        pass",
    "solution": "class Monitor:\n    def __init__(self):\n        self.occupant = None\n\n    def enter(self, thread_id):\n        if self.occupant is None:\n            self.occupant = thread_id\n            return True\n        return False\n\n    def exit(self, thread_id):\n        if self.occupant == thread_id:\n            self.occupant = None\n            return True\n        return False\n\n    def get_occupant(self):\n        return self.occupant",
    "testCases": [
      {
        "input": "m = Monitor(); m.enter(1); m.enter(2)",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Only one inside"
      },
      {
        "input": "m = Monitor(); m.enter(1); m.exit(1); m.enter(2)",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "Exit then enter"
      }
    ],
    "hints": [
      "One thread at a time",
      "Track current occupant"
    ]
  },
  {
    "id": "cs301-ex-4-12",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Test-and-Set Lock",
    "description": "Implement a lock using test-and-set semantics.",
    "difficulty": 3,
    "language": "python",
    "starterCode": "class TASLock:\n    def __init__(self):\n        pass\n    \n    def test_and_set(self):\n        # Return old value and set to True\n        pass\n    \n    def acquire(self):\n        # Return True if acquired\n        pass\n    \n    def release(self):\n        pass",
    "solution": "class TASLock:\n    def __init__(self):\n        self.locked = False\n\n    def test_and_set(self):\n        old = self.locked\n        self.locked = True\n        return old\n\n    def acquire(self):\n        old = self.test_and_set()\n        return not old  # Acquired if old was False\n\n    def release(self):\n        self.locked = False",
    "testCases": [
      {
        "input": "tas = TASLock(); tas.acquire()",
        "expectedOutput": "True",
        "isHidden": false,
        "description": "First acquire"
      },
      {
        "input": "tas = TASLock(); tas.acquire(); tas.acquire()",
        "expectedOutput": "False",
        "isHidden": false,
        "description": "Already held"
      }
    ],
    "hints": [
      "TAS returns old value and sets to true",
      "Acquired if old was false"
    ]
  },
  {
    "id": "cs301-ex-4-13",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Compare-and-Swap",
    "description": "Implement CAS operation and use it for atomic increment.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class AtomicInteger:\n    def __init__(self, initial):\n        pass\n    \n    def compare_and_swap(self, expected, new_value):\n        # Return True if swapped, False otherwise\n        pass\n    \n    def get(self):\n        pass\n    \n    def atomic_increment(self):\n        # Increment using CAS, return new value\n        pass",
    "solution": "class AtomicInteger:\n    def __init__(self, initial):\n        self.value = initial\n\n    def compare_and_swap(self, expected, new_value):\n        if self.value == expected:\n            self.value = new_value\n            return True\n        return False\n\n    def get(self):\n        return self.value\n\n    def atomic_increment(self):\n        while True:\n            old = self.value\n            if self.compare_and_swap(old, old + 1):\n                return old + 1",
    "testCases": [
      {
        "input": "ai = AtomicInteger(5); ai.compare_and_swap(5, 10); ai.get()",
        "expectedOutput": "10",
        "isHidden": false,
        "description": "CAS success"
      },
      {
        "input": "ai = AtomicInteger(5); ai.compare_and_swap(3, 10); ai.get()",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "CAS fail"
      }
    ],
    "hints": [
      "CAS only swaps if current == expected",
      "Retry loop for increment"
    ]
  },
  {
    "id": "cs301-ex-4-14",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Reusable Barrier",
    "description": "Implement a reusable barrier that resets after all threads pass.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class ReusableBarrier:\n    def __init__(self, n):\n        pass\n    \n    def arrive(self, thread_id):\n        # Return barrier round number when released\n        pass\n    \n    def get_round(self):\n        pass",
    "solution": "class ReusableBarrier:\n    def __init__(self, n):\n        self.n = n\n        self.count = 0\n        self.round = 0\n\n    def arrive(self, thread_id):\n        self.count += 1\n        if self.count >= self.n:\n            self.round += 1\n            self.count = 0\n            return self.round\n        # In real impl, would wait here\n        return self.round\n\n    def get_round(self):\n        return self.round",
    "testCases": [
      {
        "input": "rb = ReusableBarrier(2); rb.arrive(1); rb.arrive(2)",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "First round complete"
      },
      {
        "input": "rb = ReusableBarrier(2); rb.arrive(1); rb.arrive(2); rb.arrive(1); rb.arrive(2)",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "Second round"
      }
    ],
    "hints": [
      "Reset count when all arrive",
      "Increment round number"
    ]
  },
  {
    "id": "cs301-ex-4-15",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Lock-Free Stack Simulation",
    "description": "Simulate a lock-free stack using CAS operations.",
    "difficulty": 5,
    "language": "python",
    "starterCode": "class LockFreeStack:\n    def __init__(self):\n        pass\n    \n    def push(self, value):\n        pass\n    \n    def pop(self):\n        # Return value or None if empty\n        pass\n    \n    def peek(self):\n        pass",
    "solution": "class LockFreeStack:\n    def __init__(self):\n        self.head = None  # (value, next)\n\n    def push(self, value):\n        while True:\n            old_head = self.head\n            new_node = (value, old_head)\n            # CAS simulation\n            if self.head == old_head:\n                self.head = new_node\n                return\n\n    def pop(self):\n        while True:\n            old_head = self.head\n            if old_head is None:\n                return None\n            # CAS simulation\n            if self.head == old_head:\n                self.head = old_head[1]\n                return old_head[0]\n\n    def peek(self):\n        if self.head:\n            return self.head[0]\n        return None",
    "testCases": [
      {
        "input": "lfs = LockFreeStack(); lfs.push(1); lfs.push(2); lfs.pop()",
        "expectedOutput": "2",
        "isHidden": false,
        "description": "LIFO order"
      },
      {
        "input": "lfs = LockFreeStack(); lfs.pop()",
        "expectedOutput": "None",
        "isHidden": false,
        "description": "Empty pop"
      }
    ],
    "hints": [
      "Head points to top node",
      "CAS on head pointer"
    ]
  },
  {
    "id": "cs301-ex-4-16",
    "subjectId": "cs301",
    "topicId": "cs301-t4",
    "title": "Priority Inheritance",
    "description": "Implement priority inheritance protocol for mutex.",
    "difficulty": 4,
    "language": "python",
    "starterCode": "class PriorityMutex:\n    def __init__(self):\n        pass\n    \n    def lock(self, thread_id, priority):\n        # Return effective priority of holder (for inheritance)\n        pass\n    \n    def unlock(self, thread_id):\n        pass\n    \n    def get_holder_priority(self):\n        pass",
    "solution": "class PriorityMutex:\n    def __init__(self):\n        self.holder = None\n        self.holder_base_priority = None\n        self.holder_effective_priority = None\n        self.waiting = []  # (tid, priority)\n\n    def lock(self, thread_id, priority):\n        if self.holder is None:\n            self.holder = thread_id\n            self.holder_base_priority = priority\n            self.holder_effective_priority = priority\n            return priority\n        # Priority inheritance\n        self.waiting.append((thread_id, priority))\n        if priority < self.holder_effective_priority:\n            self.holder_effective_priority = priority\n        return self.holder_effective_priority\n\n    def unlock(self, thread_id):\n        if self.holder == thread_id:\n            self.holder = None\n            self.holder_base_priority = None\n            self.holder_effective_priority = None\n            self.waiting.clear()\n\n    def get_holder_priority(self):\n        return self.holder_effective_priority",
    "testCases": [
      {
        "input": "pm = PriorityMutex(); pm.lock(1, 10); pm.lock(2, 1); pm.get_holder_priority()",
        "expectedOutput": "1",
        "isHidden": false,
        "description": "Priority boosted"
      },
      {
        "input": "pm = PriorityMutex(); pm.lock(1, 5); pm.get_holder_priority()",
        "expectedOutput": "5",
        "isHidden": false,
        "description": "No boost needed"
      }
    ],
    "hints": [
      "Lower number = higher priority",
      "Boost holder to max waiter priority"
    ]
  }
]

[
  {
    "id": "cs301-project-1",
    "subjectId": "cs301",
    "title": "Process Scheduler Simulator",
    "description": "Design and implement a process scheduler simulator that demonstrates various CPU scheduling algorithms.\n\nYour simulator should:\n- Create and manage a queue of simulated processes with arrival times, burst times, and priorities\n- Implement multiple scheduling algorithms: FCFS, SJF, Round Robin, and Priority Scheduling\n- Calculate and compare performance metrics: average waiting time, turnaround time, and CPU utilization\n- Provide visualization of the scheduling timeline (Gantt chart representation)\n\nThis project integrates concepts from process management, CPU scheduling, and performance analysis to give you hands-on experience with how operating systems make scheduling decisions.",
    "requirements": [
      "Implement at least 4 scheduling algorithms (FCFS, SJF, Round Robin, Priority)",
      "Support both preemptive and non-preemptive modes where applicable",
      "Calculate average waiting time, turnaround time, and response time",
      "Generate a text-based or graphical Gantt chart showing process execution",
      "Allow users to input custom process sets or generate random workloads",
      "Compare algorithm performance with the same process set"
    ],
    "rubric": [
      {
        "name": "Algorithm Implementation",
        "weight": 30,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "All 4+ algorithms implemented correctly with preemptive/non-preemptive variants"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "All algorithms work correctly in basic scenarios"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Most algorithms implemented with minor bugs"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Fewer than 3 algorithms or significant bugs"
          }
        ]
      },
      {
        "name": "Metrics Calculation",
        "weight": 25,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "All metrics calculated correctly; handles edge cases"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Metrics generally correct with minor issues"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Basic metrics work but some calculations incorrect"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Metrics frequently incorrect or missing"
          }
        ]
      },
      {
        "name": "Visualization",
        "weight": 20,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Clear, informative Gantt chart with timing details"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Working visualization that shows process order"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Basic output showing schedule"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "No visualization or output unclear"
          }
        ]
      },
      {
        "name": "Code Quality & Documentation",
        "weight": 25,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Well-organized code; clear documentation; good modularity"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Readable code with some documentation"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Code works but organization could improve"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Difficult to read or understand"
          }
        ]
      }
    ],
    "estimatedHours": 12,
    "scaffolding": {
      "overview": "Build a simulator that helps you understand how OS schedulers make decisions about which process to run next.",
      "gettingStarted": [
        "Define a Process class/struct with PID, arrival time, burst time, priority, and state tracking",
        "Create a Scheduler base class with common interface for all algorithms",
        "Implement FCFS first as the simplest algorithm to validate your framework",
        "Add metrics tracking from the start so you can verify correctness"
      ],
      "milestones": [
        "Milestone 1: Process and queue data structures with FCFS implementation",
        "Milestone 2: Add SJF (both preemptive and non-preemptive)",
        "Milestone 3: Implement Round Robin with configurable time quantum",
        "Milestone 4: Add Priority scheduling and Gantt chart visualization"
      ],
      "tips": [
        "Use a simulation clock that advances event-by-event rather than real time",
        "For preemptive algorithms, check for new arrivals at each time unit",
        "Test with known examples from textbooks to verify your metrics",
        "Consider using a priority queue for SJF and Priority scheduling"
      ]
    }
  },
  {
    "id": "cs301-project-2",
    "subjectId": "cs301",
    "title": "Virtual Memory Manager Simulator",
    "description": "Implement a virtual memory management simulator that demonstrates page replacement algorithms and memory allocation strategies.\n\nYour simulator should:\n- Simulate a virtual memory system with configurable page size and frame count\n- Implement multiple page replacement algorithms: FIFO, LRU, Optimal, and Clock\n- Track page faults, hit rates, and working set behavior\n- Support different memory reference patterns (random, sequential, locality-based)\n- Visualize page table state and replacement decisions over time\n\nThis project provides deep insight into how operating systems manage the illusion of unlimited memory through virtual memory and demand paging.",
    "requirements": [
      "Implement at least 4 page replacement algorithms (FIFO, LRU, Optimal, Clock)",
      "Support configurable number of frames and pages",
      "Generate memory reference strings with different access patterns",
      "Calculate page fault rates and hit ratios for each algorithm",
      "Show page table state transitions as references are processed",
      "Compare algorithm performance on the same reference string"
    ],
    "rubric": [
      {
        "name": "Algorithm Implementation",
        "weight": 35,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "All algorithms implemented correctly including Clock/Second-Chance"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "FIFO, LRU, and Optimal work correctly"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Most algorithms work with minor issues"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Algorithms produce incorrect results"
          }
        ]
      },
      {
        "name": "Reference String Generation",
        "weight": 20,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Multiple patterns including locality simulation"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Random and sequential patterns supported"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Can generate basic reference strings"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Limited or no reference generation"
          }
        ]
      },
      {
        "name": "Statistics & Analysis",
        "weight": 25,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Comprehensive stats with comparison charts/tables"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Page faults and hit rates calculated correctly"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Basic statistics provided"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Statistics missing or incorrect"
          }
        ]
      },
      {
        "name": "Visualization & Output",
        "weight": 20,
        "levels": [
          {
            "score": 4,
            "label": "Excellent",
            "description": "Step-by-step visualization of frame state changes"
          },
          {
            "score": 3,
            "label": "Good",
            "description": "Clear output showing replacement decisions"
          },
          {
            "score": 2,
            "label": "Satisfactory",
            "description": "Basic output of final results"
          },
          {
            "score": 1,
            "label": "Needs Improvement",
            "description": "Output unclear or missing"
          }
        ]
      }
    ],
    "estimatedHours": 10,
    "scaffolding": {
      "overview": "Simulate how an OS decides which pages to keep in limited physical memory when demand exceeds capacity.",
      "gettingStarted": [
        "Define Page and Frame classes to track page numbers and metadata",
        "Create a Memory class that maintains the frame table and handles references",
        "Start with FIFO as it is the simplest to implement correctly",
        "Use a reference string as input (array of page numbers being accessed)"
      ],
      "milestones": [
        "Milestone 1: Basic framework with FIFO page replacement",
        "Milestone 2: Implement LRU (consider using timestamps or stack)",
        "Milestone 3: Add Optimal algorithm (requires lookahead in reference string)",
        "Milestone 4: Implement Clock algorithm and add comparison features"
      ],
      "tips": [
        "For LRU, maintain access timestamps or use a stack-based approach",
        "Optimal algorithm needs to look ahead in the reference string",
        "Clock algorithm uses a circular list with reference bits",
        "Test with small examples you can verify by hand first"
      ]
    }
  }
]
[
  {
    "id": "cs205-ex-6-1",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Create Basic Index",
    "description": "Create an index on the Email column of the Users table to speed up email lookups.",
    "difficulty": 1,
    "language": "sql",
    "starterCode": "-- Create index on Email\n",
    "solution": "CREATE INDEX idx_users_email\nON Users (Email);",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Index created on Email",
        "isHidden": false,
        "description": "Basic index"
      }
    ],
    "hints": [
      "Use CREATE INDEX syntax.",
      "Name should indicate table and column."
    ]
  },
  {
    "id": "cs205-ex-6-2",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Unique Index",
    "description": "Create a unique index on the ProductSKU column of the Products table.",
    "difficulty": 1,
    "language": "sql",
    "starterCode": "-- Create unique index\n",
    "solution": "CREATE UNIQUE INDEX idx_products_sku\nON Products (ProductSKU);",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Unique index created",
        "isHidden": false,
        "description": "Unique index"
      }
    ],
    "hints": [
      "UNIQUE prevents duplicate values.",
      "Unique indexes enforce uniqueness constraint."
    ]
  },
  {
    "id": "cs205-ex-6-3",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Composite Index",
    "description": "Create a composite index on (CustomerID, OrderDate) for the Orders table to optimize queries that filter by customer and date.",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Create composite index\n",
    "solution": "CREATE INDEX idx_orders_customer_date\nON Orders (CustomerID, OrderDate);",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Composite index created",
        "isHidden": false,
        "description": "Multi-column index"
      }
    ],
    "hints": [
      "List columns in parentheses.",
      "Column order matters for query patterns."
    ]
  },
  {
    "id": "cs205-ex-6-4",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Covering Index",
    "description": "Create an index that covers queries selecting Name and Email filtered by Status.",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Covering index for status lookups\n",
    "solution": "CREATE INDEX idx_users_status_covering\nON Users (Status)\nINCLUDE (Name, Email);",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Covering index with INCLUDE",
        "isHidden": false,
        "description": "Covering index"
      }
    ],
    "hints": [
      "INCLUDE adds non-key columns.",
      "Covering indexes avoid table lookups."
    ]
  },
  {
    "id": "cs205-ex-6-5",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Partial Index",
    "description": "Create a partial index on Orders for only active orders (Status = 'Active').",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Partial index for active orders\n",
    "solution": "CREATE INDEX idx_orders_active\nON Orders (OrderDate, CustomerID)\nWHERE Status = 'Active';",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Partial index created",
        "isHidden": false,
        "description": "Filtered index"
      }
    ],
    "hints": [
      "WHERE clause filters indexed rows.",
      "Smaller index = faster maintenance."
    ]
  },
  {
    "id": "cs205-ex-6-6",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Drop Index",
    "description": "Write the SQL to drop an index named idx_old_index from the database.",
    "difficulty": 1,
    "language": "sql",
    "starterCode": "-- Drop the index\n",
    "solution": "DROP INDEX idx_old_index;",
    "testCases": [
      {
        "input": "drop",
        "expectedOutput": "Index dropped",
        "isHidden": false,
        "description": "Drop index"
      }
    ],
    "hints": [
      "DROP INDEX removes the index.",
      "Some databases need table name: DROP INDEX idx ON table."
    ]
  },
  {
    "id": "cs205-ex-6-7",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Function-Based Index",
    "description": "Create an index on the lowercase version of Email for case-insensitive searches.",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Index on LOWER(Email)\n",
    "solution": "CREATE INDEX idx_users_email_lower\nON Users (LOWER(Email));",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Expression index created",
        "isHidden": false,
        "description": "Function-based index"
      }
    ],
    "hints": [
      "Expression indexes store computed values.",
      "Query must use same expression to use index."
    ]
  },
  {
    "id": "cs205-ex-6-8",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "B-Tree Node Calculation",
    "description": "Given a B-tree with order m=100 (max 100 children per node), what is the maximum number of keys per node? Write as a SQL comment.",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- B-tree calculation:\n-- ",
    "solution": "-- Maximum keys per node = m - 1 = 100 - 1 = 99 keys\n-- A node with m children has m-1 keys (separators between children)\n-- So with order 100, each node can hold up to 99 keys",
    "testCases": [
      {
        "input": "calculation",
        "expectedOutput": "99 keys",
        "isHidden": false,
        "description": "B-tree order"
      }
    ],
    "hints": [
      "Keys = pointers - 1.",
      "Keys separate child pointers."
    ]
  },
  {
    "id": "cs205-ex-6-9",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "B-Tree Height",
    "description": "With 1 million records and B-tree order 100, estimate the minimum tree height. Write as SQL comment.",
    "difficulty": 3,
    "language": "sql",
    "starterCode": "-- Calculate minimum B-tree height:\n-- ",
    "solution": "-- With order m=100, max keys per node = 99\n-- Level 0 (root): 99 keys\n-- Level 1: 100 children × 99 = 9,900 keys\n-- Level 2: 100 × 100 × 99 = 990,000 keys\n-- Level 3: 100 × 100 × 100 × 99 = 99,000,000 keys\n-- \n-- After level 2, we exceed 1 million\n-- Minimum height = 3 (root + 2 levels of internal + leaf)",
    "testCases": [
      {
        "input": "calculation",
        "expectedOutput": "Height ~3",
        "isHidden": false,
        "description": "Tree height"
      }
    ],
    "hints": [
      "Each level multiplies capacity by order.",
      "Height = log_m(n) approximately."
    ]
  },
  {
    "id": "cs205-ex-6-10",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Index Selection Analysis",
    "description": "Given query: SELECT * FROM Orders WHERE CustomerID = ? AND Status = 'Shipped' ORDER BY OrderDate DESC. Which index is best?",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Best index for this query:\n-- ",
    "solution": "-- Best index: (CustomerID, Status, OrderDate DESC)\n-- \n-- Reasoning:\n-- 1. CustomerID first - equality condition (most selective)\n-- 2. Status second - equality condition\n-- 3. OrderDate last - for ORDER BY (avoid sort)\n-- \n-- CREATE INDEX idx_orders_query\n-- ON Orders (CustomerID, Status, OrderDate DESC);",
    "testCases": [
      {
        "input": "analysis",
        "expectedOutput": "Composite index identified",
        "isHidden": false,
        "description": "Index selection"
      }
    ],
    "hints": [
      "Equality columns before range/sort.",
      "Match ORDER BY to avoid sorting."
    ]
  },
  {
    "id": "cs205-ex-6-11",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Clustered vs Non-Clustered",
    "description": "Explain when to use a clustered index vs non-clustered. Write as SQL comment with an example table.",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Clustered vs Non-clustered:\n-- ",
    "solution": "-- Clustered Index:\n-- - Data rows stored in index order\n-- - Only ONE per table (defines physical order)\n-- - Best for: range queries, columns often used for sorting\n-- - Example: OrderDate for time-series queries\n-- \n-- Non-Clustered Index:\n-- - Separate structure with pointers to data\n-- - Multiple allowed per table\n-- - Best for: point lookups, columns with many distinct values\n-- - Example: Email for user lookups\n-- \n-- CREATE CLUSTERED INDEX idx_orders_date ON Orders(OrderDate);\n-- CREATE NONCLUSTERED INDEX idx_orders_customer ON Orders(CustomerID);",
    "testCases": [
      {
        "input": "explanation",
        "expectedOutput": "Clear comparison",
        "isHidden": false,
        "description": "Index types"
      }
    ],
    "hints": [
      "Clustered = physical order.",
      "Only one clustered per table."
    ]
  },
  {
    "id": "cs205-ex-6-12",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Rebuild Index",
    "description": "Write SQL to rebuild a fragmented index idx_orders_date on the Orders table (SQL Server syntax).",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Rebuild fragmented index\n",
    "solution": "-- SQL Server syntax:\nALTER INDEX idx_orders_date ON Orders REBUILD;\n\n-- PostgreSQL alternative:\nREINDEX INDEX idx_orders_date;\n\n-- With options (SQL Server):\n-- ALTER INDEX idx_orders_date ON Orders REBUILD\n-- WITH (ONLINE = ON, FILLFACTOR = 90);",
    "testCases": [
      {
        "input": "maintenance",
        "expectedOutput": "Index rebuilt",
        "isHidden": false,
        "description": "Index rebuild"
      }
    ],
    "hints": [
      "REBUILD recreates the index.",
      "ONLINE = ON allows concurrent access."
    ]
  },
  {
    "id": "cs205-ex-6-13",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Index Statistics",
    "description": "Write SQL to update statistics on the Orders table (helps query optimizer).",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Update statistics\n",
    "solution": "-- SQL Server:\nUPDATE STATISTICS Orders;\n\n-- PostgreSQL:\nANALYZE Orders;\n\n-- MySQL:\nANALYZE TABLE Orders;\n\n-- With sampling (SQL Server):\n-- UPDATE STATISTICS Orders WITH FULLSCAN;",
    "testCases": [
      {
        "input": "statistics",
        "expectedOutput": "Statistics updated",
        "isHidden": false,
        "description": "Update stats"
      }
    ],
    "hints": [
      "Statistics help optimizer choose plans.",
      "Run after significant data changes."
    ]
  },
  {
    "id": "cs205-ex-6-14",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Index Usage Query",
    "description": "Write a query to find unused indexes in PostgreSQL (from pg_stat_user_indexes).",
    "difficulty": 3,
    "language": "sql",
    "starterCode": "-- Find unused indexes\n",
    "solution": "SELECT schemaname, relname AS table_name,\n       indexrelname AS index_name,\n       idx_scan AS times_used,\n       pg_size_pretty(pg_relation_size(indexrelid)) AS index_size\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\n  AND indexrelname NOT LIKE '%pkey'\nORDER BY pg_relation_size(indexrelid) DESC;",
    "testCases": [
      {
        "input": "query",
        "expectedOutput": "Unused indexes listed",
        "isHidden": false,
        "description": "Index analysis"
      }
    ],
    "hints": [
      "pg_stat_user_indexes tracks usage.",
      "idx_scan = 0 means never used."
    ]
  },
  {
    "id": "cs205-ex-6-15",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Index Selectivity",
    "description": "Calculate selectivity for a Status column with values: Active (8000), Inactive (1500), Pending (500). Write as SQL comment.",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Calculate selectivity:\n-- ",
    "solution": "-- Total rows = 8000 + 1500 + 500 = 10,000\n-- \n-- Selectivity = distinct values / total rows\n-- Selectivity = 3 / 10,000 = 0.0003 (very low)\n-- \n-- Cardinality per value:\n-- Active: 8000/10000 = 80% (low selectivity for this value)\n-- Inactive: 1500/10000 = 15%\n-- Pending: 500/10000 = 5% (high selectivity for this value)\n-- \n-- Index on Status alone is poor choice due to low overall selectivity\n-- But useful for partial index: WHERE Status = 'Pending'",
    "testCases": [
      {
        "input": "calculation",
        "expectedOutput": "Selectivity calculated",
        "isHidden": false,
        "description": "Selectivity analysis"
      }
    ],
    "hints": [
      "Selectivity = distinct/total.",
      "Higher selectivity = better for indexing."
    ]
  },
  {
    "id": "cs205-ex-6-16",
    "subjectId": "cs205",
    "topicId": "cs205-6",
    "title": "Hash Index",
    "description": "Create a hash index on UserID for exact-match lookups (PostgreSQL syntax).",
    "difficulty": 2,
    "language": "sql",
    "starterCode": "-- Create hash index\n",
    "solution": "CREATE INDEX idx_sessions_userid_hash\nON Sessions USING HASH (UserID);\n\n-- Note: Hash indexes are best for equality comparisons\n-- They do NOT support:\n-- - Range queries (>, <, BETWEEN)\n-- - ORDER BY\n-- - Pattern matching (LIKE)\n-- Use B-tree for those operations",
    "testCases": [
      {
        "input": "index creation",
        "expectedOutput": "Hash index created",
        "isHidden": false,
        "description": "Hash index"
      }
    ],
    "hints": [
      "USING HASH specifies hash index.",
      "Only good for equality (=) lookups."
    ]
  }
]

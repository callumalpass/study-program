[
  {
    "id": "cs104-exercise-4",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "First Unique Character",
    "difficulty": 2,
    "description": "Given a string, find the first non-repeating character and return its index. If all characters repeat, return -1. Use a hash table for an efficient solution.",
    "language": "python",
    "starterCode": "def first_unique_char(s):\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "First pass: count the frequency of each character using a hash map",
      "Second pass: find the first character with frequency 1",
      "Python dictionaries maintain insertion order (Python 3.7+)"
    ],
    "solution": "def first_unique_char(s):\n    char_count = {}\n    \n    # Count frequency of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count 1\n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    \n    return -1"
  },
  {
    "id": "cs104-t4-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Two Sum",
    "difficulty": 1,
    "description": "Given an array of integers and a target sum, return indices of two numbers that add up to target. Use a hash map for O(n) solution.",
    "starterCode": "def two_sum(nums, target):\n    # Return [i, j] where nums[i] + nums[j] == target\n    pass\n\nprint(two_sum([2, 7, 11, 15], 9))",
    "solution": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\nprint(two_sum([2, 7, 11, 15], 9))",
    "testCases": [],
    "hints": [
      "Store each number and its index in hash map",
      "For each number, check if (target - number) exists in map"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Group Anagrams",
    "difficulty": 2,
    "description": "Given an array of strings, group the anagrams together. Two strings are anagrams if they contain the same characters.",
    "starterCode": "def group_anagrams(strs):\n    # Return list of lists grouping anagrams\n    pass\n\nprint(group_anagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]))",
    "solution": "def group_anagrams(strs):\n    groups = {}\n    for s in strs:\n        key = tuple(sorted(s))\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(s)\n    return list(groups.values())\n\nprint(group_anagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]))",
    "testCases": [],
    "hints": [
      "Anagrams have the same sorted character sequence",
      "Use sorted string as hash key"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Implement Hash Map",
    "difficulty": 3,
    "description": "Implement a basic hash map with put, get, and remove operations. Handle collisions using chaining.",
    "starterCode": "class HashMap:\n    def __init__(self, size=1000):\n        self.size = size\n        self.buckets = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        pass\n    \n    def get(self, key):\n        # Return None if not found\n        pass\n    \n    def remove(self, key):\n        pass",
    "solution": "class HashMap:\n    def __init__(self, size=1000):\n        self.size = size\n        self.buckets = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        bucket_idx = self._hash(key)\n        bucket = self.buckets[bucket_idx]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n    \n    def get(self, key):\n        bucket_idx = self._hash(key)\n        bucket = self.buckets[bucket_idx]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return None\n    \n    def remove(self, key):\n        bucket_idx = self._hash(key)\n        bucket = self.buckets[bucket_idx]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                del bucket[i]\n                return",
    "testCases": [],
    "hints": [
      "Each bucket is a list of (key, value) pairs",
      "Check for existing key before inserting"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Subarray Sum Equals K",
    "difficulty": 3,
    "description": "Given an array and integer k, find the total number of continuous subarrays whose sum equals k.",
    "starterCode": "def subarray_sum(nums, k):\n    # Return count of subarrays with sum k\n    pass\n\nprint(subarray_sum([1, 1, 1], 2))",
    "solution": "def subarray_sum(nums, k):\n    count = 0\n    prefix_sum = 0\n    sum_counts = {0: 1}  # sum -> count of occurrences\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in sum_counts:\n            count += sum_counts[prefix_sum - k]\n        sum_counts[prefix_sum] = sum_counts.get(prefix_sum, 0) + 1\n    \n    return count\n\nprint(subarray_sum([1, 1, 1], 2))",
    "testCases": [],
    "hints": [
      "Use prefix sum technique",
      "If prefix[j] - prefix[i] = k, subarray i+1 to j sums to k",
      "Store count of each prefix sum in hash map"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Longest Consecutive Sequence",
    "difficulty": 4,
    "description": "Given an unsorted array, find the length of the longest consecutive elements sequence. Must run in O(n) time.",
    "starterCode": "def longest_consecutive(nums):\n    # Return length of longest consecutive sequence\n    pass\n\nprint(longest_consecutive([100, 4, 200, 1, 3, 2]))",
    "solution": "def longest_consecutive(nums):\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        # Only start counting from sequence start\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            \n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            \n            longest = max(longest, length)\n    \n    return longest\n\nprint(longest_consecutive([100, 4, 200, 1, 3, 2]))",
    "testCases": [],
    "hints": [
      "Convert to set for O(1) lookup",
      "Only start counting when num-1 is not in set",
      "This ensures each number is processed at most twice"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Contains Duplicate II",
    "difficulty": 2,
    "description": "Given an array and integer k, check if there are two distinct indices i and j such that nums[i] == nums[j] and |i - j| <= k.",
    "starterCode": "def contains_nearby_duplicate(nums, k):\n    pass\n\nprint(contains_nearby_duplicate([1, 2, 3, 1], 3))\nprint(contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2))",
    "solution": "def contains_nearby_duplicate(nums, k):\n    last_seen = {}\n    for i, num in enumerate(nums):\n        if num in last_seen and i - last_seen[num] <= k:\n            return True\n        last_seen[num] = i\n    return False\n\nprint(contains_nearby_duplicate([1, 2, 3, 1], 3))\nprint(contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2))",
    "testCases": [],
    "hints": [
      "Store last seen index of each number",
      "Check distance when duplicate found"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Design Twitter",
    "difficulty": 5,
    "description": "Design a simplified Twitter with postTweet, getNewsFeed (10 most recent from followed users), follow, and unfollow.",
    "starterCode": "class Twitter:\n    def __init__(self):\n        pass\n    \n    def post_tweet(self, user_id, tweet_id):\n        pass\n    \n    def get_news_feed(self, user_id):\n        # Return 10 most recent tweet IDs\n        pass\n    \n    def follow(self, follower_id, followee_id):\n        pass\n    \n    def unfollow(self, follower_id, followee_id):\n        pass",
    "solution": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)  # user_id -> [(time, tweet_id)]\n        self.following = defaultdict(set)  # user_id -> set of followed user_ids\n    \n    def post_tweet(self, user_id, tweet_id):\n        self.tweets[user_id].append((self.time, tweet_id))\n        self.time += 1\n    \n    def get_news_feed(self, user_id):\n        # Get tweets from user and all followed users\n        users = self.following[user_id] | {user_id}\n        heap = []\n        \n        for uid in users:\n            for tweet in self.tweets[uid]:\n                heapq.heappush(heap, (-tweet[0], tweet[1]))\n        \n        feed = []\n        while heap and len(feed) < 10:\n            feed.append(heapq.heappop(heap)[1])\n        return feed\n    \n    def follow(self, follower_id, followee_id):\n        if follower_id != followee_id:\n            self.following[follower_id].add(followee_id)\n    \n    def unfollow(self, follower_id, followee_id):\n        self.following[follower_id].discard(followee_id)",
    "testCases": [],
    "hints": [
      "Use timestamp for ordering tweets",
      "Store following as a set per user",
      "Use heap to get top 10 most recent"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Valid Anagram",
    "difficulty": 1,
    "description": "Determine if two strings are anagrams (contain the same characters with the same frequencies).",
    "starterCode": "def is_anagram(s, t):\n    # Your code here\n    pass\n\nprint(is_anagram(\"anagram\", \"nagaram\"))\nprint(is_anagram(\"rat\", \"car\"))",
    "solution": "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    \n    for char in t:\n        if char not in count:\n            return False\n        count[char] -= 1\n        if count[char] < 0:\n            return False\n    \n    return True\n\nprint(is_anagram(\"anagram\", \"nagaram\"))\nprint(is_anagram(\"rat\", \"car\"))",
    "testCases": [],
    "hints": [
      "Count character frequencies in first string",
      "Decrement counts while iterating second string",
      "Early return if character missing or count goes negative"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Isomorphic Strings",
    "difficulty": 2,
    "description": "Two strings are isomorphic if characters in s can be replaced to get t (no two characters may map to same character, order preserved). Check if two strings are isomorphic.",
    "starterCode": "def is_isomorphic(s, t):\n    # Your code here\n    pass\n\nprint(is_isomorphic(\"egg\", \"add\"))\nprint(is_isomorphic(\"foo\", \"bar\"))\nprint(is_isomorphic(\"paper\", \"title\"))",
    "solution": "def is_isomorphic(s, t):\n    if len(s) != len(t):\n        return False\n    \n    s_to_t = {}\n    t_to_s = {}\n    \n    for c1, c2 in zip(s, t):\n        if c1 in s_to_t:\n            if s_to_t[c1] != c2:\n                return False\n        else:\n            s_to_t[c1] = c2\n        \n        if c2 in t_to_s:\n            if t_to_s[c2] != c1:\n                return False\n        else:\n            t_to_s[c2] = c1\n    \n    return True\n\nprint(is_isomorphic(\"egg\", \"add\"))\nprint(is_isomorphic(\"foo\", \"bar\"))\nprint(is_isomorphic(\"paper\", \"title\"))",
    "testCases": [],
    "hints": [
      "Need bidirectional mapping: s->t and t->s",
      "Check consistency in both directions",
      "No character can map to two different characters"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Word Pattern",
    "difficulty": 2,
    "description": "Check if a pattern matches a string. Pattern \"abba\" matches \"dog cat cat dog\" but not \"dog cat cat fish\".",
    "starterCode": "def word_pattern(pattern, s):\n    # Your code here\n    pass\n\nprint(word_pattern(\"abba\", \"dog cat cat dog\"))\nprint(word_pattern(\"abba\", \"dog cat cat fish\"))",
    "solution": "def word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            char_to_word[char] = word\n        \n        if word in word_to_char:\n            if word_to_char[word] != char:\n                return False\n        else:\n            word_to_char[word] = char\n    \n    return True\n\nprint(word_pattern(\"abba\", \"dog cat cat dog\"))\nprint(word_pattern(\"abba\", \"dog cat cat fish\"))",
    "testCases": [],
    "hints": [
      "Similar to isomorphic strings",
      "Map pattern characters to words bidirectionally",
      "Split string into words first"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Find All Duplicates",
    "difficulty": 2,
    "description": "Given an array of n integers where 1 ≤ a[i] ≤ n, some elements appear twice and others appear once. Find all duplicates without extra space and in O(n) time.",
    "starterCode": "def find_duplicates(nums):\n    # Return list of duplicates\n    pass\n\nprint(find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]))",
    "solution": "def find_duplicates(nums):\n    result = []\n    \n    for num in nums:\n        idx = abs(num) - 1\n        if nums[idx] < 0:\n            result.append(abs(num))\n        else:\n            nums[idx] = -nums[idx]\n    \n    return result\n\nprint(find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]))",
    "testCases": [],
    "hints": [
      "Use array itself as hash table",
      "Mark visited by negating value at index nums[i]-1",
      "If already negative, we found a duplicate"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Top K Frequent Elements",
    "difficulty": 3,
    "description": "Given an integer array and k, return the k most frequent elements. You may return the answer in any order.",
    "starterCode": "def top_k_frequent(nums, k):\n    # Return list of k most frequent elements\n    pass\n\nprint(top_k_frequent([1,1,1,2,2,3], 2))",
    "solution": "from collections import Counter\n\ndef top_k_frequent(nums, k):\n    # Count frequencies\n    count = Counter(nums)\n    \n    # Bucket sort: index = frequency, value = list of nums with that frequency\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    # Collect k most frequent from end\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    \n    return result\n\nprint(top_k_frequent([1,1,1,2,2,3], 2))",
    "testCases": [],
    "hints": [
      "First count frequencies with hash map",
      "Use bucket sort by frequency for O(n)",
      "Alternative: use heap for O(n log k)"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Minimum Window Substring",
    "difficulty": 5,
    "description": "Given strings s and t, return the minimum window substring of s that contains all characters of t. Return \"\" if no such window exists.",
    "starterCode": "def min_window(s, t):\n    # Return minimum window or \"\"\n    pass\n\nprint(min_window(\"ADOBECODEBANC\", \"ABC\"))",
    "solution": "from collections import Counter\n\ndef min_window(s, t):\n    if not t or not s:\n        return \"\"\n    \n    t_count = Counter(t)\n    required = len(t_count)\n    \n    left = 0\n    formed = 0\n    window_counts = {}\n    \n    min_len = float(\"inf\")\n    min_left = 0\n    \n    for right, char in enumerate(s):\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        if char in t_count and window_counts[char] == t_count[char]:\n            formed += 1\n        \n        while formed == required and left <= right:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            left_char = s[left]\n            window_counts[left_char] -= 1\n            if left_char in t_count and window_counts[left_char] < t_count[left_char]:\n                formed -= 1\n            left += 1\n    \n    return \"\" if min_len == float(\"inf\") else s[min_left:min_left + min_len]\n\nprint(min_window(\"ADOBECODEBANC\", \"ABC\"))",
    "testCases": [],
    "hints": [
      "Use sliding window with two pointers",
      "Expand right to include all chars, contract left to minimize",
      "Track how many required chars are satisfied"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Insert Delete GetRandom O(1)",
    "difficulty": 3,
    "description": "Design a data structure that supports insert, remove, and getRandom in O(1) average time. getRandom should return a random element with equal probability.",
    "starterCode": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        pass\n    \n    def insert(self, val):\n        # Return True if val was not present\n        pass\n    \n    def remove(self, val):\n        # Return True if val was present\n        pass\n    \n    def get_random(self):\n        # Return random element\n        pass",
    "solution": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_idx = {}  # value -> index in list\n        self.values = []      # list of values\n    \n    def insert(self, val):\n        if val in self.val_to_idx:\n            return False\n        self.val_to_idx[val] = len(self.values)\n        self.values.append(val)\n        return True\n    \n    def remove(self, val):\n        if val not in self.val_to_idx:\n            return False\n        \n        # Swap with last element\n        idx = self.val_to_idx[val]\n        last_val = self.values[-1]\n        \n        self.values[idx] = last_val\n        self.val_to_idx[last_val] = idx\n        \n        self.values.pop()\n        del self.val_to_idx[val]\n        return True\n    \n    def get_random(self):\n        return random.choice(self.values)",
    "testCases": [],
    "hints": [
      "Use hash map for O(1) lookup + array for O(1) random access",
      "To remove, swap element with last and pop",
      "Update hash map when swapping"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "LFU Cache",
    "difficulty": 5,
    "description": "Design and implement an LFU (Least Frequently Used) cache. When capacity is reached, remove the least frequently used item (use LRU among same frequency). Support get and put in O(1).",
    "starterCode": "class LFUCache:\n    def __init__(self, capacity):\n        pass\n    \n    def get(self, key):\n        # Return value or -1 if not found\n        pass\n    \n    def put(self, key, value):\n        # Insert/update key-value pair\n        pass",
    "solution": "from collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.key_to_val = {}           # key -> value\n        self.key_to_freq = {}          # key -> frequency\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n        self.min_freq = 0\n    \n    def _update_freq(self, key):\n        freq = self.key_to_freq[key]\n        self.key_to_freq[key] = freq + 1\n        \n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        \n        self.freq_to_keys[freq + 1][key] = None\n    \n    def get(self, key):\n        if key not in self.key_to_val:\n            return -1\n        self._update_freq(key)\n        return self.key_to_val[key]\n    \n    def put(self, key, value):\n        if self.capacity <= 0:\n            return\n        \n        if key in self.key_to_val:\n            self.key_to_val[key] = value\n            self._update_freq(key)\n            return\n        \n        if len(self.key_to_val) >= self.capacity:\n            # Evict least frequent, least recent\n            lfu_key = next(iter(self.freq_to_keys[self.min_freq]))\n            del self.freq_to_keys[self.min_freq][lfu_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n            del self.key_to_val[lfu_key]\n            del self.key_to_freq[lfu_key]\n        \n        self.key_to_val[key] = value\n        self.key_to_freq[key] = 1\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1",
    "testCases": [],
    "hints": [
      "Track frequency per key and keys per frequency",
      "Use OrderedDict for LRU among same frequency",
      "Track min_freq for O(1) eviction"
    ],
    "language": "python"
  }
]

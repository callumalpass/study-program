[
  {
    "id": "cs104-exercise-5",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Course Schedule (Graph Cycle Detection)",
    "difficulty": 3,
    "description": "Given a number of courses and their prerequisites, determine if it's possible to complete all courses. This is a cycle detection problem in a directed graph.",
    "language": "python",
    "starterCode": "def can_finish(num_courses, prerequisites):\n    # prerequisites is a list of [course, prerequisite] pairs\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "Build an adjacency list to represent the graph",
      "Use DFS with a visited state tracking: unvisited, visiting, visited",
      "If you encounter a node in \"visiting\" state, a cycle exists"
    ],
    "solution": "def can_finish(num_courses, prerequisites):\n    # Build adjacency list\n    graph = {i: [] for i in range(num_courses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # 0 = unvisited, 1 = visiting, 2 = visited\n    state = [0] * num_courses\n    \n    def has_cycle(course):\n        if state[course] == 1:  # Currently visiting - cycle detected\n            return True\n        if state[course] == 2:  # Already visited\n            return False\n        \n        state[course] = 1  # Mark as visiting\n        for prereq in graph[course]:\n            if has_cycle(prereq):\n                return True\n        state[course] = 2  # Mark as visited\n        return False\n    \n    for course in range(num_courses):\n        if has_cycle(course):\n            return False\n    \n    return True"
  },
  {
    "id": "cs104-t5-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "BFS - Shortest Path in Unweighted Graph",
    "difficulty": 2,
    "description": "Find the shortest path between two nodes in an unweighted graph using BFS. Return the path length, or -1 if no path exists.",
    "starterCode": "from collections import deque\n\ndef shortest_path(graph, start, end):\n    # graph is adjacency list: {node: [neighbors]}\n    pass\n\ngraph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}\nprint(shortest_path(graph, 0, 4))",
    "solution": "from collections import deque\n\ndef shortest_path(graph, start, end):\n    if start == end:\n        return 0\n    \n    visited = {start}\n    queue = deque([(start, 0)])\n    \n    while queue:\n        node, distance = queue.popleft()\n        for neighbor in graph.get(node, []):\n            if neighbor == end:\n                return distance + 1\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, distance + 1))\n    \n    return -1\n\ngraph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}\nprint(shortest_path(graph, 0, 4))",
    "testCases": [],
    "hints": [
      "BFS finds shortest path in unweighted graphs",
      "Track visited nodes to avoid cycles",
      "Store distance with each node in queue"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "DFS - Count Connected Components",
    "difficulty": 2,
    "description": "Count the number of connected components in an undirected graph.",
    "starterCode": "def count_components(n, edges):\n    # n is number of nodes (0 to n-1)\n    # edges is list of [a, b] pairs\n    pass\n\nprint(count_components(5, [[0,1], [1,2], [3,4]]))",
    "solution": "def count_components(n, edges):\n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    visited = set()\n    count = 0\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    for node in range(n):\n        if node not in visited:\n            dfs(node)\n            count += 1\n    \n    return count\n\nprint(count_components(5, [[0,1], [1,2], [3,4]]))",
    "testCases": [],
    "hints": [
      "Build undirected adjacency list (add both directions)",
      "DFS from each unvisited node starts a new component"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Clone Graph",
    "difficulty": 3,
    "description": "Given a reference to a node in a connected undirected graph, return a deep copy. Each node has a value and list of neighbors.",
    "starterCode": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors else []\n\ndef clone_graph(node):\n    # Return deep copy of graph\n    pass",
    "solution": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors else []\n\ndef clone_graph(node):\n    if not node:\n        return None\n    \n    cloned = {}  # original node -> cloned node\n    \n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n        \n        copy = Node(node.val)\n        cloned[node] = copy\n        \n        for neighbor in node.neighbors:\n            copy.neighbors.append(dfs(neighbor))\n        \n        return copy\n    \n    return dfs(node)",
    "testCases": [],
    "hints": [
      "Use hash map to track original -> clone mapping",
      "DFS to traverse and clone each node",
      "Check if already cloned before creating new node"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Topological Sort",
    "difficulty": 3,
    "description": "Perform topological sort on a directed acyclic graph. Return a valid ordering, or empty list if graph has a cycle.",
    "starterCode": "def topological_sort(n, edges):\n    # n nodes (0 to n-1), edges are [from, to] pairs\n    # Return list in topological order\n    pass\n\nprint(topological_sort(4, [[0,1], [0,2], [1,3], [2,3]]))",
    "solution": "from collections import deque\n\ndef topological_sort(n, edges):\n    # Build graph and count in-degrees\n    graph = {i: [] for i in range(n)}\n    in_degree = [0] * n\n    \n    for a, b in edges:\n        graph[a].append(b)\n        in_degree[b] += 1\n    \n    # Start with nodes having 0 in-degree\n    queue = deque([i for i in range(n) if in_degree[i] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == n else []\n\nprint(topological_sort(4, [[0,1], [0,2], [1,3], [2,3]]))",
    "testCases": [],
    "hints": [
      "Use Kahn's algorithm with in-degree counting",
      "Start with nodes having in-degree 0",
      "If result length != n, there was a cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Dijkstra's Shortest Path",
    "difficulty": 4,
    "description": "Implement Dijkstra's algorithm to find the shortest path from a source to all other nodes in a weighted graph.",
    "starterCode": "import heapq\n\ndef dijkstra(graph, start):\n    # graph: {node: [(neighbor, weight), ...]}\n    # Return dict of shortest distances from start\n    pass\n\ngraph = {\n    0: [(1, 4), (2, 1)],\n    1: [(3, 1)],\n    2: [(1, 2), (3, 5)],\n    3: []\n}\nprint(dijkstra(graph, 0))",
    "solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    heap = [(0, start)]  # (distance, node)\n    \n    while heap:\n        dist, node = heapq.heappop(heap)\n        \n        if dist > distances[node]:\n            continue\n        \n        for neighbor, weight in graph.get(node, []):\n            new_dist = dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n    \n    return distances\n\ngraph = {\n    0: [(1, 4), (2, 1)],\n    1: [(3, 1)],\n    2: [(1, 2), (3, 5)],\n    3: []\n}\nprint(dijkstra(graph, 0))",
    "testCases": [],
    "hints": [
      "Use min heap for efficiency",
      "Skip if we've found a shorter path already",
      "Update distance if new path is shorter"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Number of Islands",
    "difficulty": 2,
    "description": "Given a 2D grid of \"1\"s (land) and \"0\"s (water), count the number of islands. An island is surrounded by water and formed by connecting adjacent lands.",
    "starterCode": "def num_islands(grid):\n    # grid is list of lists of \"0\" and \"1\"\n    pass\n\ngrid = [\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nprint(num_islands(grid))",
    "solution": "def num_islands(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == \"0\":\n            return\n        grid[r][c] = \"0\"  # Mark as visited\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                count += 1\n    \n    return count\n\ngrid = [\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nprint(num_islands(grid))",
    "testCases": [],
    "hints": [
      "Use DFS/BFS to explore each island",
      "Mark visited cells to avoid counting twice",
      "Each DFS from a new \"1\" is a new island"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Minimum Spanning Tree (Prim's)",
    "difficulty": 5,
    "description": "Implement Prim's algorithm to find the minimum spanning tree of a weighted undirected graph. Return the total weight.",
    "starterCode": "import heapq\n\ndef prim_mst(n, edges):\n    # n nodes (0 to n-1)\n    # edges: [[a, b, weight], ...]\n    # Return total weight of MST\n    pass\n\nprint(prim_mst(4, [[0,1,1], [0,2,4], [1,2,2], [1,3,6], [2,3,3]]))",
    "solution": "import heapq\n\ndef prim_mst(n, edges):\n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b, w in edges:\n        graph[a].append((w, b))\n        graph[b].append((w, a))\n    \n    visited = set()\n    heap = [(0, 0)]  # (weight, node), start from node 0\n    total_weight = 0\n    \n    while heap and len(visited) < n:\n        weight, node = heapq.heappop(heap)\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        total_weight += weight\n        \n        for edge_weight, neighbor in graph[node]:\n            if neighbor not in visited:\n                heapq.heappush(heap, (edge_weight, neighbor))\n    \n    return total_weight if len(visited) == n else -1\n\nprint(prim_mst(4, [[0,1,1], [0,2,4], [1,2,2], [1,3,6], [2,3,3]]))",
    "testCases": [],
    "hints": [
      "Use min heap to always pick minimum weight edge",
      "Start from any node, greedily add cheapest edge to unvisited node",
      "MST has n-1 edges for n nodes"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Pacific Atlantic Water Flow",
    "difficulty": 3,
    "description": "Given an m x n matrix of heights, water can flow to adjacent cells with equal or lower height. Find all cells that can reach both the Pacific Ocean (left/top) and Atlantic Ocean (right/bottom).",
    "starterCode": "def pacific_atlantic(heights):\n    # Return list of [row, col] coordinates\n    pass\n\nheights = [\n    [1,2,2,3,5],\n    [3,2,3,4,4],\n    [2,4,5,3,1],\n    [6,7,1,4,5],\n    [5,1,1,2,4]\n]\nprint(pacific_atlantic(heights))",
    "solution": "def pacific_atlantic(heights):\n    if not heights:\n        return []\n    \n    rows, cols = len(heights), len(heights[0])\n    pacific = set()\n    atlantic = set()\n    \n    def dfs(r, c, visited, prev_height):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if heights[r][c] < prev_height:\n            return\n        \n        visited.add((r, c))\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            dfs(r + dr, c + dc, visited, heights[r][c])\n    \n    # Start DFS from ocean borders\n    for c in range(cols):\n        dfs(0, c, pacific, heights[0][c])         # Top (Pacific)\n        dfs(rows-1, c, atlantic, heights[rows-1][c])  # Bottom (Atlantic)\n    \n    for r in range(rows):\n        dfs(r, 0, pacific, heights[r][0])         # Left (Pacific)\n        dfs(r, cols-1, atlantic, heights[r][cols-1])  # Right (Atlantic)\n    \n    return [[r, c] for r, c in pacific & atlantic]\n\nheights = [\n    [1,2,2,3,5],\n    [3,2,3,4,4],\n    [2,4,5,3,1],\n    [6,7,1,4,5],\n    [5,1,1,2,4]\n]\nprint(pacific_atlantic(heights))",
    "testCases": [],
    "hints": [
      "Think backwards: find cells reachable FROM the oceans",
      "DFS from ocean borders going uphill",
      "Answer is intersection of cells reaching both oceans"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Word Ladder",
    "difficulty": 4,
    "description": "Given begin word, end word, and a word list, find length of shortest transformation sequence where each transformed word must exist in word list and only one letter changes at a time.",
    "starterCode": "from collections import deque\n\ndef ladder_length(begin_word, end_word, word_list):\n    # Return length of shortest transformation, or 0 if impossible\n    pass\n\nprint(ladder_length(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))",
    "solution": "from collections import deque, defaultdict\n\ndef ladder_length(begin_word, end_word, word_list):\n    if end_word not in word_list:\n        return 0\n    \n    word_set = set(word_list)\n    word_len = len(begin_word)\n    \n    # Build pattern graph: h*t -> [hit, hot]\n    patterns = defaultdict(list)\n    for word in word_set:\n        for i in range(word_len):\n            pattern = word[:i] + \"*\" + word[i+1:]\n            patterns[pattern].append(word)\n    \n    queue = deque([(begin_word, 1)])\n    visited = {begin_word}\n    \n    while queue:\n        word, length = queue.popleft()\n        \n        for i in range(word_len):\n            pattern = word[:i] + \"*\" + word[i+1:]\n            for neighbor in patterns[pattern]:\n                if neighbor == end_word:\n                    return length + 1\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1))\n    \n    return 0\n\nprint(ladder_length(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))",
    "testCases": [],
    "hints": [
      "Model as graph: words are nodes, edges connect words differing by one letter",
      "Use BFS for shortest path",
      "Use wildcard patterns for efficient neighbor finding"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Surrounded Regions",
    "difficulty": 3,
    "description": "Given an m x n board containing \"X\" and \"O\", capture all regions surrounded by \"X\". A region is captured by flipping all \"O\"s to \"X\"s. \"O\"s on the border are not captured.",
    "starterCode": "def solve(board):\n    # Modify board in-place\n    pass\n\nboard = [\n    [\"X\",\"X\",\"X\",\"X\"],\n    [\"X\",\"O\",\"O\",\"X\"],\n    [\"X\",\"X\",\"O\",\"X\"],\n    [\"X\",\"O\",\"X\",\"X\"]\n]\nsolve(board)\nprint(board)",
    "solution": "def solve(board):\n    if not board:\n        return\n    \n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != \"O\":\n            return\n        board[r][c] = \"T\"  # Temporarily mark as safe\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    \n    # Mark all Os connected to border\n    for r in range(rows):\n        dfs(r, 0)\n        dfs(r, cols-1)\n    for c in range(cols):\n        dfs(0, c)\n        dfs(rows-1, c)\n    \n    # Flip: T -> O (safe), O -> X (captured)\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n            elif board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\nboard = [\n    [\"X\",\"X\",\"X\",\"X\"],\n    [\"X\",\"O\",\"O\",\"X\"],\n    [\"X\",\"X\",\"O\",\"X\"],\n    [\"X\",\"O\",\"X\",\"X\"]\n]\nsolve(board)\nprint(board)",
    "testCases": [],
    "hints": [
      "Start from border Os - these cannot be captured",
      "Mark all Os connected to border with temporary marker",
      "Then flip: remaining Os to X, temporary back to O"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Graph Valid Tree",
    "difficulty": 3,
    "description": "Given n nodes (0 to n-1) and edges, determine if these edges form a valid tree. A valid tree has n-1 edges, is connected, and has no cycles.",
    "starterCode": "def valid_tree(n, edges):\n    # Return True if edges form a valid tree\n    pass\n\nprint(valid_tree(5, [[0,1], [0,2], [0,3], [1,4]]))\nprint(valid_tree(5, [[0,1], [1,2], [2,3], [1,3], [1,4]]))",
    "solution": "def valid_tree(n, edges):\n    if len(edges) != n - 1:\n        return False\n    \n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Check if all nodes are connected (single component)\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    dfs(0)\n    return len(visited) == n\n\nprint(valid_tree(5, [[0,1], [0,2], [0,3], [1,4]]))\nprint(valid_tree(5, [[0,1], [1,2], [2,3], [1,3], [1,4]]))",
    "testCases": [],
    "hints": [
      "A tree with n nodes has exactly n-1 edges",
      "If n-1 edges and all nodes connected, no cycles possible",
      "Check connectivity with DFS from any node"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Cheapest Flights Within K Stops",
    "difficulty": 4,
    "description": "Find cheapest price from src to dst with at most k stops. Flights given as [from, to, price]. Return -1 if no such route.",
    "starterCode": "def find_cheapest_price(n, flights, src, dst, k):\n    # Return minimum cost or -1\n    pass\n\nflights = [[0,1,100],[1,2,100],[0,2,500]]\nprint(find_cheapest_price(3, flights, 0, 2, 1))",
    "solution": "def find_cheapest_price(n, flights, src, dst, k):\n    # Bellman-Ford variant: relax edges k+1 times\n    prices = [float(\"inf\")] * n\n    prices[src] = 0\n    \n    for _ in range(k + 1):\n        temp = prices.copy()\n        for u, v, price in flights:\n            if prices[u] != float(\"inf\"):\n                temp[v] = min(temp[v], prices[u] + price)\n        prices = temp\n    \n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\nflights = [[0,1,100],[1,2,100],[0,2,500]]\nprint(find_cheapest_price(3, flights, 0, 2, 1))",
    "testCases": [],
    "hints": [
      "Modified Bellman-Ford: relax exactly k+1 times",
      "Use temp array to prevent using edges from same round",
      "Each iteration allows one more edge/stop"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Redundant Connection",
    "difficulty": 3,
    "description": "Given a graph that was originally a tree with one extra edge added, find and return the redundant edge. Return the answer that occurs last in the input.",
    "starterCode": "def find_redundant_connection(edges):\n    # Return the redundant edge [u, v]\n    pass\n\nprint(find_redundant_connection([[1,2], [1,3], [2,3]]))\nprint(find_redundant_connection([[1,2], [2,3], [3,4], [1,4], [1,5]]))",
    "solution": "def find_redundant_connection(edges):\n    parent = {}\n    \n    def find(x):\n        if x not in parent:\n            parent[x] = x\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False  # Already connected = cycle\n        parent[px] = py\n        return True\n    \n    for edge in edges:\n        if not union(edge[0], edge[1]):\n            return edge\n    \n    return []\n\nprint(find_redundant_connection([[1,2], [1,3], [2,3]]))\nprint(find_redundant_connection([[1,2], [2,3], [3,4], [1,4], [1,5]]))",
    "testCases": [],
    "hints": [
      "Use Union-Find data structure",
      "If an edge connects already-connected nodes, it creates cycle",
      "Return the first edge that creates a cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Rotting Oranges",
    "difficulty": 2,
    "description": "In a grid, 0=empty, 1=fresh orange, 2=rotten. Every minute, fresh oranges adjacent to rotten become rotten. Return minutes until no fresh oranges, or -1 if impossible.",
    "starterCode": "from collections import deque\n\ndef oranges_rotting(grid):\n    # Return minutes or -1\n    pass\n\ngrid = [[2,1,1],[1,1,0],[0,1,1]]\nprint(oranges_rotting(grid))",
    "solution": "from collections import deque\n\ndef oranges_rotting(grid):\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh = 0\n    \n    # Find all rotten and count fresh\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c))\n            elif grid[r][c] == 1:\n                fresh += 1\n    \n    if fresh == 0:\n        return 0\n    \n    minutes = 0\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    \n    while queue:\n        minutes += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n    \n    return minutes - 1 if fresh == 0 else -1\n\ngrid = [[2,1,1],[1,1,0],[0,1,1]]\nprint(oranges_rotting(grid))",
    "testCases": [],
    "hints": [
      "Multi-source BFS: start from all rotten oranges",
      "Process level by level (each level = 1 minute)",
      "Track fresh count; return -1 if any remain"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "All Paths From Source to Target",
    "difficulty": 2,
    "description": "Given a directed acyclic graph (DAG) of n nodes (0 to n-1), find all paths from node 0 to node n-1. Return as list of paths.",
    "starterCode": "def all_paths_source_target(graph):\n    # graph[i] is list of nodes reachable from node i\n    # Return all paths from 0 to n-1\n    pass\n\ngraph = [[1,2],[3],[3],[]]\nprint(all_paths_source_target(graph))",
    "solution": "def all_paths_source_target(graph):\n    target = len(graph) - 1\n    result = []\n    \n    def dfs(node, path):\n        if node == target:\n            result.append(path[:])\n            return\n        \n        for neighbor in graph[node]:\n            path.append(neighbor)\n            dfs(neighbor, path)\n            path.pop()\n    \n    dfs(0, [0])\n    return result\n\ngraph = [[1,2],[3],[3],[]]\nprint(all_paths_source_target(graph))",
    "testCases": [],
    "hints": [
      "Use DFS with backtracking",
      "No need to track visited in DAG (no cycles)",
      "Copy path when reaching target"
    ],
    "language": "python"
  }
]

[
  {
    "id": "cs104-exercise-1",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Reverse a Linked List",
    "difficulty": 3,
    "description": "Implement a function to reverse a singly linked list in-place. The function should take the head of the list and return the new head after reversal.",
    "language": "python",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef reverse_linked_list(head):\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "Use three pointers: previous, current, and next",
      "Iterate through the list and reverse the next pointer of each node",
      "Don't forget to handle the edge case of an empty list"
    ],
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    \n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    \n    return prev"
  },
  {
    "id": "cs104-t1-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Find Middle of Linked List",
    "difficulty": 1,
    "description": "Find and return the middle node of a linked list. If there are two middle nodes (even length), return the second one.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef find_middle(head):\n    # Your code here\n    pass\n\n# Test\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nprint(find_middle(head).value)",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef find_middle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nprint(find_middle(head).value)",
    "testCases": [],
    "hints": [
      "Use two pointers: slow and fast",
      "Fast moves 2 steps while slow moves 1"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Detect Cycle in Linked List",
    "difficulty": 2,
    "description": "Determine if a linked list has a cycle. Return True if there is a cycle, False otherwise.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef has_cycle(head):\n    # Your code here\n    pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
    "testCases": [],
    "hints": [
      "Use Floyd's cycle detection (tortoise and hare)",
      "If fast catches up to slow, there's a cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Array Rotation",
    "difficulty": 2,
    "description": "Rotate an array to the right by k positions. For example, [1,2,3,4,5] rotated by 2 becomes [4,5,1,2,3].",
    "starterCode": "def rotate_array(arr, k):\n    # Modify arr in-place\n    pass\n\narr = [1, 2, 3, 4, 5]\nrotate_array(arr, 2)\nprint(arr)",
    "solution": "def rotate_array(arr, k):\n    n = len(arr)\n    k = k % n  # Handle k > n\n    \n    def reverse(start, end):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n    \n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n\narr = [1, 2, 3, 4, 5]\nrotate_array(arr, 2)\nprint(arr)",
    "testCases": [],
    "hints": [
      "Use the reversal algorithm: reverse all, then reverse first k, then reverse rest",
      "Handle k > array length with modulo"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Merge Two Sorted Lists",
    "difficulty": 2,
    "description": "Merge two sorted linked lists into one sorted linked list.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef merge_sorted(l1, l2):\n    # Your code here\n    pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef merge_sorted(l1, l2):\n    dummy = Node(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.value <= l2.value:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    current.next = l1 if l1 else l2\n    return dummy.next",
    "testCases": [],
    "hints": [
      "Use a dummy head node to simplify edge cases",
      "Compare values and link the smaller one"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": 1,
    "description": "Remove duplicates from a sorted array in-place. Return the new length.",
    "starterCode": "def remove_duplicates(nums):\n    # Modify nums in-place, return new length\n    pass\n\nnums = [1, 1, 2, 2, 3]\nlength = remove_duplicates(nums)\nprint(nums[:length])",
    "solution": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    write_idx = 1\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            nums[write_idx] = nums[i]\n            write_idx += 1\n    return write_idx\n\nnums = [1, 1, 2, 2, 3]\nlength = remove_duplicates(nums)\nprint(nums[:length])",
    "testCases": [],
    "hints": [
      "Use two pointers: one for reading, one for writing",
      "Write when current differs from previous"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Doubly Linked List",
    "difficulty": 3,
    "description": "Implement a doubly linked list with insert_front, insert_back, and delete operations.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n    \n    def insert_front(self, value):\n        pass\n    \n    def insert_back(self, value):\n        pass\n    \n    def delete(self, value):\n        pass\n    \n    def to_list(self):\n        result = []\n        current = self.head\n        while current:\n            result.append(current.value)\n            current = current.next\n        return result",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n    \n    def insert_front(self, value):\n        node = Node(value)\n        if not self.head:\n            self.head = self.tail = node\n        else:\n            node.next = self.head\n            self.head.prev = node\n            self.head = node\n    \n    def insert_back(self, value):\n        node = Node(value)\n        if not self.tail:\n            self.head = self.tail = node\n        else:\n            node.prev = self.tail\n            self.tail.next = node\n            self.tail = node\n    \n    def delete(self, value):\n        current = self.head\n        while current:\n            if current.value == value:\n                if current.prev:\n                    current.prev.next = current.next\n                else:\n                    self.head = current.next\n                if current.next:\n                    current.next.prev = current.prev\n                else:\n                    self.tail = current.prev\n                return True\n            current = current.next\n        return False\n    \n    def to_list(self):\n        result = []\n        current = self.head\n        while current:\n            result.append(current.value)\n            current = current.next\n        return result",
    "testCases": [],
    "hints": [
      "Track both head and tail pointers",
      "Update both prev and next when deleting"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "LRU Cache Implementation",
    "difficulty": 5,
    "description": "Implement an LRU (Least Recently Used) cache using a hash map and doubly linked list. Support get() and put() in O(1) time.",
    "starterCode": "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        # Your code here\n    \n    def get(self, key):\n        # Return -1 if not found\n        pass\n    \n    def put(self, key, value):\n        # Evict LRU if at capacity\n        pass\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))\ncache.put(3, 3)  # evicts key 2\nprint(cache.get(2))",
    "solution": "class Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def _add_to_front(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def get(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add_to_front(node)\n            return node.value\n        return -1\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = Node(key, value)\n        self._add_to_front(node)\n        self.cache[key] = node\n        if len(self.cache) > self.capacity:\n            lru = self.tail.prev\n            self._remove(lru)\n            del self.cache[lru.key]\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))\ncache.put(3, 3)\nprint(cache.get(2))",
    "testCases": [],
    "hints": [
      "Use dummy head/tail nodes to avoid edge cases",
      "HashMap stores key -> Node for O(1) lookup",
      "Move accessed nodes to front"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Move Zeroes",
    "difficulty": 1,
    "description": "Given an integer array, move all 0's to the end while maintaining the relative order of the non-zero elements. Do this in-place without making a copy.",
    "starterCode": "def move_zeroes(nums):\n    # Modify nums in-place\n    pass\n\nnums = [0, 1, 0, 3, 12]\nmove_zeroes(nums)\nprint(nums)",
    "solution": "def move_zeroes(nums):\n    write_idx = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[write_idx], nums[i] = nums[i], nums[write_idx]\n            write_idx += 1\n\nnums = [0, 1, 0, 3, 12]\nmove_zeroes(nums)\nprint(nums)",
    "testCases": [],
    "hints": [
      "Use two pointers: one for reading, one for writing non-zero values",
      "Swap instead of overwrite to handle all cases"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Remove Nth Node from End",
    "difficulty": 2,
    "description": "Given a linked list, remove the nth node from the end of the list and return the head. Use a single pass if possible.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef remove_nth_from_end(head, n):\n    # Your code here\n    pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef remove_nth_from_end(head, n):\n    dummy = Node(0)\n    dummy.next = head\n    fast = slow = dummy\n    \n    # Move fast n+1 steps ahead\n    for _ in range(n + 1):\n        fast = fast.next\n    \n    # Move both until fast reaches end\n    while fast:\n        fast = fast.next\n        slow = slow.next\n    \n    # Remove the nth node\n    slow.next = slow.next.next\n    return dummy.next",
    "testCases": [],
    "hints": [
      "Use two pointers with n nodes gap between them",
      "Use a dummy node to handle edge case of removing head"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Intersection of Two Linked Lists",
    "difficulty": 2,
    "description": "Given the heads of two singly linked-lists, return the node at which they intersect. If no intersection, return None.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef get_intersection_node(headA, headB):\n    # Your code here\n    pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef get_intersection_node(headA, headB):\n    if not headA or not headB:\n        return None\n    \n    pA, pB = headA, headB\n    \n    while pA != pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    \n    return pA",
    "testCases": [],
    "hints": [
      "If we traverse A+B and B+A, both paths have same length",
      "They will meet at intersection or both reach None"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Product of Array Except Self",
    "difficulty": 3,
    "description": "Given an integer array nums, return an array where output[i] equals the product of all elements except nums[i]. Solve without using division and in O(n) time.",
    "starterCode": "def product_except_self(nums):\n    # Return array of products\n    pass\n\nprint(product_except_self([1, 2, 3, 4]))",
    "solution": "def product_except_self(nums):\n    n = len(nums)\n    result = [1] * n\n    \n    # Left pass: result[i] = product of all elements left of i\n    left_product = 1\n    for i in range(n):\n        result[i] = left_product\n        left_product *= nums[i]\n    \n    # Right pass: multiply by product of all elements right of i\n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n    \n    return result\n\nprint(product_except_self([1, 2, 3, 4]))",
    "testCases": [],
    "hints": [
      "Use prefix and suffix products",
      "First pass: compute prefix products",
      "Second pass: multiply by suffix products"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Palindrome Linked List",
    "difficulty": 2,
    "description": "Determine if a singly linked list is a palindrome. Can you do it in O(n) time and O(1) space?",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef is_palindrome(head):\n    # Your code here\n    pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef is_palindrome(head):\n    if not head or not head.next:\n        return True\n    \n    # Find middle\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev = None\n    curr = slow.next\n    while curr:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n    \n    # Compare halves\n    first, second = head, prev\n    while second:\n        if first.value != second.value:\n            return False\n        first = first.next\n        second = second.next\n    \n    return True",
    "testCases": [],
    "hints": [
      "Find the middle using slow/fast pointers",
      "Reverse the second half",
      "Compare first half with reversed second half"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Find the Duplicate Number",
    "difficulty": 3,
    "description": "Given an array of n+1 integers where each integer is in [1, n], find the duplicate. There is exactly one duplicate which may appear more than once. Solve without modifying the array and using only O(1) extra space.",
    "starterCode": "def find_duplicate(nums):\n    # Your code here\n    pass\n\nprint(find_duplicate([1, 3, 4, 2, 2]))",
    "solution": "def find_duplicate(nums):\n    # Floyd's cycle detection (treat array as linked list)\n    slow = fast = nums[0]\n    \n    # Find intersection point\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    \n    # Find cycle start\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow\n\nprint(find_duplicate([1, 3, 4, 2, 2]))",
    "testCases": [],
    "hints": [
      "Treat array values as \"next pointers\" - nums[i] points to index nums[i]",
      "A duplicate means two indices point to same location = cycle",
      "Use Floyd's cycle detection to find the duplicate"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Reorder List",
    "difficulty": 3,
    "description": "Given a singly linked list L0→L1→...→Ln-1→Ln, reorder it to L0→Ln→L1→Ln-1→L2→Ln-2→... Do this in-place without modifying node values.",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef reorder_list(head):\n    # Modify list in-place\n    pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\ndef reorder_list(head):\n    if not head or not head.next:\n        return\n    \n    # Find middle\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev = None\n    curr = slow.next\n    slow.next = None\n    while curr:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n    \n    # Merge two halves\n    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first = tmp1\n        second = tmp2",
    "testCases": [],
    "hints": [
      "Find the middle of the list",
      "Reverse the second half",
      "Merge the two halves by alternating nodes"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t1-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-1",
    "title": "Dynamic Array Implementation",
    "difficulty": 3,
    "description": "Implement a dynamic array (like Python list or Java ArrayList) that automatically resizes. Support append, pop, get, set, and size operations.",
    "starterCode": "class DynamicArray:\n    def __init__(self):\n        self.capacity = 1\n        self.size = 0\n        self.array = [None] * self.capacity\n    \n    def append(self, val):\n        pass\n    \n    def pop(self):\n        pass\n    \n    def get(self, index):\n        pass\n    \n    def set(self, index, val):\n        pass\n    \n    def length(self):\n        pass",
    "solution": "class DynamicArray:\n    def __init__(self):\n        self.capacity = 1\n        self.size = 0\n        self.array = [None] * self.capacity\n    \n    def _resize(self, new_capacity):\n        new_array = [None] * new_capacity\n        for i in range(self.size):\n            new_array[i] = self.array[i]\n        self.array = new_array\n        self.capacity = new_capacity\n    \n    def append(self, val):\n        if self.size == self.capacity:\n            self._resize(2 * self.capacity)\n        self.array[self.size] = val\n        self.size += 1\n    \n    def pop(self):\n        if self.size == 0:\n            raise IndexError(\"pop from empty array\")\n        self.size -= 1\n        val = self.array[self.size]\n        self.array[self.size] = None\n        if self.size > 0 and self.size == self.capacity // 4:\n            self._resize(self.capacity // 2)\n        return val\n    \n    def get(self, index):\n        if index < 0 or index >= self.size:\n            raise IndexError(\"index out of bounds\")\n        return self.array[index]\n    \n    def set(self, index, val):\n        if index < 0 or index >= self.size:\n            raise IndexError(\"index out of bounds\")\n        self.array[index] = val\n    \n    def length(self):\n        return self.size",
    "testCases": [],
    "hints": [
      "Double capacity when array is full",
      "Halve capacity when 1/4 full (to avoid thrashing)",
      "Amortized O(1) for append operations"
    ],
    "language": "python"
  },
  {
    "id": "cs104-exercise-2",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Implement a Stack using Queues",
    "difficulty": 3,
    "description": "Implement a stack using only queue operations (enqueue and dequeue). Your stack should support push, pop, and top operations.",
    "language": "python",
    "starterCode": "from collections import deque\n\nclass Stack:\n    def __init__(self):\n        self.queue = deque()\n    \n    def push(self, x):\n        # Your code here\n        pass\n    \n    def pop(self):\n        # Your code here\n        pass\n    \n    def top(self):\n        # Your code here\n        pass",
    "testCases": [],
    "hints": [
      "After adding a new element, rotate the queue to make it the front",
      "Use queue size to determine how many rotations are needed",
      "The most recently added element should always be at the front"
    ],
    "solution": "from collections import deque\n\nclass Stack:\n    def __init__(self):\n        self.queue = deque()\n    \n    def push(self, x):\n        self.queue.append(x)\n        for _ in range(len(self.queue) - 1):\n            self.queue.append(self.queue.popleft())\n    \n    def pop(self):\n        return self.queue.popleft()\n    \n    def top(self):\n        return self.queue[0]"
  },
  {
    "id": "cs104-t2-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Valid Parentheses",
    "difficulty": 1,
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. Brackets must close in the correct order.",
    "starterCode": "def is_valid(s):\n    # Your code here\n    pass\n\nprint(is_valid(\"()[]{}\"))\nprint(is_valid(\"([)]\"))",
    "solution": "def is_valid(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return len(stack) == 0\n\nprint(is_valid(\"()[]{}\"))\nprint(is_valid(\"([)]\"))",
    "testCases": [],
    "hints": [
      "Use a stack to track opening brackets",
      "When you see a closing bracket, check if it matches the top of the stack"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Implement Queue using Stacks",
    "difficulty": 2,
    "description": "Implement a queue using only stack operations. Support enqueue, dequeue, and front operations.",
    "starterCode": "class Queue:\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n    \n    def enqueue(self, x):\n        pass\n    \n    def dequeue(self):\n        pass\n    \n    def front(self):\n        pass",
    "solution": "class Queue:\n    def __init__(self):\n        self.stack1 = []  # For push\n        self.stack2 = []  # For pop\n    \n    def enqueue(self, x):\n        self.stack1.append(x)\n    \n    def dequeue(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n    \n    def front(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]",
    "testCases": [],
    "hints": [
      "Use two stacks",
      "Only transfer from stack1 to stack2 when stack2 is empty"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Min Stack",
    "difficulty": 2,
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in O(1) time.",
    "starterCode": "class MinStack:\n    def __init__(self):\n        pass\n    \n    def push(self, val):\n        pass\n    \n    def pop(self):\n        pass\n    \n    def top(self):\n        pass\n    \n    def get_min(self):\n        pass\n\nms = MinStack()\nms.push(3)\nms.push(1)\nms.push(2)\nprint(ms.get_min())",
    "solution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self):\n        return self.stack[-1]\n    \n    def get_min(self):\n        return self.min_stack[-1]\n\nms = MinStack()\nms.push(3)\nms.push(1)\nms.push(2)\nprint(ms.get_min())",
    "testCases": [],
    "hints": [
      "Use a secondary stack to track minimums",
      "Push to min stack when value <= current min"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Evaluate Reverse Polish Notation",
    "difficulty": 3,
    "description": "Evaluate an expression in Reverse Polish Notation (postfix). Valid operators are +, -, *, /. Division truncates toward zero.",
    "starterCode": "def eval_rpn(tokens):\n    # Your code here\n    pass\n\nprint(eval_rpn([\"2\", \"1\", \"+\", \"3\", \"*\"]))\nprint(eval_rpn([\"4\", \"13\", \"5\", \"/\", \"+\"]))",
    "solution": "def eval_rpn(tokens):\n    stack = []\n    operators = {\n        \"+\": lambda a, b: a + b,\n        \"-\": lambda a, b: a - b,\n        \"*\": lambda a, b: a * b,\n        \"/\": lambda a, b: int(a / b)\n    }\n    \n    for token in tokens:\n        if token in operators:\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(operators[token](a, b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]\n\nprint(eval_rpn([\"2\", \"1\", \"+\", \"3\", \"*\"]))\nprint(eval_rpn([\"4\", \"13\", \"5\", \"/\", \"+\"]))",
    "testCases": [],
    "hints": [
      "Push numbers onto stack",
      "Pop two operands for each operator",
      "Order matters: second popped is left operand"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Sliding Window Maximum",
    "difficulty": 4,
    "description": "Given an array and a window size k, return the maximum value in each sliding window. Use a deque for O(n) solution.",
    "starterCode": "from collections import deque\n\ndef max_sliding_window(nums, k):\n    # Your code here\n    pass\n\nprint(max_sliding_window([1,3,-1,-3,5,3,6,7], 3))",
    "solution": "from collections import deque\n\ndef max_sliding_window(nums, k):\n    result = []\n    dq = deque()  # Store indices, maintain decreasing order of values\n    \n    for i, num in enumerate(nums):\n        # Remove indices outside window\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        \n        # Remove smaller elements (they can never be max)\n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Start adding to result once window is full\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n\nprint(max_sliding_window([1,3,-1,-3,5,3,6,7], 3))",
    "testCases": [],
    "hints": [
      "Use deque to store indices, not values",
      "Keep deque in decreasing order of values",
      "Front of deque is always current max"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Circular Queue",
    "difficulty": 3,
    "description": "Design a circular queue with fixed capacity. Implement enqueue, dequeue, front, rear, isEmpty, and isFull.",
    "starterCode": "class CircularQueue:\n    def __init__(self, k):\n        self.capacity = k\n        # Your code here\n    \n    def enqueue(self, value):\n        pass\n    \n    def dequeue(self):\n        pass\n    \n    def front(self):\n        pass\n    \n    def rear(self):\n        pass\n    \n    def is_empty(self):\n        pass\n    \n    def is_full(self):\n        pass",
    "solution": "class CircularQueue:\n    def __init__(self, k):\n        self.capacity = k\n        self.queue = [None] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n    \n    def enqueue(self, value):\n        if self.is_full():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n    \n    def dequeue(self):\n        if self.is_empty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n    \n    def front(self):\n        return -1 if self.is_empty() else self.queue[self.head]\n    \n    def rear(self):\n        return -1 if self.is_empty() else self.queue[self.tail]\n    \n    def is_empty(self):\n        return self.size == 0\n    \n    def is_full(self):\n        return self.size == self.capacity",
    "testCases": [],
    "hints": [
      "Use modulo for circular indexing",
      "Track size separately for isEmpty/isFull"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Daily Temperatures",
    "difficulty": 4,
    "description": "Given daily temperatures, return how many days you have to wait until a warmer temperature. Use a monotonic stack.",
    "starterCode": "def daily_temperatures(temperatures):\n    # Return list of days until warmer temp\n    pass\n\nprint(daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]))",
    "solution": "def daily_temperatures(temperatures):\n    n = len(temperatures)\n    result = [0] * n\n    stack = []  # Store indices\n    \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            prev_idx = stack.pop()\n            result[prev_idx] = i - prev_idx\n        stack.append(i)\n    \n    return result\n\nprint(daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]))",
    "testCases": [],
    "hints": [
      "Use monotonic decreasing stack",
      "Stack stores indices, not temperatures",
      "Pop and calculate difference when finding warmer day"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Simplify Path",
    "difficulty": 2,
    "description": "Given an absolute Unix path, simplify it. Handle \".\" (current dir), \"..\" (parent dir), multiple slashes, and trailing slashes.",
    "starterCode": "def simplify_path(path):\n    # Return canonical path\n    pass\n\nprint(simplify_path(\"/home//foo/\"))\nprint(simplify_path(\"/a/./b/../../c/\"))",
    "solution": "def simplify_path(path):\n    stack = []\n    parts = path.split(\"/\")\n    \n    for part in parts:\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        elif part and part != \".\":\n            stack.append(part)\n    \n    return \"/\" + \"/\".join(stack)\n\nprint(simplify_path(\"/home//foo/\"))\nprint(simplify_path(\"/a/./b/../../c/\"))",
    "testCases": [],
    "hints": [
      "Split path by \"/\" to get components",
      "Use stack: push directories, pop on \"..\"",
      "Ignore empty strings and \".\""
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Largest Rectangle in Histogram",
    "difficulty": 5,
    "description": "Given an array of heights representing a histogram, find the area of the largest rectangle that can be formed.",
    "starterCode": "def largest_rectangle_area(heights):\n    # Return max area\n    pass\n\nprint(largest_rectangle_area([2, 1, 5, 6, 2, 3]))",
    "solution": "def largest_rectangle_area(heights):\n    stack = []  # Store indices\n    max_area = 0\n    \n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            idx, height = stack.pop()\n            max_area = max(max_area, height * (i - idx))\n            start = idx\n        stack.append((start, h))\n    \n    # Process remaining bars\n    for idx, height in stack:\n        max_area = max(max_area, height * (len(heights) - idx))\n    \n    return max_area\n\nprint(largest_rectangle_area([2, 1, 5, 6, 2, 3]))",
    "testCases": [],
    "hints": [
      "Use monotonic increasing stack",
      "When popping, calculate area with popped height",
      "Track start index for each bar in rectangle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Basic Calculator",
    "difficulty": 4,
    "description": "Implement a basic calculator to evaluate a string expression with +, -, parentheses, and spaces. E.g., \"(1+(4+5+2)-3)+(6+8)\"",
    "starterCode": "def calculate(s):\n    # Return result\n    pass\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))",
    "solution": "def calculate(s):\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n    \n    for char in s:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == \"+\":\n            result += sign * num\n            num = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * num\n            num = 0\n            sign = -1\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * num\n            num = 0\n            result *= stack.pop()  # sign before parenthesis\n            result += stack.pop()  # result before parenthesis\n    \n    return result + sign * num\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))",
    "testCases": [],
    "hints": [
      "Track current number, sign, and running result",
      "On \"(\", push result and sign to stack",
      "On \")\", apply saved sign and add to saved result"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Decode String",
    "difficulty": 3,
    "description": "Decode an encoded string. The encoding rule is: k[encoded_string], where k copies of encoded_string are produced. E.g., \"3[a2[c]]\" = \"accaccacc\"",
    "starterCode": "def decode_string(s):\n    # Return decoded string\n    pass\n\nprint(decode_string(\"3[a2[c]]\"))\nprint(decode_string(\"2[abc]3[cd]ef\"))",
    "solution": "def decode_string(s):\n    stack = []\n    current_string = \"\"\n    current_num = 0\n    \n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char == \"[\":\n            stack.append((current_string, current_num))\n            current_string = \"\"\n            current_num = 0\n        elif char == \"]\":\n            prev_string, num = stack.pop()\n            current_string = prev_string + current_string * num\n        else:\n            current_string += char\n    \n    return current_string\n\nprint(decode_string(\"3[a2[c]]\"))\nprint(decode_string(\"2[abc]3[cd]ef\"))",
    "testCases": [],
    "hints": [
      "Use stack to handle nested brackets",
      "On \"[\", push current string and multiplier",
      "On \"]\", pop and repeat current string"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Remove All Adjacent Duplicates",
    "difficulty": 2,
    "description": "Remove all adjacent duplicates in a string repeatedly until no more duplicates exist. E.g., \"abbaca\" → \"ca\"",
    "starterCode": "def remove_duplicates(s):\n    # Return string with no adjacent duplicates\n    pass\n\nprint(remove_duplicates(\"abbaca\"))",
    "solution": "def remove_duplicates(s):\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return \"\".join(stack)\n\nprint(remove_duplicates(\"abbaca\"))",
    "testCases": [],
    "hints": [
      "Use a stack to build result",
      "If top of stack matches current char, pop",
      "Otherwise push current char"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Next Greater Element",
    "difficulty": 3,
    "description": "Given a circular array, return the next greater element for each element. The next greater element is the first greater number to its right (wrapping around).",
    "starterCode": "def next_greater_elements(nums):\n    # Return list where result[i] is next greater element, or -1\n    pass\n\nprint(next_greater_elements([1, 2, 1]))",
    "solution": "def next_greater_elements(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []  # Store indices\n    \n    # Process array twice for circular behavior\n    for i in range(2 * n):\n        idx = i % n\n        while stack and nums[stack[-1]] < nums[idx]:\n            result[stack.pop()] = nums[idx]\n        if i < n:\n            stack.append(idx)\n    \n    return result\n\nprint(next_greater_elements([1, 2, 1]))",
    "testCases": [],
    "hints": [
      "Use monotonic decreasing stack",
      "Process array twice for circular behavior",
      "Only push indices in first pass"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Implement Deque",
    "difficulty": 2,
    "description": "Implement a double-ended queue with append_left, append_right, pop_left, pop_right operations. All should be O(1).",
    "starterCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass Deque:\n    def __init__(self):\n        pass\n    \n    def append_left(self, value):\n        pass\n    \n    def append_right(self, value):\n        pass\n    \n    def pop_left(self):\n        pass\n    \n    def pop_right(self):\n        pass\n    \n    def is_empty(self):\n        pass",
    "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass Deque:\n    def __init__(self):\n        self.head = Node(0)  # Dummy head\n        self.tail = Node(0)  # Dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n    \n    def append_left(self, value):\n        node = Node(value)\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n        self.size += 1\n    \n    def append_right(self, value):\n        node = Node(value)\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n        self.size += 1\n    \n    def pop_left(self):\n        if self.is_empty():\n            return None\n        node = self.head.next\n        self.head.next = node.next\n        node.next.prev = self.head\n        self.size -= 1\n        return node.value\n    \n    def pop_right(self):\n        if self.is_empty():\n            return None\n        node = self.tail.prev\n        self.tail.prev = node.prev\n        node.prev.next = self.tail\n        self.size -= 1\n        return node.value\n    \n    def is_empty(self):\n        return self.size == 0",
    "testCases": [],
    "hints": [
      "Use doubly linked list with dummy head and tail",
      "Dummy nodes eliminate edge cases",
      "Track size for O(1) isEmpty check"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t2-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-2",
    "title": "Asteroid Collision",
    "difficulty": 3,
    "description": "Given an array of asteroids where positive means moving right and negative means moving left, simulate collisions. When two asteroids meet, the smaller one explodes. Same size = both explode.",
    "starterCode": "def asteroid_collision(asteroids):\n    # Return surviving asteroids\n    pass\n\nprint(asteroid_collision([5, 10, -5]))\nprint(asteroid_collision([8, -8]))\nprint(asteroid_collision([10, 2, -5]))",
    "solution": "def asteroid_collision(asteroids):\n    stack = []\n    \n    for asteroid in asteroids:\n        # Handle collision: only when stack has positive and current is negative\n        while stack and stack[-1] > 0 and asteroid < 0:\n            if stack[-1] < -asteroid:\n                stack.pop()\n                continue\n            elif stack[-1] == -asteroid:\n                stack.pop()\n            break\n        else:\n            stack.append(asteroid)\n    \n    return stack\n\nprint(asteroid_collision([5, 10, -5]))\nprint(asteroid_collision([8, -8]))\nprint(asteroid_collision([10, 2, -5]))",
    "testCases": [],
    "hints": [
      "Collision only when positive asteroid meets negative",
      "Use stack to track surviving asteroids",
      "Handle all three cases: first wins, second wins, both explode"
    ],
    "language": "python"
  },
  {
    "id": "cs104-exercise-3",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Binary Search Tree Validation",
    "difficulty": 3,
    "description": "Write a function to determine if a binary tree is a valid Binary Search Tree. A valid BST has all left descendants less than the node, and all right descendants greater than the node.",
    "language": "python",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "Use a helper function that tracks the valid range for each node",
      "For each node, update the min and max constraints for its children",
      "All nodes in left subtree must be less than current, not just the immediate child"
    ],
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.value <= min_val or node.value >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.value) and\n                validate(node.right, node.value, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))"
  },
  {
    "id": "cs104-t3-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Inorder Traversal",
    "difficulty": 1,
    "description": "Implement inorder traversal of a binary tree. Return the values as a list.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef inorder(root):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef inorder(root):\n    result = []\n    def traverse(node):\n        if node:\n            traverse(node.left)\n            result.append(node.value)\n            traverse(node.right)\n    traverse(root)\n    return result",
    "testCases": [],
    "hints": [
      "Inorder: left, root, right",
      "Use recursion or a stack"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Maximum Depth of Binary Tree",
    "difficulty": 1,
    "description": "Find the maximum depth (height) of a binary tree. The depth is the number of nodes along the longest path from root to leaf.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef max_depth(root):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef max_depth(root):\n    if not root:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))",
    "testCases": [],
    "hints": [
      "Base case: empty tree has depth 0",
      "Depth = 1 + max(left depth, right depth)"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Level Order Traversal",
    "difficulty": 2,
    "description": "Return the level order (BFS) traversal of a binary tree as a list of lists, where each inner list contains values at that level.",
    "starterCode": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef level_order(root):\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef level_order(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.value)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    \n    return result",
    "testCases": [],
    "hints": [
      "Use a queue for BFS",
      "Track level size before processing"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "BST Insert and Search",
    "difficulty": 2,
    "description": "Implement insert and search operations for a Binary Search Tree.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, value):\n        pass\n    \n    def search(self, value):\n        # Return True if found, False otherwise\n        pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, value):\n        if not self.root:\n            self.root = TreeNode(value)\n            return\n        \n        current = self.root\n        while True:\n            if value < current.value:\n                if current.left:\n                    current = current.left\n                else:\n                    current.left = TreeNode(value)\n                    return\n            else:\n                if current.right:\n                    current = current.right\n                else:\n                    current.right = TreeNode(value)\n                    return\n    \n    def search(self, value):\n        current = self.root\n        while current:\n            if value == current.value:\n                return True\n            elif value < current.value:\n                current = current.left\n            else:\n                current = current.right\n        return False",
    "testCases": [],
    "hints": [
      "Compare value with current node to decide left or right",
      "Insert at first empty position found"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Lowest Common Ancestor (BST)",
    "difficulty": 3,
    "description": "Find the lowest common ancestor of two nodes in a BST. The LCA is the deepest node that has both p and q as descendants.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef lca_bst(root, p, q):\n    # p and q are values, not nodes\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef lca_bst(root, p, q):\n    current = root\n    while current:\n        if p < current.value and q < current.value:\n            current = current.left\n        elif p > current.value and q > current.value:\n            current = current.right\n        else:\n            return current.value\n    return None",
    "testCases": [],
    "hints": [
      "Use BST property: left < root < right",
      "If both values are smaller, go left; if both larger, go right",
      "Otherwise, current node is LCA"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Invert Binary Tree",
    "difficulty": 2,
    "description": "Invert a binary tree (mirror it). Every left child becomes right child and vice versa.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef invert_tree(root):\n    # Modify tree in-place and return root\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef invert_tree(root):\n    if not root:\n        return None\n    \n    root.left, root.right = root.right, root.left\n    invert_tree(root.left)\n    invert_tree(root.right)\n    \n    return root",
    "testCases": [],
    "hints": [
      "Swap left and right children",
      "Recursively invert subtrees"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": 5,
    "description": "Design functions to serialize a binary tree to a string and deserialize it back. Use preorder traversal with markers for null.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    # Return string representation\n    pass\n\ndef deserialize(data):\n    # Return TreeNode root\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    def helper(node):\n        if not node:\n            return [\"null\"]\n        return [str(node.value)] + helper(node.left) + helper(node.right)\n    return \",\".join(helper(root))\n\ndef deserialize(data):\n    values = iter(data.split(\",\"))\n    \n    def helper():\n        val = next(values)\n        if val == \"null\":\n            return None\n        node = TreeNode(int(val))\n        node.left = helper()\n        node.right = helper()\n        return node\n    \n    return helper()",
    "testCases": [],
    "hints": [
      "Use preorder: process root, then left, then right",
      "Use \"null\" marker for empty nodes",
      "Use iterator for deserialization"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Balanced Binary Tree",
    "difficulty": 2,
    "description": "Determine if a binary tree is height-balanced (the depth of the two subtrees of every node never differs by more than 1).",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_balanced(root):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_balanced(root):\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n        \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n        \n        if abs(left_height - right_height) > 1:\n            return -1\n        \n        return max(left_height, right_height) + 1\n    \n    return check_height(root) != -1",
    "testCases": [],
    "hints": [
      "Return -1 to indicate unbalanced subtree",
      "Check balance at each node during height calculation",
      "This is O(n) - each node visited once"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "BST Delete",
    "difficulty": 3,
    "description": "Delete a node with a given value from a BST. Return the root of the modified tree.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef delete_node(root, key):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef delete_node(root, key):\n    if not root:\n        return None\n    \n    if key < root.value:\n        root.left = delete_node(root.left, key)\n    elif key > root.value:\n        root.right = delete_node(root.right, key)\n    else:\n        # Node to delete found\n        if not root.left:\n            return root.right\n        if not root.right:\n            return root.left\n        \n        # Two children: find inorder successor\n        successor = root.right\n        while successor.left:\n            successor = successor.left\n        root.value = successor.value\n        root.right = delete_node(root.right, successor.value)\n    \n    return root",
    "testCases": [],
    "hints": [
      "Three cases: no children, one child, two children",
      "For two children, replace with inorder successor",
      "Inorder successor is smallest node in right subtree"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Path Sum",
    "difficulty": 2,
    "description": "Determine if the tree has a root-to-leaf path such that the sum of node values equals a given target.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef has_path_sum(root, target_sum):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef has_path_sum(root, target_sum):\n    if not root:\n        return False\n    \n    # Check if leaf node\n    if not root.left and not root.right:\n        return root.value == target_sum\n    \n    # Recurse on children with reduced target\n    remaining = target_sum - root.value\n    return (has_path_sum(root.left, remaining) or \n            has_path_sum(root.right, remaining))",
    "testCases": [],
    "hints": [
      "Subtract current node value from target as you go",
      "A leaf node must have exactly the remaining sum",
      "Empty tree has no paths"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Construct Binary Tree from Preorder and Inorder",
    "difficulty": 4,
    "description": "Given preorder and inorder traversals of a tree, construct the binary tree.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef build_tree(preorder, inorder):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef build_tree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    \n    # First element of preorder is root\n    root = TreeNode(preorder[0])\n    \n    # Find root in inorder to split left/right\n    mid = inorder.index(preorder[0])\n    \n    # Recursively build subtrees\n    root.left = build_tree(preorder[1:mid+1], inorder[:mid])\n    root.right = build_tree(preorder[mid+1:], inorder[mid+1:])\n    \n    return root",
    "testCases": [],
    "hints": [
      "Preorder: root is first element",
      "Inorder: elements left of root are in left subtree",
      "Use recursion with appropriate slices"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Kth Smallest Element in BST",
    "difficulty": 2,
    "description": "Return the kth smallest element in a BST (1-indexed).",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef kth_smallest(root, k):\n    # Your code here\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef kth_smallest(root, k):\n    stack = []\n    current = root\n    count = 0\n    \n    while stack or current:\n        # Go to leftmost node\n        while current:\n            stack.append(current)\n            current = current.left\n        \n        current = stack.pop()\n        count += 1\n        \n        if count == k:\n            return current.value\n        \n        current = current.right\n    \n    return None",
    "testCases": [],
    "hints": [
      "Inorder traversal of BST gives sorted order",
      "Use iterative inorder with early termination",
      "Count nodes as you traverse"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Binary Tree Right Side View",
    "difficulty": 3,
    "description": "Return the values of the nodes you can see from the right side of the tree (ordered from top to bottom).",
    "starterCode": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef right_side_view(root):\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef right_side_view(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        for i in range(level_size):\n            node = queue.popleft()\n            if i == level_size - 1:  # Last node in level\n                result.append(node.value)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    \n    return result",
    "testCases": [],
    "hints": [
      "Use level order traversal (BFS)",
      "Keep track of the last node at each level",
      "The rightmost node at each level is visible"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Flatten Binary Tree to Linked List",
    "difficulty": 3,
    "description": "Flatten a binary tree to a \"linked list\" in-place. The linked list should use the right child pointer and be in preorder.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef flatten(root):\n    # Modify tree in-place\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef flatten(root):\n    if not root:\n        return\n    \n    current = root\n    while current:\n        if current.left:\n            # Find rightmost node of left subtree\n            rightmost = current.left\n            while rightmost.right:\n                rightmost = rightmost.right\n            \n            # Connect left subtree's rightmost to current's right\n            rightmost.right = current.right\n            current.right = current.left\n            current.left = None\n        \n        current = current.right",
    "testCases": [],
    "hints": [
      "For each node with a left child, find the rightmost of left subtree",
      "Connect it to current right subtree",
      "Move left subtree to right, clear left"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t3-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-3",
    "title": "Count Complete Tree Nodes",
    "difficulty": 3,
    "description": "Count the number of nodes in a complete binary tree in better than O(n) time.",
    "starterCode": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef count_nodes(root):\n    # Your code here - try to do better than O(n)\n    pass",
    "solution": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef count_nodes(root):\n    if not root:\n        return 0\n    \n    def get_height(node, go_left):\n        height = 0\n        while node:\n            height += 1\n            node = node.left if go_left else node.right\n        return height\n    \n    left_height = get_height(root, True)\n    right_height = get_height(root, False)\n    \n    if left_height == right_height:\n        # Perfect tree: 2^h - 1 nodes\n        return (1 << left_height) - 1\n    else:\n        # Recurse on subtrees\n        return 1 + count_nodes(root.left) + count_nodes(root.right)",
    "testCases": [],
    "hints": [
      "A complete tree has either a perfect left or right subtree",
      "Compare left and right heights (always going left/right)",
      "If heights equal, it's perfect: 2^h - 1 nodes"
    ],
    "language": "python"
  },
  {
    "id": "cs104-exercise-4",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "First Unique Character",
    "difficulty": 2,
    "description": "Given a string, find the first non-repeating character and return its index. If all characters repeat, return -1. Use a hash table for an efficient solution.",
    "language": "python",
    "starterCode": "def first_unique_char(s):\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "First pass: count the frequency of each character using a hash map",
      "Second pass: find the first character with frequency 1",
      "Python dictionaries maintain insertion order (Python 3.7+)"
    ],
    "solution": "def first_unique_char(s):\n    char_count = {}\n    \n    # Count frequency of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count 1\n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    \n    return -1"
  },
  {
    "id": "cs104-t4-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Two Sum",
    "difficulty": 1,
    "description": "Given an array of integers and a target sum, return indices of two numbers that add up to target. Use a hash map for O(n) solution.",
    "starterCode": "def two_sum(nums, target):\n    # Return [i, j] where nums[i] + nums[j] == target\n    pass\n\nprint(two_sum([2, 7, 11, 15], 9))",
    "solution": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\nprint(two_sum([2, 7, 11, 15], 9))",
    "testCases": [],
    "hints": [
      "Store each number and its index in hash map",
      "For each number, check if (target - number) exists in map"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Group Anagrams",
    "difficulty": 2,
    "description": "Given an array of strings, group the anagrams together. Two strings are anagrams if they contain the same characters.",
    "starterCode": "def group_anagrams(strs):\n    # Return list of lists grouping anagrams\n    pass\n\nprint(group_anagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]))",
    "solution": "def group_anagrams(strs):\n    groups = {}\n    for s in strs:\n        key = tuple(sorted(s))\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(s)\n    return list(groups.values())\n\nprint(group_anagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]))",
    "testCases": [],
    "hints": [
      "Anagrams have the same sorted character sequence",
      "Use sorted string as hash key"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Implement Hash Map",
    "difficulty": 3,
    "description": "Implement a basic hash map with put, get, and remove operations. Handle collisions using chaining.",
    "starterCode": "class HashMap:\n    def __init__(self, size=1000):\n        self.size = size\n        self.buckets = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        pass\n    \n    def get(self, key):\n        # Return None if not found\n        pass\n    \n    def remove(self, key):\n        pass",
    "solution": "class HashMap:\n    def __init__(self, size=1000):\n        self.size = size\n        self.buckets = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        bucket_idx = self._hash(key)\n        bucket = self.buckets[bucket_idx]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n    \n    def get(self, key):\n        bucket_idx = self._hash(key)\n        bucket = self.buckets[bucket_idx]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return None\n    \n    def remove(self, key):\n        bucket_idx = self._hash(key)\n        bucket = self.buckets[bucket_idx]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                del bucket[i]\n                return",
    "testCases": [],
    "hints": [
      "Each bucket is a list of (key, value) pairs",
      "Check for existing key before inserting"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Subarray Sum Equals K",
    "difficulty": 3,
    "description": "Given an array and integer k, find the total number of continuous subarrays whose sum equals k.",
    "starterCode": "def subarray_sum(nums, k):\n    # Return count of subarrays with sum k\n    pass\n\nprint(subarray_sum([1, 1, 1], 2))",
    "solution": "def subarray_sum(nums, k):\n    count = 0\n    prefix_sum = 0\n    sum_counts = {0: 1}  # sum -> count of occurrences\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in sum_counts:\n            count += sum_counts[prefix_sum - k]\n        sum_counts[prefix_sum] = sum_counts.get(prefix_sum, 0) + 1\n    \n    return count\n\nprint(subarray_sum([1, 1, 1], 2))",
    "testCases": [],
    "hints": [
      "Use prefix sum technique",
      "If prefix[j] - prefix[i] = k, subarray i+1 to j sums to k",
      "Store count of each prefix sum in hash map"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Longest Consecutive Sequence",
    "difficulty": 4,
    "description": "Given an unsorted array, find the length of the longest consecutive elements sequence. Must run in O(n) time.",
    "starterCode": "def longest_consecutive(nums):\n    # Return length of longest consecutive sequence\n    pass\n\nprint(longest_consecutive([100, 4, 200, 1, 3, 2]))",
    "solution": "def longest_consecutive(nums):\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        # Only start counting from sequence start\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            \n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            \n            longest = max(longest, length)\n    \n    return longest\n\nprint(longest_consecutive([100, 4, 200, 1, 3, 2]))",
    "testCases": [],
    "hints": [
      "Convert to set for O(1) lookup",
      "Only start counting when num-1 is not in set",
      "This ensures each number is processed at most twice"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Contains Duplicate II",
    "difficulty": 2,
    "description": "Given an array and integer k, check if there are two distinct indices i and j such that nums[i] == nums[j] and |i - j| <= k.",
    "starterCode": "def contains_nearby_duplicate(nums, k):\n    pass\n\nprint(contains_nearby_duplicate([1, 2, 3, 1], 3))\nprint(contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2))",
    "solution": "def contains_nearby_duplicate(nums, k):\n    last_seen = {}\n    for i, num in enumerate(nums):\n        if num in last_seen and i - last_seen[num] <= k:\n            return True\n        last_seen[num] = i\n    return False\n\nprint(contains_nearby_duplicate([1, 2, 3, 1], 3))\nprint(contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2))",
    "testCases": [],
    "hints": [
      "Store last seen index of each number",
      "Check distance when duplicate found"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Design Twitter",
    "difficulty": 5,
    "description": "Design a simplified Twitter with postTweet, getNewsFeed (10 most recent from followed users), follow, and unfollow.",
    "starterCode": "class Twitter:\n    def __init__(self):\n        pass\n    \n    def post_tweet(self, user_id, tweet_id):\n        pass\n    \n    def get_news_feed(self, user_id):\n        # Return 10 most recent tweet IDs\n        pass\n    \n    def follow(self, follower_id, followee_id):\n        pass\n    \n    def unfollow(self, follower_id, followee_id):\n        pass",
    "solution": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)  # user_id -> [(time, tweet_id)]\n        self.following = defaultdict(set)  # user_id -> set of followed user_ids\n    \n    def post_tweet(self, user_id, tweet_id):\n        self.tweets[user_id].append((self.time, tweet_id))\n        self.time += 1\n    \n    def get_news_feed(self, user_id):\n        # Get tweets from user and all followed users\n        users = self.following[user_id] | {user_id}\n        heap = []\n        \n        for uid in users:\n            for tweet in self.tweets[uid]:\n                heapq.heappush(heap, (-tweet[0], tweet[1]))\n        \n        feed = []\n        while heap and len(feed) < 10:\n            feed.append(heapq.heappop(heap)[1])\n        return feed\n    \n    def follow(self, follower_id, followee_id):\n        if follower_id != followee_id:\n            self.following[follower_id].add(followee_id)\n    \n    def unfollow(self, follower_id, followee_id):\n        self.following[follower_id].discard(followee_id)",
    "testCases": [],
    "hints": [
      "Use timestamp for ordering tweets",
      "Store following as a set per user",
      "Use heap to get top 10 most recent"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Valid Anagram",
    "difficulty": 1,
    "description": "Determine if two strings are anagrams (contain the same characters with the same frequencies).",
    "starterCode": "def is_anagram(s, t):\n    # Your code here\n    pass\n\nprint(is_anagram(\"anagram\", \"nagaram\"))\nprint(is_anagram(\"rat\", \"car\"))",
    "solution": "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    \n    for char in t:\n        if char not in count:\n            return False\n        count[char] -= 1\n        if count[char] < 0:\n            return False\n    \n    return True\n\nprint(is_anagram(\"anagram\", \"nagaram\"))\nprint(is_anagram(\"rat\", \"car\"))",
    "testCases": [],
    "hints": [
      "Count character frequencies in first string",
      "Decrement counts while iterating second string",
      "Early return if character missing or count goes negative"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Isomorphic Strings",
    "difficulty": 2,
    "description": "Two strings are isomorphic if characters in s can be replaced to get t (no two characters may map to same character, order preserved). Check if two strings are isomorphic.",
    "starterCode": "def is_isomorphic(s, t):\n    # Your code here\n    pass\n\nprint(is_isomorphic(\"egg\", \"add\"))\nprint(is_isomorphic(\"foo\", \"bar\"))\nprint(is_isomorphic(\"paper\", \"title\"))",
    "solution": "def is_isomorphic(s, t):\n    if len(s) != len(t):\n        return False\n    \n    s_to_t = {}\n    t_to_s = {}\n    \n    for c1, c2 in zip(s, t):\n        if c1 in s_to_t:\n            if s_to_t[c1] != c2:\n                return False\n        else:\n            s_to_t[c1] = c2\n        \n        if c2 in t_to_s:\n            if t_to_s[c2] != c1:\n                return False\n        else:\n            t_to_s[c2] = c1\n    \n    return True\n\nprint(is_isomorphic(\"egg\", \"add\"))\nprint(is_isomorphic(\"foo\", \"bar\"))\nprint(is_isomorphic(\"paper\", \"title\"))",
    "testCases": [],
    "hints": [
      "Need bidirectional mapping: s->t and t->s",
      "Check consistency in both directions",
      "No character can map to two different characters"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Word Pattern",
    "difficulty": 2,
    "description": "Check if a pattern matches a string. Pattern \"abba\" matches \"dog cat cat dog\" but not \"dog cat cat fish\".",
    "starterCode": "def word_pattern(pattern, s):\n    # Your code here\n    pass\n\nprint(word_pattern(\"abba\", \"dog cat cat dog\"))\nprint(word_pattern(\"abba\", \"dog cat cat fish\"))",
    "solution": "def word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            char_to_word[char] = word\n        \n        if word in word_to_char:\n            if word_to_char[word] != char:\n                return False\n        else:\n            word_to_char[word] = char\n    \n    return True\n\nprint(word_pattern(\"abba\", \"dog cat cat dog\"))\nprint(word_pattern(\"abba\", \"dog cat cat fish\"))",
    "testCases": [],
    "hints": [
      "Similar to isomorphic strings",
      "Map pattern characters to words bidirectionally",
      "Split string into words first"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Find All Duplicates",
    "difficulty": 2,
    "description": "Given an array of n integers where 1 ≤ a[i] ≤ n, some elements appear twice and others appear once. Find all duplicates without extra space and in O(n) time.",
    "starterCode": "def find_duplicates(nums):\n    # Return list of duplicates\n    pass\n\nprint(find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]))",
    "solution": "def find_duplicates(nums):\n    result = []\n    \n    for num in nums:\n        idx = abs(num) - 1\n        if nums[idx] < 0:\n            result.append(abs(num))\n        else:\n            nums[idx] = -nums[idx]\n    \n    return result\n\nprint(find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]))",
    "testCases": [],
    "hints": [
      "Use array itself as hash table",
      "Mark visited by negating value at index nums[i]-1",
      "If already negative, we found a duplicate"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Top K Frequent Elements",
    "difficulty": 3,
    "description": "Given an integer array and k, return the k most frequent elements. You may return the answer in any order.",
    "starterCode": "def top_k_frequent(nums, k):\n    # Return list of k most frequent elements\n    pass\n\nprint(top_k_frequent([1,1,1,2,2,3], 2))",
    "solution": "from collections import Counter\n\ndef top_k_frequent(nums, k):\n    # Count frequencies\n    count = Counter(nums)\n    \n    # Bucket sort: index = frequency, value = list of nums with that frequency\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    # Collect k most frequent from end\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    \n    return result\n\nprint(top_k_frequent([1,1,1,2,2,3], 2))",
    "testCases": [],
    "hints": [
      "First count frequencies with hash map",
      "Use bucket sort by frequency for O(n)",
      "Alternative: use heap for O(n log k)"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Minimum Window Substring",
    "difficulty": 5,
    "description": "Given strings s and t, return the minimum window substring of s that contains all characters of t. Return \"\" if no such window exists.",
    "starterCode": "def min_window(s, t):\n    # Return minimum window or \"\"\n    pass\n\nprint(min_window(\"ADOBECODEBANC\", \"ABC\"))",
    "solution": "from collections import Counter\n\ndef min_window(s, t):\n    if not t or not s:\n        return \"\"\n    \n    t_count = Counter(t)\n    required = len(t_count)\n    \n    left = 0\n    formed = 0\n    window_counts = {}\n    \n    min_len = float(\"inf\")\n    min_left = 0\n    \n    for right, char in enumerate(s):\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        if char in t_count and window_counts[char] == t_count[char]:\n            formed += 1\n        \n        while formed == required and left <= right:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            left_char = s[left]\n            window_counts[left_char] -= 1\n            if left_char in t_count and window_counts[left_char] < t_count[left_char]:\n                formed -= 1\n            left += 1\n    \n    return \"\" if min_len == float(\"inf\") else s[min_left:min_left + min_len]\n\nprint(min_window(\"ADOBECODEBANC\", \"ABC\"))",
    "testCases": [],
    "hints": [
      "Use sliding window with two pointers",
      "Expand right to include all chars, contract left to minimize",
      "Track how many required chars are satisfied"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "Insert Delete GetRandom O(1)",
    "difficulty": 3,
    "description": "Design a data structure that supports insert, remove, and getRandom in O(1) average time. getRandom should return a random element with equal probability.",
    "starterCode": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        pass\n    \n    def insert(self, val):\n        # Return True if val was not present\n        pass\n    \n    def remove(self, val):\n        # Return True if val was present\n        pass\n    \n    def get_random(self):\n        # Return random element\n        pass",
    "solution": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_idx = {}  # value -> index in list\n        self.values = []      # list of values\n    \n    def insert(self, val):\n        if val in self.val_to_idx:\n            return False\n        self.val_to_idx[val] = len(self.values)\n        self.values.append(val)\n        return True\n    \n    def remove(self, val):\n        if val not in self.val_to_idx:\n            return False\n        \n        # Swap with last element\n        idx = self.val_to_idx[val]\n        last_val = self.values[-1]\n        \n        self.values[idx] = last_val\n        self.val_to_idx[last_val] = idx\n        \n        self.values.pop()\n        del self.val_to_idx[val]\n        return True\n    \n    def get_random(self):\n        return random.choice(self.values)",
    "testCases": [],
    "hints": [
      "Use hash map for O(1) lookup + array for O(1) random access",
      "To remove, swap element with last and pop",
      "Update hash map when swapping"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t4-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-4",
    "title": "LFU Cache",
    "difficulty": 5,
    "description": "Design and implement an LFU (Least Frequently Used) cache. When capacity is reached, remove the least frequently used item (use LRU among same frequency). Support get and put in O(1).",
    "starterCode": "class LFUCache:\n    def __init__(self, capacity):\n        pass\n    \n    def get(self, key):\n        # Return value or -1 if not found\n        pass\n    \n    def put(self, key, value):\n        # Insert/update key-value pair\n        pass",
    "solution": "from collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.key_to_val = {}           # key -> value\n        self.key_to_freq = {}          # key -> frequency\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n        self.min_freq = 0\n    \n    def _update_freq(self, key):\n        freq = self.key_to_freq[key]\n        self.key_to_freq[key] = freq + 1\n        \n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        \n        self.freq_to_keys[freq + 1][key] = None\n    \n    def get(self, key):\n        if key not in self.key_to_val:\n            return -1\n        self._update_freq(key)\n        return self.key_to_val[key]\n    \n    def put(self, key, value):\n        if self.capacity <= 0:\n            return\n        \n        if key in self.key_to_val:\n            self.key_to_val[key] = value\n            self._update_freq(key)\n            return\n        \n        if len(self.key_to_val) >= self.capacity:\n            # Evict least frequent, least recent\n            lfu_key = next(iter(self.freq_to_keys[self.min_freq]))\n            del self.freq_to_keys[self.min_freq][lfu_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n            del self.key_to_val[lfu_key]\n            del self.key_to_freq[lfu_key]\n        \n        self.key_to_val[key] = value\n        self.key_to_freq[key] = 1\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1",
    "testCases": [],
    "hints": [
      "Track frequency per key and keys per frequency",
      "Use OrderedDict for LRU among same frequency",
      "Track min_freq for O(1) eviction"
    ],
    "language": "python"
  },
  {
    "id": "cs104-exercise-5",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Course Schedule (Graph Cycle Detection)",
    "difficulty": 3,
    "description": "Given a number of courses and their prerequisites, determine if it's possible to complete all courses. This is a cycle detection problem in a directed graph.",
    "language": "python",
    "starterCode": "def can_finish(num_courses, prerequisites):\n    # prerequisites is a list of [course, prerequisite] pairs\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "Build an adjacency list to represent the graph",
      "Use DFS with a visited state tracking: unvisited, visiting, visited",
      "If you encounter a node in \"visiting\" state, a cycle exists"
    ],
    "solution": "def can_finish(num_courses, prerequisites):\n    # Build adjacency list\n    graph = {i: [] for i in range(num_courses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # 0 = unvisited, 1 = visiting, 2 = visited\n    state = [0] * num_courses\n    \n    def has_cycle(course):\n        if state[course] == 1:  # Currently visiting - cycle detected\n            return True\n        if state[course] == 2:  # Already visited\n            return False\n        \n        state[course] = 1  # Mark as visiting\n        for prereq in graph[course]:\n            if has_cycle(prereq):\n                return True\n        state[course] = 2  # Mark as visited\n        return False\n    \n    for course in range(num_courses):\n        if has_cycle(course):\n            return False\n    \n    return True"
  },
  {
    "id": "cs104-t5-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "BFS - Shortest Path in Unweighted Graph",
    "difficulty": 2,
    "description": "Find the shortest path between two nodes in an unweighted graph using BFS. Return the path length, or -1 if no path exists.",
    "starterCode": "from collections import deque\n\ndef shortest_path(graph, start, end):\n    # graph is adjacency list: {node: [neighbors]}\n    pass\n\ngraph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}\nprint(shortest_path(graph, 0, 4))",
    "solution": "from collections import deque\n\ndef shortest_path(graph, start, end):\n    if start == end:\n        return 0\n    \n    visited = {start}\n    queue = deque([(start, 0)])\n    \n    while queue:\n        node, distance = queue.popleft()\n        for neighbor in graph.get(node, []):\n            if neighbor == end:\n                return distance + 1\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, distance + 1))\n    \n    return -1\n\ngraph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3]}\nprint(shortest_path(graph, 0, 4))",
    "testCases": [],
    "hints": [
      "BFS finds shortest path in unweighted graphs",
      "Track visited nodes to avoid cycles",
      "Store distance with each node in queue"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "DFS - Count Connected Components",
    "difficulty": 2,
    "description": "Count the number of connected components in an undirected graph.",
    "starterCode": "def count_components(n, edges):\n    # n is number of nodes (0 to n-1)\n    # edges is list of [a, b] pairs\n    pass\n\nprint(count_components(5, [[0,1], [1,2], [3,4]]))",
    "solution": "def count_components(n, edges):\n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    visited = set()\n    count = 0\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    for node in range(n):\n        if node not in visited:\n            dfs(node)\n            count += 1\n    \n    return count\n\nprint(count_components(5, [[0,1], [1,2], [3,4]]))",
    "testCases": [],
    "hints": [
      "Build undirected adjacency list (add both directions)",
      "DFS from each unvisited node starts a new component"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Clone Graph",
    "difficulty": 3,
    "description": "Given a reference to a node in a connected undirected graph, return a deep copy. Each node has a value and list of neighbors.",
    "starterCode": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors else []\n\ndef clone_graph(node):\n    # Return deep copy of graph\n    pass",
    "solution": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors else []\n\ndef clone_graph(node):\n    if not node:\n        return None\n    \n    cloned = {}  # original node -> cloned node\n    \n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n        \n        copy = Node(node.val)\n        cloned[node] = copy\n        \n        for neighbor in node.neighbors:\n            copy.neighbors.append(dfs(neighbor))\n        \n        return copy\n    \n    return dfs(node)",
    "testCases": [],
    "hints": [
      "Use hash map to track original -> clone mapping",
      "DFS to traverse and clone each node",
      "Check if already cloned before creating new node"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Topological Sort",
    "difficulty": 3,
    "description": "Perform topological sort on a directed acyclic graph. Return a valid ordering, or empty list if graph has a cycle.",
    "starterCode": "def topological_sort(n, edges):\n    # n nodes (0 to n-1), edges are [from, to] pairs\n    # Return list in topological order\n    pass\n\nprint(topological_sort(4, [[0,1], [0,2], [1,3], [2,3]]))",
    "solution": "from collections import deque\n\ndef topological_sort(n, edges):\n    # Build graph and count in-degrees\n    graph = {i: [] for i in range(n)}\n    in_degree = [0] * n\n    \n    for a, b in edges:\n        graph[a].append(b)\n        in_degree[b] += 1\n    \n    # Start with nodes having 0 in-degree\n    queue = deque([i for i in range(n) if in_degree[i] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == n else []\n\nprint(topological_sort(4, [[0,1], [0,2], [1,3], [2,3]]))",
    "testCases": [],
    "hints": [
      "Use Kahn's algorithm with in-degree counting",
      "Start with nodes having in-degree 0",
      "If result length != n, there was a cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Dijkstra's Shortest Path",
    "difficulty": 4,
    "description": "Implement Dijkstra's algorithm to find the shortest path from a source to all other nodes in a weighted graph.",
    "starterCode": "import heapq\n\ndef dijkstra(graph, start):\n    # graph: {node: [(neighbor, weight), ...]}\n    # Return dict of shortest distances from start\n    pass\n\ngraph = {\n    0: [(1, 4), (2, 1)],\n    1: [(3, 1)],\n    2: [(1, 2), (3, 5)],\n    3: []\n}\nprint(dijkstra(graph, 0))",
    "solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    heap = [(0, start)]  # (distance, node)\n    \n    while heap:\n        dist, node = heapq.heappop(heap)\n        \n        if dist > distances[node]:\n            continue\n        \n        for neighbor, weight in graph.get(node, []):\n            new_dist = dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n    \n    return distances\n\ngraph = {\n    0: [(1, 4), (2, 1)],\n    1: [(3, 1)],\n    2: [(1, 2), (3, 5)],\n    3: []\n}\nprint(dijkstra(graph, 0))",
    "testCases": [],
    "hints": [
      "Use min heap for efficiency",
      "Skip if we've found a shorter path already",
      "Update distance if new path is shorter"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Number of Islands",
    "difficulty": 2,
    "description": "Given a 2D grid of \"1\"s (land) and \"0\"s (water), count the number of islands. An island is surrounded by water and formed by connecting adjacent lands.",
    "starterCode": "def num_islands(grid):\n    # grid is list of lists of \"0\" and \"1\"\n    pass\n\ngrid = [\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nprint(num_islands(grid))",
    "solution": "def num_islands(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == \"0\":\n            return\n        grid[r][c] = \"0\"  # Mark as visited\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                count += 1\n    \n    return count\n\ngrid = [\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nprint(num_islands(grid))",
    "testCases": [],
    "hints": [
      "Use DFS/BFS to explore each island",
      "Mark visited cells to avoid counting twice",
      "Each DFS from a new \"1\" is a new island"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Minimum Spanning Tree (Prim's)",
    "difficulty": 5,
    "description": "Implement Prim's algorithm to find the minimum spanning tree of a weighted undirected graph. Return the total weight.",
    "starterCode": "import heapq\n\ndef prim_mst(n, edges):\n    # n nodes (0 to n-1)\n    # edges: [[a, b, weight], ...]\n    # Return total weight of MST\n    pass\n\nprint(prim_mst(4, [[0,1,1], [0,2,4], [1,2,2], [1,3,6], [2,3,3]]))",
    "solution": "import heapq\n\ndef prim_mst(n, edges):\n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b, w in edges:\n        graph[a].append((w, b))\n        graph[b].append((w, a))\n    \n    visited = set()\n    heap = [(0, 0)]  # (weight, node), start from node 0\n    total_weight = 0\n    \n    while heap and len(visited) < n:\n        weight, node = heapq.heappop(heap)\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        total_weight += weight\n        \n        for edge_weight, neighbor in graph[node]:\n            if neighbor not in visited:\n                heapq.heappush(heap, (edge_weight, neighbor))\n    \n    return total_weight if len(visited) == n else -1\n\nprint(prim_mst(4, [[0,1,1], [0,2,4], [1,2,2], [1,3,6], [2,3,3]]))",
    "testCases": [],
    "hints": [
      "Use min heap to always pick minimum weight edge",
      "Start from any node, greedily add cheapest edge to unvisited node",
      "MST has n-1 edges for n nodes"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Pacific Atlantic Water Flow",
    "difficulty": 3,
    "description": "Given an m x n matrix of heights, water can flow to adjacent cells with equal or lower height. Find all cells that can reach both the Pacific Ocean (left/top) and Atlantic Ocean (right/bottom).",
    "starterCode": "def pacific_atlantic(heights):\n    # Return list of [row, col] coordinates\n    pass\n\nheights = [\n    [1,2,2,3,5],\n    [3,2,3,4,4],\n    [2,4,5,3,1],\n    [6,7,1,4,5],\n    [5,1,1,2,4]\n]\nprint(pacific_atlantic(heights))",
    "solution": "def pacific_atlantic(heights):\n    if not heights:\n        return []\n    \n    rows, cols = len(heights), len(heights[0])\n    pacific = set()\n    atlantic = set()\n    \n    def dfs(r, c, visited, prev_height):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if heights[r][c] < prev_height:\n            return\n        \n        visited.add((r, c))\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            dfs(r + dr, c + dc, visited, heights[r][c])\n    \n    # Start DFS from ocean borders\n    for c in range(cols):\n        dfs(0, c, pacific, heights[0][c])         # Top (Pacific)\n        dfs(rows-1, c, atlantic, heights[rows-1][c])  # Bottom (Atlantic)\n    \n    for r in range(rows):\n        dfs(r, 0, pacific, heights[r][0])         # Left (Pacific)\n        dfs(r, cols-1, atlantic, heights[r][cols-1])  # Right (Atlantic)\n    \n    return [[r, c] for r, c in pacific & atlantic]\n\nheights = [\n    [1,2,2,3,5],\n    [3,2,3,4,4],\n    [2,4,5,3,1],\n    [6,7,1,4,5],\n    [5,1,1,2,4]\n]\nprint(pacific_atlantic(heights))",
    "testCases": [],
    "hints": [
      "Think backwards: find cells reachable FROM the oceans",
      "DFS from ocean borders going uphill",
      "Answer is intersection of cells reaching both oceans"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Word Ladder",
    "difficulty": 4,
    "description": "Given begin word, end word, and a word list, find length of shortest transformation sequence where each transformed word must exist in word list and only one letter changes at a time.",
    "starterCode": "from collections import deque\n\ndef ladder_length(begin_word, end_word, word_list):\n    # Return length of shortest transformation, or 0 if impossible\n    pass\n\nprint(ladder_length(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))",
    "solution": "from collections import deque, defaultdict\n\ndef ladder_length(begin_word, end_word, word_list):\n    if end_word not in word_list:\n        return 0\n    \n    word_set = set(word_list)\n    word_len = len(begin_word)\n    \n    # Build pattern graph: h*t -> [hit, hot]\n    patterns = defaultdict(list)\n    for word in word_set:\n        for i in range(word_len):\n            pattern = word[:i] + \"*\" + word[i+1:]\n            patterns[pattern].append(word)\n    \n    queue = deque([(begin_word, 1)])\n    visited = {begin_word}\n    \n    while queue:\n        word, length = queue.popleft()\n        \n        for i in range(word_len):\n            pattern = word[:i] + \"*\" + word[i+1:]\n            for neighbor in patterns[pattern]:\n                if neighbor == end_word:\n                    return length + 1\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1))\n    \n    return 0\n\nprint(ladder_length(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))",
    "testCases": [],
    "hints": [
      "Model as graph: words are nodes, edges connect words differing by one letter",
      "Use BFS for shortest path",
      "Use wildcard patterns for efficient neighbor finding"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Surrounded Regions",
    "difficulty": 3,
    "description": "Given an m x n board containing \"X\" and \"O\", capture all regions surrounded by \"X\". A region is captured by flipping all \"O\"s to \"X\"s. \"O\"s on the border are not captured.",
    "starterCode": "def solve(board):\n    # Modify board in-place\n    pass\n\nboard = [\n    [\"X\",\"X\",\"X\",\"X\"],\n    [\"X\",\"O\",\"O\",\"X\"],\n    [\"X\",\"X\",\"O\",\"X\"],\n    [\"X\",\"O\",\"X\",\"X\"]\n]\nsolve(board)\nprint(board)",
    "solution": "def solve(board):\n    if not board:\n        return\n    \n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != \"O\":\n            return\n        board[r][c] = \"T\"  # Temporarily mark as safe\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    \n    # Mark all Os connected to border\n    for r in range(rows):\n        dfs(r, 0)\n        dfs(r, cols-1)\n    for c in range(cols):\n        dfs(0, c)\n        dfs(rows-1, c)\n    \n    # Flip: T -> O (safe), O -> X (captured)\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n            elif board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\nboard = [\n    [\"X\",\"X\",\"X\",\"X\"],\n    [\"X\",\"O\",\"O\",\"X\"],\n    [\"X\",\"X\",\"O\",\"X\"],\n    [\"X\",\"O\",\"X\",\"X\"]\n]\nsolve(board)\nprint(board)",
    "testCases": [],
    "hints": [
      "Start from border Os - these cannot be captured",
      "Mark all Os connected to border with temporary marker",
      "Then flip: remaining Os to X, temporary back to O"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Graph Valid Tree",
    "difficulty": 3,
    "description": "Given n nodes (0 to n-1) and edges, determine if these edges form a valid tree. A valid tree has n-1 edges, is connected, and has no cycles.",
    "starterCode": "def valid_tree(n, edges):\n    # Return True if edges form a valid tree\n    pass\n\nprint(valid_tree(5, [[0,1], [0,2], [0,3], [1,4]]))\nprint(valid_tree(5, [[0,1], [1,2], [2,3], [1,3], [1,4]]))",
    "solution": "def valid_tree(n, edges):\n    if len(edges) != n - 1:\n        return False\n    \n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Check if all nodes are connected (single component)\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    dfs(0)\n    return len(visited) == n\n\nprint(valid_tree(5, [[0,1], [0,2], [0,3], [1,4]]))\nprint(valid_tree(5, [[0,1], [1,2], [2,3], [1,3], [1,4]]))",
    "testCases": [],
    "hints": [
      "A tree with n nodes has exactly n-1 edges",
      "If n-1 edges and all nodes connected, no cycles possible",
      "Check connectivity with DFS from any node"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Cheapest Flights Within K Stops",
    "difficulty": 4,
    "description": "Find cheapest price from src to dst with at most k stops. Flights given as [from, to, price]. Return -1 if no such route.",
    "starterCode": "def find_cheapest_price(n, flights, src, dst, k):\n    # Return minimum cost or -1\n    pass\n\nflights = [[0,1,100],[1,2,100],[0,2,500]]\nprint(find_cheapest_price(3, flights, 0, 2, 1))",
    "solution": "def find_cheapest_price(n, flights, src, dst, k):\n    # Bellman-Ford variant: relax edges k+1 times\n    prices = [float(\"inf\")] * n\n    prices[src] = 0\n    \n    for _ in range(k + 1):\n        temp = prices.copy()\n        for u, v, price in flights:\n            if prices[u] != float(\"inf\"):\n                temp[v] = min(temp[v], prices[u] + price)\n        prices = temp\n    \n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\nflights = [[0,1,100],[1,2,100],[0,2,500]]\nprint(find_cheapest_price(3, flights, 0, 2, 1))",
    "testCases": [],
    "hints": [
      "Modified Bellman-Ford: relax exactly k+1 times",
      "Use temp array to prevent using edges from same round",
      "Each iteration allows one more edge/stop"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Redundant Connection",
    "difficulty": 3,
    "description": "Given a graph that was originally a tree with one extra edge added, find and return the redundant edge. Return the answer that occurs last in the input.",
    "starterCode": "def find_redundant_connection(edges):\n    # Return the redundant edge [u, v]\n    pass\n\nprint(find_redundant_connection([[1,2], [1,3], [2,3]]))\nprint(find_redundant_connection([[1,2], [2,3], [3,4], [1,4], [1,5]]))",
    "solution": "def find_redundant_connection(edges):\n    parent = {}\n    \n    def find(x):\n        if x not in parent:\n            parent[x] = x\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False  # Already connected = cycle\n        parent[px] = py\n        return True\n    \n    for edge in edges:\n        if not union(edge[0], edge[1]):\n            return edge\n    \n    return []\n\nprint(find_redundant_connection([[1,2], [1,3], [2,3]]))\nprint(find_redundant_connection([[1,2], [2,3], [3,4], [1,4], [1,5]]))",
    "testCases": [],
    "hints": [
      "Use Union-Find data structure",
      "If an edge connects already-connected nodes, it creates cycle",
      "Return the first edge that creates a cycle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "Rotting Oranges",
    "difficulty": 2,
    "description": "In a grid, 0=empty, 1=fresh orange, 2=rotten. Every minute, fresh oranges adjacent to rotten become rotten. Return minutes until no fresh oranges, or -1 if impossible.",
    "starterCode": "from collections import deque\n\ndef oranges_rotting(grid):\n    # Return minutes or -1\n    pass\n\ngrid = [[2,1,1],[1,1,0],[0,1,1]]\nprint(oranges_rotting(grid))",
    "solution": "from collections import deque\n\ndef oranges_rotting(grid):\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh = 0\n    \n    # Find all rotten and count fresh\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c))\n            elif grid[r][c] == 1:\n                fresh += 1\n    \n    if fresh == 0:\n        return 0\n    \n    minutes = 0\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    \n    while queue:\n        minutes += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n    \n    return minutes - 1 if fresh == 0 else -1\n\ngrid = [[2,1,1],[1,1,0],[0,1,1]]\nprint(oranges_rotting(grid))",
    "testCases": [],
    "hints": [
      "Multi-source BFS: start from all rotten oranges",
      "Process level by level (each level = 1 minute)",
      "Track fresh count; return -1 if any remain"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t5-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-5",
    "title": "All Paths From Source to Target",
    "difficulty": 2,
    "description": "Given a directed acyclic graph (DAG) of n nodes (0 to n-1), find all paths from node 0 to node n-1. Return as list of paths.",
    "starterCode": "def all_paths_source_target(graph):\n    # graph[i] is list of nodes reachable from node i\n    # Return all paths from 0 to n-1\n    pass\n\ngraph = [[1,2],[3],[3],[]]\nprint(all_paths_source_target(graph))",
    "solution": "def all_paths_source_target(graph):\n    target = len(graph) - 1\n    result = []\n    \n    def dfs(node, path):\n        if node == target:\n            result.append(path[:])\n            return\n        \n        for neighbor in graph[node]:\n            path.append(neighbor)\n            dfs(neighbor, path)\n            path.pop()\n    \n    dfs(0, [0])\n    return result\n\ngraph = [[1,2],[3],[3],[]]\nprint(all_paths_source_target(graph))",
    "testCases": [],
    "hints": [
      "Use DFS with backtracking",
      "No need to track visited in DAG (no cycles)",
      "Copy path when reaching target"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex01",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Bubble Sort Implementation",
    "difficulty": 1,
    "description": "Implement the bubble sort algorithm. Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.",
    "starterCode": "def bubble_sort(arr):\n    # Sort arr in-place and return it\n    pass\n\nprint(bubble_sort([64, 34, 25, 12, 22, 11, 90]))",
    "solution": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n\nprint(bubble_sort([64, 34, 25, 12, 22, 11, 90]))",
    "testCases": [
      {
        "input": "[64, 34, 25, 12, 22, 11, 90]",
        "isHidden": false,
        "description": "Standard unsorted array"
      },
      {
        "input": "[5, 1, 4, 2, 8]",
        "isHidden": false,
        "description": "Small array"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      },
      {
        "input": "[1]",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "Compare adjacent elements and swap if out of order",
      "Use a flag to detect if no swaps occurred (optimization)",
      "After each pass, the largest unsorted element bubbles to its correct position"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Selection Sort Implementation",
    "difficulty": 1,
    "description": "Implement selection sort. This algorithm divides the array into sorted and unsorted regions, repeatedly finding the minimum from the unsorted region and moving it to the sorted region.",
    "starterCode": "def selection_sort(arr):\n    # Sort arr in-place and return it\n    pass\n\nprint(selection_sort([64, 25, 12, 22, 11]))",
    "solution": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\nprint(selection_sort([64, 25, 12, 22, 11]))",
    "testCases": [
      {
        "input": "[64, 25, 12, 22, 11]",
        "isHidden": false,
        "description": "Standard array"
      },
      {
        "input": "[5, 4, 3, 2, 1]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Find the minimum element in the unsorted portion",
      "Swap it with the first unsorted element",
      "Move the boundary between sorted and unsorted one position right"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Insertion Sort Implementation",
    "difficulty": 1,
    "description": "Implement insertion sort. This algorithm builds the sorted array one element at a time by inserting each element into its correct position among previously sorted elements.",
    "starterCode": "def insertion_sort(arr):\n    # Sort arr in-place and return it\n    pass\n\nprint(insertion_sort([12, 11, 13, 5, 6]))",
    "solution": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\nprint(insertion_sort([12, 11, 13, 5, 6]))",
    "testCases": [
      {
        "input": "[12, 11, 13, 5, 6]",
        "isHidden": false,
        "description": "Standard array"
      },
      {
        "input": "[4, 3, 2, 1]",
        "isHidden": false,
        "description": "Reverse sorted"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Start from the second element",
      "Compare with elements to the left and shift them right if larger",
      "Insert the key at its correct position"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Merge Sort Implementation",
    "difficulty": 2,
    "description": "Implement merge sort using the divide-and-conquer approach. Split the array in half, recursively sort each half, then merge the sorted halves.",
    "starterCode": "def merge_sort(arr):\n    # Return a new sorted array\n    pass\n\ndef merge(left, right):\n    # Merge two sorted arrays\n    pass\n\nprint(merge_sort([38, 27, 43, 3, 9, 82, 10]))",
    "solution": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\nprint(merge_sort([38, 27, 43, 3, 9, 82, 10]))",
    "testCases": [
      {
        "input": "[38, 27, 43, 3, 9, 82, 10]",
        "isHidden": false,
        "description": "Standard array"
      },
      {
        "input": "[5, 2, 8, 1]",
        "isHidden": false,
        "description": "Small array"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Base case: arrays of length 0 or 1 are already sorted",
      "Use two pointers to merge sorted arrays",
      "Merge sort is stable - maintain relative order of equal elements"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Quick Sort Implementation",
    "difficulty": 3,
    "description": "Implement quick sort with the last element as pivot. Partition the array so elements less than pivot come before it, and elements greater come after.",
    "starterCode": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    # Sort arr in-place\n    pass\n\ndef partition(arr, low, high):\n    # Return pivot index\n    pass\n\narr = [10, 7, 8, 9, 1, 5]\nquick_sort(arr)\nprint(arr)",
    "solution": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_idx = partition(arr, low, high)\n        quick_sort(arr, low, pivot_idx - 1)\n        quick_sort(arr, pivot_idx + 1, high)\n    return arr\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\narr = [10, 7, 8, 9, 1, 5]\nquick_sort(arr)\nprint(arr)",
    "testCases": [
      {
        "input": "[10, 7, 8, 9, 1, 5]",
        "isHidden": false,
        "description": "Standard array"
      },
      {
        "input": "[3, 2, 1]",
        "isHidden": false,
        "description": "Small reverse"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Choose last element as pivot",
      "i tracks the boundary of elements <= pivot",
      "Swap elements <= pivot to the left partition"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Count Inversions",
    "difficulty": 3,
    "description": "Count the number of inversions in an array. An inversion is a pair (i, j) where i < j but arr[i] > arr[j]. Use merge sort for O(n log n) solution.",
    "starterCode": "def count_inversions(arr):\n    # Return number of inversions\n    pass\n\nprint(count_inversions([2, 4, 1, 3, 5]))",
    "solution": "def count_inversions(arr):\n    def merge_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, left_inv = merge_count(arr[:mid])\n        right, right_inv = merge_count(arr[mid:])\n        merged, split_inv = merge(left, right)\n        \n        return merged, left_inv + right_inv + split_inv\n    \n    def merge(left, right):\n        result = []\n        inversions = 0\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inversions\n    \n    _, count = merge_count(arr)\n    return count\n\nprint(count_inversions([2, 4, 1, 3, 5]))",
    "testCases": [
      {
        "input": "[2, 4, 1, 3, 5]",
        "isHidden": false,
        "description": "Array with 3 inversions"
      },
      {
        "input": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "Sorted - 0 inversions"
      },
      {
        "input": "[4, 3, 2, 1]",
        "isHidden": false,
        "description": "Reverse sorted - max inversions"
      },
      {
        "input": "[1]",
        "isHidden": true,
        "description": "Single element"
      }
    ],
    "hints": [
      "Modify merge sort to count inversions during merge",
      "When taking from right array, all remaining left elements form inversions",
      "Split inversions are counted during merge"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Sort Colors (Dutch National Flag)",
    "difficulty": 2,
    "description": "Given an array with elements 0, 1, and 2, sort it in-place in one pass. This is the Dutch National Flag problem.",
    "starterCode": "def sort_colors(nums):\n    # Sort in-place\n    pass\n\nnums = [2, 0, 2, 1, 1, 0]\nsort_colors(nums)\nprint(nums)",
    "solution": "def sort_colors(nums):\n    low = 0\n    mid = 0\n    high = len(nums) - 1\n    \n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n    \n    return nums\n\nnums = [2, 0, 2, 1, 1, 0]\nsort_colors(nums)\nprint(nums)",
    "testCases": [
      {
        "input": "[2, 0, 2, 1, 1, 0]",
        "isHidden": false,
        "description": "Mixed colors"
      },
      {
        "input": "[2, 0, 1]",
        "isHidden": false,
        "description": "One of each"
      },
      {
        "input": "[0]",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "Use three pointers: low, mid, high",
      "0s go to the left (low), 2s go to the right (high)",
      "1s stay in the middle"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Kth Largest Element (Quick Select)",
    "difficulty": 3,
    "description": "Find the kth largest element in an unsorted array using the quick select algorithm (average O(n) time).",
    "starterCode": "def find_kth_largest(nums, k):\n    # Return the kth largest element\n    pass\n\nprint(find_kth_largest([3, 2, 1, 5, 6, 4], 2))",
    "solution": "def find_kth_largest(nums, k):\n    k = len(nums) - k\n    \n    def quick_select(left, right):\n        pivot = nums[right]\n        p = left\n        \n        for i in range(left, right):\n            if nums[i] <= pivot:\n                nums[p], nums[i] = nums[i], nums[p]\n                p += 1\n        \n        nums[p], nums[right] = nums[right], nums[p]\n        \n        if p == k:\n            return nums[p]\n        elif p < k:\n            return quick_select(p + 1, right)\n        else:\n            return quick_select(left, p - 1)\n    \n    return quick_select(0, len(nums) - 1)\n\nprint(find_kth_largest([3, 2, 1, 5, 6, 4], 2))",
    "testCases": [
      {
        "input": "[3, 2, 1, 5, 6, 4], 2",
        "isHidden": false,
        "description": "2nd largest in mixed array"
      },
      {
        "input": "[3, 2, 3, 1, 2, 4, 5, 5, 6], 4",
        "isHidden": false,
        "description": "4th largest with duplicates"
      },
      {
        "input": "[1], 1",
        "isHidden": false,
        "description": "Single element"
      }
    ],
    "hints": [
      "Quick select is like quick sort but only recurses into one partition",
      "Convert kth largest to kth smallest index",
      "Average O(n) but worst case O(n^2)"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Merge Sorted Arrays",
    "difficulty": 2,
    "description": "Merge two sorted arrays into one sorted array. Do not use built-in sort functions.",
    "starterCode": "def merge_sorted_arrays(arr1, arr2):\n    # Return merged sorted array\n    pass\n\nprint(merge_sorted_arrays([1, 3, 5], [2, 4, 6]))",
    "solution": "def merge_sorted_arrays(arr1, arr2):\n    result = []\n    i = j = 0\n    \n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    \n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result\n\nprint(merge_sorted_arrays([1, 3, 5], [2, 4, 6]))",
    "testCases": [
      {
        "input": "[1, 3, 5], [2, 4, 6]",
        "isHidden": false,
        "description": "Interleaved"
      },
      {
        "input": "[1, 2, 3], []",
        "isHidden": false,
        "description": "One empty"
      },
      {
        "input": "[], [1, 2]",
        "isHidden": false,
        "description": "First empty"
      },
      {
        "input": "[1, 1], [1, 1]",
        "isHidden": true,
        "description": "Duplicates"
      }
    ],
    "hints": [
      "Use two pointers, one for each array",
      "Compare elements and add the smaller one",
      "Append remaining elements from non-empty array"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Sort Array by Parity",
    "difficulty": 1,
    "description": "Given an array of integers, move all even integers to the front and all odd integers to the back.",
    "starterCode": "def sort_by_parity(nums):\n    # Return array with evens first, then odds\n    pass\n\nprint(sort_by_parity([3, 1, 2, 4]))",
    "solution": "def sort_by_parity(nums):\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        while left < right and nums[left] % 2 == 0:\n            left += 1\n        while left < right and nums[right] % 2 == 1:\n            right -= 1\n        if left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    \n    return nums\n\nprint(sort_by_parity([3, 1, 2, 4]))",
    "testCases": [
      {
        "input": "[3, 1, 2, 4]",
        "isHidden": false,
        "description": "Mixed parity"
      },
      {
        "input": "[0]",
        "isHidden": false,
        "description": "Single even"
      },
      {
        "input": "[2, 4, 6]",
        "isHidden": false,
        "description": "All even"
      },
      {
        "input": "[1, 3, 5]",
        "isHidden": true,
        "description": "All odd"
      }
    ],
    "hints": [
      "Use two pointers from both ends",
      "Move left pointer right while pointing to evens",
      "Move right pointer left while pointing to odds"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Check If Array Is Sorted",
    "difficulty": 1,
    "description": "Write a function that returns True if the array is sorted in non-decreasing order, False otherwise.",
    "starterCode": "def is_sorted(arr):\n    pass\n\nprint(is_sorted([1, 2, 3, 4]))\nprint(is_sorted([1, 3, 2, 4]))",
    "solution": "def is_sorted(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\nprint(is_sorted([1, 2, 3, 4]))\nprint(is_sorted([1, 3, 2, 4]))",
    "testCases": [
      {
        "input": "[1, 2, 3, 4]",
        "isHidden": false,
        "description": "Sorted"
      },
      {
        "input": "[1, 3, 2, 4]",
        "isHidden": false,
        "description": "Not sorted"
      },
      {
        "input": "[]",
        "isHidden": false,
        "description": "Empty"
      },
      {
        "input": "[1, 1, 1]",
        "isHidden": true,
        "description": "Equal elements"
      }
    ],
    "hints": [
      "Compare each element with the previous one",
      "If any element is smaller than its predecessor, not sorted",
      "Empty and single-element arrays are considered sorted"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Wiggle Sort",
    "difficulty": 3,
    "description": "Reorder the array such that nums[0] <= nums[1] >= nums[2] <= nums[3]... (alternating pattern).",
    "starterCode": "def wiggle_sort(nums):\n    # Reorder in-place\n    pass\n\nnums = [3, 5, 2, 1, 6, 4]\nwiggle_sort(nums)\nprint(nums)",
    "solution": "def wiggle_sort(nums):\n    for i in range(len(nums) - 1):\n        if i % 2 == 0:\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] < nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n\nnums = [3, 5, 2, 1, 6, 4]\nwiggle_sort(nums)\nprint(nums)",
    "testCases": [
      {
        "input": "[3, 5, 2, 1, 6, 4]",
        "isHidden": false,
        "description": "Standard case"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Small array"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty"
      }
    ],
    "hints": [
      "At even indices, current should be <= next",
      "At odd indices, current should be >= next",
      "Swap when the condition is violated"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Sort Characters by Frequency",
    "difficulty": 2,
    "description": "Sort a string by character frequency in descending order. Characters with equal frequency can appear in any order.",
    "starterCode": "def frequency_sort(s):\n    # Return string sorted by frequency\n    pass\n\nprint(frequency_sort(\"tree\"))",
    "solution": "def frequency_sort(s):\n    from collections import Counter\n    \n    freq = Counter(s)\n    sorted_chars = sorted(freq.keys(), key=lambda x: -freq[x])\n    \n    result = []\n    for char in sorted_chars:\n        result.append(char * freq[char])\n    \n    return \"\".join(result)\n\nprint(frequency_sort(\"tree\"))",
    "testCases": [
      {
        "input": "\"tree\"",
        "isHidden": false,
        "description": "Tree - e most frequent"
      },
      {
        "input": "\"cccaaa\"",
        "isHidden": false,
        "description": "Tied frequency"
      },
      {
        "input": "\"a\"",
        "isHidden": false,
        "description": "Single char"
      },
      {
        "input": "\"\"",
        "isHidden": true,
        "description": "Empty string"
      }
    ],
    "hints": [
      "Count frequency of each character",
      "Sort characters by their frequency (descending)",
      "Build result string by repeating each character by its frequency"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Relative Sort Array",
    "difficulty": 2,
    "description": "Sort arr1 so elements appear in the same relative order as arr2. Elements not in arr2 should be placed at the end in ascending order.",
    "starterCode": "def relative_sort(arr1, arr2):\n    pass\n\nprint(relative_sort([2,3,1,3,2,4,6,7,9,2,19], [2,1,4,3,9,6]))",
    "solution": "def relative_sort(arr1, arr2):\n    from collections import Counter\n    \n    count = Counter(arr1)\n    result = []\n    \n    for num in arr2:\n        result.extend([num] * count[num])\n        del count[num]\n    \n    for num in sorted(count.keys()):\n        result.extend([num] * count[num])\n    \n    return result\n\nprint(relative_sort([2,3,1,3,2,4,6,7,9,2,19], [2,1,4,3,9,6]))",
    "testCases": [
      {
        "input": "[2,3,1,3,2,4,6,7,9,2,19], [2,1,4,3,9,6]",
        "isHidden": false,
        "description": "Standard case"
      },
      {
        "input": "[28,6,22,8,44,17], [22,28,8,6]",
        "isHidden": false,
        "description": "Different arrays"
      },
      {
        "input": "[1, 2, 3], []",
        "isHidden": true,
        "description": "Empty arr2"
      }
    ],
    "hints": [
      "Count occurrences in arr1",
      "Add elements in arr2 order first",
      "Sort and add remaining elements"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Sort Linked List (Merge Sort)",
    "difficulty": 4,
    "description": "Sort a linked list using merge sort. Achieve O(n log n) time and O(1) space (excluding recursion stack).",
    "starterCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sort_list(head):\n    pass\n\ndef print_list(head):\n    vals = []\n    while head:\n        vals.append(head.val)\n        head = head.next\n    print(vals)\n\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint_list(sort_list(head))",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sort_list(head):\n    if not head or not head.next:\n        return head\n    \n    slow = head\n    fast = head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    mid = slow.next\n    slow.next = None\n    \n    left = sort_list(head)\n    right = sort_list(mid)\n    \n    return merge(left, right)\n\ndef merge(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n    \n    while l1 and l2:\n        if l1.val <= l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    \n    curr.next = l1 if l1 else l2\n    return dummy.next\n\ndef print_list(head):\n    vals = []\n    while head:\n        vals.append(head.val)\n        head = head.next\n    print(vals)\n\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint_list(sort_list(head))",
    "testCases": [
      {
        "input": "[4, 2, 1, 3]",
        "isHidden": false,
        "description": "Unsorted list"
      },
      {
        "input": "[-1, 5, 3, 4, 0]",
        "isHidden": false,
        "description": "With negatives"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty list"
      }
    ],
    "hints": [
      "Use slow/fast pointers to find middle",
      "Split list into two halves",
      "Recursively sort and merge"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t6-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-6",
    "title": "Pancake Sort",
    "difficulty": 4,
    "description": "Sort an array using only \"pancake flips\". A flip reverses the first k elements. Return the sequence of k values used.",
    "starterCode": "def pancake_sort(arr):\n    # Return list of k values for flips\n    pass\n\nprint(pancake_sort([3, 2, 4, 1]))",
    "solution": "def pancake_sort(arr):\n    result = []\n    n = len(arr)\n    \n    def flip(k):\n        arr[:k] = arr[:k][::-1]\n    \n    for size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        \n        if max_idx != size - 1:\n            if max_idx > 0:\n                flip(max_idx + 1)\n                result.append(max_idx + 1)\n            \n            flip(size)\n            result.append(size)\n    \n    return result\n\nprint(pancake_sort([3, 2, 4, 1]))",
    "testCases": [
      {
        "input": "[3, 2, 4, 1]",
        "isHidden": false,
        "description": "Unsorted"
      },
      {
        "input": "[1, 2, 3]",
        "isHidden": false,
        "description": "Already sorted"
      },
      {
        "input": "[2, 1]",
        "isHidden": true,
        "description": "Two elements"
      }
    ],
    "hints": [
      "Work from largest to smallest element",
      "Flip max to front, then flip to its final position",
      "Each element takes at most 2 flips"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex01",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Basic Min Heap Operations",
    "difficulty": 1,
    "description": "Use Python's heapq module to implement basic min-heap operations. Insert values and extract the minimum.",
    "starterCode": "import heapq\n\ndef heap_operations(values):\n    # Insert all values, then extract them in sorted order\n    pass\n\nprint(heap_operations([5, 3, 8, 1, 2]))",
    "solution": "import heapq\n\ndef heap_operations(values):\n    heap = []\n    for val in values:\n        heapq.heappush(heap, val)\n    \n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    return result\n\nprint(heap_operations([5, 3, 8, 1, 2]))",
    "testCases": [
      {
        "input": "[5, 3, 8, 1, 2]",
        "isHidden": false,
        "description": "Basic list with mixed values"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "isHidden": false,
        "description": "Empty list"
      },
      {
        "input": "[3, 3, 3]",
        "isHidden": true,
        "description": "All duplicate values"
      }
    ],
    "hints": [
      "Use heapq.heappush() to insert",
      "Use heapq.heappop() to extract minimum",
      "Elements come out in sorted order"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex02",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Kth Largest Element Using Heap",
    "difficulty": 2,
    "description": "Find the kth largest element in an array using a min-heap of size k.",
    "starterCode": "import heapq\n\ndef find_kth_largest(nums, k):\n    pass\n\nprint(find_kth_largest([3, 2, 1, 5, 6, 4], 2))",
    "solution": "import heapq\n\ndef find_kth_largest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap[0]\n\nprint(find_kth_largest([3, 2, 1, 5, 6, 4], 2))",
    "testCases": [
      {
        "input": "[3, 2, 1, 5, 6, 4], 2",
        "isHidden": false,
        "description": "Find 2nd largest in unsorted array"
      },
      {
        "input": "[3, 2, 3, 1, 2, 4, 5, 5, 6], 4",
        "isHidden": false,
        "description": "Array with duplicates"
      },
      {
        "input": "[1], 1",
        "isHidden": false,
        "description": "Single element array"
      },
      {
        "input": "[7, 6, 5, 4, 3, 2, 1], 7",
        "isHidden": true,
        "description": "Find smallest in descending array"
      }
    ],
    "hints": [
      "Keep a min-heap of exactly k elements",
      "If heap grows beyond k, pop the smallest",
      "The root of the heap is the kth largest"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex03",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Implement Max Heap",
    "difficulty": 2,
    "description": "Implement a max heap class with insert, extract_max, and peek methods. Since Python's heapq is a min-heap, negate values.",
    "starterCode": "import heapq\n\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def insert(self, val):\n        pass\n    \n    def extract_max(self):\n        pass\n    \n    def peek(self):\n        pass\n\nmh = MaxHeap()\nfor v in [3, 1, 4, 1, 5, 9, 2, 6]:\n    mh.insert(v)\nprint(mh.extract_max())\nprint(mh.peek())",
    "solution": "import heapq\n\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def insert(self, val):\n        heapq.heappush(self.heap, -val)\n    \n    def extract_max(self):\n        if self.heap:\n            return -heapq.heappop(self.heap)\n        return None\n    \n    def peek(self):\n        if self.heap:\n            return -self.heap[0]\n        return None\n\nmh = MaxHeap()\nfor v in [3, 1, 4, 1, 5, 9, 2, 6]:\n    mh.insert(v)\nprint(mh.extract_max())\nprint(mh.peek())",
    "testCases": [
      {
        "input": "[3, 1, 4, 1, 5, 9, 2, 6]",
        "isHidden": false,
        "description": "Extract max twice from multiple elements"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single element max heap"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty heap operations"
      }
    ],
    "hints": [
      "Negate values when pushing to convert min-heap to max-heap",
      "Negate again when extracting to get original value",
      "heap[0] is always the smallest (most negative)"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex04",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Merge K Sorted Lists",
    "difficulty": 3,
    "description": "Merge k sorted lists into one sorted list using a heap. This is more efficient than merging pairs.",
    "starterCode": "import heapq\n\ndef merge_k_sorted(lists):\n    pass\n\nprint(merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]]))",
    "solution": "import heapq\n\ndef merge_k_sorted(lists):\n    heap = []\n    \n    # Initialize heap with first element from each list\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    result = []\n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        \n        # Add next element from same list if exists\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n    \n    return result\n\nprint(merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]]))",
    "testCases": [
      {
        "input": "[[1, 4, 5], [1, 3, 4], [2, 6]]",
        "isHidden": false,
        "description": "Merge three sorted lists"
      },
      {
        "input": "[[]]",
        "isHidden": false,
        "description": "List containing empty list"
      },
      {
        "input": "[[1], [2], [3]]",
        "isHidden": false,
        "description": "Single element lists"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty list of lists"
      }
    ],
    "hints": [
      "Store (value, list_index, element_index) in heap",
      "Always pop the minimum and push next from same list",
      "Time complexity: O(n log k) where n is total elements"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex05",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Find Median from Data Stream",
    "difficulty": 4,
    "description": "Design a data structure that supports adding numbers and finding the median efficiently. Use two heaps.",
    "starterCode": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        pass\n    \n    def add_num(self, num):\n        pass\n    \n    def find_median(self):\n        pass\n\nmf = MedianFinder()\nfor num in [1, 2, 3, 4, 5]:\n    mf.add_num(num)\n    print(mf.find_median())",
    "solution": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (negated) for smaller half\n        self.large = []  # min-heap for larger half\n    \n    def add_num(self, num):\n        # Add to max-heap (small)\n        heapq.heappush(self.small, -num)\n        \n        # Balance: move largest from small to large\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        \n        # Keep small same size or 1 larger\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def find_median(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2\n\nmf = MedianFinder()\nfor num in [1, 2, 3, 4, 5]:\n    mf.add_num(num)\n    print(mf.find_median())",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Sequential additions with increasing values"
      },
      {
        "input": "[2, 1]",
        "isHidden": false,
        "description": "Two elements out of order"
      },
      {
        "input": "[5]",
        "isHidden": true,
        "description": "Single element median"
      }
    ],
    "hints": [
      "Use max-heap for smaller half, min-heap for larger half",
      "Keep heaps balanced (differ by at most 1)",
      "Median is either top of small or average of both tops"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex06",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Top K Frequent Elements",
    "difficulty": 2,
    "description": "Given an array and integer k, return the k most frequent elements.",
    "starterCode": "import heapq\nfrom collections import Counter\n\ndef top_k_frequent(nums, k):\n    pass\n\nprint(top_k_frequent([1, 1, 1, 2, 2, 3], 2))",
    "solution": "import heapq\nfrom collections import Counter\n\ndef top_k_frequent(nums, k):\n    freq = Counter(nums)\n    \n    # Use min-heap of size k\n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return [num for count, num in heap]\n\nprint(top_k_frequent([1, 1, 1, 2, 2, 3], 2))",
    "testCases": [
      {
        "input": "[1, 1, 1, 2, 2, 3], 2",
        "isHidden": false,
        "description": "Find 2 most frequent elements"
      },
      {
        "input": "[1], 1",
        "isHidden": false,
        "description": "Single element with k=1"
      },
      {
        "input": "[4, 1, -1, 2, -1, 2, 3], 2",
        "isHidden": true,
        "description": "Array with negative numbers"
      }
    ],
    "hints": [
      "Count frequencies with Counter",
      "Use min-heap of size k with (frequency, element)",
      "Pop when heap exceeds k elements"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex07",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Implement Heap Sort",
    "difficulty": 3,
    "description": "Implement heap sort algorithm. Build a max-heap, then repeatedly extract the maximum.",
    "starterCode": "def heap_sort(arr):\n    pass\n\nprint(heap_sort([12, 11, 13, 5, 6, 7]))",
    "solution": "def heap_sort(arr):\n    n = len(arr)\n    \n    def heapify(n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n        \n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(n, largest)\n    \n    # Build max-heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(n, i)\n    \n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(i, 0)\n    \n    return arr\n\nprint(heap_sort([12, 11, 13, 5, 6, 7]))",
    "testCases": [
      {
        "input": "[12, 11, 13, 5, 6, 7]",
        "isHidden": false,
        "description": "Unsorted array with 6 elements"
      },
      {
        "input": "[4, 3, 2, 1]",
        "isHidden": false,
        "description": "Reverse sorted array"
      },
      {
        "input": "[]",
        "isHidden": false,
        "description": "Empty array"
      },
      {
        "input": "[1]",
        "isHidden": true,
        "description": "Single element array"
      }
    ],
    "hints": [
      "Build max-heap starting from last non-leaf node",
      "Swap root with last element, reduce heap size, heapify",
      "O(n log n) time, O(1) space"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex08",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "K Closest Points to Origin",
    "difficulty": 2,
    "description": "Find the k closest points to the origin (0, 0). Distance is calculated as sqrt(x^2 + y^2).",
    "starterCode": "import heapq\n\ndef k_closest(points, k):\n    pass\n\nprint(k_closest([[1, 3], [-2, 2], [5, 8], [0, 1]], 2))",
    "solution": "import heapq\n\ndef k_closest(points, k):\n    # Use max-heap of size k (negate distances)\n    heap = []\n    \n    for x, y in points:\n        dist = x * x + y * y  # No need for sqrt for comparison\n        heapq.heappush(heap, (-dist, [x, y]))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return [point for _, point in heap]\n\nprint(k_closest([[1, 3], [-2, 2], [5, 8], [0, 1]], 2))",
    "testCases": [
      {
        "input": "[[1, 3], [-2, 2], [5, 8], [0, 1]], 2",
        "isHidden": false,
        "description": "Find 2 closest points from 4"
      },
      {
        "input": "[[3, 3], [5, -1], [-2, 4]], 2",
        "isHidden": false,
        "description": "Points with negative coordinates"
      },
      {
        "input": "[[0, 0]], 1",
        "isHidden": true,
        "description": "Origin point only"
      }
    ],
    "hints": [
      "Use squared distance (no need for sqrt)",
      "Max-heap keeps k smallest by removing largest",
      "Negate distances for max-heap behavior"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex09",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Last Stone Weight",
    "difficulty": 1,
    "description": "Smash stones together: take two heaviest, if different weights, put difference back. Return last stone weight or 0.",
    "starterCode": "import heapq\n\ndef last_stone_weight(stones):\n    pass\n\nprint(last_stone_weight([2, 7, 4, 1, 8, 1]))",
    "solution": "import heapq\n\ndef last_stone_weight(stones):\n    # Convert to max-heap by negating\n    heap = [-s for s in stones]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        first = -heapq.heappop(heap)\n        second = -heapq.heappop(heap)\n        \n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    \n    return -heap[0] if heap else 0\n\nprint(last_stone_weight([2, 7, 4, 1, 8, 1]))",
    "testCases": [
      {
        "input": "[2, 7, 4, 1, 8, 1]",
        "isHidden": false,
        "description": "Multiple stones with different weights"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single stone"
      },
      {
        "input": "[2, 2]",
        "isHidden": false,
        "description": "Two equal stones"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "No stones"
      }
    ],
    "hints": [
      "Need max-heap to always get two heaviest",
      "Negate values for max-heap in Python",
      "Keep smashing until 0 or 1 stones remain"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex10",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Task Scheduler",
    "difficulty": 4,
    "description": "Given tasks and cooling interval n, find minimum time to finish all tasks. Same tasks must be separated by at least n intervals.",
    "starterCode": "import heapq\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    pass\n\nprint(least_interval([\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], 2))",
    "solution": "import heapq\nfrom collections import Counter, deque\n\ndef least_interval(tasks, n):\n    freq = Counter(tasks)\n    heap = [-cnt for cnt in freq.values()]  # Max-heap\n    heapq.heapify(heap)\n    \n    time = 0\n    cooldown = deque()  # (available_time, count)\n    \n    while heap or cooldown:\n        time += 1\n        \n        if heap:\n            cnt = heapq.heappop(heap) + 1  # Execute one task\n            if cnt < 0:\n                cooldown.append((time + n, cnt))\n        \n        if cooldown and cooldown[0][0] == time:\n            heapq.heappush(heap, cooldown.popleft()[1])\n    \n    return time\n\nprint(least_interval([\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], 2))",
    "testCases": [
      {
        "input": "[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], 2",
        "isHidden": false,
        "description": "Equal frequency tasks with cooldown 2"
      },
      {
        "input": "[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], 0",
        "isHidden": false,
        "description": "No cooldown period"
      },
      {
        "input": "[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], 2",
        "isHidden": true,
        "description": "One dominant task with many others"
      }
    ],
    "hints": [
      "Always schedule most frequent available task",
      "Track when each task type becomes available",
      "Idle if no task available but work remains"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex11",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Check if Array is a Min Heap",
    "difficulty": 1,
    "description": "Given an array representing a complete binary tree, check if it satisfies the min-heap property.",
    "starterCode": "def is_min_heap(arr):\n    pass\n\nprint(is_min_heap([1, 2, 3, 4, 5]))\nprint(is_min_heap([1, 5, 2, 4, 3]))",
    "solution": "def is_min_heap(arr):\n    n = len(arr)\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        if left < n and arr[i] > arr[left]:\n            return False\n        if right < n and arr[i] > arr[right]:\n            return False\n    \n    return True\n\nprint(is_min_heap([1, 2, 3, 4, 5]))\nprint(is_min_heap([1, 5, 2, 4, 3]))",
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "isHidden": false,
        "description": "Valid min heap"
      },
      {
        "input": "[1, 5, 2, 4, 3]",
        "isHidden": false,
        "description": "Invalid heap structure"
      },
      {
        "input": "[]",
        "isHidden": false,
        "description": "Empty array is valid"
      },
      {
        "input": "[1]",
        "isHidden": true,
        "description": "Single element is valid"
      }
    ],
    "hints": [
      "For each node, check if it is smaller than both children",
      "Use index formulas: left = 2*i+1, right = 2*i+2",
      "Only check children that exist (within bounds)"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex12",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Kth Smallest Element in Sorted Matrix",
    "difficulty": 3,
    "description": "Find the kth smallest element in a matrix where each row and column is sorted.",
    "starterCode": "import heapq\n\ndef kth_smallest(matrix, k):\n    pass\n\nmatrix = [\n    [1, 5, 9],\n    [10, 11, 13],\n    [12, 13, 15]\n]\nprint(kth_smallest(matrix, 8))",
    "solution": "import heapq\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    heap = [(matrix[0][0], 0, 0)]\n    visited = {(0, 0)}\n    \n    for _ in range(k):\n        val, r, c = heapq.heappop(heap)\n        \n        if _ == k - 1:\n            return val\n        \n        # Add right neighbor\n        if c + 1 < n and (r, c + 1) not in visited:\n            heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))\n            visited.add((r, c + 1))\n        \n        # Add bottom neighbor\n        if r + 1 < n and (r + 1, c) not in visited:\n            heapq.heappush(heap, (matrix[r + 1][c], r + 1, c))\n            visited.add((r + 1, c))\n    \n    return val\n\nmatrix = [\n    [1, 5, 9],\n    [10, 11, 13],\n    [12, 13, 15]\n]\nprint(kth_smallest(matrix, 8))",
    "testCases": [
      {
        "input": "[[1,5,9],[10,11,13],[12,13,15]], 8",
        "isHidden": false,
        "description": "3x3 sorted matrix"
      },
      {
        "input": "[[-5]], 1",
        "isHidden": false,
        "description": "Single element matrix"
      },
      {
        "input": "[[1,2],[1,3]], 2",
        "isHidden": true,
        "description": "Matrix with duplicate values"
      }
    ],
    "hints": [
      "Start with top-left corner in heap",
      "Pop k times, each time add right and bottom neighbors",
      "Use visited set to avoid duplicates"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex13",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Reorganize String",
    "difficulty": 3,
    "description": "Reorganize string so no two adjacent characters are the same. Return empty string if impossible.",
    "starterCode": "import heapq\nfrom collections import Counter\n\ndef reorganize_string(s):\n    pass\n\nprint(reorganize_string(\"aab\"))\nprint(reorganize_string(\"aaab\"))",
    "solution": "import heapq\nfrom collections import Counter\n\ndef reorganize_string(s):\n    freq = Counter(s)\n    heap = [(-count, char) for char, count in freq.items()]\n    heapq.heapify(heap)\n    \n    result = []\n    prev_count, prev_char = 0, \"\"\n    \n    while heap:\n        count, char = heapq.heappop(heap)\n        result.append(char)\n        \n        # Push back previous character if still has count\n        if prev_count < 0:\n            heapq.heappush(heap, (prev_count, prev_char))\n        \n        prev_count = count + 1  # Used one\n        prev_char = char\n    \n    result = \"\".join(result)\n    return result if len(result) == len(s) else \"\"\n\nprint(reorganize_string(\"aab\"))\nprint(reorganize_string(\"aaab\"))",
    "testCases": [
      {
        "input": "\"aab\"",
        "isHidden": false,
        "description": "Simple reorganization possible"
      },
      {
        "input": "\"aaab\"",
        "isHidden": false,
        "description": "Impossible to reorganize"
      },
      {
        "input": "\"vvvlo\"",
        "isHidden": false,
        "description": "Multiple reorganizations needed"
      },
      {
        "input": "\"\"",
        "isHidden": true,
        "description": "Empty string"
      }
    ],
    "hints": [
      "Use max-heap to always pick most frequent available char",
      "Hold back the just-used character for one round",
      "Impossible if any character appears > (n+1)/2 times"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex14",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Min Heap Implementation from Scratch",
    "difficulty": 3,
    "description": "Implement a min-heap class without using heapq. Implement insert, extract_min, heapify_up, and heapify_down.",
    "starterCode": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def insert(self, key):\n        pass\n    \n    def extract_min(self):\n        pass\n    \n    def _heapify_up(self, i):\n        pass\n    \n    def _heapify_down(self, i):\n        pass\n\nmh = MinHeap()\nfor v in [5, 3, 8, 1, 2]:\n    mh.insert(v)\nprint([mh.extract_min() for _ in range(5)])",
    "solution": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def insert(self, key):\n        self.heap.append(key)\n        self._heapify_up(len(self.heap) - 1)\n    \n    def extract_min(self):\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        min_val = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down(0)\n        return min_val\n    \n    def _heapify_up(self, i):\n        parent = self.parent(i)\n        while i > 0 and self.heap[i] < self.heap[parent]:\n            self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]\n            i = parent\n            parent = self.parent(i)\n    \n    def _heapify_down(self, i):\n        smallest = i\n        left = self.left_child(i)\n        right = self.right_child(i)\n        \n        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:\n            smallest = left\n        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:\n            smallest = right\n        \n        if smallest != i:\n            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]\n            self._heapify_down(smallest)\n\nmh = MinHeap()\nfor v in [5, 3, 8, 1, 2]:\n    mh.insert(v)\nprint([mh.extract_min() for _ in range(5)])",
    "testCases": [
      {
        "input": "[5, 3, 8, 1, 2]",
        "isHidden": false,
        "description": "Basic unsorted array"
      },
      {
        "input": "[1]",
        "isHidden": false,
        "description": "Single element"
      },
      {
        "input": "[]",
        "isHidden": true,
        "description": "Empty array"
      }
    ],
    "hints": [
      "heapify_up: swap with parent while smaller",
      "heapify_down: swap with smallest child while larger",
      "extract_min: move last element to root, then heapify down"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex15",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "Smallest Range Covering K Lists",
    "difficulty": 5,
    "description": "Find the smallest range that includes at least one element from each of k sorted lists.",
    "starterCode": "import heapq\n\ndef smallest_range(nums):\n    pass\n\nprint(smallest_range([[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]))",
    "solution": "import heapq\n\ndef smallest_range(nums):\n    heap = []\n    current_max = float(\"-inf\")\n    \n    # Initialize: first element from each list\n    for i, lst in enumerate(nums):\n        heapq.heappush(heap, (lst[0], i, 0))\n        current_max = max(current_max, lst[0])\n    \n    result = [float(\"-inf\"), float(\"inf\")]\n    \n    while True:\n        current_min, list_idx, elem_idx = heapq.heappop(heap)\n        \n        # Update result if smaller range found\n        if current_max - current_min < result[1] - result[0]:\n            result = [current_min, current_max]\n        \n        # Move to next element in that list\n        if elem_idx + 1 == len(nums[list_idx]):\n            break  # Exhausted one list\n        \n        next_val = nums[list_idx][elem_idx + 1]\n        heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n        current_max = max(current_max, next_val)\n    \n    return result\n\nprint(smallest_range([[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]))",
    "testCases": [
      {
        "input": "[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
        "isHidden": false,
        "description": "Three lists with different ranges"
      },
      {
        "input": "[[1,2,3],[1,2,3],[1,2,3]]",
        "isHidden": false,
        "description": "Identical sorted lists"
      },
      {
        "input": "[[1],[2],[3]]",
        "isHidden": true,
        "description": "Single element lists"
      }
    ],
    "hints": [
      "Track current min (from heap) and current max",
      "Range = [min, max] when all lists represented",
      "Advance pointer in list that has current min"
    ],
    "language": "python"
  },
  {
    "id": "cs104-t7-ex16",
    "subjectId": "cs104",
    "topicId": "cs104-topic-7",
    "title": "IPO - Maximize Capital",
    "difficulty": 5,
    "description": "You have initial capital and can complete k projects. Each project has profit and required capital. Maximize final capital.",
    "starterCode": "import heapq\n\ndef find_maximized_capital(k, w, profits, capital):\n    # k: max projects, w: initial capital\n    pass\n\nprint(find_maximized_capital(2, 0, [1, 2, 3], [0, 1, 1]))",
    "solution": "import heapq\n\ndef find_maximized_capital(k, w, profits, capital):\n    projects = sorted(zip(capital, profits))  # Sort by capital required\n    heap = []  # Max-heap of available profits\n    idx = 0\n    n = len(profits)\n    \n    for _ in range(k):\n        # Add all projects we can now afford\n        while idx < n and projects[idx][0] <= w:\n            heapq.heappush(heap, -projects[idx][1])  # Max-heap\n            idx += 1\n        \n        if not heap:\n            break  # No affordable projects\n        \n        # Do most profitable project\n        w += -heapq.heappop(heap)\n    \n    return w\n\nprint(find_maximized_capital(2, 0, [1, 2, 3], [0, 1, 1]))",
    "testCases": [
      {
        "input": "2, 0, [1, 2, 3], [0, 1, 1]",
        "isHidden": false,
        "description": "Two projects from zero capital"
      },
      {
        "input": "3, 0, [1, 2, 3], [0, 1, 2]",
        "isHidden": false,
        "description": "Three projects with progressive capital"
      },
      {
        "input": "1, 0, [1, 2, 3], [1, 1, 2]",
        "isHidden": true,
        "description": "Cannot afford any project"
      }
    ],
    "hints": [
      "Sort projects by capital requirement",
      "Use max-heap to pick most profitable affordable project",
      "Greedily pick highest profit each time"
    ],
    "language": "python"
  }
]
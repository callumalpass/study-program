[
  {
    "id": "cs204-t6-ex1",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "VCS Fundamentals",
    "description": "Explain the difference between centralized (SVN) and distributed (Git) version control systems. List two advantages of each approach.",
    "difficulty": 1,
    "hints": [
      "Consider offline work capabilities",
      "Think about single point of failure",
      "Consider branching complexity"
    ],
    "solution": "**Centralized VCS (SVN):**\n- Single central repository; clients checkout working copies\n- Advantages: Simpler model, fine-grained access control, better for large binary files\n\n**Distributed VCS (Git):**\n- Every developer has full repository copy with complete history\n- Advantages: Offline work, no single point of failure, fast operations, flexible branching\n\n**Key difference:** In DVCS, operations like commit, branch, log are local and instant. Central server is optional, used for sharing."
  },
  {
    "id": "cs204-t6-ex2",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Git Three-Tree Architecture",
    "description": "Explain Git's three trees: Working Directory, Staging Area (Index), and Repository. Describe how files move between them.",
    "difficulty": 2,
    "hints": [
      "Working directory has actual files",
      "Staging area holds next commit",
      "Repository contains committed history"
    ],
    "solution": "**Working Directory:** Actual files on disk. Modified files are \"unstaged.\"\n\n**Staging Area (Index):** Snapshot of files to include in next commit. Files added with `git add`.\n\n**Repository (.git):** Committed history stored as objects.\n\n**Flow:**\n1. Edit files → changes in Working Directory\n2. `git add` → moves changes to Staging Area\n3. `git commit` → saves staged changes to Repository\n\n**Commands:**\n- `git status`: Shows state across all three\n- `git diff`: Working vs Staging\n- `git diff --staged`: Staging vs Repository"
  },
  {
    "id": "cs204-t6-ex3",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Git Branching Basics",
    "description": "Explain how Git branches work internally. What is a branch? What is HEAD? How does creating a branch differ from creating a commit?",
    "difficulty": 2,
    "hints": [
      "Branch is just a pointer",
      "HEAD points to current branch",
      "Commits are immutable objects"
    ],
    "solution": "**Branch:** A lightweight movable pointer to a commit. Stored as 40-char SHA in .git/refs/heads/branchname.\n\n**HEAD:** Special pointer indicating current branch (or commit in detached state). Stored in .git/HEAD.\n\n**Creating branch:** Just creates new pointer file (~41 bytes). Instant, regardless of repository size.\n\n**Creating commit:** Creates commit object (metadata + tree pointer), updates current branch pointer to new commit.\n\n**Example:**\n`git branch feature` → creates .git/refs/heads/feature pointing to current commit\n`git checkout feature` → updates HEAD to point to feature branch"
  },
  {
    "id": "cs204-t6-ex4",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Merge vs Rebase",
    "description": "Compare git merge and git rebase. When would you use each? What are the risks of rebasing?",
    "difficulty": 3,
    "hints": [
      "Merge preserves history",
      "Rebase creates linear history",
      "Never rebase public branches"
    ],
    "solution": "**git merge:**\n- Creates merge commit with two parents\n- Preserves complete history and branch structure\n- Use: Integrating feature branches, public/shared branches\n\n**git rebase:**\n- Replays commits on top of another branch\n- Creates linear, cleaner history\n- Use: Updating feature branch with main, cleaning up before PR\n\n**Rebase Risks:**\n- Rewrites commit history (changes SHAs)\n- **Never rebase commits already pushed/shared** — causes divergent histories for collaborators\n- Can cause repeated conflict resolution\n\n**Golden rule:** Rebase local work, merge shared work."
  },
  {
    "id": "cs204-t6-ex5",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Resolving Merge Conflicts",
    "description": "Explain what causes merge conflicts and describe the step-by-step process to resolve them in Git.",
    "difficulty": 2,
    "hints": [
      "Conflicts occur when same lines changed",
      "Conflict markers show both versions",
      "Must manually edit then mark resolved"
    ],
    "solution": "**Causes:** Same lines modified differently in both branches being merged.\n\n**Resolution Process:**\n1. `git merge feature` → conflict occurs\n2. Git marks files with conflict markers:\n   <<<<<<< HEAD\n   current branch code\n   =======\n   incoming branch code\n   >>>>>>> feature\n3. Edit file to resolve (keep one, both, or new combination)\n4. Remove conflict markers\n5. `git add resolved-file.txt`\n6. `git commit` → completes merge\n\n**Tools:** `git mergetool` launches visual diff tool\n**Prevention:** Frequent integration, small focused changes, communication"
  },
  {
    "id": "cs204-t6-ex6",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Git Flow Workflow",
    "description": "Describe the Git Flow branching model. What are the main branch types and their purposes?",
    "difficulty": 3,
    "hints": [
      "Two long-lived branches",
      "Feature, release, hotfix branches",
      "Consider release management"
    ],
    "solution": "**Long-lived Branches:**\n- **main/master:** Production-ready code, tagged with versions\n- **develop:** Integration branch for features\n\n**Short-lived Branches:**\n- **feature/xxx:** New features; branch from develop, merge back\n- **release/x.x:** Release preparation; branch from develop, merge to main AND develop\n- **hotfix/xxx:** Production fixes; branch from main, merge to main AND develop\n\n**Flow:**\n1. Features developed in feature branches\n2. Features merged to develop\n3. Release branch created for final testing\n4. Release merged to main (tagged) and develop\n5. Hotfixes go directly to main, then develop\n\n**Best for:** Scheduled release cycles, multiple versions in production"
  },
  {
    "id": "cs204-t6-ex7",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Trunk-Based Development",
    "description": "Compare trunk-based development with Git Flow. When is trunk-based development preferred?",
    "difficulty": 3,
    "hints": [
      "Single main branch focus",
      "Short-lived feature branches",
      "Requires strong CI/CD"
    ],
    "solution": "**Trunk-Based Development:**\n- Single main branch (trunk) for integration\n- Short-lived feature branches (<2 days)\n- Frequent commits directly to trunk or quick PRs\n- Feature flags for incomplete features\n\n**vs Git Flow:**\n- Simpler branch structure\n- Faster integration (less merge complexity)\n- Requires robust CI/CD and testing\n- Better for continuous deployment\n\n**When to prefer:**\n- Continuous deployment environments\n- Small, experienced teams\n- Strong automated testing\n- Web services (single version in production)\n\n**When Git Flow better:**\n- Multiple production versions\n- Scheduled releases\n- Less mature CI/CD infrastructure"
  },
  {
    "id": "cs204-t6-ex8",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "CI/CD Pipeline Stages",
    "description": "Design a CI/CD pipeline for a web application. List the stages and what happens in each.",
    "difficulty": 3,
    "hints": [
      "Source → Build → Test → Deploy",
      "Consider different environments",
      "Include quality gates"
    ],
    "solution": "**CI/CD Pipeline Stages:**\n\n1. **Source:** Trigger on push/PR to repository\n   - Checkout code, fetch dependencies\n\n2. **Build:** Compile/bundle application\n   - npm install, npm run build\n   - Create artifacts\n\n3. **Test:** Automated quality checks\n   - Unit tests, linting, type checking\n   - Integration tests\n   - Code coverage threshold\n\n4. **Security Scan:** Vulnerability detection\n   - SAST (static analysis)\n   - Dependency vulnerability scan\n\n5. **Deploy to Staging:** Pre-production environment\n   - Deploy artifacts\n   - Run smoke tests\n\n6. **Manual Approval:** (optional) Human gate\n\n7. **Deploy to Production:**\n   - Blue/green or rolling deployment\n   - Health checks\n   - Automated rollback on failure"
  },
  {
    "id": "cs204-t6-ex9",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Continuous Integration Principles",
    "description": "List and explain five key practices for successful continuous integration.",
    "difficulty": 2,
    "hints": [
      "Frequent integration",
      "Automated builds",
      "Fast feedback"
    ],
    "solution": "**Key CI Practices:**\n\n1. **Maintain Single Source Repository**\n   - Everything needed to build in version control\n   - No dependencies on local machine state\n\n2. **Automate the Build**\n   - Single command builds entire project\n   - Include all tests in build process\n\n3. **Commit Frequently**\n   - At least daily integration to main branch\n   - Smaller changes = easier conflict resolution\n\n4. **Keep Build Fast**\n   - Target <10 minutes for feedback\n   - Parallelize tests, optimize slow tests\n\n5. **Fix Broken Builds Immediately**\n   - Broken build is highest priority\n   - Team stops until fixed\n\n**Additional:** Everyone sees build results, test in production clone, make artifacts easily available."
  },
  {
    "id": "cs204-t6-ex10",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Deployment Strategies",
    "description": "Compare blue-green deployment, canary releases, and rolling deployments. When would you use each?",
    "difficulty": 4,
    "hints": [
      "Blue-green: instant switch",
      "Canary: gradual rollout",
      "Rolling: incremental replacement"
    ],
    "solution": "**Blue-Green Deployment:**\n- Two identical environments (blue=current, green=new)\n- Deploy to green, switch traffic instantly\n- Easy rollback: switch back to blue\n- Use: When instant switchover needed, simple rollback required\n- Con: Requires double infrastructure\n\n**Canary Release:**\n- Route small % of traffic to new version\n- Monitor, gradually increase if healthy\n- Use: High-risk changes, need real user feedback before full rollout\n- Con: Complex routing, version compatibility issues\n\n**Rolling Deployment:**\n- Replace instances incrementally (e.g., 1 at a time)\n- Use: Resource-efficient, Kubernetes default\n- Con: Mixed versions during deploy, slower rollback\n\n**Feature Flags:** Alternative — deploy code, enable via config"
  },
  {
    "id": "cs204-t6-ex11",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Git Hooks",
    "description": "Explain what Git hooks are and describe three useful hooks with practical examples.",
    "difficulty": 3,
    "hints": [
      "Scripts triggered by Git events",
      "Client-side and server-side hooks",
      "Common: pre-commit, pre-push"
    ],
    "solution": "**Git Hooks:** Scripts in .git/hooks/ triggered by Git events.\n\n**Useful Hooks:**\n\n1. **pre-commit:** Runs before commit created\n   - Example: Run linter, formatter, tests\n   - Prevent committing debug code, large files\n   ```bash\n   npm run lint && npm test\n   ```\n\n2. **prepare-commit-msg:** Modify default commit message\n   - Example: Prepend branch name/ticket number\n   - Auto-format commit message template\n\n3. **pre-push:** Runs before push to remote\n   - Example: Run full test suite\n   - Prevent pushing to protected branches\n   - Check for secrets in code\n\n**Server-side:** pre-receive, post-receive (enforce policies)\n**Sharing hooks:** Use tools like Husky (npm) to version control hooks"
  },
  {
    "id": "cs204-t6-ex12",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Pull Request Best Practices",
    "description": "Describe best practices for creating and reviewing pull requests.",
    "difficulty": 2,
    "hints": [
      "Keep PRs focused and small",
      "Clear descriptions",
      "Constructive code review"
    ],
    "solution": "**Creating PRs:**\n- Keep small and focused (single concern)\n- Clear title describing change\n- Description with context, testing done, screenshots\n- Link to issue/ticket\n- Self-review before requesting review\n- Ensure CI passes\n\n**Reviewing PRs:**\n- Understand context before reviewing\n- Check: correctness, readability, tests, edge cases\n- Be constructive: explain why, suggest alternatives\n- Approve, request changes, or comment\n- Use suggestions feature for small fixes\n\n**Team Practices:**\n- Require 1-2 approvals before merge\n- Address all comments before merging\n- Squash or rebase to clean history\n- Delete branch after merge"
  },
  {
    "id": "cs204-t6-ex13",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Git Reset vs Revert",
    "description": "Explain the difference between git reset and git revert. When should each be used? What are the safety considerations?",
    "difficulty": 3,
    "hints": [
      "Reset moves branch pointer",
      "Revert creates new commit",
      "Reset rewrites history"
    ],
    "solution": "**git reset:** Moves branch pointer backward, optionally modifying staging/working directory\n- `--soft`: Move HEAD only (changes staged)\n- `--mixed` (default): Reset staging (changes unstaged)\n- `--hard`: Reset staging AND working directory (destructive!)\n\n**git revert:** Creates new commit that undoes specified commit\n- Preserves history\n- Safe for shared branches\n\n**When to use:**\n- **reset:** Undo local uncommitted/unpushed work\n- **revert:** Undo commits already pushed/shared\n\n**Safety:**\n- **Never reset pushed commits** — causes divergent history\n- **reset --hard loses uncommitted changes permanently**\n- Revert is always safe but creates undo commits"
  },
  {
    "id": "cs204-t6-ex14",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Infrastructure as Code",
    "description": "Explain Infrastructure as Code (IaC) and its relationship with CI/CD. Give examples of IaC tools.",
    "difficulty": 4,
    "hints": [
      "Treat infrastructure like application code",
      "Version control infrastructure",
      "Automate provisioning"
    ],
    "solution": "**Infrastructure as Code:** Managing infrastructure through machine-readable definition files rather than manual configuration.\n\n**Benefits:**\n- Version control for infrastructure changes\n- Reproducible environments\n- Code review for infrastructure\n- Automated provisioning\n- Documentation as code\n\n**Tools:**\n- **Terraform:** Cloud-agnostic, declarative\n- **AWS CloudFormation:** AWS-specific\n- **Ansible/Chef/Puppet:** Configuration management\n- **Kubernetes manifests/Helm:** Container orchestration\n- **Docker/Dockerfiles:** Container images\n\n**CI/CD Integration:**\n1. Infrastructure changes in PR\n2. Plan/preview changes\n3. Review and approve\n4. Apply changes automatically\n5. Environment parity (dev=staging=prod)"
  },
  {
    "id": "cs204-t6-ex15",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "Monorepo vs Polyrepo",
    "description": "Compare monorepo and polyrepo (multi-repo) strategies. What are the trade-offs of each?",
    "difficulty": 4,
    "hints": [
      "Monorepo: one repo, many projects",
      "Polyrepo: one repo per project",
      "Consider scale and tooling"
    ],
    "solution": "**Monorepo:** Single repository containing multiple projects/services\n\n*Pros:*\n- Atomic cross-project changes\n- Shared code and tooling\n- Unified versioning\n- Easier refactoring across projects\n\n*Cons:*\n- Requires specialized tooling at scale\n- CI/CD complexity (selective builds)\n- Permission management harder\n\n**Polyrepo:** Separate repository per project\n\n*Pros:*\n- Clear ownership boundaries\n- Independent deployment cycles\n- Simpler permissions\n- Standard Git tooling works\n\n*Cons:*\n- Cross-repo changes are multiple PRs\n- Code sharing requires publishing packages\n- Version compatibility challenges\n\n**Examples:** Google, Meta use monorepos; microservices teams often use polyrepos."
  },
  {
    "id": "cs204-t6-ex16",
    "subjectId": "cs204",
    "topicId": "cs204-topic-6",
    "type": "written",
    "title": "CI/CD Pipeline Troubleshooting",
    "description": "A CI/CD pipeline is failing intermittently. Describe strategies for diagnosing and fixing flaky pipelines.",
    "difficulty": 5,
    "hints": [
      "Identify flaky tests vs infrastructure issues",
      "Check for race conditions",
      "Consider environment differences"
    ],
    "solution": "**Diagnosis Strategies:**\n\n1. **Collect Data:** Track which stages fail, frequency, patterns (time of day, load)\n\n2. **Check Logs:** Pipeline logs, test output, system metrics during failures\n\n3. **Identify Root Causes:**\n   - **Flaky tests:** Timing dependencies, shared state, external services\n   - **Resource issues:** Memory limits, disk space, CPU contention\n   - **Network:** Timeouts, rate limiting, DNS issues\n   - **Environment drift:** Differences between runs\n\n**Fixes:**\n- **Flaky tests:** Isolate tests, mock externals, use retries cautiously (masks issues)\n- **Resources:** Increase limits, optimize builds, parallelize wisely\n- **Dependencies:** Pin versions, use lock files, local caching\n- **Timeouts:** Increase where appropriate, add health checks\n\n**Prevention:** Hermetic builds, reproducible environments, monitoring and alerting on failure rates"
  }
]

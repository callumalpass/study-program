[
  {
    "id": "math102-e2",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Fibonacci with Memoization",
    "difficulty": 2,
    "description": "Implement the Fibonacci sequence using memoization to avoid redundant calculations. The Fibonacci recurrence is F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Without memoization, this has exponential time complexity. With memoization, achieve O(n) time complexity.",
    "starterCode": "def fibonacci(n, memo=None):\n    \"\"\"Calculate the nth Fibonacci number using memoization.\n    \n    Args:\n        n: The index in the Fibonacci sequence\n        memo: Dictionary for memoization (default: None)\n        \n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def fibonacci(n, memo=None):\n    \"\"\"Calculate the nth Fibonacci number using memoization.\n    \n    Args:\n        n: The index in the Fibonacci sequence\n        memo: Dictionary for memoization (default: None)\n        \n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    return memo[n]",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "0",
        "isHidden": false,
        "description": "F(0) = 0"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "F(20) = 6765"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "F(1) = 1"
      }
    ],
    "hints": [
      "Initialize the memoization dictionary if it is None",
      "Check if the result for n is already in the memo dictionary before computing",
      "Store the computed result in memo before returning it",
      "The base cases are F(0) = 0 and F(1) = 1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex02",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Iterative Fibonacci",
    "difficulty": 1,
    "description": "Implement Fibonacci using iteration with O(n) time and O(1) space.",
    "starterCode": "def fib_iterative(n):\n    \"\"\"Calculate nth Fibonacci number iteratively\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    pass\n\nprint(fib_iterative(10))",
    "solution": "def fib_iterative(n):\n    \"\"\"Calculate nth Fibonacci number iteratively\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    prev2, prev1 = 0, 1\n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    return prev1\n\nprint(fib_iterative(10))",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "1",
        "isHidden": false,
        "description": "F(1) = 1"
      },
      {
        "input": "30",
        "isHidden": true,
        "description": "F(30) = 832040"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "F(0) = 0"
      }
    ],
    "hints": [
      "Track only the last two values",
      "Update in-place each iteration"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex03",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Tower of Hanoi",
    "difficulty": 2,
    "description": "Count the minimum moves to solve Tower of Hanoi with n disks. The recurrence is T(n) = 2T(n-1) + 1.",
    "starterCode": "def hanoi_moves(n):\n    \"\"\"Calculate minimum moves to solve Tower of Hanoi\n    \n    Args:\n        n: Number of disks\n    Returns:\n        Minimum number of moves\n    \"\"\"\n    pass\n\nprint(hanoi_moves(4))",
    "solution": "def hanoi_moves(n):\n    \"\"\"Calculate minimum moves to solve Tower of Hanoi\n    \n    Args:\n        n: Number of disks\n    Returns:\n        Minimum number of moves\n    \"\"\"\n    # T(n) = 2^n - 1 (closed form)\n    return 2**n - 1\n\nprint(hanoi_moves(4))",
    "testCases": [
      {
        "input": "4",
        "isHidden": false,
        "description": "2^4 - 1 = 15"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "2^3 - 1 = 7"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "2^10 - 1 = 1023"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "2^1 - 1 = 1"
      }
    ],
    "hints": [
      "T(n) = 2T(n-1) + 1",
      "Closed form is 2^n - 1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex04",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Staircase Climbing",
    "difficulty": 2,
    "description": "Count ways to climb n stairs if you can take 1 or 2 steps at a time. This is essentially Fibonacci!",
    "starterCode": "def climb_stairs(n):\n    \"\"\"Count ways to climb n stairs with 1 or 2 steps\n    \n    Args:\n        n: Number of stairs\n    Returns:\n        Number of ways\n    \"\"\"\n    pass\n\nprint(climb_stairs(5))",
    "solution": "def climb_stairs(n):\n    \"\"\"Count ways to climb n stairs with 1 or 2 steps\n    \n    Args:\n        n: Number of stairs\n    Returns:\n        Number of ways\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    for _ in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    return prev1\n\nprint(climb_stairs(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "8 ways to climb 5 stairs"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "3 ways to climb 3 stairs"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "89 ways to climb 10 stairs"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "1 way to climb 1 stair"
      }
    ],
    "hints": [
      "Ways(n) = Ways(n-1) + Ways(n-2)",
      "Base: Ways(1)=1, Ways(2)=2"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex05",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Linear Recurrence Solver",
    "difficulty": 3,
    "description": "Solve the recurrence a(n) = c1*a(n-1) + c2*a(n-2) with given base cases using matrix exponentiation for O(log n) complexity.",
    "starterCode": "def solve_recurrence(c1, c2, a0, a1, n):\n    \"\"\"Solve linear recurrence a(n) = c1*a(n-1) + c2*a(n-2)\n    \n    Args:\n        c1, c2: Coefficients\n        a0, a1: Base cases a(0) and a(1)\n        n: Index to compute\n    Returns:\n        a(n)\n    \"\"\"\n    pass\n\n# Fibonacci: a(n) = 1*a(n-1) + 1*a(n-2), a(0)=0, a(1)=1\nprint(solve_recurrence(1, 1, 0, 1, 10))",
    "solution": "def solve_recurrence(c1, c2, a0, a1, n):\n    \"\"\"Solve linear recurrence a(n) = c1*a(n-1) + c2*a(n-2)\n    \n    Args:\n        c1, c2: Coefficients\n        a0, a1: Base cases a(0) and a(1)\n        n: Index to compute\n    Returns:\n        a(n)\n    \"\"\"\n    if n == 0:\n        return a0\n    if n == 1:\n        return a1\n    \n    def matrix_mult(A, B):\n        return [\n            [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n            [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n        ]\n    \n    def matrix_pow(M, p):\n        result = [[1, 0], [0, 1]]  # Identity\n        while p > 0:\n            if p % 2 == 1:\n                result = matrix_mult(result, M)\n            M = matrix_mult(M, M)\n            p //= 2\n        return result\n    \n    M = [[c1, c2], [1, 0]]\n    Mn = matrix_pow(M, n - 1)\n    return Mn[0][0] * a1 + Mn[0][1] * a0\n\nprint(solve_recurrence(1, 1, 0, 1, 10))",
    "testCases": [
      {
        "input": "1, 1, 0, 1, 10",
        "isHidden": false,
        "description": "Fibonacci F(10) = 55"
      },
      {
        "input": "2, 1, 1, 2, 5",
        "isHidden": false,
        "description": "Custom recurrence"
      },
      {
        "input": "1, 1, 0, 1, 20",
        "isHidden": true,
        "description": "Fibonacci F(20)"
      },
      {
        "input": "3, 2, 1, 1, 6",
        "isHidden": true,
        "description": "Another recurrence"
      }
    ],
    "hints": [
      "Use matrix [[c1, c2], [1, 0]]",
      "Matrix exponentiation gives O(log n)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex06",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Catalan Numbers",
    "difficulty": 3,
    "description": "Calculate the nth Catalan number. C(n) = C(n-1)*2*(2n-1)/(n+1) or C(n) = (2n)! / ((n+1)!*n!)",
    "starterCode": "def catalan(n):\n    \"\"\"Calculate nth Catalan number\n    \n    Args:\n        n: Index (0-indexed)\n    Returns:\n        nth Catalan number\n    \"\"\"\n    pass\n\nprint(catalan(5))",
    "solution": "def catalan(n):\n    \"\"\"Calculate nth Catalan number\n    \n    Args:\n        n: Index (0-indexed)\n    Returns:\n        nth Catalan number\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    cat = 1\n    for i in range(1, n + 1):\n        cat = cat * 2 * (2*i - 1) // (i + 1)\n    return cat\n\nprint(catalan(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "C(5) = 42"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "C(3) = 5"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "C(10) = 16796"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "C(0) = 1"
      }
    ],
    "hints": [
      "C(0) = C(1) = 1",
      "C(n) = C(n-1) * 2(2n-1) / (n+1)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex07",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Divide and Conquer Recurrence",
    "difficulty": 4,
    "description": "Analyze a divide-and-conquer recurrence. Given T(n) = a*T(n/b) + f(n), use Master Theorem to determine complexity.",
    "starterCode": "def analyze_dc(a, b, f_degree):\n    \"\"\"Determine complexity of T(n) = a*T(n/b) + n^f_degree\n    \n    Args:\n        a: Number of subproblems\n        b: Factor by which size decreases\n        f_degree: Degree of polynomial f(n) = n^f_degree\n    Returns:\n        String describing complexity\n    \"\"\"\n    pass\n\nprint(analyze_dc(2, 2, 1))  # Merge sort",
    "solution": "import math\n\ndef analyze_dc(a, b, f_degree):\n    \"\"\"Determine complexity of T(n) = a*T(n/b) + n^f_degree\n    \n    Args:\n        a: Number of subproblems\n        b: Factor by which size decreases\n        f_degree: Degree of polynomial f(n) = n^f_degree\n    Returns:\n        String describing complexity\n    \"\"\"\n    log_b_a = math.log(a) / math.log(b)\n    \n    if f_degree < log_b_a:\n        return f\"O(n^{log_b_a:.2f})\"\n    elif abs(f_degree - log_b_a) < 0.01:\n        return f\"O(n^{f_degree} log n)\"\n    else:\n        return f\"O(n^{f_degree})\"\n\nprint(analyze_dc(2, 2, 1))",
    "testCases": [
      {
        "input": "2, 2, 1",
        "isHidden": false,
        "description": "Merge sort: O(n log n)"
      },
      {
        "input": "4, 2, 2",
        "isHidden": false,
        "description": "Case 2: O(n² log n)"
      },
      {
        "input": "8, 2, 2",
        "isHidden": true,
        "description": "Case 1: O(n³)"
      },
      {
        "input": "2, 2, 0",
        "isHidden": true,
        "description": "Binary search: O(log n)"
      }
    ],
    "hints": [
      "Compare f_degree with log_b(a)",
      "Three cases of Master Theorem"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex08",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Dynamic Programming: Coin Change",
    "difficulty": 4,
    "description": "Find minimum coins needed to make amount n. Use the recurrence: dp[n] = min(dp[n-c] for each coin c) + 1.",
    "starterCode": "def min_coins(coins, amount):\n    \"\"\"Find minimum coins to make amount\n    \n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n    Returns:\n        Minimum coins needed, or -1 if impossible\n    \"\"\"\n    pass\n\nprint(min_coins([1, 5, 10, 25], 37))",
    "solution": "def min_coins(coins, amount):\n    \"\"\"Find minimum coins to make amount\n    \n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n    Returns:\n        Minimum coins needed, or -1 if impossible\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] + 1 < dp[i]:\n                dp[i] = dp[i - coin] + 1\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\nprint(min_coins([1, 5, 10, 25], 37))",
    "testCases": [
      {
        "input": "[1, 5, 10, 25], 37",
        "isHidden": false,
        "description": "37 cents: 4 coins"
      },
      {
        "input": "[1, 2, 5], 11",
        "isHidden": false,
        "description": "11: 3 coins"
      },
      {
        "input": "[2], 3",
        "isHidden": true,
        "description": "Impossible: -1"
      },
      {
        "input": "[1, 5, 10], 27",
        "isHidden": true,
        "description": "27 cents"
      }
    ],
    "hints": [
      "dp[0] = 0",
      "Build up from smaller amounts"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex09",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Matrix Exponentiation for Fibonacci",
    "difficulty": 4,
    "description": "Implement Fibonacci using matrix exponentiation to achieve O(log n) time complexity. Use the matrix [[1,1],[1,0]] raised to the nth power.",
    "starterCode": "def fib_matrix(n):\n    \"\"\"Calculate nth Fibonacci using matrix exponentiation\n    \n    Args:\n        n: Index in Fibonacci sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    pass\n\nprint(fib_matrix(50))",
    "solution": "def fib_matrix(n):\n    \"\"\"Calculate nth Fibonacci using matrix exponentiation\n    \n    Args:\n        n: Index in Fibonacci sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    def matrix_mult(A, B):\n        return [\n            [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n            [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n        ]\n    \n    def matrix_pow(M, p):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while p > 0:\n            if p & 1:\n                result = matrix_mult(result, M)\n            M = matrix_mult(M, M)\n            p >>= 1\n        return result\n    \n    M = [[1, 1], [1, 0]]\n    result_matrix = matrix_pow(M, n)\n    return result_matrix[0][1]\n\nprint(fib_matrix(50))",
    "testCases": [
      {
        "input": "50",
        "isHidden": false,
        "description": "F(50) large value"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "100",
        "isHidden": true,
        "description": "F(100) very large"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "F(0) = 0"
      }
    ],
    "hints": [
      "Matrix [[1,1],[1,0]]^n gives Fibonacci",
      "Use binary exponentiation for O(log n)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex10",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Generating Functions: Fibonacci",
    "difficulty": 5,
    "description": "Use the closed-form formula (Binet's formula) derived from generating functions to calculate Fibonacci: F(n) = (phi^n - psi^n) / sqrt(5) where phi = (1+sqrt(5))/2.",
    "starterCode": "def fib_binet(n):\n    \"\"\"Calculate nth Fibonacci using Binet's formula\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    pass\n\nprint(fib_binet(20))",
    "solution": "import math\n\ndef fib_binet(n):\n    \"\"\"Calculate nth Fibonacci using Binet's formula\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    return round((phi**n - psi**n) / sqrt5)\n\nprint(fib_binet(20))",
    "testCases": [
      {
        "input": "20",
        "isHidden": false,
        "description": "F(20) = 6765"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "30",
        "isHidden": true,
        "description": "F(30) = 832040"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "F(1) = 1"
      }
    ],
    "hints": [
      "phi = (1 + sqrt(5)) / 2 (golden ratio)",
      "Formula: (phi^n - psi^n) / sqrt(5)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex11",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Tribonacci Sequence",
    "difficulty": 3,
    "description": "Solve T(n) = T(n-1) + T(n-2) + T(n-3) with base cases T(0)=0, T(1)=1, T(2)=1 using dynamic programming.",
    "starterCode": "def tribonacci(n):\n    \"\"\"Calculate nth Tribonacci number\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Tribonacci number\n    \"\"\"\n    pass\n\nprint(tribonacci(10))",
    "solution": "def tribonacci(n):\n    \"\"\"Calculate nth Tribonacci number\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Tribonacci number\n    \"\"\"\n    if n == 0:\n        return 0\n    if n <= 2:\n        return 1\n    \n    t0, t1, t2 = 0, 1, 1\n    for _ in range(3, n + 1):\n        t0, t1, t2 = t1, t2, t0 + t1 + t2\n    return t2\n\nprint(tribonacci(10))",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "T(10) = 149"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "T(5) = 7"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "T(20) = 66012"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "T(0) = 0"
      }
    ],
    "hints": [
      "Track last three values",
      "O(n) time, O(1) space"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex12",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Longest Increasing Subsequence",
    "difficulty": 4,
    "description": "Find the length of the longest increasing subsequence. Use dp[i] = max(dp[j] + 1) for all j < i where arr[j] < arr[i].",
    "starterCode": "def lis_length(arr):\n    \"\"\"Find length of longest increasing subsequence\n    \n    Args:\n        arr: List of integers\n    Returns:\n        Length of LIS\n    \"\"\"\n    pass\n\nprint(lis_length([10, 9, 2, 5, 3, 7, 101, 18]))",
    "solution": "def lis_length(arr):\n    \"\"\"Find length of longest increasing subsequence\n    \n    Args:\n        arr: List of integers\n    Returns:\n        Length of LIS\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nprint(lis_length([10, 9, 2, 5, 3, 7, 101, 18]))",
    "testCases": [
      {
        "input": "[10, 9, 2, 5, 3, 7, 101, 18]",
        "isHidden": false,
        "description": "LIS = 4"
      },
      {
        "input": "[0, 1, 0, 3, 2, 3]",
        "isHidden": false,
        "description": "LIS = 4"
      },
      {
        "input": "[7, 7, 7, 7]",
        "isHidden": true,
        "description": "All same: LIS = 1"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "isHidden": true,
        "description": "Sorted: LIS = 5"
      }
    ],
    "hints": [
      "dp[i] = longest LIS ending at i",
      "Check all previous elements"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex13",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Edit Distance",
    "difficulty": 5,
    "description": "Calculate the minimum edit distance (Levenshtein distance) between two strings. Use recurrence: dp[i][j] = min(insert, delete, replace) operations.",
    "starterCode": "def edit_distance(s1, s2):\n    \"\"\"Calculate edit distance between two strings\n    \n    Args:\n        s1, s2: Input strings\n    Returns:\n        Minimum number of operations\n    \"\"\"\n    pass\n\nprint(edit_distance(\"kitten\", \"sitting\"))",
    "solution": "def edit_distance(s1, s2):\n    \"\"\"Calculate edit distance between two strings\n    \n    Args:\n        s1, s2: Input strings\n    Returns:\n        Minimum number of operations\n    \"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]\n\nprint(edit_distance(\"kitten\", \"sitting\"))",
    "testCases": [
      {
        "input": "\"kitten\", \"sitting\"",
        "isHidden": false,
        "description": "Distance = 3"
      },
      {
        "input": "\"abc\", \"abc\"",
        "isHidden": false,
        "description": "Same string: 0"
      },
      {
        "input": "\"\", \"test\"",
        "isHidden": true,
        "description": "Empty to test: 4"
      },
      {
        "input": "\"intention\", \"execution\"",
        "isHidden": true,
        "description": "Distance = 5"
      }
    ],
    "hints": [
      "2D DP table",
      "If chars match, no operation needed"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex14",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Generating Functions: Partitions",
    "difficulty": 5,
    "description": "Count the number of ways to partition n into positive integers (order doesn't matter). Use dynamic programming.",
    "starterCode": "def partition_count(n):\n    \"\"\"Count integer partitions of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of partitions\n    \"\"\"\n    pass\n\nprint(partition_count(5))",
    "solution": "def partition_count(n):\n    \"\"\"Count integer partitions of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of partitions\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[j] += dp[j - i]\n    \n    return dp[n]\n\nprint(partition_count(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "p(5) = 7"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "p(10) = 42"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "p(20) = 627"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "p(1) = 1"
      }
    ],
    "hints": [
      "Use coins approach with coins = [1,2,...,n]",
      "Count ways, not minimum"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex15",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Matrix Chain Multiplication",
    "difficulty": 5,
    "description": "Find the minimum number of scalar multiplications needed to multiply a chain of matrices. Given dimensions, use dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost).",
    "starterCode": "def matrix_chain(dims):\n    \"\"\"Find minimum multiplications for matrix chain\n    \n    Args:\n        dims: List where matrix i has dimensions dims[i-1] x dims[i]\n    Returns:\n        Minimum number of scalar multiplications\n    \"\"\"\n    pass\n\nprint(matrix_chain([10, 20, 30, 40, 30]))",
    "solution": "def matrix_chain(dims):\n    \"\"\"Find minimum multiplications for matrix chain\n    \n    Args:\n        dims: List where matrix i has dimensions dims[i-1] x dims[i]\n    Returns:\n        Minimum number of scalar multiplications\n    \"\"\"\n    n = len(dims) - 1\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k+1][j] + dims[i]*dims[k+1]*dims[j+1]\n                dp[i][j] = min(dp[i][j], cost)\n    \n    return dp[0][n-1]\n\nprint(matrix_chain([10, 20, 30, 40, 30]))",
    "testCases": [
      {
        "input": "[10, 20, 30, 40, 30]",
        "isHidden": false,
        "description": "4 matrices"
      },
      {
        "input": "[10, 30, 5, 60]",
        "isHidden": false,
        "description": "3 matrices: 4500"
      },
      {
        "input": "[40, 20, 30, 10, 30]",
        "isHidden": true,
        "description": "4 matrices"
      },
      {
        "input": "[10, 20, 30]",
        "isHidden": true,
        "description": "2 matrices: 6000"
      }
    ],
    "hints": [
      "Try all split points k between i and j",
      "Cost: dims[i]*dims[k+1]*dims[j+1]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex16",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Advanced Recurrence Solving",
    "difficulty": 5,
    "description": "Solve the recurrence T(n) = 3T(n/4) + n*log(n) and determine its time complexity using the Master Theorem.",
    "starterCode": "import math\n\ndef analyze_recurrence(n):\n    \"\"\"Analyze T(n) = 3T(n/4) + n*log(n)\n    \n    Args:\n        n: Input size\n    Returns:\n        Tuple (complexity_class, log_b_a)\n    \"\"\"\n    pass\n\nprint(analyze_recurrence(1024))",
    "solution": "import math\n\ndef analyze_recurrence(n):\n    \"\"\"Analyze T(n) = 3T(n/4) + n*log(n)\n    \n    Args:\n        n: Input size\n    Returns:\n        Tuple (complexity_class, log_b_a)\n    \"\"\"\n    a, b = 3, 4\n    log_b_a = math.log(a) / math.log(b)\n    # f(n) = n*log(n), which is Theta(n^1 * log(n))\n    # log_b_a ≈ 0.79, so f(n) is polynomially larger\n    # Master Theorem Case 3: T(n) = Theta(f(n)) = Theta(n*log(n))\n    \n    return f\"O(n log n), log_b(a) = {log_b_a:.3f}\", log_b_a\n\nprint(analyze_recurrence(1024))",
    "testCases": [
      {
        "input": "1024",
        "isHidden": false,
        "description": "Analyze with n=1024"
      },
      {
        "input": "256",
        "isHidden": false,
        "description": "Analyze with n=256"
      },
      {
        "input": "4096",
        "isHidden": true,
        "description": "Larger input"
      },
      {
        "input": "64",
        "isHidden": true,
        "description": "Smaller input"
      }
    ],
    "hints": [
      "a=3, b=4, so log_4(3) ≈ 0.79",
      "f(n) = n*log(n) is Case 3 (f grows faster)"
    ],
    "language": "python"
  }
]

[
  {
    "id": "math102-exam-midterm",
    "subjectId": "math102",
    "title": "Math102 Midterm",
    "durationMinutes": 75,
    "instructions": [
      "Closed-book style: rely on concepts, not copy/paste.",
      "Answer all questions; passing is 70% or higher.",
      "Fill-in questions expect lowercase, trimmed answers.",
      "Show your reasoning for written problems."
    ],
    "questions": [
      {
        "id": "mid-q1",
        "type": "multiple_choice",
        "prompt": "How many ways can you arrange the letters in the word \"MATH\"?",
        "options": [
          "4",
          "8",
          "16",
          "24"
        ],
        "correctAnswer": 3,
        "explanation": "With 4 distinct letters, the number of permutations is 4! = 24."
      },
      {
        "id": "mid-q2",
        "type": "multiple_choice",
        "prompt": "How many ways can you choose 3 students from a class of 10?",
        "options": [
          "30",
          "120",
          "720",
          "1000"
        ],
        "correctAnswer": 1,
        "explanation": "This is C(10,3) = 10!/(3!×7!) = 120 combinations."
      },
      {
        "id": "mid-q3",
        "type": "fill_blank",
        "prompt": "The principle that states \"if n objects are placed into k containers with n > k, then at least one container must contain more than one object\" is called the ____ principle.",
        "correctAnswer": "pigeonhole",
        "explanation": "The Pigeonhole Principle is fundamental in combinatorics for proving existence results."
      },
      {
        "id": "mid-q4",
        "type": "true_false",
        "prompt": "In the inclusion-exclusion principle, to count |A ∪ B|, we compute |A| + |B| - |A ∩ B|.",
        "correctAnswer": true,
        "explanation": "The inclusion-exclusion principle for two sets subtracts the intersection to avoid double-counting."
      },
      {
        "id": "mid-q5",
        "type": "multiple_choice",
        "prompt": "How many permutations of the letters in \"MISSISSIPPI\" are there?",
        "options": [
          "39,916,800",
          "34,650",
          "277,200",
          "11!"
        ],
        "correctAnswer": 1,
        "explanation": "With repeated letters (M:1, I:4, S:4, P:2), the answer is 11!/(1!×4!×4!×2!) = 34,650."
      },
      {
        "id": "mid-q6",
        "type": "code_output",
        "prompt": "What does this Python code print?",
        "codeSnippet": "from math import factorial\n\ndef binomial(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\nprint(binomial(5, 2))",
        "correctAnswer": "10",
        "explanation": "C(5,2) = 5!/(2!×3!) = 10 ways to choose 2 items from 5."
      },
      {
        "id": "mid-q7",
        "type": "written",
        "prompt": "If you have 5 pigeons and 3 pigeonholes, what is the minimum number of pigeons that must be in at least one pigeonhole? Explain your reasoning.",
        "correctAnswer": "minimum",
        "explanation": "By the Pigeonhole Principle, at least ⌈5/3⌉ = 2 pigeons must be in one hole.",
        "modelAnswer": "By the Pigeonhole Principle, if we distribute 5 pigeons into 3 pigeonholes, at least one pigeonhole must contain at least ⌈5/3⌉ = ⌈1.67⌉ = 2 pigeons. This is because if each pigeonhole had at most 1 pigeon, we could accommodate at most 3 pigeons total, but we have 5. Therefore, the minimum number of pigeons that must be in at least one pigeonhole is 2."
      },
      {
        "id": "mid-q8",
        "type": "multiple_choice",
        "prompt": "What is the closed-form solution to the recurrence T(n) = T(n-1) + 1 with T(0) = 0?",
        "options": [
          "T(n) = n²",
          "T(n) = n",
          "T(n) = 2ⁿ",
          "T(n) = log n"
        ],
        "correctAnswer": 1,
        "explanation": "This recurrence adds 1 at each step, so T(n) = n."
      },
      {
        "id": "mid-q9",
        "type": "fill_blank",
        "prompt": "The Fibonacci sequence is defined by F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = ____.",
        "correctAnswer": "1",
        "explanation": "The standard Fibonacci sequence has F(0) = 0 and F(1) = 1."
      },
      {
        "id": "mid-q10",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "def T(n):\n    if n == 0:\n        return 2\n    return 3 * T(n - 1)\n\nprint(T(3))",
        "correctAnswer": "54",
        "explanation": "T(3) = 3×T(2) = 3×3×T(1) = 3×3×3×T(0) = 3×3×3×2 = 54."
      },
      {
        "id": "mid-q11",
        "type": "multiple_choice",
        "prompt": "Using the Master Theorem, what is the time complexity of T(n) = 2T(n/2) + n?",
        "options": [
          "O(n)",
          "O(n log n)",
          "O(n²)",
          "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "With a=2, b=2, f(n)=n, we have n^(log₂2) = n and f(n)=Θ(n), so by case 2, T(n) = Θ(n log n)."
      },
      {
        "id": "mid-q12",
        "type": "true_false",
        "prompt": "The recurrence T(n) = T(n-1) + n has a closed-form solution of T(n) = n(n+1)/2.",
        "correctAnswer": true,
        "explanation": "This recurrence sums 1+2+...+n, which equals n(n+1)/2."
      },
      {
        "id": "mid-q13",
        "type": "written",
        "prompt": "Solve the recurrence T(n) = 4T(n/2) + n using the Master Theorem. Show which case applies and give the final complexity.",
        "correctAnswer": "master",
        "explanation": "With a=4, b=2, f(n)=n, we have n^(log₂4) = n². Since f(n)=O(n²⁻ᵋ), case 1 applies.",
        "modelAnswer": "For T(n) = 4T(n/2) + n, we use the Master Theorem with a=4, b=2, and f(n)=n. We compute n^(log_b a) = n^(log₂4) = n². Comparing f(n)=n with n²: since n = O(n²⁻ᵋ) for ε=1, we are in case 1 of the Master Theorem. Therefore, T(n) = Θ(n²)."
      },
      {
        "id": "mid-q14",
        "type": "multiple_choice",
        "prompt": "A graph with 5 vertices where every vertex has degree 2 has how many edges?",
        "options": [
          "5",
          "10",
          "7",
          "4"
        ],
        "correctAnswer": 0,
        "explanation": "By the Handshaking Lemma, sum of degrees = 2×|E|. So 5×2 = 10 = 2×|E|, giving |E| = 5."
      },
      {
        "id": "mid-q15",
        "type": "true_false",
        "prompt": "A tree with n vertices has exactly n-1 edges.",
        "correctAnswer": true,
        "explanation": "A tree is a connected acyclic graph, and every tree with n vertices has n-1 edges."
      },
      {
        "id": "mid-q16",
        "type": "fill_blank",
        "prompt": "A graph that can be colored with two colors such that no two adjacent vertices share the same color is called ____.",
        "correctAnswer": "bipartite",
        "explanation": "A bipartite graph can be partitioned into two sets with edges only between sets."
      },
      {
        "id": "mid-q17",
        "type": "multiple_choice",
        "prompt": "What is the maximum number of edges in a simple undirected graph with 6 vertices?",
        "options": [
          "12",
          "15",
          "18",
          "36"
        ],
        "correctAnswer": 1,
        "explanation": "A complete graph on n vertices has n(n-1)/2 edges. For n=6: 6×5/2 = 15."
      },
      {
        "id": "mid-q18",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "# adjacency list representation\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A'],\n    'D': ['B']\n}\n\nprint(sum(len(neighbors) for neighbors in graph.values()) // 2)",
        "correctAnswer": "3",
        "explanation": "Sum of degrees is 2+2+1+1=6. Number of edges = 6/2 = 3."
      },
      {
        "id": "mid-q19",
        "type": "true_false",
        "prompt": "Every tree is a bipartite graph.",
        "correctAnswer": true,
        "explanation": "Trees have no odd cycles, so they can always be 2-colored and are bipartite."
      },
      {
        "id": "mid-q20",
        "type": "written",
        "prompt": "Prove that in any graph, the number of vertices with odd degree is even.",
        "correctAnswer": "handshaking",
        "explanation": "By the Handshaking Lemma, the sum of all degrees equals 2|E|, which is even.",
        "modelAnswer": "By the Handshaking Lemma, the sum of all vertex degrees equals 2|E|, which is always even. If we partition vertices into those with even degree and those with odd degree, the sum of even-degree vertices is even. Since the total sum is even, the sum of odd-degree vertices must also be even. But the sum of an odd number of odd integers is odd, so there must be an even number of vertices with odd degree."
      },
      {
        "id": "mid-q21",
        "type": "multiple_choice",
        "prompt": "What is the time complexity of BFS on a graph with V vertices and E edges using an adjacency list?",
        "options": [
          "O(V)",
          "O(E)",
          "O(V + E)",
          "O(V × E)"
        ],
        "correctAnswer": 2,
        "explanation": "BFS visits each vertex once and explores each edge once, giving O(V + E)."
      },
      {
        "id": "mid-q22",
        "type": "fill_blank",
        "prompt": "Dijkstra's algorithm finds the shortest paths from a source vertex to all other vertices in a graph with ____ edge weights.",
        "correctAnswer": "non-negative",
        "explanation": "Dijkstra's algorithm requires non-negative edge weights to work correctly."
      },
      {
        "id": "mid-q23",
        "type": "multiple_choice",
        "prompt": "Which algorithm would you use to find a minimum spanning tree?",
        "options": [
          "BFS",
          "DFS",
          "Kruskal's or Prim's",
          "Dijkstra's"
        ],
        "correctAnswer": 2,
        "explanation": "Kruskal's and Prim's algorithms are specifically designed to find minimum spanning trees."
      },
      {
        "id": "mid-q24",
        "type": "true_false",
        "prompt": "DFS can be used to detect cycles in a directed graph.",
        "correctAnswer": true,
        "explanation": "DFS detects back edges, which indicate cycles in directed graphs."
      },
      {
        "id": "mid-q25",
        "type": "code_output",
        "prompt": "What order does DFS visit vertices starting from A?",
        "codeSnippet": "# DFS visits first neighbor first\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': [],\n    'D': []\n}\n\n# Assume alphabetical tie-breaking\n# Print: A B D C",
        "correctAnswer": "A B D C",
        "explanation": "DFS explores deeply: A → B → D (backtrack) → C."
      },
      {
        "id": "mid-q26",
        "type": "written",
        "prompt": "Explain the difference between BFS and DFS in terms of the data structure used and the order of exploration.",
        "correctAnswer": "queue",
        "explanation": "BFS uses a queue (level-by-level), DFS uses a stack (depth-first).",
        "modelAnswer": "BFS (Breadth-First Search) uses a queue data structure and explores vertices level by level, visiting all neighbors of a vertex before moving to their neighbors. DFS (Depth-First Search) uses a stack (or recursion, which uses the call stack) and explores as deeply as possible along each branch before backtracking. BFS finds shortest paths in unweighted graphs, while DFS is useful for topological sorting and cycle detection."
      }
    ]
  },
  {
    "id": "math102-exam-final",
    "subjectId": "math102",
    "title": "Math102 Final Exam",
    "durationMinutes": 120,
    "instructions": [
      "Comprehensive exam covering all course topics.",
      "Mix of multiple choice, code reading, short answers, and written problems.",
      "Assume standard mathematical definitions and conventions.",
      "Aim for at least 70% to pass."
    ],
    "questions": [
      {
        "id": "final-q1",
        "type": "multiple_choice",
        "prompt": "How many 4-digit PIN codes are possible if digits can repeat?",
        "options": [
          "5040",
          "10000",
          "1024",
          "40"
        ],
        "correctAnswer": 1,
        "explanation": "With 10 choices for each of 4 positions: 10⁴ = 10,000."
      },
      {
        "id": "final-q2",
        "type": "fill_blank",
        "prompt": "The number of ways to arrange n distinct objects is n! which is read as \"n ____\".",
        "correctAnswer": "factorial",
        "explanation": "The factorial function n! = n × (n-1) × ... × 2 × 1."
      },
      {
        "id": "final-q3",
        "type": "multiple_choice",
        "prompt": "Using the inclusion-exclusion principle, how many integers from 1 to 100 are divisible by 2 or 3?",
        "options": [
          "50",
          "67",
          "83",
          "33"
        ],
        "correctAnswer": 1,
        "explanation": "|A∪B| = |A| + |B| - |A∩B| = 50 + 33 - 16 = 67."
      },
      {
        "id": "final-q4",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "from math import comb\n\n# Choosing 2 items from 7\nprint(comb(7, 2))",
        "correctAnswer": "21",
        "explanation": "C(7,2) = 7!/(2!×5!) = 21."
      },
      {
        "id": "final-q5",
        "type": "true_false",
        "prompt": "The number of permutations of n objects is always greater than or equal to the number of combinations.",
        "correctAnswer": true,
        "explanation": "P(n,k) = k! × C(n,k), so permutations ≥ combinations (equality when k=1)."
      },
      {
        "id": "final-q6",
        "type": "written",
        "prompt": "How many ways can you distribute 10 identical candies to 3 children such that each child gets at least one candy?",
        "correctAnswer": "stars",
        "explanation": "This is stars and bars with constraints: C(9,2) = 36.",
        "modelAnswer": "First give each child 1 candy, leaving 7 candies to distribute freely. Using the stars and bars formula for distributing k identical items to n recipients: C(k+n-1, n-1). Here we distribute 7 candies to 3 children: C(7+3-1, 3-1) = C(9, 2) = 36 ways."
      },
      {
        "id": "final-q7",
        "type": "multiple_choice",
        "prompt": "What is F(7) in the Fibonacci sequence where F(0)=0, F(1)=1?",
        "options": [
          "8",
          "13",
          "21",
          "34"
        ],
        "correctAnswer": 1,
        "explanation": "F(7) = 0,1,1,2,3,5,8,13. The 7th Fibonacci number is 13."
      },
      {
        "id": "final-q8",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "def mystery(n):\n    if n <= 1:\n        return 1\n    return mystery(n-1) + mystery(n-2)\n\nprint(mystery(5))",
        "correctAnswer": "8",
        "explanation": "This is the Fibonacci sequence with F(0)=F(1)=1. F(5) = 8."
      },
      {
        "id": "final-q9",
        "type": "fill_blank",
        "prompt": "The ____ Theorem is used to solve divide-and-conquer recurrences of the form T(n) = aT(n/b) + f(n).",
        "correctAnswer": "master",
        "explanation": "The Master Theorem provides solutions for common divide-and-conquer recurrence patterns."
      },
      {
        "id": "final-q10",
        "type": "multiple_choice",
        "prompt": "Using the Master Theorem, what is the complexity of T(n) = T(n/2) + O(1)?",
        "options": [
          "O(1)",
          "O(log n)",
          "O(n)",
          "O(n log n)"
        ],
        "correctAnswer": 1,
        "explanation": "With a=1, b=2, f(n)=O(1), we have n^(log₂1)=1 and f(n)=Θ(1), so case 2: T(n)=Θ(log n)."
      },
      {
        "id": "final-q11",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "def T(n):\n    if n == 1:\n        return 1\n    return T(n // 2) + n\n\nprint(T(8))",
        "correctAnswer": "15",
        "explanation": "T(8) = T(4)+8 = T(2)+4+8 = T(1)+2+4+8 = 1+2+4+8 = 15."
      },
      {
        "id": "final-q12",
        "type": "written",
        "prompt": "Solve the recurrence T(n) = 2T(n-1) + 1 with T(0) = 1. Find the closed-form solution.",
        "correctAnswer": "geometric",
        "explanation": "This is a linear recurrence: T(n) = 2ⁿ⁺¹ - 1.",
        "modelAnswer": "Expanding: T(n) = 2T(n-1) + 1 = 2(2T(n-2) + 1) + 1 = 4T(n-2) + 2 + 1 = ... = 2ⁿT(0) + (2ⁿ⁻¹ + 2ⁿ⁻² + ... + 2 + 1). With T(0)=1, we get T(n) = 2ⁿ + (2ⁿ - 1) = 2ⁿ⁺¹ - 1."
      },
      {
        "id": "final-q13",
        "type": "true_false",
        "prompt": "A complete graph on n vertices has n(n-1)/2 edges.",
        "correctAnswer": true,
        "explanation": "In a complete graph, every pair of vertices is connected: C(n,2) = n(n-1)/2."
      },
      {
        "id": "final-q14",
        "type": "multiple_choice",
        "prompt": "Which of the following is NOT a property of trees?",
        "options": [
          "Connected",
          "Acyclic",
          "Has n-1 edges for n vertices",
          "Must be bipartite"
        ],
        "correctAnswer": 3,
        "explanation": "All trees are bipartite (no odd cycles), so \"must be bipartite\" IS a property. This is a trick question - all options are true properties."
      },
      {
        "id": "final-q15",
        "type": "fill_blank",
        "prompt": "The ____ Lemma states that the sum of all vertex degrees equals twice the number of edges.",
        "correctAnswer": "handshaking",
        "explanation": "The Handshaking Lemma: Σdeg(v) = 2|E|."
      },
      {
        "id": "final-q16",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "# Check if graph is bipartite\ndef is_bipartite(graph):\n    color = {}\n    for start in graph:\n        if start in color:\n            continue\n        queue = [start]\n        color[start] = 0\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if neighbor not in color:\n                    color[neighbor] = 1 - color[node]\n                    queue.append(neighbor)\n                elif color[neighbor] == color[node]:\n                    return False\n    return True\n\ngraph = {'A': ['B'], 'B': ['A', 'C'], 'C': ['B']}\nprint(is_bipartite(graph))",
        "correctAnswer": "True",
        "explanation": "The graph is a path A-B-C, which is bipartite (color A and C with 0, B with 1)."
      },
      {
        "id": "final-q17",
        "type": "multiple_choice",
        "prompt": "A graph with 10 vertices and 12 edges must contain at least how many cycles?",
        "options": [
          "0",
          "1",
          "2",
          "3"
        ],
        "correctAnswer": 3,
        "explanation": "A tree has n-1=9 edges. With 12 edges, we have 12-9=3 extra edges, creating at least 3 independent cycles."
      },
      {
        "id": "final-q18",
        "type": "written",
        "prompt": "Explain what it means for a graph to be bipartite and give an example of a graph that is NOT bipartite.",
        "correctAnswer": "partition",
        "explanation": "A graph is bipartite if vertices can be split into two sets with no edges within sets.",
        "modelAnswer": "A graph is bipartite if its vertices can be partitioned into two disjoint sets such that every edge connects a vertex from one set to a vertex in the other set (no edges within the same set). Equivalently, a graph is bipartite if and only if it contains no odd-length cycles. Example of a non-bipartite graph: a triangle (3-cycle) with vertices {A,B,C} and edges {AB,BC,CA} cannot be 2-colored because it has an odd cycle."
      },
      {
        "id": "final-q19",
        "type": "multiple_choice",
        "prompt": "What is the time complexity of Dijkstra's algorithm using a binary heap?",
        "options": [
          "O(V²)",
          "O(E log V)",
          "O(V + E)",
          "(V log V + E log V)"
        ],
        "correctAnswer": 3,
        "explanation": "Using a binary heap: O((V + E) log V), often written as O(E log V) for connected graphs."
      },
      {
        "id": "final-q20",
        "type": "fill_blank",
        "prompt": "Kruskal's algorithm for finding a minimum spanning tree sorts edges by ____ and adds them if they don't create a cycle.",
        "correctAnswer": "weight",
        "explanation": "Kruskal's algorithm processes edges in increasing order of weight."
      },
      {
        "id": "final-q21",
        "type": "true_false",
        "prompt": "BFS always finds the shortest path in a weighted graph.",
        "correctAnswer": false,
        "explanation": "BFS finds shortest paths only in unweighted graphs. For weighted graphs, use Dijkstra's."
      },
      {
        "id": "final-q22",
        "type": "code_output",
        "prompt": "In what order does BFS visit vertices starting from A?",
        "codeSnippet": "from collections import deque\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': ['D'],\n    'D': []\n}\n\n# BFS from A (alphabetical order)\n# Output: A B C D",
        "correctAnswer": "A B C D",
        "explanation": "BFS visits level-by-level: A, then B and C (neighbors of A), then D (neighbor of B and C)."
      },
      {
        "id": "final-q23",
        "type": "multiple_choice",
        "prompt": "Which data structure does Prim's algorithm use to efficiently select the minimum-weight edge?",
        "options": [
          "Queue",
          "Stack",
          "Priority Queue",
          "Hash Table"
        ],
        "correctAnswer": 2,
        "explanation": "Prim's algorithm uses a priority queue (min-heap) to efficiently extract the minimum-weight edge."
      },
      {
        "id": "final-q24",
        "type": "written",
        "prompt": "Explain when you would use DFS versus BFS for graph traversal. Give an example use case for each.",
        "correctAnswer": "traversal",
        "explanation": "DFS for deep exploration (topological sort), BFS for shortest paths (unweighted).",
        "modelAnswer": "Use DFS when you need to explore deeply or detect cycles in directed graphs, perform topological sorting, or find strongly connected components. Example: checking if a path exists in a maze by exploring as far as possible. Use BFS when you need shortest paths in unweighted graphs or level-order traversal. Example: finding the minimum number of hops between two people in a social network."
      },
      {
        "id": "final-q25",
        "type": "multiple_choice",
        "prompt": "What is gcd(48, 18) using the Euclidean algorithm?",
        "options": [
          "2",
          "3",
          "6",
          "12"
        ],
        "correctAnswer": 2,
        "explanation": "gcd(48,18) = gcd(18,12) = gcd(12,6) = gcd(6,0) = 6."
      },
      {
        "id": "final-q26",
        "type": "fill_blank",
        "prompt": "In modular arithmetic, a ≡ b (mod n) means that n divides ____.",
        "correctAnswer": "a-b",
        "explanation": "a ≡ b (mod n) means n | (a-b), or equivalently, a and b have the same remainder when divided by n."
      },
      {
        "id": "final-q27",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nprint(gcd(56, 98))",
        "correctAnswer": "14",
        "explanation": "gcd(56,98) = gcd(98,56) = gcd(56,42) = gcd(42,14) = gcd(14,0) = 14."
      },
      {
        "id": "final-q28",
        "type": "true_false",
        "prompt": "The number 1 is considered a prime number.",
        "correctAnswer": false,
        "explanation": "1 is not prime by definition. Primes must have exactly two distinct divisors."
      },
      {
        "id": "final-q29",
        "type": "multiple_choice",
        "prompt": "What is 17 mod 5?",
        "options": [
          "2",
          "3",
          "4",
          "5"
        ],
        "correctAnswer": 0,
        "explanation": "17 = 3×5 + 2, so 17 mod 5 = 2."
      },
      {
        "id": "final-q30",
        "type": "written",
        "prompt": "Use the Chinese Remainder Theorem to find x such that x ≡ 2 (mod 3) and x ≡ 3 (mod 5).",
        "correctAnswer": "remainder",
        "explanation": "x = 8 satisfies both congruences.",
        "modelAnswer": "We need x ≡ 2 (mod 3) and x ≡ 3 (mod 5). From the first: x = 3k + 2 for some integer k. Substituting into the second: 3k + 2 ≡ 3 (mod 5), so 3k ≡ 1 (mod 5). Trying values: k=2 works (3×2=6≡1). Thus k = 5m + 2, giving x = 3(5m + 2) + 2 = 15m + 8. The smallest positive solution is x = 8. Verify: 8 mod 3 = 2 ✓ and 8 mod 5 = 3 ✓."
      },
      {
        "id": "final-q31",
        "type": "fill_blank",
        "prompt": "The ____ numbers of the second kind count the number of ways to partition n elements into k non-empty subsets.",
        "correctAnswer": "stirling",
        "explanation": "Stirling numbers of the second kind S(n,k) count set partitions."
      },
      {
        "id": "final-q32",
        "type": "multiple_choice",
        "prompt": "How many ways can you partition the integer 4 into positive integers (order doesn't matter)?",
        "options": [
          "3",
          "4",
          "5",
          "8"
        ],
        "correctAnswer": 2,
        "explanation": "Partitions of 4: {4}, {3,1}, {2,2}, {2,1,1}, {1,1,1,1} = 5 ways."
      },
      {
        "id": "final-q33",
        "type": "true_false",
        "prompt": "Generating functions can be used to solve counting problems by encoding sequences as coefficients of power series.",
        "correctAnswer": true,
        "explanation": "Generating functions encode combinatorial sequences as coefficients, enabling algebraic manipulation."
      },
      {
        "id": "final-q34",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "# Stirling number S(n,k) - partitions of n into k subsets\ndef stirling2(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n == 0 or k == 0:\n        return 0\n    return k * stirling2(n-1, k) + stirling2(n-1, k-1)\n\nprint(stirling2(4, 2))",
        "correctAnswer": "7",
        "explanation": "S(4,2) = 7 ways to partition {1,2,3,4} into 2 non-empty subsets."
      },
      {
        "id": "final-q35",
        "type": "multiple_choice",
        "prompt": "What is the generating function for the sequence 1, 1, 1, 1, ...?",
        "options": [
          "1 + x + x² + x³ + ...",
          "1/(1-x)",
          "Both A and B",
          "eˣ"
        ],
        "correctAnswer": 2,
        "explanation": "The geometric series 1 + x + x² + ... = 1/(1-x) for |x| < 1."
      },
      {
        "id": "final-q36",
        "type": "written",
        "prompt": "Explain what a partition of an integer n is and give all partitions of n=5.",
        "correctAnswer": "partition",
        "explanation": "A partition is a way to write n as a sum of positive integers (order doesn't matter).",
        "modelAnswer": "A partition of an integer n is a way to write n as a sum of positive integers where order doesn't matter. For n=5, the partitions are: {5}, {4,1}, {3,2}, {3,1,1}, {2,2,1}, {2,1,1,1}, {1,1,1,1,1}. There are 7 partitions of 5, denoted p(5)=7."
      },
      {
        "id": "final-q37",
        "type": "multiple_choice",
        "prompt": "What is the probability of rolling a sum of 7 with two fair dice?",
        "options": [
          "1/12",
          "1/6",
          "1/4",
          "1/3"
        ],
        "correctAnswer": 1,
        "explanation": "There are 6 ways to roll 7: (1,6),(2,5),(3,4),(4,3),(5,2),(6,1) out of 36 total outcomes: 6/36 = 1/6."
      },
      {
        "id": "final-q38",
        "type": "fill_blank",
        "prompt": "The formula P(A|B) = P(A∩B)/P(B) defines ____ probability.",
        "correctAnswer": "conditional",
        "explanation": "This is the definition of conditional probability: the probability of A given B."
      },
      {
        "id": "final-q39",
        "type": "code_output",
        "prompt": "What does this code print?",
        "codeSnippet": "# Expected value of a die roll\noutcomes = [1, 2, 3, 4, 5, 6]\nprobability = 1/6\nexpected_value = sum(x * probability for x in outcomes)\nprint(expected_value)",
        "correctAnswer": "3.5",
        "explanation": "E[X] = (1+2+3+4+5+6)/6 = 21/6 = 3.5."
      },
      {
        "id": "final-q40",
        "type": "true_false",
        "prompt": "If events A and B are independent, then P(A∩B) = P(A) × P(B).",
        "correctAnswer": true,
        "explanation": "Independence means the occurrence of one event doesn't affect the other: P(A∩B) = P(A)P(B)."
      },
      {
        "id": "final-q41",
        "type": "multiple_choice",
        "prompt": "Using Bayes' Theorem, if P(A)=0.3, P(B|A)=0.8, and P(B)=0.5, what is P(A|B)?",
        "options": [
          "0.24",
          "0.48",
          "0.6",
          "0.8"
        ],
        "correctAnswer": 1,
        "explanation": "P(A|B) = P(B|A)×P(A)/P(B) = (0.8×0.3)/0.5 = 0.24/0.5 = 0.48."
      },
      {
        "id": "final-q42",
        "type": "written",
        "prompt": "A bag contains 3 red and 5 blue marbles. If you draw 2 marbles without replacement, what is the probability both are red?",
        "correctAnswer": "without",
        "explanation": "P(both red) = (3/8) × (2/7) = 6/56 = 3/28.",
        "modelAnswer": "Without replacement: P(first red) = 3/8. Given first is red, P(second red) = 2/7. Therefore, P(both red) = P(first red) × P(second red | first red) = (3/8) × (2/7) = 6/56 = 3/28 ≈ 0.107 or about 10.7%."
      }
    ]
  }
]
[
  {
    "id": "math102-e1",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Combinations Calculator",
    "difficulty": 2,
    "description": "Implement a function that calculates the binomial coefficient C(n,k), also known as \"n choose k\". This represents the number of ways to choose k items from n items without regard to order. Use the formula C(n,k) = n! / (k! × (n-k)!), but optimize to avoid computing large factorials by canceling terms.",
    "starterCode": "def combinations(n, k):\n    \"\"\"Calculate C(n,k) = n! / (k! * (n-k)!)\n    \n    Args:\n        n: Total number of items\n        k: Number of items to choose\n        \n    Returns:\n        Number of ways to choose k items from n items\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def combinations(n, k):\n    \"\"\"Calculate C(n,k) = n! / (k! * (n-k)!)\n    \n    Args:\n        n: Total number of items\n        k: Number of items to choose\n        \n    Returns:\n        Number of ways to choose k items from n items\n    \"\"\"\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Optimize by using smaller k\n    k = min(k, n - k)\n    \n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    \n    return result",
    "testCases": [
      {
        "input": "5, 2",
        "isHidden": false,
        "description": "C(5,2) = 10"
      },
      {
        "input": "10, 3",
        "isHidden": false,
        "description": "C(10,3) = 120"
      },
      {
        "input": "20, 10",
        "isHidden": true,
        "description": "Large combination C(20,10)"
      },
      {
        "input": "5, 0",
        "isHidden": true,
        "description": "Edge case: k=0"
      },
      {
        "input": "5, 5",
        "isHidden": true,
        "description": "Edge case: k=n"
      }
    ],
    "hints": [
      "Remember that C(n,k) = C(n, n-k), so you can optimize by using the smaller value",
      "To avoid overflow, multiply and divide alternately rather than computing factorials separately",
      "Handle edge cases: C(n,0) = 1, C(n,n) = 1, and C(n,k) = 0 if k > n"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex02",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Factorial Function",
    "difficulty": 1,
    "description": "Implement a function to calculate n! (n factorial). Use iteration for efficiency.",
    "starterCode": "def factorial(n):\n    \"\"\"Calculate n! = n × (n-1) × ... × 2 × 1\n    \n    Args:\n        n: Non-negative integer\n    Returns:\n        n factorial\n    \"\"\"\n    pass\n\nprint(factorial(5))",
    "solution": "def factorial(n):\n    \"\"\"Calculate n! = n × (n-1) × ... × 2 × 1\n    \n    Args:\n        n: Non-negative integer\n    Returns:\n        n factorial\n    \"\"\"\n    if n < 0:\n        return None\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\nprint(factorial(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "5! = 120"
      },
      {
        "input": "0",
        "isHidden": false,
        "description": "0! = 1"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "10! = 3628800"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "1! = 1"
      }
    ],
    "hints": [
      "0! = 1 by definition",
      "Multiply from 2 to n"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex03",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Permutations",
    "difficulty": 2,
    "description": "Calculate P(n,r) - the number of permutations of n items taken r at a time. P(n,r) = n!/(n-r)!",
    "starterCode": "def permutations(n, r):\n    \"\"\"Calculate P(n,r) = n!/(n-r)!\n    \n    Args:\n        n: Total items\n        r: Items to arrange\n    Returns:\n        Number of permutations\n    \"\"\"\n    pass\n\nprint(permutations(5, 3))",
    "solution": "def permutations(n, r):\n    \"\"\"Calculate P(n,r) = n!/(n-r)!\n    \n    Args:\n        n: Total items\n        r: Items to arrange\n    Returns:\n        Number of permutations\n    \"\"\"\n    if r > n or r < 0:\n        return 0\n    result = 1\n    for i in range(n, n - r, -1):\n        result *= i\n    return result\n\nprint(permutations(5, 3))",
    "testCases": [
      {
        "input": "5, 3",
        "isHidden": false,
        "description": "P(5,3) = 60"
      },
      {
        "input": "10, 2",
        "isHidden": false,
        "description": "P(10,2) = 90"
      },
      {
        "input": "7, 7",
        "isHidden": true,
        "description": "P(n,n) = n!"
      },
      {
        "input": "5, 0",
        "isHidden": true,
        "description": "P(n,0) = 1"
      }
    ],
    "hints": [
      "P(n,r) = n × (n-1) × ... × (n-r+1)",
      "Multiply r consecutive integers starting from n"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex04",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Pascal's Triangle Row",
    "difficulty": 2,
    "description": "Generate the nth row of Pascal's Triangle. Each element is the sum of the two elements above it.",
    "starterCode": "def pascal_row(n):\n    \"\"\"Generate the nth row of Pascal's Triangle (0-indexed)\n    \n    Args:\n        n: Row number (0-indexed)\n    Returns:\n        List of binomial coefficients\n    \"\"\"\n    pass\n\nprint(pascal_row(4))",
    "solution": "def pascal_row(n):\n    \"\"\"Generate the nth row of Pascal's Triangle (0-indexed)\n    \n    Args:\n        n: Row number (0-indexed)\n    Returns:\n        List of binomial coefficients\n    \"\"\"\n    row = [1]\n    for k in range(1, n + 1):\n        row.append(row[-1] * (n - k + 1) // k)\n    return row\n\nprint(pascal_row(4))",
    "testCases": [
      {
        "input": "4",
        "isHidden": false,
        "description": "Row 4: [1, 4, 6, 4, 1]"
      },
      {
        "input": "0",
        "isHidden": false,
        "description": "Row 0: [1]"
      },
      {
        "input": "6",
        "isHidden": true,
        "description": "Row 6"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "Row 10"
      }
    ],
    "hints": [
      "Each element C(n,k) = C(n,k-1) × (n-k+1) / k",
      "Build iteratively from previous element"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex05",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Counting with Repetition",
    "difficulty": 3,
    "description": "Calculate the number of permutations of a multiset (permutations with repetitions). Given a string, count distinct arrangements.",
    "starterCode": "from math import factorial\nfrom collections import Counter\n\ndef multiset_permutations(s):\n    \"\"\"Count distinct permutations of string s\n    \n    Args:\n        s: String (may have repeated characters)\n    Returns:\n        Number of distinct permutations\n    \"\"\"\n    pass\n\nprint(multiset_permutations(\"MISSISSIPPI\"))",
    "solution": "from math import factorial\nfrom collections import Counter\n\ndef multiset_permutations(s):\n    \"\"\"Count distinct permutations of string s\n    \n    Args:\n        s: String (may have repeated characters)\n    Returns:\n        Number of distinct permutations\n    \"\"\"\n    counts = Counter(s)\n    n = len(s)\n    result = factorial(n)\n    for count in counts.values():\n        result //= factorial(count)\n    return result\n\nprint(multiset_permutations(\"MISSISSIPPI\"))",
    "testCases": [
      {
        "input": "\"MISSISSIPPI\"",
        "isHidden": false,
        "description": "MISSISSIPPI: 34650"
      },
      {
        "input": "\"AAB\"",
        "isHidden": false,
        "description": "AAB: 3"
      },
      {
        "input": "\"ABCDE\"",
        "isHidden": true,
        "description": "All distinct: 5!"
      },
      {
        "input": "\"AAAA\"",
        "isHidden": true,
        "description": "All same: 1"
      }
    ],
    "hints": [
      "Formula: n! / (n₁! × n₂! × ... × nₖ!)",
      "Use Counter to count occurrences"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex06",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Stars and Bars",
    "difficulty": 3,
    "description": "Calculate the number of ways to distribute n identical items into k distinct bins. This is C(n+k-1, k-1).",
    "starterCode": "def distribute(n, k):\n    \"\"\"Count ways to put n identical items into k distinct bins\n    \n    Args:\n        n: Number of identical items\n        k: Number of distinct bins\n    Returns:\n        Number of distributions\n    \"\"\"\n    pass\n\nprint(distribute(5, 3))",
    "solution": "def distribute(n, k):\n    \"\"\"Count ways to put n identical items into k distinct bins\n    \n    Args:\n        n: Number of identical items\n        k: Number of distinct bins\n    Returns:\n        Number of distributions\n    \"\"\"\n    # This is C(n + k - 1, k - 1)\n    total = n + k - 1\n    choose = k - 1\n    \n    if choose < 0 or choose > total:\n        return 0\n    \n    result = 1\n    for i in range(choose):\n        result = result * (total - i) // (i + 1)\n    return result\n\nprint(distribute(5, 3))",
    "testCases": [
      {
        "input": "5, 3",
        "isHidden": false,
        "description": "5 items, 3 bins: 21 ways"
      },
      {
        "input": "3, 2",
        "isHidden": false,
        "description": "3 items, 2 bins: 4 ways"
      },
      {
        "input": "10, 4",
        "isHidden": true,
        "description": "10 items, 4 bins"
      },
      {
        "input": "0, 3",
        "isHidden": true,
        "description": "Edge: 0 items"
      }
    ],
    "hints": [
      "Stars and bars: think of n stars and k-1 bars",
      "Formula is C(n+k-1, k-1)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex07",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Derangements",
    "difficulty": 4,
    "description": "Calculate D(n), the number of derangements (permutations with no fixed points). D(n) = (n-1) × (D(n-1) + D(n-2)).",
    "starterCode": "def derangements(n):\n    \"\"\"Count permutations where no element is in its original position\n    \n    Args:\n        n: Number of elements\n    Returns:\n        Number of derangements\n    \"\"\"\n    pass\n\nprint(derangements(5))",
    "solution": "def derangements(n):\n    \"\"\"Count permutations where no element is in its original position\n    \n    Args:\n        n: Number of elements\n    Returns:\n        Number of derangements\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    \n    d_prev2 = 1  # D(0)\n    d_prev1 = 0  # D(1)\n    \n    for i in range(2, n + 1):\n        d_curr = (i - 1) * (d_prev1 + d_prev2)\n        d_prev2 = d_prev1\n        d_prev1 = d_curr\n    \n    return d_prev1\n\nprint(derangements(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "D(5) = 44"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "D(3) = 2"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "D(10) = 1334961"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "D(1) = 0"
      }
    ],
    "hints": [
      "D(0) = 1, D(1) = 0",
      "D(n) = (n-1) × (D(n-1) + D(n-2))"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex08",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Inclusion-Exclusion",
    "difficulty": 5,
    "description": "Count integers from 1 to n that are divisible by any of the given divisors using inclusion-exclusion principle.",
    "starterCode": "from math import gcd\nfrom functools import reduce\n\ndef count_divisible(n, divisors):\n    \"\"\"Count integers from 1 to n divisible by any divisor\n    \n    Args:\n        n: Upper limit\n        divisors: List of divisors\n    Returns:\n        Count of divisible integers\n    \"\"\"\n    pass\n\nprint(count_divisible(100, [2, 3, 5]))",
    "solution": "from math import gcd\nfrom functools import reduce\nfrom itertools import combinations\n\ndef count_divisible(n, divisors):\n    \"\"\"Count integers from 1 to n divisible by any divisor\n    \n    Args:\n        n: Upper limit\n        divisors: List of divisors\n    Returns:\n        Count of divisible integers\n    \"\"\"\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n    \n    total = 0\n    k = len(divisors)\n    \n    for r in range(1, k + 1):\n        for combo in combinations(divisors, r):\n            l = reduce(lcm, combo)\n            count = n // l\n            if r % 2 == 1:\n                total += count\n            else:\n                total -= count\n    \n    return total\n\nprint(count_divisible(100, [2, 3, 5]))",
    "testCases": [
      {
        "input": "100, [2, 3, 5]",
        "isHidden": false,
        "description": "Divisible by 2, 3, or 5"
      },
      {
        "input": "100, [2, 3]",
        "isHidden": false,
        "description": "Divisible by 2 or 3: 67"
      },
      {
        "input": "1000, [2, 3, 5, 7]",
        "isHidden": true,
        "description": "Larger range, 4 divisors"
      },
      {
        "input": "50, [6]",
        "isHidden": true,
        "description": "Single divisor"
      }
    ],
    "hints": [
      "|A ∪ B ∪ C| = |A| + |B| + |C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|",
      "Use LCM for intersections"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex09",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Binomial Coefficient Identity",
    "difficulty": 2,
    "description": "Verify Pascal's identity: C(n,k) = C(n-1,k-1) + C(n-1,k). Write a function that demonstrates this.",
    "starterCode": "def verify_pascal_identity(n, k):\n    \"\"\"Verify C(n,k) = C(n-1,k-1) + C(n-1,k)\n    \n    Returns:\n        Tuple (left_side, right_side, are_equal)\n    \"\"\"\n    pass\n\nprint(verify_pascal_identity(5, 2))",
    "solution": "from math import comb\n\ndef verify_pascal_identity(n, k):\n    \"\"\"Verify C(n,k) = C(n-1,k-1) + C(n-1,k)\n    \n    Returns:\n        Tuple (left_side, right_side, are_equal)\n    \"\"\"\n    if k < 1 or k >= n:\n        return None, None, False\n    \n    left = comb(n, k)\n    right = comb(n-1, k-1) + comb(n-1, k)\n    return left, right, left == right\n\nprint(verify_pascal_identity(5, 2))",
    "testCases": [
      {
        "input": "5, 2",
        "isHidden": false,
        "description": "C(5,2) = C(4,1) + C(4,2)"
      },
      {
        "input": "10, 3",
        "isHidden": false,
        "description": "Verify Pascal identity"
      },
      {
        "input": "20, 8",
        "isHidden": true,
        "description": "Large values"
      }
    ],
    "hints": [
      "Use Python's math.comb() or write your own",
      "Check edge cases where k=0 or k=n"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex10",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Counting Subsets by Size",
    "difficulty": 2,
    "description": "Count subsets of size k from a set of n elements. Also verify that sum of C(n,k) for k=0 to n equals 2^n.",
    "starterCode": "from math import comb\n\ndef subset_counts(n):\n    \"\"\"Return list of C(n,k) for k = 0 to n and verify sum = 2^n\n    \n    Returns:\n        Tuple (list of counts, total, 2^n, verified)\n    \"\"\"\n    pass\n\nprint(subset_counts(5))",
    "solution": "from math import comb\n\ndef subset_counts(n):\n    \"\"\"Return list of C(n,k) for k = 0 to n and verify sum = 2^n\n    \n    Returns:\n        Tuple (list of counts, total, 2^n, verified)\n    \"\"\"\n    counts = [comb(n, k) for k in range(n + 1)]\n    total = sum(counts)\n    expected = 2 ** n\n    return counts, total, expected, total == expected\n\nprint(subset_counts(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "Sum = 2^5 = 32"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "Sum = 2^4 = 16"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "Sum = 2^10 = 1024"
      }
    ],
    "hints": [
      "Use list comprehension",
      "The binomial theorem gives this identity"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex11",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Circular Permutations",
    "difficulty": 3,
    "description": "Count distinct circular arrangements of n people around a round table. In circular permutations, rotations are considered identical.",
    "starterCode": "from math import factorial\n\ndef circular_permutations(n):\n    \"\"\"Count circular arrangements of n distinct items\n    \n    Returns:\n        Number of distinct circular permutations\n    \"\"\"\n    pass\n\nprint(circular_permutations(5))",
    "solution": "from math import factorial\n\ndef circular_permutations(n):\n    \"\"\"Count circular arrangements of n distinct items\n    \n    Returns:\n        Number of distinct circular permutations\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return factorial(n - 1)\n\nprint(circular_permutations(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "(5-1)! = 24"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "(4-1)! = 6"
      },
      {
        "input": "8",
        "isHidden": true,
        "description": "(8-1)! = 5040"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "Single person: 1"
      }
    ],
    "hints": [
      "Fix one person's position, arrange the rest",
      "Answer is (n-1)!"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex12",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Multinomial Coefficient",
    "difficulty": 3,
    "description": "Calculate the multinomial coefficient (n; k1, k2, ..., km) = n! / (k1! × k2! × ... × km!).",
    "starterCode": "from math import factorial\n\ndef multinomial(n, groups):\n    \"\"\"Calculate multinomial coefficient\n    \n    Args:\n        n: Total items\n        groups: List of group sizes [k1, k2, ..., km]\n    Returns:\n        Multinomial coefficient\n    \"\"\"\n    pass\n\nprint(multinomial(10, [3, 3, 4]))",
    "solution": "from math import factorial\n\ndef multinomial(n, groups):\n    \"\"\"Calculate multinomial coefficient\n    \n    Args:\n        n: Total items\n        groups: List of group sizes [k1, k2, ..., km]\n    Returns:\n        Multinomial coefficient\n    \"\"\"\n    if sum(groups) != n:\n        return 0\n    \n    result = factorial(n)\n    for k in groups:\n        result //= factorial(k)\n    return result\n\nprint(multinomial(10, [3, 3, 4]))",
    "testCases": [
      {
        "input": "10, [3, 3, 4]",
        "isHidden": false,
        "description": "10!/(3!3!4!) = 4200"
      },
      {
        "input": "6, [2, 2, 2]",
        "isHidden": false,
        "description": "6!/(2!2!2!) = 90"
      },
      {
        "input": "12, [4, 4, 4]",
        "isHidden": true,
        "description": "Larger multinomial"
      },
      {
        "input": "5, [1, 1, 1, 1, 1]",
        "isHidden": true,
        "description": "All singletons: 5!"
      }
    ],
    "hints": [
      "Verify that groups sum to n",
      "Divide n! by product of factorials"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex13",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Necklace Counting",
    "difficulty": 4,
    "description": "Count distinct necklaces with n beads of 2 colors. Account for both rotations and reflections being equivalent.",
    "starterCode": "def count_necklaces(n):\n    \"\"\"Count distinct necklaces with n beads of 2 colors\n    \n    Uses Burnside's lemma (simplified for 2 colors)\n    \"\"\"\n    pass\n\nprint(count_necklaces(4))",
    "solution": "from math import gcd\n\ndef count_necklaces(n):\n    \"\"\"Count distinct necklaces with n beads of 2 colors\n    \n    Uses Burnside's lemma for dihedral group\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 2\n    \n    # Rotations contribution\n    rot_sum = sum(2 ** gcd(k, n) for k in range(n))\n    \n    # Reflections contribution\n    if n % 2 == 0:\n        ref_sum = (n // 2) * (2 ** (n // 2)) + (n // 2) * (2 ** (n // 2 + 1))\n    else:\n        ref_sum = n * (2 ** ((n + 1) // 2))\n    \n    return (rot_sum + ref_sum) // (2 * n)\n\nprint(count_necklaces(4))",
    "testCases": [
      {
        "input": "4",
        "isHidden": false,
        "description": "4-bead necklaces"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "3-bead necklaces: 4"
      },
      {
        "input": "6",
        "isHidden": true,
        "description": "6-bead necklaces"
      },
      {
        "input": "5",
        "isHidden": true,
        "description": "5-bead necklaces: 8"
      }
    ],
    "hints": [
      "Burnside's lemma: average over group actions",
      "Dihedral group has rotations and reflections"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex14",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Lattice Paths with Obstacles",
    "difficulty": 4,
    "description": "Count paths from (0,0) to (m,n) avoiding a blocked cell at (bx,by).",
    "starterCode": "from math import comb\n\ndef paths_avoiding(m, n, bx, by):\n    \"\"\"Count lattice paths avoiding blocked cell\n    \n    Args:\n        m, n: Target coordinates\n        bx, by: Blocked cell coordinates\n    Returns:\n        Number of valid paths\n    \"\"\"\n    pass\n\nprint(paths_avoiding(4, 4, 2, 2))",
    "solution": "from math import comb\n\ndef paths_avoiding(m, n, bx, by):\n    \"\"\"Count lattice paths avoiding blocked cell\n    \n    Args:\n        m, n: Target coordinates\n        bx, by: Blocked cell coordinates\n    Returns:\n        Number of valid paths\n    \"\"\"\n    # Total paths without restriction\n    total = comb(m + n, n)\n    \n    # Paths through blocked cell = paths to block × paths from block to end\n    if bx <= m and by <= n:\n        through_block = comb(bx + by, by) * comb((m - bx) + (n - by), n - by)\n    else:\n        through_block = 0\n    \n    return total - through_block\n\nprint(paths_avoiding(4, 4, 2, 2))",
    "testCases": [
      {
        "input": "4, 4, 2, 2",
        "isHidden": false,
        "description": "Avoid center cell"
      },
      {
        "input": "3, 3, 1, 1",
        "isHidden": false,
        "description": "3×3 grid, block (1,1)"
      },
      {
        "input": "5, 5, 3, 2",
        "isHidden": true,
        "description": "Larger grid"
      },
      {
        "input": "4, 4, 0, 0",
        "isHidden": true,
        "description": "Block origin"
      }
    ],
    "hints": [
      "Use complement: total - paths through block",
      "Paths through block = paths to block × paths from block"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex15",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Restricted Permutations",
    "difficulty": 4,
    "description": "Count permutations where certain elements cannot be in certain positions. Use inclusion-exclusion.",
    "starterCode": "from math import factorial\nfrom itertools import combinations\n\ndef restricted_perms(n, forbidden):\n    \"\"\"Count permutations with forbidden positions\n    \n    Args:\n        n: Number of elements\n        forbidden: List of (element, position) pairs that are forbidden\n    Returns:\n        Number of valid permutations\n    \"\"\"\n    pass\n\n# Element 0 can't be at position 0, element 1 can't be at position 1\nprint(restricted_perms(3, [(0, 0), (1, 1)]))",
    "solution": "from math import factorial\nfrom itertools import combinations\n\ndef restricted_perms(n, forbidden):\n    \"\"\"Count permutations with forbidden positions\n    \n    Args:\n        n: Number of elements\n        forbidden: List of (element, position) pairs that are forbidden\n    Returns:\n        Number of valid permutations\n    \"\"\"\n    # Inclusion-exclusion over subsets of forbidden pairs\n    total = 0\n    m = len(forbidden)\n    \n    for r in range(m + 1):\n        for subset in combinations(range(m), r):\n            # Check if subset is compatible (no element/position repeated)\n            elems = set()\n            posns = set()\n            valid = True\n            for i in subset:\n                e, p = forbidden[i]\n                if e in elems or p in posns:\n                    valid = False\n                    break\n                elems.add(e)\n                posns.add(p)\n            \n            if valid:\n                # (-1)^r × (n - len(subset))!\n                contrib = ((-1) ** r) * factorial(n - len(subset))\n                total += contrib\n    \n    return total\n\nprint(restricted_perms(3, [(0, 0), (1, 1)]))",
    "testCases": [
      {
        "input": "3, [(0, 0), (1, 1)]",
        "isHidden": false,
        "description": "2 restrictions"
      },
      {
        "input": "4, [(0, 0)]",
        "isHidden": false,
        "description": "Single restriction"
      },
      {
        "input": "5, [(0, 0), (1, 1), (2, 2)]",
        "isHidden": true,
        "description": "More restrictions"
      },
      {
        "input": "3, []",
        "isHidden": true,
        "description": "No restrictions: 3!"
      }
    ],
    "hints": [
      "Use inclusion-exclusion over forbidden pairs",
      "Ensure no conflicts in chosen subset"
    ],
    "language": "python"
  },
  {
    "id": "math102-t1-ex16",
    "subjectId": "math102",
    "topicId": "math102-1",
    "title": "Catalan Number Applications",
    "difficulty": 5,
    "description": "Implement multiple interpretations of Catalan numbers: valid parentheses, binary trees, and non-crossing partitions.",
    "starterCode": "from math import comb\n\ndef catalan(n):\n    \"\"\"Calculate nth Catalan number\"\"\"\n    pass\n\ndef count_valid_parens(n):\n    \"\"\"Count valid sequences of n pairs of parentheses\"\"\"\n    pass\n\ndef count_binary_trees(n):\n    \"\"\"Count full binary trees with n+1 leaves\"\"\"\n    pass\n\nprint(f\"C(5) = {catalan(5)}\")\nprint(f\"Valid parens: {count_valid_parens(5)}\")\nprint(f\"Binary trees: {count_binary_trees(5)}\")",
    "solution": "from math import comb\n\ndef catalan(n):\n    \"\"\"Calculate nth Catalan number\"\"\"\n    return comb(2 * n, n) // (n + 1)\n\ndef count_valid_parens(n):\n    \"\"\"Count valid sequences of n pairs of parentheses\n    This equals C(n) by bijection\n    \"\"\"\n    return catalan(n)\n\ndef count_binary_trees(n):\n    \"\"\"Count full binary trees with n+1 leaves\n    This also equals C(n)\n    \"\"\"\n    return catalan(n)\n\n# Alternative: generate actual sequences\ndef generate_valid_parens(n):\n    result = []\n    def backtrack(s, open_count, close_count):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if open_count < n:\n            backtrack(s + '(', open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(s + ')', open_count, close_count + 1)\n    backtrack('', 0, 0)\n    return result\n\nprint(f\"C(5) = {catalan(5)}\")\nprint(f\"Valid parens: {count_valid_parens(5)}\")\nprint(f\"Binary trees: {count_binary_trees(5)}\")\nprint(f\"Generated: {len(generate_valid_parens(5))}\")",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "C(5) = 42"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "C(3) = 5"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "C(10) = 16796"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "C(0) = 1"
      }
    ],
    "hints": [
      "C(n) = C(2n,n)/(n+1)",
      "Many combinatorial objects are counted by Catalan numbers"
    ],
    "language": "python"
  },
  {
    "id": "math102-e2",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Fibonacci with Memoization",
    "difficulty": 2,
    "description": "Implement the Fibonacci sequence using memoization to avoid redundant calculations. The Fibonacci recurrence is F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Without memoization, this has exponential time complexity. With memoization, achieve O(n) time complexity.",
    "starterCode": "def fibonacci(n, memo=None):\n    \"\"\"Calculate the nth Fibonacci number using memoization.\n    \n    Args:\n        n: The index in the Fibonacci sequence\n        memo: Dictionary for memoization (default: None)\n        \n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def fibonacci(n, memo=None):\n    \"\"\"Calculate the nth Fibonacci number using memoization.\n    \n    Args:\n        n: The index in the Fibonacci sequence\n        memo: Dictionary for memoization (default: None)\n        \n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    return memo[n]",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "0",
        "isHidden": false,
        "description": "F(0) = 0"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "F(20) = 6765"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "F(1) = 1"
      }
    ],
    "hints": [
      "Initialize the memoization dictionary if it is None",
      "Check if the result for n is already in the memo dictionary before computing",
      "Store the computed result in memo before returning it",
      "The base cases are F(0) = 0 and F(1) = 1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex02",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Iterative Fibonacci",
    "difficulty": 1,
    "description": "Implement Fibonacci using iteration with O(n) time and O(1) space.",
    "starterCode": "def fib_iterative(n):\n    \"\"\"Calculate nth Fibonacci number iteratively\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    pass\n\nprint(fib_iterative(10))",
    "solution": "def fib_iterative(n):\n    \"\"\"Calculate nth Fibonacci number iteratively\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    prev2, prev1 = 0, 1\n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    return prev1\n\nprint(fib_iterative(10))",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "1",
        "isHidden": false,
        "description": "F(1) = 1"
      },
      {
        "input": "30",
        "isHidden": true,
        "description": "F(30) = 832040"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "F(0) = 0"
      }
    ],
    "hints": [
      "Track only the last two values",
      "Update in-place each iteration"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex03",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Tower of Hanoi",
    "difficulty": 2,
    "description": "Count the minimum moves to solve Tower of Hanoi with n disks. The recurrence is T(n) = 2T(n-1) + 1.",
    "starterCode": "def hanoi_moves(n):\n    \"\"\"Calculate minimum moves to solve Tower of Hanoi\n    \n    Args:\n        n: Number of disks\n    Returns:\n        Minimum number of moves\n    \"\"\"\n    pass\n\nprint(hanoi_moves(4))",
    "solution": "def hanoi_moves(n):\n    \"\"\"Calculate minimum moves to solve Tower of Hanoi\n    \n    Args:\n        n: Number of disks\n    Returns:\n        Minimum number of moves\n    \"\"\"\n    # T(n) = 2^n - 1 (closed form)\n    return 2**n - 1\n\nprint(hanoi_moves(4))",
    "testCases": [
      {
        "input": "4",
        "isHidden": false,
        "description": "2^4 - 1 = 15"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "2^3 - 1 = 7"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "2^10 - 1 = 1023"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "2^1 - 1 = 1"
      }
    ],
    "hints": [
      "T(n) = 2T(n-1) + 1",
      "Closed form is 2^n - 1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex04",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Staircase Climbing",
    "difficulty": 2,
    "description": "Count ways to climb n stairs if you can take 1 or 2 steps at a time. This is essentially Fibonacci!",
    "starterCode": "def climb_stairs(n):\n    \"\"\"Count ways to climb n stairs with 1 or 2 steps\n    \n    Args:\n        n: Number of stairs\n    Returns:\n        Number of ways\n    \"\"\"\n    pass\n\nprint(climb_stairs(5))",
    "solution": "def climb_stairs(n):\n    \"\"\"Count ways to climb n stairs with 1 or 2 steps\n    \n    Args:\n        n: Number of stairs\n    Returns:\n        Number of ways\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    for _ in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    return prev1\n\nprint(climb_stairs(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "8 ways to climb 5 stairs"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "3 ways to climb 3 stairs"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "89 ways to climb 10 stairs"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "1 way to climb 1 stair"
      }
    ],
    "hints": [
      "Ways(n) = Ways(n-1) + Ways(n-2)",
      "Base: Ways(1)=1, Ways(2)=2"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex05",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Linear Recurrence Solver",
    "difficulty": 3,
    "description": "Solve the recurrence a(n) = c1*a(n-1) + c2*a(n-2) with given base cases using matrix exponentiation for O(log n) complexity.",
    "starterCode": "def solve_recurrence(c1, c2, a0, a1, n):\n    \"\"\"Solve linear recurrence a(n) = c1*a(n-1) + c2*a(n-2)\n    \n    Args:\n        c1, c2: Coefficients\n        a0, a1: Base cases a(0) and a(1)\n        n: Index to compute\n    Returns:\n        a(n)\n    \"\"\"\n    pass\n\n# Fibonacci: a(n) = 1*a(n-1) + 1*a(n-2), a(0)=0, a(1)=1\nprint(solve_recurrence(1, 1, 0, 1, 10))",
    "solution": "def solve_recurrence(c1, c2, a0, a1, n):\n    \"\"\"Solve linear recurrence a(n) = c1*a(n-1) + c2*a(n-2)\n    \n    Args:\n        c1, c2: Coefficients\n        a0, a1: Base cases a(0) and a(1)\n        n: Index to compute\n    Returns:\n        a(n)\n    \"\"\"\n    if n == 0:\n        return a0\n    if n == 1:\n        return a1\n    \n    def matrix_mult(A, B):\n        return [\n            [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n            [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n        ]\n    \n    def matrix_pow(M, p):\n        result = [[1, 0], [0, 1]]  # Identity\n        while p > 0:\n            if p % 2 == 1:\n                result = matrix_mult(result, M)\n            M = matrix_mult(M, M)\n            p //= 2\n        return result\n    \n    M = [[c1, c2], [1, 0]]\n    Mn = matrix_pow(M, n - 1)\n    return Mn[0][0] * a1 + Mn[0][1] * a0\n\nprint(solve_recurrence(1, 1, 0, 1, 10))",
    "testCases": [
      {
        "input": "1, 1, 0, 1, 10",
        "isHidden": false,
        "description": "Fibonacci F(10) = 55"
      },
      {
        "input": "2, 1, 1, 2, 5",
        "isHidden": false,
        "description": "Custom recurrence"
      },
      {
        "input": "1, 1, 0, 1, 20",
        "isHidden": true,
        "description": "Fibonacci F(20)"
      },
      {
        "input": "3, 2, 1, 1, 6",
        "isHidden": true,
        "description": "Another recurrence"
      }
    ],
    "hints": [
      "Use matrix [[c1, c2], [1, 0]]",
      "Matrix exponentiation gives O(log n)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex06",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Catalan Numbers",
    "difficulty": 3,
    "description": "Calculate the nth Catalan number. C(n) = C(n-1)*2*(2n-1)/(n+1) or C(n) = (2n)! / ((n+1)!*n!)",
    "starterCode": "def catalan(n):\n    \"\"\"Calculate nth Catalan number\n    \n    Args:\n        n: Index (0-indexed)\n    Returns:\n        nth Catalan number\n    \"\"\"\n    pass\n\nprint(catalan(5))",
    "solution": "def catalan(n):\n    \"\"\"Calculate nth Catalan number\n    \n    Args:\n        n: Index (0-indexed)\n    Returns:\n        nth Catalan number\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    cat = 1\n    for i in range(1, n + 1):\n        cat = cat * 2 * (2*i - 1) // (i + 1)\n    return cat\n\nprint(catalan(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "C(5) = 42"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "C(3) = 5"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "C(10) = 16796"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "C(0) = 1"
      }
    ],
    "hints": [
      "C(0) = C(1) = 1",
      "C(n) = C(n-1) * 2(2n-1) / (n+1)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex07",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Divide and Conquer Recurrence",
    "difficulty": 4,
    "description": "Analyze a divide-and-conquer recurrence. Given T(n) = a*T(n/b) + f(n), use Master Theorem to determine complexity.",
    "starterCode": "def analyze_dc(a, b, f_degree):\n    \"\"\"Determine complexity of T(n) = a*T(n/b) + n^f_degree\n    \n    Args:\n        a: Number of subproblems\n        b: Factor by which size decreases\n        f_degree: Degree of polynomial f(n) = n^f_degree\n    Returns:\n        String describing complexity\n    \"\"\"\n    pass\n\nprint(analyze_dc(2, 2, 1))  # Merge sort",
    "solution": "import math\n\ndef analyze_dc(a, b, f_degree):\n    \"\"\"Determine complexity of T(n) = a*T(n/b) + n^f_degree\n    \n    Args:\n        a: Number of subproblems\n        b: Factor by which size decreases\n        f_degree: Degree of polynomial f(n) = n^f_degree\n    Returns:\n        String describing complexity\n    \"\"\"\n    log_b_a = math.log(a) / math.log(b)\n    \n    if f_degree < log_b_a:\n        return f\"O(n^{log_b_a:.2f})\"\n    elif abs(f_degree - log_b_a) < 0.01:\n        return f\"O(n^{f_degree} log n)\"\n    else:\n        return f\"O(n^{f_degree})\"\n\nprint(analyze_dc(2, 2, 1))",
    "testCases": [
      {
        "input": "2, 2, 1",
        "isHidden": false,
        "description": "Merge sort: O(n log n)"
      },
      {
        "input": "4, 2, 2",
        "isHidden": false,
        "description": "Case 2: O(n² log n)"
      },
      {
        "input": "8, 2, 2",
        "isHidden": true,
        "description": "Case 1: O(n³)"
      },
      {
        "input": "2, 2, 0",
        "isHidden": true,
        "description": "Binary search: O(log n)"
      }
    ],
    "hints": [
      "Compare f_degree with log_b(a)",
      "Three cases of Master Theorem"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex08",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Dynamic Programming: Coin Change",
    "difficulty": 4,
    "description": "Find minimum coins needed to make amount n. Use the recurrence: dp[n] = min(dp[n-c] for each coin c) + 1.",
    "starterCode": "def min_coins(coins, amount):\n    \"\"\"Find minimum coins to make amount\n    \n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n    Returns:\n        Minimum coins needed, or -1 if impossible\n    \"\"\"\n    pass\n\nprint(min_coins([1, 5, 10, 25], 37))",
    "solution": "def min_coins(coins, amount):\n    \"\"\"Find minimum coins to make amount\n    \n    Args:\n        coins: List of coin denominations\n        amount: Target amount\n    Returns:\n        Minimum coins needed, or -1 if impossible\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] + 1 < dp[i]:\n                dp[i] = dp[i - coin] + 1\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\nprint(min_coins([1, 5, 10, 25], 37))",
    "testCases": [
      {
        "input": "[1, 5, 10, 25], 37",
        "isHidden": false,
        "description": "37 cents: 4 coins"
      },
      {
        "input": "[1, 2, 5], 11",
        "isHidden": false,
        "description": "11: 3 coins"
      },
      {
        "input": "[2], 3",
        "isHidden": true,
        "description": "Impossible: -1"
      },
      {
        "input": "[1, 5, 10], 27",
        "isHidden": true,
        "description": "27 cents"
      }
    ],
    "hints": [
      "dp[0] = 0",
      "Build up from smaller amounts"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex09",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Matrix Exponentiation for Fibonacci",
    "difficulty": 4,
    "description": "Implement Fibonacci using matrix exponentiation to achieve O(log n) time complexity. Use the matrix [[1,1],[1,0]] raised to the nth power.",
    "starterCode": "def fib_matrix(n):\n    \"\"\"Calculate nth Fibonacci using matrix exponentiation\n    \n    Args:\n        n: Index in Fibonacci sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    pass\n\nprint(fib_matrix(50))",
    "solution": "def fib_matrix(n):\n    \"\"\"Calculate nth Fibonacci using matrix exponentiation\n    \n    Args:\n        n: Index in Fibonacci sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    def matrix_mult(A, B):\n        return [\n            [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n            [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n        ]\n    \n    def matrix_pow(M, p):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while p > 0:\n            if p & 1:\n                result = matrix_mult(result, M)\n            M = matrix_mult(M, M)\n            p >>= 1\n        return result\n    \n    M = [[1, 1], [1, 0]]\n    result_matrix = matrix_pow(M, n)\n    return result_matrix[0][1]\n\nprint(fib_matrix(50))",
    "testCases": [
      {
        "input": "50",
        "isHidden": false,
        "description": "F(50) large value"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "100",
        "isHidden": true,
        "description": "F(100) very large"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "F(0) = 0"
      }
    ],
    "hints": [
      "Matrix [[1,1],[1,0]]^n gives Fibonacci",
      "Use binary exponentiation for O(log n)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex10",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Generating Functions: Fibonacci",
    "difficulty": 5,
    "description": "Use the closed-form formula (Binet's formula) derived from generating functions to calculate Fibonacci: F(n) = (phi^n - psi^n) / sqrt(5) where phi = (1+sqrt(5))/2.",
    "starterCode": "def fib_binet(n):\n    \"\"\"Calculate nth Fibonacci using Binet's formula\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    pass\n\nprint(fib_binet(20))",
    "solution": "import math\n\ndef fib_binet(n):\n    \"\"\"Calculate nth Fibonacci using Binet's formula\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    return round((phi**n - psi**n) / sqrt5)\n\nprint(fib_binet(20))",
    "testCases": [
      {
        "input": "20",
        "isHidden": false,
        "description": "F(20) = 6765"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "F(10) = 55"
      },
      {
        "input": "30",
        "isHidden": true,
        "description": "F(30) = 832040"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "F(1) = 1"
      }
    ],
    "hints": [
      "phi = (1 + sqrt(5)) / 2 (golden ratio)",
      "Formula: (phi^n - psi^n) / sqrt(5)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex11",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Tribonacci Sequence",
    "difficulty": 3,
    "description": "Solve T(n) = T(n-1) + T(n-2) + T(n-3) with base cases T(0)=0, T(1)=1, T(2)=1 using dynamic programming.",
    "starterCode": "def tribonacci(n):\n    \"\"\"Calculate nth Tribonacci number\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Tribonacci number\n    \"\"\"\n    pass\n\nprint(tribonacci(10))",
    "solution": "def tribonacci(n):\n    \"\"\"Calculate nth Tribonacci number\n    \n    Args:\n        n: Index in sequence\n    Returns:\n        nth Tribonacci number\n    \"\"\"\n    if n == 0:\n        return 0\n    if n <= 2:\n        return 1\n    \n    t0, t1, t2 = 0, 1, 1\n    for _ in range(3, n + 1):\n        t0, t1, t2 = t1, t2, t0 + t1 + t2\n    return t2\n\nprint(tribonacci(10))",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "T(10) = 149"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "T(5) = 7"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "T(20) = 66012"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "T(0) = 0"
      }
    ],
    "hints": [
      "Track last three values",
      "O(n) time, O(1) space"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex12",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Longest Increasing Subsequence",
    "difficulty": 4,
    "description": "Find the length of the longest increasing subsequence. Use dp[i] = max(dp[j] + 1) for all j < i where arr[j] < arr[i].",
    "starterCode": "def lis_length(arr):\n    \"\"\"Find length of longest increasing subsequence\n    \n    Args:\n        arr: List of integers\n    Returns:\n        Length of LIS\n    \"\"\"\n    pass\n\nprint(lis_length([10, 9, 2, 5, 3, 7, 101, 18]))",
    "solution": "def lis_length(arr):\n    \"\"\"Find length of longest increasing subsequence\n    \n    Args:\n        arr: List of integers\n    Returns:\n        Length of LIS\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nprint(lis_length([10, 9, 2, 5, 3, 7, 101, 18]))",
    "testCases": [
      {
        "input": "[10, 9, 2, 5, 3, 7, 101, 18]",
        "isHidden": false,
        "description": "LIS = 4"
      },
      {
        "input": "[0, 1, 0, 3, 2, 3]",
        "isHidden": false,
        "description": "LIS = 4"
      },
      {
        "input": "[7, 7, 7, 7]",
        "isHidden": true,
        "description": "All same: LIS = 1"
      },
      {
        "input": "[1, 2, 3, 4, 5]",
        "isHidden": true,
        "description": "Sorted: LIS = 5"
      }
    ],
    "hints": [
      "dp[i] = longest LIS ending at i",
      "Check all previous elements"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex13",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Edit Distance",
    "difficulty": 5,
    "description": "Calculate the minimum edit distance (Levenshtein distance) between two strings. Use recurrence: dp[i][j] = min(insert, delete, replace) operations.",
    "starterCode": "def edit_distance(s1, s2):\n    \"\"\"Calculate edit distance between two strings\n    \n    Args:\n        s1, s2: Input strings\n    Returns:\n        Minimum number of operations\n    \"\"\"\n    pass\n\nprint(edit_distance(\"kitten\", \"sitting\"))",
    "solution": "def edit_distance(s1, s2):\n    \"\"\"Calculate edit distance between two strings\n    \n    Args:\n        s1, s2: Input strings\n    Returns:\n        Minimum number of operations\n    \"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]\n\nprint(edit_distance(\"kitten\", \"sitting\"))",
    "testCases": [
      {
        "input": "\"kitten\", \"sitting\"",
        "isHidden": false,
        "description": "Distance = 3"
      },
      {
        "input": "\"abc\", \"abc\"",
        "isHidden": false,
        "description": "Same string: 0"
      },
      {
        "input": "\"\", \"test\"",
        "isHidden": true,
        "description": "Empty to test: 4"
      },
      {
        "input": "\"intention\", \"execution\"",
        "isHidden": true,
        "description": "Distance = 5"
      }
    ],
    "hints": [
      "2D DP table",
      "If chars match, no operation needed"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex14",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Generating Functions: Partitions",
    "difficulty": 5,
    "description": "Count the number of ways to partition n into positive integers (order doesn't matter). Use dynamic programming.",
    "starterCode": "def partition_count(n):\n    \"\"\"Count integer partitions of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of partitions\n    \"\"\"\n    pass\n\nprint(partition_count(5))",
    "solution": "def partition_count(n):\n    \"\"\"Count integer partitions of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of partitions\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[j] += dp[j - i]\n    \n    return dp[n]\n\nprint(partition_count(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "p(5) = 7"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "p(10) = 42"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "p(20) = 627"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "p(1) = 1"
      }
    ],
    "hints": [
      "Use coins approach with coins = [1,2,...,n]",
      "Count ways, not minimum"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex15",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Matrix Chain Multiplication",
    "difficulty": 5,
    "description": "Find the minimum number of scalar multiplications needed to multiply a chain of matrices. Given dimensions, use dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost).",
    "starterCode": "def matrix_chain(dims):\n    \"\"\"Find minimum multiplications for matrix chain\n    \n    Args:\n        dims: List where matrix i has dimensions dims[i-1] x dims[i]\n    Returns:\n        Minimum number of scalar multiplications\n    \"\"\"\n    pass\n\nprint(matrix_chain([10, 20, 30, 40, 30]))",
    "solution": "def matrix_chain(dims):\n    \"\"\"Find minimum multiplications for matrix chain\n    \n    Args:\n        dims: List where matrix i has dimensions dims[i-1] x dims[i]\n    Returns:\n        Minimum number of scalar multiplications\n    \"\"\"\n    n = len(dims) - 1\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k+1][j] + dims[i]*dims[k+1]*dims[j+1]\n                dp[i][j] = min(dp[i][j], cost)\n    \n    return dp[0][n-1]\n\nprint(matrix_chain([10, 20, 30, 40, 30]))",
    "testCases": [
      {
        "input": "[10, 20, 30, 40, 30]",
        "isHidden": false,
        "description": "4 matrices"
      },
      {
        "input": "[10, 30, 5, 60]",
        "isHidden": false,
        "description": "3 matrices: 4500"
      },
      {
        "input": "[40, 20, 30, 10, 30]",
        "isHidden": true,
        "description": "4 matrices"
      },
      {
        "input": "[10, 20, 30]",
        "isHidden": true,
        "description": "2 matrices: 6000"
      }
    ],
    "hints": [
      "Try all split points k between i and j",
      "Cost: dims[i]*dims[k+1]*dims[j+1]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t2-ex16",
    "subjectId": "math102",
    "topicId": "math102-2",
    "title": "Advanced Recurrence Solving",
    "difficulty": 5,
    "description": "Solve the recurrence T(n) = 3T(n/4) + n*log(n) and determine its time complexity using the Master Theorem.",
    "starterCode": "import math\n\ndef analyze_recurrence(n):\n    \"\"\"Analyze T(n) = 3T(n/4) + n*log(n)\n    \n    Args:\n        n: Input size\n    Returns:\n        Tuple (complexity_class, log_b_a)\n    \"\"\"\n    pass\n\nprint(analyze_recurrence(1024))",
    "solution": "import math\n\ndef analyze_recurrence(n):\n    \"\"\"Analyze T(n) = 3T(n/4) + n*log(n)\n    \n    Args:\n        n: Input size\n    Returns:\n        Tuple (complexity_class, log_b_a)\n    \"\"\"\n    a, b = 3, 4\n    log_b_a = math.log(a) / math.log(b)\n    # f(n) = n*log(n), which is Theta(n^1 * log(n))\n    # log_b_a ≈ 0.79, so f(n) is polynomially larger\n    # Master Theorem Case 3: T(n) = Theta(f(n)) = Theta(n*log(n))\n    \n    return f\"O(n log n), log_b(a) = {log_b_a:.3f}\", log_b_a\n\nprint(analyze_recurrence(1024))",
    "testCases": [
      {
        "input": "1024",
        "isHidden": false,
        "description": "Analyze with n=1024"
      },
      {
        "input": "256",
        "isHidden": false,
        "description": "Analyze with n=256"
      },
      {
        "input": "4096",
        "isHidden": true,
        "description": "Larger input"
      },
      {
        "input": "64",
        "isHidden": true,
        "description": "Smaller input"
      }
    ],
    "hints": [
      "a=3, b=4, so log_4(3) ≈ 0.79",
      "f(n) = n*log(n) is Case 3 (f grows faster)"
    ],
    "language": "python"
  },
  {
    "id": "math102-e3",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Graph Representation",
    "difficulty": 2,
    "description": "Implement a function to convert an edge list representation of a graph to an adjacency list representation. An edge list is a list of tuples (u, v) representing edges. An adjacency list is a dictionary where each vertex maps to a list of its neighbors. Handle both directed and undirected graphs.",
    "starterCode": "def edge_list_to_adjacency_list(edges, directed=False):\n    \"\"\"Convert edge list to adjacency list representation.\n    \n    Args:\n        edges: List of tuples (u, v) representing edges\n        directed: Boolean indicating if graph is directed\n        \n    Returns:\n        Dictionary mapping each vertex to list of neighbors\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def edge_list_to_adjacency_list(edges, directed=False):\n    \"\"\"Convert edge list to adjacency list representation.\n    \n    Args:\n        edges: List of tuples (u, v) representing edges\n        directed: Boolean indicating if graph is directed\n        \n    Returns:\n        Dictionary mapping each vertex to list of neighbors\n    \"\"\"\n    adj_list = {}\n    \n    # Initialize all vertices\n    for u, v in edges:\n        if u not in adj_list:\n            adj_list[u] = []\n        if v not in adj_list:\n            adj_list[v] = []\n    \n    # Add edges\n    for u, v in edges:\n        adj_list[u].append(v)\n        if not directed:\n            adj_list[v].append(u)\n    \n    return adj_list",
    "testCases": [
      {
        "input": "[(0,1), (1,2)], False",
        "isHidden": false,
        "description": "Simple path, undirected"
      },
      {
        "input": "[(0,1), (1,2)], True",
        "isHidden": false,
        "description": "Simple path, directed"
      },
      {
        "input": "[(0,1), (0,2), (1,2)], False",
        "isHidden": true,
        "description": "Triangle, undirected"
      },
      {
        "input": "[], False",
        "isHidden": true,
        "description": "Empty graph"
      }
    ],
    "hints": [
      "First, create entries for all vertices that appear in the edge list",
      "For undirected graphs, each edge (u,v) should add v to u's list and u to v's list",
      "For directed graphs, only add v to u's adjacency list",
      "Handle the case of an empty edge list"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex02",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Degree Calculation",
    "difficulty": 1,
    "description": "Calculate the degree of each vertex in an undirected graph and verify the handshaking lemma.",
    "starterCode": "def vertex_degrees(adj_list):\n    \"\"\"Calculate degree of each vertex\n    \n    Args:\n        adj_list: Adjacency list representation\n    Returns:\n        Dictionary mapping vertex to degree\n    \"\"\"\n    pass\n\ngraph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}\nprint(vertex_degrees(graph))",
    "solution": "def vertex_degrees(adj_list):\n    \"\"\"Calculate degree of each vertex\n    \n    Args:\n        adj_list: Adjacency list representation\n    Returns:\n        Dictionary mapping vertex to degree\n    \"\"\"\n    return {v: len(neighbors) for v, neighbors in adj_list.items()}\n\ngraph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}\nprint(vertex_degrees(graph))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: all degree 2"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": false,
        "description": "Single edge: both degree 1"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": true,
        "description": "Star graph"
      },
      {
        "input": "{0: []}",
        "isHidden": true,
        "description": "Isolated vertex: degree 0"
      }
    ],
    "hints": [
      "Degree = number of neighbors",
      "Sum of degrees = 2 × number of edges"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex03",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Adjacency Matrix",
    "difficulty": 2,
    "description": "Convert adjacency list to adjacency matrix representation.",
    "starterCode": "def to_adj_matrix(adj_list, n):\n    \"\"\"Convert adjacency list to n×n matrix\n    \n    Args:\n        adj_list: Adjacency list with vertices 0 to n-1\n        n: Number of vertices\n    Returns:\n        2D list representing adjacency matrix\n    \"\"\"\n    pass\n\ngraph = {0: [1, 2], 1: [0], 2: [0]}\nprint(to_adj_matrix(graph, 3))",
    "solution": "def to_adj_matrix(adj_list, n):\n    \"\"\"Convert adjacency list to n×n matrix\n    \n    Args:\n        adj_list: Adjacency list with vertices 0 to n-1\n        n: Number of vertices\n    Returns:\n        2D list representing adjacency matrix\n    \"\"\"\n    matrix = [[0] * n for _ in range(n)]\n    for v, neighbors in adj_list.items():\n        for u in neighbors:\n            matrix[v][u] = 1\n    return matrix\n\ngraph = {0: [1, 2], 1: [0], 2: [0]}\nprint(to_adj_matrix(graph, 3))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0], 2: [0]}, 3",
        "isHidden": false,
        "description": "Small graph to matrix"
      },
      {
        "input": "{0: [1], 1: [0]}, 2",
        "isHidden": false,
        "description": "Two vertices"
      },
      {
        "input": "{0: [], 1: [], 2: []}, 3",
        "isHidden": true,
        "description": "No edges"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, 4",
        "isHidden": true,
        "description": "Star graph"
      }
    ],
    "hints": [
      "Initialize n×n matrix of zeros",
      "Set matrix[u][v] = 1 for each edge"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex04",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Is Connected",
    "difficulty": 2,
    "description": "Check if an undirected graph is connected (all vertices reachable from any vertex).",
    "starterCode": "def is_connected(adj_list):\n    \"\"\"Check if graph is connected\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if connected, False otherwise\n    \"\"\"\n    pass\n\nprint(is_connected({0: [1], 1: [0, 2], 2: [1]}))",
    "solution": "def is_connected(adj_list):\n    \"\"\"Check if graph is connected\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if connected, False otherwise\n    \"\"\"\n    if not adj_list:\n        return True\n    \n    start = next(iter(adj_list))\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        v = stack.pop()\n        if v not in visited:\n            visited.add(v)\n            for neighbor in adj_list[v]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return len(visited) == len(adj_list)\n\nprint(is_connected({0: [1], 1: [0, 2], 2: [1]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Connected path"
      },
      {
        "input": "{0: [1], 1: [0], 2: []}",
        "isHidden": false,
        "description": "Disconnected: isolated vertex"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": true,
        "description": "Connected triangle"
      },
      {
        "input": "{}",
        "isHidden": true,
        "description": "Empty graph"
      }
    ],
    "hints": [
      "DFS from any vertex",
      "Connected if all vertices visited"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex05",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Is Bipartite",
    "difficulty": 3,
    "description": "Check if a graph is bipartite (vertices can be colored with 2 colors such that no adjacent vertices share a color).",
    "starterCode": "def is_bipartite(adj_list):\n    \"\"\"Check if graph is bipartite\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if bipartite, False otherwise\n    \"\"\"\n    pass\n\nprint(is_bipartite({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}))",
    "solution": "def is_bipartite(adj_list):\n    \"\"\"Check if graph is bipartite\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if bipartite, False otherwise\n    \"\"\"\n    color = {}\n    \n    for start in adj_list:\n        if start in color:\n            continue\n        \n        stack = [(start, 0)]\n        while stack:\n            v, c = stack.pop()\n            if v in color:\n                if color[v] != c:\n                    return False\n                continue\n            \n            color[v] = c\n            for neighbor in adj_list[v]:\n                stack.append((neighbor, 1 - c))\n    \n    return True\n\nprint(is_bipartite({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}))",
    "testCases": [
      {
        "input": "{0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}",
        "isHidden": false,
        "description": "Cycle of 4: bipartite"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: NOT bipartite"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": true,
        "description": "Single edge: bipartite"
      },
      {
        "input": "{0: [1, 2, 3, 4], 1: [0], 2: [0], 3: [0], 4: [0]}",
        "isHidden": true,
        "description": "Star: bipartite"
      }
    ],
    "hints": [
      "BFS/DFS with 2-coloring",
      "If adjacent vertices have same color, not bipartite"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex06",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Has Cycle",
    "difficulty": 3,
    "description": "Detect if an undirected graph contains a cycle.",
    "starterCode": "def has_cycle(adj_list):\n    \"\"\"Detect cycle in undirected graph\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if cycle exists, False otherwise\n    \"\"\"\n    pass\n\nprint(has_cycle({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "solution": "def has_cycle(adj_list):\n    \"\"\"Detect cycle in undirected graph\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if cycle exists, False otherwise\n    \"\"\"\n    visited = set()\n    \n    def dfs(v, parent):\n        visited.add(v)\n        for neighbor in adj_list[v]:\n            if neighbor not in visited:\n                if dfs(neighbor, v):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    for v in adj_list:\n        if v not in visited:\n            if dfs(v, -1):\n                return True\n    return False\n\nprint(has_cycle({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: has cycle"
      },
      {
        "input": "{0: [1, 2], 1: [0], 2: [0]}",
        "isHidden": false,
        "description": "Star: no cycle"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": true,
        "description": "Path: no cycle"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3, 0], 3: [2]}",
        "isHidden": true,
        "description": "Cycle present"
      }
    ],
    "hints": [
      "DFS keeping track of parent",
      "Back edge (not to parent) means cycle"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex07",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Count Connected Components",
    "difficulty": 2,
    "description": "Count the number of connected components in an undirected graph.",
    "starterCode": "def count_components(adj_list):\n    \"\"\"Count connected components\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        Number of connected components\n    \"\"\"\n    pass\n\nprint(count_components({0: [1], 1: [0], 2: [3], 3: [2], 4: []}))",
    "solution": "def count_components(adj_list):\n    \"\"\"Count connected components\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        Number of connected components\n    \"\"\"\n    visited = set()\n    count = 0\n    \n    def dfs(v):\n        visited.add(v)\n        for neighbor in adj_list[v]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    for v in adj_list:\n        if v not in visited:\n            dfs(v)\n            count += 1\n    \n    return count\n\nprint(count_components({0: [1], 1: [0], 2: [3], 3: [2], 4: []}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0], 2: [3], 3: [2], 4: []}",
        "isHidden": false,
        "description": "3 components"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "1 component"
      },
      {
        "input": "{0: [], 1: [], 2: []}",
        "isHidden": true,
        "description": "All isolated: 3 components"
      },
      {
        "input": "{}",
        "isHidden": true,
        "description": "Empty: 0 components"
      }
    ],
    "hints": [
      "DFS from each unvisited vertex",
      "Each DFS explores one component"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex08",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Is Tree",
    "difficulty": 3,
    "description": "Check if an undirected graph is a tree (connected and acyclic).",
    "starterCode": "def is_tree(adj_list):\n    \"\"\"Check if graph is a tree\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if tree, False otherwise\n    \"\"\"\n    pass\n\nprint(is_tree({0: [1, 2], 1: [0], 2: [0]}))",
    "solution": "def is_tree(adj_list):\n    \"\"\"Check if graph is a tree\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if tree, False otherwise\n    \"\"\"\n    if not adj_list:\n        return True\n    \n    n = len(adj_list)\n    edges = sum(len(neighbors) for neighbors in adj_list.values()) // 2\n    \n    # Tree must have exactly n-1 edges\n    if edges != n - 1:\n        return False\n    \n    # Must be connected\n    visited = set()\n    start = next(iter(adj_list))\n    stack = [start]\n    \n    while stack:\n        v = stack.pop()\n        if v not in visited:\n            visited.add(v)\n            stack.extend(adj_list[v])\n    \n    return len(visited) == n\n\nprint(is_tree({0: [1, 2], 1: [0], 2: [0]}))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0], 2: [0]}",
        "isHidden": false,
        "description": "Star: is tree"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: not tree"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": true,
        "description": "Path: is tree"
      },
      {
        "input": "{0: [], 1: []}",
        "isHidden": true,
        "description": "Disconnected: not tree"
      }
    ],
    "hints": [
      "Tree: n vertices, n-1 edges, connected",
      "Or: connected and no cycles"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex09",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Eulerian Path Existence",
    "difficulty": 3,
    "description": "Check if an undirected graph has an Eulerian path (a path that visits every edge exactly once). An Eulerian path exists if the graph has exactly 0 or 2 vertices with odd degree.",
    "starterCode": "def has_eulerian_path(adj_list):\n    \"\"\"Check if graph has an Eulerian path\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if Eulerian path exists\n    \"\"\"\n    pass\n\nprint(has_eulerian_path({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "solution": "def has_eulerian_path(adj_list):\n    \"\"\"Check if graph has an Eulerian path\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if Eulerian path exists\n    \"\"\"\n    # Check connectivity (except isolated vertices)\n    non_isolated = {v for v in adj_list if len(adj_list[v]) > 0}\n    if non_isolated:\n        visited = set()\n        start = next(iter(non_isolated))\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v not in visited:\n                visited.add(v)\n                stack.extend(adj_list[v])\n        if visited != non_isolated:\n            return False\n    \n    # Count vertices with odd degree\n    odd_degree_count = sum(1 for v in adj_list if len(adj_list[v]) % 2 == 1)\n    return odd_degree_count == 0 or odd_degree_count == 2\n\nprint(has_eulerian_path({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: all even degree"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Path: 2 odd degree vertices"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": true,
        "description": "Star: 3 odd degree"
      },
      {
        "input": "{0: [1], 1: [0], 2: []}",
        "isHidden": true,
        "description": "Disconnected"
      }
    ],
    "hints": [
      "Eulerian path: 0 or 2 vertices with odd degree",
      "Graph must be connected"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex10",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Eulerian Circuit",
    "difficulty": 4,
    "description": "Check if a graph has an Eulerian circuit (a cycle visiting every edge exactly once). All vertices must have even degree.",
    "starterCode": "def has_eulerian_circuit(adj_list):\n    \"\"\"Check if graph has an Eulerian circuit\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if Eulerian circuit exists\n    \"\"\"\n    pass\n\nprint(has_eulerian_circuit({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "solution": "def has_eulerian_circuit(adj_list):\n    \"\"\"Check if graph has an Eulerian circuit\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if Eulerian circuit exists\n    \"\"\"\n    # Check connectivity\n    non_isolated = {v for v in adj_list if len(adj_list[v]) > 0}\n    if non_isolated:\n        visited = set()\n        start = next(iter(non_isolated))\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v not in visited:\n                visited.add(v)\n                stack.extend(adj_list[v])\n        if visited != non_isolated:\n            return False\n    \n    # All vertices must have even degree\n    return all(len(neighbors) % 2 == 0 for neighbors in adj_list.values())\n\nprint(has_eulerian_circuit({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: has circuit"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Path: no circuit (odd deg)"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2]}",
        "isHidden": true,
        "description": "K4: no circuit"
      },
      {
        "input": "{0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}",
        "isHidden": true,
        "description": "C4: has circuit"
      }
    ],
    "hints": [
      "Eulerian circuit: all vertices have even degree",
      "Must be connected"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex11",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Graph Diameter",
    "difficulty": 3,
    "description": "Find the diameter of a graph (the longest shortest path between any two vertices). Use BFS from each vertex.",
    "starterCode": "from collections import deque\n\ndef graph_diameter(adj_list):\n    \"\"\"Find graph diameter\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        Diameter (maximum shortest path length)\n    \"\"\"\n    pass\n\nprint(graph_diameter({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "solution": "from collections import deque\n\ndef graph_diameter(adj_list):\n    \"\"\"Find graph diameter\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        Diameter (maximum shortest path length)\n    \"\"\"\n    def bfs_farthest(start):\n        visited = {start}\n        queue = deque([(start, 0)])\n        max_dist = 0\n        while queue:\n            v, dist = queue.popleft()\n            max_dist = max(max_dist, dist)\n            for neighbor in adj_list[v]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        return max_dist\n    \n    if not adj_list:\n        return 0\n    \n    diameter = 0\n    for v in adj_list:\n        diameter = max(diameter, bfs_farthest(v))\n    return diameter\n\nprint(graph_diameter({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": false,
        "description": "Path of 4: diameter 3"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: diameter 1"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": true,
        "description": "Star: diameter 2"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": true,
        "description": "Single edge: diameter 1"
      }
    ],
    "hints": [
      "BFS from each vertex to find maximum distance",
      "Diameter is max of all shortest paths"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex12",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Graph Center",
    "difficulty": 4,
    "description": "Find the center(s) of a graph - vertices with minimum eccentricity. Eccentricity is the maximum distance from a vertex to any other vertex.",
    "starterCode": "from collections import deque\n\ndef graph_center(adj_list):\n    \"\"\"Find center vertices of graph\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        List of center vertices\n    \"\"\"\n    pass\n\nprint(graph_center({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "solution": "from collections import deque\n\ndef graph_center(adj_list):\n    \"\"\"Find center vertices of graph\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        List of center vertices\n    \"\"\"\n    def eccentricity(start):\n        visited = {start}\n        queue = deque([(start, 0)])\n        max_dist = 0\n        while queue:\n            v, dist = queue.popleft()\n            max_dist = max(max_dist, dist)\n            for neighbor in adj_list[v]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        return max_dist\n    \n    if not adj_list:\n        return []\n    \n    ecc = {v: eccentricity(v) for v in adj_list}\n    min_ecc = min(ecc.values())\n    return [v for v, e in ecc.items() if e == min_ecc]\n\nprint(graph_center({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": false,
        "description": "Path: center is [1, 2]"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: all are center"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": true,
        "description": "Star: center is [0]"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": true,
        "description": "Path of 3: center is [1]"
      }
    ],
    "hints": [
      "Eccentricity = max distance to any vertex",
      "Center has minimum eccentricity"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex13",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Planarity Check (Kuratowski)",
    "difficulty": 5,
    "description": "Check if a graph is planar (can be drawn without edge crossings). For small graphs, check if it avoids K5 and K3,3 subdivisions.",
    "starterCode": "def is_planar(adj_list):\n    \"\"\"Simple planarity check\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if likely planar (using simple heuristics)\n    \"\"\"\n    pass\n\nprint(is_planar({0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2]}))",
    "solution": "def is_planar(adj_list):\n    \"\"\"Simple planarity check\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        True if likely planar (using simple heuristics)\n    \"\"\"\n    n = len(adj_list)\n    if n <= 4:\n        return True\n    \n    # Count edges\n    edges = sum(len(neighbors) for neighbors in adj_list.values()) // 2\n    \n    # Planar graph: e <= 3n - 6\n    if edges > 3 * n - 6:\n        return False\n    \n    # If no triangles, e <= 2n - 4\n    # Simple heuristic: not a full implementation of Kuratowski\n    return True\n\nprint(is_planar({0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2]}))",
    "testCases": [
      {
        "input": "{0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2]}",
        "isHidden": false,
        "description": "K4: planar"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Path: planar"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": true,
        "description": "Triangle: planar"
      },
      {
        "input": "{}",
        "isHidden": true,
        "description": "Empty: trivially planar"
      }
    ],
    "hints": [
      "Planar graph: edges ≤ 3n - 6",
      "K5 and K3,3 are non-planar"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex14",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Graph Complement",
    "difficulty": 2,
    "description": "Generate the complement of a graph. The complement has the same vertices but only edges that were NOT in the original graph.",
    "starterCode": "def graph_complement(adj_list):\n    \"\"\"Generate complement graph\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        Adjacency list of complement\n    \"\"\"\n    pass\n\nprint(graph_complement({0: [1], 1: [0], 2: []}))",
    "solution": "def graph_complement(adj_list):\n    \"\"\"Generate complement graph\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        Adjacency list of complement\n    \"\"\"\n    vertices = set(adj_list.keys())\n    complement = {v: [] for v in vertices}\n    \n    for v in vertices:\n        neighbors = set(adj_list[v])\n        for u in vertices:\n            if u != v and u not in neighbors:\n                complement[v].append(u)\n    \n    return complement\n\nprint(graph_complement({0: [1], 1: [0], 2: []}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0], 2: []}",
        "isHidden": false,
        "description": "Add edges to 2"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "K3 complement is empty"
      },
      {
        "input": "{0: [], 1: [], 2: []}",
        "isHidden": true,
        "description": "Empty complement is K3"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": true,
        "description": "K2 complement"
      }
    ],
    "hints": [
      "For each vertex, connect to non-neighbors",
      "Exclude self-loops"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex15",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Regular Graph Check",
    "difficulty": 2,
    "description": "Check if a graph is k-regular (all vertices have the same degree k).",
    "starterCode": "def is_regular(adj_list):\n    \"\"\"Check if graph is regular\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        (is_regular, k) where k is the degree\n    \"\"\"\n    pass\n\nprint(is_regular({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "solution": "def is_regular(adj_list):\n    \"\"\"Check if graph is regular\n    \n    Args:\n        adj_list: Adjacency list\n    Returns:\n        (is_regular, k) where k is the degree\n    \"\"\"\n    if not adj_list:\n        return True, 0\n    \n    degrees = [len(neighbors) for neighbors in adj_list.values()]\n    k = degrees[0]\n    is_reg = all(d == k for d in degrees)\n    return is_reg, k if is_reg else -1\n\nprint(is_regular({0: [1, 2], 1: [0, 2], 2: [0, 1]}))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "K3: 2-regular"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Path: not regular"
      },
      {
        "input": "{0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}",
        "isHidden": true,
        "description": "C4: 2-regular"
      },
      {
        "input": "{0: []}",
        "isHidden": true,
        "description": "Single vertex: 0-regular"
      }
    ],
    "hints": [
      "All vertices must have same degree",
      "Check if all degrees equal"
    ],
    "language": "python"
  },
  {
    "id": "math102-t3-ex16",
    "subjectId": "math102",
    "topicId": "math102-3",
    "title": "Graph Isomorphism Check",
    "difficulty": 5,
    "description": "Check if two graphs are isomorphic (same structure). Compare degree sequences as a necessary but not sufficient condition.",
    "starterCode": "def could_be_isomorphic(g1, g2):\n    \"\"\"Check if graphs could be isomorphic\n    \n    Args:\n        g1, g2: Adjacency lists\n    Returns:\n        True if degree sequences match\n    \"\"\"\n    pass\n\nprint(could_be_isomorphic({0: [1], 1: [0]}, {2: [3], 3: [2]}))",
    "solution": "def could_be_isomorphic(g1, g2):\n    \"\"\"Check if graphs could be isomorphic\n    \n    Args:\n        g1, g2: Adjacency lists\n    Returns:\n        True if degree sequences match\n    \"\"\"\n    if len(g1) != len(g2):\n        return False\n    \n    deg1 = sorted([len(neighbors) for neighbors in g1.values()])\n    deg2 = sorted([len(neighbors) for neighbors in g2.values()])\n    \n    return deg1 == deg2\n\nprint(could_be_isomorphic({0: [1], 1: [0]}, {2: [3], 3: [2]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0]}, {2: [3], 3: [2]}",
        "isHidden": false,
        "description": "Both K2: isomorphic"
      },
      {
        "input": "{0: [1, 2], 1: [0], 2: [0]}, {0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": false,
        "description": "Same degrees"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, {0: [1], 1: [0, 2], 2: [1]}",
        "isHidden": true,
        "description": "Different degrees"
      },
      {
        "input": "{0: [], 1: []}, {0: []}",
        "isHidden": true,
        "description": "Different sizes"
      }
    ],
    "hints": [
      "Compare sorted degree sequences",
      "Same sequence is necessary, not sufficient"
    ],
    "language": "python"
  },
  {
    "id": "math102-e4",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Breadth-First Search",
    "difficulty": 3,
    "description": "Implement the Breadth-First Search (BFS) algorithm to find the shortest path between two vertices in an unweighted graph. BFS explores vertices level by level using a queue. Return the path as a list of vertices from start to end, or None if no path exists.",
    "starterCode": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    \"\"\"Find shortest path using BFS.\n    \n    Args:\n        graph: Adjacency list representation (dict)\n        start: Starting vertex\n        end: Ending vertex\n        \n    Returns:\n        List of vertices in path from start to end, or None\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "from collections import deque\n\ndef bfs_shortest_path(graph, start, end):\n    \"\"\"Find shortest path using BFS.\n    \n    Args:\n        graph: Adjacency list representation (dict)\n        start: Starting vertex\n        end: Ending vertex\n        \n    Returns:\n        List of vertices in path from start to end, or None\n    \"\"\"\n    if start not in graph or end not in graph:\n        return None\n    \n    if start == end:\n        return [start]\n    \n    queue = deque([start])\n    visited = {start}\n    parent = {start: None}\n    \n    while queue:\n        current = queue.popleft()\n        \n        if current == end:\n            # Reconstruct path\n            path = []\n            while current is not None:\n                path.append(current)\n                current = parent[current]\n            return path[::-1]\n        \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    return None",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}, 0, 3",
        "isHidden": false,
        "description": "Path 0→1→3"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: [1]}, 0, 2",
        "isHidden": false,
        "description": "Path 0→1→2"
      },
      {
        "input": "{0: [1], 1: [0], 2: []}, 0, 2",
        "isHidden": true,
        "description": "No path exists"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}, 0, 0",
        "isHidden": true,
        "description": "Same start and end"
      }
    ],
    "hints": [
      "Use a queue to track vertices to visit and a set to track visited vertices",
      "Keep a parent dictionary to reconstruct the path once you reach the end",
      "When you find the end vertex, backtrack through parents to build the path",
      "Remember to reverse the path before returning it"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex02",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Depth-First Search",
    "difficulty": 2,
    "description": "Implement DFS to check if a path exists between two vertices.",
    "starterCode": "def dfs_path_exists(graph, start, end):\n    \"\"\"Check if path exists using DFS\n    \n    Args:\n        graph: Adjacency list\n        start, end: Vertices\n    Returns:\n        True if path exists\n    \"\"\"\n    pass\n\nprint(dfs_path_exists({0: [1], 1: [2], 2: []}, 0, 2))",
    "solution": "def dfs_path_exists(graph, start, end):\n    \"\"\"Check if path exists using DFS\n    \n    Args:\n        graph: Adjacency list\n        start, end: Vertices\n    Returns:\n        True if path exists\n    \"\"\"\n    visited = set()\n    \n    def dfs(v):\n        if v == end:\n            return True\n        visited.add(v)\n        for neighbor in graph.get(v, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    return dfs(start)\n\nprint(dfs_path_exists({0: [1], 1: [2], 2: []}, 0, 2))",
    "testCases": [
      {
        "input": "{0: [1], 1: [2], 2: []}, 0, 2",
        "isHidden": false,
        "description": "Path exists"
      },
      {
        "input": "{0: [1], 1: [0], 2: []}, 0, 2",
        "isHidden": false,
        "description": "No path to isolated vertex"
      },
      {
        "input": "{0: [1, 2], 1: [3], 2: [3], 3: []}, 0, 3",
        "isHidden": true,
        "description": "Multiple paths exist"
      },
      {
        "input": "{0: []}, 0, 0",
        "isHidden": true,
        "description": "Same vertex"
      }
    ],
    "hints": [
      "Recursive DFS returns True when end found",
      "Track visited to avoid cycles"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex03",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Topological Sort",
    "difficulty": 3,
    "description": "Implement topological sort for a directed acyclic graph (DAG).",
    "starterCode": "def topological_sort(graph):\n    \"\"\"Topological sort of DAG\n    \n    Args:\n        graph: Adjacency list of directed graph\n    Returns:\n        List of vertices in topological order\n    \"\"\"\n    pass\n\nprint(topological_sort({0: [1, 2], 1: [3], 2: [3], 3: []}))",
    "solution": "def topological_sort(graph):\n    \"\"\"Topological sort of DAG\n    \n    Args:\n        graph: Adjacency list of directed graph\n    Returns:\n        List of vertices in topological order\n    \"\"\"\n    visited = set()\n    result = []\n    \n    def dfs(v):\n        visited.add(v)\n        for neighbor in graph.get(v, []):\n            if neighbor not in visited:\n                dfs(neighbor)\n        result.append(v)\n    \n    for v in graph:\n        if v not in visited:\n            dfs(v)\n    \n    return result[::-1]\n\nprint(topological_sort({0: [1, 2], 1: [3], 2: [3], 3: []}))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [3], 2: [3], 3: []}",
        "isHidden": false,
        "description": "Diamond DAG"
      },
      {
        "input": "{0: [1], 1: [2], 2: []}",
        "isHidden": false,
        "description": "Linear chain"
      },
      {
        "input": "{0: [], 1: [], 2: []}",
        "isHidden": true,
        "description": "No edges"
      },
      {
        "input": "{0: [1, 2, 3], 1: [], 2: [], 3: []}",
        "isHidden": true,
        "description": "Fan out from 0"
      }
    ],
    "hints": [
      "DFS postorder gives reverse topological order",
      "Append after visiting all neighbors"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex04",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Dijkstra's Algorithm",
    "difficulty": 4,
    "description": "Implement Dijkstra's algorithm for shortest paths in weighted graphs.",
    "starterCode": "import heapq\n\ndef dijkstra(graph, start):\n    \"\"\"Find shortest paths from start to all vertices\n    \n    Args:\n        graph: {v: [(neighbor, weight), ...]}\n        start: Starting vertex\n    Returns:\n        Dictionary of shortest distances\n    \"\"\"\n    pass\n\ng = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}\nprint(dijkstra(g, 0))",
    "solution": "import heapq\n\ndef dijkstra(graph, start):\n    \"\"\"Find shortest paths from start to all vertices\n    \n    Args:\n        graph: {v: [(neighbor, weight), ...]}\n        start: Starting vertex\n    Returns:\n        Dictionary of shortest distances\n    \"\"\"\n    dist = {v: float('inf') for v in graph}\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, v = heapq.heappop(pq)\n        if d > dist[v]:\n            continue\n        for neighbor, weight in graph.get(v, []):\n            new_dist = dist[v] + weight\n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    return dist\n\ng = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}\nprint(dijkstra(g, 0))",
    "testCases": [
      {
        "input": "{0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}, 0",
        "isHidden": false,
        "description": "Find shortest paths"
      },
      {
        "input": "{0: [(1, 1)], 1: [(2, 2)], 2: []}, 0",
        "isHidden": false,
        "description": "Linear chain"
      },
      {
        "input": "{0: [(1, 10), (2, 5)], 1: [(3, 1)], 2: [(1, 3)], 3: []}, 0",
        "isHidden": true,
        "description": "Shorter indirect path"
      },
      {
        "input": "{0: []}, 0",
        "isHidden": true,
        "description": "Single vertex"
      }
    ],
    "hints": [
      "Use min-heap for efficiency",
      "Skip if already found shorter path"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex05",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Kruskal's MST",
    "difficulty": 4,
    "description": "Implement Kruskal's algorithm for Minimum Spanning Tree using Union-Find.",
    "starterCode": "def kruskal_mst(n, edges):\n    \"\"\"Find MST using Kruskal's algorithm\n    \n    Args:\n        n: Number of vertices (0 to n-1)\n        edges: List of (u, v, weight)\n    Returns:\n        List of edges in MST and total weight\n    \"\"\"\n    pass\n\nprint(kruskal_mst(4, [(0,1,1), (1,2,2), (2,3,3), (0,3,4), (1,3,5)]))",
    "solution": "def kruskal_mst(n, edges):\n    \"\"\"Find MST using Kruskal's algorithm\n    \n    Args:\n        n: Number of vertices (0 to n-1)\n        edges: List of (u, v, weight)\n    Returns:\n        List of edges in MST and total weight\n    \"\"\"\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n        return True\n    \n    edges = sorted(edges, key=lambda e: e[2])\n    mst = []\n    total = 0\n    \n    for u, v, w in edges:\n        if union(u, v):\n            mst.append((u, v, w))\n            total += w\n    \n    return mst, total\n\nprint(kruskal_mst(4, [(0,1,1), (1,2,2), (2,3,3), (0,3,4), (1,3,5)]))",
    "testCases": [
      {
        "input": "4, [(0,1,1), (1,2,2), (2,3,3), (0,3,4), (1,3,5)]",
        "isHidden": false,
        "description": "MST weight 6"
      },
      {
        "input": "3, [(0,1,1), (1,2,2), (0,2,3)]",
        "isHidden": false,
        "description": "Triangle MST"
      },
      {
        "input": "4, [(0,1,1), (2,3,1)]",
        "isHidden": true,
        "description": "Disconnected graph"
      },
      {
        "input": "2, [(0,1,5)]",
        "isHidden": true,
        "description": "Single edge"
      }
    ],
    "hints": [
      "Sort edges by weight",
      "Use Union-Find to detect cycles"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex06",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "BFS Level Order",
    "difficulty": 2,
    "description": "Return vertices level by level from a starting vertex.",
    "starterCode": "from collections import deque\n\ndef bfs_levels(graph, start):\n    \"\"\"Return vertices grouped by BFS level\n    \n    Args:\n        graph: Adjacency list\n        start: Starting vertex\n    Returns:\n        List of lists, each containing vertices at that level\n    \"\"\"\n    pass\n\nprint(bfs_levels({0: [1, 2], 1: [3], 2: [3], 3: []}, 0))",
    "solution": "from collections import deque\n\ndef bfs_levels(graph, start):\n    \"\"\"Return vertices grouped by BFS level\n    \n    Args:\n        graph: Adjacency list\n        start: Starting vertex\n    Returns:\n        List of lists, each containing vertices at that level\n    \"\"\"\n    levels = []\n    visited = {start}\n    queue = deque([start])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        for _ in range(level_size):\n            v = queue.popleft()\n            current_level.append(v)\n            for neighbor in graph.get(v, []):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        levels.append(current_level)\n    \n    return levels\n\nprint(bfs_levels({0: [1, 2], 1: [3], 2: [3], 3: []}, 0))",
    "testCases": [
      {
        "input": "{0: [1, 2], 1: [3], 2: [3], 3: []}, 0",
        "isHidden": false,
        "description": "3 levels"
      },
      {
        "input": "{0: [1, 2, 3], 1: [], 2: [], 3: []}, 0",
        "isHidden": false,
        "description": "2 levels (star)"
      },
      {
        "input": "{0: [1], 1: [2], 2: [3], 3: []}, 0",
        "isHidden": true,
        "description": "4 levels (chain)"
      },
      {
        "input": "{0: []}, 0",
        "isHidden": true,
        "description": "Single vertex"
      }
    ],
    "hints": [
      "Track level size before processing",
      "Process all nodes at current level"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex07",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Bellman-Ford",
    "difficulty": 4,
    "description": "Implement Bellman-Ford algorithm that handles negative weights.",
    "starterCode": "def bellman_ford(n, edges, start):\n    \"\"\"Shortest paths handling negative weights\n    \n    Args:\n        n: Number of vertices\n        edges: List of (u, v, weight)\n        start: Starting vertex\n    Returns:\n        Distance dict or None if negative cycle\n    \"\"\"\n    pass\n\nprint(bellman_ford(3, [(0,1,4), (0,2,5), (1,2,-3)], 0))",
    "solution": "def bellman_ford(n, edges, start):\n    \"\"\"Shortest paths handling negative weights\n    \n    Args:\n        n: Number of vertices\n        edges: List of (u, v, weight)\n        start: Starting vertex\n    Returns:\n        Distance dict or None if negative cycle\n    \"\"\"\n    dist = {i: float('inf') for i in range(n)}\n    dist[start] = 0\n    \n    for _ in range(n - 1):\n        for u, v, w in edges:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n    \n    # Check for negative cycle\n    for u, v, w in edges:\n        if dist[u] + w < dist[v]:\n            return None\n    \n    return dist\n\nprint(bellman_ford(3, [(0,1,4), (0,2,5), (1,2,-3)], 0))",
    "testCases": [
      {
        "input": "3, [(0,1,4), (0,2,5), (1,2,-3)], 0",
        "isHidden": false,
        "description": "Negative edge"
      },
      {
        "input": "3, [(0,1,1), (1,2,2)], 0",
        "isHidden": false,
        "description": "Simple path"
      },
      {
        "input": "3, [(0,1,1), (1,2,-5), (2,0,2)], 0",
        "isHidden": true,
        "description": "Negative cycle"
      },
      {
        "input": "2, [(0,1,3)], 0",
        "isHidden": true,
        "description": "Two vertices"
      }
    ],
    "hints": [
      "Relax all edges n-1 times",
      "Check for improvements on nth pass"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex08",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Floyd-Warshall",
    "difficulty": 5,
    "description": "Implement Floyd-Warshall for all-pairs shortest paths.",
    "starterCode": "def floyd_warshall(n, edges):\n    \"\"\"All-pairs shortest paths\n    \n    Args:\n        n: Number of vertices\n        edges: List of (u, v, weight)\n    Returns:\n        n×n distance matrix\n    \"\"\"\n    pass\n\nprint(floyd_warshall(3, [(0,1,3), (1,2,1), (0,2,6)]))",
    "solution": "def floyd_warshall(n, edges):\n    \"\"\"All-pairs shortest paths\n    \n    Args:\n        n: Number of vertices\n        edges: List of (u, v, weight)\n    Returns:\n        n×n distance matrix\n    \"\"\"\n    INF = float('inf')\n    dist = [[INF] * n for _ in range(n)]\n    \n    for i in range(n):\n        dist[i][i] = 0\n    \n    for u, v, w in edges:\n        dist[u][v] = w\n    \n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    \n    return dist\n\nprint(floyd_warshall(3, [(0,1,3), (1,2,1), (0,2,6)]))",
    "testCases": [
      {
        "input": "3, [(0,1,3), (1,2,1), (0,2,6)]",
        "isHidden": false,
        "description": "3 vertices"
      },
      {
        "input": "4, [(0,1,1), (1,2,2), (2,3,3)]",
        "isHidden": false,
        "description": "Chain"
      },
      {
        "input": "3, [(0,1,1), (1,0,1), (1,2,2)]",
        "isHidden": true,
        "description": "Bidirectional edge"
      },
      {
        "input": "2, [(0,1,5)]",
        "isHidden": true,
        "description": "Two vertices"
      }
    ],
    "hints": [
      "O(n³) complexity",
      "Try all intermediate vertices k"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex09",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Prim's MST Algorithm",
    "difficulty": 4,
    "description": "Implement Prim's algorithm for finding the Minimum Spanning Tree. Start from any vertex and greedily add the minimum weight edge that connects a new vertex.",
    "starterCode": "import heapq\n\ndef prim_mst(n, edges):\n    \"\"\"Find MST using Prim's algorithm\n    \n    Args:\n        n: Number of vertices (0 to n-1)\n        edges: List of (u, v, weight)\n    Returns:\n        (mst_edges, total_weight)\n    \"\"\"\n    pass\n\nprint(prim_mst(4, [(0,1,1), (1,2,2), (2,3,3), (0,3,4), (1,3,5)]))",
    "solution": "import heapq\n\ndef prim_mst(n, edges):\n    \"\"\"Find MST using Prim's algorithm\n    \n    Args:\n        n: Number of vertices (0 to n-1)\n        edges: List of (u, v, weight)\n    Returns:\n        (mst_edges, total_weight)\n    \"\"\"\n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    visited = set([0])\n    mst = []\n    total = 0\n    pq = [(w, 0, v) for v, w in graph[0]]\n    heapq.heapify(pq)\n    \n    while pq and len(visited) < n:\n        w, u, v = heapq.heappop(pq)\n        if v in visited:\n            continue\n        \n        visited.add(v)\n        mst.append((u, v, w))\n        total += w\n        \n        for neighbor, weight in graph[v]:\n            if neighbor not in visited:\n                heapq.heappush(pq, (weight, v, neighbor))\n    \n    return mst, total\n\nprint(prim_mst(4, [(0,1,1), (1,2,2), (2,3,3), (0,3,4), (1,3,5)]))",
    "testCases": [
      {
        "input": "4, [(0,1,1), (1,2,2), (2,3,3), (0,3,4), (1,3,5)]",
        "isHidden": false,
        "description": "MST weight 6"
      },
      {
        "input": "3, [(0,1,2), (1,2,3), (0,2,5)]",
        "isHidden": false,
        "description": "Triangle"
      },
      {
        "input": "4, [(0,1,1), (0,2,1), (0,3,1)]",
        "isHidden": true,
        "description": "Star graph"
      },
      {
        "input": "2, [(0,1,10)]",
        "isHidden": true,
        "description": "Two vertices"
      }
    ],
    "hints": [
      "Start from any vertex",
      "Use min-heap for edge selection",
      "Skip edges to visited vertices"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex10",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Strongly Connected Components",
    "difficulty": 5,
    "description": "Find all strongly connected components in a directed graph using Kosaraju's algorithm (two DFS passes).",
    "starterCode": "def strongly_connected_components(graph):\n    \"\"\"Find SCCs using Kosaraju's algorithm\n    \n    Args:\n        graph: Adjacency list of directed graph\n    Returns:\n        List of SCCs (each SCC is a list of vertices)\n    \"\"\"\n    pass\n\nprint(strongly_connected_components({0: [1], 1: [2], 2: [0], 3: [1, 2]}))",
    "solution": "def strongly_connected_components(graph):\n    \"\"\"Find SCCs using Kosaraju's algorithm\n    \n    Args:\n        graph: Adjacency list of directed graph\n    Returns:\n        List of SCCs (each SCC is a list of vertices)\n    \"\"\"\n    # First DFS to get finishing order\n    visited = set()\n    stack = []\n    \n    def dfs1(v):\n        visited.add(v)\n        for neighbor in graph.get(v, []):\n            if neighbor not in visited:\n                dfs1(neighbor)\n        stack.append(v)\n    \n    for v in graph:\n        if v not in visited:\n            dfs1(v)\n    \n    # Build reverse graph\n    reverse_graph = {v: [] for v in graph}\n    for v in graph:\n        for u in graph[v]:\n            if u not in reverse_graph:\n                reverse_graph[u] = []\n            reverse_graph[u].append(v)\n    \n    # Second DFS on reverse graph in reverse finishing order\n    visited = set()\n    sccs = []\n    \n    def dfs2(v, component):\n        visited.add(v)\n        component.append(v)\n        for neighbor in reverse_graph.get(v, []):\n            if neighbor not in visited:\n                dfs2(neighbor, component)\n    \n    while stack:\n        v = stack.pop()\n        if v not in visited:\n            component = []\n            dfs2(v, component)\n            sccs.append(component)\n    \n    return sccs\n\nprint(strongly_connected_components({0: [1], 1: [2], 2: [0], 3: [1, 2]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [2], 2: [0], 3: [1, 2]}",
        "isHidden": false,
        "description": "Cycle + external vertex"
      },
      {
        "input": "{0: [1], 1: [2], 2: []}",
        "isHidden": false,
        "description": "Chain: 3 SCCs"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": true,
        "description": "Single SCC of 2"
      },
      {
        "input": "{0: []}",
        "isHidden": true,
        "description": "Single vertex"
      }
    ],
    "hints": [
      "DFS to get finishing times",
      "Reverse graph",
      "DFS in reverse finishing order"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex11",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Tarjan's SCC Algorithm",
    "difficulty": 5,
    "description": "Implement Tarjan's algorithm for finding strongly connected components using a single DFS with low-link values.",
    "starterCode": "def tarjan_scc(graph):\n    \"\"\"Find SCCs using Tarjan's algorithm\n    \n    Args:\n        graph: Adjacency list\n    Returns:\n        List of SCCs\n    \"\"\"\n    pass\n\nprint(tarjan_scc({0: [1], 1: [2], 2: [0], 3: [1]}))",
    "solution": "def tarjan_scc(graph):\n    \"\"\"Find SCCs using Tarjan's algorithm\n    \n    Args:\n        graph: Adjacency list\n    Returns:\n        List of SCCs\n    \"\"\"\n    index_counter = [0]\n    stack = []\n    lowlink = {}\n    index = {}\n    on_stack = set()\n    sccs = []\n    \n    def dfs(v):\n        index[v] = index_counter[0]\n        lowlink[v] = index_counter[0]\n        index_counter[0] += 1\n        stack.append(v)\n        on_stack.add(v)\n        \n        for w in graph.get(v, []):\n            if w not in index:\n                dfs(w)\n                lowlink[v] = min(lowlink[v], lowlink[w])\n            elif w in on_stack:\n                lowlink[v] = min(lowlink[v], index[w])\n        \n        if lowlink[v] == index[v]:\n            scc = []\n            while True:\n                w = stack.pop()\n                on_stack.remove(w)\n                scc.append(w)\n                if w == v:\n                    break\n            sccs.append(scc)\n    \n    for v in graph:\n        if v not in index:\n            dfs(v)\n    \n    return sccs\n\nprint(tarjan_scc({0: [1], 1: [2], 2: [0], 3: [1]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [2], 2: [0], 3: [1]}",
        "isHidden": false,
        "description": "Cycle with tail"
      },
      {
        "input": "{0: [1], 1: [0, 2], 2: []}",
        "isHidden": false,
        "description": "Cycle + chain"
      },
      {
        "input": "{0: [1, 2], 1: [2], 2: [0]}",
        "isHidden": true,
        "description": "All one SCC"
      },
      {
        "input": "{0: [], 1: [], 2: []}",
        "isHidden": true,
        "description": "No edges"
      }
    ],
    "hints": [
      "Track index and lowlink values",
      "Use stack for current path",
      "SCC found when lowlink[v] == index[v]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex12",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Articulation Points (Cut Vertices)",
    "difficulty": 4,
    "description": "Find all articulation points in an undirected graph. An articulation point is a vertex whose removal increases the number of connected components.",
    "starterCode": "def find_articulation_points(graph):\n    \"\"\"Find articulation points\n    \n    Args:\n        graph: Adjacency list\n    Returns:\n        List of articulation points\n    \"\"\"\n    pass\n\nprint(find_articulation_points({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "solution": "def find_articulation_points(graph):\n    \"\"\"Find articulation points\n    \n    Args:\n        graph: Adjacency list\n    Returns:\n        List of articulation points\n    \"\"\"\n    visited = set()\n    disc = {}\n    low = {}\n    parent = {}\n    ap = set()\n    time = [0]\n    \n    def dfs(u):\n        children = 0\n        visited.add(u)\n        disc[u] = low[u] = time[0]\n        time[0] += 1\n        \n        for v in graph.get(u, []):\n            if v not in visited:\n                children += 1\n                parent[v] = u\n                dfs(v)\n                low[u] = min(low[u], low[v])\n                \n                # u is articulation point if:\n                # 1. u is root and has 2+ children\n                # 2. u is not root and low[v] >= disc[u]\n                if parent.get(u) is None and children > 1:\n                    ap.add(u)\n                if parent.get(u) is not None and low[v] >= disc[u]:\n                    ap.add(u)\n            elif v != parent.get(u):\n                low[u] = min(low[u], disc[v])\n    \n    for v in graph:\n        if v not in visited:\n            parent[v] = None\n            dfs(v)\n    \n    return list(ap)\n\nprint(find_articulation_points({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": false,
        "description": "Chain: 1 and 2 are APs"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: no APs"
      },
      {
        "input": "{0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": true,
        "description": "Star: 0 is AP"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": true,
        "description": "Two vertices: no APs"
      }
    ],
    "hints": [
      "Track discovery time and low values",
      "Root is AP if it has 2+ children",
      "Non-root is AP if low[child] >= disc[u]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex13",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Bridge Detection",
    "difficulty": 4,
    "description": "Find all bridges in an undirected graph. A bridge is an edge whose removal increases the number of connected components.",
    "starterCode": "def find_bridges(graph):\n    \"\"\"Find all bridges\n    \n    Args:\n        graph: Adjacency list\n    Returns:\n        List of bridge edges (u, v)\n    \"\"\"\n    pass\n\nprint(find_bridges({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "solution": "def find_bridges(graph):\n    \"\"\"Find all bridges\n    \n    Args:\n        graph: Adjacency list\n    Returns:\n        List of bridge edges (u, v)\n    \"\"\"\n    visited = set()\n    disc = {}\n    low = {}\n    parent = {}\n    bridges = []\n    time = [0]\n    \n    def dfs(u):\n        visited.add(u)\n        disc[u] = low[u] = time[0]\n        time[0] += 1\n        \n        for v in graph.get(u, []):\n            if v not in visited:\n                parent[v] = u\n                dfs(v)\n                low[u] = min(low[u], low[v])\n                \n                # Edge u-v is a bridge if low[v] > disc[u]\n                if low[v] > disc[u]:\n                    bridges.append((u, v))\n            elif v != parent.get(u):\n                low[u] = min(low[u], disc[v])\n    \n    for v in graph:\n        if v not in visited:\n            parent[v] = None\n            dfs(v)\n    \n    return bridges\n\nprint(find_bridges({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}))",
    "testCases": [
      {
        "input": "{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}",
        "isHidden": false,
        "description": "All edges are bridges"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle: no bridges"
      },
      {
        "input": "{0: [1, 2], 1: [0, 2, 3], 2: [0, 1], 3: [1]}",
        "isHidden": true,
        "description": "One bridge"
      },
      {
        "input": "{0: [1], 1: [0]}",
        "isHidden": true,
        "description": "Single edge: one bridge"
      }
    ],
    "hints": [
      "Similar to articulation points",
      "Bridge if low[v] > disc[u]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex14",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "A* Search Algorithm",
    "difficulty": 5,
    "description": "Implement A* pathfinding with a heuristic function. Use f(n) = g(n) + h(n) where g is actual cost and h is heuristic.",
    "starterCode": "import heapq\n\ndef astar(graph, start, goal, heuristic):\n    \"\"\"A* pathfinding algorithm\n    \n    Args:\n        graph: {v: [(neighbor, cost), ...]}\n        start: Start vertex\n        goal: Goal vertex\n        heuristic: Function h(v) estimating cost to goal\n    Returns:\n        (path, cost) or (None, inf) if no path\n    \"\"\"\n    pass\n\ng = {0: [(1, 1), (2, 4)], 1: [(3, 2)], 2: [(3, 1)], 3: []}\nh = {0: 3, 1: 2, 2: 1, 3: 0}\nprint(astar(g, 0, 3, lambda v: h[v]))",
    "solution": "import heapq\n\ndef astar(graph, start, goal, heuristic):\n    \"\"\"A* pathfinding algorithm\n    \n    Args:\n        graph: {v: [(neighbor, cost), ...]}\n        start: Start vertex\n        goal: Goal vertex\n        heuristic: Function h(v) estimating cost to goal\n    Returns:\n        (path, cost) or (None, inf) if no path\n    \"\"\"\n    pq = [(heuristic(start), 0, start, [start])]\n    visited = set()\n    \n    while pq:\n        f, g, current, path = heapq.heappop(pq)\n        \n        if current == goal:\n            return path, g\n        \n        if current in visited:\n            continue\n        visited.add(current)\n        \n        for neighbor, cost in graph.get(current, []):\n            if neighbor not in visited:\n                new_g = g + cost\n                new_f = new_g + heuristic(neighbor)\n                new_path = path + [neighbor]\n                heapq.heappush(pq, (new_f, new_g, neighbor, new_path))\n    \n    return None, float('inf')\n\ng = {0: [(1, 1), (2, 4)], 1: [(3, 2)], 2: [(3, 1)], 3: []}\nh = {0: 3, 1: 2, 2: 1, 3: 0}\nprint(astar(g, 0, 3, lambda v: h[v]))",
    "testCases": [
      {
        "input": "{0: [(1, 1), (2, 4)], 1: [(3, 2)], 2: [(3, 1)], 3: []}, 0, 3, h={0:3,1:2,2:1,3:0}",
        "isHidden": false,
        "description": "Find optimal path"
      },
      {
        "input": "{0: [(1, 1)], 1: [(2, 1)], 2: []}, 0, 2, h={0:2,1:1,2:0}",
        "isHidden": false,
        "description": "Linear path"
      },
      {
        "input": "{0: [(1, 5)], 1: [], 2: []}, 0, 2, h={0:1,1:1,2:0}",
        "isHidden": true,
        "description": "No path"
      },
      {
        "input": "{0: []}, 0, 0, h={0:0}",
        "isHidden": true,
        "description": "Same start and goal"
      }
    ],
    "hints": [
      "f = g + h (actual + heuristic)",
      "Use min-heap with f values",
      "Track path in heap entries"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex15",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Bipartite Matching",
    "difficulty": 4,
    "description": "Find maximum matching in a bipartite graph using augmenting paths (Hungarian algorithm approach).",
    "starterCode": "def max_bipartite_matching(left, right, edges):\n    \"\"\"Find maximum matching in bipartite graph\n    \n    Args:\n        left: Set of left vertices\n        right: Set of right vertices\n        edges: List of (left_v, right_v) edges\n    Returns:\n        List of matched edges\n    \"\"\"\n    pass\n\nprint(max_bipartite_matching({0, 1, 2}, {3, 4, 5}, [(0,3), (0,4), (1,4), (2,5)]))",
    "solution": "def max_bipartite_matching(left, right, edges):\n    \"\"\"Find maximum matching in bipartite graph\n    \n    Args:\n        left: Set of left vertices\n        right: Set of right vertices\n        edges: List of (left_v, right_v) edges\n    Returns:\n        List of matched edges\n    \"\"\"\n    # Build adjacency list\n    graph = {v: [] for v in left}\n    for u, v in edges:\n        graph[u].append(v)\n    \n    match = {}\n    \n    def dfs(u, visited):\n        for v in graph[u]:\n            if v in visited:\n                continue\n            visited.add(v)\n            \n            if v not in match or dfs(match[v], visited):\n                match[v] = u\n                return True\n        return False\n    \n    for u in left:\n        dfs(u, set())\n    \n    return [(v, u) for u, v in match.items()]\n\nprint(max_bipartite_matching({0, 1, 2}, {3, 4, 5}, [(0,3), (0,4), (1,4), (2,5)]))",
    "testCases": [
      {
        "input": "{0, 1, 2}, {3, 4, 5}, [(0,3), (0,4), (1,4), (2,5)]",
        "isHidden": false,
        "description": "Max matching 3"
      },
      {
        "input": "{0, 1}, {2, 3}, [(0,2), (1,3)]",
        "isHidden": false,
        "description": "Perfect matching"
      },
      {
        "input": "{0, 1, 2}, {3, 4}, [(0,3), (1,3), (2,4)]",
        "isHidden": true,
        "description": "Max matching 2"
      },
      {
        "input": "{0}, {1}, [(0,1)]",
        "isHidden": true,
        "description": "Single edge"
      }
    ],
    "hints": [
      "Use augmenting paths",
      "DFS to find alternating paths",
      "Try to match each left vertex"
    ],
    "language": "python"
  },
  {
    "id": "math102-t4-ex16",
    "subjectId": "math102",
    "topicId": "math102-4",
    "title": "Johnson's Algorithm",
    "difficulty": 5,
    "description": "Implement Johnson's algorithm for all-pairs shortest paths that handles negative weights by reweighting the graph.",
    "starterCode": "import heapq\n\ndef johnson(n, edges):\n    \"\"\"All-pairs shortest paths with negative weights\n    \n    Args:\n        n: Number of vertices\n        edges: List of (u, v, weight)\n    Returns:\n        n×n distance matrix or None if negative cycle\n    \"\"\"\n    pass\n\nprint(johnson(3, [(0,1,4), (0,2,5), (1,2,-2)]))",
    "solution": "import heapq\n\ndef johnson(n, edges):\n    \"\"\"All-pairs shortest paths with negative weights\n    \n    Args:\n        n: Number of vertices\n        edges: List of (u, v, weight)\n    Returns:\n        n×n distance matrix or None if negative cycle\n    \"\"\"\n    # Add new vertex n connected to all others with weight 0\n    extended_edges = edges + [(n, i, 0) for i in range(n)]\n    \n    # Bellman-Ford from new vertex to find reweighting function h\n    h = [float('inf')] * (n + 1)\n    h[n] = 0\n    \n    for _ in range(n):\n        for u, v, w in extended_edges:\n            if h[u] + w < h[v]:\n                h[v] = h[u] + w\n    \n    # Check for negative cycle\n    for u, v, w in extended_edges:\n        if h[u] + w < h[v]:\n            return None\n    \n    # Build reweighted graph\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        new_w = w + h[u] - h[v]\n        graph[u].append((v, new_w))\n    \n    # Run Dijkstra from each vertex\n    dist = [[float('inf')] * n for _ in range(n)]\n    \n    for start in range(n):\n        d = [float('inf')] * n\n        d[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            curr_d, u = heapq.heappop(pq)\n            if curr_d > d[u]:\n                continue\n            for v, w in graph[u]:\n                if d[u] + w < d[v]:\n                    d[v] = d[u] + w\n                    heapq.heappush(pq, (d[v], v))\n        \n        for v in range(n):\n            if d[v] != float('inf'):\n                dist[start][v] = d[v] - h[start] + h[v]\n            else:\n                dist[start][v] = float('inf')\n    \n    return dist\n\nprint(johnson(3, [(0,1,4), (0,2,5), (1,2,-2)]))",
    "testCases": [
      {
        "input": "3, [(0,1,4), (0,2,5), (1,2,-2)]",
        "isHidden": false,
        "description": "Negative edge"
      },
      {
        "input": "3, [(0,1,1), (1,2,2), (0,2,5)]",
        "isHidden": false,
        "description": "No negative edges"
      },
      {
        "input": "3, [(0,1,1), (1,2,-5), (2,0,2)]",
        "isHidden": true,
        "description": "Negative cycle"
      },
      {
        "input": "2, [(0,1,3), (1,0,-1)]",
        "isHidden": true,
        "description": "Bidirectional edges"
      }
    ],
    "hints": [
      "Add auxiliary vertex",
      "Bellman-Ford to find h values",
      "Reweight: w' = w + h[u] - h[v]",
      "Dijkstra from each vertex"
    ],
    "language": "python"
  },
  {
    "id": "math102-e5",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Euclidean Algorithm",
    "difficulty": 2,
    "description": "Implement the Euclidean algorithm to find the greatest common divisor (GCD) of two integers. The algorithm is based on the principle that gcd(a,b) = gcd(b, a mod b). Continue until the remainder is 0. Also implement the extended version to find coefficients x and y such that ax + by = gcd(a,b).",
    "starterCode": "def gcd(a, b):\n    \"\"\"Calculate GCD using Euclidean algorithm.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Greatest common divisor of a and b\n    \"\"\"\n    # Your code here\n    pass\n\ndef extended_gcd(a, b):\n    \"\"\"Extended Euclidean algorithm.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Tuple (gcd, x, y) where ax + by = gcd\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def gcd(a, b):\n    \"\"\"Calculate GCD using Euclidean algorithm.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Greatest common divisor of a and b\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)\n\ndef extended_gcd(a, b):\n    \"\"\"Extended Euclidean algorithm.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Tuple (gcd, x, y) where ax + by = gcd\n    \"\"\"\n    if b == 0:\n        return abs(a), 1 if a >= 0 else -1, 0\n    \n    x1, y1 = 1, 0\n    x2, y2 = 0, 1\n    \n    while b != 0:\n        q = a // b\n        a, b = b, a % b\n        x1, x2 = x2, x1 - q * x2\n        y1, y2 = y2, y1 - q * y2\n    \n    return abs(a), x1 if a >= 0 else -x1, y1 if a >= 0 else -y1",
    "testCases": [
      {
        "input": "48, 18",
        "isHidden": false,
        "description": "gcd(48, 18) = 6"
      },
      {
        "input": "100, 35",
        "isHidden": false,
        "description": "gcd(100, 35) = 5"
      },
      {
        "input": "17, 13",
        "isHidden": true,
        "description": "gcd of coprime numbers = 1"
      },
      {
        "input": "0, 5",
        "isHidden": true,
        "description": "gcd with zero"
      }
    ],
    "hints": [
      "For the basic GCD, repeatedly replace (a,b) with (b, a mod b) until b is 0",
      "The extended version tracks coefficients that combine to give the GCD",
      "Handle the base case when b equals 0",
      "Remember to handle negative numbers by taking absolute values"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex02",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "LCM Function",
    "difficulty": 1,
    "description": "Implement a function to calculate the Least Common Multiple of two integers.",
    "starterCode": "def lcm(a, b):\n    \"\"\"Calculate LCM of two integers\n    \n    Args:\n        a, b: Integers\n    Returns:\n        Least common multiple\n    \"\"\"\n    pass\n\nprint(lcm(12, 18))",
    "solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return abs(a)\n\ndef lcm(a, b):\n    \"\"\"Calculate LCM of two integers\n    \n    Args:\n        a, b: Integers\n    Returns:\n        Least common multiple\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // gcd(a, b)\n\nprint(lcm(12, 18))",
    "testCases": [
      {
        "input": "12, 18",
        "isHidden": false,
        "description": "lcm(12, 18) = 36"
      },
      {
        "input": "4, 6",
        "isHidden": false,
        "description": "lcm(4, 6) = 12"
      },
      {
        "input": "7, 11",
        "isHidden": true,
        "description": "lcm of coprime = 77"
      },
      {
        "input": "0, 5",
        "isHidden": true,
        "description": "lcm with zero = 0"
      }
    ],
    "hints": [
      "lcm(a, b) = |a × b| / gcd(a, b)",
      "Handle zero case"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex03",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Prime Checker",
    "difficulty": 1,
    "description": "Check if a number is prime efficiently.",
    "starterCode": "def is_prime(n):\n    \"\"\"Check if n is prime\n    \n    Args:\n        n: Integer\n    Returns:\n        True if prime\n    \"\"\"\n    pass\n\nprint(is_prime(17))",
    "solution": "def is_prime(n):\n    \"\"\"Check if n is prime\n    \n    Args:\n        n: Integer\n    Returns:\n        True if prime\n    \"\"\"\n    if n < 2:\n        return False\n    if n < 4:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nprint(is_prime(17))",
    "testCases": [
      {
        "input": "17",
        "isHidden": false,
        "description": "17 is prime"
      },
      {
        "input": "15",
        "isHidden": false,
        "description": "15 is not prime"
      },
      {
        "input": "2",
        "isHidden": true,
        "description": "2 is prime"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "1 is not prime"
      }
    ],
    "hints": [
      "Only check up to √n",
      "After 2 and 3, primes are 6k±1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex04",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Sieve of Eratosthenes",
    "difficulty": 2,
    "description": "Generate all primes up to n using the Sieve of Eratosthenes.",
    "starterCode": "def sieve(n):\n    \"\"\"Generate all primes up to n\n    \n    Args:\n        n: Upper limit\n    Returns:\n        List of primes\n    \"\"\"\n    pass\n\nprint(sieve(30))",
    "solution": "def sieve(n):\n    \"\"\"Generate all primes up to n\n    \n    Args:\n        n: Upper limit\n    Returns:\n        List of primes\n    \"\"\"\n    if n < 2:\n        return []\n    \n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    return [i for i in range(2, n + 1) if is_prime[i]]\n\nprint(sieve(30))",
    "testCases": [
      {
        "input": "30",
        "isHidden": false,
        "description": "Primes up to 30"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "Primes up to 10: [2,3,5,7]"
      },
      {
        "input": "100",
        "isHidden": true,
        "description": "Primes up to 100"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "No primes ≤ 1"
      }
    ],
    "hints": [
      "Start from i² (smaller multiples already crossed)",
      "O(n log log n) complexity"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex05",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Modular Exponentiation",
    "difficulty": 3,
    "description": "Calculate a^b mod m efficiently using binary exponentiation.",
    "starterCode": "def mod_pow(a, b, m):\n    \"\"\"Calculate a^b mod m\n    \n    Args:\n        a: Base\n        b: Exponent\n        m: Modulus\n    Returns:\n        a^b mod m\n    \"\"\"\n    pass\n\nprint(mod_pow(2, 10, 1000))",
    "solution": "def mod_pow(a, b, m):\n    \"\"\"Calculate a^b mod m\n    \n    Args:\n        a: Base\n        b: Exponent\n        m: Modulus\n    Returns:\n        a^b mod m\n    \"\"\"\n    result = 1\n    a = a % m\n    while b > 0:\n        if b & 1:\n            result = (result * a) % m\n        b >>= 1\n        a = (a * a) % m\n    return result\n\nprint(mod_pow(2, 10, 1000))",
    "testCases": [
      {
        "input": "2, 10, 1000",
        "isHidden": false,
        "description": "2^10 mod 1000 = 24"
      },
      {
        "input": "3, 5, 7",
        "isHidden": false,
        "description": "3^5 mod 7 = 5"
      },
      {
        "input": "7, 100, 13",
        "isHidden": true,
        "description": "Large exponent"
      },
      {
        "input": "5, 0, 3",
        "isHidden": true,
        "description": "Zero exponent"
      }
    ],
    "hints": [
      "Square and multiply",
      "Take mod at each step"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex06",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Modular Inverse",
    "difficulty": 3,
    "description": "Find the modular multiplicative inverse of a mod m (when gcd(a,m) = 1).",
    "starterCode": "def mod_inverse(a, m):\n    \"\"\"Find a^(-1) mod m\n    \n    Args:\n        a: Number\n        m: Modulus\n    Returns:\n        Modular inverse, or None if doesn't exist\n    \"\"\"\n    pass\n\nprint(mod_inverse(3, 7))",
    "solution": "def mod_inverse(a, m):\n    \"\"\"Find a^(-1) mod m\n    \n    Args:\n        a: Number\n        m: Modulus\n    Returns:\n        Modular inverse, or None if doesn't exist\n    \"\"\"\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n    \n    g, x, _ = extended_gcd(a % m, m)\n    if g != 1:\n        return None\n    return x % m\n\nprint(mod_inverse(3, 7))",
    "testCases": [
      {
        "input": "3, 7",
        "isHidden": false,
        "description": "3^(-1) mod 7 = 5"
      },
      {
        "input": "2, 5",
        "isHidden": false,
        "description": "2^(-1) mod 5 = 3"
      },
      {
        "input": "7, 11",
        "isHidden": true,
        "description": "7^(-1) mod 11"
      },
      {
        "input": "6, 9",
        "isHidden": true,
        "description": "No inverse (gcd > 1)"
      }
    ],
    "hints": [
      "Use extended GCD",
      "Inverse exists iff gcd(a,m) = 1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex07",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Prime Factorization",
    "difficulty": 2,
    "description": "Find the prime factorization of an integer.",
    "starterCode": "def prime_factors(n):\n    \"\"\"Find prime factorization\n    \n    Args:\n        n: Integer > 1\n    Returns:\n        Dictionary {prime: exponent}\n    \"\"\"\n    pass\n\nprint(prime_factors(360))",
    "solution": "def prime_factors(n):\n    \"\"\"Find prime factorization\n    \n    Args:\n        n: Integer > 1\n    Returns:\n        Dictionary {prime: exponent}\n    \"\"\"\n    factors = {}\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            n //= d\n        d += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\nprint(prime_factors(360))",
    "testCases": [
      {
        "input": "360",
        "isHidden": false,
        "description": "360 = 2³×3²×5"
      },
      {
        "input": "84",
        "isHidden": false,
        "description": "84 = 2²×3×7"
      },
      {
        "input": "17",
        "isHidden": true,
        "description": "Prime: {17: 1}"
      },
      {
        "input": "1024",
        "isHidden": true,
        "description": "1024 = 2¹⁰"
      }
    ],
    "hints": [
      "Divide by smallest factor repeatedly",
      "Remaining n > 1 is prime"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex08",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Chinese Remainder Theorem",
    "difficulty": 5,
    "description": "Solve a system of congruences using the Chinese Remainder Theorem.",
    "starterCode": "def chinese_remainder(remainders, moduli):\n    \"\"\"Solve x ≡ r_i (mod m_i) for pairwise coprime moduli\n    \n    Args:\n        remainders: List of remainders [r_1, r_2, ...]\n        moduli: List of moduli [m_1, m_2, ...]\n    Returns:\n        x such that x ≡ r_i (mod m_i) for all i\n    \"\"\"\n    pass\n\nprint(chinese_remainder([2, 3, 2], [3, 5, 7]))",
    "solution": "def chinese_remainder(remainders, moduli):\n    \"\"\"Solve x ≡ r_i (mod m_i) for pairwise coprime moduli\n    \n    Args:\n        remainders: List of remainders [r_1, r_2, ...]\n        moduli: List of moduli [m_1, m_2, ...]\n    Returns:\n        x such that x ≡ r_i (mod m_i) for all i\n    \"\"\"\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x, y = extended_gcd(b, a % b)\n        return g, y, x - (a // b) * y\n    \n    def mod_inverse(a, m):\n        g, x, _ = extended_gcd(a, m)\n        return x % m\n    \n    M = 1\n    for m in moduli:\n        M *= m\n    \n    x = 0\n    for r, m in zip(remainders, moduli):\n        Mi = M // m\n        yi = mod_inverse(Mi, m)\n        x += r * Mi * yi\n    \n    return x % M\n\nprint(chinese_remainder([2, 3, 2], [3, 5, 7]))",
    "testCases": [
      {
        "input": "[2, 3, 2], [3, 5, 7]",
        "isHidden": false,
        "description": "x ≡ 2,3,2 mod 3,5,7"
      },
      {
        "input": "[1, 2], [3, 5]",
        "isHidden": false,
        "description": "x ≡ 1,2 mod 3,5 → x=7"
      },
      {
        "input": "[0, 0, 0], [3, 5, 7]",
        "isHidden": true,
        "description": "All zeros"
      },
      {
        "input": "[1], [7]",
        "isHidden": true,
        "description": "Single congruence"
      }
    ],
    "hints": [
      "M = product of all moduli",
      "For each i: Mi = M/mi, find Mi^(-1) mod mi"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex09",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Miller-Rabin Primality Test",
    "difficulty": 5,
    "description": "Implement the Miller-Rabin probabilistic primality test. Write n-1 = 2^r * d, then test with witnesses to check if n is probably prime.",
    "starterCode": "import random\n\ndef miller_rabin(n, k=5):\n    \"\"\"Miller-Rabin primality test\n    \n    Args:\n        n: Number to test\n        k: Number of rounds (higher = more accurate)\n    Returns:\n        True if probably prime, False if composite\n    \"\"\"\n    pass\n\nprint(miller_rabin(561))  # Carmichael number\nprint(miller_rabin(997))",
    "solution": "import random\n\ndef miller_rabin(n, k=5):\n    \"\"\"Miller-Rabin primality test\n    \n    Args:\n        n: Number to test\n        k: Number of rounds (higher = more accurate)\n    Returns:\n        True if probably prime, False if composite\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Write n-1 as 2^r * d\n    r, d = 0, n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n    \n    # Witness loop\n    for _ in range(k):\n        a = random.randrange(2, n - 1)\n        x = pow(a, d, n)\n        \n        if x == 1 or x == n - 1:\n            continue\n        \n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    \n    return True\n\nprint(miller_rabin(561))  # Carmichael number\nprint(miller_rabin(997))",
    "testCases": [
      {
        "input": "561",
        "isHidden": false,
        "description": "561 (Carmichael): composite"
      },
      {
        "input": "997",
        "isHidden": false,
        "description": "997: prime"
      },
      {
        "input": "104729",
        "isHidden": true,
        "description": "Large prime"
      },
      {
        "input": "1000001",
        "isHidden": true,
        "description": "Composite"
      }
    ],
    "hints": [
      "Write n-1 = 2^r * d",
      "Test with random witnesses",
      "Check if a^d ≡ 1 or a^(2^i*d) ≡ -1 (mod n)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex10",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Euler's Totient Function",
    "difficulty": 3,
    "description": "Calculate φ(n) - the count of numbers ≤ n that are coprime to n. Use the formula with prime factorization.",
    "starterCode": "def euler_totient(n):\n    \"\"\"Calculate Euler's totient function φ(n)\n    \n    Args:\n        n: Positive integer\n    Returns:\n        φ(n) = count of numbers ≤ n coprime to n\n    \"\"\"\n    pass\n\nprint(euler_totient(36))",
    "solution": "def euler_totient(n):\n    \"\"\"Calculate Euler's totient function φ(n)\n    \n    Args:\n        n: Positive integer\n    Returns:\n        φ(n) = count of numbers ≤ n coprime to n\n    \"\"\"\n    result = n\n    p = 2\n    \n    # For each prime factor p: φ(n) = n * ∏(1 - 1/p)\n    while p * p <= n:\n        if n % p == 0:\n            # Remove all factors of p\n            while n % p == 0:\n                n //= p\n            # Multiply result by (1 - 1/p) = (p-1)/p\n            result -= result // p\n        p += 1\n    \n    # If n > 1, then it's a prime factor\n    if n > 1:\n        result -= result // n\n    \n    return result\n\nprint(euler_totient(36))",
    "testCases": [
      {
        "input": "36",
        "isHidden": false,
        "description": "φ(36) = 12"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "φ(10) = 4"
      },
      {
        "input": "13",
        "isHidden": true,
        "description": "φ(prime) = prime - 1"
      },
      {
        "input": "100",
        "isHidden": true,
        "description": "φ(100) = 40"
      }
    ],
    "hints": [
      "φ(n) = n * ∏(1 - 1/p) for prime factors p",
      "Process each prime factor once"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex11",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Fermat's Little Theorem",
    "difficulty": 3,
    "description": "Use Fermat's Little Theorem (a^(p-1) ≡ 1 mod p for prime p) to compute modular inverse when modulus is prime.",
    "starterCode": "def fermat_inverse(a, p):\n    \"\"\"Find modular inverse using Fermat's Little Theorem\n    \n    Args:\n        a: Number\n        p: Prime modulus\n    Returns:\n        a^(-1) mod p\n    \"\"\"\n    pass\n\nprint(fermat_inverse(3, 11))",
    "solution": "def fermat_inverse(a, p):\n    \"\"\"Find modular inverse using Fermat's Little Theorem\n    \n    Args:\n        a: Number\n        p: Prime modulus\n    Returns:\n        a^(-1) mod p\n    \"\"\"\n    # By Fermat: a^(p-1) ≡ 1 (mod p)\n    # So: a^(-1) ≡ a^(p-2) (mod p)\n    return pow(a, p - 2, p)\n\nprint(fermat_inverse(3, 11))",
    "testCases": [
      {
        "input": "3, 11",
        "isHidden": false,
        "description": "3^(-1) mod 11 = 4"
      },
      {
        "input": "2, 7",
        "isHidden": false,
        "description": "2^(-1) mod 7 = 4"
      },
      {
        "input": "5, 13",
        "isHidden": true,
        "description": "5^(-1) mod 13"
      },
      {
        "input": "6, 17",
        "isHidden": true,
        "description": "6^(-1) mod 17"
      }
    ],
    "hints": [
      "a^(p-1) ≡ 1 (mod p)",
      "Therefore a^(-1) ≡ a^(p-2) (mod p)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex12",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Discrete Logarithm (Baby-step Giant-step)",
    "difficulty": 5,
    "description": "Solve a^x ≡ b (mod p) for x using the baby-step giant-step algorithm.",
    "starterCode": "import math\n\ndef discrete_log(a, b, p):\n    \"\"\"Find x such that a^x ≡ b (mod p)\n    \n    Args:\n        a: Base\n        b: Target\n        p: Modulus (prime)\n    Returns:\n        x or None if no solution\n    \"\"\"\n    pass\n\nprint(discrete_log(2, 8, 11))",
    "solution": "import math\n\ndef discrete_log(a, b, p):\n    \"\"\"Find x such that a^x ≡ b (mod p)\n    \n    Args:\n        a: Base\n        b: Target\n        p: Modulus (prime)\n    Returns:\n        x or None if no solution\n    \"\"\"\n    m = math.ceil(math.sqrt(p))\n    \n    # Baby step: build table of a^j mod p\n    table = {}\n    power = 1\n    for j in range(m):\n        table[power] = j\n        power = (power * a) % p\n    \n    # Giant step: compute a^(-m)\n    a_inv_m = pow(a, p - 1 - m, p)  # a^(-m) = a^(p-1-m) by Fermat\n    \n    # Check b * (a^(-m))^i\n    gamma = b\n    for i in range(m):\n        if gamma in table:\n            return i * m + table[gamma]\n        gamma = (gamma * a_inv_m) % p\n    \n    return None\n\nprint(discrete_log(2, 8, 11))",
    "testCases": [
      {
        "input": "2, 8, 11",
        "isHidden": false,
        "description": "2^x ≡ 8 mod 11, x=3"
      },
      {
        "input": "3, 27, 31",
        "isHidden": false,
        "description": "3^x ≡ 27 mod 31"
      },
      {
        "input": "5, 25, 97",
        "isHidden": true,
        "description": "5^x ≡ 25 mod 97"
      },
      {
        "input": "2, 1, 7",
        "isHidden": true,
        "description": "2^x ≡ 1 mod 7, x=0 or order"
      }
    ],
    "hints": [
      "Split into baby steps and giant steps of size √p",
      "Build table for a^j",
      "Check b*(a^(-m))^i"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex13",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Pollard's Rho Factorization",
    "difficulty": 5,
    "description": "Implement Pollard's rho algorithm for integer factorization using cycle detection.",
    "starterCode": "def pollard_rho(n):\n    \"\"\"Find a non-trivial factor of n using Pollard's rho\n    \n    Args:\n        n: Composite number to factor\n    Returns:\n        A factor of n (not necessarily prime)\n    \"\"\"\n    pass\n\nprint(pollard_rho(8051))",
    "solution": "import math\n\ndef pollard_rho(n):\n    \"\"\"Find a non-trivial factor of n using Pollard's rho\n    \n    Args:\n        n: Composite number to factor\n    Returns:\n        A factor of n (not necessarily prime)\n    \"\"\"\n    if n % 2 == 0:\n        return 2\n    \n    x = 2\n    y = 2\n    d = 1\n    \n    # Polynomial function f(x) = x^2 + 1\n    def f(x):\n        return (x * x + 1) % n\n    \n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = math.gcd(abs(x - y), n)\n    \n    if d == n:\n        return None  # Failed, try different starting point\n    return d\n\nprint(pollard_rho(8051))",
    "testCases": [
      {
        "input": "8051",
        "isHidden": false,
        "description": "8051 = 83 × 97"
      },
      {
        "input": "1000003",
        "isHidden": false,
        "description": "Large semiprime"
      },
      {
        "input": "91",
        "isHidden": true,
        "description": "91 = 7 × 13"
      },
      {
        "input": "323",
        "isHidden": true,
        "description": "323 = 17 × 19"
      }
    ],
    "hints": [
      "Use f(x) = x^2 + 1 mod n",
      "Floyd's cycle detection: tortoise and hare",
      "gcd(|x-y|, n) finds factor"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex14",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Quadratic Residue",
    "difficulty": 4,
    "description": "Check if a is a quadratic residue modulo p (i.e., does there exist x such that x^2 ≡ a (mod p)). Use Euler's criterion.",
    "starterCode": "def is_quadratic_residue(a, p):\n    \"\"\"Check if a is quadratic residue mod p\n    \n    Args:\n        a: Number to check\n        p: Prime modulus\n    Returns:\n        True if a is QR mod p\n    \"\"\"\n    pass\n\nprint(is_quadratic_residue(2, 7))\nprint(is_quadratic_residue(4, 7))",
    "solution": "def is_quadratic_residue(a, p):\n    \"\"\"Check if a is quadratic residue mod p\n    \n    Args:\n        a: Number to check\n        p: Prime modulus\n    Returns:\n        True if a is QR mod p\n    \"\"\"\n    # Euler's criterion: a^((p-1)/2) ≡ 1 (mod p) iff a is QR\n    a = a % p\n    if a == 0:\n        return True\n    return pow(a, (p - 1) // 2, p) == 1\n\nprint(is_quadratic_residue(2, 7))\nprint(is_quadratic_residue(4, 7))",
    "testCases": [
      {
        "input": "2, 7",
        "isHidden": false,
        "description": "2 is QR mod 7"
      },
      {
        "input": "4, 7",
        "isHidden": false,
        "description": "4 is QR mod 7 (2²=4)"
      },
      {
        "input": "3, 7",
        "isHidden": true,
        "description": "3 is non-QR mod 7"
      },
      {
        "input": "1, 11",
        "isHidden": true,
        "description": "1 is always QR"
      }
    ],
    "hints": [
      "Euler's criterion: a^((p-1)/2) ≡ ±1 (mod p)",
      "QR if result is 1, non-QR if -1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex15",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Legendre Symbol",
    "difficulty": 4,
    "description": "Calculate the Legendre symbol (a/p) which is 1 if a is QR, -1 if non-QR, 0 if a ≡ 0 (mod p).",
    "starterCode": "def legendre_symbol(a, p):\n    \"\"\"Calculate Legendre symbol (a/p)\n    \n    Args:\n        a: Number\n        p: Odd prime\n    Returns:\n        1, -1, or 0\n    \"\"\"\n    pass\n\nprint(legendre_symbol(5, 11))",
    "solution": "def legendre_symbol(a, p):\n    \"\"\"Calculate Legendre symbol (a/p)\n    \n    Args:\n        a: Number\n        p: Odd prime\n    Returns:\n        1, -1, or 0\n    \"\"\"\n    a = a % p\n    if a == 0:\n        return 0\n    \n    result = pow(a, (p - 1) // 2, p)\n    return -1 if result == p - 1 else result\n\nprint(legendre_symbol(5, 11))",
    "testCases": [
      {
        "input": "5, 11",
        "isHidden": false,
        "description": "(5/11) = 1 (QR)"
      },
      {
        "input": "2, 11",
        "isHidden": false,
        "description": "(2/11) = -1 (non-QR)"
      },
      {
        "input": "11, 13",
        "isHidden": true,
        "description": "(11/13)"
      },
      {
        "input": "0, 7",
        "isHidden": true,
        "description": "(0/7) = 0"
      }
    ],
    "hints": [
      "(a/p) = a^((p-1)/2) mod p",
      "Convert p-1 to -1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t5-ex16",
    "subjectId": "math102",
    "topicId": "math102-5",
    "title": "Carmichael Numbers",
    "difficulty": 4,
    "description": "Check if a number is a Carmichael number (composite number n where a^(n-1) ≡ 1 (mod n) for all a coprime to n).",
    "starterCode": "def is_carmichael(n):\n    \"\"\"Check if n is a Carmichael number\n    \n    Args:\n        n: Number to test\n    Returns:\n        True if Carmichael number\n    \"\"\"\n    pass\n\nprint(is_carmichael(561))\nprint(is_carmichael(1105))",
    "solution": "import math\n\ndef is_carmichael(n):\n    \"\"\"Check if n is a Carmichael number\n    \n    Args:\n        n: Number to test\n    Returns:\n        True if Carmichael number\n    \"\"\"\n    # Must be composite\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n < 4:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    if is_prime(n) or n < 2:\n        return False\n    \n    # Check Korselt's criterion:\n    # 1. n is square-free\n    # 2. For all prime divisors p of n: (p-1) divides (n-1)\n    \n    # Get prime factors\n    factors = []\n    temp = n\n    d = 2\n    while d * d <= temp:\n        if temp % d == 0:\n            factors.append(d)\n            temp //= d\n            if temp % d == 0:  # Not square-free\n                return False\n        d += 1\n    if temp > 1:\n        factors.append(temp)\n    \n    # Check (p-1) | (n-1) for all prime factors\n    for p in factors:\n        if (n - 1) % (p - 1) != 0:\n            return False\n    \n    return True\n\nprint(is_carmichael(561))\nprint(is_carmichael(1105))",
    "testCases": [
      {
        "input": "561",
        "isHidden": false,
        "description": "561 is Carmichael"
      },
      {
        "input": "1105",
        "isHidden": false,
        "description": "1105 is Carmichael"
      },
      {
        "input": "1729",
        "isHidden": true,
        "description": "1729 (taxicab) is Carmichael"
      },
      {
        "input": "341",
        "isHidden": true,
        "description": "341 is not Carmichael"
      }
    ],
    "hints": [
      "Must be composite and square-free",
      "Korselt: (p-1) divides (n-1) for all prime divisors p"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex01",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Generating Function for Coin Change",
    "difficulty": 2,
    "description": "Use generating functions to count the number of ways to make change for n cents using coins of denominations 1, 5, and 10 cents.",
    "starterCode": "def coin_change_ways(n):\n    \"\"\"Count ways to make n cents using 1, 5, 10 cent coins\n    \n    Args:\n        n: Target amount in cents\n    Returns:\n        Number of ways to make change\n    \"\"\"\n    pass\n\nprint(coin_change_ways(20))",
    "solution": "def coin_change_ways(n):\n    \"\"\"Count ways to make n cents using 1, 5, 10 cent coins\n    \n    Args:\n        n: Target amount in cents\n    Returns:\n        Number of ways to make change\n    \"\"\"\n    # Dynamic programming approach\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    \n    coins = [1, 5, 10]\n    for coin in coins:\n        for i in range(coin, n + 1):\n            ways[i] += ways[i - coin]\n    \n    return ways[n]\n\nprint(coin_change_ways(20))",
    "testCases": [
      {
        "input": "20",
        "isHidden": false,
        "description": "20 cents: 9 ways"
      },
      {
        "input": "10",
        "isHidden": false,
        "description": "10 cents: 4 ways"
      },
      {
        "input": "25",
        "isHidden": true,
        "description": "25 cents"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "0 cents: 1 way"
      }
    ],
    "hints": [
      "Use dynamic programming",
      "Process each coin denomination in order",
      "ways[i] accumulates from ways[i-coin]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex02",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Integer Partitions",
    "difficulty": 2,
    "description": "Count the number of ways to partition integer n into positive integers (order doesn't matter).",
    "starterCode": "def partition_count(n):\n    \"\"\"Count integer partitions of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of partitions\n    \"\"\"\n    pass\n\nprint(partition_count(5))",
    "solution": "def partition_count(n):\n    \"\"\"Count integer partitions of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of partitions\n    \"\"\"\n    # dp[i][j] = partitions of i using numbers <= j\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case\n    for j in range(n + 1):\n        dp[0][j] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j-1]  # Don't use j\n            if i >= j:\n                dp[i][j] += dp[i-j][j]  # Use at least one j\n    \n    return dp[n][n]\n\nprint(partition_count(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "p(5) = 7"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "p(4) = 5"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "p(10) = 42"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "p(1) = 1"
      }
    ],
    "hints": [
      "Use DP with max element constraint",
      "dp[n][k] = partitions of n with parts ≤ k"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex03",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Stirling Numbers of the Second Kind",
    "difficulty": 3,
    "description": "Calculate S(n,k), the number of ways to partition n distinct objects into k non-empty subsets.",
    "starterCode": "def stirling_second(n, k):\n    \"\"\"Calculate S(n,k)\n    \n    Args:\n        n: Number of objects\n        k: Number of non-empty subsets\n    Returns:\n        Stirling number S(n,k)\n    \"\"\"\n    pass\n\nprint(stirling_second(5, 2))",
    "solution": "def stirling_second(n, k):\n    \"\"\"Calculate S(n,k)\n    \n    Args:\n        n: Number of objects\n        k: Number of non-empty subsets\n    Returns:\n        Stirling number S(n,k)\n    \"\"\"\n    if n == 0 and k == 0:\n        return 1\n    if n == 0 or k == 0:\n        return 0\n    if k > n:\n        return 0\n    \n    # Use DP: S(n,k) = k*S(n-1,k) + S(n-1,k-1)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1]\n    \n    return dp[n][k]\n\nprint(stirling_second(5, 2))",
    "testCases": [
      {
        "input": "5, 2",
        "isHidden": false,
        "description": "S(5,2) = 15"
      },
      {
        "input": "4, 3",
        "isHidden": false,
        "description": "S(4,3) = 6"
      },
      {
        "input": "6, 3",
        "isHidden": true,
        "description": "S(6,3) = 90"
      },
      {
        "input": "5, 5",
        "isHidden": true,
        "description": "S(n,n) = 1"
      }
    ],
    "hints": [
      "Recurrence: S(n,k) = k·S(n-1,k) + S(n-1,k-1)",
      "Base cases: S(0,0)=1, S(n,0)=0, S(0,k)=0"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex04",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Bell Numbers",
    "difficulty": 3,
    "description": "Calculate B(n), the number of ways to partition a set of n elements (sum of all Stirling numbers S(n,k)).",
    "starterCode": "def bell_number(n):\n    \"\"\"Calculate B(n) = sum of S(n,k) for k=0 to n\n    \n    Args:\n        n: Number of elements\n    Returns:\n        Bell number B(n)\n    \"\"\"\n    pass\n\nprint(bell_number(5))",
    "solution": "def bell_number(n):\n    \"\"\"Calculate B(n) = sum of S(n,k) for k=0 to n\n    \n    Args:\n        n: Number of elements\n    Returns:\n        Bell number B(n)\n    \"\"\"\n    # Use Bell triangle\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    return bell[n][0]\n\nprint(bell_number(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "B(5) = 52"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "B(4) = 15"
      },
      {
        "input": "6",
        "isHidden": true,
        "description": "B(6) = 203"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "B(0) = 1"
      }
    ],
    "hints": [
      "Use Bell triangle",
      "Each row starts with last element of previous row",
      "Each element = sum of left and upper-left"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex05",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Stirling Numbers of the First Kind",
    "difficulty": 4,
    "description": "Calculate s(n,k), the (unsigned) Stirling number of the first kind, representing the number of permutations of n elements with k cycles.",
    "starterCode": "def stirling_first(n, k):\n    \"\"\"Calculate unsigned s(n,k)\n    \n    Args:\n        n: Number of elements\n        k: Number of cycles\n    Returns:\n        Unsigned Stirling number s(n,k)\n    \"\"\"\n    pass\n\nprint(stirling_first(5, 2))",
    "solution": "def stirling_first(n, k):\n    \"\"\"Calculate unsigned s(n,k)\n    \n    Args:\n        n: Number of elements\n        k: Number of cycles\n    Returns:\n        Unsigned Stirling number s(n,k)\n    \"\"\"\n    if n == 0 and k == 0:\n        return 1\n    if n == 0 or k == 0:\n        return 0\n    if k > n:\n        return 0\n    \n    # Recurrence: s(n,k) = (n-1)*s(n-1,k) + s(n-1,k-1)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i][j] = (i - 1) * dp[i-1][j] + dp[i-1][j-1]\n    \n    return dp[n][k]\n\nprint(stirling_first(5, 2))",
    "testCases": [
      {
        "input": "5, 2",
        "isHidden": false,
        "description": "s(5,2) = 50"
      },
      {
        "input": "4, 3",
        "isHidden": false,
        "description": "s(4,3) = 11"
      },
      {
        "input": "5, 1",
        "isHidden": true,
        "description": "s(n,1) = (n-1)!"
      },
      {
        "input": "4, 4",
        "isHidden": true,
        "description": "s(n,n) = 1"
      }
    ],
    "hints": [
      "Recurrence: s(n,k) = (n-1)·s(n-1,k) + s(n-1,k-1)",
      "Similar to Stirling second kind but different coefficient"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex06",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Partition with Distinct Parts",
    "difficulty": 3,
    "description": "Count partitions of n where all parts are distinct (no repeated numbers).",
    "starterCode": "def partition_distinct(n):\n    \"\"\"Count partitions of n with distinct parts\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of distinct-part partitions\n    \"\"\"\n    pass\n\nprint(partition_distinct(6))",
    "solution": "def partition_distinct(n):\n    \"\"\"Count partitions of n with distinct parts\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of distinct-part partitions\n    \"\"\"\n    # dp[i][j] = partitions of i using distinct numbers <= j\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for j in range(n + 1):\n        dp[0][j] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j-1]  # Don't use j\n            if i >= j:\n                dp[i][j] += dp[i-j][j-1]  # Use j (can't use again)\n    \n    return dp[n][n]\n\nprint(partition_distinct(6))",
    "testCases": [
      {
        "input": "6",
        "isHidden": false,
        "description": "q(6) = 4: 6, 5+1, 4+2, 3+2+1"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "q(5) = 3"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "q(10) = 10"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "q(1) = 1"
      }
    ],
    "hints": [
      "Similar to regular partitions but can't reuse numbers",
      "dp[i-j][j-1] ensures j is not used again"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex07",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Partition with Odd Parts",
    "difficulty": 3,
    "description": "Count partitions of n where all parts are odd numbers.",
    "starterCode": "def partition_odd(n):\n    \"\"\"Count partitions of n with only odd parts\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of odd-part partitions\n    \"\"\"\n    pass\n\nprint(partition_odd(7))",
    "solution": "def partition_odd(n):\n    \"\"\"Count partitions of n with only odd parts\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of odd-part partitions\n    \"\"\"\n    # Dynamic programming\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    \n    # Use only odd numbers\n    for num in range(1, n + 1, 2):  # 1, 3, 5, 7, ...\n        for i in range(num, n + 1):\n            ways[i] += ways[i - num]\n    \n    return ways[n]\n\nprint(partition_odd(7))",
    "testCases": [
      {
        "input": "7",
        "isHidden": false,
        "description": "Odd parts of 7: 5 ways"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "Odd parts of 5: 3 ways"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "Odd parts of 10"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "Only 1: 1 way"
      }
    ],
    "hints": [
      "Use coin change DP with odd coins only",
      "Iterate through 1, 3, 5, 7, ..."
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex08",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Compositions of n",
    "difficulty": 2,
    "description": "Count compositions of n (ordered partitions). For example, 3 = 1+2 and 3 = 2+1 are different compositions.",
    "starterCode": "def composition_count(n):\n    \"\"\"Count ordered partitions (compositions) of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of compositions\n    \"\"\"\n    pass\n\nprint(composition_count(5))",
    "solution": "def composition_count(n):\n    \"\"\"Count ordered partitions (compositions) of n\n    \n    Args:\n        n: Positive integer\n    Returns:\n        Number of compositions\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    # Each composition is determined by n-1 binary choices\n    # (whether to place a separator or not)\n    return 2 ** (n - 1)\n\nprint(composition_count(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "2^4 = 16 compositions"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "2^2 = 4 compositions"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "2^9 = 512"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "2^0 = 1"
      }
    ],
    "hints": [
      "Think of n-1 gaps between n ones",
      "Each gap can have a separator or not",
      "Answer is 2^(n-1)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex09",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Generating Function Product Coefficients",
    "difficulty": 2,
    "description": "Find the coefficient of x^k in the expansion of (1 + x + x^2 + ... + x^m)^n.",
    "starterCode": "def coeff_in_product(n, m, k):\n    \"\"\"Find coefficient of x^k in (1+x+...+x^m)^n\n    \n    Args:\n        n: Power of the polynomial\n        m: Highest degree in base polynomial\n        k: Target degree\n    Returns:\n        Coefficient of x^k\n    \"\"\"\n    pass\n\nprint(coeff_in_product(3, 2, 4))",
    "solution": "def coeff_in_product(n, m, k):\n    \"\"\"Find coefficient of x^k in (1+x+...+x^m)^n\n    \n    Args:\n        n: Power of the polynomial\n        m: Highest degree in base polynomial\n        k: Target degree\n    Returns:\n        Coefficient of x^k\n    \"\"\"\n    # Use dynamic programming\n    # dp[i][j] = coefficient of x^j in (1+x+...+x^m)^i\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for deg in range(min(m, j) + 1):\n                dp[i][j] += dp[i-1][j-deg]\n    \n    return dp[n][k]\n\nprint(coeff_in_product(3, 2, 4))",
    "testCases": [
      {
        "input": "3, 2, 4",
        "isHidden": false,
        "description": "(1+x+x²)³ coeff of x⁴"
      },
      {
        "input": "2, 3, 3",
        "isHidden": false,
        "description": "(1+x+x²+x³)² coeff of x³"
      },
      {
        "input": "4, 2, 6",
        "isHidden": true,
        "description": "Larger values"
      },
      {
        "input": "3, 1, 2",
        "isHidden": true,
        "description": "(1+x)³ coeff of x²"
      }
    ],
    "hints": [
      "Use DP to multiply polynomials",
      "dp[i][j] tracks coefficient of x^j after i multiplications"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex10",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Ferrers Diagram Conjugate",
    "difficulty": 3,
    "description": "Given a partition as a list, compute its conjugate partition (transpose of Ferrers diagram).",
    "starterCode": "def conjugate_partition(partition):\n    \"\"\"Compute conjugate partition\n    \n    Args:\n        partition: List of parts in non-increasing order\n    Returns:\n        Conjugate partition\n    \"\"\"\n    pass\n\nprint(conjugate_partition([4, 3, 1]))",
    "solution": "def conjugate_partition(partition):\n    \"\"\"Compute conjugate partition\n    \n    Args:\n        partition: List of parts in non-increasing order\n    Returns:\n        Conjugate partition\n    \"\"\"\n    if not partition:\n        return []\n    \n    max_part = max(partition)\n    conjugate = []\n    \n    for i in range(1, max_part + 1):\n        count = sum(1 for p in partition if p >= i)\n        conjugate.append(count)\n    \n    return conjugate\n\nprint(conjugate_partition([4, 3, 1]))",
    "testCases": [
      {
        "input": "[4, 3, 1]",
        "isHidden": false,
        "description": "Conjugate of [4,3,1]"
      },
      {
        "input": "[5, 3, 3, 1]",
        "isHidden": false,
        "description": "Conjugate of [5,3,3,1]"
      },
      {
        "input": "[3, 3, 3]",
        "isHidden": true,
        "description": "Self-conjugate shape"
      },
      {
        "input": "[4]",
        "isHidden": true,
        "description": "Single row"
      }
    ],
    "hints": [
      "Count how many parts are >= i for each i",
      "Conjugate flips rows and columns of Ferrers diagram"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex11",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Catalan via Generating Functions",
    "difficulty": 4,
    "description": "Use the generating function approach to compute Catalan numbers C(n) = (2n choose n)/(n+1).",
    "starterCode": "from math import comb\n\ndef catalan_gf(n):\n    \"\"\"Compute nth Catalan number\n    \n    Args:\n        n: Index\n    Returns:\n        C(n)\n    \"\"\"\n    pass\n\nprint(catalan_gf(5))",
    "solution": "from math import comb\n\ndef catalan_gf(n):\n    \"\"\"Compute nth Catalan number\n    \n    Args:\n        n: Index\n    Returns:\n        C(n)\n    \"\"\"\n    # C(n) = C(2n,n) / (n+1)\n    return comb(2 * n, n) // (n + 1)\n\nprint(catalan_gf(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "C(5) = 42"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "C(4) = 14"
      },
      {
        "input": "10",
        "isHidden": true,
        "description": "C(10) = 16796"
      },
      {
        "input": "0",
        "isHidden": true,
        "description": "C(0) = 1"
      }
    ],
    "hints": [
      "Formula: C(n) = (2n)! / ((n+1)! × n!)",
      "Equivalently: C(2n,n)/(n+1)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex12",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Pentagonal Number Theorem",
    "difficulty": 5,
    "description": "Use Euler's pentagonal number theorem to compute partition numbers more efficiently.",
    "starterCode": "def partition_euler(n):\n    \"\"\"Compute p(n) using pentagonal number theorem\n    \n    Args:\n        n: Number to partition\n    Returns:\n        Number of partitions\n    \"\"\"\n    pass\n\nprint(partition_euler(10))",
    "solution": "def partition_euler(n):\n    \"\"\"Compute p(n) using pentagonal number theorem\n    \n    Args:\n        n: Number to partition\n    Returns:\n        Number of partitions\n    \"\"\"\n    p = [0] * (n + 1)\n    p[0] = 1\n    \n    for i in range(1, n + 1):\n        k = 1\n        while True:\n            # Pentagonal numbers: k(3k-1)/2 and k(3k+1)/2\n            pent1 = k * (3 * k - 1) // 2\n            pent2 = k * (3 * k + 1) // 2\n            \n            if pent1 > i:\n                break\n            \n            sign = (-1) ** (k + 1)\n            p[i] += sign * p[i - pent1]\n            \n            if pent2 <= i:\n                p[i] += sign * p[i - pent2]\n            \n            k += 1\n    \n    return p[n]\n\nprint(partition_euler(10))",
    "testCases": [
      {
        "input": "10",
        "isHidden": false,
        "description": "p(10) = 42"
      },
      {
        "input": "5",
        "isHidden": false,
        "description": "p(5) = 7"
      },
      {
        "input": "20",
        "isHidden": true,
        "description": "p(20) = 627"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "p(1) = 1"
      }
    ],
    "hints": [
      "p(n) = sum over pentagonal numbers with alternating signs",
      "Pentagonal: k(3k±1)/2"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex13",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Surjective Functions Count",
    "difficulty": 4,
    "description": "Count surjective (onto) functions from a set of size n to a set of size k using Stirling numbers.",
    "starterCode": "def surjective_count(n, k):\n    \"\"\"Count onto functions from n elements to k elements\n    \n    Args:\n        n: Domain size\n        k: Codomain size\n    Returns:\n        Number of surjective functions\n    \"\"\"\n    pass\n\nprint(surjective_count(5, 3))",
    "solution": "from math import factorial\n\ndef stirling_second(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n == 0 or k == 0 or k > n:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1]\n    \n    return dp[n][k]\n\ndef surjective_count(n, k):\n    \"\"\"Count onto functions from n elements to k elements\n    \n    Args:\n        n: Domain size\n        k: Codomain size\n    Returns:\n        Number of surjective functions\n    \"\"\"\n    if k > n:\n        return 0\n    \n    # Number of surjections = S(n,k) × k!\n    return stirling_second(n, k) * factorial(k)\n\nprint(surjective_count(5, 3))",
    "testCases": [
      {
        "input": "5, 3",
        "isHidden": false,
        "description": "S(5,3) × 3! = 150"
      },
      {
        "input": "4, 2",
        "isHidden": false,
        "description": "S(4,2) × 2! = 14"
      },
      {
        "input": "6, 4",
        "isHidden": true,
        "description": "Larger values"
      },
      {
        "input": "3, 3",
        "isHidden": true,
        "description": "All singletons: 6"
      }
    ],
    "hints": [
      "Use Stirling numbers S(n,k)",
      "Answer is S(n,k) × k!"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex14",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Exponential Generating Functions",
    "difficulty": 4,
    "description": "Use exponential generating functions to count permutations with forbidden patterns.",
    "starterCode": "from math import factorial\n\ndef derangement_egf(n):\n    \"\"\"Calculate derangements using EGF approach\n    \n    Args:\n        n: Number of elements\n    Returns:\n        Number of derangements\n    \"\"\"\n    pass\n\nprint(derangement_egf(5))",
    "solution": "from math import factorial\n\ndef derangement_egf(n):\n    \"\"\"Calculate derangements using EGF approach\n    \n    Args:\n        n: Number of elements\n    Returns:\n        Number of derangements\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    \n    # EGF approach: D(n) ≈ n! / e\n    # Exact: sum of (-1)^k × n! / k! for k=0 to n\n    result = 0\n    for k in range(n + 1):\n        sign = (-1) ** k\n        result += sign * factorial(n) // factorial(k)\n    \n    return result\n\nprint(derangement_egf(5))",
    "testCases": [
      {
        "input": "5",
        "isHidden": false,
        "description": "D(5) = 44"
      },
      {
        "input": "4",
        "isHidden": false,
        "description": "D(4) = 9"
      },
      {
        "input": "6",
        "isHidden": true,
        "description": "D(6) = 265"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "D(1) = 0"
      }
    ],
    "hints": [
      "D(n) = n! × sum of (-1)^k/k! for k=0 to n",
      "This is n!/e rounded to nearest integer"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex15",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "Young Tableaux Counting",
    "difficulty": 5,
    "description": "Count the number of standard Young tableaux of a given shape using the hook length formula.",
    "starterCode": "from math import factorial\n\ndef count_tableaux(shape):\n    \"\"\"Count standard Young tableaux using hook length formula\n    \n    Args:\n        shape: Partition as list [λ1, λ2, ...]\n    Returns:\n        Number of standard Young tableaux\n    \"\"\"\n    pass\n\nprint(count_tableaux([3, 2, 1]))",
    "solution": "from math import factorial\n\ndef count_tableaux(shape):\n    \"\"\"Count standard Young tableaux using hook length formula\n    \n    Args:\n        shape: Partition as list [λ1, λ2, ...]\n    Returns:\n        Number of standard Young tableaux\n    \"\"\"\n    if not shape:\n        return 1\n    \n    n = sum(shape)\n    hook_product = 1\n    \n    for i, row_len in enumerate(shape):\n        for j in range(row_len):\n            # Hook length = cells to right + cells below + 1\n            cells_right = row_len - j - 1\n            cells_below = sum(1 for k in range(i + 1, len(shape)) if shape[k] > j)\n            hook_length = cells_right + cells_below + 1\n            hook_product *= hook_length\n    \n    return factorial(n) // hook_product\n\nprint(count_tableaux([3, 2, 1]))",
    "testCases": [
      {
        "input": "[3, 2, 1]",
        "isHidden": false,
        "description": "Shape [3,2,1]: 16 tableaux"
      },
      {
        "input": "[3, 2]",
        "isHidden": false,
        "description": "Shape [3,2]: 5 tableaux"
      },
      {
        "input": "[4, 3, 2, 1]",
        "isHidden": true,
        "description": "Larger staircase"
      },
      {
        "input": "[3, 3]",
        "isHidden": true,
        "description": "Rectangle 2×3"
      }
    ],
    "hints": [
      "Hook length = cells right + cells below + 1",
      "Answer = n! / (product of all hook lengths)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t6-ex16",
    "subjectId": "math102",
    "topicId": "math102-6",
    "title": "q-Binomial Coefficients",
    "difficulty": 5,
    "description": "Compute the q-binomial coefficient (Gaussian binomial coefficient) [n k]_q, which counts k-dimensional subspaces of an n-dimensional vector space over GF(q).",
    "starterCode": "def q_binomial(n, k, q):\n    \"\"\"Compute q-binomial coefficient [n k]_q\n    \n    Args:\n        n: Upper parameter\n        k: Lower parameter  \n        q: Base\n    Returns:\n        q-binomial coefficient\n    \"\"\"\n    pass\n\nprint(q_binomial(5, 2, 2))",
    "solution": "def q_binomial(n, k, q):\n    \"\"\"Compute q-binomial coefficient [n k]_q\n    \n    Args:\n        n: Upper parameter\n        k: Lower parameter\n        q: Base\n    Returns:\n        q-binomial coefficient\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # [n k]_q = product of (q^i - 1) for i in range / similar for denominator\n    def q_factorial(m):\n        \"\"\"Compute [m]_q! = [1]_q × [2]_q × ... × [m]_q\"\"\"\n        result = 1\n        for i in range(1, m + 1):\n            # [i]_q = (q^i - 1)/(q - 1)\n            result *= (q**i - 1)\n        return result\n    \n    numerator = q_factorial(n)\n    denominator = q_factorial(k) * q_factorial(n - k)\n    \n    # Additional powers of (q-1)\n    for i in range(k):\n        numerator //= (q - 1)\n    for i in range(n - k):\n        numerator //= (q - 1)\n    \n    return numerator // denominator\n\nprint(q_binomial(5, 2, 2))",
    "testCases": [
      {
        "input": "5, 2, 2",
        "isHidden": false,
        "description": "[5 2]_2 (GF(2) subspaces)"
      },
      {
        "input": "4, 2, 2",
        "isHidden": false,
        "description": "[4 2]_2 = 35"
      },
      {
        "input": "6, 3, 2",
        "isHidden": true,
        "description": "Larger dimension"
      },
      {
        "input": "3, 1, 3",
        "isHidden": true,
        "description": "[3 1]_3 = 13"
      }
    ],
    "hints": [
      "[n]_q = (q^n - 1)/(q - 1)",
      "[n]_q! = [1]_q × [2]_q × ... × [n]_q",
      "[n k]_q = [n]_q! / ([k]_q! × [n-k]_q!)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex01",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Sample Space Generation",
    "difficulty": 1,
    "description": "Generate the sample space for rolling two dice.",
    "starterCode": "def dice_sample_space():\n    \"\"\"Generate all outcomes of rolling two dice\n    \n    Returns:\n        List of tuples (die1, die2)\n    \"\"\"\n    pass\n\nprint(len(dice_sample_space()))",
    "solution": "def dice_sample_space():\n    \"\"\"Generate all outcomes of rolling two dice\n    \n    Returns:\n        List of tuples (die1, die2)\n    \"\"\"\n    sample_space = []\n    for die1 in range(1, 7):\n        for die2 in range(1, 7):\n            sample_space.append((die1, die2))\n    return sample_space\n\nprint(len(dice_sample_space()))",
    "testCases": [
      {
        "input": "",
        "isHidden": false,
        "description": "Sample space has 36 outcomes"
      },
      {
        "input": "",
        "isHidden": true,
        "description": "All pairs (1,1) to (6,6)"
      }
    ],
    "hints": [
      "Two nested loops from 1 to 6",
      "Total outcomes = 6 × 6 = 36"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex02",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Basic Probability",
    "difficulty": 1,
    "description": "Calculate the probability of rolling a sum of 7 with two dice.",
    "starterCode": "def prob_sum_seven():\n    \"\"\"Calculate P(sum = 7) for two dice\n    \n    Returns:\n        Probability as a fraction\n    \"\"\"\n    pass\n\nprint(prob_sum_seven())",
    "solution": "def prob_sum_seven():\n    \"\"\"Calculate P(sum = 7) for two dice\n    \n    Returns:\n        Probability as a fraction\n    \"\"\"\n    favorable = 0\n    total = 0\n    \n    for die1 in range(1, 7):\n        for die2 in range(1, 7):\n            total += 1\n            if die1 + die2 == 7:\n                favorable += 1\n    \n    return favorable / total\n\nprint(prob_sum_seven())",
    "testCases": [
      {
        "input": "",
        "isHidden": false,
        "description": "P(sum=7) = 6/36 = 1/6"
      },
      {
        "input": "",
        "isHidden": true,
        "description": "Approx 0.1667"
      }
    ],
    "hints": [
      "Count favorable outcomes: (1,6), (2,5), (3,4), etc.",
      "6 favorable out of 36 total"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex03",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Conditional Probability",
    "difficulty": 2,
    "description": "Calculate P(A|B) where A is \"sum > 7\" and B is \"first die is 4\" for two dice.",
    "starterCode": "def conditional_prob():\n    \"\"\"Calculate P(sum > 7 | first die = 4)\n    \n    Returns:\n        Conditional probability\n    \"\"\"\n    pass\n\nprint(conditional_prob())",
    "solution": "def conditional_prob():\n    \"\"\"Calculate P(sum > 7 | first die = 4)\n    \n    Returns:\n        Conditional probability\n    \"\"\"\n    # Count outcomes where first die = 4\n    b_outcomes = 0\n    # Count outcomes where first die = 4 AND sum > 7\n    a_and_b = 0\n    \n    for die2 in range(1, 7):\n        b_outcomes += 1\n        if 4 + die2 > 7:\n            a_and_b += 1\n    \n    return a_and_b / b_outcomes\n\nprint(conditional_prob())",
    "testCases": [
      {
        "input": "",
        "isHidden": false,
        "description": "P(sum>7|die1=4) = 3/6 = 0.5"
      },
      {
        "input": "",
        "isHidden": true,
        "description": "die2 must be 4, 5, or 6"
      }
    ],
    "hints": [
      "P(A|B) = P(A ∩ B) / P(B)",
      "When die1=4, sum>7 requires die2>3"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex04",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Bayes' Theorem",
    "difficulty": 3,
    "description": "Given P(Disease)=0.01, P(+|Disease)=0.95, P(+|No Disease)=0.05, calculate P(Disease|+).",
    "starterCode": "def bayes_disease(p_disease, p_pos_given_disease, p_pos_given_no_disease):\n    \"\"\"Calculate P(Disease | positive test)\n    \n    Args:\n        p_disease: Prior probability of disease\n        p_pos_given_disease: P(+ | Disease)\n        p_pos_given_no_disease: P(+ | No Disease)\n    Returns:\n        P(Disease | +)\n    \"\"\"\n    pass\n\nprint(bayes_disease(0.01, 0.95, 0.05))",
    "solution": "def bayes_disease(p_disease, p_pos_given_disease, p_pos_given_no_disease):\n    \"\"\"Calculate P(Disease | positive test)\n    \n    Args:\n        p_disease: Prior probability of disease\n        p_pos_given_disease: P(+ | Disease)\n        p_pos_given_no_disease: P(+ | No Disease)\n    Returns:\n        P(Disease | +)\n    \"\"\"\n    # P(+) = P(+ | D) × P(D) + P(+ | ¬D) × P(¬D)\n    p_pos = (p_pos_given_disease * p_disease + \n             p_pos_given_no_disease * (1 - p_disease))\n    \n    # Bayes: P(D | +) = P(+ | D) × P(D) / P(+)\n    return (p_pos_given_disease * p_disease) / p_pos\n\nprint(bayes_disease(0.01, 0.95, 0.05))",
    "testCases": [
      {
        "input": "0.01, 0.95, 0.05",
        "isHidden": false,
        "description": "P(Disease|+) ≈ 0.161"
      },
      {
        "input": "0.1, 0.99, 0.01",
        "isHidden": false,
        "description": "Higher base rate"
      },
      {
        "input": "0.001, 0.99, 0.01",
        "isHidden": true,
        "description": "Rare disease"
      },
      {
        "input": "0.5, 0.9, 0.1",
        "isHidden": true,
        "description": "High base rate"
      }
    ],
    "hints": [
      "Use law of total probability for P(+)",
      "Bayes: P(A|B) = P(B|A)×P(A) / P(B)"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex05",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Expected Value of Dice",
    "difficulty": 2,
    "description": "Calculate the expected value of rolling a fair six-sided die.",
    "starterCode": "def expected_die():\n    \"\"\"Calculate E[X] for a fair die\n    \n    Returns:\n        Expected value\n    \"\"\"\n    pass\n\nprint(expected_die())",
    "solution": "def expected_die():\n    \"\"\"Calculate E[X] for a fair die\n    \n    Returns:\n        Expected value\n    \"\"\"\n    total = 0\n    for outcome in range(1, 7):\n        probability = 1/6\n        total += outcome * probability\n    return total\n\nprint(expected_die())",
    "testCases": [
      {
        "input": "",
        "isHidden": false,
        "description": "E[X] = 3.5"
      },
      {
        "input": "",
        "isHidden": true,
        "description": "(1+2+3+4+5+6)/6 = 21/6"
      }
    ],
    "hints": [
      "E[X] = sum of x × P(X=x)",
      "For fair die: (1+2+3+4+5+6)/6 = 3.5"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex06",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Variance of Random Variable",
    "difficulty": 2,
    "description": "Calculate the variance of a fair six-sided die roll.",
    "starterCode": "def variance_die():\n    \"\"\"Calculate Var(X) for a fair die\n    \n    Returns:\n        Variance\n    \"\"\"\n    pass\n\nprint(variance_die())",
    "solution": "def variance_die():\n    \"\"\"Calculate Var(X) for a fair die\n    \n    Returns:\n        Variance\n    \"\"\"\n    # E[X]\n    expected = sum(range(1, 7)) / 6\n    \n    # E[X^2]\n    expected_sq = sum(x**2 for x in range(1, 7)) / 6\n    \n    # Var(X) = E[X^2] - (E[X])^2\n    return expected_sq - expected**2\n\nprint(variance_die())",
    "testCases": [
      {
        "input": "",
        "isHidden": false,
        "description": "Var(X) ≈ 2.917"
      },
      {
        "input": "",
        "isHidden": true,
        "description": "E[X²]=15.167, E[X]=3.5"
      }
    ],
    "hints": [
      "Var(X) = E[X²] - (E[X])²",
      "Calculate both E[X] and E[X²]"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex07",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Binomial Distribution",
    "difficulty": 3,
    "description": "Calculate P(X = k) for a binomial distribution with n trials and probability p.",
    "starterCode": "from math import comb\n\ndef binomial_prob(n, k, p):\n    \"\"\"Calculate P(X = k) for Binomial(n, p)\n    \n    Args:\n        n: Number of trials\n        k: Number of successes\n        p: Probability of success\n    Returns:\n        P(X = k)\n    \"\"\"\n    pass\n\nprint(binomial_prob(10, 3, 0.5))",
    "solution": "from math import comb\n\ndef binomial_prob(n, k, p):\n    \"\"\"Calculate P(X = k) for Binomial(n, p)\n    \n    Args:\n        n: Number of trials\n        k: Number of successes\n        p: Probability of success\n    Returns:\n        P(X = k)\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    \n    # P(X = k) = C(n,k) × p^k × (1-p)^(n-k)\n    return comb(n, k) * (p ** k) * ((1 - p) ** (n - k))\n\nprint(binomial_prob(10, 3, 0.5))",
    "testCases": [
      {
        "input": "10, 3, 0.5",
        "isHidden": false,
        "description": "P(X=3) with n=10, p=0.5"
      },
      {
        "input": "5, 2, 0.3",
        "isHidden": false,
        "description": "P(X=2) with n=5, p=0.3"
      },
      {
        "input": "20, 10, 0.5",
        "isHidden": true,
        "description": "Middle value"
      },
      {
        "input": "10, 0, 0.1",
        "isHidden": true,
        "description": "P(X=0)"
      }
    ],
    "hints": [
      "P(X=k) = C(n,k) × p^k × (1-p)^(n-k)",
      "Use binomial coefficient"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex08",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Expected Value of Binomial",
    "difficulty": 2,
    "description": "Calculate the expected value of a binomial distribution.",
    "starterCode": "def expected_binomial(n, p):\n    \"\"\"Calculate E[X] for Binomial(n, p)\n    \n    Args:\n        n: Number of trials\n        p: Probability of success\n    Returns:\n        Expected value\n    \"\"\"\n    pass\n\nprint(expected_binomial(100, 0.3))",
    "solution": "def expected_binomial(n, p):\n    \"\"\"Calculate E[X] for Binomial(n, p)\n    \n    Args:\n        n: Number of trials\n        p: Probability of success\n    Returns:\n        Expected value\n    \"\"\"\n    # For binomial: E[X] = n × p\n    return n * p\n\nprint(expected_binomial(100, 0.3))",
    "testCases": [
      {
        "input": "100, 0.3",
        "isHidden": false,
        "description": "E[X] = 30"
      },
      {
        "input": "50, 0.5",
        "isHidden": false,
        "description": "E[X] = 25"
      },
      {
        "input": "1000, 0.01",
        "isHidden": true,
        "description": "E[X] = 10"
      },
      {
        "input": "20, 0.9",
        "isHidden": true,
        "description": "E[X] = 18"
      }
    ],
    "hints": [
      "E[X] = n × p for binomial distribution",
      "This is a well-known formula"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex09",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Geometric Distribution",
    "difficulty": 3,
    "description": "Calculate P(X = k) for geometric distribution (number of trials until first success).",
    "starterCode": "def geometric_prob(k, p):\n    \"\"\"Calculate P(X = k) for Geometric(p)\n    \n    Args:\n        k: Trial number of first success\n        p: Probability of success\n    Returns:\n        P(X = k)\n    \"\"\"\n    pass\n\nprint(geometric_prob(3, 0.5))",
    "solution": "def geometric_prob(k, p):\n    \"\"\"Calculate P(X = k) for Geometric(p)\n    \n    Args:\n        k: Trial number of first success\n        p: Probability of success\n    Returns:\n        P(X = k)\n    \"\"\"\n    if k < 1:\n        return 0\n    \n    # P(X = k) = (1-p)^(k-1) × p\n    return ((1 - p) ** (k - 1)) * p\n\nprint(geometric_prob(3, 0.5))",
    "testCases": [
      {
        "input": "3, 0.5",
        "isHidden": false,
        "description": "P(X=3) = 0.25 × 0.5 = 0.125"
      },
      {
        "input": "1, 0.5",
        "isHidden": false,
        "description": "P(X=1) = 0.5"
      },
      {
        "input": "5, 0.2",
        "isHidden": true,
        "description": "P(X=5) with p=0.2"
      },
      {
        "input": "1, 1.0",
        "isHidden": true,
        "description": "Certain success: P(X=1)=1"
      }
    ],
    "hints": [
      "P(X=k) = (1-p)^(k-1) × p",
      "k-1 failures then 1 success"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex10",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Expected Value of Geometric",
    "difficulty": 2,
    "description": "Calculate the expected number of trials until first success in geometric distribution.",
    "starterCode": "def expected_geometric(p):\n    \"\"\"Calculate E[X] for Geometric(p)\n    \n    Args:\n        p: Probability of success\n    Returns:\n        Expected value\n    \"\"\"\n    pass\n\nprint(expected_geometric(0.2))",
    "solution": "def expected_geometric(p):\n    \"\"\"Calculate E[X] for Geometric(p)\n    \n    Args:\n        p: Probability of success\n    Returns:\n        Expected value\n    \"\"\"\n    # For geometric: E[X] = 1/p\n    return 1 / p\n\nprint(expected_geometric(0.2))",
    "testCases": [
      {
        "input": "0.2",
        "isHidden": false,
        "description": "E[X] = 5"
      },
      {
        "input": "0.5",
        "isHidden": false,
        "description": "E[X] = 2"
      },
      {
        "input": "0.1",
        "isHidden": true,
        "description": "E[X] = 10"
      },
      {
        "input": "1.0",
        "isHidden": true,
        "description": "E[X] = 1"
      }
    ],
    "hints": [
      "E[X] = 1/p for geometric distribution",
      "Intuitive: if p=0.5, expect 2 trials"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex11",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Independence Test",
    "difficulty": 2,
    "description": "Check if two events A and B are independent given their probabilities.",
    "starterCode": "def are_independent(p_a, p_b, p_a_and_b):\n    \"\"\"Check if P(A ∩ B) = P(A) × P(B)\n    \n    Args:\n        p_a: P(A)\n        p_b: P(B)\n        p_a_and_b: P(A ∩ B)\n    Returns:\n        True if independent\n    \"\"\"\n    pass\n\nprint(are_independent(0.5, 0.5, 0.25))",
    "solution": "def are_independent(p_a, p_b, p_a_and_b):\n    \"\"\"Check if P(A ∩ B) = P(A) × P(B)\n    \n    Args:\n        p_a: P(A)\n        p_b: P(B)\n        p_a_and_b: P(A ∩ B)\n    Returns:\n        True if independent\n    \"\"\"\n    # Use small epsilon for floating point comparison\n    epsilon = 1e-10\n    return abs(p_a_and_b - (p_a * p_b)) < epsilon\n\nprint(are_independent(0.5, 0.5, 0.25))",
    "testCases": [
      {
        "input": "0.5, 0.5, 0.25",
        "isHidden": false,
        "description": "Independent (0.25 = 0.5×0.5)"
      },
      {
        "input": "0.3, 0.4, 0.12",
        "isHidden": false,
        "description": "Independent"
      },
      {
        "input": "0.5, 0.5, 0.3",
        "isHidden": true,
        "description": "Not independent"
      },
      {
        "input": "0.2, 0.3, 0.0",
        "isHidden": true,
        "description": "Mutually exclusive, not independent"
      }
    ],
    "hints": [
      "Events are independent iff P(A∩B) = P(A)×P(B)",
      "Use epsilon for float comparison"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex12",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Hypergeometric Distribution",
    "difficulty": 4,
    "description": "Calculate probability of k successes in n draws without replacement from population of N items with K successes.",
    "starterCode": "from math import comb\n\ndef hypergeometric_prob(N, K, n, k):\n    \"\"\"Calculate P(X = k) for hypergeometric distribution\n    \n    Args:\n        N: Population size\n        K: Number of success states in population\n        n: Number of draws\n        k: Number of observed successes\n    Returns:\n        P(X = k)\n    \"\"\"\n    pass\n\nprint(hypergeometric_prob(52, 13, 5, 2))",
    "solution": "from math import comb\n\ndef hypergeometric_prob(N, K, n, k):\n    \"\"\"Calculate P(X = k) for hypergeometric distribution\n    \n    Args:\n        N: Population size\n        K: Number of success states in population\n        n: Number of draws\n        k: Number of observed successes\n    Returns:\n        P(X = k)\n    \"\"\"\n    if k > K or k > n or n - k > N - K:\n        return 0\n    \n    # P(X = k) = C(K,k) × C(N-K, n-k) / C(N,n)\n    numerator = comb(K, k) * comb(N - K, n - k)\n    denominator = comb(N, n)\n    \n    return numerator / denominator\n\nprint(hypergeometric_prob(52, 13, 5, 2))",
    "testCases": [
      {
        "input": "52, 13, 5, 2",
        "isHidden": false,
        "description": "Drawing 2 hearts from 5 cards"
      },
      {
        "input": "20, 7, 5, 3",
        "isHidden": false,
        "description": "3 successes from 5 draws"
      },
      {
        "input": "50, 10, 10, 5",
        "isHidden": true,
        "description": "Larger population"
      },
      {
        "input": "10, 5, 3, 2",
        "isHidden": true,
        "description": "Small population"
      }
    ],
    "hints": [
      "P(X=k) = C(K,k)×C(N-K,n-k) / C(N,n)",
      "Sampling without replacement"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex13",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Poisson Distribution",
    "difficulty": 3,
    "description": "Calculate P(X = k) for Poisson distribution with rate parameter λ.",
    "starterCode": "from math import factorial, exp\n\ndef poisson_prob(lam, k):\n    \"\"\"Calculate P(X = k) for Poisson(λ)\n    \n    Args:\n        lam: Rate parameter λ\n        k: Number of events\n    Returns:\n        P(X = k)\n    \"\"\"\n    pass\n\nprint(poisson_prob(3.5, 2))",
    "solution": "from math import factorial, exp\n\ndef poisson_prob(lam, k):\n    \"\"\"Calculate P(X = k) for Poisson(λ)\n    \n    Args:\n        lam: Rate parameter λ\n        k: Number of events\n    Returns:\n        P(X = k)\n    \"\"\"\n    if k < 0:\n        return 0\n    \n    # P(X = k) = (λ^k × e^(-λ)) / k!\n    return (lam ** k) * exp(-lam) / factorial(k)\n\nprint(poisson_prob(3.5, 2))",
    "testCases": [
      {
        "input": "3.5, 2",
        "isHidden": false,
        "description": "P(X=2) with λ=3.5"
      },
      {
        "input": "5, 5",
        "isHidden": false,
        "description": "P(X=5) with λ=5"
      },
      {
        "input": "1, 0",
        "isHidden": true,
        "description": "P(X=0) = e^(-1)"
      },
      {
        "input": "10, 10",
        "isHidden": true,
        "description": "Mean = mode for λ=10"
      }
    ],
    "hints": [
      "P(X=k) = (λ^k × e^(-λ)) / k!",
      "Models rare events"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex14",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Markov Inequality",
    "difficulty": 4,
    "description": "Use Markov's inequality to bound P(X ≥ a) for a non-negative random variable.",
    "starterCode": "def markov_bound(expected_value, a):\n    \"\"\"Calculate upper bound on P(X ≥ a) using Markov inequality\n    \n    Args:\n        expected_value: E[X]\n        a: Threshold (a > 0)\n    Returns:\n        Upper bound on P(X ≥ a)\n    \"\"\"\n    pass\n\nprint(markov_bound(10, 50))",
    "solution": "def markov_bound(expected_value, a):\n    \"\"\"Calculate upper bound on P(X ≥ a) using Markov inequality\n    \n    Args:\n        expected_value: E[X]\n        a: Threshold (a > 0)\n    Returns:\n        Upper bound on P(X ≥ a)\n    \"\"\"\n    if a <= 0:\n        return 1  # Trivial bound\n    \n    # Markov: P(X ≥ a) ≤ E[X] / a\n    return min(1, expected_value / a)\n\nprint(markov_bound(10, 50))",
    "testCases": [
      {
        "input": "10, 50",
        "isHidden": false,
        "description": "P(X≥50) ≤ 10/50 = 0.2"
      },
      {
        "input": "20, 100",
        "isHidden": false,
        "description": "P(X≥100) ≤ 0.2"
      },
      {
        "input": "100, 50",
        "isHidden": true,
        "description": "Bound > 1, return 1"
      },
      {
        "input": "5, 25",
        "isHidden": true,
        "description": "P(X≥25) ≤ 0.2"
      }
    ],
    "hints": [
      "Markov: P(X ≥ a) ≤ E[X]/a",
      "Only valid for non-negative X",
      "Bound cannot exceed 1"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex15",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Chebyshev Inequality",
    "difficulty": 4,
    "description": "Use Chebyshev's inequality to bound P(|X - μ| ≥ kσ).",
    "starterCode": "def chebyshev_bound(k):\n    \"\"\"Calculate upper bound on P(|X - μ| ≥ kσ)\n    \n    Args:\n        k: Number of standard deviations\n    Returns:\n        Upper bound\n    \"\"\"\n    pass\n\nprint(chebyshev_bound(2))",
    "solution": "def chebyshev_bound(k):\n    \"\"\"Calculate upper bound on P(|X - μ| ≥ kσ)\n    \n    Args:\n        k: Number of standard deviations\n    Returns:\n        Upper bound\n    \"\"\"\n    if k <= 0:\n        return 1\n    \n    # Chebyshev: P(|X - μ| ≥ kσ) ≤ 1/k²\n    return min(1, 1 / (k ** 2))\n\nprint(chebyshev_bound(2))",
    "testCases": [
      {
        "input": "2",
        "isHidden": false,
        "description": "P(|X-μ|≥2σ) ≤ 0.25"
      },
      {
        "input": "3",
        "isHidden": false,
        "description": "P(|X-μ|≥3σ) ≤ 0.111"
      },
      {
        "input": "1",
        "isHidden": true,
        "description": "P(|X-μ|≥1σ) ≤ 1"
      },
      {
        "input": "5",
        "isHidden": true,
        "description": "P(|X-μ|≥5σ) ≤ 0.04"
      }
    ],
    "hints": [
      "Chebyshev: P(|X-μ| ≥ kσ) ≤ 1/k²",
      "At k=2: at most 25% outside 2σ"
    ],
    "language": "python"
  },
  {
    "id": "math102-t7-ex16",
    "subjectId": "math102",
    "topicId": "math102-7",
    "title": "Monte Carlo Simulation",
    "difficulty": 5,
    "description": "Estimate π using Monte Carlo simulation by randomly sampling points in a unit square.",
    "starterCode": "import random\n\ndef estimate_pi(num_samples):\n    \"\"\"Estimate π using Monte Carlo method\n    \n    Args:\n        num_samples: Number of random points\n    Returns:\n        Estimated value of π\n    \"\"\"\n    pass\n\nrandom.seed(42)\nprint(estimate_pi(100000))",
    "solution": "import random\n\ndef estimate_pi(num_samples):\n    \"\"\"Estimate π using Monte Carlo method\n    \n    Args:\n        num_samples: Number of random points\n    Returns:\n        Estimated value of π\n    \"\"\"\n    inside_circle = 0\n    \n    for _ in range(num_samples):\n        x = random.uniform(-1, 1)\n        y = random.uniform(-1, 1)\n        \n        # Check if point is inside unit circle\n        if x**2 + y**2 <= 1:\n            inside_circle += 1\n    \n    # Ratio of areas: π/4 = inside_circle / num_samples\n    return 4 * inside_circle / num_samples\n\nrandom.seed(42)\nprint(estimate_pi(100000))",
    "testCases": [
      {
        "input": "100000",
        "isHidden": false,
        "description": "Estimate close to 3.14159"
      },
      {
        "input": "10000",
        "isHidden": false,
        "description": "Less accurate estimate"
      },
      {
        "input": "1000000",
        "isHidden": true,
        "description": "More accurate estimate"
      },
      {
        "input": "1000",
        "isHidden": true,
        "description": "Rough estimate"
      }
    ],
    "hints": [
      "Sample random points in [-1,1] × [-1,1]",
      "Check if x²+y² ≤ 1",
      "π ≈ 4 × (points in circle) / (total points)"
    ],
    "language": "python"
  }
]
[
  {
    "id": "cs102-ex-2",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Binary Addition Calculator",
    "difficulty": 3,
    "description": "Implement a function that performs binary addition on two binary strings and returns the result as a binary string. Do not use built-in base conversion functions.",
    "starterCode": "def binary_addition(bin1, bin2):\n    \"\"\"\n    Add two binary numbers represented as strings.\n    \n    Args:\n        bin1: First binary number as string (e.g., \"1011\")\n        bin2: Second binary number as string (e.g., \"0110\")\n    \n    Returns:\n        Sum as binary string\n    \"\"\"\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "Start adding from the rightmost bit (least significant bit)",
      "Keep track of the carry bit as you move left",
      "Pad the shorter string with leading zeros to make both strings equal length"
    ],
    "solution": "def binary_addition(bin1, bin2):\n    max_len = max(len(bin1), len(bin2))\n    bin1 = bin1.zfill(max_len)\n    bin2 = bin2.zfill(max_len)\n    \n    result = []\n    carry = 0\n    \n    for i in range(max_len - 1, -1, -1):\n        bit_sum = int(bin1[i]) + int(bin2[i]) + carry\n        result.append(str(bit_sum % 2))\n        carry = bit_sum // 2\n    \n    if carry:\n        result.append(\"1\")\n    \n    return \"\".join(reversed(result))",
    "language": "python"
  },
  {
    "id": "cs102-t2-ex02",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Binary Increment",
    "difficulty": 1,
    "description": "Write a function that adds 1 to a binary number string.",
    "starterCode": "# Add 1 to a binary number\ndef binary_increment(binary_str):\n    # Your code here\n    pass\n\nprint(binary_increment(\"1010\"))\nprint(binary_increment(\"1111\"))",
    "solution": "def binary_increment(binary_str):\n    result = list(binary_str)\n    carry = 1\n    for i in range(len(result) - 1, -1, -1):\n        if carry == 0:\n            break\n        if result[i] == \"0\":\n            result[i] = \"1\"\n            carry = 0\n        else:\n            result[i] = \"0\"\n    if carry:\n        result.insert(0, \"1\")\n    return \"\".join(result)\n\nprint(binary_increment(\"1010\"))\nprint(binary_increment(\"1111\"))",
    "testCases": [],
    "hints": [
      "Start from the rightmost bit",
      "If bit is 0, change to 1 and done",
      "If bit is 1, change to 0 and continue (carry)"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex03",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Ones Complement",
    "difficulty": 1,
    "description": "Write a function that returns the ones complement of a binary string (flip all bits).",
    "starterCode": "# Get ones complement (flip all bits)\ndef ones_complement(binary_str):\n    # Your code here\n    pass\n\nprint(ones_complement(\"1010\"))\nprint(ones_complement(\"11110000\"))",
    "solution": "def ones_complement(binary_str):\n    result = \"\"\n    for bit in binary_str:\n        result += \"0\" if bit == \"1\" else \"1\"\n    return result\n\nprint(ones_complement(\"1010\"))\nprint(ones_complement(\"11110000\"))",
    "testCases": [],
    "hints": [
      "Flip each bit: 0 becomes 1, 1 becomes 0",
      "Process each character in the string",
      "Build the result string"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex04",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Twos Complement",
    "difficulty": 2,
    "description": "Write a function that returns the twos complement of a binary string. Twos complement = ones complement + 1.",
    "starterCode": "# Get twos complement\ndef twos_complement(binary_str):\n    # Your code here\n    pass\n\nprint(twos_complement(\"0101\"))  # 5 becomes -5\nprint(twos_complement(\"0001\"))  # 1 becomes -1",
    "solution": "def twos_complement(binary_str):\n    # First get ones complement\n    ones = \"\"\n    for bit in binary_str:\n        ones += \"0\" if bit == \"1\" else \"1\"\n    \n    # Add 1\n    result = list(ones)\n    carry = 1\n    for i in range(len(result) - 1, -1, -1):\n        if carry == 0:\n            break\n        if result[i] == \"0\":\n            result[i] = \"1\"\n            carry = 0\n        else:\n            result[i] = \"0\"\n    return \"\".join(result)\n\nprint(twos_complement(\"0101\"))\nprint(twos_complement(\"0001\"))",
    "testCases": [],
    "hints": [
      "First compute ones complement (flip all bits)",
      "Then add 1 to the result",
      "Handle the carry propagation"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex05",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Binary Subtraction",
    "difficulty": 3,
    "description": "Write a function that subtracts two binary numbers (bin1 - bin2) using twos complement addition.",
    "starterCode": "# Subtract binary numbers using twos complement\ndef binary_subtract(bin1, bin2):\n    # Your code here\n    pass\n\nprint(binary_subtract(\"1010\", \"0011\"))  # 10 - 3 = 7",
    "solution": "def binary_subtract(bin1, bin2):\n    # Ensure same length\n    max_len = max(len(bin1), len(bin2))\n    bin1 = bin1.zfill(max_len)\n    bin2 = bin2.zfill(max_len)\n    \n    # Get twos complement of bin2\n    twos = \"\"\n    for bit in bin2:\n        twos += \"0\" if bit == \"1\" else \"1\"\n    # Add 1\n    twos_list = list(twos)\n    carry = 1\n    for i in range(len(twos_list) - 1, -1, -1):\n        if carry == 0:\n            break\n        if twos_list[i] == \"0\":\n            twos_list[i] = \"1\"\n            carry = 0\n        else:\n            twos_list[i] = \"0\"\n    twos = \"\".join(twos_list)\n    \n    # Add bin1 + twos complement of bin2\n    result = []\n    carry = 0\n    for i in range(max_len - 1, -1, -1):\n        bit_sum = int(bin1[i]) + int(twos[i]) + carry\n        result.append(str(bit_sum % 2))\n        carry = bit_sum // 2\n    \n    return \"\".join(reversed(result))\n\nprint(binary_subtract(\"1010\", \"0011\"))",
    "testCases": [],
    "hints": [
      "Subtraction A - B = A + (-B)",
      "-B in binary is the twos complement of B",
      "Add bin1 and the twos complement of bin2"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex06",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Detect Overflow",
    "difficulty": 3,
    "description": "Write a function that adds two signed binary numbers and detects if overflow occurred. Use 8-bit signed representation.",
    "starterCode": "# Add signed binary and detect overflow\ndef add_with_overflow(bin1, bin2):\n    # Returns tuple: (result, overflow_occurred)\n    # Your code here\n    pass\n\nprint(add_with_overflow(\"01111111\", \"00000001\"))  # 127 + 1, overflow!",
    "solution": "def add_with_overflow(bin1, bin2):\n    # Ensure 8 bits\n    bin1 = bin1.zfill(8)\n    bin2 = bin2.zfill(8)\n    \n    # Add\n    result = []\n    carry = 0\n    for i in range(7, -1, -1):\n        bit_sum = int(bin1[i]) + int(bin2[i]) + carry\n        result.append(str(bit_sum % 2))\n        carry = bit_sum // 2\n    \n    result_str = \"\".join(reversed(result))\n    \n    # Overflow if signs of operands are same but result sign differs\n    sign1 = bin1[0]\n    sign2 = bin2[0]\n    result_sign = result_str[0]\n    \n    overflow = (sign1 == sign2) and (result_sign != sign1)\n    \n    return (result_str, overflow)\n\nprint(add_with_overflow(\"01111111\", \"00000001\"))",
    "testCases": [],
    "hints": [
      "Overflow occurs when adding two positives gives negative",
      "Or when adding two negatives gives positive",
      "Check the sign bit (MSB) of inputs and result"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex07",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Binary Multiplication",
    "difficulty": 4,
    "description": "Write a function that multiplies two binary numbers using the shift-and-add method.",
    "starterCode": "# Multiply binary numbers using shift-and-add\ndef binary_multiply(bin1, bin2):\n    # Your code here\n    pass\n\nprint(binary_multiply(\"101\", \"11\"))  # 5 * 3 = 15",
    "solution": "def binary_multiply(bin1, bin2):\n    # Convert to integers for simplicity of demonstration\n    # but use binary operations\n    result = \"0\"\n    \n    for i, bit in enumerate(reversed(bin2)):\n        if bit == \"1\":\n            shifted = bin1 + \"0\" * i\n            # Add to result\n            max_len = max(len(result), len(shifted))\n            result = result.zfill(max_len)\n            shifted = shifted.zfill(max_len)\n            \n            new_result = []\n            carry = 0\n            for j in range(max_len - 1, -1, -1):\n                bit_sum = int(result[j]) + int(shifted[j]) + carry\n                new_result.append(str(bit_sum % 2))\n                carry = bit_sum // 2\n            if carry:\n                new_result.append(\"1\")\n            result = \"\".join(reversed(new_result))\n    \n    return result.lstrip(\"0\") or \"0\"\n\nprint(binary_multiply(\"101\", \"11\"))",
    "testCases": [],
    "hints": [
      "For each 1 bit in multiplier, shift multiplicand and add",
      "Shift left = append zeros",
      "Sum all the shifted partial products"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex08",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Signed Integer Representation",
    "difficulty": 5,
    "description": "Write functions to convert between decimal and 8-bit twos complement signed binary.",
    "starterCode": "# Convert between decimal and 8-bit twos complement\ndef decimal_to_signed_binary(n):\n    # n is between -128 and 127\n    # Your code here\n    pass\n\ndef signed_binary_to_decimal(binary_str):\n    # Your code here\n    pass\n\nprint(decimal_to_signed_binary(-5))\nprint(signed_binary_to_decimal(\"11111011\"))",
    "solution": "def decimal_to_signed_binary(n):\n    if n >= 0:\n        return bin(n)[2:].zfill(8)\n    else:\n        # Twos complement for negative\n        return bin(256 + n)[2:]\n\ndef signed_binary_to_decimal(binary_str):\n    binary_str = binary_str.zfill(8)\n    if binary_str[0] == \"0\":\n        # Positive\n        return int(binary_str, 2)\n    else:\n        # Negative - twos complement\n        return int(binary_str, 2) - 256\n\nprint(decimal_to_signed_binary(-5))\nprint(signed_binary_to_decimal(\"11111011\"))",
    "testCases": [],
    "hints": [
      "For positive numbers, just convert to binary",
      "For negative numbers, use twos complement",
      "Shortcut: for n-bit twos complement of -x, compute 2^n - x"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex09",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Binary Division (Restoring)",
    "difficulty": 4,
    "description": "Implement unsigned binary division using the restoring division algorithm. Return the tuple (quotient, remainder) as binary strings.",
    "starterCode": "# Unsigned binary restoring division\ndef binary_divide(dividend, divisor):\n    # Your code here\n    pass\n\nprint(binary_divide(\"1101\", \"11\"))  # (100, 1)",
    "solution": "def binary_divide(dividend, divisor):\n    if divisor == \"0\":\n        raise ValueError(\"divide by zero\")\n    n = len(dividend)\n    divisor_int = int(divisor, 2)\n    remainder = 0\n    quotient_bits = []\n    for bit in dividend:\n        remainder = (remainder << 1) + int(bit)\n        if remainder >= divisor_int:\n            remainder -= divisor_int\n            quotient_bits.append(\"1\")\n        else:\n            quotient_bits.append(\"0\")\n    q = \"\".join(quotient_bits).lstrip(\"0\") or \"0\"\n    r = bin(remainder)[2:]\n    return (q, r)\n\nprint(binary_divide(\"1101\", \"11\"))",
    "testCases": [],
    "hints": [
      "Process bits left to right, keeping a running remainder.",
      "Shift remainder, bring down next bit, compare to divisor.",
      "Set quotient bit to 1 when remainder >= divisor, then subtract."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex10",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Saturating Add (8-bit signed)",
    "difficulty": 3,
    "description": "Implement 8-bit signed addition with saturation. If overflow would occur, clamp to 01111111 (+127) or 10000000 (-128) instead of wrapping.",
    "starterCode": "# Saturating add for 8-bit signed\ndef saturating_add(bin1, bin2):\n    # Return saturated 8-bit binary string\n    pass\n\nprint(saturating_add(\"01111111\", \"00000001\"))  # clamp to 01111111",
    "solution": "def saturating_add(bin1, bin2):\n    bin1 = bin1.zfill(8)\n    bin2 = bin2.zfill(8)\n    a = int(bin1, 2)\n    b = int(bin2, 2)\n    # Interpret as signed\n    def to_signed(x):\n        return x - 256 if x & 0b10000000 else x\n    def to_unsigned(x):\n        return x & 0xFF\n    sa, sb = to_signed(a), to_signed(b)\n    s = sa + sb\n    if s > 127:\n        return \"01111111\"\n    if s < -128:\n        return \"10000000\"\n    return bin(to_unsigned(s))[2:].zfill(8)\n\nprint(saturating_add(\"01111111\", \"00000001\"))",
    "testCases": [],
    "hints": [
      "Convert to signed ints, add, then clamp to [-128, 127].",
      "Convert back to 8-bit two's complement.",
      "Be careful to preserve leading zeros when returning binary."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-drill-1",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Check Signed Overflow (8-bit)",
    "difficulty": 1,
    "description": "Given two 8-bit signed binaries, return True if adding them would overflow in two's complement.",
    "starterCode": "# Detect signed overflow in 8-bit add\ndef will_overflow(a, b):\n    # Your code here\n    pass\n\nprint(will_overflow(\"01111111\", \"00000001\"))  # True",
    "solution": "def will_overflow(a, b):\n    a = a.zfill(8)\n    b = b.zfill(8)\n    sign_a, sign_b = a[0], b[0]\n    # add to get sign of result\n    res = add_bits(a, b)\n    sign_r = res[0]\n    return sign_a == sign_b and sign_r != sign_a\n\ndef add_bits(x, y):\n    max_len = max(len(x), len(y))\n    x = x.zfill(max_len)\n    y = y.zfill(max_len)\n    carry = 0\n    out = []\n    for i in range(max_len - 1, -1, -1):\n        s = int(x[i]) + int(y[i]) + carry\n        out.append(str(s % 2))\n        carry = s // 2\n    if carry:\n        out.append(\"1\")\n    return \"\".join(reversed(out))[-8:]\n\nprint(will_overflow(\"01111111\", \"00000001\"))",
    "testCases": [],
    "hints": [
      "Overflow only when signs of operands match but differ from result sign.",
      "You can simulate addition or reuse existing add logic.",
      "Keep width at 8 bits."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-drill-2",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Half Adder Bitwise",
    "difficulty": 1,
    "description": "Implement a pure-bitwise half-adder function that returns (sum, carry) for inputs a,b âˆˆ {0,1}.",
    "starterCode": "# Half adder using bitwise ops\ndef half_adder_bit(a, b):\n    # Your code here\n    pass\n\nprint(half_adder_bit(1, 1))",
    "solution": "def half_adder_bit(a, b):\n    sum_bit = a ^ b\n    carry = a & b\n    return (sum_bit, carry)\n\nprint(half_adder_bit(1, 1))",
    "testCases": [],
    "hints": [
      "sum = XOR, carry = AND.",
      "Inputs are 0/1 integers."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex13",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Logical Shift Left",
    "difficulty": 1,
    "description": "Implement logical left shift `x << n` without using `<<` operator. Assume 8-bit width.",
    "starterCode": "def logical_lshift(x, n):\n    # Your code here\n    pass\n\nprint(logical_lshift(3, 2)) # 12",
    "solution": "def logical_lshift(x, n):\n    return (x * (2**n)) & 0xFF\n\nprint(logical_lshift(3, 2))",
    "testCases": [],
    "hints": [
      "Left shift by n is equivalent to multiplying by 2^n.",
      "Mask with 0xFF to keep 8 bits."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex14",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Logical Shift Right",
    "difficulty": 1,
    "description": "Implement logical right shift `x >> n` without `>>`.",
    "starterCode": "def logical_rshift(x, n):\n    # Your code here\n    pass\n\nprint(logical_rshift(12, 2)) # 3",
    "solution": "def logical_rshift(x, n):\n    return x // (2**n)\n\nprint(logical_rshift(12, 2))",
    "testCases": [],
    "hints": [
      "Right shift by n is integer division by 2^n."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex15",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Rotate Left (8-bit)",
    "difficulty": 3,
    "description": "Rotate bits of an 8-bit integer `x` left by `n` positions.",
    "starterCode": "def rotate_left(x, n):\n    # Your code here\n    pass\n\nprint(rotate_left(0b10000001, 1)) # 0b00000011 (3)",
    "solution": "def rotate_left(x, n):\n    n = n % 8\n    return ((x << n) | (x >> (8 - n))) & 0xFF\n\nprint(rotate_left(0x81, 1))",
    "testCases": [],
    "hints": [
      "Combine left shift and right shift.",
      "Mask with 0xFF."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t2-ex16",
    "subjectId": "cs102",
    "topicId": "cs102-2",
    "title": "Hamming Weight",
    "difficulty": 2,
    "description": "Count the number of 1s in the binary representation of `x` (population count).",
    "starterCode": "def pop_count(x):\n    # Your code here\n    pass\n\nprint(pop_count(15)) # 4 (1111)",
    "solution": "def pop_count(x):\n    return bin(x).count(\"1\")\n\nprint(pop_count(15))",
    "testCases": [],
    "hints": [
      "Convert to binary string and count \"1\"s."
    ],
    "language": "python"
  }
]

[
  {
    "id": "cs102-t6-ex01",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Simulate Register Move",
    "difficulty": 1,
    "description": "Write a function `simulate_mov(registers, dest, src)` where `registers` is a dictionary (e.g., `{\"AX\": 0, \"BX\": 5}`), and `dest`/`src` are register names. The function should copy the value from `src` to `dest` and return the updated dictionary.",
    "starterCode": "def simulate_mov(registers, dest, src):\n    # Your code here\n    pass\n\nregs = {\"AX\": 10, \"BX\": 20}\nprint(simulate_mov(regs, \"AX\", \"BX\"))",
    "solution": "def simulate_mov(registers, dest, src):\n    if src in registers and dest in registers:\n        registers[dest] = registers[src]\n    return registers\n\nregs = {\"AX\": 10, \"BX\": 20}\nprint(simulate_mov(regs, \"AX\", \"BX\"))",
    "testCases": [],
    "hints": [
      "Access the dictionary using the keys provided.",
      "Assign the value of registers[src] to registers[dest]."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex02",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Simulate ADD Instruction",
    "difficulty": 1,
    "description": "Write a function `simulate_add(registers, dest, src)` that adds the value of `src` to `dest` and stores the result in `dest`. Return the updated registers.",
    "starterCode": "def simulate_add(registers, dest, src):\n    # Your code here\n    pass\n\nregs = {\"AX\": 5, \"BX\": 3}\nprint(simulate_add(regs, \"AX\", \"BX\")) # AX should be 8",
    "solution": "def simulate_add(registers, dest, src):\n    registers[dest] += registers[src]\n    return registers\n\nregs = {\"AX\": 5, \"BX\": 3}\nprint(simulate_add(regs, \"AX\", \"BX\"))",
    "testCases": [],
    "hints": [
      "Similar to MOV, but perform addition.",
      "registers[dest] = registers[dest] + registers[src]"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex03",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Simulate Immediate Value",
    "difficulty": 1,
    "description": "Assembly instructions often use \"immediate\" values (constants). Modify `simulate_mov` to handle cases where `src` is an integer (e.g., 5) instead of a register name.",
    "starterCode": "def simulate_mov_imm(registers, dest, src):\n    # src can be a string (register) or int (immediate)\n    # Your code here\n    pass\n\nregs = {\"AX\": 0}\nprint(simulate_mov_imm(regs, \"AX\", 42))",
    "solution": "def simulate_mov_imm(registers, dest, src):\n    if isinstance(src, int):\n        registers[dest] = src\n    elif src in registers:\n        registers[dest] = registers[src]\n    return registers\n\nregs = {\"AX\": 0}\nprint(simulate_mov_imm(regs, \"AX\", 42))",
    "testCases": [],
    "hints": [
      "Check the type of `src` using `isinstance(src, int)`",
      "If it is an int, assign directly. If it is a string, look it up in registers."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex04",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Zero Flag Simulation",
    "difficulty": 2,
    "description": "Write a function `update_zero_flag(result)` that returns `1` if the result is 0, and `0` otherwise. This simulates the CPU Zero Flag (ZF).",
    "starterCode": "def update_zero_flag(result):\n    # Your code here\n    pass\n\nprint(update_zero_flag(0))  # Should return 1\nprint(update_zero_flag(5))  # Should return 0",
    "solution": "def update_zero_flag(result):\n    return 1 if result == 0 else 0\n\nprint(update_zero_flag(0))\nprint(update_zero_flag(5))",
    "testCases": [],
    "hints": [
      "Use a simple if statement or conditional expression.",
      "The Zero Flag is set (1) when the result of an operation is zero."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex05",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Sign Flag Simulation",
    "difficulty": 2,
    "description": "Write a function `update_sign_flag(result, bits=8)` that returns `1` if the result is negative (MSB is 1) in an n-bit system, and `0` otherwise.",
    "starterCode": "def update_sign_flag(result, bits=8):\n    # Your code here\n    pass\n\nprint(update_sign_flag(-5))      # 1\nprint(update_sign_flag(127))     # 0\nprint(update_sign_flag(0xFF, 8)) # 1 (if interpreted as signed 8-bit)",
    "solution": "def update_sign_flag(result, bits=8):\n    # Mask to keep only relevant bits\n    val = result & ((1 << bits) - 1)\n    # Check MSB\n    msb = (val >> (bits - 1)) & 1\n    return msb\n\nprint(update_sign_flag(-5))",
    "testCases": [],
    "hints": [
      "Use bitwise operators to isolate the Most Significant Bit (MSB).",
      "MSB position is `bits - 1`."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex06",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Simulate CMP Instruction",
    "difficulty": 2,
    "description": "The `CMP dest, src` instruction subtracts `src` from `dest` internally to update flags but does NOT store the result. Write `simulate_cmp(dest_val, src_val)` that returns a dict `{\"ZF\": ?, \"SF\": ?}` based on `dest_val - src_val`.",
    "starterCode": "def simulate_cmp(dest_val, src_val):\n    # Returns dictionary with ZF and SF\n    pass\n\nprint(simulate_cmp(5, 5))  # ZF=1, SF=0\nprint(simulate_cmp(5, 10)) # ZF=0, SF=1",
    "solution": "def simulate_cmp(dest_val, src_val):\n    res = dest_val - src_val\n    zf = 1 if res == 0 else 0\n    sf = 1 if res < 0 else 0\n    return {\"ZF\": zf, \"SF\": sf}\n\nprint(simulate_cmp(5, 5))\nprint(simulate_cmp(5, 10))",
    "testCases": [],
    "hints": [
      "Calculate the difference `dest_val - src_val`.",
      "Set ZF to 1 if difference is 0.",
      "Set SF to 1 if difference is negative."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex07",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Jump Condition Checker",
    "difficulty": 3,
    "description": "Implement `check_jump(condition, flags)` where `condition` is a string like \"JE\" (Jump Equal), \"JNE\" (Jump Not Equal), \"JL\" (Jump Less), \"JG\" (Jump Greater), and `flags` is `{\"ZF\": 0/1, \"SF\": 0/1}`. Return True if jump should be taken.",
    "starterCode": "def check_jump(condition, flags):\n    # JE: Jump if ZF=1\n    # JNE: Jump if ZF=0\n    # JL: Jump if SF != OF (simplify to SF=1 for this ex)\n    # JG: Jump if ZF=0 and SF=OF (simplify to ZF=0 and SF=0)\n    pass\n\nprint(check_jump(\"JE\", {\"ZF\": 1, \"SF\": 0}))",
    "solution": "def check_jump(condition, flags):\n    zf = flags.get(\"ZF\", 0)\n    sf = flags.get(\"SF\", 0)\n    if condition == \"JE\":\n        return zf == 1\n    elif condition == \"JNE\":\n        return zf == 0\n    elif condition == \"JL\":\n        return sf == 1\n    elif condition == \"JG\":\n        return zf == 0 and sf == 0\n    return False\n\nprint(check_jump(\"JE\", {\"ZF\": 1, \"SF\": 0}))",
    "testCases": [],
    "hints": [
      "Map each mnemonic to its flag logic.",
      "JE checks ZF==1.",
      "JNE checks ZF==0."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex08",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Program Counter Increment",
    "difficulty": 2,
    "description": "In a simple CPU, the Program Counter (PC) increments by 1 after each instruction, unless a jump occurs. Write `next_pc(current_pc, instruction_type, jump_taken, target_addr)`. If jump_taken is True, return target_addr. Else return current_pc + 1.",
    "starterCode": "def next_pc(current_pc, is_jump, jump_taken, target_addr):\n    # Your code here\n    pass\n\nprint(next_pc(10, True, True, 50))  # Should return 50\nprint(next_pc(10, True, False, 50)) # Should return 11",
    "solution": "def next_pc(current_pc, is_jump, jump_taken, target_addr):\n    if is_jump and jump_taken:\n        return target_addr\n    return current_pc + 1\n\nprint(next_pc(10, True, True, 50))\nprint(next_pc(10, True, False, 50))",
    "testCases": [],
    "hints": [
      "Check if it is a jump AND the jump condition was met.",
      "If so, return the target.",
      "Otherwise, just add 1."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex09",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Stack Push Simulation",
    "difficulty": 3,
    "description": "Simulate a `PUSH` instruction. You have a `stack` (list) and a `registers` (dict). `PUSH src` should append `registers[src]` to `stack`. Write `simulate_push(stack, registers, src)`.",
    "starterCode": "def simulate_push(stack, registers, src):\n    # Your code here\n    pass\n\nstack = []\nregs = {\"AX\": 42}\nsimulate_push(stack, regs, \"AX\")\nprint(stack) # [42]",
    "solution": "def simulate_push(stack, registers, src):\n    if src in registers:\n        stack.append(registers[src])\n    return stack\n\nstack = []\nregs = {\"AX\": 42}\nsimulate_push(stack, regs, \"AX\")\nprint(stack)",
    "testCases": [],
    "hints": [
      "Use list.append() to simulate pushing to the stack.",
      "Get the value from the registers dict."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex10",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Stack Pop Simulation",
    "difficulty": 3,
    "description": "Simulate `POP dest`. It should remove the last item from `stack` and store it in `registers[dest]`. Write `simulate_pop(stack, registers, dest)`.",
    "starterCode": "def simulate_pop(stack, registers, dest):\n    # Your code here\n    pass\n\nstack = [10, 20]\nregs = {\"AX\": 0}\nsimulate_pop(stack, regs, \"AX\")\nprint(regs[\"AX\"]) # 20\nprint(stack)      # [10]",
    "solution": "def simulate_pop(stack, registers, dest):\n    if stack:\n        val = stack.pop()\n        registers[dest] = val\n    return registers\n\nstack = [10, 20]\nregs = {\"AX\": 0}\nsimulate_pop(stack, regs, \"AX\")\nprint(regs[\"AX\"])",
    "testCases": [],
    "hints": [
      "Use list.pop() to get the top element.",
      "Store it in the register."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex11",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Instruction Decoder",
    "difficulty": 4,
    "description": "Write a function that parses a string like \"MOV AX, 5\" and returns a tuple `(opcode, dest, src)`. Handle whitespace flexibly.",
    "starterCode": "def decode_instruction(instr_str):\n    # Your code here\n    pass\n\nprint(decode_instruction(\"MOV AX, 5\")) # (\"MOV\", \"AX\", \"5\")",
    "solution": "def decode_instruction(instr_str):\n    parts = instr_str.replace(\",\", \" \").split()\n    opcode = parts[0]\n    dest = parts[1]\n    src = parts[2] if len(parts) > 2 else None\n    return (opcode, dest, src)\n\nprint(decode_instruction(\"MOV AX, 5\"))",
    "testCases": [],
    "hints": [
      "Replace commas with spaces to simplify splitting.",
      "Split the string into a list of words.",
      "The first word is opcode, second is dest, third is src."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex12",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Execute Program Loop",
    "difficulty": 5,
    "description": "Simulate running a tiny program. Given a list of instructions (tuples) and initial regs, execute them sequentially. Support \"MOV\", \"ADD\", \"SUB\". Ignore jumps for now.",
    "starterCode": "def run_program(instructions, registers):\n    for opcode, dest, src in instructions:\n        # implement logic\n        pass\n    return registers\n\nprog = [(\"MOV\", \"AX\", 10), (\"MOV\", \"BX\", 5), (\"ADD\", \"AX\", \"BX\")]\nregs = {\"AX\": 0, \"BX\": 0}\nprint(run_program(prog, regs))",
    "solution": "def run_program(instructions, registers):\n    for opcode, dest, src in instructions:\n        val = src\n        if isinstance(src, str) and src in registers:\n            val = registers[src]\n        \n        if opcode == \"MOV\":\n            registers[dest] = val\n        elif opcode == \"ADD\":\n            registers[dest] += val\n        elif opcode == \"SUB\":\n            registers[dest] -= val\n    return registers\n\nprog = [(\"MOV\", \"AX\", 10), (\"MOV\", \"BX\", 5), (\"ADD\", \"AX\", \"BX\")]\nregs = {\"AX\": 0, \"BX\": 0}\nprint(run_program(prog, regs))",
    "testCases": [],
    "hints": [
      "Iterate through the list of instruction tuples.",
      "Use if/elif blocks to handle each opcode.",
      "Resolve `src` to a value (integer or register lookup) before operating."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex13",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Relative Addressing",
    "difficulty": 3,
    "description": "Calculate the physical address given a base address and an offset. `calc_address(base, offset)`.",
    "starterCode": "def calc_address(base, offset):\n    # Your code here\n    pass\n\nprint(calc_address(0x1000, 0x0020))",
    "solution": "def calc_address(base, offset):\n    return base + offset\n\nprint(calc_address(0x1000, 0x0020))",
    "testCases": [],
    "hints": [
      "Simply add the base and offset."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex14",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Simple Memory Store",
    "difficulty": 3,
    "description": "Simulate `MOV [addr], src`. Write `store_memory(memory_dict, address, value)`.",
    "starterCode": "def store_memory(memory, addr, val):\n    # Your code here\n    pass\n\nmem = {}\nstore_memory(mem, 1024, 255)\nprint(mem)",
    "solution": "def store_memory(memory, addr, val):\n    memory[addr] = val\n    return memory\n\nmem = {}\nstore_memory(mem, 1024, 255)\nprint(mem)",
    "testCases": [],
    "hints": [
      "Use the address as the dictionary key.",
      "Set the value."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex15",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "Instruction Pointer with Jump",
    "difficulty": 4,
    "description": "Enhance the program loop. Use a `pc` variable index. Allow `(\"JMP\", target_index)` instruction. Write `run_program_with_jump(instructions)`.",
    "starterCode": "def run_program_with_jump(prog):\n    regs = {\"AX\": 0}\n    pc = 0\n    while pc < len(prog):\n        # execute instruction at pc\n        # handle JMP\n        pass\n    return regs\n\nprog = [(\"MOV\", \"AX\", 1), (\"JMP\", 3), (\"MOV\", \"AX\", 99), (\"ADD\", \"AX\", 1)]\n# Should skip the 99 assignment\nprint(run_program_with_jump(prog))",
    "solution": "def run_program_with_jump(prog):\n    regs = {\"AX\": 0}\n    pc = 0\n    while pc < len(prog):\n        op = prog[pc]\n        opcode = op[0]\n        \n        if opcode == \"JMP\":\n            pc = op[1]\n            continue\n        elif opcode == \"MOV\":\n            regs[op[1]] = op[2]\n        elif opcode == \"ADD\":\n            regs[op[1]] += op[2]\n            \n        pc += 1\n    return regs\n\nprog = [(\"MOV\", \"AX\", 1), (\"JMP\", 3), (\"MOV\", \"AX\", 99), (\"ADD\", \"AX\", 1)]\nprint(run_program_with_jump(prog))",
    "testCases": [],
    "hints": [
      "Use a while loop with `pc` index.",
      "If opcode is JMP, set `pc` to the target and `continue`.",
      "Otherwise, execute and increment `pc`."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t6-ex16",
    "subjectId": "cs102",
    "topicId": "cs102-6",
    "title": "End of Assembly Drill",
    "difficulty": 1,
    "description": "Return the string \"HALT\" to signify the end of the program.",
    "starterCode": "def end_program():\n    pass",
    "solution": "def end_program():\n    return \"HALT\"",
    "testCases": [],
    "hints": [
      "Just return the string \"HALT\""
    ],
    "language": "python"
  }
]

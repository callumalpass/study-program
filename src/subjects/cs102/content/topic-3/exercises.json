[
  {
    "id": "cs102-ex-3",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Character Encoding Explorer",
    "difficulty": 2,
    "description": "Write a function that takes a string and returns information about its character encoding, including ASCII values for ASCII characters and UTF-8 byte representation.",
    "starterCode": "def analyze_encoding(text):\n    \"\"\"\n    Analyze character encoding of a string.\n    \n    Args:\n        text: A string to analyze\n    \n    Returns:\n        A list of dictionaries with character info\n    \"\"\"\n    # Your code here\n    pass",
    "testCases": [],
    "hints": [
      "Use the ord() function to get the ASCII/Unicode code point of a character",
      "Use the encode() method with 'utf-8' to get byte representation",
      "len() on the encoded bytes gives you the number of bytes in UTF-8"
    ],
    "solution": "def analyze_encoding(text):\n    result = []\n    for char in text:\n        result.append({\n            'char': char,\n            'ascii': ord(char),\n            'utf8_bytes': len(char.encode('utf-8'))\n        })\n    return result",
    "language": "python"
  },
  {
    "id": "cs102-t3-ex02",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "ASCII Table Lookup",
    "difficulty": 1,
    "description": "Write a function that takes a character and returns its ASCII code, and another that takes a code and returns the character.",
    "starterCode": "# ASCII conversions\ndef char_to_ascii(char):\n    # Your code here\n    pass\n\ndef ascii_to_char(code):\n    # Your code here\n    pass\n\nprint(char_to_ascii(\"A\"))\nprint(ascii_to_char(65))",
    "solution": "def char_to_ascii(char):\n    return ord(char)\n\ndef ascii_to_char(code):\n    return chr(code)\n\nprint(char_to_ascii(\"A\"))\nprint(ascii_to_char(65))",
    "testCases": [],
    "hints": [
      "ord() converts a character to its ASCII/Unicode value",
      "chr() converts an ASCII/Unicode value to a character"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex03",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Integer Range Calculator",
    "difficulty": 1,
    "description": "Write a function that calculates the range of values for n-bit unsigned and signed integers.",
    "starterCode": "# Calculate integer ranges for n bits\ndef integer_range(n_bits):\n    # Returns dict with unsigned_min, unsigned_max, signed_min, signed_max\n    # Your code here\n    pass\n\nprint(integer_range(8))\nprint(integer_range(16))",
    "solution": "def integer_range(n_bits):\n    return {\n        \"unsigned_min\": 0,\n        \"unsigned_max\": 2**n_bits - 1,\n        \"signed_min\": -(2**(n_bits-1)),\n        \"signed_max\": 2**(n_bits-1) - 1\n    }\n\nprint(integer_range(8))\nprint(integer_range(16))",
    "testCases": [],
    "hints": [
      "Unsigned range: 0 to 2^n - 1",
      "Signed range: -2^(n-1) to 2^(n-1) - 1",
      "Use ** for exponentiation"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex04",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Float to Binary",
    "difficulty": 3,
    "description": "Write a function that shows how a simple positive float is represented as a 32-bit IEEE 754 number. Return sign, exponent (8 bits), and mantissa (23 bits).",
    "starterCode": "# Show IEEE 754 representation of a float\ndef float_to_ieee754(f):\n    # Return dict with sign, exponent, mantissa as binary strings\n    # Your code here\n    pass\n\nprint(float_to_ieee754(5.5))",
    "solution": "import struct\n\ndef float_to_ieee754(f):\n    # Pack float as bytes, unpack as integer\n    packed = struct.pack(\">f\", f)\n    integer = struct.unpack(\">I\", packed)[0]\n    \n    binary = bin(integer)[2:].zfill(32)\n    \n    return {\n        \"sign\": binary[0],\n        \"exponent\": binary[1:9],\n        \"mantissa\": binary[9:]\n    }\n\nprint(float_to_ieee754(5.5))",
    "testCases": [],
    "hints": [
      "IEEE 754: 1 sign bit + 8 exponent bits + 23 mantissa bits",
      "Use struct module to get raw bytes",
      "Sign bit: 0 for positive, 1 for negative"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex05",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Byte Order Converter",
    "difficulty": 2,
    "description": "Write functions to convert between big-endian and little-endian byte order for a 32-bit integer represented as hex.",
    "starterCode": "# Convert byte order\ndef swap_endian(hex_str):\n    # Input: \"12345678\" (big-endian)\n    # Output: \"78563412\" (little-endian) or vice versa\n    # Your code here\n    pass\n\nprint(swap_endian(\"12345678\"))\nprint(swap_endian(\"78563412\"))",
    "solution": "def swap_endian(hex_str):\n    # Split into bytes (pairs of hex digits)\n    hex_str = hex_str.zfill(8)  # Ensure 4 bytes\n    bytes_list = [hex_str[i:i+2] for i in range(0, 8, 2)]\n    # Reverse byte order\n    return \"\".join(reversed(bytes_list))\n\nprint(swap_endian(\"12345678\"))\nprint(swap_endian(\"78563412\"))",
    "testCases": [],
    "hints": [
      "A byte is 2 hex digits",
      "Big-endian: most significant byte first",
      "Little-endian: least significant byte first",
      "Reverse the order of bytes"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex06",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "String to Binary",
    "difficulty": 2,
    "description": "Write a function that converts a string to its binary representation (ASCII values as 8-bit binary).",
    "starterCode": "# Convert string to binary\ndef string_to_binary(text):\n    # Return binary representation of each character\n    # Your code here\n    pass\n\nprint(string_to_binary(\"Hi\"))",
    "solution": "def string_to_binary(text):\n    result = []\n    for char in text:\n        binary = bin(ord(char))[2:].zfill(8)\n        result.append(binary)\n    return \" \".join(result)\n\nprint(string_to_binary(\"Hi\"))",
    "testCases": [],
    "hints": [
      "Get ASCII value with ord()",
      "Convert to binary with bin()",
      "Pad to 8 bits with zfill(8)"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex07",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Fixed Point Representation",
    "difficulty": 4,
    "description": "Implement fixed-point number representation using 8 bits total with 4 bits for integer part and 4 bits for fractional part.",
    "starterCode": "# Fixed-point representation (4.4 format)\ndef decimal_to_fixed(d):\n    # Convert decimal to 8-bit fixed point (4.4)\n    # Your code here\n    pass\n\ndef fixed_to_decimal(binary_str):\n    # Convert 8-bit fixed point to decimal\n    # Your code here\n    pass\n\nprint(decimal_to_fixed(5.5))\nprint(fixed_to_decimal(\"01011000\"))",
    "solution": "def decimal_to_fixed(d):\n    # Multiply by 16 (2^4) to shift decimal point\n    fixed_int = int(d * 16)\n    return bin(fixed_int)[2:].zfill(8)\n\ndef fixed_to_decimal(binary_str):\n    value = int(binary_str, 2)\n    return value / 16\n\nprint(decimal_to_fixed(5.5))\nprint(fixed_to_decimal(\"01011000\"))",
    "testCases": [],
    "hints": [
      "Fixed point: multiply by 2^(fractional bits) to get integer",
      "To convert back: divide by 2^(fractional bits)",
      "4.4 format means 4 integer bits, 4 fractional bits"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex08",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "UTF-8 Encoder",
    "difficulty": 5,
    "description": "Write a function that shows how a Unicode code point is encoded in UTF-8 format. Return the bytes as hex.",
    "starterCode": "# Encode Unicode code point to UTF-8\ndef unicode_to_utf8(code_point):\n    # Return UTF-8 bytes as hex string\n    # Your code here\n    pass\n\nprint(unicode_to_utf8(0x0041))    # A\nprint(unicode_to_utf8(0x00A9))    # Copyright symbol\nprint(unicode_to_utf8(0x4E2D))    # Chinese character",
    "solution": "def unicode_to_utf8(code_point):\n    if code_point <= 0x7F:\n        # 1 byte: 0xxxxxxx\n        return format(code_point, \"02x\")\n    elif code_point <= 0x7FF:\n        # 2 bytes: 110xxxxx 10xxxxxx\n        b1 = 0xC0 | (code_point >> 6)\n        b2 = 0x80 | (code_point & 0x3F)\n        return format(b1, \"02x\") + format(b2, \"02x\")\n    elif code_point <= 0xFFFF:\n        # 3 bytes: 1110xxxx 10xxxxxx 10xxxxxx\n        b1 = 0xE0 | (code_point >> 12)\n        b2 = 0x80 | ((code_point >> 6) & 0x3F)\n        b3 = 0x80 | (code_point & 0x3F)\n        return format(b1, \"02x\") + format(b2, \"02x\") + format(b3, \"02x\")\n    else:\n        # 4 bytes: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n        b1 = 0xF0 | (code_point >> 18)\n        b2 = 0x80 | ((code_point >> 12) & 0x3F)\n        b3 = 0x80 | ((code_point >> 6) & 0x3F)\n        b4 = 0x80 | (code_point & 0x3F)\n        return format(b1, \"02x\") + format(b2, \"02x\") + format(b3, \"02x\") + format(b4, \"02x\")\n\nprint(unicode_to_utf8(0x0041))\nprint(unicode_to_utf8(0x00A9))\nprint(unicode_to_utf8(0x4E2D))",
    "testCases": [],
    "hints": [
      "UTF-8 uses 1-4 bytes depending on code point",
      "0x00-0x7F: 1 byte (ASCII compatible)",
      "0x80-0x7FF: 2 bytes",
      "0x800-0xFFFF: 3 bytes",
      "Use bit manipulation to extract and combine bits"
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex09",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Float Bit Breakdown",
    "difficulty": 4,
    "description": "Given a 32-bit binary string, interpret it as an IEEE 754 single-precision float and return a tuple (sign, exponent, fraction, value).",
    "starterCode": "# Interpret IEEE 754 single precision bits\ndef decode_float32(bits):\n    # bits: 32-char string of 0/1\n    # Return (sign_bit, exponent_int, fraction_int, numeric_value)\n    pass\n\nprint(decode_float32(\"01000000101000000000000000000000\"))  # 5.0",
    "solution": "import struct\n\ndef decode_float32(bits):\n    if len(bits) != 32:\n        raise ValueError(\"need 32 bits\")\n    sign_bit = int(bits[0], 2)\n    exponent_bits = bits[1:9]\n    fraction_bits = bits[9:]\n    exponent = int(exponent_bits, 2)\n    fraction = int(fraction_bits, 2)\n    # Convert to actual float using struct\n    as_int = int(bits, 2)\n    packed = as_int.to_bytes(4, byteorder=\"big\")\n    value = struct.unpack('>f', packed)[0]\n    return (sign_bit, exponent, fraction, value)\n\nprint(decode_float32(\"01000000101000000000000000000000\"))",
    "testCases": [],
    "hints": [
      "Split bits into sign (1), exponent (8), fraction (23).",
      "You can reuse Python struct to get numeric value; the point is to show the pieces.",
      "Remember exponent bias is 127."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex10",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Endian Swap 32-bit",
    "difficulty": 2,
    "description": "Write a function that takes an 8-hex-digit string (e.g., \"1234ABCD\") and returns the bytes swapped from little endian to big endian (e.g., \"CDAB3412\").",
    "starterCode": "# Swap endian of 32-bit hex string\ndef swap_endian32(hex_str):\n    # Your code here\n    pass\n\nprint(swap_endian32(\"1234ABCD\"))",
    "solution": "def swap_endian32(hex_str):\n    if len(hex_str) != 8:\n        raise ValueError(\"need exactly 8 hex chars\")\n    hex_str = hex_str.lower()\n    bytes_list = [hex_str[i:i+2] for i in range(0, 8, 2)]\n    bytes_list.reverse()\n    return \"\".join(bytes_list)\n\nprint(swap_endian32(\"1234ABCD\"))",
    "testCases": [],
    "hints": [
      "Group hex string into bytes (2 hex chars each).",
      "Reverse byte order, then join back.",
      "Assume valid hex input of length 8."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-drill-1",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Unsigned vs Signed Interpret",
    "difficulty": 1,
    "description": "Given an 8-bit binary string, return a tuple (unsigned_value, signed_value).",
    "starterCode": "# Interpret 8-bit value as unsigned and signed\ndef interpret_byte(bits):\n    # Your code here\n    pass\n\nprint(interpret_byte(\"11111111\"))  # (255, -1)",
    "solution": "def interpret_byte(bits):\n    bits = bits.zfill(8)\n    unsigned_val = int(bits, 2)\n    signed_val = unsigned_val - 256 if bits[0] == \"1\" else unsigned_val\n    return (unsigned_val, signed_val)\n\nprint(interpret_byte(\"11111111\"))",
    "testCases": [],
    "hints": [
      "Unsigned: plain base-2.",
      "Signed: subtract 256 if sign bit is 1.",
      "Ensure string is 8 bits."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-drill-2",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Printable ASCII Check",
    "difficulty": 1,
    "description": "Given a byte value (0-255), return True if it is a printable ASCII character (0x20-0x7E).",
    "starterCode": "# Check printable ASCII\ndef is_printable(byte_val):\n    # Your code here\n    pass\n\nprint(is_printable(65))  # True for \"A\"",
    "solution": "def is_printable(byte_val):\n    return 0x20 <= byte_val <= 0x7E\n\nprint(is_printable(65))",
    "testCases": [],
    "hints": [
      "Printable ASCII ranges from 32 (space) to 126 (~).",
      "Return boolean."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex13",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "ASCII Is Upper",
    "difficulty": 1,
    "description": "Return True if `char` is an uppercase ASCII letter (A-Z), without using .isupper().",
    "starterCode": "def is_upper_ascii(char):\n    # Your code here\n    pass\n\nprint(is_upper_ascii(\"A\"))",
    "solution": "def is_upper_ascii(char):\n    return 0x41 <= ord(char) <= 0x5A\n\nprint(is_upper_ascii(\"A\"))",
    "testCases": [],
    "hints": [
      "A is 65 (0x41), Z is 90 (0x5A).",
      "Use ord()."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex14",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "ASCII To Lower",
    "difficulty": 1,
    "description": "Convert an uppercase ASCII char to lowercase by manipulating the bit value. Hint: 'a' - 'A' = 32.",
    "starterCode": "def to_lower_ascii(char):\n    # Your code here\n    pass\n\nprint(to_lower_ascii(\"G\"))",
    "solution": "def to_lower_ascii(char):\n    if \"A\" <= char <= \"Z\":\n        return chr(ord(char) | 0x20)\n    return char\n\nprint(to_lower_ascii(\"G\"))",
    "testCases": [],
    "hints": [
      "OR with 0x20 (32) sets the 6th bit, converting upper to lower."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex15",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Hex Dump String",
    "difficulty": 2,
    "description": "Given a string, return a space-separated string of hex values for each character.",
    "starterCode": "def hex_dump(s):\n    # Your code here\n    pass\n\nprint(hex_dump(\"Hi\")) # \"48 69\"",
    "solution": "def hex_dump(s):\n    return \" \".join(format(ord(c), \"02x\") for c in s)\n\nprint(hex_dump(\"Hi\"))",
    "testCases": [],
    "hints": [
      "Iterate chars.",
      "Convert each to hex.",
      "Join with spaces."
    ],
    "language": "python"
  },
  {
    "id": "cs102-t3-ex16",
    "subjectId": "cs102",
    "topicId": "cs102-3",
    "title": "Simple RLE",
    "difficulty": 3,
    "description": "Run Length Encode a string of 0s and 1s. E.g., \"00011\" -> \"0312\".",
    "starterCode": "def rle_encode(s):\n    # Your code here\n    pass\n\nprint(rle_encode(\"00011\"))",
    "solution": "def rle_encode(s):\n    if not s: return \"\"\n    res = \"\"\n    count = 1\n    curr = s[0]\n    for c in s[1:]:\n        if c == curr:\n            count += 1\n        else:\n            res += curr + str(count)\n            curr = c\n            count = 1\n    res += curr + str(count)\n    return res\n\nprint(rle_encode(\"00011\"))",
    "testCases": [],
    "hints": [
      "Track current char and count.",
      "Append to result when char changes."
    ],
    "language": "python"
  }
]

[
  {
    "id": "cs406-t6-ex01",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Propositional Logic Evaluation",
    "difficulty": 2,
    "description": "Implement a propositional logic evaluator.\n\nYour implementation should:\n- Parse and evaluate propositional formulas\n- Support operators: AND, OR, NOT, IMPLIES\n- Evaluate formulas given truth assignments\n- Check if formulas are tautologies",
    "starterCode": "class PropFormula:\n    pass\n\nclass Atom(PropFormula):\n    def __init__(self, name):\n        pass\n\nclass Not(PropFormula):\n    def __init__(self, formula):\n        pass\n\nclass And(PropFormula):\n    def __init__(self, left, right):\n        pass\n\ndef evaluate(formula, assignment):\n    # Evaluate formula under given assignment\n    pass\n\ndef is_tautology(formula, variables):\n    # Check if formula is true under all assignments\n    pass",
    "solution": "from itertools import product\n\nclass PropFormula:\n    \"\"\"Base class for propositional formulas.\"\"\"\n    pass\n\nclass Atom(PropFormula):\n    def __init__(self, name):\n        self.name = name\n\n    def evaluate(self, assignment):\n        return assignment.get(self.name, False)\n\n    def __repr__(self):\n        return self.name\n\nclass Not(PropFormula):\n    def __init__(self, formula):\n        self.formula = formula\n\n    def evaluate(self, assignment):\n        return not self.formula.evaluate(assignment)\n\n    def __repr__(self):\n        return f\"¬{self.formula}\"\n\nclass And(PropFormula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, assignment):\n        return self.left.evaluate(assignment) and self.right.evaluate(assignment)\n\n    def __repr__(self):\n        return f\"({self.left} ∧ {self.right})\"\n\nclass Or(PropFormula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, assignment):\n        return self.left.evaluate(assignment) or self.right.evaluate(assignment)\n\n    def __repr__(self):\n        return f\"({self.left} ∨ {self.right})\"\n\nclass Implies(PropFormula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, assignment):\n        return (not self.left.evaluate(assignment)) or self.right.evaluate(assignment)\n\n    def __repr__(self):\n        return f\"({self.left} → {self.right})\"\n\ndef evaluate(formula, assignment):\n    \"\"\"Evaluate formula under given truth assignment.\"\"\"\n    return formula.evaluate(assignment)\n\ndef is_tautology(formula, variables):\n    \"\"\"Check if formula is true under all possible truth assignments.\"\"\"\n    # Generate all possible assignments\n    for values in product([False, True], repeat=len(variables)):\n        assignment = dict(zip(variables, values))\n\n        if not formula.evaluate(assignment):\n            return False, assignment  # Counterexample\n\n    return True, None\n\ndef truth_table(formula, variables):\n    \"\"\"Generate complete truth table for formula.\"\"\"\n    print(\"Truth table for:\", formula)\n    print()\n\n    # Header\n    header = \" | \".join(variables) + \" | Result\"\n    print(header)\n    print(\"-\" * len(header))\n\n    # Rows\n    for values in product([False, True], repeat=len(variables)):\n        assignment = dict(zip(variables, values))\n        result = formula.evaluate(assignment)\n\n        row = \" | \".join(\"T\" if assignment[v] else \"F\" for v in variables)\n        row += \" | \" + (\"T\" if result else \"F\")\n        print(row)\n\n# Test formulas\nP = Atom('P')\nQ = Atom('Q')\nR = Atom('R')\n\n# P ∧ Q\nformula1 = And(P, Q)\nprint(\"Formula 1:\", formula1)\nprint(\"Evaluation (P=T, Q=T):\", evaluate(formula1, {'P': True, 'Q': True}))\nprint(\"Evaluation (P=T, Q=F):\", evaluate(formula1, {'P': True, 'Q': False}))\nprint()\n\n# P → Q (equivalent to ¬P ∨ Q)\nformula2 = Implies(P, Q)\nprint(\"Formula 2:\", formula2)\ntruth_table(formula2, ['P', 'Q'])\nprint()\n\n# Tautology: P ∨ ¬P\nformula3 = Or(P, Not(P))\nprint(\"Formula 3:\", formula3)\nis_taut, counterex = is_tautology(formula3, ['P'])\nprint(f\"Is tautology: {is_taut}\")\nprint()\n\n# Not a tautology: P ∧ Q\nis_taut, counterex = is_tautology(formula1, ['P', 'Q'])\nprint(f\"Formula 1 is tautology: {is_taut}\")\nif counterex:\n    print(f\"Counterexample: {counterex}\")\nprint()\n\n# Modus ponens: ((P → Q) ∧ P) → Q\nformula4 = Implies(And(Implies(P, Q), P), Q)\nprint(\"Formula 4 (Modus Ponens):\", formula4)\nis_taut, counterex = is_tautology(formula4, ['P', 'Q'])\nprint(f\"Is tautology: {is_taut}\")\ntruth_table(formula4, ['P', 'Q'])",
    "testCases": [
      {
        "input": "evaluate(And(P, Q), {\"P\": True, \"Q\": True})",
        "isHidden": false,
        "description": "Test AND evaluation"
      },
      {
        "input": "evaluate(Implies(P, Q), {\"P\": True, \"Q\": False})",
        "isHidden": false,
        "description": "Test IMPLIES evaluation"
      },
      {
        "input": "is_tautology(Or(P, Not(P)), [\"P\"])",
        "isHidden": false,
        "description": "Test tautology detection (law of excluded middle)"
      }
    ],
    "hints": [
      "Implement evaluate() method for each formula class (Atom, Not, And, Or, Implies)",
      "Implies is equivalent to (NOT left) OR right",
      "For tautology checking, generate all possible truth assignments and verify formula is true for all"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex02",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Resolution Theorem Prover",
    "difficulty": 3,
    "description": "Implement a resolution-based theorem prover for propositional logic.\n\nYour implementation should:\n- Convert formulas to CNF (Conjunctive Normal Form)\n- Implement resolution rule\n- Detect when empty clause is derived\n- Prove theorems by refutation",
    "starterCode": "class Clause:\n    def __init__(self, literals):\n        # Clause is a set of literals\n        pass\n\ndef to_cnf(formula):\n    # Convert formula to CNF\n    # Return: set of clauses\n    pass\n\ndef resolve(clause1, clause2):\n    # Apply resolution rule\n    # Return: set of resolvent clauses\n    pass\n\ndef resolution_prove(kb, query):\n    # Prove query from knowledge base using resolution\n    pass",
    "solution": "class Literal:\n    def __init__(self, atom, negated=False):\n        self.atom = atom\n        self.negated = negated\n\n    def negate(self):\n        return Literal(self.atom, not self.negated)\n\n    def __eq__(self, other):\n        return self.atom == other.atom and self.negated == other.negated\n\n    def __hash__(self):\n        return hash((self.atom, self.negated))\n\n    def __repr__(self):\n        return f\"¬{self.atom}\" if self.negated else self.atom\n\nclass Clause:\n    def __init__(self, literals):\n        self.literals = frozenset(literals)\n\n    def is_empty(self):\n        return len(self.literals) == 0\n\n    def __eq__(self, other):\n        return self.literals == other.literals\n\n    def __hash__(self):\n        return hash(self.literals)\n\n    def __repr__(self):\n        if self.is_empty():\n            return \"□\"  # Empty clause\n        return \"{\" + \" ∨ \".join(str(lit) for lit in self.literals) + \"}\"\n\ndef resolve(clause1, clause2):\n    \"\"\"\n    Apply resolution rule to two clauses.\n    Returns: set of resolvent clauses (may be empty)\n    \"\"\"\n    resolvents = set()\n\n    # Try to resolve on each pair of complementary literals\n    for lit1 in clause1.literals:\n        for lit2 in clause2.literals:\n            # Check if complementary\n            if lit1.atom == lit2.atom and lit1.negated != lit2.negated:\n                # Resolve: remove complementary pair, union the rest\n                new_literals = (clause1.literals - {lit1}) | (clause2.literals - {lit2})\n                resolvent = Clause(new_literals)\n                resolvents.add(resolvent)\n\n    return resolvents\n\ndef resolution_prove(clauses, query_clause):\n    \"\"\"\n    Prove query using resolution (by refutation).\n    Negate query and add to KB, derive empty clause.\n\n    clauses: set of Clause objects (KB in CNF)\n    query_clause: Clause to prove\n\n    Returns: (proved, steps) where steps shows derivation\n    \"\"\"\n    # Negate query and add to clauses\n    # (Query is a clause, negating means we try to prove its negation leads to contradiction)\n    clauses = set(clauses)\n    clauses.add(query_clause)\n\n    new_clauses = set()\n    steps = []\n\n    iteration = 0\n    max_iterations = 100\n\n    while iteration < max_iterations:\n        iteration += 1\n\n        # Try resolving all pairs of clauses\n        clause_list = list(clauses)\n\n        for i in range(len(clause_list)):\n            for j in range(i + 1, len(clause_list)):\n                resolvents = resolve(clause_list[i], clause_list[j])\n\n                for resolvent in resolvents:\n                    # Check if empty clause derived\n                    if resolvent.is_empty():\n                        steps.append({\n                            'iteration': iteration,\n                            'clause1': clause_list[i],\n                            'clause2': clause_list[j],\n                            'resolvent': resolvent\n                        })\n                        return True, steps\n\n                    new_clauses.add(resolvent)\n                    steps.append({\n                        'iteration': iteration,\n                        'clause1': clause_list[i],\n                        'clause2': clause_list[j],\n                        'resolvent': resolvent\n                    })\n\n        # Check if no new clauses derived\n        if new_clauses.issubset(clauses):\n            return False, steps  # Cannot prove\n\n        clauses |= new_clauses\n\n    return False, steps  # Max iterations reached\n\n# Test\n# KB: {P → Q, Q → R, P}\n# Prove: R\n\n# Convert to CNF:\n# P → Q  ≡  ¬P ∨ Q\n# Q → R  ≡  ¬Q ∨ R\n# P\n\nP = 'P'\nQ = 'Q'\nR = 'R'\n\nkb = {\n    Clause([Literal(P, negated=True), Literal(Q)]),  # ¬P ∨ Q\n    Clause([Literal(Q, negated=True), Literal(R)]),  # ¬Q ∨ R\n    Clause([Literal(P)])  # P\n}\n\n# Query: R\n# To prove R, we negate it and try to derive empty clause\n# ¬R\nquery = Clause([Literal(R, negated=True)])\n\nprint(\"Knowledge Base:\")\nfor clause in kb:\n    print(f\"  {clause}\")\nprint(f\"\\nQuery (negated): {query}\")\nprint()\n\nproved, steps = resolution_prove(kb, query)\n\nprint(f\"Proved: {proved}\")\nprint(f\"\\nDerivation steps:\")\nfor step in steps[-10:]:  # Show last 10 steps\n    print(f\"  {step['clause1']} + {step['clause2']} → {step['resolvent']}\")\n\n# Another example: Modus Ponens\nprint(\"\\n\" + \"=\"*50)\nprint(\"Example 2: Modus Ponens\")\nprint(\"=\"*50)\n\n# KB: {P → Q, P}\n# Prove: Q\n\nA = 'A'\nB = 'B'\n\nkb2 = {\n    Clause([Literal(A, negated=True), Literal(B)]),  # ¬A ∨ B (A → B)\n    Clause([Literal(A)])  # A\n}\n\nquery2 = Clause([Literal(B, negated=True)])  # Prove B (negate it)\n\nprint(\"Knowledge Base:\")\nfor clause in kb2:\n    print(f\"  {clause}\")\nprint(f\"\\nQuery (negated): {query2}\")\n\nproved2, steps2 = resolution_prove(kb2, query2)\n\nprint(f\"\\nProved: {proved2}\")\nprint(f\"Derivation steps:\")\nfor step in steps2:\n    print(f\"  {step['clause1']} + {step['clause2']} → {step['resolvent']}\")",
    "testCases": [
      {
        "input": "resolve(clause1, clause2)",
        "isHidden": false,
        "description": "Test resolution produces correct resolvent"
      },
      {
        "input": "resolution_prove(kb, query)",
        "isHidden": false,
        "description": "Test resolution proves valid theorem"
      },
      {
        "input": "empty clause derivation",
        "isHidden": false,
        "description": "Test proof by refutation derives empty clause"
      }
    ],
    "hints": [
      "Resolution rule: if one clause contains literal L and another contains ¬L, create new clause with all literals except L and ¬L",
      "To prove a query, negate it and add to KB, then try to derive the empty clause (contradiction)",
      "Keep track of which clauses have been resolved to avoid infinite loops"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex03",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "First-Order Logic Unification",
    "difficulty": 4,
    "description": "Implement unification for first-order logic terms.\n\nYour implementation should:\n- Represent FOL terms (constants, variables, functions)\n- Implement occur check\n- Find most general unifier (MGU) for two terms\n- Handle complex nested terms",
    "starterCode": "class Term:\n    pass\n\nclass Constant(Term):\n    pass\n\nclass Variable(Term):\n    pass\n\nclass Function(Term):\n    pass\n\ndef unify(term1, term2, subst=None):\n    # Find most general unifier\n    # Returns: substitution dict or None if unification fails\n    pass\n\ndef apply_subst(term, subst):\n    # Apply substitution to term\n    pass",
    "solution": "class Term:\n    \"\"\"Base class for FOL terms.\"\"\"\n    pass\n\nclass Constant(Term):\n    def __init__(self, name):\n        self.name = name\n\n    def __eq__(self, other):\n        return isinstance(other, Constant) and self.name == other.name\n\n    def __hash__(self):\n        return hash(('const', self.name))\n\n    def __repr__(self):\n        return self.name\n\nclass Variable(Term):\n    def __init__(self, name):\n        self.name = name\n\n    def __eq__(self, other):\n        return isinstance(other, Variable) and self.name == other.name\n\n    def __hash__(self):\n        return hash(('var', self.name))\n\n    def __repr__(self):\n        return f\"?{self.name}\"\n\nclass Function(Term):\n    def __init__(self, name, args):\n        self.name = name\n        self.args = tuple(args)  # List of terms\n\n    def __eq__(self, other):\n        return (isinstance(other, Function) and\n                self.name == other.name and\n                self.args == other.args)\n\n    def __hash__(self):\n        return hash(('func', self.name, self.args))\n\n    def __repr__(self):\n        args_str = \", \".join(str(arg) for arg in self.args)\n        return f\"{self.name}({args_str})\"\n\ndef apply_subst(term, subst):\n    \"\"\"Apply substitution to term.\"\"\"\n    if isinstance(term, Constant):\n        return term\n    elif isinstance(term, Variable):\n        if term in subst:\n            # Recursively apply (for transitive substitutions)\n            return apply_subst(subst[term], subst)\n        return term\n    elif isinstance(term, Function):\n        new_args = [apply_subst(arg, subst) for arg in term.args]\n        return Function(term.name, new_args)\n\ndef occur_check(var, term, subst):\n    \"\"\"Check if var occurs in term (prevents infinite structures).\"\"\"\n    if var == term:\n        return True\n    elif isinstance(term, Variable) and term in subst:\n        return occur_check(var, subst[term], subst)\n    elif isinstance(term, Function):\n        return any(occur_check(var, arg, subst) for arg in term.args)\n    return False\n\ndef unify(term1, term2, subst=None):\n    \"\"\"\n    Find most general unifier for two terms.\n    Returns: substitution dict or None if unification fails\n    \"\"\"\n    if subst is None:\n        subst = {}\n\n    # Apply current substitution\n    term1 = apply_subst(term1, subst)\n    term2 = apply_subst(term2, subst)\n\n    # If identical, already unified\n    if term1 == term2:\n        return subst\n\n    # Variable unification\n    if isinstance(term1, Variable):\n        if occur_check(term1, term2, subst):\n            return None  # Fail\n        subst[term1] = term2\n        return subst\n\n    if isinstance(term2, Variable):\n        if occur_check(term2, term1, subst):\n            return None  # Fail\n        subst[term2] = term1\n        return subst\n\n    # Function unification\n    if isinstance(term1, Function) and isinstance(term2, Function):\n        # Must have same functor and arity\n        if term1.name != term2.name or len(term1.args) != len(term2.args):\n            return None  # Fail\n\n        # Unify arguments pairwise\n        for arg1, arg2 in zip(term1.args, term2.args):\n            subst = unify(arg1, arg2, subst)\n            if subst is None:\n                return None  # Fail\n\n        return subst\n\n    # Constants or mismatched types\n    return None  # Fail\n\n# Test cases\nprint(\"=\"*50)\nprint(\"First-Order Logic Unification Tests\")\nprint(\"=\"*50)\n\n# Test 1: Constant unification\nprint(\"\\nTest 1: Unify constants\")\nc1 = Constant('a')\nc2 = Constant('a')\nc3 = Constant('b')\n\nsubst = unify(c1, c2)\nprint(f\"unify({c1}, {c2}) = {subst}\")\n\nsubst = unify(c1, c3)\nprint(f\"unify({c1}, {c3}) = {subst}\")\n\n# Test 2: Variable unification\nprint(\"\\nTest 2: Unify variables\")\nx = Variable('X')\ny = Variable('Y')\na = Constant('a')\n\nsubst = unify(x, a)\nprint(f\"unify({x}, {a}) = {subst}\")\n\nsubst = unify(x, y)\nprint(f\"unify({x}, {y}) = {subst}\")\n\n# Test 3: Function unification\nprint(\"\\nTest 3: Unify functions\")\n# f(X, a) and f(b, Y)\nf1 = Function('f', [Variable('X'), Constant('a')])\nf2 = Function('f', [Constant('b'), Variable('Y')])\n\nsubst = unify(f1, f2)\nprint(f\"unify({f1}, {f2}) = {subst}\")\n\nif subst:\n    print(f\"  {f1} becomes {apply_subst(f1, subst)}\")\n    print(f\"  {f2} becomes {apply_subst(f2, subst)}\")\n\n# Test 4: Nested functions\nprint(\"\\nTest 4: Nested functions\")\n# g(X, f(X)) and g(f(Y), Y)\nt1 = Function('g', [Variable('X'), Function('f', [Variable('X')])])\nt2 = Function('g', [Function('f', [Variable('Y')]), Variable('Y')])\n\nsubst = unify(t1, t2)\nprint(f\"unify({t1}, {t2}) = {subst}\")\n\nif subst:\n    print(f\"  {t1} becomes {apply_subst(t1, subst)}\")\n    print(f\"  {t2} becomes {apply_subst(t2, subst)}\")\n\n# Test 5: Occur check (should fail)\nprint(\"\\nTest 5: Occur check\")\n# Unify X with f(X) - should fail\nx = Variable('X')\nfx = Function('f', [x])\n\nsubst = unify(x, fx)\nprint(f\"unify({x}, {fx}) = {subst}\")\nprint(\"  (Should fail due to occur check)\")\n\n# Test 6: Complex example\nprint(\"\\nTest 6: Complex example\")\n# loves(X, f(X)) and loves(g(Y), Z)\nt1 = Function('loves', [Variable('X'), Function('f', [Variable('X')])])\nt2 = Function('loves', [Function('g', [Variable('Y')]), Variable('Z')])\n\nsubst = unify(t1, t2)\nprint(f\"unify({t1}, {t2}) = {subst}\")\n\nif subst:\n    print(f\"  {t1} becomes {apply_subst(t1, subst)}\")\n    print(f\"  {t2} becomes {apply_subst(t2, subst)}\")",
    "testCases": [
      {
        "input": "unify(Function(\"f\", [Variable(\"X\")]), Function(\"f\", [Constant(\"a\")]))",
        "isHidden": false,
        "description": "Test unifying function terms"
      },
      {
        "input": "unify(Variable(\"X\"), Variable(\"Y\"))",
        "isHidden": false,
        "description": "Test unifying two variables"
      },
      {
        "input": "unify(Variable(\"X\"), Function(\"f\", [Variable(\"X\")]))",
        "isHidden": false,
        "description": "Test occur check prevents infinite structures"
      }
    ],
    "hints": [
      "Constants unify only with identical constants",
      "Variables unify with anything (but check occur check first)",
      "Functions unify if they have the same name, arity, and all arguments unify",
      "Occur check: variable X cannot unify with a term containing X (like f(X))"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex04",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "CNF Conversion",
    "difficulty": 2,
    "description": "Implement an algorithm to convert propositional logic formulas to Conjunctive Normal Form (CNF).\n\nYour implementation should:\n- Eliminate implications (A → B ≡ ¬A ∨ B)\n- Push negations inward using De Morgan's laws\n- Distribute OR over AND to get conjunctions of disjunctions\n- Handle nested formulas correctly",
    "starterCode": "class Formula:\n    pass\n\nclass Atom(Formula):\n    def __init__(self, name):\n        self.name = name\n\nclass Not(Formula):\n    def __init__(self, f):\n        self.formula = f\n\nclass And(Formula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\nclass Or(Formula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\nclass Implies(Formula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\ndef eliminate_implications(formula):\n    # Convert A → B to ¬A ∨ B\n    pass\n\ndef push_negations(formula):\n    # Apply De Morgan's laws to push ¬ inward\n    pass\n\ndef distribute_or_over_and(formula):\n    # Convert (A ∧ B) ∨ C to (A ∨ C) ∧ (B ∨ C)\n    pass\n\ndef to_cnf(formula):\n    # Convert formula to CNF\n    pass",
    "solution": "class Formula:\n    pass\n\nclass Atom(Formula):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n\nclass Not(Formula):\n    def __init__(self, f):\n        self.formula = f\n    def __repr__(self):\n        return f\"¬{self.formula}\"\n\nclass And(Formula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"({self.left} ∧ {self.right})\"\n\nclass Or(Formula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"({self.left} ∨ {self.right})\"\n\nclass Implies(Formula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"({self.left} → {self.right})\"\n\ndef eliminate_implications(formula):\n    \"\"\"Convert A → B to ¬A ∨ B recursively.\"\"\"\n    if isinstance(formula, Atom):\n        return formula\n    elif isinstance(formula, Not):\n        return Not(eliminate_implications(formula.formula))\n    elif isinstance(formula, And):\n        return And(eliminate_implications(formula.left),\n                   eliminate_implications(formula.right))\n    elif isinstance(formula, Or):\n        return Or(eliminate_implications(formula.left),\n                  eliminate_implications(formula.right))\n    elif isinstance(formula, Implies):\n        # A → B ≡ ¬A ∨ B\n        return Or(Not(eliminate_implications(formula.left)),\n                  eliminate_implications(formula.right))\n\ndef push_negations(formula):\n    \"\"\"Push negations inward using De Morgan's laws.\"\"\"\n    if isinstance(formula, Atom):\n        return formula\n    elif isinstance(formula, Not):\n        inner = formula.formula\n        if isinstance(inner, Atom):\n            return formula  # ¬A stays as is\n        elif isinstance(inner, Not):\n            return push_negations(inner.formula)  # ¬¬A → A\n        elif isinstance(inner, And):\n            # ¬(A ∧ B) → ¬A ∨ ¬B\n            return Or(push_negations(Not(inner.left)),\n                      push_negations(Not(inner.right)))\n        elif isinstance(inner, Or):\n            # ¬(A ∨ B) → ¬A ∧ ¬B\n            return And(push_negations(Not(inner.left)),\n                       push_negations(Not(inner.right)))\n    elif isinstance(formula, And):\n        return And(push_negations(formula.left),\n                   push_negations(formula.right))\n    elif isinstance(formula, Or):\n        return Or(push_negations(formula.left),\n                  push_negations(formula.right))\n    return formula\n\ndef distribute_or_over_and(formula):\n    \"\"\"Distribute OR over AND to get CNF.\"\"\"\n    if isinstance(formula, Atom) or isinstance(formula, Not):\n        return formula\n    elif isinstance(formula, And):\n        return And(distribute_or_over_and(formula.left),\n                   distribute_or_over_and(formula.right))\n    elif isinstance(formula, Or):\n        left = distribute_or_over_and(formula.left)\n        right = distribute_or_over_and(formula.right)\n        # (A ∧ B) ∨ C → (A ∨ C) ∧ (B ∨ C)\n        if isinstance(left, And):\n            return And(distribute_or_over_and(Or(left.left, right)),\n                       distribute_or_over_and(Or(left.right, right)))\n        # A ∨ (B ∧ C) → (A ∨ B) ∧ (A ∨ C)\n        elif isinstance(right, And):\n            return And(distribute_or_over_and(Or(left, right.left)),\n                       distribute_or_over_and(Or(left, right.right)))\n        else:\n            return Or(left, right)\n    return formula\n\ndef to_cnf(formula):\n    \"\"\"Convert formula to CNF.\"\"\"\n    f = eliminate_implications(formula)\n    f = push_negations(f)\n    f = distribute_or_over_and(f)\n    return f\n\n# Test\nP, Q, R = Atom('P'), Atom('Q'), Atom('R')\n\n# Test 1: (P → Q) → R\nf1 = Implies(Implies(P, Q), R)\nprint(f\"Original: {f1}\")\nprint(f\"CNF: {to_cnf(f1)}\")\n\n# Test 2: ¬(P ∧ Q)\nf2 = Not(And(P, Q))\nprint(f\"\\nOriginal: {f2}\")\nprint(f\"CNF: {to_cnf(f2)}\")\n\n# Test 3: (P ∨ Q) ∧ R → P\nf3 = Implies(And(Or(P, Q), R), P)\nprint(f\"\\nOriginal: {f3}\")\nprint(f\"CNF: {to_cnf(f3)}\")",
    "testCases": [
      {
        "input": "to_cnf(Implies(P, Q))",
        "isHidden": false,
        "description": "Convert implication to CNF"
      },
      {
        "input": "to_cnf(Not(And(P, Q)))",
        "isHidden": false,
        "description": "Apply De Morgan's law"
      },
      {
        "input": "to_cnf(Or(And(P, Q), R))",
        "isHidden": false,
        "description": "Distribute OR over AND"
      }
    ],
    "hints": [
      "Process in order: eliminate implications, push negations, distribute",
      "De Morgan: ¬(A ∧ B) = ¬A ∨ ¬B and ¬(A ∨ B) = ¬A ∧ ¬B",
      "Distribution may need to be applied multiple times"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex05",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "DPLL SAT Solver",
    "difficulty": 3,
    "description": "Implement the DPLL (Davis-Putnam-Logemann-Loveland) algorithm for satisfiability checking.\n\nYour implementation should:\n- Handle CNF formulas represented as sets of clauses\n- Implement unit propagation\n- Implement pure literal elimination\n- Use recursive backtracking search\n- Return a satisfying assignment or indicate unsatisfiability",
    "starterCode": "def unit_propagate(clauses, assignment):\n    # Find and propagate unit clauses\n    # Return updated (clauses, assignment) or None if conflict\n    pass\n\ndef pure_literal_eliminate(clauses, assignment):\n    # Find and assign pure literals\n    # Return updated (clauses, assignment)\n    pass\n\ndef dpll(clauses, assignment=None):\n    # DPLL algorithm\n    # Return satisfying assignment or None\n    pass\n\ndef solve_sat(cnf):\n    # cnf: list of clauses, each clause is set of literals\n    # literals: positive int for var, negative for negation\n    pass",
    "solution": "def simplify(clauses, literal):\n    \"\"\"Simplify clauses after assigning a literal.\"\"\"\n    new_clauses = []\n    for clause in clauses:\n        if literal in clause:\n            continue  # Clause satisfied, remove it\n        new_clause = clause - {-literal}  # Remove negation\n        if len(new_clause) == 0:\n            return None  # Empty clause = conflict\n        new_clauses.append(new_clause)\n    return new_clauses\n\ndef unit_propagate(clauses, assignment):\n    \"\"\"Find and propagate unit clauses.\"\"\"\n    changed = True\n    while changed:\n        changed = False\n        for clause in clauses:\n            if len(clause) == 1:\n                literal = next(iter(clause))\n                var = abs(literal)\n                if var not in assignment:\n                    assignment[var] = literal > 0\n                    clauses = simplify(clauses, literal)\n                    if clauses is None:\n                        return None, None  # Conflict\n                    changed = True\n                    break\n    return clauses, assignment\n\ndef pure_literal_eliminate(clauses, assignment):\n    \"\"\"Find and assign pure literals.\"\"\"\n    all_literals = set()\n    for clause in clauses:\n        all_literals.update(clause)\n    \n    pure = []\n    for lit in all_literals:\n        if -lit not in all_literals:\n            pure.append(lit)\n    \n    for literal in pure:\n        var = abs(literal)\n        if var not in assignment:\n            assignment[var] = literal > 0\n            clauses = simplify(clauses, literal)\n            if clauses is None:\n                return None, None\n    \n    return clauses, assignment\n\ndef get_unassigned_var(clauses, assignment):\n    \"\"\"Get first unassigned variable from clauses.\"\"\"\n    for clause in clauses:\n        for lit in clause:\n            var = abs(lit)\n            if var not in assignment:\n                return var\n    return None\n\ndef dpll(clauses, assignment=None):\n    \"\"\"DPLL algorithm for SAT solving.\"\"\"\n    if assignment is None:\n        assignment = {}\n    \n    # Unit propagation\n    clauses, assignment = unit_propagate(clauses, assignment.copy())\n    if clauses is None:\n        return None  # Conflict\n    \n    # Pure literal elimination\n    clauses, assignment = pure_literal_eliminate(clauses, assignment)\n    if clauses is None:\n        return None\n    \n    # Check if satisfied\n    if len(clauses) == 0:\n        return assignment  # All clauses satisfied\n    \n    # Choose unassigned variable\n    var = get_unassigned_var(clauses, assignment)\n    if var is None:\n        return assignment\n    \n    # Try assigning True\n    new_assignment = assignment.copy()\n    new_assignment[var] = True\n    new_clauses = simplify(clauses, var)\n    if new_clauses is not None:\n        result = dpll(new_clauses, new_assignment)\n        if result is not None:\n            return result\n    \n    # Try assigning False\n    new_assignment = assignment.copy()\n    new_assignment[var] = False\n    new_clauses = simplify(clauses, -var)\n    if new_clauses is not None:\n        result = dpll(new_clauses, new_assignment)\n        if result is not None:\n            return result\n    \n    return None  # Unsatisfiable\n\ndef solve_sat(cnf):\n    \"\"\"Solve SAT problem given CNF formula.\"\"\"\n    clauses = [set(clause) for clause in cnf]\n    return dpll(clauses)\n\n# Test cases\nprint(\"DPLL SAT Solver Tests\")\nprint(\"=\"*50)\n\n# Test 1: Simple satisfiable\n# (x1 ∨ x2) ∧ (¬x1 ∨ x2) ∧ (x1 ∨ ¬x2)\ncnf1 = [[1, 2], [-1, 2], [1, -2]]\nresult = solve_sat(cnf1)\nprint(f\"CNF 1: {cnf1}\")\nprint(f\"Result: {result}\")\n\n# Test 2: Unsatisfiable\n# (x1) ∧ (¬x1)\ncnf2 = [[1], [-1]]\nresult = solve_sat(cnf2)\nprint(f\"\\nCNF 2: {cnf2}\")\nprint(f\"Result: {result}\")\n\n# Test 3: Unit propagation test\n# (x1) ∧ (¬x1 ∨ x2) ∧ (¬x2 ∨ x3)\ncnf3 = [[1], [-1, 2], [-2, 3]]\nresult = solve_sat(cnf3)\nprint(f\"\\nCNF 3: {cnf3}\")\nprint(f\"Result: {result}\")\n\n# Test 4: Larger problem\ncnf4 = [[1, 2, 3], [-1, -2], [-2, -3], [1, 3]]\nresult = solve_sat(cnf4)\nprint(f\"\\nCNF 4: {cnf4}\")\nprint(f\"Result: {result}\")",
    "testCases": [
      {
        "input": "solve_sat([[1, 2], [-1, 2]])",
        "isHidden": false,
        "description": "Test satisfiable formula"
      },
      {
        "input": "solve_sat([[1], [-1]])",
        "isHidden": false,
        "description": "Test unsatisfiable formula"
      },
      {
        "input": "unit_propagate([[1], [-1, 2]], {})",
        "isHidden": false,
        "description": "Test unit propagation"
      }
    ],
    "hints": [
      "Unit clause has exactly one literal - it must be true",
      "Pure literal appears only positive or only negative - can safely assign",
      "After simplification, check for empty clauses (conflict) or empty formula (SAT)"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex06",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Forward Chaining Inference",
    "difficulty": 2,
    "description": "Implement forward chaining inference for propositional Horn clauses.\n\nYour implementation should:\n- Parse Horn clause knowledge bases\n- Apply forward chaining (data-driven) inference\n- Track which facts trigger which rules\n- Determine if a query can be derived from the KB",
    "starterCode": "class HornKB:\n    def __init__(self):\n        self.facts = set()  # Known true propositions\n        self.rules = []     # (premises, conclusion)\n    \n    def add_fact(self, fact):\n        pass\n    \n    def add_rule(self, premises, conclusion):\n        # premises: list of propositions\n        # conclusion: single proposition\n        pass\n\ndef forward_chain(kb, query):\n    # Apply forward chaining to derive query\n    # Return: (derivable, derivation_trace)\n    pass",
    "solution": "class HornKB:\n    def __init__(self):\n        self.facts = set()  # Known true propositions\n        self.rules = []     # (premises, conclusion)\n    \n    def add_fact(self, fact):\n        self.facts.add(fact)\n    \n    def add_rule(self, premises, conclusion):\n        self.rules.append((set(premises), conclusion))\n\ndef forward_chain(kb, query):\n    \"\"\"Forward chaining inference.\n    Returns: (derivable, derivation_trace)\n    \"\"\"\n    inferred = set(kb.facts)  # Start with known facts\n    trace = [('initial', list(kb.facts))]\n    \n    # Track how many premises remain for each rule\n    count = {i: len(rule[0]) for i, rule in enumerate(kb.rules)}\n    \n    # Queue of facts to process\n    agenda = list(kb.facts)\n    \n    while agenda:\n        p = agenda.pop(0)\n        \n        # Check each rule\n        for i, (premises, conclusion) in enumerate(kb.rules):\n            if p in premises:\n                count[i] -= 1\n                \n                # If all premises satisfied\n                if count[i] == 0:\n                    if conclusion not in inferred:\n                        inferred.add(conclusion)\n                        agenda.append(conclusion)\n                        trace.append(('derive', conclusion, list(premises)))\n                        \n                        if conclusion == query:\n                            return True, trace\n    \n    return query in inferred, trace\n\n# Test\nprint(\"Forward Chaining Inference\")\nprint(\"=\"*50)\n\n# Example KB:\n# P\n# Q\n# P ∧ Q → R\n# R → S\n# S ∧ P → T\n\nkb = HornKB()\nkb.add_fact('P')\nkb.add_fact('Q')\nkb.add_rule(['P', 'Q'], 'R')\nkb.add_rule(['R'], 'S')\nkb.add_rule(['S', 'P'], 'T')\n\nprint(\"Knowledge Base:\")\nprint(f\"  Facts: {kb.facts}\")\nprint(\"  Rules:\")\nfor premises, conclusion in kb.rules:\n    print(f\"    {' ∧ '.join(premises)} → {conclusion}\")\n\n# Query: Can we derive T?\nresult, trace = forward_chain(kb, 'T')\nprint(f\"\\nQuery: T\")\nprint(f\"Derivable: {result}\")\nprint(\"\\nDerivation trace:\")\nfor step in trace:\n    if step[0] == 'initial':\n        print(f\"  Initial facts: {step[1]}\")\n    else:\n        print(f\"  Derived {step[1]} from {step[2]}\")\n\n# Query: Can we derive X (not in KB)?\nresult, trace = forward_chain(kb, 'X')\nprint(f\"\\nQuery: X\")\nprint(f\"Derivable: {result}\")",
    "testCases": [
      {
        "input": "forward_chain(kb_with_PQ_and_rule_PQ_implies_R, 'R')",
        "isHidden": false,
        "description": "Test simple forward chaining"
      },
      {
        "input": "forward_chain(kb, 'nonexistent')",
        "isHidden": false,
        "description": "Test query not derivable"
      },
      {
        "input": "forward_chain(chain_kb, 'end_of_chain')",
        "isHidden": false,
        "description": "Test chained rules"
      }
    ],
    "hints": [
      "Start with known facts and repeatedly apply rules",
      "Track how many unsatisfied premises each rule has",
      "When a new fact is derived, check which rules it helps satisfy"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex07",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Backward Chaining Inference",
    "difficulty": 2,
    "description": "Implement backward chaining (goal-driven) inference for propositional Horn clauses.\n\nYour implementation should:\n- Work backward from the query to find supporting facts\n- Handle recursive subgoal derivation\n- Detect cycles to prevent infinite loops\n- Return the proof tree if query is derivable",
    "starterCode": "class HornKB:\n    def __init__(self):\n        self.facts = set()\n        self.rules = []  # (premises, conclusion)\n    \n    def add_fact(self, fact):\n        self.facts.add(fact)\n    \n    def add_rule(self, premises, conclusion):\n        self.rules.append((premises, conclusion))\n\ndef backward_chain(kb, query, visited=None):\n    # Goal-driven backward chaining\n    # Return: (derivable, proof_tree)\n    pass",
    "solution": "class HornKB:\n    def __init__(self):\n        self.facts = set()\n        self.rules = []  # (premises, conclusion)\n    \n    def add_fact(self, fact):\n        self.facts.add(fact)\n    \n    def add_rule(self, premises, conclusion):\n        self.rules.append((list(premises), conclusion))\n    \n    def get_rules_for(self, conclusion):\n        \"\"\"Get all rules that can derive the given conclusion.\"\"\"\n        return [(p, c) for p, c in self.rules if c == conclusion]\n\ndef backward_chain(kb, query, visited=None):\n    \"\"\"Backward chaining inference.\n    Returns: (derivable, proof_tree)\n    \"\"\"\n    if visited is None:\n        visited = set()\n    \n    # Cycle detection\n    if query in visited:\n        return False, None\n    visited = visited | {query}\n    \n    # Base case: query is a known fact\n    if query in kb.facts:\n        return True, {'goal': query, 'type': 'fact'}\n    \n    # Try each rule that concludes the query\n    rules = kb.get_rules_for(query)\n    \n    for premises, conclusion in rules:\n        # Try to prove all premises\n        subproofs = []\n        all_proved = True\n        \n        for premise in premises:\n            proved, proof = backward_chain(kb, premise, visited)\n            if proved:\n                subproofs.append(proof)\n            else:\n                all_proved = False\n                break\n        \n        if all_proved:\n            return True, {\n                'goal': query,\n                'type': 'rule',\n                'rule': f\"{' ∧ '.join(premises)} → {conclusion}\",\n                'subgoals': subproofs\n            }\n    \n    return False, None\n\ndef print_proof(proof, indent=0):\n    \"\"\"Pretty print a proof tree.\"\"\"\n    prefix = \"  \" * indent\n    if proof['type'] == 'fact':\n        print(f\"{prefix}✓ {proof['goal']} (fact)\")\n    else:\n        print(f\"{prefix}✓ {proof['goal']} by rule: {proof['rule']}\")\n        for subproof in proof['subgoals']:\n            print_proof(subproof, indent + 1)\n\n# Test\nprint(\"Backward Chaining Inference\")\nprint(\"=\"*50)\n\nkb = HornKB()\nkb.add_fact('P')\nkb.add_fact('Q')\nkb.add_rule(['P', 'Q'], 'R')\nkb.add_rule(['R'], 'S')\nkb.add_rule(['S', 'P'], 'T')\nkb.add_rule(['X'], 'Y')  # Rule with unprovable premise\n\nprint(\"Knowledge Base:\")\nprint(f\"  Facts: {kb.facts}\")\nprint(\"  Rules:\")\nfor premises, conclusion in kb.rules:\n    print(f\"    {' ∧ '.join(premises)} → {conclusion}\")\n\n# Query T\nprint(\"\\nQuery: T\")\nresult, proof = backward_chain(kb, 'T')\nprint(f\"Derivable: {result}\")\nif proof:\n    print(\"\\nProof tree:\")\n    print_proof(proof)\n\n# Query Y (not derivable)\nprint(\"\\nQuery: Y\")\nresult, proof = backward_chain(kb, 'Y')\nprint(f\"Derivable: {result}\")\n\n# Test cycle detection\nprint(\"\\nCycle Detection Test:\")\nkb2 = HornKB()\nkb2.add_rule(['B'], 'A')\nkb2.add_rule(['A'], 'B')  # Cycle!\nresult, proof = backward_chain(kb2, 'A')\nprint(f\"Query A with cycle: Derivable = {result}\")",
    "testCases": [
      {
        "input": "backward_chain(kb, 'known_fact')",
        "isHidden": false,
        "description": "Test query that is a fact"
      },
      {
        "input": "backward_chain(kb, 'derived_goal')",
        "isHidden": false,
        "description": "Test backward chaining through rules"
      },
      {
        "input": "backward_chain(kb_with_cycle, 'A')",
        "isHidden": false,
        "description": "Test cycle detection"
      }
    ],
    "hints": [
      "Start from the query and work backward to find supporting facts",
      "Use a visited set to detect and break cycles",
      "Try each rule that could derive the goal"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex08",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Skolemization",
    "difficulty": 3,
    "description": "Implement Skolemization to convert first-order logic formulas to Skolem normal form.\n\nYour implementation should:\n- Eliminate existential quantifiers by introducing Skolem functions\n- Handle nested quantifiers correctly (Skolem functions depend on outer universals)\n- Maintain logical equivalence for satisfiability\n- Convert to prenex form first if needed",
    "starterCode": "class FOLFormula:\n    pass\n\nclass Predicate(FOLFormula):\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args  # List of terms\n\nclass ForAll(FOLFormula):\n    def __init__(self, var, formula):\n        self.var = var\n        self.formula = formula\n\nclass Exists(FOLFormula):\n    def __init__(self, var, formula):\n        self.var = var\n        self.formula = formula\n\nclass Variable:\n    def __init__(self, name):\n        self.name = name\n\nclass SkolemFunction:\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args\n\ndef skolemize(formula, universal_vars=None, skolem_count=None):\n    # Eliminate existential quantifiers\n    # Return: Skolemized formula\n    pass",
    "solution": "class FOLFormula:\n    pass\n\nclass Predicate(FOLFormula):\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args\n    def __repr__(self):\n        args_str = ', '.join(str(a) for a in self.args)\n        return f\"{self.name}({args_str})\"\n\nclass Not(FOLFormula):\n    def __init__(self, f):\n        self.formula = f\n    def __repr__(self):\n        return f\"¬{self.formula}\"\n\nclass And(FOLFormula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"({self.left} ∧ {self.right})\"\n\nclass Or(FOLFormula):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"({self.left} ∨ {self.right})\"\n\nclass ForAll(FOLFormula):\n    def __init__(self, var, formula):\n        self.var = var\n        self.formula = formula\n    def __repr__(self):\n        return f\"∀{self.var}.{self.formula}\"\n\nclass Exists(FOLFormula):\n    def __init__(self, var, formula):\n        self.var = var\n        self.formula = formula\n    def __repr__(self):\n        return f\"∃{self.var}.{self.formula}\"\n\nclass Variable:\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n\nclass Constant:\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n\nclass SkolemFunction:\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args\n    def __repr__(self):\n        if not self.args:\n            return self.name  # Skolem constant\n        args_str = ', '.join(str(a) for a in self.args)\n        return f\"{self.name}({args_str})\"\n\ndef substitute(formula, var, term):\n    \"\"\"Substitute term for variable in formula.\"\"\"\n    if isinstance(formula, Predicate):\n        new_args = []\n        for arg in formula.args:\n            if isinstance(arg, Variable) and arg.name == var:\n                new_args.append(term)\n            else:\n                new_args.append(arg)\n        return Predicate(formula.name, new_args)\n    elif isinstance(formula, Not):\n        return Not(substitute(formula.formula, var, term))\n    elif isinstance(formula, And):\n        return And(substitute(formula.left, var, term),\n                   substitute(formula.right, var, term))\n    elif isinstance(formula, Or):\n        return Or(substitute(formula.left, var, term),\n                  substitute(formula.right, var, term))\n    elif isinstance(formula, ForAll):\n        if formula.var == var:\n            return formula  # Variable shadowed\n        return ForAll(formula.var, substitute(formula.formula, var, term))\n    elif isinstance(formula, Exists):\n        if formula.var == var:\n            return formula\n        return Exists(formula.var, substitute(formula.formula, var, term))\n    return formula\n\nclass SkolemCounter:\n    def __init__(self):\n        self.count = 0\n    def next(self):\n        self.count += 1\n        return f\"sk{self.count}\"\n\ndef skolemize(formula, universal_vars=None, counter=None):\n    \"\"\"Eliminate existential quantifiers using Skolem functions.\"\"\"\n    if universal_vars is None:\n        universal_vars = []\n    if counter is None:\n        counter = SkolemCounter()\n    \n    if isinstance(formula, Predicate):\n        return formula\n    elif isinstance(formula, Not):\n        return Not(skolemize(formula.formula, universal_vars, counter))\n    elif isinstance(formula, And):\n        return And(skolemize(formula.left, universal_vars, counter),\n                   skolemize(formula.right, universal_vars, counter))\n    elif isinstance(formula, Or):\n        return Or(skolemize(formula.left, universal_vars, counter),\n                  skolemize(formula.right, universal_vars, counter))\n    elif isinstance(formula, ForAll):\n        # Add variable to scope and continue\n        new_universal = universal_vars + [Variable(formula.var)]\n        inner = skolemize(formula.formula, new_universal, counter)\n        return ForAll(formula.var, inner)\n    elif isinstance(formula, Exists):\n        # Replace with Skolem function/constant\n        skolem_name = counter.next()\n        if universal_vars:\n            # Skolem function depends on universal vars\n            skolem_term = SkolemFunction(skolem_name, universal_vars)\n        else:\n            # Skolem constant (no dependencies)\n            skolem_term = SkolemFunction(skolem_name, [])\n        \n        # Substitute and continue\n        inner = substitute(formula.formula, formula.var, skolem_term)\n        return skolemize(inner, universal_vars, counter)\n    \n    return formula\n\n# Test\nprint(\"Skolemization Examples\")\nprint(\"=\"*50)\n\nx, y, z = Variable('x'), Variable('y'), Variable('z')\n\n# Test 1: ∃x.P(x) → P(sk1)\nf1 = Exists('x', Predicate('P', [Variable('x')]))\nprint(f\"Original: {f1}\")\nprint(f\"Skolemized: {skolemize(f1)}\")\n\n# Test 2: ∀x.∃y.Loves(x,y) → ∀x.Loves(x, sk(x))\nf2 = ForAll('x', Exists('y', Predicate('Loves', [Variable('x'), Variable('y')])))\nprint(f\"\\nOriginal: {f2}\")\nprint(f\"Skolemized: {skolemize(f2)}\")\n\n# Test 3: ∀x.∀y.∃z.Between(x,z,y)\nf3 = ForAll('x', ForAll('y', Exists('z', \n    Predicate('Between', [Variable('x'), Variable('z'), Variable('y')]))))\nprint(f\"\\nOriginal: {f3}\")\nprint(f\"Skolemized: {skolemize(f3)}\")",
    "testCases": [
      {
        "input": "skolemize(Exists('x', P(x)))",
        "isHidden": false,
        "description": "Skolemize simple existential"
      },
      {
        "input": "skolemize(ForAll('x', Exists('y', R(x,y))))",
        "isHidden": false,
        "description": "Skolem function with universal dependency"
      },
      {
        "input": "skolemize(nested_quantifiers)",
        "isHidden": false,
        "description": "Multiple nested quantifiers"
      }
    ],
    "hints": [
      "Track universal variables in scope when encountering existentials",
      "Skolem constants have no arguments; Skolem functions have universal vars as args",
      "Substitute the Skolem term for the existentially quantified variable"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex09",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Semantic Network",
    "difficulty": 2,
    "description": "Implement a semantic network for knowledge representation with inheritance.\n\nYour implementation should:\n- Support IS-A and HAS-A relationships\n- Implement property inheritance through IS-A links\n- Handle property overriding in subclasses\n- Support queries about concepts and their properties",
    "starterCode": "class SemanticNetwork:\n    def __init__(self):\n        self.nodes = {}  # concept -> properties dict\n        self.isa = {}    # concept -> parent concepts\n    \n    def add_concept(self, name, properties=None):\n        pass\n    \n    def add_isa(self, child, parent):\n        pass\n    \n    def get_property(self, concept, property_name):\n        # Get property with inheritance\n        pass\n    \n    def get_all_properties(self, concept):\n        # Get all properties including inherited\n        pass\n    \n    def query_isa(self, concept, ancestor):\n        # Check if concept IS-A ancestor (transitive)\n        pass",
    "solution": "class SemanticNetwork:\n    def __init__(self):\n        self.nodes = {}  # concept -> properties dict\n        self.isa = {}    # concept -> list of parent concepts\n    \n    def add_concept(self, name, properties=None):\n        if properties is None:\n            properties = {}\n        self.nodes[name] = properties\n        if name not in self.isa:\n            self.isa[name] = []\n    \n    def add_isa(self, child, parent):\n        if child not in self.isa:\n            self.isa[child] = []\n        self.isa[child].append(parent)\n    \n    def get_ancestors(self, concept, visited=None):\n        \"\"\"Get all ancestors of a concept (transitive IS-A).\"\"\"\n        if visited is None:\n            visited = set()\n        if concept in visited:\n            return set()\n        visited.add(concept)\n        \n        ancestors = set()\n        for parent in self.isa.get(concept, []):\n            ancestors.add(parent)\n            ancestors.update(self.get_ancestors(parent, visited))\n        return ancestors\n    \n    def get_property(self, concept, property_name):\n        \"\"\"Get property with inheritance (most specific wins).\"\"\"\n        # Check local properties first\n        if concept in self.nodes:\n            if property_name in self.nodes[concept]:\n                return self.nodes[concept][property_name]\n        \n        # Check parents (BFS for closest ancestor)\n        to_check = list(self.isa.get(concept, []))\n        visited = {concept}\n        \n        while to_check:\n            parent = to_check.pop(0)\n            if parent in visited:\n                continue\n            visited.add(parent)\n            \n            if parent in self.nodes:\n                if property_name in self.nodes[parent]:\n                    return self.nodes[parent][property_name]\n            \n            to_check.extend(self.isa.get(parent, []))\n        \n        return None\n    \n    def get_all_properties(self, concept):\n        \"\"\"Get all properties including inherited (local overrides inherited).\"\"\"\n        properties = {}\n        \n        # Collect from ancestors (farthest first)\n        ancestors = list(self.get_ancestors(concept))\n        for ancestor in reversed(ancestors):\n            if ancestor in self.nodes:\n                properties.update(self.nodes[ancestor])\n        \n        # Local properties override\n        if concept in self.nodes:\n            properties.update(self.nodes[concept])\n        \n        return properties\n    \n    def query_isa(self, concept, ancestor):\n        \"\"\"Check if concept IS-A ancestor (transitive).\"\"\"\n        if concept == ancestor:\n            return True\n        return ancestor in self.get_ancestors(concept)\n\n# Test\nprint(\"Semantic Network with Inheritance\")\nprint(\"=\"*50)\n\nnet = SemanticNetwork()\n\n# Animal hierarchy\nnet.add_concept('Animal', {'has': 'metabolism', 'moves': True})\nnet.add_concept('Mammal', {'has': 'fur', 'warm_blooded': True})\nnet.add_concept('Bird', {'has': 'feathers', 'warm_blooded': True, 'can_fly': True})\nnet.add_concept('Dog', {'sound': 'bark', 'legs': 4})\nnet.add_concept('Cat', {'sound': 'meow', 'legs': 4})\nnet.add_concept('Penguin', {'can_fly': False, 'habitat': 'Antarctica'})\nnet.add_concept('Tweety', {'color': 'yellow', 'name': 'Tweety'})\n\nnet.add_isa('Mammal', 'Animal')\nnet.add_isa('Bird', 'Animal')\nnet.add_isa('Dog', 'Mammal')\nnet.add_isa('Cat', 'Mammal')\nnet.add_isa('Penguin', 'Bird')\nnet.add_isa('Tweety', 'Bird')\n\nprint(\"Hierarchy: Animal > Mammal > Dog, Cat\")\nprint(\"          Animal > Bird > Penguin, Tweety\")\n\n# Test inheritance\nprint(\"\\nProperty queries:\")\nprint(f\"  Dog has: {net.get_property('Dog', 'has')}\")\nprint(f\"  Dog warm_blooded: {net.get_property('Dog', 'warm_blooded')}\")\nprint(f\"  Penguin can_fly: {net.get_property('Penguin', 'can_fly')}\")\nprint(f\"  Tweety can_fly: {net.get_property('Tweety', 'can_fly')}\")\n\nprint(\"\\nAll properties of Penguin:\")\nfor prop, val in net.get_all_properties('Penguin').items():\n    print(f\"  {prop}: {val}\")\n\nprint(\"\\nIS-A queries:\")\nprint(f\"  Dog IS-A Animal: {net.query_isa('Dog', 'Animal')}\")\nprint(f\"  Cat IS-A Bird: {net.query_isa('Cat', 'Bird')}\")\nprint(f\"  Penguin IS-A Bird: {net.query_isa('Penguin', 'Bird')}\")",
    "testCases": [
      {
        "input": "net.get_property('Dog', 'warm_blooded')",
        "isHidden": false,
        "description": "Test property inheritance"
      },
      {
        "input": "net.get_property('Penguin', 'can_fly')",
        "isHidden": false,
        "description": "Test property override"
      },
      {
        "input": "net.query_isa('Dog', 'Animal')",
        "isHidden": false,
        "description": "Test transitive IS-A"
      }
    ],
    "hints": [
      "Use BFS to find closest ancestor with the property",
      "Local properties override inherited ones",
      "Handle cycles in the IS-A graph"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex10",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Description Logic Reasoner",
    "difficulty": 4,
    "description": "Implement a basic description logic reasoner supporting ALC (Attributive Language with Complements).\n\nYour implementation should:\n- Support concept definitions (atomic, conjunction, disjunction, negation)\n- Support role restrictions (existential ∃R.C and universal ∀R.C)\n- Check concept subsumption (C ⊑ D)\n- Check concept satisfiability",
    "starterCode": "class Concept:\n    pass\n\nclass AtomicConcept(Concept):\n    def __init__(self, name):\n        self.name = name\n\nclass Conjunction(Concept):\n    def __init__(self, concepts):\n        self.concepts = concepts  # C ⊓ D\n\nclass Disjunction(Concept):\n    def __init__(self, concepts):\n        self.concepts = concepts  # C ⊔ D\n\nclass Negation(Concept):\n    def __init__(self, concept):\n        self.concept = concept    # ¬C\n\nclass ExistsRestriction(Concept):\n    def __init__(self, role, concept):\n        self.role = role\n        self.concept = concept    # ∃R.C\n\nclass ForallRestriction(Concept):\n    def __init__(self, role, concept):\n        self.role = role\n        self.concept = concept    # ∀R.C\n\ndef is_satisfiable(concept, tbox=None):\n    # Check if concept is satisfiable\n    pass\n\ndef subsumes(c1, c2, tbox=None):\n    # Check if c1 ⊑ c2\n    pass",
    "solution": "class Concept:\n    pass\n\nclass Top(Concept):\n    def __repr__(self):\n        return \"⊤\"\n\nclass Bottom(Concept):\n    def __repr__(self):\n        return \"⊥\"\n\nclass AtomicConcept(Concept):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n    def __eq__(self, other):\n        return isinstance(other, AtomicConcept) and self.name == other.name\n    def __hash__(self):\n        return hash(self.name)\n\nclass Conjunction(Concept):\n    def __init__(self, concepts):\n        self.concepts = list(concepts)\n    def __repr__(self):\n        return f\"({' ⊓ '.join(str(c) for c in self.concepts)})\"\n\nclass Disjunction(Concept):\n    def __init__(self, concepts):\n        self.concepts = list(concepts)\n    def __repr__(self):\n        return f\"({' ⊔ '.join(str(c) for c in self.concepts)})\"\n\nclass Negation(Concept):\n    def __init__(self, concept):\n        self.concept = concept\n    def __repr__(self):\n        return f\"¬{self.concept}\"\n\nclass ExistsRestriction(Concept):\n    def __init__(self, role, concept):\n        self.role = role\n        self.concept = concept\n    def __repr__(self):\n        return f\"∃{self.role}.{self.concept}\"\n\nclass ForallRestriction(Concept):\n    def __init__(self, role, concept):\n        self.role = role\n        self.concept = concept\n    def __repr__(self):\n        return f\"∀{self.role}.{self.concept}\"\n\ndef nnf(concept):\n    \"\"\"Convert concept to Negation Normal Form.\"\"\"\n    if isinstance(concept, (Top, Bottom, AtomicConcept)):\n        return concept\n    elif isinstance(concept, Negation):\n        inner = concept.concept\n        if isinstance(inner, Top):\n            return Bottom()\n        elif isinstance(inner, Bottom):\n            return Top()\n        elif isinstance(inner, AtomicConcept):\n            return concept\n        elif isinstance(inner, Negation):\n            return nnf(inner.concept)\n        elif isinstance(inner, Conjunction):\n            return Disjunction([nnf(Negation(c)) for c in inner.concepts])\n        elif isinstance(inner, Disjunction):\n            return Conjunction([nnf(Negation(c)) for c in inner.concepts])\n        elif isinstance(inner, ExistsRestriction):\n            return ForallRestriction(inner.role, nnf(Negation(inner.concept)))\n        elif isinstance(inner, ForallRestriction):\n            return ExistsRestriction(inner.role, nnf(Negation(inner.concept)))\n    elif isinstance(concept, Conjunction):\n        return Conjunction([nnf(c) for c in concept.concepts])\n    elif isinstance(concept, Disjunction):\n        return Disjunction([nnf(c) for c in concept.concepts])\n    elif isinstance(concept, ExistsRestriction):\n        return ExistsRestriction(concept.role, nnf(concept.concept))\n    elif isinstance(concept, ForallRestriction):\n        return ForallRestriction(concept.role, nnf(concept.concept))\n    return concept\n\ndef is_satisfiable(concept, tbox=None, max_depth=10):\n    \"\"\"Check satisfiability using tableau algorithm (simplified).\"\"\"\n    concept = nnf(concept)\n    \n    def tableau(labels, successors, depth):\n        if depth > max_depth:\n            return True  # Assume satisfiable if depth exceeded\n        \n        # Check for clash (A and ¬A)\n        atoms = set()\n        neg_atoms = set()\n        for c in labels:\n            if isinstance(c, AtomicConcept):\n                atoms.add(c.name)\n            elif isinstance(c, Negation) and isinstance(c.concept, AtomicConcept):\n                neg_atoms.add(c.concept.name)\n        if atoms & neg_atoms:\n            return False  # Clash found\n        \n        if isinstance(Bottom(), type) and Bottom() in labels:\n            return False\n        \n        # Expand conjunctions\n        for c in list(labels):\n            if isinstance(c, Conjunction):\n                labels.remove(c)\n                labels.update(c.concepts)\n                return tableau(labels, successors, depth)\n        \n        # Expand disjunctions (try both branches)\n        for c in list(labels):\n            if isinstance(c, Disjunction):\n                labels.remove(c)\n                for disjunct in c.concepts:\n                    new_labels = labels.copy()\n                    new_labels.add(disjunct)\n                    if tableau(new_labels, successors.copy(), depth):\n                        return True\n                return False\n        \n        # Handle existential restrictions\n        for c in list(labels):\n            if isinstance(c, ExistsRestriction):\n                labels.remove(c)\n                role = c.role\n                if role not in successors:\n                    successors[role] = set()\n                successors[role].add(c.concept)\n        \n        # Handle universal restrictions\n        for c in list(labels):\n            if isinstance(c, ForallRestriction):\n                role = c.role\n                if role in successors:\n                    for succ_concept in successors[role]:\n                        labels.add(Conjunction([succ_concept, c.concept]))\n        \n        # Check successors\n        for role, concepts in successors.items():\n            succ_labels = set(concepts)\n            if not tableau(succ_labels, {}, depth + 1):\n                return False\n        \n        return True\n    \n    return tableau({concept}, {}, 0)\n\ndef subsumes(c1, c2, tbox=None):\n    \"\"\"Check if c1 ⊑ c2 (c1 is subsumed by c2).\n    c1 ⊑ c2 iff c1 ⊓ ¬c2 is unsatisfiable.\"\"\"\n    test = Conjunction([c1, Negation(c2)])\n    return not is_satisfiable(test, tbox)\n\n# Test\nprint(\"Description Logic Reasoner\")\nprint(\"=\"*50)\n\nPerson = AtomicConcept('Person')\nParent = AtomicConcept('Parent')\nChild = AtomicConcept('Child')\n\n# Test 1: Person ⊓ ¬Person is unsatisfiable\ntest1 = Conjunction([Person, Negation(Person)])\nprint(f\"\\n{test1}\")\nprint(f\"Satisfiable: {is_satisfiable(test1)}\")\n\n# Test 2: Person ⊔ ¬Person is satisfiable (tautology)\ntest2 = Disjunction([Person, Negation(Person)])\nprint(f\"\\n{test2}\")\nprint(f\"Satisfiable: {is_satisfiable(test2)}\")\n\n# Test 3: ∃hasChild.Person\ntest3 = ExistsRestriction('hasChild', Person)\nprint(f\"\\n{test3}\")\nprint(f\"Satisfiable: {is_satisfiable(test3)}\")\n\n# Test 4: Subsumption\nprint(f\"\\nSubsumption tests:\")\nprint(f\"  (Person ⊓ Parent) ⊑ Person: {subsumes(Conjunction([Person, Parent]), Person)}\")\nprint(f\"  Person ⊑ (Person ⊓ Parent): {subsumes(Person, Conjunction([Person, Parent]))}\")",
    "testCases": [
      {
        "input": "is_satisfiable(Conjunction([A, Negation(A)]))",
        "isHidden": false,
        "description": "Test unsatisfiable concept"
      },
      {
        "input": "is_satisfiable(Disjunction([A, B]))",
        "isHidden": false,
        "description": "Test satisfiable disjunction"
      },
      {
        "input": "subsumes(Conjunction([A, B]), A)",
        "isHidden": false,
        "description": "Test subsumption"
      }
    ],
    "hints": [
      "Convert to NNF first for easier processing",
      "Use tableau algorithm: expand formulas and check for clashes",
      "C ⊑ D iff C ⊓ ¬D is unsatisfiable"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex11",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Rule-Based Expert System",
    "difficulty": 3,
    "description": "Implement a rule-based expert system with conflict resolution.\n\nYour implementation should:\n- Support IF-THEN rules with multiple conditions\n- Implement forward chaining inference\n- Handle conflict resolution when multiple rules fire\n- Support rule priorities and recency-based selection",
    "starterCode": "class Rule:\n    def __init__(self, name, conditions, actions, priority=0):\n        self.name = name\n        self.conditions = conditions  # List of facts to match\n        self.actions = actions        # Facts to assert\n        self.priority = priority\n\nclass ExpertSystem:\n    def __init__(self):\n        self.rules = []\n        self.facts = set()\n        self.fact_timestamps = {}  # For recency\n    \n    def add_rule(self, rule):\n        pass\n    \n    def assert_fact(self, fact):\n        pass\n    \n    def get_applicable_rules(self):\n        # Return rules whose conditions are all satisfied\n        pass\n    \n    def resolve_conflicts(self, rules):\n        # Select which rule to fire\n        pass\n    \n    def run(self, max_iterations=100):\n        # Run inference engine\n        pass",
    "solution": "import time\n\nclass Rule:\n    def __init__(self, name, conditions, actions, priority=0):\n        self.name = name\n        self.conditions = conditions\n        self.actions = actions\n        self.priority = priority\n    \n    def __repr__(self):\n        conds = ' AND '.join(self.conditions)\n        acts = ', '.join(self.actions)\n        return f\"{self.name}: IF {conds} THEN {acts} (pri={self.priority})\"\n\nclass ExpertSystem:\n    def __init__(self):\n        self.rules = []\n        self.facts = set()\n        self.fact_timestamps = {}\n        self.fired_rules = set()  # Track which (rule, bindings) have fired\n        self.time_counter = 0\n    \n    def add_rule(self, rule):\n        self.rules.append(rule)\n    \n    def assert_fact(self, fact):\n        if fact not in self.facts:\n            self.facts.add(fact)\n            self.time_counter += 1\n            self.fact_timestamps[fact] = self.time_counter\n            return True\n        return False\n    \n    def retract_fact(self, fact):\n        self.facts.discard(fact)\n        self.fact_timestamps.pop(fact, None)\n    \n    def get_applicable_rules(self):\n        \"\"\"Return list of (rule, matching_facts) for applicable rules.\"\"\"\n        applicable = []\n        for rule in self.rules:\n            # Check if all conditions are satisfied\n            if all(cond in self.facts for cond in rule.conditions):\n                # Create tuple of matched facts for refraction\n                match_key = (rule.name, tuple(sorted(rule.conditions)))\n                if match_key not in self.fired_rules:\n                    applicable.append((rule, match_key))\n        return applicable\n    \n    def resolve_conflicts(self, applicable):\n        \"\"\"Select rule using: priority > specificity > recency.\"\"\"\n        if not applicable:\n            return None\n        \n        def rule_score(item):\n            rule, match_key = item\n            # Higher priority first\n            priority = rule.priority\n            # More conditions = more specific\n            specificity = len(rule.conditions)\n            # Most recent fact timestamp\n            recency = max(self.fact_timestamps.get(c, 0) \n                         for c in rule.conditions) if rule.conditions else 0\n            return (priority, specificity, recency)\n        \n        applicable.sort(key=rule_score, reverse=True)\n        return applicable[0]\n    \n    def run(self, max_iterations=100, verbose=True):\n        \"\"\"Run forward chaining inference.\"\"\"\n        iteration = 0\n        trace = []\n        \n        while iteration < max_iterations:\n            iteration += 1\n            applicable = self.get_applicable_rules()\n            \n            if not applicable:\n                break\n            \n            # Conflict resolution\n            selected = self.resolve_conflicts(applicable)\n            if selected is None:\n                break\n            \n            rule, match_key = selected\n            \n            # Fire rule\n            self.fired_rules.add(match_key)\n            new_facts = []\n            for action in rule.actions:\n                if self.assert_fact(action):\n                    new_facts.append(action)\n            \n            trace.append({\n                'iteration': iteration,\n                'rule': rule.name,\n                'new_facts': new_facts\n            })\n            \n            if verbose:\n                print(f\"Iteration {iteration}: Fire {rule.name}\")\n                print(f\"  New facts: {new_facts}\")\n        \n        return trace\n\n# Test: Medical diagnosis expert system\nprint(\"Rule-Based Expert System\")\nprint(\"=\"*50)\n\nes = ExpertSystem()\n\n# Rules for diagnosing flu\nes.add_rule(Rule('R1', ['fever', 'cough'], ['possible_flu'], priority=1))\nes.add_rule(Rule('R2', ['possible_flu', 'body_aches'], ['likely_flu'], priority=2))\nes.add_rule(Rule('R3', ['likely_flu'], ['recommend_rest', 'recommend_fluids'], priority=3))\nes.add_rule(Rule('R4', ['fever', 'rash'], ['possible_measles'], priority=1))\nes.add_rule(Rule('R5', ['fever'], ['take_temperature'], priority=0))\n\nprint(\"Rules:\")\nfor rule in es.rules:\n    print(f\"  {rule}\")\n\nprint(\"\\n\" + \"=\"*50)\nprint(\"Scenario: Patient has fever, cough, body_aches\")\nprint(\"=\"*50 + \"\\n\")\n\n# Initial facts\nes.assert_fact('fever')\nes.assert_fact('cough')\nes.assert_fact('body_aches')\n\nprint(f\"Initial facts: {es.facts}\\n\")\n\n# Run inference\ntrace = es.run()\n\nprint(f\"\\nFinal facts: {es.facts}\")",
    "testCases": [
      {
        "input": "es.get_applicable_rules()",
        "isHidden": false,
        "description": "Test finding applicable rules"
      },
      {
        "input": "es.resolve_conflicts([r1, r2])",
        "isHidden": false,
        "description": "Test conflict resolution by priority"
      },
      {
        "input": "es.run()",
        "isHidden": false,
        "description": "Test complete inference cycle"
      }
    ],
    "hints": [
      "Refraction: don't fire same rule with same facts twice",
      "Conflict resolution order: priority, specificity, recency",
      "Track timestamps to implement recency-based selection"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex12",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Default Logic Reasoning",
    "difficulty": 4,
    "description": "Implement default logic reasoning for non-monotonic inference.\n\nYour implementation should:\n- Support default rules of the form A:B/C (if A and B is consistent, conclude C)\n- Compute extensions (maximal consistent belief sets)\n- Handle conflicts between defaults\n- Support prerequisite, justification, and consequent",
    "starterCode": "class Default:\n    def __init__(self, prerequisite, justifications, consequent):\n        self.prerequisite = prerequisite    # Must be believed\n        self.justifications = justifications # Must be consistent\n        self.consequent = consequent        # Conclusion\n\nclass DefaultTheory:\n    def __init__(self):\n        self.facts = set()      # Initial facts (W)\n        self.defaults = []      # Default rules (D)\n    \n    def add_fact(self, fact):\n        pass\n    \n    def add_default(self, default):\n        pass\n    \n    def is_consistent(self, beliefs, formula):\n        # Check if formula is consistent with beliefs\n        pass\n    \n    def compute_extension(self):\n        # Compute an extension\n        pass",
    "solution": "class Default:\n    def __init__(self, prerequisite, justifications, consequent):\n        self.prerequisite = prerequisite\n        self.justifications = justifications  # List of formulas\n        self.consequent = consequent\n    \n    def __repr__(self):\n        justs = ', '.join(self.justifications) if self.justifications else 'True'\n        return f\"{self.prerequisite} : {justs} / {self.consequent}\"\n\nclass DefaultTheory:\n    def __init__(self):\n        self.facts = set()\n        self.defaults = []\n        self.negation_map = {}  # Map formulas to their negations\n    \n    def add_fact(self, fact):\n        self.facts.add(fact)\n    \n    def add_default(self, default):\n        self.defaults.append(default)\n    \n    def set_negation(self, pos, neg):\n        \"\"\"Define negation relationship between formulas.\"\"\"\n        self.negation_map[pos] = neg\n        self.negation_map[neg] = pos\n    \n    def get_negation(self, formula):\n        \"\"\"Get negation of formula.\"\"\"\n        if formula in self.negation_map:\n            return self.negation_map[formula]\n        if formula.startswith('~'):\n            return formula[1:]\n        return '~' + formula\n    \n    def is_consistent(self, beliefs, formula):\n        \"\"\"Check if formula is consistent with beliefs.\"\"\"\n        neg = self.get_negation(formula)\n        return neg not in beliefs\n    \n    def prerequisite_satisfied(self, default, beliefs):\n        \"\"\"Check if prerequisite is in beliefs or is 'True'.\"\"\"\n        if default.prerequisite == 'True' or default.prerequisite is None:\n            return True\n        return default.prerequisite in beliefs\n    \n    def justifications_consistent(self, default, beliefs):\n        \"\"\"Check if all justifications are consistent with beliefs.\"\"\"\n        for just in default.justifications:\n            if not self.is_consistent(beliefs, just):\n                return False\n        return True\n    \n    def get_applicable_defaults(self, beliefs, used_defaults):\n        \"\"\"Find defaults that can be applied.\"\"\"\n        applicable = []\n        for i, d in enumerate(self.defaults):\n            if i in used_defaults:\n                continue\n            if self.prerequisite_satisfied(d, beliefs):\n                if self.justifications_consistent(d, beliefs):\n                    if d.consequent not in beliefs:\n                        applicable.append((i, d))\n        return applicable\n    \n    def compute_extension(self, order=None):\n        \"\"\"Compute an extension using given order of defaults.\"\"\"\n        beliefs = set(self.facts)\n        used_defaults = set()\n        trace = [('initial', list(self.facts))]\n        \n        changed = True\n        while changed:\n            changed = False\n            applicable = self.get_applicable_defaults(beliefs, used_defaults)\n            \n            if not applicable:\n                break\n            \n            # Select first applicable (or use provided order)\n            idx, default = applicable[0]\n            \n            # Apply default\n            used_defaults.add(idx)\n            beliefs.add(default.consequent)\n            trace.append(('apply', str(default), default.consequent))\n            changed = True\n        \n        # Verify extension: check justifications still hold\n        valid = True\n        for idx in used_defaults:\n            d = self.defaults[idx]\n            for just in d.justifications:\n                if not self.is_consistent(beliefs, just):\n                    valid = False\n                    break\n        \n        return beliefs, trace, valid\n    \n    def compute_all_extensions(self):\n        \"\"\"Compute all possible extensions (simplified).\"\"\"\n        from itertools import permutations\n        \n        extensions = []\n        seen = set()\n        \n        # Try different orderings of defaults\n        for perm in permutations(range(len(self.defaults))):\n            beliefs = set(self.facts)\n            used = set()\n            \n            for idx in perm:\n                d = self.defaults[idx]\n                if self.prerequisite_satisfied(d, beliefs):\n                    if self.justifications_consistent(d, beliefs):\n                        beliefs.add(d.consequent)\n                        used.add(idx)\n            \n            # Check validity\n            valid = True\n            for idx in used:\n                d = self.defaults[idx]\n                for just in d.justifications:\n                    if not self.is_consistent(beliefs, just):\n                        valid = False\n            \n            if valid:\n                frozen = frozenset(beliefs)\n                if frozen not in seen:\n                    seen.add(frozen)\n                    extensions.append(beliefs)\n        \n        return extensions\n\n# Test\nprint(\"Default Logic Reasoning\")\nprint(\"=\"*50)\n\n# Classic example: Birds normally fly\ndt = DefaultTheory()\n\n# Facts\ndt.add_fact('bird(tweety)')\ndt.add_fact('penguin(opus)')\ndt.add_fact('bird(opus)')  # Penguins are birds\n\n# Negations\ndt.set_negation('flies(tweety)', '~flies(tweety)')\ndt.set_negation('flies(opus)', '~flies(opus)')\n\n# Defaults\n# Birds normally fly: bird(X) : flies(X) / flies(X)\ndt.add_default(Default('bird(tweety)', ['flies(tweety)'], 'flies(tweety)'))\ndt.add_default(Default('bird(opus)', ['flies(opus)'], 'flies(opus)'))\n\n# Penguins don't fly: penguin(X) : ~flies(X) / ~flies(X)\ndt.add_default(Default('penguin(opus)', ['~flies(opus)'], '~flies(opus)'))\n\nprint(\"Facts:\", dt.facts)\nprint(\"\\nDefaults:\")\nfor d in dt.defaults:\n    print(f\"  {d}\")\n\nprint(\"\\n\" + \"=\"*50)\nprint(\"Computing extension...\")\nprint(\"=\"*50)\n\nbeliefs, trace, valid = dt.compute_extension()\nprint(\"\\nTrace:\")\nfor step in trace:\n    print(f\"  {step}\")\n\nprint(f\"\\nExtension: {beliefs}\")\nprint(f\"Valid: {valid}\")\n\n# Nixon diamond\nprint(\"\\n\" + \"=\"*50)\nprint(\"Nixon Diamond Example\")\nprint(\"=\"*50)\n\ndt2 = DefaultTheory()\ndt2.add_fact('quaker(nixon)')\ndt2.add_fact('republican(nixon)')\ndt2.set_negation('pacifist(nixon)', '~pacifist(nixon)')\n\n# Quakers are normally pacifists\ndt2.add_default(Default('quaker(nixon)', ['pacifist(nixon)'], 'pacifist(nixon)'))\n# Republicans are normally not pacifists\ndt2.add_default(Default('republican(nixon)', ['~pacifist(nixon)'], '~pacifist(nixon)'))\n\nprint(\"Facts:\", dt2.facts)\nprint(\"Defaults:\")\nfor d in dt2.defaults:\n    print(f\"  {d}\")\n\nextensions = dt2.compute_all_extensions()\nprint(f\"\\nNumber of extensions: {len(extensions)}\")\nfor i, ext in enumerate(extensions):\n    print(f\"  Extension {i+1}: {ext}\")",
    "testCases": [
      {
        "input": "dt.compute_extension()",
        "isHidden": false,
        "description": "Test computing single extension"
      },
      {
        "input": "dt.is_consistent(beliefs, formula)",
        "isHidden": false,
        "description": "Test consistency checking"
      },
      {
        "input": "nixon_diamond.compute_all_extensions()",
        "isHidden": false,
        "description": "Test multiple extensions"
      }
    ],
    "hints": [
      "Default A:B/C means: if A is believed and B is consistent, conclude C",
      "Extension must be maximal and satisfy all applied justifications",
      "Multiple extensions are possible when defaults conflict"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex13",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "FOL Resolution Theorem Prover",
    "difficulty": 4,
    "description": "Extend resolution theorem proving to first-order logic with unification.\n\nYour implementation should:\n- Handle clauses with variables and function symbols\n- Apply unification to find complementary literals\n- Implement the resolution rule with substitution\n- Standardize variables apart when resolving clauses",
    "starterCode": "class FOLClause:\n    def __init__(self, literals):\n        # literals: list of (predicate, args, negated)\n        pass\n\ndef unify_literals(lit1, lit2):\n    # Find MGU for two literals\n    pass\n\ndef resolve_fol(clause1, clause2):\n    # Apply resolution with unification\n    pass\n\ndef fol_resolution(kb, query):\n    # First-order resolution theorem prover\n    pass",
    "solution": "class Term:\n    pass\n\nclass Variable(Term):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return f\"?{self.name}\"\n    def __eq__(self, other):\n        return isinstance(other, Variable) and self.name == other.name\n    def __hash__(self):\n        return hash(('var', self.name))\n\nclass Constant(Term):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return self.name\n    def __eq__(self, other):\n        return isinstance(other, Constant) and self.name == other.name\n    def __hash__(self):\n        return hash(('const', self.name))\n\nclass Function(Term):\n    def __init__(self, name, args):\n        self.name = name\n        self.args = tuple(args)\n    def __repr__(self):\n        args_str = ', '.join(str(a) for a in self.args)\n        return f\"{self.name}({args_str})\"\n    def __eq__(self, other):\n        return isinstance(other, Function) and self.name == other.name and self.args == other.args\n    def __hash__(self):\n        return hash(('func', self.name, self.args))\n\nclass Literal:\n    def __init__(self, predicate, args, negated=False):\n        self.predicate = predicate\n        self.args = tuple(args)\n        self.negated = negated\n    \n    def __repr__(self):\n        args_str = ', '.join(str(a) for a in self.args)\n        lit = f\"{self.predicate}({args_str})\"\n        return f\"¬{lit}\" if self.negated else lit\n    \n    def __eq__(self, other):\n        return (self.predicate == other.predicate and \n                self.args == other.args and \n                self.negated == other.negated)\n    \n    def __hash__(self):\n        return hash((self.predicate, self.args, self.negated))\n    \n    def complement(self):\n        return Literal(self.predicate, self.args, not self.negated)\n\nclass FOLClause:\n    def __init__(self, literals):\n        self.literals = frozenset(literals)\n    \n    def __repr__(self):\n        if not self.literals:\n            return \"□\"\n        return \"{\" + \" ∨ \".join(str(l) for l in self.literals) + \"}\"\n    \n    def __eq__(self, other):\n        return self.literals == other.literals\n    \n    def __hash__(self):\n        return hash(self.literals)\n    \n    def is_empty(self):\n        return len(self.literals) == 0\n\nvar_counter = [0]\n\ndef fresh_var():\n    var_counter[0] += 1\n    return Variable(f\"_v{var_counter[0]}\")\n\ndef apply_subst_term(term, subst):\n    if isinstance(term, Variable):\n        if term in subst:\n            return apply_subst_term(subst[term], subst)\n        return term\n    elif isinstance(term, Constant):\n        return term\n    elif isinstance(term, Function):\n        new_args = [apply_subst_term(a, subst) for a in term.args]\n        return Function(term.name, new_args)\n    return term\n\ndef apply_subst_literal(lit, subst):\n    new_args = [apply_subst_term(a, subst) for a in lit.args]\n    return Literal(lit.predicate, new_args, lit.negated)\n\ndef apply_subst_clause(clause, subst):\n    new_lits = [apply_subst_literal(l, subst) for l in clause.literals]\n    return FOLClause(new_lits)\n\ndef occur_check(var, term, subst):\n    if var == term:\n        return True\n    elif isinstance(term, Variable) and term in subst:\n        return occur_check(var, subst[term], subst)\n    elif isinstance(term, Function):\n        return any(occur_check(var, arg, subst) for arg in term.args)\n    return False\n\ndef unify_terms(t1, t2, subst):\n    t1 = apply_subst_term(t1, subst)\n    t2 = apply_subst_term(t2, subst)\n    \n    if t1 == t2:\n        return subst\n    if isinstance(t1, Variable):\n        if occur_check(t1, t2, subst):\n            return None\n        subst = subst.copy()\n        subst[t1] = t2\n        return subst\n    if isinstance(t2, Variable):\n        if occur_check(t2, t1, subst):\n            return None\n        subst = subst.copy()\n        subst[t2] = t1\n        return subst\n    if isinstance(t1, Function) and isinstance(t2, Function):\n        if t1.name != t2.name or len(t1.args) != len(t2.args):\n            return None\n        for a1, a2 in zip(t1.args, t2.args):\n            subst = unify_terms(a1, a2, subst)\n            if subst is None:\n                return None\n        return subst\n    return None\n\ndef unify_literals(lit1, lit2):\n    if lit1.predicate != lit2.predicate:\n        return None\n    if len(lit1.args) != len(lit2.args):\n        return None\n    \n    subst = {}\n    for a1, a2 in zip(lit1.args, lit2.args):\n        subst = unify_terms(a1, a2, subst)\n        if subst is None:\n            return None\n    return subst\n\ndef standardize_apart(clause, used_vars):\n    \"\"\"Rename variables in clause to avoid conflicts.\"\"\"\n    var_map = {}\n    \n    def rename_term(term):\n        if isinstance(term, Variable):\n            if term not in var_map:\n                new_var = fresh_var()\n                while new_var in used_vars:\n                    new_var = fresh_var()\n                var_map[term] = new_var\n                used_vars.add(new_var)\n            return var_map[term]\n        elif isinstance(term, Function):\n            return Function(term.name, [rename_term(a) for a in term.args])\n        return term\n    \n    new_lits = []\n    for lit in clause.literals:\n        new_args = [rename_term(a) for a in lit.args]\n        new_lits.append(Literal(lit.predicate, new_args, lit.negated))\n    \n    return FOLClause(new_lits)\n\ndef resolve_fol(clause1, clause2):\n    \"\"\"Apply resolution with unification.\"\"\"\n    clause2 = standardize_apart(clause2, set())\n    resolvents = []\n    \n    for lit1 in clause1.literals:\n        for lit2 in clause2.literals:\n            if lit1.predicate == lit2.predicate and lit1.negated != lit2.negated:\n                subst = unify_literals(lit1, lit2)\n                if subst is not None:\n                    new_lits = set()\n                    for l in clause1.literals:\n                        if l != lit1:\n                            new_lits.add(apply_subst_literal(l, subst))\n                    for l in clause2.literals:\n                        if l != lit2:\n                            new_lits.add(apply_subst_literal(l, subst))\n                    resolvents.append(FOLClause(new_lits))\n    \n    return resolvents\n\ndef fol_resolution(clauses, max_iter=100):\n    \"\"\"First-order resolution.\"\"\"\n    clauses = set(clauses)\n    \n    for _ in range(max_iter):\n        new_clauses = set()\n        clause_list = list(clauses)\n        \n        for i in range(len(clause_list)):\n            for j in range(i + 1, len(clause_list)):\n                resolvents = resolve_fol(clause_list[i], clause_list[j])\n                for r in resolvents:\n                    if r.is_empty():\n                        return True, r\n                    new_clauses.add(r)\n        \n        if new_clauses.issubset(clauses):\n            return False, None\n        clauses |= new_clauses\n    \n    return False, None\n\n# Test\nprint(\"FOL Resolution Theorem Prover\")\nprint(\"=\"*50)\n\nx, y = Variable('x'), Variable('y')\njohn, mary = Constant('John'), Constant('Mary')\n\n# KB: ∀x.Human(x) → Mortal(x), Human(John)\n# Prove: Mortal(John)\n\nclauses = [\n    FOLClause([Literal('Human', [x], True), Literal('Mortal', [x])]),  # ¬Human(x) ∨ Mortal(x)\n    FOLClause([Literal('Human', [john])]),  # Human(John)\n    FOLClause([Literal('Mortal', [john], True)])  # ¬Mortal(John) (negated query)\n]\n\nprint(\"Clauses:\")\nfor c in clauses:\n    print(f\"  {c}\")\n\nproved, empty = fol_resolution(clauses)\nprint(f\"\\nProved: {proved}\")",
    "testCases": [
      {
        "input": "unify_literals(P(x), P(John))",
        "isHidden": false,
        "description": "Test unification with variable and constant"
      },
      {
        "input": "resolve_fol(clause1, clause2)",
        "isHidden": false,
        "description": "Test FOL resolution"
      },
      {
        "input": "fol_resolution(syllogism_clauses)",
        "isHidden": false,
        "description": "Test complete FOL proof"
      }
    ],
    "hints": [
      "Standardize variables apart before resolution to avoid capture",
      "Only resolve complementary literals (same predicate, opposite sign)",
      "Apply the unifying substitution to both clauses"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex14",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Ontology with OWL-like Semantics",
    "difficulty": 3,
    "description": "Implement an ontology system with OWL-like semantics for knowledge organization.\n\nYour implementation should:\n- Support class hierarchy (subClassOf)\n- Support property definitions with domain and range\n- Support individuals with class assertions and property assertions\n- Implement basic reasoning (type inference, domain/range inference)",
    "starterCode": "class Ontology:\n    def __init__(self):\n        self.classes = {}       # class_name -> parent_classes\n        self.properties = {}    # prop_name -> {domain, range, type}\n        self.individuals = {}   # individual -> {types, properties}\n    \n    def add_class(self, name, parents=None):\n        pass\n    \n    def add_property(self, name, domain=None, range_=None, prop_type='object'):\n        pass\n    \n    def add_individual(self, name, types=None):\n        pass\n    \n    def assert_property(self, subject, prop, obj):\n        pass\n    \n    def infer_types(self, individual):\n        # Infer all types including from property assertions\n        pass\n    \n    def query_instances(self, class_name):\n        # Get all instances of a class\n        pass",
    "solution": "class Ontology:\n    def __init__(self):\n        self.classes = {}       # class_name -> set of parent classes\n        self.properties = {}    # prop_name -> {domain, range, type}\n        self.individuals = {}   # individual -> {types: set, props: dict}\n    \n    def add_class(self, name, parents=None):\n        if parents is None:\n            parents = set()\n        self.classes[name] = set(parents)\n    \n    def add_property(self, name, domain=None, range_=None, prop_type='object'):\n        self.properties[name] = {\n            'domain': domain,\n            'range': range_,\n            'type': prop_type  # 'object' or 'datatype'\n        }\n    \n    def add_individual(self, name, types=None):\n        if types is None:\n            types = set()\n        self.individuals[name] = {\n            'types': set(types),\n            'props': {}  # property -> list of values\n        }\n    \n    def assert_property(self, subject, prop, obj):\n        if subject not in self.individuals:\n            self.add_individual(subject)\n        if prop not in self.individuals[subject]['props']:\n            self.individuals[subject]['props'][prop] = []\n        self.individuals[subject]['props'][prop].append(obj)\n    \n    def get_all_superclasses(self, class_name, visited=None):\n        \"\"\"Get all superclasses (transitive closure).\"\"\"\n        if visited is None:\n            visited = set()\n        if class_name in visited:\n            return set()\n        visited.add(class_name)\n        \n        supers = set()\n        for parent in self.classes.get(class_name, set()):\n            supers.add(parent)\n            supers.update(self.get_all_superclasses(parent, visited))\n        return supers\n    \n    def infer_types(self, individual):\n        \"\"\"Infer all types for an individual.\"\"\"\n        if individual not in self.individuals:\n            return set()\n        \n        ind = self.individuals[individual]\n        types = set(ind['types'])\n        \n        # Add superclasses of asserted types\n        for t in list(types):\n            types.update(self.get_all_superclasses(t))\n        \n        # Infer from property domains\n        for prop in ind['props']:\n            if prop in self.properties:\n                domain = self.properties[prop]['domain']\n                if domain:\n                    types.add(domain)\n                    types.update(self.get_all_superclasses(domain))\n        \n        # Infer from property ranges (for objects)\n        for other_ind, data in self.individuals.items():\n            for prop, values in data['props'].items():\n                if individual in values:\n                    if prop in self.properties:\n                        range_ = self.properties[prop]['range']\n                        if range_:\n                            types.add(range_)\n                            types.update(self.get_all_superclasses(range_))\n        \n        return types\n    \n    def query_instances(self, class_name):\n        \"\"\"Get all instances of a class (including subclass instances).\"\"\"\n        instances = []\n        for ind in self.individuals:\n            types = self.infer_types(ind)\n            if class_name in types:\n                instances.append(ind)\n        return instances\n    \n    def get_property_values(self, individual, prop):\n        \"\"\"Get values of a property for an individual.\"\"\"\n        if individual not in self.individuals:\n            return []\n        return self.individuals[individual]['props'].get(prop, [])\n    \n    def describe(self, individual):\n        \"\"\"Describe an individual with all inferred information.\"\"\"\n        if individual not in self.individuals:\n            return None\n        \n        return {\n            'individual': individual,\n            'types': self.infer_types(individual),\n            'properties': self.individuals[individual]['props']\n        }\n\n# Test\nprint(\"Ontology with OWL-like Semantics\")\nprint(\"=\"*50)\n\nonto = Ontology()\n\n# Class hierarchy\nonto.add_class('Thing')\nonto.add_class('Agent', {'Thing'})\nonto.add_class('Person', {'Agent'})\nonto.add_class('Organization', {'Agent'})\nonto.add_class('University', {'Organization'})\n\n# Properties\nonto.add_property('worksAt', domain='Person', range_='Organization')\nonto.add_property('hasName', domain='Thing', prop_type='datatype')\nonto.add_property('employs', domain='Organization', range_='Person')\n\nprint(\"Class Hierarchy:\")\nfor cls, parents in onto.classes.items():\n    print(f\"  {cls} subClassOf {parents if parents else 'Thing'}\")\n\nprint(\"\\nProperties:\")\nfor prop, info in onto.properties.items():\n    print(f\"  {prop}: domain={info['domain']}, range={info['range']}\")\n\n# Individuals\nonto.add_individual('John', {'Person'})\nonto.add_individual('MIT', {'University'})\nonto.assert_property('John', 'worksAt', 'MIT')\nonto.assert_property('John', 'hasName', 'John Smith')\nonto.assert_property('MIT', 'hasName', 'Massachusetts Institute of Technology')\n\nprint(\"\\nIndividuals:\")\nprint(f\"  John: {onto.describe('John')}\")\nprint(f\"  MIT: {onto.describe('MIT')}\")\n\nprint(\"\\nInferred types for John:\")\nprint(f\"  {onto.infer_types('John')}\")\n\nprint(\"\\nInstances of Agent:\")\nprint(f\"  {onto.query_instances('Agent')}\")\n\nprint(\"\\nInstances of Organization:\")\nprint(f\"  {onto.query_instances('Organization')}\")",
    "testCases": [
      {
        "input": "onto.infer_types('individual')",
        "isHidden": false,
        "description": "Test type inference"
      },
      {
        "input": "onto.query_instances('superclass')",
        "isHidden": false,
        "description": "Test querying instances"
      },
      {
        "input": "domain/range inference",
        "isHidden": false,
        "description": "Test domain/range type inference"
      }
    ],
    "hints": [
      "Subclass relationships are transitive",
      "Domain means: if x has property P, then x is of type Domain(P)",
      "Range means: if x P y, then y is of type Range(P)"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex15",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Frame-Based Knowledge System",
    "difficulty": 2,
    "description": "Implement a frame-based knowledge representation system.\n\nYour implementation should:\n- Support frames with slots and facets\n- Implement slot inheritance from parent frames\n- Support default values and value restrictions\n- Implement demons (procedural attachments) for slot access",
    "starterCode": "class Frame:\n    def __init__(self, name, parents=None):\n        self.name = name\n        self.parents = parents or []\n        self.slots = {}  # slot_name -> facets\n\nclass FrameSystem:\n    def __init__(self):\n        self.frames = {}\n    \n    def create_frame(self, name, parents=None):\n        pass\n    \n    def add_slot(self, frame_name, slot_name, value=None, default=None, \n                 value_type=None, if_needed=None, if_added=None):\n        # Add slot with facets\n        pass\n    \n    def get_slot(self, frame_name, slot_name):\n        # Get slot value with inheritance\n        pass\n    \n    def set_slot(self, frame_name, slot_name, value):\n        # Set slot value, triggering demons\n        pass",
    "solution": "class Frame:\n    def __init__(self, name, parents=None):\n        self.name = name\n        self.parents = parents or []\n        self.slots = {}\n    \n    def __repr__(self):\n        return f\"Frame({self.name})\"\n\nclass FrameSystem:\n    def __init__(self):\n        self.frames = {}\n    \n    def create_frame(self, name, parents=None):\n        frame = Frame(name, parents or [])\n        self.frames[name] = frame\n        return frame\n    \n    def add_slot(self, frame_name, slot_name, value=None, default=None,\n                 value_type=None, if_needed=None, if_added=None):\n        \"\"\"Add slot with facets.\n        \n        Facets:\n        - value: actual value\n        - default: default value if no value set\n        - value_type: type constraint\n        - if_needed: demon called when slot is read (no value)\n        - if_added: demon called when slot is written\n        \"\"\"\n        if frame_name not in self.frames:\n            raise ValueError(f\"Frame {frame_name} not found\")\n        \n        self.frames[frame_name].slots[slot_name] = {\n            'value': value,\n            'default': default,\n            'value_type': value_type,\n            'if_needed': if_needed,\n            'if_added': if_added\n        }\n    \n    def get_inherited_slots(self, frame_name, visited=None):\n        \"\"\"Get all slots including inherited ones.\"\"\"\n        if visited is None:\n            visited = set()\n        if frame_name in visited:\n            return {}\n        visited.add(frame_name)\n        \n        if frame_name not in self.frames:\n            return {}\n        \n        frame = self.frames[frame_name]\n        slots = {}\n        \n        # Get parent slots first (can be overridden)\n        for parent in frame.parents:\n            parent_slots = self.get_inherited_slots(parent, visited)\n            slots.update(parent_slots)\n        \n        # Local slots override\n        slots.update(frame.slots)\n        \n        return slots\n    \n    def get_slot(self, frame_name, slot_name):\n        \"\"\"Get slot value with inheritance and demons.\"\"\"\n        slots = self.get_inherited_slots(frame_name)\n        \n        if slot_name not in slots:\n            return None\n        \n        slot = slots[slot_name]\n        \n        # Return actual value if set\n        if slot['value'] is not None:\n            return slot['value']\n        \n        # Try if_needed demon\n        if slot['if_needed'] is not None:\n            return slot['if_needed'](self, frame_name, slot_name)\n        \n        # Return default\n        return slot['default']\n    \n    def set_slot(self, frame_name, slot_name, value):\n        \"\"\"Set slot value, triggering demons.\"\"\"\n        if frame_name not in self.frames:\n            raise ValueError(f\"Frame {frame_name} not found\")\n        \n        frame = self.frames[frame_name]\n        \n        # Create slot if doesn't exist locally\n        if slot_name not in frame.slots:\n            frame.slots[slot_name] = {\n                'value': None, 'default': None,\n                'value_type': None, 'if_needed': None, 'if_added': None\n            }\n        \n        slot = frame.slots[slot_name]\n        \n        # Check type constraint\n        if slot['value_type'] is not None:\n            if not isinstance(value, slot['value_type']):\n                raise TypeError(f\"Value must be {slot['value_type']}\")\n        \n        old_value = slot['value']\n        slot['value'] = value\n        \n        # Trigger if_added demon\n        if slot['if_added'] is not None:\n            slot['if_added'](self, frame_name, slot_name, old_value, value)\n    \n    def describe_frame(self, frame_name):\n        \"\"\"Get complete description of frame.\"\"\"\n        if frame_name not in self.frames:\n            return None\n        \n        frame = self.frames[frame_name]\n        slots = self.get_inherited_slots(frame_name)\n        \n        desc = {\n            'name': frame_name,\n            'parents': frame.parents,\n            'slots': {}\n        }\n        \n        for slot_name in slots:\n            desc['slots'][slot_name] = self.get_slot(frame_name, slot_name)\n        \n        return desc\n\n# Test\nprint(\"Frame-Based Knowledge System\")\nprint(\"=\"*50)\n\nfs = FrameSystem()\n\n# Create frame hierarchy\nfs.create_frame('Vehicle')\nfs.add_slot('Vehicle', 'wheels', default=4)\nfs.add_slot('Vehicle', 'engine', default='internal_combustion')\n\nfs.create_frame('Car', parents=['Vehicle'])\nfs.add_slot('Car', 'doors', default=4)\nfs.add_slot('Car', 'passengers', default=5)\n\nfs.create_frame('SportsCar', parents=['Car'])\nfs.add_slot('SportsCar', 'doors', default=2)\nfs.add_slot('SportsCar', 'passengers', default=2)\nfs.add_slot('SportsCar', 'top_speed', default=200)\n\n# Instance with demons\nfs.create_frame('MyCar', parents=['SportsCar'])\n\n# If-needed demon for age\ndef compute_age(fs, frame, slot):\n    year = fs.get_slot(frame, 'year')\n    if year:\n        return 2024 - year\n    return None\n\nfs.add_slot('MyCar', 'year', value=2020)\nfs.add_slot('MyCar', 'age', if_needed=compute_age)\nfs.add_slot('MyCar', 'color', value='red')\n\n# If-added demon for logging\ndef log_change(fs, frame, slot, old, new):\n    print(f\"  [Demon] {frame}.{slot}: {old} -> {new}\")\n\nfs.add_slot('MyCar', 'mileage', value=0, if_added=log_change)\n\nprint(\"\\nFrame Descriptions:\")\nprint(f\"\\nVehicle: {fs.describe_frame('Vehicle')}\")\nprint(f\"\\nCar: {fs.describe_frame('Car')}\")\nprint(f\"\\nSportsCar: {fs.describe_frame('SportsCar')}\")\nprint(f\"\\nMyCar: {fs.describe_frame('MyCar')}\")\n\nprint(\"\\nDemon demonstration:\")\nprint(f\"  MyCar.age (computed): {fs.get_slot('MyCar', 'age')}\")\n\nprint(\"\\nUpdating mileage (triggers if_added demon):\")\nfs.set_slot('MyCar', 'mileage', 1000)\nfs.set_slot('MyCar', 'mileage', 5000)",
    "testCases": [
      {
        "input": "fs.get_slot('MyCar', 'wheels')",
        "isHidden": false,
        "description": "Test slot inheritance"
      },
      {
        "input": "fs.get_slot('MyCar', 'age')",
        "isHidden": false,
        "description": "Test if-needed demon"
      },
      {
        "input": "fs.set_slot('frame', 'slot', value)",
        "isHidden": false,
        "description": "Test if-added demon"
      }
    ],
    "hints": [
      "Collect inherited slots from parents first, then override with local",
      "Demons are procedural attachments triggered on slot access",
      "if-needed computes value on read, if-added triggers on write"
    ],
    "language": "python"
  },
  {
    "id": "cs406-t6-ex16",
    "subjectId": "cs406",
    "topicId": "cs406-topic-6",
    "title": "Fuzzy Logic Inference",
    "difficulty": 3,
    "description": "Implement a fuzzy logic inference system with fuzzy sets and rules.\n\nYour implementation should:\n- Define fuzzy sets with membership functions\n- Support fuzzy AND, OR, and NOT operations\n- Implement Mamdani-style fuzzy inference\n- Perform defuzzification using centroid method",
    "starterCode": "class FuzzySet:\n    def __init__(self, name, membership_func):\n        self.name = name\n        self.membership = membership_func  # x -> degree [0,1]\n\nclass FuzzyVariable:\n    def __init__(self, name, min_val, max_val):\n        self.name = name\n        self.range = (min_val, max_val)\n        self.sets = {}  # name -> FuzzySet\n\nclass FuzzyRule:\n    def __init__(self, antecedent, consequent):\n        # antecedent: list of (variable, set_name)\n        # consequent: (variable, set_name)\n        pass\n\nclass FuzzySystem:\n    def __init__(self):\n        self.variables = {}\n        self.rules = []\n    \n    def fuzzify(self, variable, value):\n        # Get membership degrees for value\n        pass\n    \n    def infer(self, inputs):\n        # Apply fuzzy inference\n        pass\n    \n    def defuzzify(self, fuzzy_output):\n        # Centroid defuzzification\n        pass",
    "solution": "import numpy as np\n\nclass FuzzySet:\n    def __init__(self, name, membership_func):\n        self.name = name\n        self.membership = membership_func\n    \n    def __repr__(self):\n        return f\"FuzzySet({self.name})\"\n\ndef triangular(a, b, c):\n    \"\"\"Triangular membership function.\"\"\"\n    def membership(x):\n        if x <= a or x >= c:\n            return 0.0\n        elif a < x <= b:\n            return (x - a) / (b - a)\n        else:  # b < x < c\n            return (c - x) / (c - b)\n    return membership\n\ndef trapezoidal(a, b, c, d):\n    \"\"\"Trapezoidal membership function.\"\"\"\n    def membership(x):\n        if x <= a or x >= d:\n            return 0.0\n        elif a < x < b:\n            return (x - a) / (b - a)\n        elif b <= x <= c:\n            return 1.0\n        else:  # c < x < d\n            return (d - x) / (d - c)\n    return membership\n\nclass FuzzyVariable:\n    def __init__(self, name, min_val, max_val):\n        self.name = name\n        self.range = (min_val, max_val)\n        self.sets = {}\n    \n    def add_set(self, fuzzy_set):\n        self.sets[fuzzy_set.name] = fuzzy_set\n    \n    def fuzzify(self, value):\n        \"\"\"Get membership degrees for a crisp value.\"\"\"\n        return {name: fs.membership(value) \n                for name, fs in self.sets.items()}\n\nclass FuzzyRule:\n    def __init__(self, antecedent, consequent):\n        self.antecedent = antecedent  # [(var_name, set_name), ...]\n        self.consequent = consequent  # (var_name, set_name)\n    \n    def __repr__(self):\n        ant = ' AND '.join(f\"{v} IS {s}\" for v, s in self.antecedent)\n        con = f\"{self.consequent[0]} IS {self.consequent[1]}\"\n        return f\"IF {ant} THEN {con}\"\n\nclass FuzzySystem:\n    def __init__(self):\n        self.variables = {}\n        self.rules = []\n    \n    def add_variable(self, variable):\n        self.variables[variable.name] = variable\n    \n    def add_rule(self, rule):\n        self.rules.append(rule)\n    \n    def infer(self, inputs):\n        \"\"\"Mamdani fuzzy inference.\n        inputs: dict of variable_name -> crisp_value\n        \"\"\"\n        # Fuzzify inputs\n        fuzzified = {}\n        for var_name, value in inputs.items():\n            fuzzified[var_name] = self.variables[var_name].fuzzify(value)\n        \n        # Evaluate rules\n        output_activations = {}  # (var, set) -> activation level\n        \n        for rule in self.rules:\n            # Compute antecedent strength (AND = min)\n            strengths = []\n            for var_name, set_name in rule.antecedent:\n                strength = fuzzified[var_name][set_name]\n                strengths.append(strength)\n            rule_strength = min(strengths)  # AND operation\n            \n            # Activate consequent\n            key = rule.consequent\n            if key not in output_activations:\n                output_activations[key] = 0\n            output_activations[key] = max(output_activations[key], rule_strength)  # OR\n        \n        return output_activations\n    \n    def defuzzify(self, output_activations, output_var_name, resolution=100):\n        \"\"\"Centroid defuzzification.\"\"\"\n        var = self.variables[output_var_name]\n        min_val, max_val = var.range\n        \n        x_values = np.linspace(min_val, max_val, resolution)\n        aggregated = np.zeros(resolution)\n        \n        # Aggregate output fuzzy sets (clipped by activation)\n        for (var_name, set_name), activation in output_activations.items():\n            if var_name == output_var_name:\n                fuzzy_set = var.sets[set_name]\n                for i, x in enumerate(x_values):\n                    membership = min(fuzzy_set.membership(x), activation)\n                    aggregated[i] = max(aggregated[i], membership)\n        \n        # Centroid calculation\n        if np.sum(aggregated) == 0:\n            return (min_val + max_val) / 2  # Default to center\n        \n        centroid = np.sum(x_values * aggregated) / np.sum(aggregated)\n        return centroid\n\n# Test: Temperature Control System\nprint(\"Fuzzy Logic Inference System\")\nprint(\"=\"*50)\nprint(\"\\nExample: Temperature Control\")\n\n# Input: Temperature\ntemp = FuzzyVariable('temperature', 0, 40)\ntemp.add_set(FuzzySet('cold', trapezoidal(0, 0, 10, 15)))\ntemp.add_set(FuzzySet('comfortable', triangular(12, 20, 28)))\ntemp.add_set(FuzzySet('hot', trapezoidal(25, 30, 40, 40)))\n\n# Output: Fan Speed\nfan = FuzzyVariable('fan_speed', 0, 100)\nfan.add_set(FuzzySet('low', trapezoidal(0, 0, 20, 40)))\nfan.add_set(FuzzySet('medium', triangular(30, 50, 70)))\nfan.add_set(FuzzySet('high', trapezoidal(60, 80, 100, 100)))\n\n# Create system\nfs = FuzzySystem()\nfs.add_variable(temp)\nfs.add_variable(fan)\n\n# Rules\nfs.add_rule(FuzzyRule([('temperature', 'cold')], ('fan_speed', 'low')))\nfs.add_rule(FuzzyRule([('temperature', 'comfortable')], ('fan_speed', 'medium')))\nfs.add_rule(FuzzyRule([('temperature', 'hot')], ('fan_speed', 'high')))\n\nprint(\"\\nRules:\")\nfor rule in fs.rules:\n    print(f\"  {rule}\")\n\n# Test with different temperatures\nprint(\"\\nInference Results:\")\nfor test_temp in [8, 15, 20, 27, 35]:\n    activations = fs.infer({'temperature': test_temp})\n    output = fs.defuzzify(activations, 'fan_speed')\n    fuzz = temp.fuzzify(test_temp)\n    print(f\"  Temp={test_temp}°C -> Memberships: {fuzz}\")\n    print(f\"              -> Fan Speed: {output:.1f}%\")",
    "testCases": [
      {
        "input": "temp.fuzzify(20)",
        "isHidden": false,
        "description": "Test fuzzification"
      },
      {
        "input": "fs.infer({'temperature': 30})",
        "isHidden": false,
        "description": "Test fuzzy inference"
      },
      {
        "input": "fs.defuzzify(activations, 'fan_speed')",
        "isHidden": false,
        "description": "Test centroid defuzzification"
      }
    ],
    "hints": [
      "Triangular/trapezoidal functions are common membership functions",
      "AND = min, OR = max for fuzzy operations",
      "Centroid = sum(x * membership) / sum(membership)"
    ],
    "language": "python"
  }
]

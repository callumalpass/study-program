[
  {"id": "cs406-t5-ex01", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "STRIPS Planning Representation", "difficulty": 2, "description": "Implement a STRIPS-style planning problem representation.\n\nDefine states as sets of propositions and actions with preconditions and effects.", "starterCode": "class Action:\n    def __init__(self, name, preconditions, add_effects, delete_effects):\n        pass\n\n    def is_applicable(self, state):\n        pass\n\n    def apply(self, state):\n        pass", "solution": "class Action:\n    def __init__(self, name, preconditions, add_effects, delete_effects):\n        self.name = name\n        self.preconditions = set(preconditions)\n        self.add_effects = set(add_effects)\n        self.delete_effects = set(delete_effects)\n\n    def is_applicable(self, state):\n        return self.preconditions.issubset(state)\n\n    def apply(self, state):\n        if not self.is_applicable(state): return None\n        new_state = state.copy()\n        new_state -= self.delete_effects\n        new_state |= self.add_effects\n        return new_state\n\nclass PlanningProblem:\n    def __init__(self, initial_state, goal, actions):\n        self.initial_state = initial_state\n        self.goal = goal\n        self.actions = actions\n\n    def is_goal(self, state):\n        return self.goal.issubset(state)", "testCases": [{"input": "action.is_applicable(state)", "isHidden": false, "description": "Test action applicability"}, {"input": "action.apply(state)", "isHidden": false, "description": "Test action application"}, {"input": "problem.is_goal(state)", "isHidden": true, "description": "Test goal checking"}], "hints": ["States are sets of propositions", "Action is applicable if preconditions subset of state", "Apply: remove delete effects, add add effects"], "language": "python"},
  {"id": "cs406-t5-ex02", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Forward State-Space Search", "difficulty": 3, "description": "Implement forward search from initial state to goal using A*.", "starterCode": "def h_goal_count(state, goal):\n    pass\n\ndef forward_search(problem):\n    pass", "solution": "import heapq\n\ndef h_goal_count(state, goal):\n    return len(goal - state)\n\ndef forward_search(problem, heuristic=h_goal_count):\n    initial = problem.initial_state\n    frontier = [(heuristic(initial, problem.goal), 0, initial, [])]\n    explored = set()\n    \n    while frontier:\n        f, g, state, plan = heapq.heappop(frontier)\n        state_key = frozenset(state)\n        if state_key in explored: continue\n        explored.add(state_key)\n        \n        if problem.is_goal(state): return plan\n        \n        for action in problem.actions:\n            if action.is_applicable(state):\n                new_state = action.apply(state)\n                if frozenset(new_state) not in explored:\n                    new_g = g + 1\n                    new_f = new_g + heuristic(new_state, problem.goal)\n                    heapq.heappush(frontier, (new_f, new_g, new_state, plan + [action]))\n    return None", "testCases": [{"input": "forward_search(problem)", "isHidden": false, "description": "Test forward search finds plan"}, {"input": "h_goal_count(state, goal)", "isHidden": false, "description": "Test heuristic"}, {"input": "plan achieves goal", "isHidden": true, "description": "Test plan validity"}], "hints": ["Use A* with goal count heuristic", "States are sets, use frozenset for hashing", "Return sequence of actions"], "language": "python"},
  {"id": "cs406-t5-ex03", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "GraphPlan Algorithm", "difficulty": 4, "description": "Implement a simplified GraphPlan algorithm.\n\nBuild planning graph with alternating proposition/action layers.", "starterCode": "class PlanningGraph:\n    def __init__(self, problem):\n        pass\n\n    def expand(self):\n        pass\n\ndef graphplan(problem):\n    pass", "solution": "class PlanningGraph:\n    def __init__(self, problem):\n        self.problem = problem\n        self.prop_layers = [problem.initial_state.copy()]\n        self.action_layers = []\n\n    def expand(self):\n        prev_props = self.prop_layers[-1]\n        applicable = [a for a in self.problem.actions if a.is_applicable(prev_props)]\n        # Add no-ops\n        for prop in prev_props:\n            noop = Action(f'noop({prop})', [prop], [prop], [])\n            applicable.append(noop)\n        self.action_layers.append(applicable)\n        new_props = set()\n        for action in applicable:\n            new_props |= action.add_effects\n        self.prop_layers.append(new_props)\n\n    def all_goals_reachable(self):\n        return self.problem.goal.issubset(self.prop_layers[-1])\n\ndef graphplan(problem, max_levels=10):\n    graph = PlanningGraph(problem)\n    for level in range(max_levels):\n        if graph.all_goals_reachable():\n            # Simplified: use forward search instead of full extraction\n            return forward_search(problem)\n        graph.expand()\n        if graph.prop_layers[-1] == graph.prop_layers[-2]:\n            return None\n    return None", "testCases": [{"input": "graphplan(problem)", "isHidden": false, "description": "Test GraphPlan finds plan"}, {"input": "graph.expand()", "isHidden": false, "description": "Test graph expansion"}, {"input": "graph.all_goals_reachable()", "isHidden": true, "description": "Test goal reachability"}], "hints": ["Alternate proposition and action layers", "Include no-op actions for persistence", "Fixed point when layers stop growing"], "language": "python"},
  {"id": "cs406-t5-ex04", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Action Count Calculation", "difficulty": 1, "description": "Calculate the number of ground actions in a planning domain.\n\nGiven action schemas and objects, compute the number of possible instantiations.", "starterCode": "def count_ground_actions(action_schemas, objects):\n    pass\n\ndef ground_action(schema, binding):\n    pass", "solution": "from itertools import product\n\ndef count_ground_actions(action_schemas, objects_by_type):\n    total = 0\n    for schema in action_schemas:\n        param_types = schema['parameters']  # [(name, type), ...]\n        combos = 1\n        for param_name, param_type in param_types:\n            combos *= len(objects_by_type.get(param_type, []))\n        total += combos\n    return total\n\ndef ground_action(schema, binding):\n    name = schema['name'] + '(' + ','.join(binding.values()) + ')'\n    def substitute(props):\n        return {p.format(**binding) for p in props}\n    return Action(\n        name,\n        substitute(schema['preconditions']),\n        substitute(schema['add_effects']),\n        substitute(schema['delete_effects'])\n    )\n\n# Example: Blocks World\nschemas = [\n    {'name': 'pickup', 'parameters': [('x', 'block')], 'preconditions': ['on({x},table)', 'clear({x})'], 'add_effects': ['holding({x})'], 'delete_effects': ['on({x},table)']},\n    {'name': 'stack', 'parameters': [('x', 'block'), ('y', 'block')], 'preconditions': ['holding({x})', 'clear({y})'], 'add_effects': ['on({x},{y})'], 'delete_effects': ['holding({x})', 'clear({y})']},\n]\nobjects = {'block': ['A', 'B', 'C']}\nprint(f\"Ground actions: {count_ground_actions(schemas, objects)}\")", "testCases": [{"input": "count_ground_actions(schemas, objects)", "isHidden": false, "description": "Test action counting"}, {"input": "ground_action(schema, binding)", "isHidden": false, "description": "Test grounding"}, {"input": "large domain", "isHidden": true, "description": "Test with many objects"}], "hints": ["Multiply domain sizes for each parameter", "Account for type restrictions", "Grounding substitutes variables with constants"], "language": "python"},
  {"id": "cs406-t5-ex05", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Backward Search (Regression)", "difficulty": 3, "description": "Implement backward search from goal to initial state.\n\nUse regression to find relevant actions.", "starterCode": "def regress(goal, action):\n    pass\n\ndef backward_search(problem):\n    pass", "solution": "import heapq\n\ndef regress(goal, action):\n    \"\"\"Regress goal through action: what must be true before action.\"\"\"\n    if not action.add_effects & goal:\n        return None  # Action not relevant\n    if action.delete_effects & goal:\n        return None  # Action deletes needed proposition\n    regressed = (goal - action.add_effects) | action.preconditions\n    return regressed\n\ndef backward_search(problem):\n    goal = problem.goal\n    frontier = [(len(goal - problem.initial_state), goal, [])]\n    explored = set()\n    \n    while frontier:\n        _, subgoal, plan = heapq.heappop(frontier)\n        subgoal_key = frozenset(subgoal)\n        if subgoal_key in explored: continue\n        explored.add(subgoal_key)\n        \n        if subgoal.issubset(problem.initial_state):\n            return list(reversed(plan))\n        \n        for action in problem.actions:\n            regressed = regress(subgoal, action)\n            if regressed and frozenset(regressed) not in explored:\n                h = len(regressed - problem.initial_state)\n                heapq.heappush(frontier, (h, regressed, plan + [action]))\n    return None", "testCases": [{"input": "backward_search(problem)", "isHidden": false, "description": "Test backward search"}, {"input": "regress(goal, action)", "isHidden": false, "description": "Test regression"}, {"input": "plan is reversed", "isHidden": true, "description": "Test plan ordering"}], "hints": ["Regression: what must be true before action to achieve subgoal after", "Action relevant if it adds something in goal", "Reverse plan at end"], "language": "python"},
  {"id": "cs406-t5-ex06", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Delete Relaxation Heuristic", "difficulty": 3, "description": "Implement the delete relaxation heuristic for planning.\n\nIgnore delete effects to get admissible estimate.", "starterCode": "def relaxed_plan_length(state, goal, actions):\n    pass\n\ndef h_add(state, goal, actions):\n    pass", "solution": "def relaxed_plan_length(state, goal, actions):\n    \"\"\"Estimate plan length ignoring delete effects.\"\"\"\n    current = state.copy()\n    plan_length = 0\n    \n    while not goal.issubset(current):\n        best_action = None\n        best_gain = 0\n        \n        for action in actions:\n            if action.is_applicable(current):\n                gain = len(action.add_effects - current)\n                if gain > best_gain:\n                    best_gain = gain\n                    best_action = action\n        \n        if best_action is None or best_gain == 0:\n            return float('inf')  # Unsolvable\n        \n        current |= best_action.add_effects  # No deletes!\n        plan_length += 1\n    \n    return plan_length\n\ndef h_add(state, goal, actions):\n    \"\"\"Additive heuristic: sum of costs to achieve each goal.\"\"\"\n    costs = {p: 0 if p in state else float('inf') for p in goal | state}\n    \n    changed = True\n    while changed:\n        changed = False\n        for action in actions:\n            if all(costs.get(p, float('inf')) < float('inf') for p in action.preconditions):\n                pre_cost = sum(costs.get(p, 0) for p in action.preconditions)\n                action_cost = pre_cost + 1\n                for eff in action.add_effects:\n                    if eff not in costs or action_cost < costs[eff]:\n                        costs[eff] = action_cost\n                        changed = True\n    \n    return sum(costs.get(g, float('inf')) for g in goal)", "testCases": [{"input": "relaxed_plan_length(state, goal, actions)", "isHidden": false, "description": "Test relaxed planning"}, {"input": "h_add(state, goal, actions)", "isHidden": false, "description": "Test additive heuristic"}, {"input": "heuristic is admissible", "isHidden": true, "description": "Test admissibility"}], "hints": ["Ignoring deletes makes problem easier", "Relaxed plan length is admissible", "h_add sums individual goal costs"], "language": "python"},
  {"id": "cs406-t5-ex07", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Landmark Extraction", "difficulty": 4, "description": "Extract landmarks that must be achieved in any valid plan.\n\nA landmark is a fact that must be true at some point.", "starterCode": "def extract_landmarks(problem):\n    pass\n\ndef order_landmarks(landmarks, problem):\n    pass", "solution": "def extract_landmarks(problem):\n    \"\"\"Extract facts that must be true at some point in any plan.\"\"\"\n    landmarks = set(problem.goal)  # Goals are trivially landmarks\n    \n    changed = True\n    while changed:\n        changed = False\n        for landmark in list(landmarks):\n            # Find actions that achieve this landmark\n            achievers = [a for a in problem.actions if landmark in a.add_effects]\n            if not achievers: continue\n            \n            # Common preconditions across all achievers are landmarks\n            common_precs = set(achievers[0].preconditions)\n            for a in achievers[1:]:\n                common_precs &= a.preconditions\n            \n            for prec in common_precs:\n                if prec not in landmarks and prec not in problem.initial_state:\n                    landmarks.add(prec)\n                    changed = True\n    \n    return landmarks\n\ndef order_landmarks(landmarks, problem):\n    \"\"\"Compute ordering constraints between landmarks.\"\"\"\n    orderings = []  # (before, after) pairs\n    \n    for lm1 in landmarks:\n        for lm2 in landmarks:\n            if lm1 == lm2: continue\n            # lm1 must come before lm2 if all achievers of lm2 require lm1\n            achievers = [a for a in problem.actions if lm2 in a.add_effects]\n            if all(lm1 in a.preconditions for a in achievers):\n                orderings.append((lm1, lm2))\n    \n    return orderings", "testCases": [{"input": "extract_landmarks(problem)", "isHidden": false, "description": "Test landmark extraction"}, {"input": "order_landmarks(landmarks, problem)", "isHidden": false, "description": "Test ordering"}, {"input": "landmarks are necessary", "isHidden": true, "description": "Test correctness"}], "hints": ["Goals are landmarks", "Common preconditions of all achievers are landmarks", "Orderings from necessary preconditions"], "language": "python"},
  {"id": "cs406-t5-ex08", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Partial Order Planning", "difficulty": 4, "description": "Implement basic partial order planning (POP).\n\nMaintain a partial plan with ordering constraints.", "starterCode": "class PartialPlan:\n    def __init__(self):\n        self.steps = []\n        self.orderings = []\n        self.causal_links = []\n        self.open_conditions = []\n\ndef pop_search(problem):\n    pass", "solution": "class PartialPlan:\n    def __init__(self):\n        self.steps = ['init', 'goal']  # Special start/end steps\n        self.orderings = [('init', 'goal')]  # (before, after) constraints\n        self.causal_links = []  # (provider, condition, consumer)\n        self.open_conditions = []  # (step, condition)\n    \n    def add_step(self, action):\n        self.steps.append(action)\n        self.orderings.append(('init', action.name))\n        self.orderings.append((action.name, 'goal'))\n    \n    def is_threat(self, link, step):\n        provider, cond, consumer = link\n        if step == provider or step == consumer: return False\n        # Check if step deletes condition and is ordered between provider and consumer\n        if hasattr(step, 'delete_effects') and cond in step.delete_effects:\n            return self.possibly_between(step.name, provider, consumer)\n        return False\n    \n    def possibly_between(self, step, before, after):\n        # Simplified: check if no ordering prevents it\n        return not (self.ordered(step, before) or self.ordered(after, step))\n    \n    def ordered(self, a, b):\n        return (a, b) in self.orderings\n\ndef pop_search(problem):\n    initial_plan = PartialPlan()\n    # Add goal conditions as open\n    for g in problem.goal:\n        initial_plan.open_conditions.append(('goal', g))\n    \n    frontier = [initial_plan]\n    \n    while frontier:\n        plan = frontier.pop(0)\n        \n        if not plan.open_conditions:\n            return linearize(plan)\n        \n        step, condition = plan.open_conditions[0]\n        \n        # Find actions that achieve condition\n        for action in problem.actions:\n            if condition in action.add_effects:\n                new_plan = copy_plan(plan)\n                new_plan.open_conditions.remove((step, condition))\n                new_plan.add_step(action)\n                new_plan.causal_links.append((action.name, condition, step))\n                new_plan.orderings.append((action.name, step))\n                \n                # Add new open conditions\n                for prec in action.preconditions:\n                    new_plan.open_conditions.append((action.name, prec))\n                \n                frontier.append(new_plan)\n    \n    return None\n\ndef linearize(plan):\n    # Topological sort of steps\n    return plan.steps[1:-1]  # Simplified\n\ndef copy_plan(plan):\n    import copy\n    return copy.deepcopy(plan)", "testCases": [{"input": "pop_search(problem)", "isHidden": false, "description": "Test POP search"}, {"input": "plan.add_step(action)", "isHidden": false, "description": "Test step addition"}, {"input": "causal links protected", "isHidden": true, "description": "Test threat resolution"}], "hints": ["Maintain partial ordering, not total order", "Causal links protect achieved conditions", "Threats must be resolved by ordering"], "language": "python"},
  {"id": "cs406-t5-ex09", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "HTN Planning Basics", "difficulty": 3, "description": "Implement basic Hierarchical Task Network decomposition.\n\nDecompose abstract tasks into primitive actions.", "starterCode": "class Task:\n    def __init__(self, name, primitive=True):\n        pass\n\ndef htn_plan(initial_tasks, methods, actions, state):\n    pass", "solution": "class Task:\n    def __init__(self, name, primitive=True):\n        self.name = name\n        self.primitive = primitive\n\ndef htn_plan(initial_tasks, methods, actions, state):\n    \"\"\"HTN planning with task decomposition.\"\"\"\n    \n    def plan_tasks(tasks, current_state):\n        if not tasks:\n            return []\n        \n        task = tasks[0]\n        remaining = tasks[1:]\n        \n        if task.primitive:\n            # Find matching action\n            for action in actions:\n                if action.name == task.name and action.is_applicable(current_state):\n                    new_state = action.apply(current_state)\n                    rest_plan = plan_tasks(remaining, new_state)\n                    if rest_plan is not None:\n                        return [action] + rest_plan\n            return None\n        else:\n            # Decompose using methods\n            for method in methods:\n                if method['task'] == task.name:\n                    if method['precondition'](current_state):\n                        subtasks = [Task(t, t in [a.name for a in actions]) for t in method['subtasks']]\n                        result = plan_tasks(subtasks + remaining, current_state)\n                        if result is not None:\n                            return result\n            return None\n    \n    return plan_tasks(initial_tasks, state)\n\n# Example: Travel domain\nactions = [Action('drive', ['at(car,{x})'], ['at(car,{y})'], ['at(car,{x})']),\n           Action('walk', ['at(person,{x})'], ['at(person,{y})'], ['at(person,{x})'])]\n\nmethods = [\n    {'task': 'travel', 'precondition': lambda s: 'has_car' in s, 'subtasks': ['drive']},\n    {'task': 'travel', 'precondition': lambda s: True, 'subtasks': ['walk']},\n]", "testCases": [{"input": "htn_plan(tasks, methods, actions, state)", "isHidden": false, "description": "Test HTN planning"}, {"input": "method selection", "isHidden": false, "description": "Test method choice"}, {"input": "deep decomposition", "isHidden": true, "description": "Test nested tasks"}], "hints": ["Primitive tasks map to actions", "Non-primitive tasks decompose via methods", "Try methods in order, backtrack on failure"], "language": "python"},
  {"id": "cs406-t5-ex10", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Mutex Detection", "difficulty": 3, "description": "Detect mutex (mutually exclusive) propositions and actions in planning graph.", "starterCode": "def are_mutex_props(p1, p2, actions):\n    pass\n\ndef are_mutex_actions(a1, a2):\n    pass", "solution": "def are_mutex_actions(a1, a2):\n    \"\"\"Check if two actions are mutex.\"\"\"\n    # Inconsistent effects: one deletes what other adds\n    if a1.delete_effects & a2.add_effects:\n        return True\n    if a2.delete_effects & a1.add_effects:\n        return True\n    \n    # Interference: one deletes other's precondition\n    if a1.delete_effects & a2.preconditions:\n        return True\n    if a2.delete_effects & a1.preconditions:\n        return True\n    \n    return False\n\ndef are_mutex_props(p1, p2, actions, mutex_actions):\n    \"\"\"Check if two propositions are mutex.\"\"\"\n    # Find all actions that achieve p1\n    achievers_p1 = [a for a in actions if p1 in a.add_effects]\n    achievers_p2 = [a for a in actions if p2 in a.add_effects]\n    \n    # Props are mutex if all pairs of achievers are mutex\n    for a1 in achievers_p1:\n        for a2 in achievers_p2:\n            if a1 != a2 and not (a1.name, a2.name) in mutex_actions:\n                return False\n    return True\n\ndef build_mutex_graph(actions, propositions):\n    \"\"\"Build mutex relations for planning graph.\"\"\"\n    action_mutexes = set()\n    for i, a1 in enumerate(actions):\n        for a2 in actions[i+1:]:\n            if are_mutex_actions(a1, a2):\n                action_mutexes.add((a1.name, a2.name))\n                action_mutexes.add((a2.name, a1.name))\n    \n    prop_mutexes = set()\n    for i, p1 in enumerate(propositions):\n        for p2 in propositions[i+1:]:\n            if are_mutex_props(p1, p2, actions, action_mutexes):\n                prop_mutexes.add((p1, p2))\n                prop_mutexes.add((p2, p1))\n    \n    return action_mutexes, prop_mutexes", "testCases": [{"input": "are_mutex_actions(a1, a2)", "isHidden": false, "description": "Test action mutex"}, {"input": "are_mutex_props(p1, p2, actions, mutex)", "isHidden": false, "description": "Test prop mutex"}, {"input": "build_mutex_graph(actions, props)", "isHidden": true, "description": "Test full graph"}], "hints": ["Actions mutex if effects/preconditions conflict", "Props mutex if all achievers are pairwise mutex", "Mutex relations decrease as graph expands"], "language": "python"},
  {"id": "cs406-t5-ex11", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Plan Validation", "difficulty": 2, "description": "Validate that a plan achieves the goal from the initial state.", "starterCode": "def validate_plan(plan, initial_state, goal):\n    pass\n\ndef simulate_plan(plan, initial_state):\n    pass", "solution": "def simulate_plan(plan, initial_state):\n    \"\"\"Execute plan and return final state.\"\"\"\n    state = initial_state.copy()\n    for action in plan:\n        if not action.is_applicable(state):\n            return None, action  # Failed at this action\n        state = action.apply(state)\n    return state, None\n\ndef validate_plan(plan, initial_state, goal):\n    \"\"\"Check if plan achieves goal from initial state.\"\"\"\n    final_state, failed_action = simulate_plan(plan, initial_state)\n    \n    if failed_action:\n        return False, f\"Action {failed_action.name} not applicable\"\n    \n    if not goal.issubset(final_state):\n        missing = goal - final_state\n        return False, f\"Goal not achieved, missing: {missing}\"\n    \n    return True, \"Plan valid\"\n\n# Test\ninitial = {'at(A,table)', 'at(B,table)', 'clear(A)', 'clear(B)', 'handempty'}\ngoal = {'on(A,B)'}\n\npickup_A = Action('pickup(A)', ['at(A,table)', 'clear(A)', 'handempty'], ['holding(A)'], ['at(A,table)', 'clear(A)', 'handempty'])\nstack_A_B = Action('stack(A,B)', ['holding(A)', 'clear(B)'], ['on(A,B)', 'clear(A)', 'handempty'], ['holding(A)', 'clear(B)'])\n\nplan = [pickup_A, stack_A_B]\nvalid, msg = validate_plan(plan, initial, goal)\nprint(f\"Valid: {valid}, {msg}\")", "testCases": [{"input": "validate_plan(plan, initial, goal)", "isHidden": false, "description": "Test plan validation"}, {"input": "simulate_plan(plan, initial)", "isHidden": false, "description": "Test simulation"}, {"input": "detect invalid plan", "isHidden": true, "description": "Test error detection"}], "hints": ["Execute actions in sequence", "Check preconditions before each action", "Verify goal subset of final state"], "language": "python"},
  {"id": "cs406-t5-ex12", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Plan Repair", "difficulty": 4, "description": "Repair a broken plan when execution fails due to unexpected changes.", "starterCode": "def repair_plan(original_plan, current_state, goal, actions):\n    pass\n\ndef find_divergence(expected_states, actual_state):\n    pass", "solution": "def find_divergence(plan, expected_initial, actual_state):\n    \"\"\"Find first step where expected differs from actual.\"\"\"\n    state = expected_initial.copy()\n    for i, action in enumerate(plan):\n        if not action.is_applicable(actual_state if i == 0 else state):\n            return i\n        state = action.apply(state)\n    return len(plan)  # No divergence\n\ndef repair_plan(original_plan, current_state, goal, actions):\n    \"\"\"Repair plan starting from current state.\"\"\"\n    # Find remaining applicable portion of plan\n    remaining_plan = []\n    state = current_state.copy()\n    \n    for action in original_plan:\n        if action.is_applicable(state):\n            remaining_plan.append(action)\n            state = action.apply(state)\n        # Skip inapplicable actions\n    \n    # Check if remaining plan achieves goal\n    if goal.issubset(state):\n        return remaining_plan\n    \n    # Need to replan for missing goals\n    missing_goals = goal - state\n    \n    # Simple repair: find actions that achieve missing goals\n    repair_actions = []\n    for g in missing_goals:\n        for action in actions:\n            if g in action.add_effects and action.is_applicable(state):\n                repair_actions.append(action)\n                state = action.apply(state)\n                break\n    \n    return remaining_plan + repair_actions\n\n# Alternative: full replanning\ndef replan(current_state, goal, actions):\n    problem = PlanningProblem(current_state, goal, actions)\n    return forward_search(problem)", "testCases": [{"input": "repair_plan(plan, current, goal, actions)", "isHidden": false, "description": "Test plan repair"}, {"input": "find_divergence(plan, expected, actual)", "isHidden": false, "description": "Test divergence detection"}, {"input": "minimal repair", "isHidden": true, "description": "Test repair minimality"}], "hints": ["Find where plan breaks", "Keep applicable suffix", "Replan for missing goals"], "language": "python"},
  {"id": "cs406-t5-ex13", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Temporal Planning Basics", "difficulty": 4, "description": "Extend planning to handle action durations and temporal constraints.", "starterCode": "class DurativeAction:\n    def __init__(self, name, duration, at_start, at_end, over_all):\n        pass\n\ndef temporal_plan(problem):\n    pass", "solution": "class DurativeAction:\n    def __init__(self, name, duration, start_cond, end_cond, start_eff, end_eff, invariant):\n        self.name = name\n        self.duration = duration\n        self.start_conditions = set(start_cond)  # Required at start\n        self.end_conditions = set(end_cond)      # Required at end\n        self.start_effects = set(start_eff)       # Applied at start\n        self.end_effects = set(end_eff)           # Applied at end\n        self.invariant = set(invariant)           # Must hold during\n\nclass TemporalPlan:\n    def __init__(self):\n        self.scheduled = []  # (start_time, action)\n        self.makespan = 0\n    \n    def schedule(self, action, start_time):\n        self.scheduled.append((start_time, action))\n        self.makespan = max(self.makespan, start_time + action.duration)\n    \n    def get_state_at(self, time):\n        state = set()\n        for start_time, action in self.scheduled:\n            if start_time <= time:\n                state |= action.start_effects\n            if start_time + action.duration <= time:\n                state |= action.end_effects\n        return state\n\ndef greedy_temporal_plan(initial_state, goal, actions):\n    \"\"\"Simple greedy temporal planner.\"\"\"\n    plan = TemporalPlan()\n    state = initial_state.copy()\n    time = 0\n    \n    while not goal.issubset(state):\n        for action in actions:\n            if action.start_conditions.issubset(state):\n                plan.schedule(action, time)\n                state |= action.start_effects\n                state |= action.end_effects  # Simplified\n                time += action.duration\n                break\n        else:\n            return None  # No applicable action\n    \n    return plan", "testCases": [{"input": "temporal_plan(problem)", "isHidden": false, "description": "Test temporal planning"}, {"input": "plan.schedule(action, time)", "isHidden": false, "description": "Test scheduling"}, {"input": "concurrent actions", "isHidden": true, "description": "Test parallel execution"}], "hints": ["Actions have durations and temporal conditions", "Conditions at start, end, and throughout", "Schedule actions to minimize makespan"], "language": "python"},
  {"id": "cs406-t5-ex14", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Conformant Planning", "difficulty": 5, "description": "Plan under uncertainty when initial state is not fully known.\n\nFind plan that works for all possible initial states.", "starterCode": "def conformant_plan(belief_state, goal, actions):\n    pass\n\ndef apply_to_belief(belief_state, action):\n    pass", "solution": "def apply_to_belief(belief_states, action):\n    \"\"\"Apply action to set of possible states.\"\"\"\n    result = set()\n    for state in belief_states:\n        if action.is_applicable(state):\n            result.add(frozenset(action.apply(state)))\n        else:\n            return None  # Action must be applicable in all states\n    return result\n\ndef conformant_plan(initial_belief, goal, actions):\n    \"\"\"Find plan that achieves goal from any initial state in belief.\"\"\"\n    # BFS over belief states\n    from collections import deque\n    \n    initial = frozenset(frozenset(s) for s in initial_belief)\n    frontier = deque([(initial, [])])\n    explored = set()\n    \n    while frontier:\n        belief, plan = frontier.popleft()\n        belief_key = frozenset(belief)\n        if belief_key in explored: continue\n        explored.add(belief_key)\n        \n        # Check if goal achieved in all states\n        if all(goal.issubset(state) for state in belief):\n            return plan\n        \n        for action in actions:\n            new_belief = apply_to_belief(belief, action)\n            if new_belief and frozenset(new_belief) not in explored:\n                frontier.append((new_belief, plan + [action]))\n    \n    return None\n\n# Example: Robot localization\ninitial_belief = [\n    {'at(A)'}, {'at(B)'}, {'at(C)'}  # Could be at any of 3 locations\n]\ngoal = {'at(D)', 'sensed'}\nactions = [\n    Action('move_to_D', ['at(A)'], ['at(D)'], ['at(A)']),\n    Action('move_to_D', ['at(B)'], ['at(D)'], ['at(B)']),\n    Action('move_to_D', ['at(C)'], ['at(D)'], ['at(C)']),\n    Action('sense', ['at(D)'], ['sensed'], []),\n]", "testCases": [{"input": "conformant_plan(belief, goal, actions)", "isHidden": false, "description": "Test conformant planning"}, {"input": "apply_to_belief(belief, action)", "isHidden": false, "description": "Test belief update"}, {"input": "handles uncertainty", "isHidden": true, "description": "Test robustness"}], "hints": ["Belief state is set of possible states", "Action must be applicable in all states", "Plan works for every possibility"], "language": "python"},
  {"id": "cs406-t5-ex15", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Multi-Agent Planning", "difficulty": 5, "description": "Plan for multiple agents with independent and joint actions.", "starterCode": "def multi_agent_plan(agents, initial_state, goal, actions):\n    pass\n\ndef merge_plans(agent_plans):\n    pass", "solution": "def multi_agent_plan(agents, initial_state, goal, actions_by_agent):\n    \"\"\"Simple multi-agent planning with coordination.\"\"\"\n    \n    # Decompose goal by agent\n    agent_goals = {agent: set() for agent in agents}\n    for g in goal:\n        # Assign goal to agent that can achieve it\n        for agent in agents:\n            if any(g in a.add_effects for a in actions_by_agent[agent]):\n                agent_goals[agent].add(g)\n                break\n    \n    # Plan for each agent independently\n    agent_plans = {}\n    current_state = initial_state.copy()\n    \n    for agent in agents:\n        if not agent_goals[agent]: continue\n        problem = PlanningProblem(current_state, agent_goals[agent], actions_by_agent[agent])\n        plan = forward_search(problem)\n        if plan:\n            agent_plans[agent] = plan\n            for action in plan:\n                current_state = action.apply(current_state)\n    \n    return agent_plans\n\ndef parallel_plan(agents, initial_state, goal, actions_by_agent):\n    \"\"\"Find plans that can execute in parallel.\"\"\"\n    agent_plans = multi_agent_plan(agents, initial_state, goal, actions_by_agent)\n    \n    # Check for conflicts\n    all_actions = []\n    for agent, plan in agent_plans.items():\n        for i, action in enumerate(plan):\n            all_actions.append((agent, i, action))\n    \n    conflicts = []\n    for i, (a1, t1, act1) in enumerate(all_actions):\n        for a2, t2, act2 in all_actions[i+1:]:\n            if t1 == t2 and are_mutex_actions(act1, act2):\n                conflicts.append((a1, a2, t1))\n    \n    return agent_plans, conflicts\n\ndef merge_plans(agent_plans):\n    \"\"\"Merge agent plans into joint timeline.\"\"\"\n    timeline = []\n    max_len = max(len(p) for p in agent_plans.values()) if agent_plans else 0\n    \n    for t in range(max_len):\n        step = {}\n        for agent, plan in agent_plans.items():\n            if t < len(plan):\n                step[agent] = plan[t]\n        timeline.append(step)\n    \n    return timeline", "testCases": [{"input": "multi_agent_plan(agents, initial, goal, actions)", "isHidden": false, "description": "Test multi-agent planning"}, {"input": "parallel_plan(agents, initial, goal, actions)", "isHidden": false, "description": "Test parallel execution"}, {"input": "conflict detection", "isHidden": true, "description": "Test coordination"}], "hints": ["Decompose goals among agents", "Check for action conflicts", "Coordinate to avoid interference"], "language": "python"},
  {"id": "cs406-t5-ex16", "subjectId": "cs406", "topicId": "cs406-topic-5", "title": "Logistics Domain Modeling", "difficulty": 2, "description": "Model a logistics planning domain with trucks, packages, and locations.", "starterCode": "def create_logistics_domain(locations, trucks, packages):\n    pass\n\ndef create_logistics_problem(trucks, packages, goal_locations):\n    pass", "solution": "def create_logistics_domain(locations, trucks, packages):\n    \"\"\"Create logistics planning domain.\"\"\"\n    actions = []\n    \n    # Drive truck from loc1 to loc2\n    for truck in trucks:\n        for loc1 in locations:\n            for loc2 in locations:\n                if loc1 != loc2:\n                    actions.append(Action(\n                        f'drive({truck},{loc1},{loc2})',\n                        [f'at({truck},{loc1})'],\n                        [f'at({truck},{loc2})'],\n                        [f'at({truck},{loc1})']\n                    ))\n    \n    # Load package onto truck\n    for pkg in packages:\n        for truck in trucks:\n            for loc in locations:\n                actions.append(Action(\n                    f'load({pkg},{truck},{loc})',\n                    [f'at({pkg},{loc})', f'at({truck},{loc})'],\n                    [f'in({pkg},{truck})'],\n                    [f'at({pkg},{loc})']\n                ))\n    \n    # Unload package from truck\n    for pkg in packages:\n        for truck in trucks:\n            for loc in locations:\n                actions.append(Action(\n                    f'unload({pkg},{truck},{loc})',\n                    [f'in({pkg},{truck})', f'at({truck},{loc})'],\n                    [f'at({pkg},{loc})'],\n                    [f'in({pkg},{truck})']\n                ))\n    \n    return actions\n\ndef create_logistics_problem(locations, trucks, packages, initial_locs, goal_locs):\n    \"\"\"Create logistics problem instance.\"\"\"\n    # Initial state\n    initial_state = set()\n    for truck, loc in initial_locs['trucks'].items():\n        initial_state.add(f'at({truck},{loc})')\n    for pkg, loc in initial_locs['packages'].items():\n        initial_state.add(f'at({pkg},{loc})')\n    \n    # Goal\n    goal = set()\n    for pkg, loc in goal_locs.items():\n        goal.add(f'at({pkg},{loc})')\n    \n    actions = create_logistics_domain(locations, trucks, packages)\n    return PlanningProblem(initial_state, goal, actions)\n\n# Example\nlocations = ['depot', 'A', 'B']\ntrucks = ['truck1']\npackages = ['pkg1', 'pkg2']\ninitial = {'trucks': {'truck1': 'depot'}, 'packages': {'pkg1': 'A', 'pkg2': 'depot'}}\ngoals = {'pkg1': 'B', 'pkg2': 'A'}\n\nproblem = create_logistics_problem(locations, trucks, packages, initial, goals)\nplan = forward_search(problem)\nprint(f\"Logistics plan: {[a.name for a in plan] if plan else 'No plan'}\")", "testCases": [{"input": "create_logistics_domain(locs, trucks, pkgs)", "isHidden": false, "description": "Test domain creation"}, {"input": "create_logistics_problem(...)", "isHidden": false, "description": "Test problem creation"}, {"input": "solve logistics problem", "isHidden": true, "description": "Test planning"}], "hints": ["Actions: drive, load, unload", "Preconditions: location constraints", "Track truck and package locations"], "language": "python"}
]

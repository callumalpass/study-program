[
  {"id": "cs406-t4-ex01", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Backtracking Search for CSP", "difficulty": 2, "description": "Implement backtracking search for constraint satisfaction problems.\n\nYour implementation should:\n- Assign variables one at a time\n- Check constraints after each assignment\n- Backtrack when no legal values remain", "starterCode": "def is_consistent(assignment, var, value, constraints):\n    pass\n\ndef backtracking_search(variables, domains, constraints):\n    pass", "solution": "def is_consistent(assignment, var, value, constraints):\n    for av, aval in assignment.items():\n        if not constraints(var, value, av, aval):\n            return False\n    return True\n\ndef backtracking_search(variables, domains, constraints, assignment=None):\n    if assignment is None: assignment = {}\n    if len(assignment) == len(variables): return assignment\n    var = [v for v in variables if v not in assignment][0]\n    for value in domains[var]:\n        if is_consistent(assignment, var, value, constraints):\n            assignment[var] = value\n            result = backtracking_search(variables, domains, constraints, assignment)\n            if result: return result\n            del assignment[var]\n    return None", "testCases": [{"input": "backtracking_search(vars, domains, constraint)", "isHidden": false, "description": "Test backtracking finds solution"}, {"input": "is_consistent(assignment, var, value, constraints)", "isHidden": false, "description": "Test consistency check"}, {"input": "backtracking with 8-Queens", "isHidden": true, "description": "Test larger problem"}], "hints": ["Check consistency by verifying against all existing assignments", "Select any unassigned variable and try values from its domain", "Backtrack by removing assignment and trying next value"], "language": "python"},
  {"id": "cs406-t4-ex02", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "AC-3 Constraint Propagation", "difficulty": 3, "description": "Implement the AC-3 algorithm for arc consistency.\n\nMaintain a queue of arcs to check, remove inconsistent values, and add affected arcs back when domains change.", "starterCode": "def revise(xi, xj, domains, constraints):\n    pass\n\ndef ac3(variables, domains, constraints):\n    pass", "solution": "from collections import deque\n\ndef revise(xi, xj, domains, constraints):\n    revised = False\n    for x in list(domains[xi]):\n        if not any(constraints(xi, x, xj, y) for y in domains[xj]):\n            domains[xi].remove(x)\n            revised = True\n    return revised\n\ndef ac3(variables, domains, constraints):\n    domains = {v: d[:] for v, d in domains.items()}\n    queue = deque((xi, xj) for xi in variables for xj in variables if xi != xj)\n    while queue:\n        xi, xj = queue.popleft()\n        if revise(xi, xj, domains, constraints):\n            if not domains[xi]: return False, domains\n            for xk in variables:\n                if xk != xi and xk != xj:\n                    queue.append((xk, xi))\n    return True, domains", "testCases": [{"input": "ac3(variables, domains, constraints)", "isHidden": false, "description": "Test AC-3 reduces domains"}, {"input": "revise(xi, xj, domains, constraints)", "isHidden": false, "description": "Test revise function"}, {"input": "ac3 detects inconsistency", "isHidden": true, "description": "Test empty domain detection"}], "hints": ["Revise removes values that have no supporting value in neighbor", "When domain changes, re-check arcs pointing to that variable", "Return False if any domain becomes empty"], "language": "python"},
  {"id": "cs406-t4-ex03", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "MRV and Forward Checking", "difficulty": 3, "description": "Enhance backtracking with Minimum Remaining Values heuristic and forward checking.", "starterCode": "def select_mrv(variables, assignment, domains):\n    pass\n\ndef forward_check(var, value, domains, constraints):\n    pass", "solution": "def select_mrv(variables, assignment, domains):\n    unassigned = [v for v in variables if v not in assignment]\n    return min(unassigned, key=lambda v: len(domains[v])) if unassigned else None\n\ndef forward_check(var, value, assignment, domains, constraints):\n    inferences = {}\n    for other in domains:\n        if other == var or other in assignment: continue\n        removed = [v for v in domains[other] if not constraints(var, value, other, v)]\n        for v in removed: domains[other].remove(v)\n        if removed: inferences[other] = removed\n        if not domains[other]: return False, inferences\n    return True, inferences\n\ndef restore(domains, inferences):\n    for var, vals in inferences.items():\n        domains[var].extend(vals)", "testCases": [{"input": "select_mrv(variables, assignment, domains)", "isHidden": false, "description": "Test MRV selection"}, {"input": "forward_check(var, value, domains, constraints)", "isHidden": false, "description": "Test forward checking"}, {"input": "MRV+FC is faster", "isHidden": true, "description": "Test efficiency"}], "hints": ["MRV: select variable with smallest remaining domain", "Forward check: prune values inconsistent with new assignment", "Restore domains when backtracking"], "language": "python"},
  {"id": "cs406-t4-ex04", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "CSP Variable Count", "difficulty": 1, "description": "Calculate search space size for a CSP.\n\nGiven variables and domain sizes, compute total assignments and constraint satisfaction complexity.", "starterCode": "def search_space_size(domain_sizes):\n    pass\n\ndef estimate_solutions(domain_sizes, constraint_tightness):\n    pass", "solution": "import math\n\ndef search_space_size(domain_sizes):\n    result = 1\n    for size in domain_sizes:\n        result *= size\n    return result\n\ndef estimate_solutions(domain_sizes, constraint_tightness):\n    total = search_space_size(domain_sizes)\n    n = len(domain_sizes)\n    num_constraints = n * (n - 1) // 2\n    survival_rate = (1 - constraint_tightness) ** num_constraints\n    return total * survival_rate\n\n# Example\nprint(f\"4 variables, domain size 3: {search_space_size([3,3,3,3])} assignments\")\nprint(f\"N-Queens 8: {search_space_size([8]*8)} total, ~{estimate_solutions([8]*8, 0.1):.0f} estimated solutions\")", "testCases": [{"input": "search_space_size([3,3,3])", "isHidden": false, "description": "Test space calculation"}, {"input": "estimate_solutions([4,4,4], 0.5)", "isHidden": false, "description": "Test solution estimate"}, {"input": "large domain calculation", "isHidden": true, "description": "Test with large domains"}], "hints": ["Total assignments = product of all domain sizes", "Each constraint filters out some fraction of assignments", "Estimate assumes constraints are independent"], "language": "python"},
  {"id": "cs406-t4-ex05", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Graph Coloring CSP", "difficulty": 2, "description": "Model and solve graph coloring as a CSP.\n\nGiven a graph and k colors, find a valid coloring where no adjacent vertices share a color.", "starterCode": "def model_graph_coloring(nodes, edges, colors):\n    pass\n\ndef solve_coloring(nodes, edges, colors):\n    pass", "solution": "def model_graph_coloring(nodes, edges, colors):\n    variables = nodes\n    domains = {node: colors[:] for node in nodes}\n    def constraint(v1, c1, v2, c2):\n        if (v1, v2) in edges or (v2, v1) in edges:\n            return c1 != c2\n        return True\n    return variables, domains, constraint\n\ndef solve_coloring(nodes, edges, colors):\n    variables, domains, constraint = model_graph_coloring(nodes, edges, colors)\n    return backtracking_search(variables, domains, constraint)\n\n# Map coloring example\nnodes = ['WA', 'NT', 'SA', 'Q', 'NSW', 'V', 'T']\nedges = [('WA','NT'), ('WA','SA'), ('NT','SA'), ('NT','Q'), ('SA','Q'), ('SA','NSW'), ('SA','V'), ('Q','NSW'), ('NSW','V')]\ncolors = ['red', 'green', 'blue']\n\nsolution = solve_coloring(nodes, edges, colors)\nprint(f\"Map coloring: {solution}\")", "testCases": [{"input": "solve_coloring(nodes, edges, ['R','G','B'])", "isHidden": false, "description": "Test 3-coloring"}, {"input": "model_graph_coloring returns CSP", "isHidden": false, "description": "Test CSP modeling"}, {"input": "chromatic number detection", "isHidden": true, "description": "Test minimum colors"}], "hints": ["Variables are nodes, domains are colors", "Constraint: adjacent nodes must have different colors", "Australia map is 3-colorable"], "language": "python"},
  {"id": "cs406-t4-ex06", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Sudoku Solver", "difficulty": 3, "description": "Solve Sudoku using CSP with constraint propagation.\n\nImplement AC-3 preprocessing followed by backtracking.", "starterCode": "def parse_sudoku(grid_string):\n    pass\n\ndef solve_sudoku(grid):\n    pass", "solution": "def parse_sudoku(grid_string):\n    grid = []\n    for i in range(9):\n        row = []\n        for j in range(9):\n            c = grid_string[i*9+j]\n            row.append(int(c) if c != '.' else 0)\n        grid.append(row)\n    return grid\n\ndef solve_sudoku(grid):\n    variables = [(i,j) for i in range(9) for j in range(9)]\n    domains = {}\n    for i,j in variables:\n        if grid[i][j] != 0:\n            domains[(i,j)] = [grid[i][j]]\n        else:\n            domains[(i,j)] = list(range(1,10))\n    \n    def constraint(v1, val1, v2, val2):\n        i1,j1 = v1; i2,j2 = v2\n        same_row = i1 == i2\n        same_col = j1 == j2\n        same_box = (i1//3 == i2//3) and (j1//3 == j2//3)\n        if same_row or same_col or same_box:\n            return val1 != val2\n        return True\n    \n    _, domains = ac3(variables, domains, constraint)\n    solution = backtracking_search(variables, domains, constraint)\n    \n    if solution:\n        result = [[0]*9 for _ in range(9)]\n        for (i,j), val in solution.items():\n            result[i][j] = val\n        return result\n    return None", "testCases": [{"input": "solve_sudoku(easy_puzzle)", "isHidden": false, "description": "Test easy Sudoku"}, {"input": "solve_sudoku(hard_puzzle)", "isHidden": false, "description": "Test hard Sudoku"}, {"input": "AC-3 reduces domains", "isHidden": true, "description": "Test propagation"}], "hints": ["Variables are cells, domains are 1-9", "Constraints: no duplicates in row, column, or 3x3 box", "AC-3 preprocessing dramatically reduces search"], "language": "python"},
  {"id": "cs406-t4-ex07", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Least Constraining Value", "difficulty": 3, "description": "Implement the Least Constraining Value heuristic for value ordering.\n\nOrder values by how many choices they leave for neighboring variables.", "starterCode": "def lcv_order(var, domains, neighbors, constraints):\n    pass\n\ndef count_conflicts(var, value, domains, neighbors, constraints):\n    pass", "solution": "def count_conflicts(var, value, domains, neighbors, constraints):\n    count = 0\n    for neighbor in neighbors[var]:\n        for nval in domains[neighbor]:\n            if not constraints(var, value, neighbor, nval):\n                count += 1\n    return count\n\ndef lcv_order(var, domains, neighbors, constraints):\n    values = domains[var][:]\n    values.sort(key=lambda v: count_conflicts(var, v, domains, neighbors, constraints))\n    return values\n\ndef backtracking_lcv(variables, domains, neighbors, constraints, assignment=None):\n    if assignment is None: assignment = {}\n    if len(assignment) == len(variables): return assignment\n    \n    unassigned = [v for v in variables if v not in assignment]\n    var = min(unassigned, key=lambda v: len(domains[v]))  # MRV\n    \n    for value in lcv_order(var, domains, neighbors, constraints):\n        if is_consistent(assignment, var, value, constraints):\n            assignment[var] = value\n            result = backtracking_lcv(variables, domains, neighbors, constraints, assignment)\n            if result: return result\n            del assignment[var]\n    return None", "testCases": [{"input": "lcv_order(var, domains, neighbors, constraints)", "isHidden": false, "description": "Test LCV ordering"}, {"input": "count_conflicts(var, value, domains, neighbors, constraints)", "isHidden": false, "description": "Test conflict counting"}, {"input": "LCV improves search", "isHidden": true, "description": "Test efficiency"}], "hints": ["LCV: prefer values that rule out fewest choices for neighbors", "Count how many neighbor values become invalid", "Sort values by ascending conflict count"], "language": "python"},
  {"id": "cs406-t4-ex08", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Min-Conflicts Local Search", "difficulty": 3, "description": "Implement min-conflicts algorithm for CSP.\n\nStart with random assignment and iteratively improve by minimizing conflicts.", "starterCode": "def min_conflicts(variables, domains, constraints, max_steps=1000):\n    pass\n\ndef count_all_conflicts(assignment, constraints):\n    pass", "solution": "import random\n\ndef count_var_conflicts(var, value, assignment, constraints):\n    return sum(1 for v2, val2 in assignment.items() if v2 != var and not constraints(var, value, v2, val2))\n\ndef min_conflicts(variables, domains, constraints, max_steps=1000):\n    assignment = {v: random.choice(domains[v]) for v in variables}\n    \n    for _ in range(max_steps):\n        conflicted = [v for v in variables if count_var_conflicts(v, assignment[v], assignment, constraints) > 0]\n        if not conflicted: return assignment\n        \n        var = random.choice(conflicted)\n        min_conf = float('inf')\n        best_vals = []\n        \n        for val in domains[var]:\n            conf = count_var_conflicts(var, val, assignment, constraints)\n            if conf < min_conf:\n                min_conf = conf\n                best_vals = [val]\n            elif conf == min_conf:\n                best_vals.append(val)\n        \n        assignment[var] = random.choice(best_vals)\n    \n    return None\n\n# N-Queens test\nn = 100\nvars = list(range(n))\ndoms = {i: list(range(n)) for i in range(n)}\ndef queens(c1, r1, c2, r2): return r1 != r2 and abs(r1-r2) != abs(c1-c2)\nsol = min_conflicts(vars, doms, queens, 10000)\nprint(f\"100-Queens solved: {sol is not None}\")", "testCases": [{"input": "min_conflicts(vars, doms, constraints)", "isHidden": false, "description": "Test min-conflicts finds solution"}, {"input": "count_var_conflicts(var, value, assignment, constraints)", "isHidden": false, "description": "Test conflict counting"}, {"input": "100-Queens in reasonable time", "isHidden": true, "description": "Test scalability"}], "hints": ["Start with random complete assignment", "Pick a conflicted variable randomly", "Change it to value that minimizes conflicts"], "language": "python"},
  {"id": "cs406-t4-ex09", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Node and Path Consistency", "difficulty": 2, "description": "Implement node consistency (NC) and path consistency (PC) for CSP preprocessing.", "starterCode": "def node_consistency(domains, unary_constraints):\n    pass\n\ndef path_consistency(variables, domains, constraints):\n    pass", "solution": "def node_consistency(domains, unary_constraints):\n    \"\"\"Remove values that violate unary constraints.\"\"\"\n    for var, constraint_fn in unary_constraints.items():\n        domains[var] = [v for v in domains[var] if constraint_fn(v)]\n    return domains\n\ndef path_consistency(variables, domains, constraints):\n    \"\"\"PC-2 algorithm for path consistency.\"\"\"\n    changed = True\n    while changed:\n        changed = False\n        for vi in variables:\n            for vj in variables:\n                if vi >= vj: continue\n                for vk in variables:\n                    if vk == vi or vk == vj: continue\n                    # Check if (vi, vj) pair is supported via vk\n                    for xi in list(domains[vi]):\n                        for xj in list(domains[vj]):\n                            if not constraints(vi, xi, vj, xj): continue\n                            supported = any(\n                                constraints(vi, xi, vk, xk) and constraints(vj, xj, vk, xk)\n                                for xk in domains[vk]\n                            )\n                            if not supported:\n                                # Would need to remove (xi, xj) pair - simplified\n                                changed = True\n    return domains\n\n# Example\ndomains = {'X': [1,2,3,4,5], 'Y': [1,2,3,4,5]}\nunary = {'X': lambda x: x > 2, 'Y': lambda y: y % 2 == 0}\ndomains = node_consistency(domains, unary)\nprint(f\"After NC: {domains}\")", "testCases": [{"input": "node_consistency(domains, unary)", "isHidden": false, "description": "Test node consistency"}, {"input": "path_consistency(vars, domains, constraints)", "isHidden": false, "description": "Test path consistency"}, {"input": "NC removes invalid values", "isHidden": true, "description": "Test filtering"}], "hints": ["NC: filter domain values against unary constraints", "PC: ensure every pair has support via third variable", "NC is O(nd), PC is O(n³d³)"], "language": "python"},
  {"id": "cs406-t4-ex10", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Conflict-Directed Backjumping", "difficulty": 4, "description": "Implement conflict-directed backjumping to skip irrelevant backtrack levels.", "starterCode": "def backjumping(variables, domains, constraints):\n    pass\n\ndef get_conflict_set(var, assignment, domains, constraints):\n    pass", "solution": "def get_conflict_set(var, value, assignment, constraints):\n    \"\"\"Return variables that caused this assignment to fail.\"\"\"\n    conflicts = set()\n    for other_var, other_val in assignment.items():\n        if not constraints(var, value, other_var, other_val):\n            conflicts.add(other_var)\n    return conflicts\n\ndef backjumping(variables, domains, constraints, assignment=None, conflict_sets=None):\n    if assignment is None:\n        assignment = {}\n        conflict_sets = {v: set() for v in variables}\n    \n    if len(assignment) == len(variables):\n        return assignment, set()\n    \n    var = [v for v in variables if v not in assignment][0]\n    my_conflicts = set()\n    \n    for value in domains[var]:\n        if is_consistent(assignment, var, value, constraints):\n            assignment[var] = value\n            result, conflicts = backjumping(variables, domains, constraints, assignment, conflict_sets)\n            \n            if result is not None:\n                return result, set()\n            \n            my_conflicts |= conflicts\n            \n            if var not in conflicts:\n                del assignment[var]\n                return None, my_conflicts\n            \n            my_conflicts.discard(var)\n            del assignment[var]\n        else:\n            my_conflicts |= get_conflict_set(var, value, assignment, constraints)\n    \n    return None, my_conflicts\n\n# Test\nresult, _ = backjumping(variables, domains, constraints)\nprint(f\"Solution found: {result is not None}\")", "testCases": [{"input": "backjumping(vars, domains, constraints)", "isHidden": false, "description": "Test backjumping finds solution"}, {"input": "get_conflict_set(var, value, assignment, constraints)", "isHidden": false, "description": "Test conflict detection"}, {"input": "backjumping skips levels", "isHidden": true, "description": "Test efficiency"}], "hints": ["Track which earlier variables caused conflicts", "Jump back to most recent conflicting variable", "Skip intermediate variables not in conflict set"], "language": "python"},
  {"id": "cs406-t4-ex11", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Symmetry Breaking", "difficulty": 4, "description": "Implement symmetry breaking constraints to reduce search space.\n\nFor problems with symmetries, add constraints to eliminate equivalent solutions.", "starterCode": "def add_symmetry_breaking(domains, symmetries):\n    pass\n\ndef detect_row_symmetry(grid_size):\n    pass", "solution": "def add_symmetry_breaking(variables, domains, ordering_constraints):\n    \"\"\"Add ordering constraints to break symmetries.\"\"\"\n    new_constraints = []\n    for v1, v2 in ordering_constraints:\n        # v1 should be <= v2\n        new_constraints.append((v1, v2, lambda x, y: x <= y))\n    return new_constraints\n\ndef break_row_symmetry_nqueens(n):\n    \"\"\"For N-Queens, fix first queen's row to be in first half.\"\"\"\n    # Queen in column 0 should be in rows 0 to n//2\n    return {0: list(range(n//2 + 1))}\n\ndef break_pigeonhole_symmetry(n_objects, n_holes):\n    \"\"\"For identical objects, order their assignments.\"\"\"\n    # Object i should be assigned to hole <= object i+1's hole\n    ordering = [(i, i+1) for i in range(n_objects - 1)]\n    return ordering\n\n# Example: N-Queens with symmetry breaking\nn = 8\nvars = list(range(n))\ndoms = {i: list(range(n)) for i in range(n)}\n\n# Break symmetry: first queen in top half\ndoms[0] = list(range(n//2 + 1))\n\ndef queens(c1, r1, c2, r2): return r1 != r2 and abs(r1-r2) != abs(c1-c2)\n\nfrom collections import Counter\nsolutions = []\ndef count_solutions(assignment={}):\n    if len(assignment) == n:\n        solutions.append(assignment.copy())\n        return\n    var = len(assignment)\n    for val in doms[var]:\n        if all(queens(var, val, v2, r2) for v2, r2 in assignment.items()):\n            assignment[var] = val\n            count_solutions(assignment)\n            del assignment[var]\n\ncount_solutions()\nprint(f\"Solutions with symmetry breaking: {len(solutions)}\")", "testCases": [{"input": "add_symmetry_breaking(vars, domains, ordering)", "isHidden": false, "description": "Test symmetry constraints"}, {"input": "break_row_symmetry_nqueens(8)", "isHidden": false, "description": "Test N-Queens symmetry"}, {"input": "reduces solution count", "isHidden": true, "description": "Test effectiveness"}], "hints": ["Identify equivalent solutions (rotations, reflections)", "Add ordering constraints to pick canonical representative", "Symmetry breaking reduces search space by symmetry factor"], "language": "python"},
  {"id": "cs406-t4-ex12", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Global Constraints: AllDifferent", "difficulty": 4, "description": "Implement specialized propagation for the AllDifferent global constraint.", "starterCode": "def propagate_alldiff(variables, domains):\n    pass\n\ndef alldiff_satisfied(assignment, variables):\n    pass", "solution": "def alldiff_satisfied(assignment, variables):\n    \"\"\"Check if all assigned values are different.\"\"\"\n    vals = [assignment[v] for v in variables if v in assignment]\n    return len(vals) == len(set(vals))\n\ndef propagate_alldiff(variables, domains):\n    \"\"\"Propagate AllDifferent constraint.\"\"\"\n    changed = True\n    while changed:\n        changed = False\n        # If a domain has size 1, remove that value from other domains\n        for var in variables:\n            if len(domains[var]) == 1:\n                val = domains[var][0]\n                for other in variables:\n                    if other != var and val in domains[other]:\n                        domains[other].remove(val)\n                        changed = True\n                        if not domains[other]:\n                            return False, domains\n        \n        # Hall's theorem: if k variables have union of k values, remove from others\n        from itertools import combinations\n        for k in range(2, len(variables)):\n            for subset in combinations(variables, k):\n                union = set()\n                for var in subset:\n                    union.update(domains[var])\n                if len(union) == k:\n                    for var in variables:\n                        if var not in subset:\n                            for val in union:\n                                if val in domains[var]:\n                                    domains[var].remove(val)\n                                    changed = True\n                elif len(union) < k:\n                    return False, domains\n    \n    return True, domains\n\n# Test\nvars = ['A', 'B', 'C', 'D']\ndoms = {'A': [1,2], 'B': [1,2,3], 'C': [1,2,3], 'D': [3,4]}\nconsistent, new_doms = propagate_alldiff(vars, doms)\nprint(f\"After propagation: {new_doms}\")", "testCases": [{"input": "propagate_alldiff(vars, domains)", "isHidden": false, "description": "Test AllDiff propagation"}, {"input": "alldiff_satisfied(assignment, vars)", "isHidden": false, "description": "Test satisfaction check"}, {"input": "Hall set detection", "isHidden": true, "description": "Test advanced propagation"}], "hints": ["If domain has one value, remove it from all other domains", "Hall's theorem: k variables with k values total must use those values", "Repeat until no changes"], "language": "python"},
  {"id": "cs406-t4-ex13", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Weighted CSP Optimization", "difficulty": 4, "description": "Extend CSP to handle soft constraints with weights.\n\nFind assignment that maximizes satisfied constraint weight.", "starterCode": "def weighted_csp(variables, domains, hard_constraints, soft_constraints):\n    pass\n\ndef evaluate_assignment(assignment, soft_constraints):\n    pass", "solution": "def evaluate_assignment(assignment, soft_constraints):\n    \"\"\"Return total weight of satisfied soft constraints.\"\"\"\n    total = 0\n    for (v1, v2, constraint_fn, weight) in soft_constraints:\n        if v1 in assignment and v2 in assignment:\n            if constraint_fn(assignment[v1], assignment[v2]):\n                total += weight\n    return total\n\ndef weighted_csp(variables, domains, hard_constraints, soft_constraints):\n    \"\"\"Find assignment satisfying hard constraints and maximizing soft constraint weight.\"\"\"\n    best_assignment = None\n    best_score = float('-inf')\n    \n    def backtrack(assignment):\n        nonlocal best_assignment, best_score\n        \n        if len(assignment) == len(variables):\n            score = evaluate_assignment(assignment, soft_constraints)\n            if score > best_score:\n                best_score = score\n                best_assignment = assignment.copy()\n            return\n        \n        var = [v for v in variables if v not in assignment][0]\n        for value in domains[var]:\n            if is_consistent(assignment, var, value, hard_constraints):\n                assignment[var] = value\n                backtrack(assignment)\n                del assignment[var]\n    \n    backtrack({})\n    return best_assignment, best_score\n\n# Example: Meeting scheduling\nvars = ['Alice', 'Bob', 'Charlie']\ndoms = {v: ['9am', '10am', '11am'] for v in vars}\nhard = lambda v1, t1, v2, t2: True  # No hard constraints\nsoft = [\n    ('Alice', 'Bob', lambda t1, t2: t1 == t2, 10),      # Alice & Bob prefer same time\n    ('Bob', 'Charlie', lambda t1, t2: t1 == t2, 5),     # Bob & Charlie prefer same\n    ('Alice', 'Charlie', lambda t1, t2: t1 != t2, 3),   # Alice & Charlie prefer different\n]\n\nbest, score = weighted_csp(vars, doms, hard, soft)\nprint(f\"Best schedule: {best}, score: {score}\")", "testCases": [{"input": "weighted_csp(vars, domains, hard, soft)", "isHidden": false, "description": "Test weighted CSP"}, {"input": "evaluate_assignment(assignment, soft)", "isHidden": false, "description": "Test scoring"}, {"input": "optimal solution found", "isHidden": true, "description": "Test optimality"}], "hints": ["Hard constraints must be satisfied, soft constraints are preferences", "Enumerate all valid solutions and track best score", "Branch and bound can prune suboptimal branches"], "language": "python"},
  {"id": "cs406-t4-ex14", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Degree Heuristic", "difficulty": 3, "description": "Implement the degree heuristic as a tie-breaker for variable selection.", "starterCode": "def degree_heuristic(var, neighbors, assignment):\n    pass\n\ndef select_mrv_degree(variables, domains, neighbors, assignment):\n    pass", "solution": "def degree_heuristic(var, neighbors, assignment):\n    \"\"\"Return number of constraints on unassigned neighbors.\"\"\"\n    return sum(1 for n in neighbors.get(var, []) if n not in assignment)\n\ndef select_mrv_degree(variables, domains, neighbors, assignment):\n    \"\"\"Select variable using MRV with degree as tie-breaker.\"\"\"\n    unassigned = [v for v in variables if v not in assignment]\n    if not unassigned:\n        return None\n    \n    # Sort by (domain_size, -degree) - smallest domain, largest degree\n    return min(unassigned, key=lambda v: (\n        len(domains[v]),\n        -degree_heuristic(v, neighbors, assignment)\n    ))\n\ndef build_neighbors(variables, constraints):\n    \"\"\"Build neighbor dictionary from constraint function.\"\"\"\n    neighbors = {v: set() for v in variables}\n    for v1 in variables:\n        for v2 in variables:\n            if v1 != v2:\n                # Check if there's a constraint between v1 and v2\n                # (simplified: assume all pairs are constrained)\n                neighbors[v1].add(v2)\n    return neighbors\n\n# Test\nvars = list(range(8))\ndoms = {i: list(range(8)) for i in range(8)}\nneighbors = {i: set(range(8)) - {i} for i in range(8)}\nassignment = {0: 0, 1: 2}\n\nvar = select_mrv_degree(vars, doms, neighbors, assignment)\nprint(f\"Selected variable: {var}\")\nprint(f\"Degree: {degree_heuristic(var, neighbors, assignment)}\")", "testCases": [{"input": "degree_heuristic(var, neighbors, assignment)", "isHidden": false, "description": "Test degree calculation"}, {"input": "select_mrv_degree(vars, domains, neighbors, assignment)", "isHidden": false, "description": "Test combined selection"}, {"input": "breaks ties effectively", "isHidden": true, "description": "Test tie-breaking"}], "hints": ["Degree = number of constraints involving unassigned variables", "Higher degree means more impact on remaining problem", "Use degree to break ties when domains are equal"], "language": "python"},
  {"id": "cs406-t4-ex15", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Constraint Learning", "difficulty": 5, "description": "Implement no-good learning to avoid repeating failures.\n\nWhen backtracking, learn a constraint that prevents the same conflict.", "starterCode": "class NoGoodLearner:\n    def __init__(self):\n        self.nogoods = []\n    \n    def learn_nogood(self, conflict_set):\n        pass\n    \n    def is_nogood(self, assignment):\n        pass", "solution": "class NoGoodLearner:\n    def __init__(self):\n        self.nogoods = []  # List of {var: value} dicts\n    \n    def learn_nogood(self, conflict_set):\n        \"\"\"Learn a no-good from conflict set.\"\"\"\n        # conflict_set is {var: value} for variables involved in conflict\n        if conflict_set and conflict_set not in self.nogoods:\n            self.nogoods.append(conflict_set.copy())\n    \n    def is_nogood(self, assignment):\n        \"\"\"Check if current assignment contains a known no-good.\"\"\"\n        for nogood in self.nogoods:\n            if all(assignment.get(v) == val for v, val in nogood.items()):\n                return True\n        return False\n    \n    def get_pruned_domains(self, var, domains, assignment):\n        \"\"\"Return domain values that don't lead to known no-goods.\"\"\"\n        pruned = []\n        for val in domains[var]:\n            test_assignment = assignment.copy()\n            test_assignment[var] = val\n            if not self.is_nogood(test_assignment):\n                pruned.append(val)\n        return pruned\n\ndef backtrack_with_learning(variables, domains, constraints, learner=None):\n    if learner is None:\n        learner = NoGoodLearner()\n    \n    def backtrack(assignment):\n        if len(assignment) == len(variables):\n            return assignment\n        \n        if learner.is_nogood(assignment):\n            return None\n        \n        var = [v for v in variables if v not in assignment][0]\n        \n        for value in learner.get_pruned_domains(var, domains, assignment):\n            if is_consistent(assignment, var, value, constraints):\n                assignment[var] = value\n                result = backtrack(assignment)\n                if result:\n                    return result\n                del assignment[var]\n        \n        # Learn from failure\n        conflict = {v: assignment[v] for v in assignment}\n        learner.learn_nogood(conflict)\n        return None\n    \n    return backtrack({})\n\n# Test\nvars = ['A', 'B', 'C']\ndoms = {'A': [1,2], 'B': [1,2], 'C': [1,2]}\ndef constraint(v1, val1, v2, val2): return val1 != val2\n\nlearner = NoGoodLearner()\nresult = backtrack_with_learning(vars, doms, constraint, learner)\nprint(f\"Solution: {result}\")\nprint(f\"No-goods learned: {len(learner.nogoods)}\")", "testCases": [{"input": "learner.learn_nogood(conflict)", "isHidden": false, "description": "Test no-good learning"}, {"input": "learner.is_nogood(assignment)", "isHidden": false, "description": "Test no-good detection"}, {"input": "learning prunes search", "isHidden": true, "description": "Test efficiency"}], "hints": ["No-good: partial assignment known to lead to failure", "Learn from conflicts during backtracking", "Prune future search when no-good pattern detected"], "language": "python"},
  {"id": "cs406-t4-ex16", "subjectId": "cs406", "topicId": "cs406-topic-4", "title": "Job Shop Scheduling CSP", "difficulty": 5, "description": "Model and solve job shop scheduling as a CSP.\n\nJobs have tasks that must be scheduled on machines with precedence constraints.", "starterCode": "def model_job_shop(jobs, machines, durations):\n    pass\n\ndef solve_job_shop(jobs, machines, durations, deadline):\n    pass", "solution": "def model_job_shop(jobs, machines, durations, deadline):\n    \"\"\"Model job shop as CSP.\"\"\"\n    # Variables: start time of each (job, task)\n    variables = []\n    domains = {}\n    for job_id, tasks in jobs.items():\n        for task_idx, (machine, duration) in enumerate(tasks):\n            var = (job_id, task_idx)\n            variables.append(var)\n            domains[var] = list(range(deadline - duration + 1))\n    \n    def constraint(v1, t1, v2, t2):\n        job1, task1 = v1\n        job2, task2 = v2\n        \n        dur1 = jobs[job1][task1][1]\n        dur2 = jobs[job2][task2][1]\n        mach1 = jobs[job1][task1][0]\n        mach2 = jobs[job2][task2][0]\n        \n        # Precedence: tasks in same job must be sequential\n        if job1 == job2:\n            if task1 < task2:\n                return t1 + dur1 <= t2\n            else:\n                return t2 + dur2 <= t1\n        \n        # Resource: same machine tasks can't overlap\n        if mach1 == mach2:\n            return t1 + dur1 <= t2 or t2 + dur2 <= t1\n        \n        return True\n    \n    return variables, domains, constraint\n\ndef solve_job_shop(jobs, machines, durations, deadline):\n    variables, domains, constraint = model_job_shop(jobs, machines, durations, deadline)\n    return backtracking_search(variables, domains, constraint)\n\ndef compute_makespan(schedule, jobs):\n    \"\"\"Compute total completion time.\"\"\"\n    max_end = 0\n    for (job, task), start in schedule.items():\n        duration = jobs[job][task][1]\n        max_end = max(max_end, start + duration)\n    return max_end\n\n# Example: 2 jobs, 2 machines\njobs = {\n    'J1': [('M1', 3), ('M2', 2)],  # Job 1: M1 for 3, then M2 for 2\n    'J2': [('M2', 2), ('M1', 4)],  # Job 2: M2 for 2, then M1 for 4\n}\n\nschedule = solve_job_shop(jobs, ['M1', 'M2'], None, 10)\nif schedule:\n    print(f\"Schedule: {schedule}\")\n    print(f\"Makespan: {compute_makespan(schedule, jobs)}\")\nelse:\n    print(\"No feasible schedule\")", "testCases": [{"input": "solve_job_shop(jobs, machines, durations, deadline)", "isHidden": false, "description": "Test scheduling"}, {"input": "compute_makespan(schedule, jobs)", "isHidden": false, "description": "Test makespan"}, {"input": "optimal schedule", "isHidden": true, "description": "Test optimization"}], "hints": ["Variables are task start times", "Precedence: tasks in same job must be sequential", "Resource: same-machine tasks can't overlap"], "language": "python"}
]

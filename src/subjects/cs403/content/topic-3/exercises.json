[
  {
    "id": "cs403-t3-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Quicksort",
    "difficulty": 2,
    "description": "Implement randomized quicksort that randomly selects pivots to achieve expected O(n log n) time complexity.",
    "starterCode": "import random\n\ndef randomized_quicksort(arr):\n    \"\"\"\n    Sort an array using randomized quicksort.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        list: Sorted array.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_quicksort(arr):\n    \"\"\"\n    Sort an array using randomized quicksort.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        list: Sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    # Randomly select a pivot\n    pivot_idx = random.randint(0, len(arr) - 1)\n    pivot = arr[pivot_idx]\n\n    # Partition the array\n    less = [x for x in arr if x < pivot]\n    equal = [x for x in arr if x == pivot]\n    greater = [x for x in arr if x > pivot]\n\n    # Recursively sort and combine\n    return randomized_quicksort(less) + equal + randomized_quicksort(greater)",
    "testCases": [
      {
        "input": "arr = [3, 1, 4, 1, 5, 9, 2, 6]",
        "isHidden": false,
        "description": "Random array with duplicates"
      },
      {
        "input": "arr = [5, 4, 3, 2, 1]",
        "isHidden": false,
        "description": "Reverse sorted array - worst case for deterministic quicksort"
      },
      {
        "input": "arr = [1]",
        "isHidden": false,
        "description": "Single element array"
      }
    ],
    "hints": [
      "Randomly select a pivot element from the array",
      "Partition the array into elements less than, equal to, and greater than the pivot",
      "Recursively sort the less and greater partitions",
      "Random pivot selection makes expected time complexity O(n log n) regardless of input"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Monte Carlo Primality Testing",
    "difficulty": 3,
    "description": "Implement the Miller-Rabin primality test, a Monte Carlo algorithm that probabilistically determines if a number is prime.",
    "starterCode": "import random\n\ndef miller_rabin(n, k=5):\n    \"\"\"\n    Test if n is prime using Miller-Rabin algorithm.\n\n    Args:\n        n: Integer to test for primality.\n        k: Number of rounds (higher k = more confidence).\n\n    Returns:\n        bool: True if n is probably prime, False if definitely composite.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef miller_rabin(n, k=5):\n    \"\"\"\n    Test if n is prime using Miller-Rabin algorithm.\n\n    Args:\n        n: Integer to test for primality.\n        k: Number of rounds (higher k = more confidence).\n\n    Returns:\n        bool: True if n is probably prime, False if definitely composite.\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Write n-1 as 2^r * d\n    r, d = 0, n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n\n    # Perform k rounds of testing\n    for _ in range(k):\n        a = random.randint(2, n - 2)\n        x = pow(a, d, n)\n\n        if x == 1 or x == n - 1:\n            continue\n\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n\n    return True",
    "testCases": [
      {
        "input": "n = 17, k = 5",
        "isHidden": false,
        "description": "Small prime number"
      },
      {
        "input": "n = 561, k = 5",
        "isHidden": false,
        "description": "Carmichael number (composite but passes Fermat test)"
      },
      {
        "input": "n = 97, k = 5",
        "isHidden": false,
        "description": "Prime number"
      }
    ],
    "hints": [
      "Write n-1 as 2^r * d where d is odd",
      "For each round, pick a random witness a",
      "Compute x = a^d mod n",
      "If n is prime, x must be 1 or n-1, or squaring x repeatedly must eventually yield n-1"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized QuickSelect",
    "difficulty": 2,
    "description": "Implement the randomized QuickSelect algorithm to find the k-th smallest element in O(n) expected time.",
    "starterCode": "import random\n\ndef quickselect(arr, k):\n    \"\"\"\n    Find the k-th smallest element (0-indexed) using randomized QuickSelect.\n\n    Args:\n        arr: List of comparable elements.\n        k: Index of the element to find (0-indexed).\n\n    Returns:\n        The k-th smallest element.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef quickselect(arr, k):\n    \"\"\"\n    Find the k-th smallest element (0-indexed) using randomized QuickSelect.\n\n    Args:\n        arr: List of comparable elements.\n        k: Index of the element to find (0-indexed).\n\n    Returns:\n        The k-th smallest element.\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n\n    # Randomly select pivot\n    pivot = random.choice(arr)\n\n    # Partition array\n    less = [x for x in arr if x < pivot]\n    equal = [x for x in arr if x == pivot]\n    greater = [x for x in arr if x > pivot]\n\n    # Determine which partition contains k-th element\n    if k < len(less):\n        return quickselect(less, k)\n    elif k < len(less) + len(equal):\n        return pivot\n    else:\n        return quickselect(greater, k - len(less) - len(equal))",
    "testCases": [
      {
        "input": "arr = [3, 1, 4, 1, 5, 9, 2, 6], k = 4",
        "isHidden": false,
        "description": "Find median (4th smallest element)"
      },
      {
        "input": "arr = [7, 10, 4, 3, 20, 15], k = 2",
        "isHidden": false,
        "description": "Find 3rd smallest element"
      },
      {
        "input": "arr = [5, 5, 5, 5, 5], k = 0",
        "isHidden": false,
        "description": "All elements equal"
      }
    ],
    "hints": [
      "Randomly select a pivot to ensure expected O(n) time",
      "Partition array into elements less than, equal to, and greater than pivot",
      "Recursively search only the partition containing the k-th element",
      "Expected time is O(n) because each recursion reduces size by constant factor"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Bloom Filter",
    "difficulty": 3,
    "description": "Implement a Bloom filter, a space-efficient probabilistic data structure for set membership testing.",
    "starterCode": "import random\n\nclass BloomFilter:\n    \"\"\"\n    Bloom filter for probabilistic set membership testing.\n    \"\"\"\n    def __init__(self, size, num_hashes):\n        \"\"\"\n        Initialize Bloom filter.\n\n        Args:\n            size: Size of bit array.\n            num_hashes: Number of hash functions to use.\n        \"\"\"\n        # Your code here\n        pass\n\n    def add(self, item):\n        \"\"\"Add item to the filter.\"\"\"\n        # Your code here\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if item might be in the set.\n\n        Returns:\n            bool: False means definitely not in set, True means probably in set.\n        \"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass BloomFilter:\n    \"\"\"\n    Bloom filter for probabilistic set membership testing.\n    \"\"\"\n    def __init__(self, size, num_hashes):\n        \"\"\"\n        Initialize Bloom filter.\n\n        Args:\n            size: Size of bit array.\n            num_hashes: Number of hash functions to use.\n        \"\"\"\n        self.size = size\n        self.num_hashes = num_hashes\n        self.bit_array = [0] * size\n\n    def _hash(self, item, seed):\n        \"\"\"Generate hash value for item with given seed.\"\"\"\n        random.seed(str(item) + str(seed))\n        return random.randint(0, self.size - 1)\n\n    def add(self, item):\n        \"\"\"Add item to the filter.\"\"\"\n        for i in range(self.num_hashes):\n            index = self._hash(item, i)\n            self.bit_array[index] = 1\n\n    def contains(self, item):\n        \"\"\"\n        Check if item might be in the set.\n\n        Returns:\n            bool: False means definitely not in set, True means probably in set.\n        \"\"\"\n        for i in range(self.num_hashes):\n            index = self._hash(item, i)\n            if self.bit_array[index] == 0:\n                return False\n        return True",
    "testCases": [
      {
        "input": "bf = BloomFilter(100, 3); bf.add(\"apple\"); bf.add(\"banana\"); bf.contains(\"apple\")",
        "isHidden": false,
        "description": "Test membership of added items"
      },
      {
        "input": "bf = BloomFilter(100, 3); bf.add(\"cat\"); bf.contains(\"dog\")",
        "isHidden": false,
        "description": "Test non-membership (may have false positives)"
      },
      {
        "input": "bf = BloomFilter(50, 5); [bf.add(i) for i in range(10)]; bf.contains(5)",
        "isHidden": false,
        "description": "Multiple items, check membership"
      }
    ],
    "hints": [
      "Use a bit array to store the filter state",
      "For adding, set k bits (where k = num_hashes) based on hash functions",
      "For checking, verify all k bits are set",
      "False positives are possible but false negatives are not",
      "Use different seeds for each hash function"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Reservoir Sampling",
    "difficulty": 2,
    "description": "Implement reservoir sampling to randomly select k items from a stream of unknown length with uniform probability.",
    "starterCode": "import random\n\ndef reservoir_sampling(stream, k):\n    \"\"\"\n    Randomly select k items from a stream with uniform probability.\n\n    Args:\n        stream: Iterator or list of items.\n        k: Number of items to sample.\n\n    Returns:\n        list: k randomly selected items.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef reservoir_sampling(stream, k):\n    \"\"\"\n    Randomly select k items from a stream with uniform probability.\n\n    Args:\n        stream: Iterator or list of items.\n        k: Number of items to sample.\n\n    Returns:\n        list: k randomly selected items.\n    \"\"\"\n    reservoir = []\n\n    for i, item in enumerate(stream):\n        if i < k:\n            # Fill reservoir with first k items\n            reservoir.append(item)\n        else:\n            # Randomly replace items with decreasing probability\n            j = random.randint(0, i)\n            if j < k:\n                reservoir[j] = item\n\n    return reservoir",
    "testCases": [
      {
        "input": "stream = range(100), k = 10",
        "isHidden": false,
        "description": "Sample 10 items from stream of 100"
      },
      {
        "input": "stream = [1, 2, 3, 4, 5], k = 3",
        "isHidden": false,
        "description": "Small stream, sample 3 items"
      },
      {
        "input": "stream = range(1000), k = 5",
        "isHidden": false,
        "description": "Large stream, small sample"
      }
    ],
    "hints": [
      "Keep first k items in the reservoir",
      "For item at index i (i >= k), include it with probability k/i",
      "If included, replace a random item in the reservoir",
      "This ensures each item has equal probability k/n of being selected",
      "Works for streams of unknown length"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Skip List Implementation",
    "difficulty": 4,
    "description": "Implement a skip list, a randomized data structure that provides O(log n) expected time for search, insert, and delete.",
    "starterCode": "import random\n\nclass SkipListNode:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level=16, p=0.5):\n        \"\"\"\n        Initialize skip list.\n\n        Args:\n            max_level: Maximum number of levels.\n            p: Probability for level generation.\n        \"\"\"\n        # Your code here\n        pass\n\n    def random_level(self):\n        \"\"\"Generate random level for new node.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, value):\n        \"\"\"Insert value into skip list.\"\"\"\n        # Your code here\n        pass\n\n    def search(self, value):\n        \"\"\"Search for value in skip list.\"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass SkipListNode:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level=16, p=0.5):\n        \"\"\"\n        Initialize skip list.\n\n        Args:\n            max_level: Maximum number of levels.\n            p: Probability for level generation.\n        \"\"\"\n        self.max_level = max_level\n        self.p = p\n        self.header = SkipListNode(float('-inf'), max_level)\n        self.level = 0\n\n    def random_level(self):\n        \"\"\"Generate random level for new node.\"\"\"\n        level = 0\n        while random.random() < self.p and level < self.max_level:\n            level += 1\n        return level\n\n    def insert(self, value):\n        \"\"\"Insert value into skip list.\"\"\"\n        update = [None] * (self.max_level + 1)\n        current = self.header\n\n        # Find position to insert\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n            update[i] = current\n\n        # Generate random level\n        level = self.random_level()\n\n        # Update level if needed\n        if level > self.level:\n            for i in range(self.level + 1, level + 1):\n                update[i] = self.header\n            self.level = level\n\n        # Create and insert new node\n        new_node = SkipListNode(value, level)\n        for i in range(level + 1):\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n\n    def search(self, value):\n        \"\"\"Search for value in skip list.\"\"\"\n        current = self.header\n\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n\n        current = current.forward[0]\n        return current is not None and current.value == value",
    "testCases": [
      {
        "input": "sl = SkipList(); sl.insert(3); sl.insert(1); sl.insert(4); sl.search(3)",
        "isHidden": false,
        "description": "Insert and search for existing element"
      },
      {
        "input": "sl = SkipList(); sl.insert(5); sl.insert(2); sl.search(7)",
        "isHidden": false,
        "description": "Search for non-existing element"
      },
      {
        "input": "sl = SkipList(); [sl.insert(i) for i in range(10)]; sl.search(5)",
        "isHidden": false,
        "description": "Multiple insertions"
      }
    ],
    "hints": [
      "Skip list has multiple levels, each acting as an express lane",
      "Use random level generation with probability p",
      "Maintain forward pointers at each level",
      "Search by starting at highest level and descending",
      "Expected time complexity is O(log n) for all operations"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Treap Implementation",
    "difficulty": 4,
    "description": "Implement a treap (tree + heap), a randomized BST where each node has a random priority to maintain balance.",
    "starterCode": "import random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def rotate_right(self, node):\n        \"\"\"Perform right rotation.\"\"\"\n        # Your code here\n        pass\n\n    def rotate_left(self, node):\n        \"\"\"Perform left rotation.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, key):\n        \"\"\"Insert key into treap.\"\"\"\n        # Your code here\n        pass\n\n    def search(self, key):\n        \"\"\"Search for key in treap.\"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def rotate_right(self, node):\n        \"\"\"Perform right rotation.\"\"\"\n        left_child = node.left\n        node.left = left_child.right\n        left_child.right = node\n        return left_child\n\n    def rotate_left(self, node):\n        \"\"\"Perform left rotation.\"\"\"\n        right_child = node.right\n        node.right = right_child.left\n        right_child.left = node\n        return right_child\n\n    def _insert(self, node, key):\n        \"\"\"Helper method to insert key.\"\"\"\n        if node is None:\n            return TreapNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n            # Maintain heap property\n            if node.left.priority > node.priority:\n                node = self.rotate_right(node)\n        else:\n            node.right = self._insert(node.right, key)\n            # Maintain heap property\n            if node.right.priority > node.priority:\n                node = self.rotate_left(node)\n\n        return node\n\n    def insert(self, key):\n        \"\"\"Insert key into treap.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _search(self, node, key):\n        \"\"\"Helper method to search.\"\"\"\n        if node is None:\n            return False\n        if node.key == key:\n            return True\n        elif key < node.key:\n            return self._search(node.left, key)\n        else:\n            return self._search(node.right, key)\n\n    def search(self, key):\n        \"\"\"Search for key in treap.\"\"\"\n        return self._search(self.root, key)",
    "testCases": [
      {
        "input": "t = Treap(); t.insert(5); t.insert(3); t.insert(7); t.search(3)",
        "isHidden": false,
        "description": "Basic insertion and search"
      },
      {
        "input": "t = Treap(); [t.insert(i) for i in [1,2,3,4,5]]; t.search(3)",
        "isHidden": false,
        "description": "Sequential insertions (would unbalance regular BST)"
      },
      {
        "input": "t = Treap(); t.insert(10); t.search(5)",
        "isHidden": false,
        "description": "Search for non-existing key"
      }
    ],
    "hints": [
      "Treap maintains BST property by keys and heap property by random priorities",
      "Insert as in BST, then rotate to maintain heap property",
      "Rotations preserve BST property while fixing heap violations",
      "Random priorities ensure expected O(log n) height",
      "Use right rotation when left child priority > parent priority"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Min-Cut",
    "difficulty": 5,
    "description": "Implement Karger's randomized algorithm to find the minimum cut in an undirected graph.",
    "starterCode": "import random\n\ndef karger_min_cut(graph, iterations=100):\n    \"\"\"\n    Find minimum cut using Karger's randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n        iterations: Number of times to repeat the algorithm.\n\n    Returns:\n        int: Size of minimum cut found.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef karger_min_cut(graph, iterations=100):\n    \"\"\"\n    Find minimum cut using Karger's randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n        iterations: Number of times to repeat the algorithm.\n\n    Returns:\n        int: Size of minimum cut found.\n    \"\"\"\n    def contract_edge(g):\n        \"\"\"Contract a random edge in the graph.\"\"\"\n        # Make a copy\n        g = {k: v[:] for k, v in g.items()}\n\n        while len(g) > 2:\n            # Pick random edge\n            u = random.choice(list(g.keys()))\n            v = random.choice(g[u])\n\n            # Merge v into u\n            g[u].extend(g[v])\n\n            # Update all edges pointing to v to point to u\n            for node in g[v]:\n                g[node] = [u if x == v else x for x in g[node]]\n\n            # Remove self-loops\n            g[u] = [x for x in g[u] if x != u]\n\n            # Remove v\n            del g[v]\n\n        # Return size of cut\n        return len(list(g.values())[0])\n\n    min_cut = float('inf')\n\n    for _ in range(iterations):\n        cut_size = contract_edge(graph)\n        min_cut = min(min_cut, cut_size)\n\n    return min_cut",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}, iterations = 50",
        "isHidden": false,
        "description": "Triangle graph - min cut is 2"
      },
      {
        "input": "graph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}, iterations = 50",
        "isHidden": false,
        "description": "Square graph - min cut is 2"
      },
      {
        "input": "graph = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, iterations = 50",
        "isHidden": false,
        "description": "Path graph - min cut is 1"
      }
    ],
    "hints": [
      "Repeatedly contract random edges until 2 vertices remain",
      "Contracting edge (u,v) means merging v into u",
      "Update all edges pointing to v to point to u instead",
      "Remove self-loops after contraction",
      "Run multiple iterations and take minimum (success probability increases)",
      "With O(n^2 log n) iterations, high probability of finding min cut"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Las Vegas Algorithm - Random Binary Search",
    "difficulty": 2,
    "description": "Implement a Las Vegas algorithm for binary search that always returns correct result but has randomized runtime.",
    "starterCode": "import random\n\ndef las_vegas_binary_search(arr, target):\n    \"\"\"\n    Las Vegas binary search - always correct, randomized runtime.\n\n    Args:\n        arr: Sorted list of elements.\n        target: Element to find.\n\n    Returns:\n        int: Index of target, or -1 if not found.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef las_vegas_binary_search(arr, target):\n    \"\"\"\n    Las Vegas binary search - always correct, randomized runtime.\n\n    Args:\n        arr: Sorted list of elements.\n        target: Element to find.\n\n    Returns:\n        int: Index of target, or -1 if not found.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        # Randomly choose mid point instead of (left + right) // 2\n        mid = random.randint(left, right)\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1",
    "testCases": [
      {
        "input": "arr = [1, 3, 5, 7, 9, 11, 13], target = 7",
        "isHidden": false,
        "description": "Find element in middle"
      },
      {
        "input": "arr = [2, 4, 6, 8, 10, 12, 14, 16], target = 2",
        "isHidden": false,
        "description": "Find first element"
      },
      {
        "input": "arr = [1, 2, 3, 4, 5], target = 6",
        "isHidden": false,
        "description": "Element not in array"
      }
    ],
    "hints": [
      "Las Vegas algorithms always produce correct output",
      "Runtime is randomized, not the output",
      "Choose random midpoint instead of deterministic (left + right) // 2",
      "Expected runtime is still O(log n)",
      "Worst case runtime could be O(n) with bad luck"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Monte Carlo Pi Estimation",
    "difficulty": 1,
    "description": "Use Monte Carlo method to estimate π by randomly sampling points in a unit square.",
    "starterCode": "import random\n\ndef estimate_pi(num_samples):\n    \"\"\"\n    Estimate pi using Monte Carlo method.\n\n    Args:\n        num_samples: Number of random points to sample.\n\n    Returns:\n        float: Estimate of pi.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef estimate_pi(num_samples):\n    \"\"\"\n    Estimate pi using Monte Carlo method.\n\n    Args:\n        num_samples: Number of random points to sample.\n\n    Returns:\n        float: Estimate of pi.\n    \"\"\"\n    inside_circle = 0\n\n    for _ in range(num_samples):\n        # Random point in unit square [0,1] x [0,1]\n        x = random.random()\n        y = random.random()\n\n        # Check if point is inside unit circle\n        if x*x + y*y <= 1:\n            inside_circle += 1\n\n    # Area of quarter circle / Area of unit square = pi/4\n    return 4 * inside_circle / num_samples",
    "testCases": [
      {
        "input": "num_samples = 10000",
        "isHidden": false,
        "description": "Estimate with 10,000 samples"
      },
      {
        "input": "num_samples = 100000",
        "isHidden": false,
        "description": "More samples = better estimate"
      },
      {
        "input": "num_samples = 1000",
        "isHidden": false,
        "description": "Fewer samples = less accurate"
      }
    ],
    "hints": [
      "Sample random points (x, y) in unit square [0,1] x [0,1]",
      "Check if point is inside unit circle: x^2 + y^2 <= 1",
      "Ratio of points inside circle to total points ≈ π/4",
      "Multiply by 4 to get π estimate",
      "More samples give better approximation"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Load Balancing",
    "difficulty": 2,
    "description": "Implement randomized load balancing where jobs are assigned to random servers.",
    "starterCode": "import random\n\ndef randomized_load_balance(jobs, num_servers):\n    \"\"\"\n    Assign jobs to servers randomly and compute max load.\n\n    Args:\n        jobs: List of job IDs.\n        num_servers: Number of servers available.\n\n    Returns:\n        tuple: (server_loads dict, max_load)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_load_balance(jobs, num_servers):\n    \"\"\"\n    Assign jobs to servers randomly and compute max load.\n\n    Args:\n        jobs: List of job IDs.\n        num_servers: Number of servers available.\n\n    Returns:\n        tuple: (server_loads dict, max_load)\n    \"\"\"\n    server_loads = {i: [] for i in range(num_servers)}\n\n    for job in jobs:\n        # Randomly assign to a server\n        server = random.randint(0, num_servers - 1)\n        server_loads[server].append(job)\n\n    max_load = max(len(server_loads[i]) for i in range(num_servers))\n\n    return server_loads, max_load",
    "testCases": [
      {
        "input": "jobs = list(range(100)), num_servers = 10",
        "isHidden": false,
        "description": "100 jobs, 10 servers - expected max load ~ 10-15"
      },
      {
        "input": "jobs = list(range(50)), num_servers = 5",
        "isHidden": false,
        "description": "50 jobs, 5 servers"
      },
      {
        "input": "jobs = list(range(20)), num_servers = 4",
        "isHidden": false,
        "description": "20 jobs, 4 servers"
      }
    ],
    "hints": [
      "Assign each job to a uniformly random server",
      "Expected max load is O(n/m + log m) with high probability",
      "Simple strategy but effective in practice",
      "Can be improved with power-of-two-choices strategy"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Hash Table",
    "difficulty": 3,
    "description": "Implement a hash table with universal hashing to minimize collisions.",
    "starterCode": "import random\n\nclass RandomizedHashTable:\n    def __init__(self, size):\n        \"\"\"\n        Initialize hash table with universal hashing.\n\n        Args:\n            size: Size of hash table.\n        \"\"\"\n        # Your code here\n        pass\n\n    def _hash(self, key):\n        \"\"\"Universal hash function.\"\"\"\n        # Your code here\n        pass\n\n    def insert(self, key, value):\n        \"\"\"Insert key-value pair.\"\"\"\n        # Your code here\n        pass\n\n    def get(self, key):\n        \"\"\"Get value for key.\"\"\"\n        # Your code here\n        pass",
    "solution": "import random\n\nclass RandomizedHashTable:\n    def __init__(self, size):\n        \"\"\"\n        Initialize hash table with universal hashing.\n\n        Args:\n            size: Size of hash table.\n        \"\"\"\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        # Random parameters for universal hashing\n        self.a = random.randint(1, size - 1)\n        self.b = random.randint(0, size - 1)\n        self.prime = 1000000007  # Large prime\n\n    def _hash(self, key):\n        \"\"\"Universal hash function: ((a*key + b) mod prime) mod size.\"\"\"\n        return ((self.a * hash(key) + self.b) % self.prime) % self.size\n\n    def insert(self, key, value):\n        \"\"\"Insert key-value pair.\"\"\"\n        index = self._hash(key)\n        # Check if key already exists\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index][i] = (key, value)\n                return\n        # Add new key-value pair\n        self.table[index].append((key, value))\n\n    def get(self, key):\n        \"\"\"Get value for key.\"\"\"\n        index = self._hash(key)\n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        return None",
    "testCases": [
      {
        "input": "ht = RandomizedHashTable(10); ht.insert(\"a\", 1); ht.insert(\"b\", 2); ht.get(\"a\")",
        "isHidden": false,
        "description": "Basic insert and get"
      },
      {
        "input": "ht = RandomizedHashTable(5); [ht.insert(i, i*2) for i in range(10)]; ht.get(5)",
        "isHidden": false,
        "description": "Multiple insertions with collisions"
      },
      {
        "input": "ht = RandomizedHashTable(10); ht.insert(\"x\", 10); ht.get(\"y\")",
        "isHidden": false,
        "description": "Get non-existing key"
      }
    ],
    "hints": [
      "Universal hashing: h(k) = ((ak + b) mod p) mod m",
      "Choose random a, b for each hash table instance",
      "Use chaining to handle collisions",
      "Expected chain length is O(1 + α) where α = n/m",
      "Randomization ensures good expected performance"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Median of Medians",
    "difficulty": 3,
    "description": "Implement a randomized version of the median of medians algorithm for deterministic pivot selection.",
    "starterCode": "import random\n\ndef randomized_select_good_pivot(arr):\n    \"\"\"\n    Select a good pivot using randomized sampling.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        A pivot element that splits the array reasonably.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_select_good_pivot(arr):\n    \"\"\"\n    Select a good pivot using randomized sampling.\n\n    Args:\n        arr: List of comparable elements.\n\n    Returns:\n        A pivot element that splits the array reasonably.\n    \"\"\"\n    if len(arr) <= 5:\n        return sorted(arr)[len(arr) // 2]\n\n    # Sample sqrt(n) elements randomly\n    sample_size = int(len(arr) ** 0.5)\n    sample = random.sample(arr, min(sample_size, len(arr)))\n\n    # Return median of sample\n    sample.sort()\n    return sample[len(sample) // 2]",
    "testCases": [
      {
        "input": "arr = list(range(100))",
        "isHidden": false,
        "description": "Select pivot from sorted array"
      },
      {
        "input": "arr = [random.randint(1, 1000) for _ in range(100)]",
        "isHidden": false,
        "description": "Random array of 100 elements"
      },
      {
        "input": "arr = [5, 5, 5, 5, 5]",
        "isHidden": false,
        "description": "All elements equal"
      }
    ],
    "hints": [
      "Sample sqrt(n) random elements from array",
      "Find median of the sample",
      "This gives a good pivot with high probability",
      "Simpler than deterministic median-of-medians",
      "Expected time is still O(n)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Graph Coloring",
    "difficulty": 4,
    "description": "Implement a randomized algorithm for graph coloring that uses O(Δ+1) colors where Δ is max degree.",
    "starterCode": "import random\n\ndef randomized_graph_coloring(graph):\n    \"\"\"\n    Color graph vertices using randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n\n    Returns:\n        dict: Mapping from vertices to colors (integers).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef randomized_graph_coloring(graph):\n    \"\"\"\n    Color graph vertices using randomized algorithm.\n\n    Args:\n        graph: Dictionary where graph[u] is list of neighbors of u.\n\n    Returns:\n        dict: Mapping from vertices to colors (integers).\n    \"\"\"\n    vertices = list(graph.keys())\n    # Randomize order of coloring\n    random.shuffle(vertices)\n\n    colors = {}\n    max_degree = max(len(neighbors) for neighbors in graph.values()) if graph else 0\n\n    for vertex in vertices:\n        # Find colors used by neighbors\n        neighbor_colors = {colors[neighbor] for neighbor in graph[vertex] if neighbor in colors}\n\n        # Assign first available color\n        color = 0\n        while color in neighbor_colors:\n            color += 1\n\n        colors[vertex] = color\n\n    return colors",
    "testCases": [
      {
        "input": "graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}",
        "isHidden": false,
        "description": "Triangle - needs 3 colors"
      },
      {
        "input": "graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}",
        "isHidden": false,
        "description": "Square - needs 2 colors"
      },
      {
        "input": "graph = {0: [1, 2, 3], 1: [0], 2: [0], 3: [0]}",
        "isHidden": false,
        "description": "Star graph - needs 2 colors"
      }
    ],
    "hints": [
      "Process vertices in random order",
      "For each vertex, assign smallest color not used by neighbors",
      "Randomization can lead to better coloring in practice",
      "Guaranteed to use at most Δ+1 colors",
      "Can be repeated multiple times to find better coloring"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Approximate Median",
    "difficulty": 2,
    "description": "Find an approximate median by sampling, returning an element that is close to the true median.",
    "starterCode": "import random\n\ndef approximate_median(arr, sample_size_factor=0.1):\n    \"\"\"\n    Find approximate median using random sampling.\n\n    Args:\n        arr: List of comparable elements.\n        sample_size_factor: Fraction of array to sample.\n\n    Returns:\n        An element that is approximately the median.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef approximate_median(arr, sample_size_factor=0.1):\n    \"\"\"\n    Find approximate median using random sampling.\n\n    Args:\n        arr: List of comparable elements.\n        sample_size_factor: Fraction of array to sample.\n\n    Returns:\n        An element that is approximately the median.\n    \"\"\"\n    # Sample random elements\n    sample_size = max(1, int(len(arr) * sample_size_factor))\n    sample = random.sample(arr, sample_size)\n\n    # Return median of sample\n    sample.sort()\n    return sample[len(sample) // 2]",
    "testCases": [
      {
        "input": "arr = list(range(1000)), sample_size_factor = 0.1",
        "isHidden": false,
        "description": "Large sorted array"
      },
      {
        "input": "arr = [random.randint(1, 100) for _ in range(500)], sample_size_factor = 0.2",
        "isHidden": false,
        "description": "Random array with larger sample"
      },
      {
        "input": "arr = [5] * 100, sample_size_factor = 0.1",
        "isHidden": false,
        "description": "All elements equal"
      }
    ],
    "hints": [
      "Sample a small fraction of the array",
      "Sort the sample and return its median",
      "Result is approximately the true median with high probability",
      "Much faster than finding exact median for large arrays",
      "Trade accuracy for speed"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t3-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-3",
    "title": "Randomized Coupon Collector",
    "difficulty": 3,
    "description": "Simulate the coupon collector problem: how many random samples needed to collect all n distinct items?",
    "starterCode": "import random\n\ndef coupon_collector(n, num_simulations=1000):\n    \"\"\"\n    Simulate coupon collector problem.\n\n    Args:\n        n: Number of distinct coupons.\n        num_simulations: Number of times to run simulation.\n\n    Returns:\n        float: Average number of samples needed to collect all coupons.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "import random\n\ndef coupon_collector(n, num_simulations=1000):\n    \"\"\"\n    Simulate coupon collector problem.\n\n    Args:\n        n: Number of distinct coupons.\n        num_simulations: Number of times to run simulation.\n\n    Returns:\n        float: Average number of samples needed to collect all coupons.\n    \"\"\"\n    total_samples = 0\n\n    for _ in range(num_simulations):\n        collected = set()\n        samples = 0\n\n        while len(collected) < n:\n            # Draw random coupon\n            coupon = random.randint(0, n - 1)\n            collected.add(coupon)\n            samples += 1\n\n        total_samples += samples\n\n    return total_samples / num_simulations",
    "testCases": [
      {
        "input": "n = 10, num_simulations = 1000",
        "isHidden": false,
        "description": "10 coupons - expected ~29 samples"
      },
      {
        "input": "n = 5, num_simulations = 500",
        "isHidden": false,
        "description": "5 coupons - expected ~12 samples"
      },
      {
        "input": "n = 20, num_simulations = 1000",
        "isHidden": false,
        "description": "20 coupons - expected ~72 samples"
      }
    ],
    "hints": [
      "Keep drawing random coupons until all n are collected",
      "Track collected coupons using a set",
      "Expected number of draws is n * H(n) where H(n) is harmonic number",
      "H(n) ≈ ln(n) + γ ≈ ln(n) + 0.577",
      "Run multiple simulations and average the results"
    ],
    "language": "python"
  }
]

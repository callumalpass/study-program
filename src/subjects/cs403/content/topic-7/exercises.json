[
  {
    "id": "cs403-t7-ex01",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Convex Hull - Graham Scan",
    "difficulty": 4,
    "description": "Implement Graham's scan algorithm to find the convex hull of a set of 2D points in O(n log n) time.",
    "starterCode": "def convex_hull(points):\n    \"\"\"\n    Find convex hull using Graham's scan algorithm.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        list: Points on the convex hull in counterclockwise order.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def convex_hull(points):\n    \"\"\"\n    Find convex hull using Graham's scan algorithm.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        list: Points on the convex hull in counterclockwise order.\n    \"\"\"\n    def cross_product(o, a, b):\n        \"\"\"Calculate cross product of vectors OA and OB.\"\"\"\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    # Sort points lexicographically (first by x, then by y)\n    points = sorted(set(points))\n\n    if len(points) <= 2:\n        return points\n\n    # Build lower hull\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    # Build upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    # Remove last point of each half because it's repeated\n    return lower[:-1] + upper[:-1]",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0)]",
        "isHidden": false,
        "description": "Simple convex hull with some interior points"
      },
      {
        "input": "points = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Square - all points on hull"
      },
      {
        "input": "points = [(0, 0), (3, 3), (1, 1), (2, 2), (4, 4), (0, 4), (4, 0)]",
        "isHidden": false,
        "description": "Points with collinear segments"
      }
    ],
    "hints": [
      "Sort points lexicographically (by x-coordinate, then y-coordinate)",
      "Build lower hull by scanning left to right",
      "Build upper hull by scanning right to left",
      "Use cross product to determine if three points make a left or right turn",
      "Remove points that create right turns (non-convex angles)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex02",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Closest Pair of Points",
    "difficulty": 4,
    "description": "Find the closest pair of points in 2D using divide-and-conquer in O(n log n) time.",
    "starterCode": "def closest_pair(points):\n    \"\"\"\n    Find the closest pair of points using divide-and-conquer.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        tuple: (distance, point1, point2) where distance is the minimum distance.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def closest_pair(points):\n    \"\"\"\n    Find the closest pair of points using divide-and-conquer.\n\n    Args:\n        points: List of (x, y) tuples representing 2D points.\n\n    Returns:\n        tuple: (distance, point1, point2) where distance is the minimum distance.\n    \"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = (None, None)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                d = distance(points[i], points[j])\n                if d < min_dist:\n                    min_dist = d\n                    pair = (points[i], points[j])\n        return min_dist, pair\n\n    def closest_pair_recursive(px, py):\n        n = len(px)\n\n        # Use brute force for small cases\n        if n <= 3:\n            dist, pair = brute_force(px)\n            return dist, pair\n\n        # Divide\n        mid = n // 2\n        midpoint = px[mid]\n\n        # Split points by x-coordinate\n        pyl = [p for p in py if p[0] <= midpoint[0]]\n        pyr = [p for p in py if p[0] > midpoint[0]]\n\n        # Conquer\n        dl, pair_l = closest_pair_recursive(px[:mid], pyl)\n        dr, pair_r = closest_pair_recursive(px[mid:], pyr)\n\n        # Find minimum of two sides\n        d = min(dl, dr)\n        min_pair = pair_l if dl < dr else pair_r\n\n        # Build strip of points closer than d to dividing line\n        strip = [p for p in py if abs(p[0] - midpoint[0]) < d]\n\n        # Check strip for closer pairs\n        for i in range(len(strip)):\n            j = i + 1\n            while j < len(strip) and (strip[j][1] - strip[i][1]) < d:\n                dist = distance(strip[i], strip[j])\n                if dist < d:\n                    d = dist\n                    min_pair = (strip[i], strip[j])\n                j += 1\n\n        return d, min_pair\n\n    # Sort points by x and y coordinates\n    px = sorted(points, key=lambda p: p[0])\n    py = sorted(points, key=lambda p: p[1])\n\n    dist, pair = closest_pair_recursive(px, py)\n    return (dist, pair[0], pair[1])",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 1), (2, 2), (5, 5), (6, 6)]",
        "isHidden": false,
        "description": "Points along a diagonal"
      },
      {
        "input": "points = [(0, 0), (7, 6), (2, 20), (12, 5), (16, 16), (5, 8)]",
        "isHidden": false,
        "description": "Random scattered points"
      },
      {
        "input": "points = [(1, 1), (1, 2), (3, 4), (5, 6)]",
        "isHidden": false,
        "description": "Small set with vertical pair"
      }
    ],
    "hints": [
      "Sort points by x-coordinate and y-coordinate (maintain both orderings)",
      "Divide points by x-coordinate into two halves",
      "Recursively find closest pairs in each half",
      "Check points in the middle strip (within d of dividing line)",
      "For each point in strip, only check next 7 points (geometric property)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex03",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Line Segment Intersection",
    "difficulty": 3,
    "description": "Check if two line segments intersect.",
    "starterCode": "def segments_intersect(p1, q1, p2, q2):\n    \"\"\"\n    Check if line segment p1q1 intersects with line segment p2q2.\n\n    Args:\n        p1, q1: Endpoints of first segment (tuples (x, y)).\n        p2, q2: Endpoints of second segment (tuples (x, y)).\n\n    Returns:\n        bool: True if segments intersect.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def segments_intersect(p1, q1, p2, q2):\n    \"\"\"\n    Check if line segment p1q1 intersects with line segment p2q2.\n\n    Args:\n        p1, q1: Endpoints of first segment (tuples (x, y)).\n        p2, q2: Endpoints of second segment (tuples (x, y)).\n\n    Returns:\n        bool: True if segments intersect.\n    \"\"\"\n    def orientation(p, q, r):\n        \"\"\"\n        Find orientation of ordered triplet (p, q, r).\n        Returns:\n            0: Collinear\n            1: Clockwise\n            2: Counterclockwise\n        \"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val) < 1e-9:\n            return 0\n        return 1 if val > 0 else 2\n\n    def on_segment(p, q, r):\n        \"\"\"Check if point q lies on segment pr (given they are collinear).\"\"\"\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special cases (collinear points)\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False",
    "testCases": [
      {
        "input": "p1 = (0, 0), q1 = (10, 10), p2 = (0, 10), q2 = (10, 0)",
        "isHidden": false,
        "description": "Intersecting segments forming an X"
      },
      {
        "input": "p1 = (0, 0), q1 = (5, 5), p2 = (0, 5), q2 = (5, 0)",
        "isHidden": false,
        "description": "Non-intersecting parallel-ish segments"
      },
      {
        "input": "p1 = (0, 0), q1 = (10, 0), p2 = (5, 0), q2 = (15, 0)",
        "isHidden": false,
        "description": "Collinear overlapping segments"
      }
    ],
    "hints": [
      "Use orientation test to check if points are clockwise, counterclockwise, or collinear",
      "Two segments intersect if orientations differ on both sides",
      "Handle special cases: collinear points",
      "Check if collinear point lies on segment",
      "Orientation test: sign of cross product"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex04",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Point in Polygon",
    "difficulty": 3,
    "description": "Determine if a point lies inside a polygon using ray casting algorithm.",
    "starterCode": "def point_in_polygon(point, polygon):\n    \"\"\"\n    Check if point is inside polygon.\n\n    Args:\n        point: Tuple (x, y).\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if point is inside polygon.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def point_in_polygon(point, polygon):\n    \"\"\"\n    Check if point is inside polygon.\n\n    Args:\n        point: Tuple (x, y).\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if point is inside polygon.\n    \"\"\"\n    x, y = point\n    n = len(polygon)\n    inside = False\n\n    p1x, p1y = polygon[0]\n    for i in range(1, n + 1):\n        p2x, p2y = polygon[i % n]\n\n        # Check if ray from point crosses edge\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n\n        p1x, p1y = p2x, p2y\n\n    return inside",
    "testCases": [
      {
        "input": "point = (5, 5), polygon = [(0, 0), (10, 0), (10, 10), (0, 10)]",
        "isHidden": false,
        "description": "Point inside square"
      },
      {
        "input": "point = (15, 5), polygon = [(0, 0), (10, 0), (10, 10), (0, 10)]",
        "isHidden": false,
        "description": "Point outside square"
      },
      {
        "input": "point = (2, 2), polygon = [(0, 0), (4, 0), (4, 4), (2, 6), (0, 4)]",
        "isHidden": false,
        "description": "Point in non-convex polygon"
      }
    ],
    "hints": [
      "Ray casting algorithm: cast ray from point to infinity",
      "Count how many edges the ray crosses",
      "Odd number of crossings = inside, even = outside",
      "Handle edge cases: ray passing through vertex",
      "Works for both convex and non-convex polygons"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex05",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Jarvis March (Gift Wrapping)",
    "difficulty": 3,
    "description": "Implement Jarvis march algorithm for convex hull in O(nh) time.",
    "starterCode": "def jarvis_march(points):\n    \"\"\"\n    Find convex hull using Jarvis march (gift wrapping) algorithm.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        list: Points on convex hull in counterclockwise order.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def jarvis_march(points):\n    \"\"\"\n    Find convex hull using Jarvis march (gift wrapping) algorithm.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        list: Points on convex hull in counterclockwise order.\n    \"\"\"\n    n = len(points)\n    if n < 3:\n        return points\n\n    def orientation(p, q, r):\n        \"\"\"Return orientation: 0=collinear, 1=clockwise, 2=counterclockwise.\"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val) < 1e-9:\n            return 0\n        return 1 if val > 0 else 2\n\n    # Find leftmost point\n    leftmost = min(range(n), key=lambda i: (points[i][0], points[i][1]))\n\n    hull = []\n    current = leftmost\n\n    while True:\n        hull.append(points[current])\n\n        # Find most counterclockwise point from current\n        next_point = (current + 1) % n\n        for i in range(n):\n            if orientation(points[current], points[i], points[next_point]) == 2:\n                next_point = i\n\n        current = next_point\n\n        # Stop when we return to starting point\n        if current == leftmost:\n            break\n\n    return hull",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0), (1, 0.5)]",
        "isHidden": false,
        "description": "Points with some interior"
      },
      {
        "input": "points = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Square"
      },
      {
        "input": "points = [(0, 0), (2, 1), (1, 2), (0, 2)]",
        "isHidden": false,
        "description": "Irregular quadrilateral"
      }
    ],
    "hints": [
      "Start from leftmost point (guaranteed to be on hull)",
      "At each step, find most counterclockwise point",
      "Use orientation test to compare angles",
      "Wrap around the hull like wrapping a gift",
      "Stop when returning to start point",
      "Time complexity: O(nh) where h is hull size"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex06",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Area of Polygon",
    "difficulty": 1,
    "description": "Calculate the area of a polygon using the shoelace formula.",
    "starterCode": "def polygon_area(vertices):\n    \"\"\"\n    Calculate area of polygon using shoelace formula.\n\n    Args:\n        vertices: List of (x, y) tuples in order (clockwise or counterclockwise).\n\n    Returns:\n        float: Area of polygon.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def polygon_area(vertices):\n    \"\"\"\n    Calculate area of polygon using shoelace formula.\n\n    Args:\n        vertices: List of (x, y) tuples in order (clockwise or counterclockwise).\n\n    Returns:\n        float: Area of polygon.\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n\n    return abs(area) / 2.0",
    "testCases": [
      {
        "input": "vertices = [(0, 0), (4, 0), (4, 3), (0, 3)]",
        "isHidden": false,
        "description": "Rectangle: 4 x 3 = 12"
      },
      {
        "input": "vertices = [(0, 0), (2, 0), (1, 2)]",
        "isHidden": false,
        "description": "Triangle: area = 2"
      },
      {
        "input": "vertices = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Unit square: area = 1"
      }
    ],
    "hints": [
      "Shoelace formula: sum of (x_i * y_{i+1} - x_{i+1} * y_i)",
      "Divide result by 2 and take absolute value",
      "Works for any simple polygon (no self-intersections)",
      "Order of vertices matters for sign, but we take abs",
      "Also known as surveyor's formula"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex07",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Convex Polygon Check",
    "difficulty": 2,
    "description": "Determine if a polygon is convex.",
    "starterCode": "def is_convex(polygon):\n    \"\"\"\n    Check if polygon is convex.\n\n    Args:\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if polygon is convex.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def is_convex(polygon):\n    \"\"\"\n    Check if polygon is convex.\n\n    Args:\n        polygon: List of vertices [(x1, y1), (x2, y2), ...] in order.\n\n    Returns:\n        bool: True if polygon is convex.\n    \"\"\"\n    def cross_product_sign(o, a, b):\n        \"\"\"Return sign of cross product of vectors OA and OB.\"\"\"\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    n = len(polygon)\n    if n < 3:\n        return False\n\n    sign = None\n\n    for i in range(n):\n        o = polygon[i]\n        a = polygon[(i + 1) % n]\n        b = polygon[(i + 2) % n]\n\n        cross = cross_product_sign(o, a, b)\n\n        if abs(cross) > 1e-9:  # Not collinear\n            if sign is None:\n                sign = cross > 0\n            elif (cross > 0) != sign:\n                return False  # Sign changed = not convex\n\n    return True",
    "testCases": [
      {
        "input": "polygon = [(0, 0), (2, 0), (2, 2), (0, 2)]",
        "isHidden": false,
        "description": "Square - convex"
      },
      {
        "input": "polygon = [(0, 0), (2, 0), (2, 2), (1, 1), (0, 2)]",
        "isHidden": false,
        "description": "Non-convex polygon (has reflex angle)"
      },
      {
        "input": "polygon = [(0, 0), (1, 0), (2, 1), (1, 2), (0, 1)]",
        "isHidden": false,
        "description": "Convex pentagon"
      }
    ],
    "hints": [
      "For each consecutive triple of vertices, compute cross product",
      "If all cross products have same sign, polygon is convex",
      "If signs differ, there is a reflex angle (not convex)",
      "Cross product tells if turn is left or right",
      "Ignore collinear points (cross product = 0)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex08",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "2D Range Query",
    "difficulty": 3,
    "description": "Find all points within a rectangular range.",
    "starterCode": "def range_query(points, rect):\n    \"\"\"\n    Find all points within rectangular range.\n\n    Args:\n        points: List of (x, y) tuples.\n        rect: Tuple (x_min, y_min, x_max, y_max).\n\n    Returns:\n        list: Points inside rectangle.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def range_query(points, rect):\n    \"\"\"\n    Find all points within rectangular range.\n\n    Args:\n        points: List of (x, y) tuples.\n        rect: Tuple (x_min, y_min, x_max, y_max).\n\n    Returns:\n        list: Points inside rectangle.\n    \"\"\"\n    x_min, y_min, x_max, y_max = rect\n    result = []\n\n    for x, y in points:\n        if x_min <= x <= x_max and y_min <= y <= y_max:\n            result.append((x, y))\n\n    return result",
    "testCases": [
      {
        "input": "points = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], rect = (2, 2, 4, 4)",
        "isHidden": false,
        "description": "Points in and out of range"
      },
      {
        "input": "points = [(0, 0), (10, 10), (5, 5)], rect = (3, 3, 7, 7)",
        "isHidden": false,
        "description": "Single point in range"
      },
      {
        "input": "points = [(1, 1), (2, 2), (3, 3)], rect = (5, 5, 10, 10)",
        "isHidden": false,
        "description": "No points in range"
      }
    ],
    "hints": [
      "Simple approach: check each point individually",
      "Point (x, y) is inside if x_min ≤ x ≤ x_max and y_min ≤ y ≤ y_max",
      "Time complexity: O(n) for n points",
      "For better performance, use data structures like kd-tree or range tree",
      "This is orthogonal range searching problem"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex09",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Line Sweep - Rectangle Intersection",
    "difficulty": 4,
    "description": "Find if any pair of axis-aligned rectangles intersect using line sweep.",
    "starterCode": "def rectangles_intersect(rectangles):\n    \"\"\"\n    Check if any two rectangles intersect using line sweep.\n\n    Args:\n        rectangles: List of rectangles [(x1, y1, x2, y2), ...] where (x1,y1) is bottom-left.\n\n    Returns:\n        bool: True if any two rectangles intersect.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def rectangles_intersect(rectangles):\n    \"\"\"\n    Check if any two rectangles intersect using line sweep.\n\n    Args:\n        rectangles: List of rectangles [(x1, y1, x2, y2), ...] where (x1,y1) is bottom-left.\n\n    Returns:\n        bool: True if any two rectangles intersect.\n    \"\"\"\n    # Create events: (x, type, rect_index, y1, y2)\n    # type: 0=start, 1=end\n    events = []\n\n    for i, (x1, y1, x2, y2) in enumerate(rectangles):\n        events.append((x1, 0, i, y1, y2))  # Start\n        events.append((x2, 1, i, y1, y2))  # End\n\n    # Sort by x-coordinate\n    events.sort()\n\n    # Active rectangles: dict of index -> (y1, y2)\n    active = {}\n\n    for x, event_type, idx, y1, y2 in events:\n        if event_type == 0:  # Start\n            # Check if new rectangle intersects with any active\n            for other_idx, (other_y1, other_y2) in active.items():\n                # Check y-interval overlap\n                if not (y2 < other_y1 or y1 > other_y2):\n                    return True\n            active[idx] = (y1, y2)\n        else:  # End\n            if idx in active:\n                del active[idx]\n\n    return False",
    "testCases": [
      {
        "input": "rectangles = [(0, 0, 2, 2), (1, 1, 3, 3)]",
        "isHidden": false,
        "description": "Two overlapping rectangles"
      },
      {
        "input": "rectangles = [(0, 0, 1, 1), (2, 2, 3, 3)]",
        "isHidden": false,
        "description": "Two non-overlapping rectangles"
      },
      {
        "input": "rectangles = [(0, 0, 2, 2), (1, 0, 3, 2), (2, 0, 4, 2)]",
        "isHidden": false,
        "description": "Multiple rectangles with overlaps"
      }
    ],
    "hints": [
      "Sweep vertical line from left to right",
      "Maintain set of active rectangles (those intersected by sweep line)",
      "When rectangle starts, check if it overlaps with active rectangles",
      "Two rectangles overlap if x-intervals and y-intervals both overlap",
      "Events: rectangle start and end",
      "Check y-interval overlap: not (y1_max < y2_min or y1_min > y2_max)"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex10",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Polygon Triangulation",
    "difficulty": 5,
    "description": "Triangulate a simple polygon using ear clipping method.",
    "starterCode": "def triangulate_polygon(polygon):\n    \"\"\"\n    Triangulate simple polygon using ear clipping.\n\n    Args:\n        polygon: List of vertices [(x1, y1), ...] in counterclockwise order.\n\n    Returns:\n        list: List of triangles [(p1, p2, p3), ...].\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def triangulate_polygon(polygon):\n    \"\"\"\n    Triangulate simple polygon using ear clipping.\n\n    Args:\n        polygon: List of vertices [(x1, y1), ...] in counterclockwise order.\n\n    Returns:\n        list: List of triangles [(p1, p2, p3), ...].\n    \"\"\"\n    def cross_product(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    def point_in_triangle(p, a, b, c):\n        \"\"\"Check if point p is inside triangle abc.\"\"\"\n        v0 = (c[0] - a[0], c[1] - a[1])\n        v1 = (b[0] - a[0], b[1] - a[1])\n        v2 = (p[0] - a[0], p[1] - a[1])\n\n        dot00 = v0[0] * v0[0] + v0[1] * v0[1]\n        dot01 = v0[0] * v1[0] + v0[1] * v1[1]\n        dot02 = v0[0] * v2[0] + v0[1] * v2[1]\n        dot11 = v1[0] * v1[0] + v1[1] * v1[1]\n        dot12 = v1[0] * v2[0] + v1[1] * v2[1]\n\n        inv_denom = 1 / (dot00 * dot11 - dot01 * dot01)\n        u = (dot11 * dot02 - dot01 * dot12) * inv_denom\n        v = (dot00 * dot12 - dot01 * dot02) * inv_denom\n\n        return (u >= 0) and (v >= 0) and (u + v <= 1)\n\n    def is_ear(polygon, i):\n        \"\"\"Check if vertex i forms an ear.\"\"\"\n        n = len(polygon)\n        prev = polygon[(i - 1) % n]\n        curr = polygon[i]\n        next = polygon[(i + 1) % n]\n\n        # Check if convex\n        if cross_product(prev, curr, next) <= 0:\n            return False\n\n        # Check if no other vertex is inside triangle\n        for j in range(n):\n            if j == i or j == (i - 1) % n or j == (i + 1) % n:\n                continue\n            if point_in_triangle(polygon[j], prev, curr, next):\n                return False\n\n        return True\n\n    triangles = []\n    vertices = list(polygon)\n\n    while len(vertices) > 3:\n        n = len(vertices)\n        ear_found = False\n\n        for i in range(n):\n            if is_ear(vertices, i):\n                # Cut off ear\n                prev = vertices[(i - 1) % n]\n                curr = vertices[i]\n                next = vertices[(i + 1) % n]\n\n                triangles.append((prev, curr, next))\n                vertices.pop(i)\n                ear_found = True\n                break\n\n        if not ear_found:\n            break  # Failed to triangulate\n\n    if len(vertices) == 3:\n        triangles.append(tuple(vertices))\n\n    return triangles",
    "testCases": [
      {
        "input": "polygon = [(0, 0), (4, 0), (4, 3), (0, 3)]",
        "isHidden": false,
        "description": "Rectangle - 2 triangles"
      },
      {
        "input": "polygon = [(0, 0), (2, 0), (3, 2), (1, 3), (0, 2)]",
        "isHidden": false,
        "description": "Pentagon - 3 triangles"
      },
      {
        "input": "polygon = [(0, 0), (1, 0), (1, 1)]",
        "isHidden": false,
        "description": "Already a triangle"
      }
    ],
    "hints": [
      "Ear clipping: find convex vertex (ear) and cut it off",
      "Ear: three consecutive vertices where triangle contains no other vertices",
      "Check if vertex is convex using cross product",
      "For each convex vertex, check if triangle contains other vertices",
      "Repeat until only one triangle remains",
      "Time complexity: O(n^2) for simple ear clipping"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex11",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Rotating Calipers - Diameter",
    "difficulty": 4,
    "description": "Find the diameter of a convex polygon using rotating calipers.",
    "starterCode": "def convex_polygon_diameter(polygon):\n    \"\"\"\n    Find diameter (maximum distance between any two vertices) of convex polygon.\n\n    Args:\n        polygon: List of vertices in counterclockwise order (convex hull).\n\n    Returns:\n        tuple: (max_distance, point1, point2)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def convex_polygon_diameter(polygon):\n    \"\"\"\n    Find diameter (maximum distance between any two vertices) of convex polygon.\n\n    Args:\n        polygon: List of vertices in counterclockwise order (convex hull).\n\n    Returns:\n        tuple: (max_distance, point1, point2)\n    \"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    n = len(polygon)\n    if n < 2:\n        return 0, None, None\n\n    # Find initial antipodal pair\n    k = 1\n    while distance(polygon[k + 1], polygon[0]) > distance(polygon[k], polygon[0]):\n        k += 1\n\n    max_dist = 0\n    best_pair = (polygon[0], polygon[k])\n\n    i, j = 0, k\n\n    # Rotate calipers\n    for _ in range(n):\n        # Check current pair\n        dist = distance(polygon[i], polygon[j])\n        if dist > max_dist:\n            max_dist = dist\n            best_pair = (polygon[i], polygon[j])\n\n        # Rotate caliper\n        # Check which edge to advance along\n        i_next = (i + 1) % n\n        j_next = (j + 1) % n\n\n        # Vector from i to i_next\n        v1 = (polygon[i_next][0] - polygon[i][0], polygon[i_next][1] - polygon[i][1])\n        # Vector from j to j_next\n        v2 = (polygon[j_next][0] - polygon[j][0], polygon[j_next][1] - polygon[j][1])\n\n        # Cross product determines which to advance\n        cross = v1[0] * v2[1] - v1[1] * v2[0]\n\n        if cross < 0:\n            i = i_next\n        else:\n            j = j_next\n\n    return max_dist, best_pair[0], best_pair[1]",
    "testCases": [
      {
        "input": "polygon = [(0, 0), (4, 0), (4, 3), (0, 3)]",
        "isHidden": false,
        "description": "Rectangle - diameter is diagonal"
      },
      {
        "input": "polygon = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Unit square"
      },
      {
        "input": "polygon = [(0, 0), (3, 0), (3, 3), (1, 4), (0, 3)]",
        "isHidden": false,
        "description": "Convex pentagon"
      }
    ],
    "hints": [
      "Rotating calipers: rotate two parallel lines around convex hull",
      "Diameter is between antipodal pair of vertices",
      "Start with initial antipodal pair",
      "Rotate calipers by advancing along edges",
      "Check distance at each step",
      "O(n) time for convex polygon"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex12",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Voronoi Cell",
    "difficulty": 5,
    "description": "Find which site a query point belongs to in Voronoi diagram (nearest neighbor).",
    "starterCode": "def nearest_site(query, sites):\n    \"\"\"\n    Find nearest site to query point (Voronoi cell membership).\n\n    Args:\n        query: Query point (x, y).\n        sites: List of site points [(x1, y1), (x2, y2), ...].\n\n    Returns:\n        tuple: (nearest_site, distance)\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def nearest_site(query, sites):\n    \"\"\"\n    Find nearest site to query point (Voronoi cell membership).\n\n    Args:\n        query: Query point (x, y).\n        sites: List of site points [(x1, y1), (x2, y2), ...].\n\n    Returns:\n        tuple: (nearest_site, distance)\n    \"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    if not sites:\n        return None, float('inf')\n\n    min_dist = float('inf')\n    nearest = None\n\n    for site in sites:\n        dist = distance(query, site)\n        if dist < min_dist:\n            min_dist = dist\n            nearest = site\n\n    return nearest, min_dist",
    "testCases": [
      {
        "input": "query = (2, 2), sites = [(0, 0), (5, 5), (0, 5)]",
        "isHidden": false,
        "description": "Find nearest site"
      },
      {
        "input": "query = (1, 1), sites = [(0, 0), (2, 2), (0, 2)]",
        "isHidden": false,
        "description": "Query near one site"
      },
      {
        "input": "query = (5, 5), sites = [(0, 0), (10, 10)]",
        "isHidden": false,
        "description": "Query equidistant to two sites"
      }
    ],
    "hints": [
      "Voronoi cell: region of points closest to a particular site",
      "Simple approach: compute distance to all sites",
      "Return site with minimum distance",
      "O(n) time for n sites",
      "For faster queries, preprocess Voronoi diagram",
      "This is nearest neighbor search"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex13",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Circle-Circle Intersection",
    "difficulty": 2,
    "description": "Find intersection points of two circles.",
    "starterCode": "def circle_intersection(c1, r1, c2, r2):\n    \"\"\"\n    Find intersection points of two circles.\n\n    Args:\n        c1, c2: Centers (x, y) of circles.\n        r1, r2: Radii of circles.\n\n    Returns:\n        list: Intersection points [(x1, y1), (x2, y2)] or empty if no intersection.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def circle_intersection(c1, r1, c2, r2):\n    \"\"\"\n    Find intersection points of two circles.\n\n    Args:\n        c1, c2: Centers (x, y) of circles.\n        r1, r2: Radii of circles.\n\n    Returns:\n        list: Intersection points [(x1, y1), (x2, y2)] or empty if no intersection.\n    \"\"\"\n    import math\n\n    x1, y1 = c1\n    x2, y2 = c2\n\n    # Distance between centers\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    # Check if circles intersect\n    if d > r1 + r2:  # Too far apart\n        return []\n    if d < abs(r1 - r2):  # One inside other\n        return []\n    if d == 0 and r1 == r2:  # Same circle\n        return []  # Infinite intersections\n\n    # Calculate intersection points\n    a = (r1**2 - r2**2 + d**2) / (2 * d)\n    h = math.sqrt(r1**2 - a**2)\n\n    # Point on line between centers\n    px = x1 + a * (x2 - x1) / d\n    py = y1 + a * (y2 - y1) / d\n\n    # Intersection points\n    ix1 = px + h * (y2 - y1) / d\n    iy1 = py - h * (x2 - x1) / d\n\n    ix2 = px - h * (y2 - y1) / d\n    iy2 = py + h * (x2 - x1) / d\n\n    if abs(ix1 - ix2) < 1e-9 and abs(iy1 - iy2) < 1e-9:\n        return [(ix1, iy1)]  # Tangent (one point)\n    else:\n        return [(ix1, iy1), (ix2, iy2)]",
    "testCases": [
      {
        "input": "c1 = (0, 0), r1 = 5, c2 = (5, 0), r2 = 5",
        "isHidden": false,
        "description": "Two intersecting circles"
      },
      {
        "input": "c1 = (0, 0), r1 = 3, c2 = (10, 0), r2 = 3",
        "isHidden": false,
        "description": "Non-intersecting circles"
      },
      {
        "input": "c1 = (0, 0), r1 = 5, c2 = (5, 0), r2 = 0",
        "isHidden": false,
        "description": "Circle and point"
      }
    ],
    "hints": [
      "Check distance between centers vs sum and difference of radii",
      "If d > r1 + r2: circles too far apart",
      "If d < |r1 - r2|: one circle inside other",
      "Use geometry to find intersection points",
      "Find point on line between centers, then perpendicular offset",
      "Handle special cases: tangent (one point), no intersection"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex14",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Smallest Enclosing Circle",
    "difficulty": 5,
    "description": "Find smallest circle that encloses all points using Welzl's algorithm.",
    "starterCode": "def smallest_enclosing_circle(points):\n    \"\"\"\n    Find smallest circle that encloses all points.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        tuple: (center, radius) where center is (x, y).\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def smallest_enclosing_circle(points):\n    \"\"\"\n    Find smallest circle that encloses all points.\n\n    Args:\n        points: List of (x, y) tuples.\n\n    Returns:\n        tuple: (center, radius) where center is (x, y).\n    \"\"\"\n    import random\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def circle_from_2_points(p1, p2):\n        \"\"\"Circle with diameter p1-p2.\"\"\"\n        center = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)\n        radius = distance(p1, p2) / 2\n        return center, radius\n\n    def circle_from_3_points(p1, p2, p3):\n        \"\"\"Circumcircle of three points.\"\"\"\n        ax, ay = p1\n        bx, by = p2\n        cx, cy = p3\n\n        d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n        if abs(d) < 1e-9:\n            return circle_from_2_points(p1, p2)\n\n        ux = ((ax**2 + ay**2) * (by - cy) + (bx**2 + by**2) * (cy - ay) + (cx**2 + cy**2) * (ay - by)) / d\n        uy = ((ax**2 + ay**2) * (cx - bx) + (bx**2 + by**2) * (ax - cx) + (cx**2 + cy**2) * (bx - ax)) / d\n\n        center = (ux, uy)\n        radius = distance(center, p1)\n        return center, radius\n\n    def welzl_helper(points, boundary, n):\n        \"\"\"Recursive helper for Welzl's algorithm.\"\"\"\n        if n == 0 or len(boundary) == 3:\n            if len(boundary) == 0:\n                return ((0, 0), 0)\n            elif len(boundary) == 1:\n                return (boundary[0], 0)\n            elif len(boundary) == 2:\n                return circle_from_2_points(boundary[0], boundary[1])\n            else:\n                return circle_from_3_points(boundary[0], boundary[1], boundary[2])\n\n        # Pick random point\n        idx = random.randint(0, n - 1)\n        p = points[idx]\n\n        # Swap with last\n        points[idx], points[n - 1] = points[n - 1], points[idx]\n\n        # Recursively find circle without p\n        circle = welzl_helper(points, boundary, n - 1)\n        center, radius = circle\n\n        # If p is inside circle, return it\n        if distance(center, p) <= radius + 1e-9:\n            return circle\n\n        # Otherwise, p must be on boundary\n        return welzl_helper(points, boundary + [p], n - 1)\n\n    if not points:\n        return ((0, 0), 0)\n\n    points_copy = points[:]\n    return welzl_helper(points_copy, [], len(points_copy))",
    "testCases": [
      {
        "input": "points = [(0, 0), (1, 0), (0, 1)]",
        "isHidden": false,
        "description": "Three points forming triangle"
      },
      {
        "input": "points = [(0, 0), (2, 0), (1, 1)]",
        "isHidden": false,
        "description": "Triangle with different shape"
      },
      {
        "input": "points = [(0, 0), (1, 0), (1, 1), (0, 1)]",
        "isHidden": false,
        "description": "Square"
      }
    ],
    "hints": [
      "Welzl's algorithm: randomized incremental approach",
      "Key insight: optimal circle has 2 or 3 points on boundary",
      "Process points randomly",
      "If point outside current circle, it must be on boundary",
      "Recursively find circle with point on boundary",
      "Expected O(n) time with randomization"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex15",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "Bentley-Ottmann Line Sweep",
    "difficulty": 5,
    "description": "Find all intersection points of line segments using Bentley-Ottmann algorithm (simplified).",
    "starterCode": "def find_intersections(segments):\n    \"\"\"\n    Find all intersection points of line segments.\n\n    Args:\n        segments: List of segments [((x1, y1), (x2, y2)), ...].\n\n    Returns:\n        list: Intersection points.\n    \"\"\"\n    # Your code here\n    pass",
    "solution": "def find_intersections(segments):\n    \"\"\"\n    Find all intersection points of line segments.\n\n    Args:\n        segments: List of segments [((x1, y1), (x2, y2)), ...].\n\n    Returns:\n        list: Intersection points.\n    \"\"\"\n    def segments_intersect_point(seg1, seg2):\n        \"\"\"Find intersection point of two segments if exists.\"\"\"\n        (x1, y1), (x2, y2) = seg1\n        (x3, y3), (x4, y4) = seg2\n\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n\n        if abs(denom) < 1e-9:\n            return None  # Parallel or collinear\n\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            # Intersection point\n            px = x1 + t * (x2 - x1)\n            py = y1 + t * (y2 - y1)\n            return (px, py)\n\n        return None\n\n    # Simplified O(n^2) approach: check all pairs\n    intersections = []\n\n    for i in range(len(segments)):\n        for j in range(i + 1, len(segments)):\n            point = segments_intersect_point(segments[i], segments[j])\n            if point:\n                # Check if already added (avoid duplicates)\n                is_duplicate = False\n                for p in intersections:\n                    if abs(p[0] - point[0]) < 1e-9 and abs(p[1] - point[1]) < 1e-9:\n                        is_duplicate = True\n                        break\n                if not is_duplicate:\n                    intersections.append(point)\n\n    return intersections",
    "testCases": [
      {
        "input": "segments = [((0, 0), (2, 2)), ((0, 2), (2, 0))]",
        "isHidden": false,
        "description": "Two intersecting segments (X pattern)"
      },
      {
        "input": "segments = [((0, 0), (1, 1)), ((2, 2), (3, 3)), ((0, 1), (1, 0))]",
        "isHidden": false,
        "description": "Multiple segments with one intersection"
      },
      {
        "input": "segments = [((0, 0), (1, 0)), ((2, 0), (3, 0))]",
        "isHidden": false,
        "description": "Non-intersecting segments"
      }
    ],
    "hints": [
      "Bentley-Ottmann: sweep line + event queue + status structure",
      "This simplified version is O(n^2) checking all pairs",
      "For true O((n+k) log n): use sweep line with balanced BST",
      "Events: segment endpoints and intersections",
      "Status: segments currently intersecting sweep line",
      "Full algorithm is complex; simplified version still useful"
    ],
    "language": "python"
  },
  {
    "id": "cs403-t7-ex16",
    "subjectId": "cs403",
    "topicId": "cs403-topic-7",
    "title": "KD-Tree Nearest Neighbor",
    "difficulty": 4,
    "description": "Find nearest neighbor using KD-tree for efficient spatial queries.",
    "starterCode": "class KDNode:\n    def __init__(self, point, left=None, right=None):\n        self.point = point\n        self.left = left\n        self.right = right\n\ndef build_kdtree(points, depth=0):\n    \"\"\"Build KD-tree from points.\"\"\"\n    # Your code here\n    pass\n\ndef nearest_neighbor(root, query, depth=0):\n    \"\"\"Find nearest neighbor to query point in KD-tree.\"\"\"\n    # Your code here\n    pass",
    "solution": "class KDNode:\n    def __init__(self, point, left=None, right=None):\n        self.point = point\n        self.left = left\n        self.right = right\n\ndef build_kdtree(points, depth=0):\n    \"\"\"Build KD-tree from points.\"\"\"\n    if not points:\n        return None\n\n    k = len(points[0])  # Dimensions\n    axis = depth % k\n\n    # Sort and choose median\n    points.sort(key=lambda p: p[axis])\n    median = len(points) // 2\n\n    # Create node and recursively build subtrees\n    return KDNode(\n        point=points[median],\n        left=build_kdtree(points[:median], depth + 1),\n        right=build_kdtree(points[median + 1:], depth + 1)\n    )\n\ndef nearest_neighbor(root, query, depth=0, best=None):\n    \"\"\"Find nearest neighbor to query point in KD-tree.\"\"\"\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt(sum((a - b)**2 for a, b in zip(p1, p2)))\n\n    if root is None:\n        return best\n\n    k = len(query)\n    axis = depth % k\n\n    # Update best if current node is closer\n    dist = distance(root.point, query)\n    if best is None or dist < distance(best, query):\n        best = root.point\n\n    # Determine which subtree to search first\n    if query[axis] < root.point[axis]:\n        near, far = root.left, root.right\n    else:\n        near, far = root.right, root.left\n\n    # Search near subtree\n    best = nearest_neighbor(near, query, depth + 1, best)\n\n    # Check if we need to search far subtree\n    if abs(query[axis] - root.point[axis]) < distance(best, query):\n        best = nearest_neighbor(far, query, depth + 1, best)\n\n    return best",
    "testCases": [
      {
        "input": "points = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)], query = (9, 2)",
        "isHidden": false,
        "description": "Find nearest neighbor in 2D"
      },
      {
        "input": "points = [(1, 1), (2, 2), (3, 3), (4, 4)], query = (2.5, 2.5)",
        "isHidden": false,
        "description": "Query between points"
      },
      {
        "input": "points = [(0, 0), (10, 10)], query = (5, 5)",
        "isHidden": false,
        "description": "Two points, query in middle"
      }
    ],
    "hints": [
      "KD-tree: binary space partitioning tree",
      "Each level splits along different axis (alternating)",
      "Build tree by sorting along axis and choosing median",
      "For nearest neighbor: recursively search closer subtree first",
      "Prune far subtree if impossible to contain closer point",
      "Average case: O(log n), worst case: O(n)"
    ],
    "language": "python"
  }
]

import type { TestCase, ProgrammingLanguage } from '@/core/types';
import type { PyodideInterface, loadPyodide as LoadPyodideType } from 'pyodide';

export interface TestResult {
  testCase: TestCase;
  passed: boolean;
  actualOutput: string;
  expectedOutput: string; // Generated from running solution
  error?: string;
}

let pyodideInstance: PyodideInterface | null = null;
let pyodideLoading: Promise<PyodideInterface> | null = null;

// JSCPP for C/C++ interpretation
let jscppInstance: typeof import('JSCPP') | null = null;
let jscppLoading: Promise<typeof import('JSCPP')> | null = null;

declare global {
  interface Window {
    loadPyodide: typeof LoadPyodideType;
  }
}

// Pyodide version - keep in sync with package.json devDependencies
const PYODIDE_VERSION = '0.24.1';
const PYODIDE_CDN_BASE = `https://cdn.jsdelivr.net/pyodide/v${PYODIDE_VERSION}/full`;

/**
 * Initialize Pyodide lazily. Only loads when first needed.
 */
export async function initPyodide(): Promise<PyodideInterface> {
  if (pyodideInstance) {
    return pyodideInstance;
  }

  if (pyodideLoading) {
    return pyodideLoading;
  }

  pyodideLoading = (async () => {
    try {
      // Load Pyodide from CDN
      if (!window.loadPyodide) {
        const script = document.createElement('script');
        script.src = `${PYODIDE_CDN_BASE}/pyodide.js`;
        document.head.appendChild(script);

        await new Promise<void>((resolve, reject) => {
          script.onload = () => resolve();
          script.onerror = () => reject(new Error('Failed to load Pyodide'));
        });
      }

      pyodideInstance = await window.loadPyodide({
        indexURL: `${PYODIDE_CDN_BASE}/`,
      });

      return pyodideInstance;
    } catch (error) {
      pyodideLoading = null;
      throw error;
    }
  })();

  return pyodideLoading;
}

/**
 * Run Python code and return the output as a string.
 * Captures stdout and stderr.
 */
export async function runPython(code: string, timeout = 10000): Promise<string> {
  const pyodide = await initPyodide();

  // Set up output capture
  const captureCode = `
import sys
from io import StringIO

_stdout = StringIO()
_stderr = StringIO()
sys.stdout = _stdout
sys.stderr = _stderr

try:
${code.split('\n').map(line => '    ' + line).join('\n')}
finally:
    sys.stdout = sys.__stdout__
    sys.stderr = sys.__stderr__

_output = _stdout.getvalue()
_errors = _stderr.getvalue()

if _errors:
    _output = _output + '\\nErrors:\\n' + _errors

_output
`;

  return Promise.race([
    (async () => {
      try {
        const result = await pyodide.runPythonAsync(captureCode);
        return String(result || '');
      } catch (error) {
        if (error instanceof Error) {
          throw new Error(error.message);
        }
        throw new Error(String(error));
      }
    })(),
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Execution timeout')), timeout)
    ),
  ]);
}

/**
 * Run test cases against user code.
 * Each test case provides input (function arguments).
 * Expected output is generated by running the solution code.
 */
export async function runTests(
  code: string,
  tests: TestCase[],
  solution: string,
  timeout = 5000
): Promise<TestResult[]> {
  const results: TestResult[] = [];

  // Extract a top-level function name from the code (avoid matching class methods)
  const funcMatch = code.match(/^def\s+(\w+)\s*\(/m);
  const funcName = funcMatch ? funcMatch[1] : null;

  // Extract function name from solution (should match)
  const solutionFuncMatch = solution.match(/^def\s+(\w+)\s*\(/m);
  const solutionFuncName = solutionFuncMatch ? solutionFuncMatch[1] : null;

  for (const testCase of tests) {
    try {
      let testCode: string;
      let solutionTestCode: string;

      if (funcName && testCase.input) {
        // Function-based test: call the function with test input
        testCode = prepareFunctionTestCode(code, funcName, testCase.input);
        solutionTestCode = prepareFunctionTestCode(solution, solutionFuncName || funcName, testCase.input);
      } else if (testCase.input) {
        // No top-level function detected.
        // If code reads stdin, mock input(); otherwise append a test snippet.
        const usesStdin = /\binput\s*\(/.test(code) || /\binput\s*\(/.test(solution);
        if (usesStdin) {
          testCode = prepareStdinTestCode(code, testCase.input);
          solutionTestCode = prepareStdinTestCode(solution, testCase.input);
        } else {
          testCode = prepareSnippetTestCode(code, testCase.input);
          solutionTestCode = prepareSnippetTestCode(solution, testCase.input);
        }
      } else {
        // No input: just run the code
        testCode = code;
        solutionTestCode = solution;
      }

      // Run solution to get expected output
      const expectedOutput = await runPython(solutionTestCode, timeout);
      const normalizedExpected = normalizeOutput(expectedOutput);

      // Run user code to get actual output
      const actualOutput = await runPython(testCode, timeout);
      const normalizedActual = normalizeOutput(actualOutput);

      results.push({
        testCase,
        passed: normalizedActual === normalizedExpected,
        actualOutput: normalizedActual,
        expectedOutput: normalizedExpected,
      });
    } catch (error) {
      results.push({
        testCase,
        passed: false,
        actualOutput: '',
        expectedOutput: '',
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  return results;
}

/**
 * Prepare code for function-based testing.
 * Strips existing print/test calls and adds a call with test input.
 */
function prepareFunctionTestCode(code: string, funcName: string, input: string): string {
  // Split the code into lines
  const lines = code.split('\n');

  // Find where the function definition ends (track indentation)
  let inFunction = false;
  let functionIndent = 0;
  const functionLines: string[] = [];
  const otherLines: string[] = [];

  for (const line of lines) {
    // Check if this is the start of the target function
    if (line.match(new RegExp(`^def\\s+${funcName}\\s*\\(`))) {
      inFunction = true;
      functionIndent = line.search(/\S/);
      functionLines.push(line);
      continue;
    }

    if (inFunction) {
      // Check if we've exited the function (non-empty line with same or less indentation)
      const trimmed = line.trim();
      if (trimmed.length > 0) {
        const currentIndent = line.search(/\S/);
        if (currentIndent <= functionIndent && !line.match(/^\s*#/)) {
          inFunction = false;
          // Don't include test calls from the original code
          if (!isTestCall(line)) {
            otherLines.push(line);
          }
        } else {
          functionLines.push(line);
        }
      } else {
        functionLines.push(line);
      }
    } else {
      // Skip test calls and print statements that call our function
      if (!isTestCall(line) && !line.match(new RegExp(`print\\s*\\(\\s*${funcName}\\s*\\(`))) {
        otherLines.push(line);
      }
    }
  }

  // Build the test code: function definition + single print with test input
  const testCode = [...functionLines, ...otherLines, `print(${funcName}(${input}))`].join('\n');

  return testCode;
}

/**
 * Check if a line is a test/example call that should be skipped.
 */
function isTestCall(line: string): boolean {
  const trimmed = line.trim();
  // Skip lines that are just comments, empty, or example calls
  if (trimmed.startsWith('#')) return false;
  if (trimmed === '') return false;
  // Skip common test patterns
  if (trimmed.match(/^print\s*\(/)) return true;
  if (trimmed.match(/^result\s*=/)) return true;
  if (trimmed.match(/^assert\s/)) return true;
  return false;
}

/**
 * Prepare code for stdin-based testing.
 * Handles input() function calls by pre-defining input values.
 */
function prepareStdinTestCode(code: string, input: string): string {
  // Split input into lines for multiple input() calls
  const inputLines = input.split('\n').filter(line => line.trim());

  const inputSetup = `
import sys
from io import StringIO

_input_data = ${JSON.stringify(inputLines)}
_input_index = 0

def _mock_input(prompt=''):
    global _input_index
    if _input_index < len(_input_data):
        value = _input_data[_input_index]
        _input_index += 1
        return value
    return ''

# Replace input with our mock
input = _mock_input
`;

  return inputSetup + '\n' + code;
}

/**
 * Prepare code for snippet-based testing.
 * Appends a snippet that should print/raise/assert to validate behavior.
 */
function prepareSnippetTestCode(code: string, snippet: string): string {
  return `${code}\n\n# === TEST SNIPPET ===\n${snippet}\n`;
}

/**
 * Normalize output for comparison.
 * Removes trailing whitespace and normalizes line endings.
 */
function normalizeOutput(output: string): string {
  return output
    .trim()
    .replace(/\r\n/g, '\n')
    .replace(/\s+$/gm, '');
}

/**
 * Clear the Pyodide instance (useful for testing or reset).
 */
export function clearPyodide(): void {
  pyodideInstance = null;
  pyodideLoading = null;
}

// ============================================================
// JSCPP (C/C++) Runner
// ============================================================

/**
 * Initialize JSCPP lazily. Only loads when first needed.
 */
export async function initJSCPP(): Promise<typeof import('JSCPP')> {
  if (jscppInstance) {
    return jscppInstance;
  }

  if (jscppLoading) {
    return jscppLoading;
  }

  jscppLoading = (async () => {
    try {
      // Dynamic import of JSCPP
      const JSCPP = await import('JSCPP');
      jscppInstance = JSCPP.default || JSCPP;
      return jscppInstance;
    } catch (error) {
      jscppLoading = null;
      throw error;
    }
  })();

  return jscppLoading;
}

/**
 * Run C code and return the output as a string.
 * Uses JSCPP interpreter.
 *
 * Note: JSCPP supports basic C/C++ but has limitations:
 * - No malloc/free (use static arrays)
 * - No file I/O
 * - No multi-dimensional array initializers
 */
export async function runC(code: string, input = '', timeout = 10000): Promise<string> {
  const JSCPP = await initJSCPP();

  let output = '';

  const config = {
    stdio: {
      write: (s: string) => {
        output += s;
      },
      drain: () => {
        const data = input;
        input = ''; // Consume input
        return data;
      },
    },
    unsigned_overflow: 'warn' as const,
    maxTimeout: timeout,
  };

  return new Promise((resolve, reject) => {
    try {
      const exitCode = JSCPP.run(code, input, config);

      // If there was no output but the program ran successfully
      if (output === '' && exitCode === 0) {
        resolve('(No output)');
      } else {
        resolve(output.trim());
      }
    } catch (error) {
      if (error instanceof Error) {
        // Clean up JSCPP error messages for better readability
        let message = error.message;

        // Extract line number from JSCPP errors if available
        const lineMatch = message.match(/line (\d+)/i);
        if (lineMatch) {
          message = `Error on line ${lineMatch[1]}: ${message}`;
        }

        reject(new Error(message));
      } else {
        reject(new Error(String(error)));
      }
    }
  });
}

/**
 * Run test cases against user C code.
 * Each test case provides input (stdin).
 * Expected output is generated by running the solution code.
 */
export async function runCTests(
  code: string,
  tests: TestCase[],
  solution: string,
  timeout = 5000
): Promise<TestResult[]> {
  const results: TestResult[] = [];

  // Extract function name from the code (for function-based tests)
  // Supports compound types like "unsigned int", "long long", "unsigned long", etc.
  const funcMatch = code.match(/^\s*(?:(?:unsigned|signed|static|const)\s+)*(?:int|void|float|double|char|long|short)(?:\s+(?:long|int))?\s+(\w+)\s*\(/m);
  const funcName = funcMatch ? funcMatch[1] : null;

  // Check if this is a main-based program or function-based
  const hasMain = /\bint\s+main\s*\(/.test(code);

  for (const testCase of tests) {
    try {
      let testCode: string;
      let solutionTestCode: string;

      if (hasMain) {
        // Main-based program: use stdin for input
        testCode = code;
        solutionTestCode = solution;
      } else if (funcName && funcName !== 'main' && testCase.input) {
        // Function-based test: create a main that calls the function
        testCode = prepareCFunctionTestCode(code, funcName, testCase.input);
        solutionTestCode = prepareCFunctionTestCode(solution, funcName, testCase.input);
      } else {
        // Default: run as-is
        testCode = code;
        solutionTestCode = solution;
      }

      // Run solution to get expected output
      const expectedOutput = await runC(solutionTestCode, testCase.input || '', timeout);
      const normalizedExpected = normalizeOutput(expectedOutput);

      // Run user code to get actual output
      const actualOutput = await runC(testCode, testCase.input || '', timeout);
      const normalizedActual = normalizeOutput(actualOutput);

      results.push({
        testCase,
        passed: normalizedActual === normalizedExpected,
        actualOutput: normalizedActual,
        expectedOutput: normalizedExpected,
      });
    } catch (error) {
      results.push({
        testCase,
        passed: false,
        actualOutput: '',
        expectedOutput: '',
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  return results;
}

/**
 * Get the printf format specifier for a C type.
 * @param cType - The C type (int, float, char, etc.)
 * @returns The corresponding printf format specifier
 *
 * Note: JSCPP (the C interpreter) only supports basic format specifiers (%d, %f, %c, %s).
 * It does not support %ld, %hd, %lld, etc. All integer types use %d.
 */
function getPrintfFormatSpecifier(cType: string): string {
  // Normalize the type by removing extra whitespace
  const normalizedType = cType.trim().replace(/\s+/g, ' ');

  // JSCPP only supports basic specifiers - use %f for floating point
  if (normalizedType.includes('double') || normalizedType.includes('float')) {
    return '%f';
  }
  // Use %c for char
  if (normalizedType.includes('char')) {
    return '%c';
  }

  // Default to %d for all integer types (int, long, short, unsigned, etc.)
  // JSCPP doesn't support %ld, %hd, %lld - it treats all integers the same
  return '%d';
}

/**
 * Prepare C code for function-based testing.
 * Creates a main function that calls the target function with test input.
 */
function prepareCFunctionTestCode(code: string, funcName: string, input: string): string {
  // Check if code already has main
  if (/\bint\s+main\s*\(/.test(code)) {
    return code;
  }

  // Detect return type of the function (supports compound types like "unsigned int", "long long", etc.)
  const funcMatch = code.match(new RegExp(`((?:(?:unsigned|signed|static|const)\\s+)*(?:int|void|float|double|char|long|short)(?:\\s+(?:long|int))?)\\s+${funcName}\\s*\\(`));
  const returnType = funcMatch ? funcMatch[1] : 'int';

  // Build the function call statement based on return type
  const functionCall = `${funcName}(${input})`;
  const isVoid = returnType.includes('void');
  const printStatement = isVoid
    ? `${functionCall};`
    : `printf("${getPrintfFormatSpecifier(returnType)}", ${functionCall});`;

  // Create a main function that calls the target function
  const mainCode = `
int main() {
    ${printStatement}
    return 0;
}
`;

  // Ensure stdio.h is included
  const hasStdio = /#include\s*<stdio\.h>/.test(code) || /#include\s*<cstdio>/.test(code);
  const includeStdio = hasStdio ? '' : '#include <stdio.h>\n';

  return includeStdio + code + '\n' + mainCode;
}

/**
 * Clear the JSCPP instance (useful for testing or reset).
 */
export function clearJSCPP(): void {
  jscppInstance = null;
  jscppLoading = null;
}

// ============================================================
// Language-agnostic runner
// ============================================================

/**
 * Run code in the appropriate language interpreter.
 */
export async function runCode(
  code: string,
  language: ProgrammingLanguage,
  input = '',
  timeout = 10000
): Promise<string> {
  switch (language) {
    case 'python':
      return runPython(code, timeout);
    case 'c':
    case 'cpp':
      return runC(code, input, timeout);
    default:
      throw new Error(`Unsupported language: ${language}`);
  }
}

/**
 * Run tests for the appropriate language.
 */
export async function runTestsForLanguage(
  code: string,
  tests: TestCase[],
  solution: string,
  language: ProgrammingLanguage,
  timeout = 5000
): Promise<TestResult[]> {
  switch (language) {
    case 'python':
      return runTests(code, tests, solution, timeout);
    case 'c':
    case 'cpp':
      return runCTests(code, tests, solution, timeout);
    default:
      throw new Error(`Unsupported language: ${language}`);
  }
}

import type { TestCase } from '@/core/types';
import type { PyodideInterface, loadPyodide as LoadPyodideType } from 'pyodide';

export interface TestResult {
  testCase: TestCase;
  passed: boolean;
  actualOutput: string;
  expectedOutput: string; // Generated from running solution
  error?: string;
}

let pyodideInstance: PyodideInterface | null = null;
let pyodideLoading: Promise<PyodideInterface> | null = null;

declare global {
  interface Window {
    loadPyodide: typeof LoadPyodideType;
  }
}

// Pyodide version - keep in sync with package.json devDependencies
const PYODIDE_VERSION = '0.24.1';
const PYODIDE_CDN_BASE = `https://cdn.jsdelivr.net/pyodide/v${PYODIDE_VERSION}/full`;

/**
 * Initialize Pyodide lazily. Only loads when first needed.
 */
export async function initPyodide(): Promise<PyodideInterface> {
  if (pyodideInstance) {
    return pyodideInstance;
  }

  if (pyodideLoading) {
    return pyodideLoading;
  }

  pyodideLoading = (async () => {
    try {
      // Load Pyodide from CDN
      if (!window.loadPyodide) {
        const script = document.createElement('script');
        script.src = `${PYODIDE_CDN_BASE}/pyodide.js`;
        document.head.appendChild(script);

        await new Promise<void>((resolve, reject) => {
          script.onload = () => resolve();
          script.onerror = () => reject(new Error('Failed to load Pyodide'));
        });
      }

      pyodideInstance = await window.loadPyodide({
        indexURL: `${PYODIDE_CDN_BASE}/`,
      });

      return pyodideInstance;
    } catch (error) {
      pyodideLoading = null;
      throw error;
    }
  })();

  return pyodideLoading;
}

/**
 * Run Python code and return the output as a string.
 * Captures stdout and stderr.
 */
export async function runPython(code: string, timeout = 10000): Promise<string> {
  const pyodide = await initPyodide();

  // Set up output capture
  const captureCode = `
import sys
from io import StringIO

_stdout = StringIO()
_stderr = StringIO()
sys.stdout = _stdout
sys.stderr = _stderr

try:
${code.split('\n').map(line => '    ' + line).join('\n')}
finally:
    sys.stdout = sys.__stdout__
    sys.stderr = sys.__stderr__

_output = _stdout.getvalue()
_errors = _stderr.getvalue()

if _errors:
    _output = _output + '\\nErrors:\\n' + _errors

_output
`;

  return Promise.race([
    (async () => {
      try {
        const result = await pyodide.runPythonAsync(captureCode);
        return String(result || '');
      } catch (error) {
        if (error instanceof Error) {
          throw new Error(error.message);
        }
        throw new Error(String(error));
      }
    })(),
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Execution timeout')), timeout)
    ),
  ]);
}

/**
 * Run test cases against user code.
 * Each test case provides input (function arguments).
 * Expected output is generated by running the solution code.
 */
export async function runTests(
  code: string,
  tests: TestCase[],
  solution: string,
  timeout = 5000
): Promise<TestResult[]> {
  const results: TestResult[] = [];

  // Extract a top-level function name from the code (avoid matching class methods)
  const funcMatch = code.match(/^def\s+(\w+)\s*\(/m);
  const funcName = funcMatch ? funcMatch[1] : null;

  // Extract function name from solution (should match)
  const solutionFuncMatch = solution.match(/^def\s+(\w+)\s*\(/m);
  const solutionFuncName = solutionFuncMatch ? solutionFuncMatch[1] : null;

  for (const testCase of tests) {
    try {
      let testCode: string;
      let solutionTestCode: string;

      if (funcName && testCase.input) {
        // Function-based test: call the function with test input
        testCode = prepareFunctionTestCode(code, funcName, testCase.input);
        solutionTestCode = prepareFunctionTestCode(solution, solutionFuncName || funcName, testCase.input);
      } else if (testCase.input) {
        // No top-level function detected.
        // If code reads stdin, mock input(); otherwise append a test snippet.
        const usesStdin = /\binput\s*\(/.test(code) || /\binput\s*\(/.test(solution);
        if (usesStdin) {
          testCode = prepareStdinTestCode(code, testCase.input);
          solutionTestCode = prepareStdinTestCode(solution, testCase.input);
        } else {
          testCode = prepareSnippetTestCode(code, testCase.input);
          solutionTestCode = prepareSnippetTestCode(solution, testCase.input);
        }
      } else {
        // No input: just run the code
        testCode = code;
        solutionTestCode = solution;
      }

      // Run solution to get expected output
      const expectedOutput = await runPython(solutionTestCode, timeout);
      const normalizedExpected = normalizeOutput(expectedOutput);

      // Run user code to get actual output
      const actualOutput = await runPython(testCode, timeout);
      const normalizedActual = normalizeOutput(actualOutput);

      results.push({
        testCase,
        passed: normalizedActual === normalizedExpected,
        actualOutput: normalizedActual,
        expectedOutput: normalizedExpected,
      });
    } catch (error) {
      results.push({
        testCase,
        passed: false,
        actualOutput: '',
        expectedOutput: '',
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  return results;
}

/**
 * Prepare code for function-based testing.
 * Strips existing print/test calls and adds a call with test input.
 */
function prepareFunctionTestCode(code: string, funcName: string, input: string): string {
  // Split the code into lines
  const lines = code.split('\n');

  // Find where the function definition ends (track indentation)
  let inFunction = false;
  let functionIndent = 0;
  const functionLines: string[] = [];
  const otherLines: string[] = [];

  for (const line of lines) {
    // Check if this is the start of the target function
    if (line.match(new RegExp(`^def\\s+${funcName}\\s*\\(`))) {
      inFunction = true;
      functionIndent = line.search(/\S/);
      functionLines.push(line);
      continue;
    }

    if (inFunction) {
      // Check if we've exited the function (non-empty line with same or less indentation)
      const trimmed = line.trim();
      if (trimmed.length > 0) {
        const currentIndent = line.search(/\S/);
        if (currentIndent <= functionIndent && !line.match(/^\s*#/)) {
          inFunction = false;
          // Don't include test calls from the original code
          if (!isTestCall(line)) {
            otherLines.push(line);
          }
        } else {
          functionLines.push(line);
        }
      } else {
        functionLines.push(line);
      }
    } else {
      // Skip test calls and print statements that call our function
      if (!isTestCall(line) && !line.match(new RegExp(`print\\s*\\(\\s*${funcName}\\s*\\(`))) {
        otherLines.push(line);
      }
    }
  }

  // Build the test code: function definition + single print with test input
  const testCode = [...functionLines, ...otherLines, `print(${funcName}(${input}))`].join('\n');

  return testCode;
}

/**
 * Check if a line is a test/example call that should be skipped.
 */
function isTestCall(line: string): boolean {
  const trimmed = line.trim();
  // Skip lines that are just comments, empty, or example calls
  if (trimmed.startsWith('#')) return false;
  if (trimmed === '') return false;
  // Skip common test patterns
  if (trimmed.match(/^print\s*\(/)) return true;
  if (trimmed.match(/^result\s*=/)) return true;
  if (trimmed.match(/^assert\s/)) return true;
  return false;
}

/**
 * Prepare code for stdin-based testing.
 * Handles input() function calls by pre-defining input values.
 */
function prepareStdinTestCode(code: string, input: string): string {
  // Split input into lines for multiple input() calls
  const inputLines = input.split('\n').filter(line => line.trim());

  const inputSetup = `
import sys
from io import StringIO

_input_data = ${JSON.stringify(inputLines)}
_input_index = 0

def _mock_input(prompt=''):
    global _input_index
    if _input_index < len(_input_data):
        value = _input_data[_input_index]
        _input_index += 1
        return value
    return ''

# Replace input with our mock
input = _mock_input
`;

  return inputSetup + '\n' + code;
}

/**
 * Prepare code for snippet-based testing.
 * Appends a snippet that should print/raise/assert to validate behavior.
 */
function prepareSnippetTestCode(code: string, snippet: string): string {
  return `${code}\n\n# === TEST SNIPPET ===\n${snippet}\n`;
}

/**
 * Normalize output for comparison.
 * Removes trailing whitespace and normalizes line endings.
 */
function normalizeOutput(output: string): string {
  return output
    .trim()
    .replace(/\r\n/g, '\n')
    .replace(/\s+$/gm, '');
}

/**
 * Clear the Pyodide instance (useful for testing or reset).
 */
export function clearPyodide(): void {
  pyodideInstance = null;
  pyodideLoading = null;
}

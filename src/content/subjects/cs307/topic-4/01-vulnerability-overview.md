# Vulnerability Overview

## Introduction

Understanding vulnerabilities is the foundation of defensive security. Security vulnerabilities are weaknesses in systems, applications, or networks that can be exploited by attackers to compromise confidentiality, integrity, or availability. This overview introduces the frameworks and methodologies used to identify, classify, and assess vulnerabilities.

## The OWASP Top 10

The Open Web Application Security Project (OWASP) Top 10 is the most recognized and authoritative list of the most critical web application security risks. Updated every few years, it serves as a guideline for developers, security professionals, and organizations to prioritize their security efforts.

### OWASP Top 10 (2021 Edition)

1. **Broken Access Control**: Failures in enforcing proper user permissions, allowing unauthorized access to data or functionality
2. **Cryptographic Failures**: Inadequate protection of sensitive data through weak or missing encryption
3. **Injection**: Untrusted data sent to interpreters as commands or queries, including SQL, NoSQL, OS commands, and LDAP
4. **Insecure Design**: Missing or ineffective security controls in the design phase of applications
5. **Security Misconfiguration**: Improperly configured security settings, default credentials, or unnecessary features enabled
6. **Vulnerable and Outdated Components**: Using libraries, frameworks, or modules with known vulnerabilities
7. **Identification and Authentication Failures**: Weaknesses in authentication mechanisms allowing attackers to compromise credentials
8. **Software and Data Integrity Failures**: Code and infrastructure that doesn't protect against integrity violations
9. **Security Logging and Monitoring Failures**: Insufficient logging, detection, and response capabilities
10. **Server-Side Request Forgery (SSRF)**: Applications fetching remote resources without validating user-supplied URLs

### Using OWASP for Defense

The OWASP Top 10 should guide your development lifecycle:

```python
# Example: Defensive checklist integration
class SecurityChecklist:
    def __init__(self):
        self.owasp_checks = {
            'access_control': False,
            'cryptography': False,
            'injection_prevention': False,
            'secure_design': False,
            'configuration': False,
            'dependencies': False,
            'authentication': False,
            'integrity': False,
            'logging': False,
            'ssrf_prevention': False
        }

    def validate_deployment(self):
        """Ensure all OWASP Top 10 concerns are addressed"""
        if not all(self.owasp_checks.values()):
            missing = [k for k, v in self.owasp_checks.items() if not v]
            raise SecurityException(f"Missing security controls: {missing}")
        return True

    def mark_complete(self, check_name):
        if check_name in self.owasp_checks:
            self.owasp_checks[check_name] = True
```

## Common Vulnerabilities and Exposures (CVE)

The CVE system is a standardized dictionary of publicly known security vulnerabilities and exposures. Each CVE entry provides a unique identifier, description, and references for a specific vulnerability.

### CVE Identifier Structure

CVE identifiers follow the format: `CVE-YYYY-NNNNN`
- YYYY: Year of publication
- NNNNN: Unique sequential number

Example: `CVE-2021-44228` (Log4Shell vulnerability)

### CVE Database Usage

Defensive security teams use CVE databases to:
- Track vulnerabilities in their technology stack
- Prioritize patching efforts
- Assess risk exposure
- Validate security controls

```python
import requests
from datetime import datetime, timedelta

class CVEMonitor:
    """Monitor CVEs for technologies in your stack"""

    def __init__(self, technologies):
        self.technologies = technologies
        self.cve_api = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def check_recent_cves(self, days=7):
        """Check for CVEs published in the last N days"""
        start_date = datetime.now() - timedelta(days=days)
        vulnerabilities = []

        for tech in self.technologies:
            params = {
                'keywordSearch': tech,
                'pubStartDate': start_date.isoformat(),
                'pubEndDate': datetime.now().isoformat()
            }

            try:
                response = requests.get(self.cve_api, params=params)
                data = response.json()

                for item in data.get('vulnerabilities', []):
                    cve = item.get('cve', {})
                    vulnerabilities.append({
                        'id': cve.get('id'),
                        'description': cve.get('descriptions', [{}])[0].get('value'),
                        'technology': tech,
                        'published': cve.get('published'),
                        'severity': self.extract_severity(cve)
                    })
            except Exception as e:
                print(f"Error checking CVEs for {tech}: {e}")

        return vulnerabilities

    def extract_severity(self, cve):
        """Extract CVSS severity from CVE data"""
        metrics = cve.get('metrics', {})
        cvss_v3 = metrics.get('cvssMetricV31', [{}])[0]
        return cvss_v3.get('cvssData', {}).get('baseSeverity', 'UNKNOWN')
```

## Common Vulnerability Scoring System (CVSS)

CVSS provides a standardized way to assess the severity of security vulnerabilities. The scoring system produces numerical scores (0-10) that translate to severity ratings.

### CVSS v3.1 Metric Groups

1. **Base Metrics**: Intrinsic qualities that don't change over time
   - Attack Vector (AV): Network, Adjacent, Local, Physical
   - Attack Complexity (AC): Low, High
   - Privileges Required (PR): None, Low, High
   - User Interaction (UI): None, Required
   - Scope (S): Unchanged, Changed
   - Confidentiality Impact (C): None, Low, High
   - Integrity Impact (I): None, Low, High
   - Availability Impact (A): None, Low, High

2. **Temporal Metrics**: Characteristics that change over time
   - Exploit Code Maturity
   - Remediation Level
   - Report Confidence

3. **Environmental Metrics**: Unique to a specific user's environment
   - Modified Base Metrics
   - Confidentiality/Integrity/Availability Requirements

### CVSS Severity Ratings

| Score Range | Severity |
|-------------|----------|
| 0.0 | None |
| 0.1 - 3.9 | Low |
| 4.0 - 6.9 | Medium |
| 7.0 - 8.9 | High |
| 9.0 - 10.0 | Critical |

### Implementing CVSS-Based Prioritization

```python
class VulnerabilityPrioritizer:
    """Prioritize vulnerabilities based on CVSS scores and environmental factors"""

    def __init__(self):
        self.critical_threshold = 9.0
        self.high_threshold = 7.0
        self.medium_threshold = 4.0

    def calculate_priority(self, cvss_base, exploitability, asset_criticality):
        """
        Calculate remediation priority

        Args:
            cvss_base: Base CVSS score (0-10)
            exploitability: 'high', 'medium', 'low'
            asset_criticality: 'critical', 'high', 'medium', 'low'

        Returns:
            Priority level and recommended SLA
        """
        # Adjust score based on environmental factors
        adjusted_score = cvss_base

        # Increase priority if exploit is available
        if exploitability == 'high':
            adjusted_score = min(10.0, cvss_base + 1.5)
        elif exploitability == 'medium':
            adjusted_score = min(10.0, cvss_base + 0.5)

        # Increase priority for critical assets
        if asset_criticality == 'critical':
            adjusted_score = min(10.0, adjusted_score + 1.0)
        elif asset_criticality == 'high':
            adjusted_score = min(10.0, adjusted_score + 0.5)

        # Determine priority and SLA
        if adjusted_score >= self.critical_threshold:
            return {
                'priority': 'P0 - Critical',
                'sla_hours': 24,
                'action': 'Immediate patching or mitigation required'
            }
        elif adjusted_score >= self.high_threshold:
            return {
                'priority': 'P1 - High',
                'sla_hours': 72,
                'action': 'Patch within 3 days'
            }
        elif adjusted_score >= self.medium_threshold:
            return {
                'priority': 'P2 - Medium',
                'sla_hours': 168,  # 1 week
                'action': 'Patch within 1 week'
            }
        else:
            return {
                'priority': 'P3 - Low',
                'sla_hours': 720,  # 30 days
                'action': 'Patch during next maintenance window'
            }

# Example usage
prioritizer = VulnerabilityPrioritizer()

# Critical vulnerability in production database
vuln1 = prioritizer.calculate_priority(
    cvss_base=9.8,
    exploitability='high',
    asset_criticality='critical'
)
# Returns: P0 - Critical, 24 hours

# Medium vulnerability in development server
vuln2 = prioritizer.calculate_priority(
    cvss_base=5.3,
    exploitability='low',
    asset_criticality='low'
)
# Returns: P2 - Medium, 1 week
```

## Vulnerability Management Process

Effective vulnerability management follows a continuous cycle:

### 1. Discovery and Identification

```python
class VulnerabilityScanner:
    """Coordinate vulnerability scanning across your infrastructure"""

    def __init__(self):
        self.scan_targets = []
        self.scan_results = []

    def add_target(self, target_type, identifier):
        """Add scanning target"""
        self.scan_targets.append({
            'type': target_type,  # 'network', 'application', 'container', 'code'
            'identifier': identifier,
            'last_scan': None,
            'scan_frequency': self.get_scan_frequency(target_type)
        })

    def get_scan_frequency(self, target_type):
        """Define scanning frequency based on target type"""
        frequencies = {
            'network': 'weekly',
            'application': 'daily',
            'container': 'on_build',
            'code': 'on_commit'
        }
        return frequencies.get(target_type, 'monthly')
```

### 2. Assessment and Prioritization

Use CVSS scores, exploitability, and business impact to prioritize remediation efforts.

### 3. Remediation

Apply patches, implement compensating controls, or accept risk based on business context.

### 4. Verification

Confirm vulnerabilities are properly remediated through rescanning and testing.

### 5. Reporting and Metrics

Track key metrics:
- Mean Time to Detect (MTTD)
- Mean Time to Remediate (MTTR)
- Vulnerability density (vulnerabilities per asset)
- SLA compliance rate

```python
class VulnerabilityMetrics:
    """Track vulnerability management metrics"""

    def calculate_mttr(self, vulnerabilities):
        """Calculate Mean Time to Remediate"""
        from datetime import datetime

        remediation_times = []
        for vuln in vulnerabilities:
            if vuln.get('remediated_date') and vuln.get('discovered_date'):
                discovered = datetime.fromisoformat(vuln['discovered_date'])
                remediated = datetime.fromisoformat(vuln['remediated_date'])
                days = (remediated - discovered).days
                remediation_times.append(days)

        if remediation_times:
            return sum(remediation_times) / len(remediation_times)
        return 0

    def sla_compliance_rate(self, vulnerabilities):
        """Calculate percentage of vulnerabilities remediated within SLA"""
        compliant = 0
        total = 0

        for vuln in vulnerabilities:
            if vuln.get('remediated_date'):
                total += 1
                if vuln.get('remediated_within_sla', False):
                    compliant += 1

        if total > 0:
            return (compliant / total) * 100
        return 100.0
```

## Defense-in-Depth Strategy

No single security control is perfect. Defense-in-depth uses multiple layers of security controls:

1. **Perimeter Security**: Firewalls, IDS/IPS
2. **Network Security**: Segmentation, encryption
3. **Application Security**: Input validation, output encoding
4. **Data Security**: Encryption at rest and in transit
5. **Identity and Access**: Strong authentication, least privilege
6. **Monitoring and Response**: Logging, alerting, incident response

## Summary

Understanding vulnerabilities through frameworks like OWASP Top 10, tracking them with CVE databases, and assessing their severity with CVSS provides the foundation for defensive security. Effective vulnerability management requires continuous discovery, assessment, prioritization, and remediation. By implementing systematic processes and maintaining defense-in-depth, organizations can significantly reduce their attack surface and improve their security posture.

## Key Takeaways

- OWASP Top 10 prioritizes the most critical web application security risks
- CVE database provides standardized vulnerability identification
- CVSS scoring enables consistent severity assessment
- Vulnerability management is a continuous process
- Defense-in-depth provides multiple layers of protection
- Metrics drive continuous improvement in security programs

# OAuth 2.0 and OpenID Connect

## Introduction to OAuth 2.0

OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on third-party services without exposing user credentials. It's important to understand that OAuth 2.0 is fundamentally an **authorization** protocol, not an authentication protocol, though it's commonly used as a foundation for authentication through OpenID Connect.

### Common Use Cases

- "Login with Google/Facebook/GitHub" buttons
- Granting mobile apps access to your cloud storage
- Allowing third-party apps to post on your behalf
- Accessing APIs on behalf of users

### Key Terminology

- **Resource Owner**: The user who owns the data
- **Client**: The application requesting access to resources
- **Authorization Server**: Issues access tokens after authenticating the resource owner
- **Resource Server**: Hosts the protected resources (API)
- **Access Token**: Credential used to access protected resources
- **Refresh Token**: Long-lived token used to obtain new access tokens
- **Scope**: Defines the level of access requested

## OAuth 2.0 Authorization Flows

OAuth 2.0 defines several grant types (flows) for different scenarios. The most important for web applications is the Authorization Code flow.

### Authorization Code Flow

This is the most secure flow for web applications and mobile apps. It involves:

1. User clicks "Login with X"
2. Client redirects to authorization server
3. User authenticates and grants permission
4. Authorization server redirects back with authorization code
5. Client exchanges code for access token (server-side)
6. Client uses access token to access resources

```python
import secrets
import hashlib
import base64
from typing import Optional, Dict, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
from urllib.parse import urlencode, parse_qs

@dataclass
class OAuthClient:
    """Represents a registered OAuth client application"""
    client_id: str
    client_secret: str
    redirect_uris: list[str]
    client_name: str
    scopes: list[str]

@dataclass
class AuthorizationCode:
    """Temporary authorization code"""
    code: str
    client_id: str
    redirect_uri: str
    scope: str
    user_id: str
    expires_at: datetime
    code_challenge: Optional[str] = None
    code_challenge_method: Optional[str] = None

@dataclass
class AccessToken:
    """OAuth 2.0 access token"""
    token: str
    token_type: str
    expires_at: datetime
    scope: str
    user_id: str
    client_id: str

@dataclass
class RefreshToken:
    """Long-lived refresh token"""
    token: str
    client_id: str
    user_id: str
    scope: str
    expires_at: datetime

class OAuthAuthorizationServer:
    """
    OAuth 2.0 Authorization Server implementation
    Demonstrates Authorization Code flow with PKCE
    """

    def __init__(self):
        self.clients: Dict[str, OAuthClient] = {}
        self.authorization_codes: Dict[str, AuthorizationCode] = {}
        self.access_tokens: Dict[str, AccessToken] = {}
        self.refresh_tokens: Dict[str, RefreshToken] = {}

    def register_client(
        self,
        client_name: str,
        redirect_uris: list[str],
        scopes: list[str]
    ) -> Tuple[str, str]:
        """
        Register a new OAuth client
        Returns (client_id, client_secret)
        """
        client_id = f"client_{secrets.token_urlsafe(16)}"
        client_secret = secrets.token_urlsafe(32)

        client = OAuthClient(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uris=redirect_uris,
            client_name=client_name,
            scopes=scopes
        )

        self.clients[client_id] = client
        return client_id, client_secret

    def generate_authorization_url(
        self,
        client_id: str,
        redirect_uri: str,
        scope: str,
        state: str,
        code_challenge: Optional[str] = None,
        code_challenge_method: Optional[str] = None
    ) -> str:
        """
        Generate authorization URL for the authorization code flow

        state: CSRF protection token generated by client
        code_challenge: PKCE code challenge (for public clients)
        code_challenge_method: 'S256' or 'plain'
        """
        params = {
            'response_type': 'code',
            'client_id': client_id,
            'redirect_uri': redirect_uri,
            'scope': scope,
            'state': state
        }

        if code_challenge:
            params['code_challenge'] = code_challenge
            params['code_challenge_method'] = code_challenge_method or 'S256'

        base_url = "https://auth.example.com/authorize"
        return f"{base_url}?{urlencode(params)}"

    def authorize(
        self,
        client_id: str,
        redirect_uri: str,
        scope: str,
        user_id: str,
        code_challenge: Optional[str] = None,
        code_challenge_method: Optional[str] = None
    ) -> str:
        """
        Generate authorization code after user grants permission
        """
        # Validate client
        if client_id not in self.clients:
            raise ValueError("Invalid client_id")

        client = self.clients[client_id]

        # Validate redirect_uri
        if redirect_uri not in client.redirect_uris:
            raise ValueError("Invalid redirect_uri")

        # Validate scope
        requested_scopes = set(scope.split())
        allowed_scopes = set(client.scopes)
        if not requested_scopes.issubset(allowed_scopes):
            raise ValueError("Invalid scope")

        # Generate authorization code
        code = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(minutes=10)

        auth_code = AuthorizationCode(
            code=code,
            client_id=client_id,
            redirect_uri=redirect_uri,
            scope=scope,
            user_id=user_id,
            expires_at=expires_at,
            code_challenge=code_challenge,
            code_challenge_method=code_challenge_method
        )

        self.authorization_codes[code] = auth_code
        return code

    def exchange_code_for_token(
        self,
        code: str,
        client_id: str,
        client_secret: str,
        redirect_uri: str,
        code_verifier: Optional[str] = None
    ) -> Tuple[str, str, int]:
        """
        Exchange authorization code for access token
        Returns (access_token, refresh_token, expires_in)
        """
        # Validate authorization code
        if code not in self.authorization_codes:
            raise ValueError("Invalid authorization code")

        auth_code = self.authorization_codes[code]

        # Check expiration
        if datetime.now() > auth_code.expires_at:
            del self.authorization_codes[code]
            raise ValueError("Authorization code expired")

        # Validate client credentials
        if client_id != auth_code.client_id:
            raise ValueError("Client ID mismatch")

        client = self.clients.get(client_id)
        if not client:
            raise ValueError("Invalid client")

        # Verify client secret (for confidential clients)
        if client_secret and client_secret != client.client_secret:
            raise ValueError("Invalid client secret")

        # Validate redirect_uri
        if redirect_uri != auth_code.redirect_uri:
            raise ValueError("Redirect URI mismatch")

        # Verify PKCE if used
        if auth_code.code_challenge:
            if not code_verifier:
                raise ValueError("Code verifier required")

            if not self._verify_pkce(
                code_verifier,
                auth_code.code_challenge,
                auth_code.code_challenge_method
            ):
                raise ValueError("Invalid code verifier")

        # Generate access token
        access_token_str = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(hours=1)

        access_token = AccessToken(
            token=access_token_str,
            token_type="Bearer",
            expires_at=expires_at,
            scope=auth_code.scope,
            user_id=auth_code.user_id,
            client_id=client_id
        )

        self.access_tokens[access_token_str] = access_token

        # Generate refresh token
        refresh_token_str = secrets.token_urlsafe(32)
        refresh_expires_at = datetime.now() + timedelta(days=30)

        refresh_token = RefreshToken(
            token=refresh_token_str,
            client_id=client_id,
            user_id=auth_code.user_id,
            scope=auth_code.scope,
            expires_at=refresh_expires_at
        )

        self.refresh_tokens[refresh_token_str] = refresh_token

        # Delete used authorization code
        del self.authorization_codes[code]

        expires_in = int((expires_at - datetime.now()).total_seconds())
        return access_token_str, refresh_token_str, expires_in

    def verify_access_token(self, token: str) -> Optional[AccessToken]:
        """Verify and return access token if valid"""
        if token not in self.access_tokens:
            return None

        access_token = self.access_tokens[token]

        if datetime.now() > access_token.expires_at:
            del self.access_tokens[token]
            return None

        return access_token

    def refresh_access_token(
        self,
        refresh_token_str: str,
        client_id: str,
        client_secret: str
    ) -> Tuple[str, int]:
        """
        Use refresh token to get new access token
        Returns (new_access_token, expires_in)
        """
        if refresh_token_str not in self.refresh_tokens:
            raise ValueError("Invalid refresh token")

        refresh_token = self.refresh_tokens[refresh_token_str]

        # Validate client
        if client_id != refresh_token.client_id:
            raise ValueError("Client ID mismatch")

        client = self.clients.get(client_id)
        if not client or client.client_secret != client_secret:
            raise ValueError("Invalid client credentials")

        # Check expiration
        if datetime.now() > refresh_token.expires_at:
            del self.refresh_tokens[refresh_token_str]
            raise ValueError("Refresh token expired")

        # Generate new access token
        access_token_str = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(hours=1)

        access_token = AccessToken(
            token=access_token_str,
            token_type="Bearer",
            expires_at=expires_at,
            scope=refresh_token.scope,
            user_id=refresh_token.user_id,
            client_id=client_id
        )

        self.access_tokens[access_token_str] = access_token

        expires_in = int((expires_at - datetime.now()).total_seconds())
        return access_token_str, expires_in

    def _verify_pkce(
        self,
        verifier: str,
        challenge: str,
        method: str
    ) -> bool:
        """Verify PKCE code challenge"""
        if method == 'S256':
            # SHA-256 hash of verifier, base64url encoded
            hash_bytes = hashlib.sha256(verifier.encode('ascii')).digest()
            computed_challenge = base64.urlsafe_b64encode(hash_bytes).decode('ascii').rstrip('=')
            return computed_challenge == challenge
        elif method == 'plain':
            return verifier == challenge
        else:
            return False

# Example usage
if __name__ == "__main__":
    auth_server = OAuthAuthorizationServer()

    # Register client
    client_id, client_secret = auth_server.register_client(
        client_name="My Web App",
        redirect_uris=["https://myapp.com/callback"],
        scopes=["read", "write", "profile"]
    )
    print(f"Client registered: {client_id}")

    # Generate PKCE challenge (for public clients like mobile apps)
    code_verifier = secrets.token_urlsafe(32)
    code_challenge = base64.urlsafe_b64encode(
        hashlib.sha256(code_verifier.encode('ascii')).digest()
    ).decode('ascii').rstrip('=')

    # Step 1: Generate authorization URL
    state = secrets.token_urlsafe(16)
    auth_url = auth_server.generate_authorization_url(
        client_id=client_id,
        redirect_uri="https://myapp.com/callback",
        scope="read profile",
        state=state,
        code_challenge=code_challenge,
        code_challenge_method='S256'
    )
    print(f"\nAuthorization URL: {auth_url}")

    # Step 2: User authorizes, get authorization code
    auth_code = auth_server.authorize(
        client_id=client_id,
        redirect_uri="https://myapp.com/callback",
        scope="read profile",
        user_id="user123",
        code_challenge=code_challenge,
        code_challenge_method='S256'
    )
    print(f"\nAuthorization code: {auth_code}")

    # Step 3: Exchange code for tokens
    access_token, refresh_token, expires_in = auth_server.exchange_code_for_token(
        code=auth_code,
        client_id=client_id,
        client_secret=client_secret,
        redirect_uri="https://myapp.com/callback",
        code_verifier=code_verifier
    )
    print(f"\nAccess token: {access_token}")
    print(f"Refresh token: {refresh_token}")
    print(f"Expires in: {expires_in} seconds")

    # Step 4: Verify access token
    token_info = auth_server.verify_access_token(access_token)
    if token_info:
        print(f"\nToken valid for user: {token_info.user_id}")
        print(f"Scopes: {token_info.scope}")
```

## PKCE (Proof Key for Code Exchange)

PKCE (pronounced "pixy") is an extension to the authorization code flow that prevents authorization code interception attacks. It's essential for public clients like mobile apps and single-page applications.

```python
import hashlib
import base64
import secrets

class PKCEHelper:
    """Helper for generating and verifying PKCE challenges"""

    @staticmethod
    def generate_code_verifier(length: int = 43) -> str:
        """
        Generate code verifier
        Must be 43-128 characters: [A-Z] [a-z] [0-9] - . _ ~
        """
        if length < 43 or length > 128:
            raise ValueError("Length must be between 43 and 128")

        return secrets.token_urlsafe(length)[:length]

    @staticmethod
    def generate_code_challenge(
        code_verifier: str,
        method: str = 'S256'
    ) -> str:
        """
        Generate code challenge from verifier
        method: 'S256' (recommended) or 'plain'
        """
        if method == 'S256':
            hash_bytes = hashlib.sha256(code_verifier.encode('ascii')).digest()
            challenge = base64.urlsafe_b64encode(hash_bytes).decode('ascii')
            return challenge.rstrip('=')
        elif method == 'plain':
            return code_verifier
        else:
            raise ValueError("Method must be 'S256' or 'plain'")

# Example PKCE usage
if __name__ == "__main__":
    pkce = PKCEHelper()

    # Client generates these before authorization request
    verifier = pkce.generate_code_verifier()
    challenge = pkce.generate_code_challenge(verifier, method='S256')

    print(f"Code Verifier: {verifier}")
    print(f"Code Challenge: {challenge}")

    # Client sends challenge in authorization request
    # Later, sends verifier when exchanging code for token
```

## OpenID Connect (OIDC)

OpenID Connect is an identity layer built on top of OAuth 2.0. While OAuth 2.0 handles authorization, OIDC adds authentication, providing information about the authenticated user.

### ID Token Structure

OIDC introduces the ID Token, a JSON Web Token (JWT) that contains user identity information.

```python
import json
import hmac
import hashlib
import base64
from typing import Dict, Any
from datetime import datetime, timedelta

class JWTHandler:
    """
    Simple JWT (JSON Web Token) implementation
    Used for OIDC ID tokens
    """

    def __init__(self, secret_key: str):
        self.secret_key = secret_key.encode('utf-8')

    def encode(
        self,
        payload: Dict[str, Any],
        algorithm: str = 'HS256'
    ) -> str:
        """
        Encode payload as JWT
        """
        # Header
        header = {
            'typ': 'JWT',
            'alg': algorithm
        }

        # Encode header and payload
        header_encoded = self._base64url_encode(
            json.dumps(header).encode('utf-8')
        )
        payload_encoded = self._base64url_encode(
            json.dumps(payload).encode('utf-8')
        )

        # Create signature
        message = f"{header_encoded}.{payload_encoded}"
        signature = self._sign(message, algorithm)

        return f"{message}.{signature}"

    def decode(
        self,
        token: str,
        verify: bool = True
    ) -> Dict[str, Any]:
        """
        Decode and verify JWT
        """
        try:
            header_encoded, payload_encoded, signature = token.split('.')
        except ValueError:
            raise ValueError("Invalid token format")

        if verify:
            # Verify signature
            message = f"{header_encoded}.{payload_encoded}"
            header = json.loads(self._base64url_decode(header_encoded))
            expected_signature = self._sign(message, header['alg'])

            if not hmac.compare_digest(signature, expected_signature):
                raise ValueError("Invalid signature")

        # Decode payload
        payload = json.loads(self._base64url_decode(payload_encoded))

        # Verify expiration
        if verify and 'exp' in payload:
            if datetime.fromtimestamp(payload['exp']) < datetime.now():
                raise ValueError("Token expired")

        return payload

    def _sign(self, message: str, algorithm: str) -> str:
        """Create HMAC signature"""
        if algorithm != 'HS256':
            raise ValueError("Only HS256 supported in this example")

        signature = hmac.new(
            self.secret_key,
            message.encode('utf-8'),
            hashlib.sha256
        ).digest()

        return self._base64url_encode(signature)

    def _base64url_encode(self, data: bytes) -> str:
        """Base64url encoding without padding"""
        return base64.urlsafe_b64encode(data).decode('utf-8').rstrip('=')

    def _base64url_decode(self, data: str) -> bytes:
        """Base64url decoding with padding"""
        padding = 4 - (len(data) % 4)
        data += '=' * padding
        return base64.urlsafe_b64decode(data)

class OpenIDConnectProvider:
    """OpenID Connect Provider implementation"""

    def __init__(self, issuer: str, secret_key: str):
        self.issuer = issuer
        self.jwt_handler = JWTHandler(secret_key)

    def create_id_token(
        self,
        user_id: str,
        client_id: str,
        nonce: Optional[str] = None,
        additional_claims: Optional[Dict] = None
    ) -> str:
        """
        Create OIDC ID token
        """
        now = datetime.now()
        expires_at = now + timedelta(hours=1)

        # Standard OIDC claims
        payload = {
            'iss': self.issuer,  # Issuer
            'sub': user_id,  # Subject (user ID)
            'aud': client_id,  # Audience (client ID)
            'exp': int(expires_at.timestamp()),  # Expiration
            'iat': int(now.timestamp()),  # Issued at
            'auth_time': int(now.timestamp()),  # Authentication time
        }

        # Add nonce for replay protection
        if nonce:
            payload['nonce'] = nonce

        # Add additional claims (email, name, etc.)
        if additional_claims:
            payload.update(additional_claims)

        return self.jwt_handler.encode(payload)

    def verify_id_token(
        self,
        id_token: str,
        client_id: str,
        nonce: Optional[str] = None
    ) -> Dict[str, Any]:
        """Verify and decode ID token"""
        payload = self.jwt_handler.decode(id_token, verify=True)

        # Verify issuer
        if payload.get('iss') != self.issuer:
            raise ValueError("Invalid issuer")

        # Verify audience
        if payload.get('aud') != client_id:
            raise ValueError("Invalid audience")

        # Verify nonce if provided
        if nonce and payload.get('nonce') != nonce:
            raise ValueError("Invalid nonce")

        return payload

# Example usage
if __name__ == "__main__":
    oidc_provider = OpenIDConnectProvider(
        issuer="https://auth.example.com",
        secret_key="your-secret-key-min-32-characters-long"
    )

    # Create ID token
    id_token = oidc_provider.create_id_token(
        user_id="user123",
        client_id="client_abc",
        nonce="random_nonce_value",
        additional_claims={
            'email': 'user@example.com',
            'name': 'John Doe',
            'email_verified': True
        }
    )

    print(f"ID Token: {id_token}\n")

    # Verify ID token
    try:
        claims = oidc_provider.verify_id_token(
            id_token,
            client_id="client_abc",
            nonce="random_nonce_value"
        )
        print("Token verified successfully!")
        print(f"User: {claims['name']} ({claims['email']})")
        print(f"Subject: {claims['sub']}")
    except ValueError as e:
        print(f"Verification failed: {e}")
```

## Security Considerations

### State Parameter

Always use the state parameter to prevent CSRF attacks in the OAuth flow:

```python
def generate_state() -> str:
    """Generate random state for CSRF protection"""
    return secrets.token_urlsafe(32)

# Store state in session before redirecting
session['oauth_state'] = generate_state()

# Verify state when receiving callback
if request.args.get('state') != session.get('oauth_state'):
    raise ValueError("Invalid state - possible CSRF attack")
```

### Token Storage

- Store tokens securely (encrypted at rest)
- Use httpOnly cookies for web applications
- Never expose tokens in URLs or logs
- Implement token rotation

### Scope Limitations

Always request minimal scopes needed:

```python
# Good: Request only what you need
scope = "read:user email"

# Bad: Request excessive permissions
scope = "read write delete admin"
```

## Conclusion

OAuth 2.0 and OpenID Connect provide robust frameworks for authorization and authentication. Understanding the authorization code flow with PKCE, proper token handling, and JWT structure is essential for implementing secure third-party authentication. Always use established libraries in production and follow security best practices including state validation, PKCE for public clients, and minimal scope requests.

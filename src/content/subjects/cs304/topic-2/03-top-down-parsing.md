# Top-Down Parsing

Top-down parsing is a syntax analysis strategy that constructs parse trees from the root (start symbol) downward to the leaves (input tokens). This approach mirrors the intuitive way humans might analyze sentence structure: starting with high-level constructs and decomposing them into smaller components. Top-down parsers attempt to find a leftmost derivation for the input string.

## Fundamental Concept

A top-down parser begins with the start symbol and tries to transform it into the input string by repeatedly applying production rules. At each step, the parser must decide which production to use for the current non-terminal. This decision is guided by looking ahead at the input tokens.

The parser maintains a working string that starts as the start symbol and evolves toward the input. At any point, the working string contains a mix of terminals and non-terminals. The parser processes this string from left to right, matching terminals with input and expanding non-terminals with productions.

## Recursive Descent Parsing

Recursive descent is the most straightforward implementation of top-down parsing. It uses a set of recursive procedures, one for each non-terminal in the grammar. Each procedure recognizes the language generated by its corresponding non-terminal.

### Basic Structure

For a non-terminal A with productions:

```
A → α₁ | α₂ | ... | αₙ
```

The procedure for A has this structure:

```
procedure A():
    if next input suggests α₁:
        process α₁
    else if next input suggests α₂:
        process α₂
    ...
    else if next input suggests αₙ:
        process αₙ
    else:
        report error
```

Processing a production body involves:
- If the symbol is a terminal, match it with the current input token
- If the symbol is a non-terminal, call its procedure recursively

### Example: Expression Grammar

Consider a simple expression grammar:

```
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε
F → ( E ) | id
```

The recursive descent parser consists of procedures for E, E', T, T', and F:

```python
def parse_E():
    parse_T()
    parse_E_prime()

def parse_E_prime():
    if current_token == '+':
        match('+')
        parse_T()
        parse_E_prime()
    # else: ε production, do nothing

def parse_T():
    parse_F()
    parse_T_prime()

def parse_T_prime():
    if current_token == '*':
        match('*')
        parse_F()
        parse_T_prime()
    # else: ε production, do nothing

def parse_F():
    if current_token == '(':
        match('(')
        parse_E()
        match(')')
    elif current_token == 'id':
        match('id')
    else:
        error("Expected '(' or id")

def match(expected):
    if current_token == expected:
        advance_to_next_token()
    else:
        error(f"Expected {expected}")
```

For input `id + id * id`, the call sequence is:

```
parse_E()
  parse_T()
    parse_F() → matches 'id'
    parse_T_prime() → returns (ε)
  parse_E_prime()
    matches '+'
    parse_T()
      parse_F() → matches 'id'
      parse_T_prime()
        matches '*'
        parse_F() → matches 'id'
        parse_T_prime() → returns (ε)
    parse_E_prime() → returns (ε)
```

### Advantages of Recursive Descent

Recursive descent parsing offers several benefits:

**Simplicity**: The implementation directly mirrors the grammar structure, making it easy to understand and maintain.

**Error handling**: Custom error messages and recovery strategies can be inserted at any point.

**Flexibility**: The parser can perform semantic actions (like building AST nodes) alongside syntax recognition.

**No special tools**: Unlike table-driven parsers, recursive descent requires no parser generator, just hand-written code.

**Debugging**: Standard debugging tools work naturally with the procedural code.

## Predictive Parsing

Predictive parsing is a more formal top-down approach that makes parsing decisions without backtracking. It uses a lookahead symbol to predict which production to apply. The key requirement is that the parser can determine the correct production by examining only the next k input tokens (typically k=1).

### LL(k) Grammars

A grammar is LL(k) if it can be parsed by:
- Reading input from Left to right
- Producing a Leftmost derivation
- Using at most k tokens of lookahead

LL(1) grammars, which require only one token of lookahead, are particularly important because they enable efficient parsing.

### Requirements for Predictive Parsing

For predictive parsing to work without backtracking, the grammar must satisfy certain conditions:

**No left recursion**: Productions like `A → A α` cause infinite recursion in top-down parsers. Left recursion must be eliminated.

**Left-factored**: When multiple productions share a common prefix, the grammar must be refactored to defer the decision until distinguishing symbols appear.

### Eliminating Left Recursion

Left-recursive productions have the form:

```
A → A α | β
```

This can be transformed to:

```
A → β A'
A' → α A' | ε
```

For example:

```
E → E + T | T
```

Becomes:

```
E → T E'
E' → + T E' | ε
```

This transformation maintains the language while enabling top-down parsing.

### Left Factoring

When productions share a common prefix:

```
A → α β₁ | α β₂
```

The grammar should be refactored:

```
A → α A'
A' → β₁ | β₂
```

For example:

```
stmt → if ( expr ) stmt else stmt
     | if ( expr ) stmt
```

Becomes:

```
stmt → if ( expr ) stmt stmt'
stmt' → else stmt | ε
```

This defers the decision about which production to use until after processing the common prefix.

## Building Parse Trees

During parsing, the parser can build a parse tree or AST by creating nodes as productions are applied:

```python
class Node:
    def __init__(self, label, children=None):
        self.label = label
        self.children = children or []

def parse_E():
    node = Node('E')
    node.children.append(parse_T())
    node.children.append(parse_E_prime())
    return node

def parse_F():
    if current_token == 'id':
        node = Node('F')
        node.children.append(Node(current_token))
        match('id')
        return node
    # ... other cases
```

This approach constructs the parse tree during the parsing process.

## Error Recovery

Top-down parsers can implement sophisticated error recovery:

**Panic mode**: On error, discard input tokens until a synchronizing token (like semicolon or closing brace) is found.

**Phrase-level recovery**: Make local corrections, like inserting missing tokens or replacing incorrect tokens.

**Error productions**: Add productions to the grammar that explicitly handle common errors.

```python
def parse_F():
    if current_token == '(':
        match('(')
        parse_E()
        if current_token != ')':
            error("Missing closing parenthesis")
            # Recovery: assume ')' and continue
        else:
            match(')')
    # ... other cases
```

## Limitations

Top-down parsing has inherent limitations:

**Left recursion**: Cannot handle left-recursive grammars without transformation.

**Grammar restrictions**: Not all context-free grammars can be parsed top-down without backtracking.

**Efficiency**: Naive recursive descent with backtracking can be exponential in worst cases.

Despite these limitations, top-down parsing remains popular for:
- Hand-written parsers in compilers
- Recursive descent parsers for domain-specific languages
- Parser combinators in functional programming

## Key Takeaways

- Top-down parsing constructs parse trees from root to leaves, finding leftmost derivations
- Recursive descent uses one procedure per non-terminal, directly encoding grammar structure
- Predictive parsing makes decisions without backtracking using lookahead tokens
- LL(k) grammars can be parsed with k tokens of lookahead; LL(1) is most common
- Left recursion must be eliminated for top-down parsing to avoid infinite recursion
- Left factoring resolves ambiguity when productions share common prefixes
- Recursive descent is simple to implement and allows flexible error handling
- Parse trees or ASTs can be constructed during the parsing process
- Top-down parsers support sophisticated error recovery strategies
- Despite limitations, top-down parsing is widely used for hand-written and generated parsers

# Memory Management Basics

Memory management is a critical operating system function. This subtopic covers memory hierarchy, address binding, and logical vs physical addresses.

## Memory Hierarchy

Computer systems use a hierarchy of memory types:

```
            ┌─────────────┐
            │  Registers  │  ← Fastest, smallest
            └─────────────┘
                  │
            ┌─────────────┐
            │   Cache     │  ← L1, L2, L3
            └─────────────┘
                  │
            ┌─────────────┐
            │    RAM      │  ← Main memory
            └─────────────┘
                  │
            ┌─────────────┐
            │   SSD/HDD   │  ← Secondary storage
            └─────────────┘
                  │
            ┌─────────────┐
            │   Tape      │  ← Archival (slowest)
            └─────────────┘

Speed:    ~1ns    ~10ns    ~100ns    ~10μs-10ms
Size:     ~KB     ~MB      ~GB       ~TB
```

## Why Memory Management?

### The Challenge

- Programs need memory to execute
- Multiple programs compete for limited RAM
- Programs shouldn't interfere with each other
- Programs shouldn't access OS memory

### Goals

1. **Allocation**: Assign memory to processes efficiently
2. **Protection**: Isolate processes from each other
3. **Sharing**: Allow controlled sharing when needed
4. **Virtualization**: Provide illusion of large, contiguous memory

## Address Binding

Programs reference memory addresses. When are these addresses determined?

### Compile Time

Address known at compile time (absolute code):

```c
// Old DOS programs
// Compiled to run at specific address
int* ptr = (int*)0x5000;  // Fixed address

// Must recompile to change location
```

### Load Time

Address determined when program loaded:

```c
// Relocatable code
// Addresses adjusted by loader

// Object file: offset 0x100
// Loaded at: 0x8000
// Runtime address: 0x8100
```

### Execution Time (Runtime)

Address bound during execution:

```c
// Modern systems use this
// Process can be moved in memory during execution
// Requires hardware support (MMU)
```

```
┌──────────────────────────────────────────────────────────────┐
│           Address Binding Timeline                           │
│                                                              │
│ Source    →  Compiler  →  Object    →  Linker  →  Executable │
│ Code         (symbols)     Module       (merge)     (.exe)   │
│                               ↓                        │     │
│                           Relocatable              Load │     │
│                           Addresses                Time │     │
│                                                        ↓     │
│                                                     Loader   │
│                                                        │     │
│                                                   Execution  │
│                                                   Time       │
│                                                   Binding    │
└──────────────────────────────────────────────────────────────┘
```

## Logical vs Physical Addresses

### Logical Address (Virtual Address)

Generated by the CPU during execution:
- What the program "sees"
- Starts at 0 for each process
- Process's view of its memory

### Physical Address

Actual address in RAM:
- What appears on memory bus
- Where data actually resides
- Hardware uses this address

```
Process view:           Physical memory:
┌───────────────┐       ┌───────────────┐
│ 0x0000: code  │       │ 0x10000: OS   │
│ 0x1000: data  │  →→→  │ 0x20000: P1   │
│ 0x2000: heap  │  MMU  │ 0x30000: P2   │
│ 0x3000: stack │       │ 0x40000: P1   │
└───────────────┘       └───────────────┘
```

### Memory Management Unit (MMU)

Hardware that translates logical to physical addresses:

```c
// Conceptual MMU operation
physical_address = translate(logical_address);

// Simple relocation register
physical_address = logical_address + relocation_register;
```

## Address Space

### Logical Address Space

Set of all logical addresses generated by a process:

```
Process Address Space (32-bit):
┌─────────────────┐ 0xFFFFFFFF
│     Stack       │ ↓ grows down
├─────────────────┤
│       ↓         │
│   (free space)  │
│       ↑         │
├─────────────────┤
│     Heap        │ ↑ grows up
├─────────────────┤
│  Uninitialized  │
│  Data (BSS)     │
├─────────────────┤
│  Initialized    │
│  Data           │
├─────────────────┤
│     Code        │
│    (Text)       │
└─────────────────┘ 0x00000000
```

### Physical Address Space

Set of all physical addresses in the system:

```
Physical Memory (4GB system):
┌─────────────────┐ 0xFFFFFFFF
│   Device I/O    │
├─────────────────┤
│   Free space    │
├─────────────────┤
│   Process 3     │
├─────────────────┤
│   Process 2     │
├─────────────────┤
│   Process 1     │
├─────────────────┤
│ Operating System│
└─────────────────┘ 0x00000000
```

## Base and Limit Registers

Simple memory protection scheme:

```
Process P:
┌─────────────────────────────────────────────┐
│  base = 0x20000                             │
│  limit = 0x10000 (64KB)                     │
│                                             │
│  Valid addresses: 0x20000 to 0x2FFFF        │
└─────────────────────────────────────────────┘

CPU generates address 0x5000:
  Physical = base + logical = 0x20000 + 0x5000 = 0x25000 ✓

CPU generates address 0x15000:
  0x15000 > limit (0x10000)
  → TRAP: Memory violation!
```

### Implementation

```c
// Hardware check on every memory access
void check_address(uint32_t logical_addr) {
    if (logical_addr >= limit_register) {
        trap(MEMORY_VIOLATION);
    }

    uint32_t physical = logical_addr + base_register;
    // Proceed with memory access
}
```

## Memory Protection

### Goals

1. **User processes cannot access OS memory**
2. **Processes cannot access each other's memory**
3. **OS can access all memory**

### Implementation

```c
// Mode bit: 0 = kernel, 1 = user

void memory_access(uint32_t addr, int mode) {
    if (mode == USER_MODE) {
        // Check bounds
        if (addr < current_process->base ||
            addr >= current_process->base + current_process->limit) {
            trap(SEGMENTATION_FAULT);
        }
    }
    // Kernel mode can access anything
}
```

### Context Switch

On process switch, update protection registers:

```c
void context_switch(Process* new_process) {
    // Save old process state...

    // Update memory protection
    set_base_register(new_process->base);
    set_limit_register(new_process->limit);

    // Restore new process state...
}
```

## Memory Allocation Tracking

### Memory Map

```c
typedef struct {
    uint32_t base;
    uint32_t size;
    int pid;        // -1 = free, >=0 = process ID
    bool allocated;
} MemoryBlock;

MemoryBlock memory_map[MAX_BLOCKS];

void print_memory_map() {
    printf("Memory Map:\n");
    for (int i = 0; i < num_blocks; i++) {
        printf("  %08x - %08x: %s",
               memory_map[i].base,
               memory_map[i].base + memory_map[i].size,
               memory_map[i].allocated ? "USED" : "FREE");
        if (memory_map[i].allocated) {
            printf(" (PID %d)", memory_map[i].pid);
        }
        printf("\n");
    }
}
```

### Linux Memory Info

```bash
# View memory map of a process
cat /proc/<pid>/maps

# Example output:
# 00400000-00452000 r-xp 00000000 08:01 393449 /bin/bash
# 00651000-00652000 r--p 00051000 08:01 393449 /bin/bash
# 00652000-0065b000 rw-p 00052000 08:01 393449 /bin/bash
# 7f8a4c000000-7f8a4c021000 rw-p 00000000 00:00 0
```

## Summary

Memory management fundamentals:
- Memory hierarchy trades speed for capacity
- Address binding can occur at compile, load, or runtime
- Logical addresses are what programs use
- Physical addresses are actual RAM locations
- MMU translates between address spaces
- Base and limit registers provide simple protection
- OS must isolate processes from each other
- Context switches update memory protection
- Modern systems use sophisticated virtual memory
